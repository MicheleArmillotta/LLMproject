[
  {
    "function_name": "exit_hfsplus_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
    "lines": "686-697",
    "snippet": "static void __exit exit_hfsplus_fs(void)\n{\n\tunregister_filesystem(&hfsplus_fs_type);\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\thfsplus_destroy_attr_tree_cache();\n\tkmem_cache_destroy(hfsplus_inode_cachep);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *hfsplus_inode_cachep;",
      "static struct file_system_type hfsplus_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"hfsplus\",\n\t.mount\t\t= hfsplus_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "hfsplus_inode_cachep"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_destroy_attr_tree_cache",
          "args": [],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_destroy_attr_tree_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "29-32",
          "snippet": "void hfsplus_destroy_attr_tree_cache(void)\n{\n\tkmem_cache_destroy(hfsplus_attr_tree_cachep);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hfsplus_attr_tree_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct kmem_cache *hfsplus_attr_tree_cachep;\n\nvoid hfsplus_destroy_attr_tree_cache(void)\n{\n\tkmem_cache_destroy(hfsplus_attr_tree_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&hfsplus_fs_type"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *hfsplus_inode_cachep;\nstatic struct file_system_type hfsplus_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"hfsplus\",\n\t.mount\t\t= hfsplus_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic void __exit exit_hfsplus_fs(void)\n{\n\tunregister_filesystem(&hfsplus_fs_type);\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\thfsplus_destroy_attr_tree_cache();\n\tkmem_cache_destroy(hfsplus_inode_cachep);\n}"
  },
  {
    "function_name": "init_hfsplus_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
    "lines": "660-684",
    "snippet": "static int __init init_hfsplus_fs(void)\n{\n\tint err;\n\n\thfsplus_inode_cachep = kmem_cache_create(\"hfsplus_icache\",\n\t\tHFSPLUS_INODE_SIZE, 0, SLAB_HWCACHE_ALIGN,\n\t\thfsplus_init_once);\n\tif (!hfsplus_inode_cachep)\n\t\treturn -ENOMEM;\n\terr = hfsplus_create_attr_tree_cache();\n\tif (err)\n\t\tgoto destroy_inode_cache;\n\terr = register_filesystem(&hfsplus_fs_type);\n\tif (err)\n\t\tgoto destroy_attr_tree_cache;\n\treturn 0;\n\ndestroy_attr_tree_cache:\n\thfsplus_destroy_attr_tree_cache();\n\ndestroy_inode_cache:\n\tkmem_cache_destroy(hfsplus_inode_cachep);\n\n\treturn err;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HFSPLUS_INODE_SIZE\tsizeof(struct hfsplus_inode_info)"
    ],
    "globals_used": [
      "static struct kmem_cache *hfsplus_inode_cachep;",
      "static struct file_system_type hfsplus_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"hfsplus\",\n\t.mount\t\t= hfsplus_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "hfsplus_inode_cachep"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_destroy_attr_tree_cache",
          "args": [],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_destroy_attr_tree_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "29-32",
          "snippet": "void hfsplus_destroy_attr_tree_cache(void)\n{\n\tkmem_cache_destroy(hfsplus_attr_tree_cachep);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hfsplus_attr_tree_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct kmem_cache *hfsplus_attr_tree_cachep;\n\nvoid hfsplus_destroy_attr_tree_cache(void)\n{\n\tkmem_cache_destroy(hfsplus_attr_tree_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&hfsplus_fs_type"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_create_attr_tree_cache",
          "args": [],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_create_attr_tree_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "14-27",
          "snippet": "int __init hfsplus_create_attr_tree_cache(void)\n{\n\tif (hfsplus_attr_tree_cachep)\n\t\treturn -EEXIST;\n\n\thfsplus_attr_tree_cachep =\n\t\tkmem_cache_create(\"hfsplus_attr_cache\",\n\t\t\tsizeof(hfsplus_attr_entry), 0,\n\t\t\tSLAB_HWCACHE_ALIGN, NULL);\n\tif (!hfsplus_attr_tree_cachep)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hfsplus_attr_tree_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct kmem_cache *hfsplus_attr_tree_cachep;\n\nint __init hfsplus_create_attr_tree_cache(void)\n{\n\tif (hfsplus_attr_tree_cachep)\n\t\treturn -EEXIST;\n\n\thfsplus_attr_tree_cachep =\n\t\tkmem_cache_create(\"hfsplus_attr_cache\",\n\t\t\tsizeof(hfsplus_attr_entry), 0,\n\t\t\tSLAB_HWCACHE_ALIGN, NULL);\n\tif (!hfsplus_attr_tree_cachep)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"hfsplus_icache\"",
            "HFSPLUS_INODE_SIZE",
            "0",
            "SLAB_HWCACHE_ALIGN",
            "hfsplus_init_once"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define HFSPLUS_INODE_SIZE\tsizeof(struct hfsplus_inode_info)\n\nstatic struct kmem_cache *hfsplus_inode_cachep;\nstatic struct file_system_type hfsplus_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"hfsplus\",\n\t.mount\t\t= hfsplus_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic int __init init_hfsplus_fs(void)\n{\n\tint err;\n\n\thfsplus_inode_cachep = kmem_cache_create(\"hfsplus_icache\",\n\t\tHFSPLUS_INODE_SIZE, 0, SLAB_HWCACHE_ALIGN,\n\t\thfsplus_init_once);\n\tif (!hfsplus_inode_cachep)\n\t\treturn -ENOMEM;\n\terr = hfsplus_create_attr_tree_cache();\n\tif (err)\n\t\tgoto destroy_inode_cache;\n\terr = register_filesystem(&hfsplus_fs_type);\n\tif (err)\n\t\tgoto destroy_attr_tree_cache;\n\treturn 0;\n\ndestroy_attr_tree_cache:\n\thfsplus_destroy_attr_tree_cache();\n\ndestroy_inode_cache:\n\tkmem_cache_destroy(hfsplus_inode_cachep);\n\n\treturn err;\n}"
  },
  {
    "function_name": "hfsplus_init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
    "lines": "653-658",
    "snippet": "static void hfsplus_init_once(void *p)\n{\n\tstruct hfsplus_inode_info *i = p;\n\n\tinode_init_once(&i->vfs_inode);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&i->vfs_inode"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1725-1755",
          "snippet": "static void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_remount(struct super_block *sb, int *flags, char *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\n\nstatic void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void hfsplus_init_once(void *p)\n{\n\tstruct hfsplus_inode_info *i = p;\n\n\tinode_init_once(&i->vfs_inode);\n}"
  },
  {
    "function_name": "hfsplus_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
    "lines": "638-642",
    "snippet": "static struct dentry *hfsplus_mount(struct file_system_type *fs_type,\n\t\t\t  int flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, hfsplus_fill_super);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "hfsplus_fill_super"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct dentry *hfsplus_mount(struct file_system_type *fs_type,\n\t\t\t  int flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, hfsplus_fill_super);\n}"
  },
  {
    "function_name": "hfsplus_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
    "lines": "631-634",
    "snippet": "static void hfsplus_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, hfsplus_i_callback);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void hfsplus_destroy_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "hfsplus_i_callback"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void hfsplus_destroy_inode(struct inode *inode);\n\nstatic void hfsplus_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, hfsplus_i_callback);\n}"
  },
  {
    "function_name": "hfsplus_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
    "lines": "624-629",
    "snippet": "static void hfsplus_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\n\tkmem_cache_free(hfsplus_inode_cachep, HFSPLUS_I(inode));\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void hfsplus_destroy_inode(struct inode *inode);",
      "static struct kmem_cache *hfsplus_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "hfsplus_inode_cachep",
            "HFSPLUS_I(inode)"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void hfsplus_destroy_inode(struct inode *inode);\nstatic struct kmem_cache *hfsplus_inode_cachep;\n\nstatic void hfsplus_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\n\tkmem_cache_free(hfsplus_inode_cachep, HFSPLUS_I(inode));\n}"
  },
  {
    "function_name": "hfsplus_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
    "lines": "616-622",
    "snippet": "static struct inode *hfsplus_alloc_inode(struct super_block *sb)\n{\n\tstruct hfsplus_inode_info *i;\n\n\ti = kmem_cache_alloc(hfsplus_inode_cachep, GFP_KERNEL);\n\treturn i ? &i->vfs_inode : NULL;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *hfsplus_alloc_inode(struct super_block *sb);",
      "static void hfsplus_destroy_inode(struct inode *inode);",
      "static struct kmem_cache *hfsplus_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "hfsplus_inode_cachep",
            "GFP_KERNEL"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct inode *hfsplus_alloc_inode(struct super_block *sb);\nstatic void hfsplus_destroy_inode(struct inode *inode);\nstatic struct kmem_cache *hfsplus_inode_cachep;\n\nstatic struct inode *hfsplus_alloc_inode(struct super_block *sb)\n{\n\tstruct hfsplus_inode_info *i;\n\n\ti = kmem_cache_alloc(hfsplus_inode_cachep, GFP_KERNEL);\n\treturn i ? &i->vfs_inode : NULL;\n}"
  },
  {
    "function_name": "hfsplus_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
    "lines": "370-608",
    "snippet": "static int hfsplus_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct hfsplus_vh *vhdr;\n\tstruct hfsplus_sb_info *sbi;\n\thfsplus_cat_entry entry;\n\tstruct hfs_find_data fd;\n\tstruct inode *root, *inode;\n\tstruct qstr str;\n\tstruct nls_table *nls = NULL;\n\tu64 last_fs_block, last_fs_page;\n\tint err;\n\n\terr = -ENOMEM;\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\tgoto out;\n\n\tsb->s_fs_info = sbi;\n\tmutex_init(&sbi->alloc_mutex);\n\tmutex_init(&sbi->vh_mutex);\n\tspin_lock_init(&sbi->work_lock);\n\tINIT_DELAYED_WORK(&sbi->sync_work, delayed_sync_fs);\n\thfsplus_fill_defaults(sbi);\n\n\terr = -EINVAL;\n\tif (!hfsplus_parse_options(data, sbi)) {\n\t\tpr_err(\"unable to parse mount options\\n\");\n\t\tgoto out_unload_nls;\n\t}\n\n\t/* temporarily use utf8 to correctly find the hidden dir below */\n\tnls = sbi->nls;\n\tsbi->nls = load_nls(\"utf8\");\n\tif (!sbi->nls) {\n\t\tpr_err(\"unable to load nls for utf8\\n\");\n\t\tgoto out_unload_nls;\n\t}\n\n\t/* Grab the volume header */\n\tif (hfsplus_read_wrapper(sb)) {\n\t\tif (!silent)\n\t\t\tpr_warn(\"unable to find HFS+ superblock\\n\");\n\t\tgoto out_unload_nls;\n\t}\n\tvhdr = sbi->s_vhdr;\n\n\t/* Copy parts of the volume header into the superblock */\n\tsb->s_magic = HFSPLUS_VOLHEAD_SIG;\n\tif (be16_to_cpu(vhdr->version) < HFSPLUS_MIN_VERSION ||\n\t    be16_to_cpu(vhdr->version) > HFSPLUS_CURRENT_VERSION) {\n\t\tpr_err(\"wrong filesystem version\\n\");\n\t\tgoto out_free_vhdr;\n\t}\n\tsbi->total_blocks = be32_to_cpu(vhdr->total_blocks);\n\tsbi->free_blocks = be32_to_cpu(vhdr->free_blocks);\n\tsbi->next_cnid = be32_to_cpu(vhdr->next_cnid);\n\tsbi->file_count = be32_to_cpu(vhdr->file_count);\n\tsbi->folder_count = be32_to_cpu(vhdr->folder_count);\n\tsbi->data_clump_blocks =\n\t\tbe32_to_cpu(vhdr->data_clump_sz) >> sbi->alloc_blksz_shift;\n\tif (!sbi->data_clump_blocks)\n\t\tsbi->data_clump_blocks = 1;\n\tsbi->rsrc_clump_blocks =\n\t\tbe32_to_cpu(vhdr->rsrc_clump_sz) >> sbi->alloc_blksz_shift;\n\tif (!sbi->rsrc_clump_blocks)\n\t\tsbi->rsrc_clump_blocks = 1;\n\n\terr = -EFBIG;\n\tlast_fs_block = sbi->total_blocks - 1;\n\tlast_fs_page = (last_fs_block << sbi->alloc_blksz_shift) >>\n\t\t\tPAGE_CACHE_SHIFT;\n\n\tif ((last_fs_block > (sector_t)(~0ULL) >> (sbi->alloc_blksz_shift - 9)) ||\n\t    (last_fs_page > (pgoff_t)(~0ULL))) {\n\t\tpr_err(\"filesystem size too large\\n\");\n\t\tgoto out_free_vhdr;\n\t}\n\n\t/* Set up operations so we can load metadata */\n\tsb->s_op = &hfsplus_sops;\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\n\tif (!(vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_UNMNT))) {\n\t\tpr_warn(\"Filesystem was not cleanly unmounted, running fsck.hfsplus is recommended.  mounting read-only.\\n\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t} else if (test_and_clear_bit(HFSPLUS_SB_FORCE, &sbi->flags)) {\n\t\t/* nothing */\n\t} else if (vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_SOFTLOCK)) {\n\t\tpr_warn(\"Filesystem is marked locked, mounting read-only.\\n\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t} else if ((vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_JOURNALED)) &&\n\t\t\t!(sb->s_flags & MS_RDONLY)) {\n\t\tpr_warn(\"write access to a journaled filesystem is not supported, use the force option at your own risk, mounting read-only.\\n\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\n\terr = -EINVAL;\n\n\t/* Load metadata objects (B*Trees) */\n\tsbi->ext_tree = hfs_btree_open(sb, HFSPLUS_EXT_CNID);\n\tif (!sbi->ext_tree) {\n\t\tpr_err(\"failed to load extents file\\n\");\n\t\tgoto out_free_vhdr;\n\t}\n\tsbi->cat_tree = hfs_btree_open(sb, HFSPLUS_CAT_CNID);\n\tif (!sbi->cat_tree) {\n\t\tpr_err(\"failed to load catalog file\\n\");\n\t\tgoto out_close_ext_tree;\n\t}\n\tatomic_set(&sbi->attr_tree_state, HFSPLUS_EMPTY_ATTR_TREE);\n\tif (vhdr->attr_file.total_blocks != 0) {\n\t\tsbi->attr_tree = hfs_btree_open(sb, HFSPLUS_ATTR_CNID);\n\t\tif (!sbi->attr_tree) {\n\t\t\tpr_err(\"failed to load attributes file\\n\");\n\t\t\tgoto out_close_cat_tree;\n\t\t}\n\t\tatomic_set(&sbi->attr_tree_state, HFSPLUS_VALID_ATTR_TREE);\n\t}\n\tsb->s_xattr = hfsplus_xattr_handlers;\n\n\tinode = hfsplus_iget(sb, HFSPLUS_ALLOC_CNID);\n\tif (IS_ERR(inode)) {\n\t\tpr_err(\"failed to load allocation file\\n\");\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_close_attr_tree;\n\t}\n\tsbi->alloc_file = inode;\n\n\t/* Load the root directory */\n\troot = hfsplus_iget(sb, HFSPLUS_ROOT_CNID);\n\tif (IS_ERR(root)) {\n\t\tpr_err(\"failed to load root directory\\n\");\n\t\terr = PTR_ERR(root);\n\t\tgoto out_put_alloc_file;\n\t}\n\n\tsb->s_d_op = &hfsplus_dentry_operations;\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_alloc_file;\n\t}\n\n\tstr.len = sizeof(HFSP_HIDDENDIR_NAME) - 1;\n\tstr.name = HFSP_HIDDENDIR_NAME;\n\terr = hfs_find_init(sbi->cat_tree, &fd);\n\tif (err)\n\t\tgoto out_put_root;\n\terr = hfsplus_cat_build_key(sb, fd.search_key, HFSPLUS_ROOT_CNID, &str);\n\tif (unlikely(err < 0))\n\t\tgoto out_put_root;\n\tif (!hfs_brec_read(&fd, &entry, sizeof(entry))) {\n\t\thfs_find_exit(&fd);\n\t\tif (entry.type != cpu_to_be16(HFSPLUS_FOLDER))\n\t\t\tgoto out_put_root;\n\t\tinode = hfsplus_iget(sb, be32_to_cpu(entry.folder.id));\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tgoto out_put_root;\n\t\t}\n\t\tsbi->hidden_dir = inode;\n\t} else\n\t\thfs_find_exit(&fd);\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t/*\n\t\t * H+LX == hfsplusutils, H+Lx == this driver, H+lx is unused\n\t\t * all three are registered with Apple for our use\n\t\t */\n\t\tvhdr->last_mount_vers = cpu_to_be32(HFSP_MOUNT_VERSION);\n\t\tvhdr->modify_date = hfsp_now2mt();\n\t\tbe32_add_cpu(&vhdr->write_count, 1);\n\t\tvhdr->attributes &= cpu_to_be32(~HFSPLUS_VOL_UNMNT);\n\t\tvhdr->attributes |= cpu_to_be32(HFSPLUS_VOL_INCNSTNT);\n\t\thfsplus_sync_fs(sb, 1);\n\n\t\tif (!sbi->hidden_dir) {\n\t\t\tmutex_lock(&sbi->vh_mutex);\n\t\t\tsbi->hidden_dir = hfsplus_new_inode(sb, S_IFDIR);\n\t\t\tif (!sbi->hidden_dir) {\n\t\t\t\tmutex_unlock(&sbi->vh_mutex);\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out_put_root;\n\t\t\t}\n\t\t\terr = hfsplus_create_cat(sbi->hidden_dir->i_ino, root,\n\t\t\t\t\t\t &str, sbi->hidden_dir);\n\t\t\tif (err) {\n\t\t\t\tmutex_unlock(&sbi->vh_mutex);\n\t\t\t\tgoto out_put_hidden_dir;\n\t\t\t}\n\n\t\t\terr = hfsplus_init_inode_security(sbi->hidden_dir,\n\t\t\t\t\t\t\t\troot, &str);\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\terr = 0; /* Operation is not supported. */\n\t\t\telse if (err) {\n\t\t\t\t/*\n\t\t\t\t * Try to delete anyway without\n\t\t\t\t * error analysis.\n\t\t\t\t */\n\t\t\t\thfsplus_delete_cat(sbi->hidden_dir->i_ino,\n\t\t\t\t\t\t\troot, &str);\n\t\t\t\tmutex_unlock(&sbi->vh_mutex);\n\t\t\t\tgoto out_put_hidden_dir;\n\t\t\t}\n\n\t\t\tmutex_unlock(&sbi->vh_mutex);\n\t\t\thfsplus_mark_inode_dirty(sbi->hidden_dir,\n\t\t\t\t\t\t HFSPLUS_I_CAT_DIRTY);\n\t\t}\n\t}\n\n\tunload_nls(sbi->nls);\n\tsbi->nls = nls;\n\treturn 0;\n\nout_put_hidden_dir:\n\tiput(sbi->hidden_dir);\nout_put_root:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nout_put_alloc_file:\n\tiput(sbi->alloc_file);\nout_close_attr_tree:\n\thfs_btree_close(sbi->attr_tree);\nout_close_cat_tree:\n\thfs_btree_close(sbi->cat_tree);\nout_close_ext_tree:\n\thfs_btree_close(sbi->ext_tree);\nout_free_vhdr:\n\tkfree(sbi->s_vhdr_buf);\n\tkfree(sbi->s_backup_vhdr_buf);\nout_unload_nls:\n\tunload_nls(sbi->nls);\n\tunload_nls(nls);\n\tkfree(sbi);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *hfsplus_alloc_inode(struct super_block *sb);",
      "static void hfsplus_destroy_inode(struct inode *inode);",
      "static const struct super_operations hfsplus_sops = {\n\t.alloc_inode\t= hfsplus_alloc_inode,\n\t.destroy_inode\t= hfsplus_destroy_inode,\n\t.write_inode\t= hfsplus_write_inode,\n\t.evict_inode\t= hfsplus_evict_inode,\n\t.put_super\t= hfsplus_put_super,\n\t.sync_fs\t= hfsplus_sync_fs,\n\t.statfs\t\t= hfsplus_statfs,\n\t.remount_fs\t= hfsplus_remount,\n\t.show_options\t= hfsplus_show_options,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unload_nls",
          "args": [
            "nls"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "unload_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "296-300",
          "snippet": "void unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_backup_vhdr_buf"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_vhdr_buf"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_btree_close",
          "args": [
            "sbi->ext_tree"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_btree_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/btree.c",
          "lines": "257-279",
          "snippet": "void hfs_btree_close(struct hfs_btree *tree)\n{\n\tstruct hfs_bnode *node;\n\tint i;\n\n\tif (!tree)\n\t\treturn;\n\n\tfor (i = 0; i < NODE_HASH_SIZE; i++) {\n\t\twhile ((node = tree->node_hash[i])) {\n\t\t\ttree->node_hash[i] = node->next_hash;\n\t\t\tif (atomic_read(&node->refcnt))\n\t\t\t\tpr_crit(\"node %d:%d \"\n\t\t\t\t\t\t\"still has %d user(s)!\\n\",\n\t\t\t\t\tnode->tree->cnid, node->this,\n\t\t\t\t\tatomic_read(&node->refcnt));\n\t\t\thfs_bnode_free(node);\n\t\t\ttree->node_hash_cnt--;\n\t\t}\n\t}\n\tiput(tree->inode);\n\tkfree(tree);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/log2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/log2.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nvoid hfs_btree_close(struct hfs_btree *tree)\n{\n\tstruct hfs_bnode *node;\n\tint i;\n\n\tif (!tree)\n\t\treturn;\n\n\tfor (i = 0; i < NODE_HASH_SIZE; i++) {\n\t\twhile ((node = tree->node_hash[i])) {\n\t\t\ttree->node_hash[i] = node->next_hash;\n\t\t\tif (atomic_read(&node->refcnt))\n\t\t\t\tpr_crit(\"node %d:%d \"\n\t\t\t\t\t\t\"still has %d user(s)!\\n\",\n\t\t\t\t\tnode->tree->cnid, node->this,\n\t\t\t\t\tatomic_read(&node->refcnt));\n\t\t\thfs_bnode_free(node);\n\t\t\ttree->node_hash_cnt--;\n\t\t}\n\t}\n\tiput(tree->inode);\n\tkfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "sbi->alloc_file"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "sb->s_root"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_mark_inode_dirty",
          "args": [
            "sbi->hidden_dir",
            "HFSPLUS_I_CAT_DIRTY"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "275-280",
          "snippet": "static inline void hfsplus_mark_inode_dirty(struct inode *inode,\n\t\tunsigned int flag)\n{\n\tset_bit(flag, &HFSPLUS_I(inode)->flags);\n\tmark_inode_dirty(inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline void hfsplus_mark_inode_dirty(struct inode *inode,\n\t\tunsigned int flag)\n{\n\tset_bit(flag, &HFSPLUS_I(inode)->flags);\n\tmark_inode_dirty(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->vh_mutex"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->vh_mutex"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_delete_cat",
          "args": [
            "sbi->hidden_dir->i_ino",
            "root",
            "&str"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_delete_cat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "321-411",
          "snippet": "int hfsplus_delete_cat(u32 cnid, struct inode *dir, struct qstr *str)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_fork_raw fork;\n\tstruct list_head *pos;\n\tint err, off;\n\tu16 type;\n\n\thfs_dbg(CAT_MOD, \"delete_cat: %s,%u\\n\", str ? str->name : NULL, cnid);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tif (!str) {\n\t\tint len;\n\n\t\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\t\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_thread, nodeName);\n\t\tfd.search_key->cat.parent = cpu_to_be32(dir->i_ino);\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.length, off, 2);\n\t\tlen = be16_to_cpu(fd.search_key->cat.name.length) * 2;\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.unicode,\n\t\t\toff + 2, len);\n\t\tfd.search_key->key_len = cpu_to_be16(6 + len);\n\t} else\n\t\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\ttype = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);\n\tif (type == HFSPLUS_FILE) {\n#if 0\n\t\toff = fd.entryoffset + offsetof(hfsplus_cat_file, data_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_DATA);\n#endif\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_file, rsrc_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_RSRC);\n\t}\n\n\tlist_for_each(pos, &HFSPLUS_I(dir)->open_dir_list) {\n\t\tstruct hfsplus_readdir_data *rd =\n\t\t\tlist_entry(pos, struct hfsplus_readdir_data, list);\n\t\tif (fd.tree->keycmp(fd.search_key, (void *)&rd->key) < 0)\n\t\t\trd->file->f_pos--;\n\t}\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\tdir->i_size--;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_dec(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\tif (type == HFSPLUS_FILE || type == HFSPLUS_FOLDER) {\n\t\tif (HFSPLUS_SB(sb)->attr_tree)\n\t\t\thfsplus_delete_all_attrs(dir, cnid);\n\t}\n\nout:\n\thfs_find_exit(&fd);\n\n\treturn err;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_delete_cat(u32 cnid, struct inode *dir, struct qstr *str)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_fork_raw fork;\n\tstruct list_head *pos;\n\tint err, off;\n\tu16 type;\n\n\thfs_dbg(CAT_MOD, \"delete_cat: %s,%u\\n\", str ? str->name : NULL, cnid);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tif (!str) {\n\t\tint len;\n\n\t\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\t\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_thread, nodeName);\n\t\tfd.search_key->cat.parent = cpu_to_be32(dir->i_ino);\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.length, off, 2);\n\t\tlen = be16_to_cpu(fd.search_key->cat.name.length) * 2;\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.unicode,\n\t\t\toff + 2, len);\n\t\tfd.search_key->key_len = cpu_to_be16(6 + len);\n\t} else\n\t\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\ttype = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);\n\tif (type == HFSPLUS_FILE) {\n#if 0\n\t\toff = fd.entryoffset + offsetof(hfsplus_cat_file, data_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_DATA);\n#endif\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_file, rsrc_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_RSRC);\n\t}\n\n\tlist_for_each(pos, &HFSPLUS_I(dir)->open_dir_list) {\n\t\tstruct hfsplus_readdir_data *rd =\n\t\t\tlist_entry(pos, struct hfsplus_readdir_data, list);\n\t\tif (fd.tree->keycmp(fd.search_key, (void *)&rd->key) < 0)\n\t\t\trd->file->f_pos--;\n\t}\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\tdir->i_size--;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_dec(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\tif (type == HFSPLUS_FILE || type == HFSPLUS_FOLDER) {\n\t\tif (HFSPLUS_SB(sb)->attr_tree)\n\t\t\thfsplus_delete_all_attrs(dir, cnid);\n\t}\n\nout:\n\thfs_find_exit(&fd);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_init_inode_security",
          "args": [
            "sbi->hidden_dir",
            "root",
            "&str"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_init_inode_security",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr_security.c",
          "lines": "107-117",
          "snippet": "int hfsplus_init_inode_security(struct inode *inode,\n\t\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\t\tconst struct qstr *qstr)\n{\n\tint err;\n\n\terr = hfsplus_init_posix_acl(inode, dir);\n\tif (!err)\n\t\terr = hfsplus_init_security(inode, dir, qstr);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/security.h>\n\nint hfsplus_init_inode_security(struct inode *inode,\n\t\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\t\tconst struct qstr *qstr)\n{\n\tint err;\n\n\terr = hfsplus_init_posix_acl(inode, dir);\n\tif (!err)\n\t\terr = hfsplus_init_security(inode, dir, qstr);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->vh_mutex"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_create_cat",
          "args": [
            "sbi->hidden_dir->i_ino",
            "root",
            "&str",
            "sbi->hidden_dir"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_create_cat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "252-319",
          "snippet": "int hfsplus_create_cat(u32 cnid, struct inode *dir,\n\t\tstruct qstr *str, struct inode *inode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\thfsplus_cat_entry entry;\n\tint entry_size;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"create_cat: %s,%u(%d)\\n\",\n\t\tstr->name, cnid, inode->i_nlink);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry,\n\t\tS_ISDIR(inode->i_mode) ?\n\t\t\tHFSPLUS_FOLDER_THREAD : HFSPLUS_FILE_THREAD,\n\t\tdir->i_ino, str);\n\tif (unlikely(entry_size < 0)) {\n\t\terr = entry_size;\n\t\tgoto err2;\n\t}\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err2;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err2;\n\n\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\tif (unlikely(err))\n\t\tgoto err1;\n\n\tentry_size = hfsplus_cat_build_record(&entry, cnid, inode);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\t/* panic? */\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err1;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err1;\n\n\tdir->i_size++;\n\tif (S_ISDIR(inode->i_mode))\n\t\thfsplus_subfolders_inc(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\thfs_find_exit(&fd);\n\treturn 0;\n\nerr1:\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\tif (!hfs_brec_find(&fd, hfs_find_rec_by_key))\n\t\thfs_brec_remove(&fd);\nerr2:\n\thfs_find_exit(&fd);\n\treturn err;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_create_cat(u32 cnid, struct inode *dir,\n\t\tstruct qstr *str, struct inode *inode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\thfsplus_cat_entry entry;\n\tint entry_size;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"create_cat: %s,%u(%d)\\n\",\n\t\tstr->name, cnid, inode->i_nlink);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry,\n\t\tS_ISDIR(inode->i_mode) ?\n\t\t\tHFSPLUS_FOLDER_THREAD : HFSPLUS_FILE_THREAD,\n\t\tdir->i_ino, str);\n\tif (unlikely(entry_size < 0)) {\n\t\terr = entry_size;\n\t\tgoto err2;\n\t}\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err2;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err2;\n\n\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\tif (unlikely(err))\n\t\tgoto err1;\n\n\tentry_size = hfsplus_cat_build_record(&entry, cnid, inode);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\t/* panic? */\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err1;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err1;\n\n\tdir->i_size++;\n\tif (S_ISDIR(inode->i_mode))\n\t\thfsplus_subfolders_inc(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\thfs_find_exit(&fd);\n\treturn 0;\n\nerr1:\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\tif (!hfs_brec_find(&fd, hfs_find_rec_by_key))\n\t\thfs_brec_remove(&fd);\nerr2:\n\thfs_find_exit(&fd);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->vh_mutex"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_new_inode",
          "args": [
            "sb",
            "S_IFDIR"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
          "lines": "356-412",
          "snippet": "struct inode *hfsplus_new_inode(struct super_block *sb, umode_t mode)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct inode *inode = new_inode(sb);\n\tstruct hfsplus_inode_info *hip;\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tinode->i_ino = sbi->next_cnid++;\n\tinode->i_mode = mode;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tset_nlink(inode, 1);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\n\thip = HFSPLUS_I(inode);\n\tINIT_LIST_HEAD(&hip->open_dir_list);\n\tmutex_init(&hip->extents_lock);\n\tatomic_set(&hip->opencnt, 0);\n\thip->extent_state = 0;\n\thip->flags = 0;\n\thip->userflags = 0;\n\thip->subfolders = 0;\n\tmemset(hip->first_extents, 0, sizeof(hfsplus_extent_rec));\n\tmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\n\thip->alloc_blocks = 0;\n\thip->first_blocks = 0;\n\thip->cached_start = 0;\n\thip->cached_blocks = 0;\n\thip->phys_size = 0;\n\thip->fs_blocks = 0;\n\thip->rsrc_inode = NULL;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_size = 2;\n\t\tsbi->folder_count++;\n\t\tinode->i_op = &hfsplus_dir_inode_operations;\n\t\tinode->i_fop = &hfsplus_dir_operations;\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tsbi->file_count++;\n\t\tinode->i_op = &hfsplus_file_inode_operations;\n\t\tinode->i_fop = &hfsplus_file_operations;\n\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\thip->clump_blocks = sbi->data_clump_blocks;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tsbi->file_count++;\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\thip->clump_blocks = 1;\n\t} else\n\t\tsbi->file_count++;\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\thfsplus_mark_mdb_dirty(sb);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct address_space_operations hfsplus_aops = {\n\t.readpage\t= hfsplus_readpage,\n\t.writepage\t= hfsplus_writepage,\n\t.write_begin\t= hfsplus_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfsplus_bmap,\n\t.direct_IO\t= hfsplus_direct_IO,\n\t.writepages\t= hfsplus_writepages,\n};",
            "static const struct inode_operations hfsplus_file_inode_operations = {\n\t.setattr\t= hfsplus_setattr,\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= hfsplus_listxattr,\n\t.removexattr\t= generic_removexattr,\n#ifdef CONFIG_HFSPLUS_FS_POSIX_ACL\n\t.get_acl\t= hfsplus_get_posix_acl,\n\t.set_acl\t= hfsplus_set_posix_acl,\n#endif\n};",
            "static const struct file_operations hfsplus_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.splice_read\t= generic_file_splice_read,\n\t.fsync\t\t= hfsplus_file_fsync,\n\t.open\t\t= hfsplus_file_open,\n\t.release\t= hfsplus_file_release,\n\t.unlocked_ioctl = hfsplus_ioctl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nconst struct address_space_operations hfsplus_aops = {\n\t.readpage\t= hfsplus_readpage,\n\t.writepage\t= hfsplus_writepage,\n\t.write_begin\t= hfsplus_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfsplus_bmap,\n\t.direct_IO\t= hfsplus_direct_IO,\n\t.writepages\t= hfsplus_writepages,\n};\nstatic const struct inode_operations hfsplus_file_inode_operations = {\n\t.setattr\t= hfsplus_setattr,\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= hfsplus_listxattr,\n\t.removexattr\t= generic_removexattr,\n#ifdef CONFIG_HFSPLUS_FS_POSIX_ACL\n\t.get_acl\t= hfsplus_get_posix_acl,\n\t.set_acl\t= hfsplus_set_posix_acl,\n#endif\n};\nstatic const struct file_operations hfsplus_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.splice_read\t= generic_file_splice_read,\n\t.fsync\t\t= hfsplus_file_fsync,\n\t.open\t\t= hfsplus_file_open,\n\t.release\t= hfsplus_file_release,\n\t.unlocked_ioctl = hfsplus_ioctl,\n};\n\nstruct inode *hfsplus_new_inode(struct super_block *sb, umode_t mode)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct inode *inode = new_inode(sb);\n\tstruct hfsplus_inode_info *hip;\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tinode->i_ino = sbi->next_cnid++;\n\tinode->i_mode = mode;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tset_nlink(inode, 1);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\n\thip = HFSPLUS_I(inode);\n\tINIT_LIST_HEAD(&hip->open_dir_list);\n\tmutex_init(&hip->extents_lock);\n\tatomic_set(&hip->opencnt, 0);\n\thip->extent_state = 0;\n\thip->flags = 0;\n\thip->userflags = 0;\n\thip->subfolders = 0;\n\tmemset(hip->first_extents, 0, sizeof(hfsplus_extent_rec));\n\tmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\n\thip->alloc_blocks = 0;\n\thip->first_blocks = 0;\n\thip->cached_start = 0;\n\thip->cached_blocks = 0;\n\thip->phys_size = 0;\n\thip->fs_blocks = 0;\n\thip->rsrc_inode = NULL;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_size = 2;\n\t\tsbi->folder_count++;\n\t\tinode->i_op = &hfsplus_dir_inode_operations;\n\t\tinode->i_fop = &hfsplus_dir_operations;\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tsbi->file_count++;\n\t\tinode->i_op = &hfsplus_file_inode_operations;\n\t\tinode->i_fop = &hfsplus_file_operations;\n\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\thip->clump_blocks = sbi->data_clump_blocks;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tsbi->file_count++;\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\thip->clump_blocks = 1;\n\t} else\n\t\tsbi->file_count++;\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\thfsplus_mark_mdb_dirty(sb);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->vh_mutex"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_sync_fs",
          "args": [
            "sb",
            "1"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_sync_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
          "lines": "173-240",
          "snippet": "static int hfsplus_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_vh *vhdr = sbi->s_vhdr;\n\tint write_backup = 0;\n\tint error, error2;\n\n\tif (!wait)\n\t\treturn 0;\n\n\thfs_dbg(SUPER, \"hfsplus_sync_fs\\n\");\n\n\t/*\n\t * Explicitly write out the special metadata inodes.\n\t *\n\t * While these special inodes are marked as hashed and written\n\t * out peridocically by the flusher threads we redirty them\n\t * during writeout of normal inodes, and thus the life lock\n\t * prevents us from getting the latest state to disk.\n\t */\n\terror = filemap_write_and_wait(sbi->cat_tree->inode->i_mapping);\n\terror2 = filemap_write_and_wait(sbi->ext_tree->inode->i_mapping);\n\tif (!error)\n\t\terror = error2;\n\tif (sbi->attr_tree) {\n\t\terror2 =\n\t\t    filemap_write_and_wait(sbi->attr_tree->inode->i_mapping);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\terror2 = filemap_write_and_wait(sbi->alloc_file->i_mapping);\n\tif (!error)\n\t\terror = error2;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tmutex_lock(&sbi->alloc_mutex);\n\tvhdr->free_blocks = cpu_to_be32(sbi->free_blocks);\n\tvhdr->next_cnid = cpu_to_be32(sbi->next_cnid);\n\tvhdr->folder_count = cpu_to_be32(sbi->folder_count);\n\tvhdr->file_count = cpu_to_be32(sbi->file_count);\n\n\tif (test_and_clear_bit(HFSPLUS_SB_WRITEBACKUP, &sbi->flags)) {\n\t\tmemcpy(sbi->s_backup_vhdr, sbi->s_vhdr, sizeof(*sbi->s_vhdr));\n\t\twrite_backup = 1;\n\t}\n\n\terror2 = hfsplus_submit_bio(sb,\n\t\t\t\t   sbi->part_start + HFSPLUS_VOLHEAD_SECTOR,\n\t\t\t\t   sbi->s_vhdr_buf, NULL, WRITE_SYNC);\n\tif (!error)\n\t\terror = error2;\n\tif (!write_backup)\n\t\tgoto out;\n\n\terror2 = hfsplus_submit_bio(sb,\n\t\t\t\t  sbi->part_start + sbi->sect_count - 2,\n\t\t\t\t  sbi->s_backup_vhdr_buf, NULL, WRITE_SYNC);\n\tif (!error)\n\t\terror2 = error;\nout:\n\tmutex_unlock(&sbi->alloc_mutex);\n\tmutex_unlock(&sbi->vh_mutex);\n\n\tif (!test_bit(HFSPLUS_SB_NOBARRIER, &sbi->flags))\n\t\tblkdev_issue_flush(sb->s_bdev, GFP_KERNEL, NULL);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode *hfsplus_alloc_inode(struct super_block *sb);",
            "static void hfsplus_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct inode *hfsplus_alloc_inode(struct super_block *sb);\nstatic void hfsplus_destroy_inode(struct inode *inode);\n\nstatic int hfsplus_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_vh *vhdr = sbi->s_vhdr;\n\tint write_backup = 0;\n\tint error, error2;\n\n\tif (!wait)\n\t\treturn 0;\n\n\thfs_dbg(SUPER, \"hfsplus_sync_fs\\n\");\n\n\t/*\n\t * Explicitly write out the special metadata inodes.\n\t *\n\t * While these special inodes are marked as hashed and written\n\t * out peridocically by the flusher threads we redirty them\n\t * during writeout of normal inodes, and thus the life lock\n\t * prevents us from getting the latest state to disk.\n\t */\n\terror = filemap_write_and_wait(sbi->cat_tree->inode->i_mapping);\n\terror2 = filemap_write_and_wait(sbi->ext_tree->inode->i_mapping);\n\tif (!error)\n\t\terror = error2;\n\tif (sbi->attr_tree) {\n\t\terror2 =\n\t\t    filemap_write_and_wait(sbi->attr_tree->inode->i_mapping);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\terror2 = filemap_write_and_wait(sbi->alloc_file->i_mapping);\n\tif (!error)\n\t\terror = error2;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tmutex_lock(&sbi->alloc_mutex);\n\tvhdr->free_blocks = cpu_to_be32(sbi->free_blocks);\n\tvhdr->next_cnid = cpu_to_be32(sbi->next_cnid);\n\tvhdr->folder_count = cpu_to_be32(sbi->folder_count);\n\tvhdr->file_count = cpu_to_be32(sbi->file_count);\n\n\tif (test_and_clear_bit(HFSPLUS_SB_WRITEBACKUP, &sbi->flags)) {\n\t\tmemcpy(sbi->s_backup_vhdr, sbi->s_vhdr, sizeof(*sbi->s_vhdr));\n\t\twrite_backup = 1;\n\t}\n\n\terror2 = hfsplus_submit_bio(sb,\n\t\t\t\t   sbi->part_start + HFSPLUS_VOLHEAD_SECTOR,\n\t\t\t\t   sbi->s_vhdr_buf, NULL, WRITE_SYNC);\n\tif (!error)\n\t\terror = error2;\n\tif (!write_backup)\n\t\tgoto out;\n\n\terror2 = hfsplus_submit_bio(sb,\n\t\t\t\t  sbi->part_start + sbi->sect_count - 2,\n\t\t\t\t  sbi->s_backup_vhdr_buf, NULL, WRITE_SYNC);\n\tif (!error)\n\t\terror2 = error;\nout:\n\tmutex_unlock(&sbi->alloc_mutex);\n\tmutex_unlock(&sbi->vh_mutex);\n\n\tif (!test_bit(HFSPLUS_SB_NOBARRIER, &sbi->flags))\n\t\tblkdev_issue_flush(sb->s_bdev, GFP_KERNEL, NULL);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "HFSPLUS_VOL_INCNSTNT"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "~HFSPLUS_VOL_UNMNT"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&vhdr->write_count",
            "1"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsp_now2mt",
          "args": [],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "HFSP_MOUNT_VERSION"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "43-51",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_iget",
          "args": [
            "sb",
            "be32_to_cpu(entry.folder.id)"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
          "lines": "56-95",
          "snippet": "struct inode *hfsplus_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct hfs_find_data fd;\n\tstruct inode *inode;\n\tint err;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tINIT_LIST_HEAD(&HFSPLUS_I(inode)->open_dir_list);\n\tmutex_init(&HFSPLUS_I(inode)->extents_lock);\n\tHFSPLUS_I(inode)->flags = 0;\n\tHFSPLUS_I(inode)->extent_state = 0;\n\tHFSPLUS_I(inode)->rsrc_inode = NULL;\n\tatomic_set(&HFSPLUS_I(inode)->opencnt, 0);\n\n\tif (inode->i_ino >= HFSPLUS_FIRSTUSER_CNID ||\n\t    inode->i_ino == HFSPLUS_ROOT_CNID) {\n\t\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &fd);\n\t\tif (!err) {\n\t\t\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd);\n\t\t\tif (!err)\n\t\t\t\terr = hfsplus_cat_read_inode(inode, &fd);\n\t\t\thfs_find_exit(&fd);\n\t\t}\n\t} else {\n\t\terr = hfsplus_system_read_inode(inode);\n\t}\n\n\tif (err) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode *hfsplus_alloc_inode(struct super_block *sb);",
            "static void hfsplus_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct inode *hfsplus_alloc_inode(struct super_block *sb);\nstatic void hfsplus_destroy_inode(struct inode *inode);\n\nstruct inode *hfsplus_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct hfs_find_data fd;\n\tstruct inode *inode;\n\tint err;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tINIT_LIST_HEAD(&HFSPLUS_I(inode)->open_dir_list);\n\tmutex_init(&HFSPLUS_I(inode)->extents_lock);\n\tHFSPLUS_I(inode)->flags = 0;\n\tHFSPLUS_I(inode)->extent_state = 0;\n\tHFSPLUS_I(inode)->rsrc_inode = NULL;\n\tatomic_set(&HFSPLUS_I(inode)->opencnt, 0);\n\n\tif (inode->i_ino >= HFSPLUS_FIRSTUSER_CNID ||\n\t    inode->i_ino == HFSPLUS_ROOT_CNID) {\n\t\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &fd);\n\t\tif (!err) {\n\t\t\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd);\n\t\t\tif (!err)\n\t\t\t\terr = hfsplus_cat_read_inode(inode, &fd);\n\t\t\thfs_find_exit(&fd);\n\t\t}\n\t} else {\n\t\terr = hfsplus_system_read_inode(inode);\n\t}\n\n\tif (err) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry.folder.id"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFSPLUS_FOLDER"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_brec_read",
          "args": [
            "&fd",
            "&entry",
            "sizeof(entry)"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "219-230",
          "snippet": "int hfs_brec_read(struct hfs_find_data *fd, void *rec, int rec_len)\n{\n\tint res;\n\n\tres = hfs_brec_find(fd, hfs_find_rec_by_key);\n\tif (res)\n\t\treturn res;\n\tif (fd->entrylength > rec_len)\n\t\treturn -EINVAL;\n\thfs_bnode_read(fd->bnode, rec, fd->entryoffset, fd->entrylength);\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_brec_read(struct hfs_find_data *fd, void *rec, int rec_len)\n{\n\tint res;\n\n\tres = hfs_brec_find(fd, hfs_find_rec_by_key);\n\tif (res)\n\t\treturn res;\n\tif (fd->entrylength > rec_len)\n\t\treturn -EINVAL;\n\thfs_bnode_read(fd->bnode, rec, fd->entryoffset, fd->entrylength);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err < 0"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_cat_build_key",
          "args": [
            "sb",
            "fd.search_key",
            "HFSPLUS_ROOT_CNID",
            "&str"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_cat_build_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "42-56",
          "snippet": "int hfsplus_cat_build_key(struct super_block *sb,\n\t\thfsplus_btree_key *key, u32 parent, struct qstr *str)\n{\n\tint len, err;\n\n\tkey->cat.parent = cpu_to_be32(parent);\n\terr = hfsplus_asc2uni(sb, &key->cat.name, HFSPLUS_MAX_STRLEN,\n\t\t\tstr->name, str->len);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\n\tlen = be16_to_cpu(key->cat.name.length);\n\tkey->key_len = cpu_to_be16(6 + 2 * len);\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_cat_build_key(struct super_block *sb,\n\t\thfsplus_btree_key *key, u32 parent, struct qstr *str)\n{\n\tint len, err;\n\n\tkey->cat.parent = cpu_to_be32(parent);\n\terr = hfsplus_asc2uni(sb, &key->cat.name, HFSPLUS_MAX_STRLEN,\n\t\t\tstr->name, str->len);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\n\tlen = be16_to_cpu(key->cat.name.length);\n\tkey->key_len = cpu_to_be16(6 + 2 * len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "sbi->cat_tree",
            "&fd"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "14-41",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to load root directory\\n\""
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to load allocation file\\n\""
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sbi->attr_tree_state",
            "HFSPLUS_VALID_ATTR_TREE"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to load attributes file\\n\""
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_btree_open",
          "args": [
            "sb",
            "HFSPLUS_ATTR_CNID"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_btree_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/btree.c",
          "lines": "132-254",
          "snippet": "struct hfs_btree *hfs_btree_open(struct super_block *sb, u32 id)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_btree_header_rec *head;\n\tstruct address_space *mapping;\n\tstruct inode *inode;\n\tstruct page *page;\n\tunsigned int size;\n\n\ttree = kzalloc(sizeof(*tree), GFP_KERNEL);\n\tif (!tree)\n\t\treturn NULL;\n\n\tmutex_init(&tree->tree_lock);\n\tspin_lock_init(&tree->hash_lock);\n\ttree->sb = sb;\n\ttree->cnid = id;\n\tinode = hfsplus_iget(sb, id);\n\tif (IS_ERR(inode))\n\t\tgoto free_tree;\n\ttree->inode = inode;\n\n\tif (!HFSPLUS_I(tree->inode)->first_blocks) {\n\t\tpr_err(\"invalid btree extent records (0 size)\\n\");\n\t\tgoto free_inode;\n\t}\n\n\tmapping = tree->inode->i_mapping;\n\tpage = read_mapping_page(mapping, 0, NULL);\n\tif (IS_ERR(page))\n\t\tgoto free_inode;\n\n\t/* Load the header */\n\thead = (struct hfs_btree_header_rec *)(kmap(page) +\n\t\tsizeof(struct hfs_bnode_desc));\n\ttree->root = be32_to_cpu(head->root);\n\ttree->leaf_count = be32_to_cpu(head->leaf_count);\n\ttree->leaf_head = be32_to_cpu(head->leaf_head);\n\ttree->leaf_tail = be32_to_cpu(head->leaf_tail);\n\ttree->node_count = be32_to_cpu(head->node_count);\n\ttree->free_nodes = be32_to_cpu(head->free_nodes);\n\ttree->attributes = be32_to_cpu(head->attributes);\n\ttree->node_size = be16_to_cpu(head->node_size);\n\ttree->max_key_len = be16_to_cpu(head->max_key_len);\n\ttree->depth = be16_to_cpu(head->depth);\n\n\t/* Verify the tree and set the correct compare function */\n\tswitch (id) {\n\tcase HFSPLUS_EXT_CNID:\n\t\tif (tree->max_key_len != HFSPLUS_EXT_KEYLEN - sizeof(u16)) {\n\t\t\tpr_err(\"invalid extent max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tif (tree->attributes & HFS_TREE_VARIDXKEYS) {\n\t\t\tpr_err(\"invalid extent btree flag\\n\");\n\t\t\tgoto fail_page;\n\t\t}\n\n\t\ttree->keycmp = hfsplus_ext_cmp_key;\n\t\tbreak;\n\tcase HFSPLUS_CAT_CNID:\n\t\tif (tree->max_key_len != HFSPLUS_CAT_KEYLEN - sizeof(u16)) {\n\t\t\tpr_err(\"invalid catalog max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tif (!(tree->attributes & HFS_TREE_VARIDXKEYS)) {\n\t\t\tpr_err(\"invalid catalog btree flag\\n\");\n\t\t\tgoto fail_page;\n\t\t}\n\n\t\tif (test_bit(HFSPLUS_SB_HFSX, &HFSPLUS_SB(sb)->flags) &&\n\t\t    (head->key_type == HFSPLUS_KEY_BINARY))\n\t\t\ttree->keycmp = hfsplus_cat_bin_cmp_key;\n\t\telse {\n\t\t\ttree->keycmp = hfsplus_cat_case_cmp_key;\n\t\t\tset_bit(HFSPLUS_SB_CASEFOLD, &HFSPLUS_SB(sb)->flags);\n\t\t}\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tif (tree->max_key_len != HFSPLUS_ATTR_KEYLEN - sizeof(u16)) {\n\t\t\tpr_err(\"invalid attributes max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\ttree->keycmp = hfsplus_attr_bin_cmp_key;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown B*Tree requested\\n\");\n\t\tgoto fail_page;\n\t}\n\n\tif (!(tree->attributes & HFS_TREE_BIGKEYS)) {\n\t\tpr_err(\"invalid btree flag\\n\");\n\t\tgoto fail_page;\n\t}\n\n\tsize = tree->node_size;\n\tif (!is_power_of_2(size))\n\t\tgoto fail_page;\n\tif (!tree->node_count)\n\t\tgoto fail_page;\n\n\ttree->node_size_shift = ffs(size) - 1;\n\n\ttree->pages_per_bnode =\n\t\t(tree->node_size + PAGE_CACHE_SIZE - 1) >>\n\t\tPAGE_CACHE_SHIFT;\n\n\tkunmap(page);\n\tpage_cache_release(page);\n\treturn tree;\n\n fail_page:\n\tpage_cache_release(page);\n free_inode:\n\ttree->inode->i_mapping->a_ops = &hfsplus_aops;\n\tiput(tree->inode);\n free_tree:\n\tkfree(tree);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/log2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/log2.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstruct hfs_btree *hfs_btree_open(struct super_block *sb, u32 id)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_btree_header_rec *head;\n\tstruct address_space *mapping;\n\tstruct inode *inode;\n\tstruct page *page;\n\tunsigned int size;\n\n\ttree = kzalloc(sizeof(*tree), GFP_KERNEL);\n\tif (!tree)\n\t\treturn NULL;\n\n\tmutex_init(&tree->tree_lock);\n\tspin_lock_init(&tree->hash_lock);\n\ttree->sb = sb;\n\ttree->cnid = id;\n\tinode = hfsplus_iget(sb, id);\n\tif (IS_ERR(inode))\n\t\tgoto free_tree;\n\ttree->inode = inode;\n\n\tif (!HFSPLUS_I(tree->inode)->first_blocks) {\n\t\tpr_err(\"invalid btree extent records (0 size)\\n\");\n\t\tgoto free_inode;\n\t}\n\n\tmapping = tree->inode->i_mapping;\n\tpage = read_mapping_page(mapping, 0, NULL);\n\tif (IS_ERR(page))\n\t\tgoto free_inode;\n\n\t/* Load the header */\n\thead = (struct hfs_btree_header_rec *)(kmap(page) +\n\t\tsizeof(struct hfs_bnode_desc));\n\ttree->root = be32_to_cpu(head->root);\n\ttree->leaf_count = be32_to_cpu(head->leaf_count);\n\ttree->leaf_head = be32_to_cpu(head->leaf_head);\n\ttree->leaf_tail = be32_to_cpu(head->leaf_tail);\n\ttree->node_count = be32_to_cpu(head->node_count);\n\ttree->free_nodes = be32_to_cpu(head->free_nodes);\n\ttree->attributes = be32_to_cpu(head->attributes);\n\ttree->node_size = be16_to_cpu(head->node_size);\n\ttree->max_key_len = be16_to_cpu(head->max_key_len);\n\ttree->depth = be16_to_cpu(head->depth);\n\n\t/* Verify the tree and set the correct compare function */\n\tswitch (id) {\n\tcase HFSPLUS_EXT_CNID:\n\t\tif (tree->max_key_len != HFSPLUS_EXT_KEYLEN - sizeof(u16)) {\n\t\t\tpr_err(\"invalid extent max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tif (tree->attributes & HFS_TREE_VARIDXKEYS) {\n\t\t\tpr_err(\"invalid extent btree flag\\n\");\n\t\t\tgoto fail_page;\n\t\t}\n\n\t\ttree->keycmp = hfsplus_ext_cmp_key;\n\t\tbreak;\n\tcase HFSPLUS_CAT_CNID:\n\t\tif (tree->max_key_len != HFSPLUS_CAT_KEYLEN - sizeof(u16)) {\n\t\t\tpr_err(\"invalid catalog max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tif (!(tree->attributes & HFS_TREE_VARIDXKEYS)) {\n\t\t\tpr_err(\"invalid catalog btree flag\\n\");\n\t\t\tgoto fail_page;\n\t\t}\n\n\t\tif (test_bit(HFSPLUS_SB_HFSX, &HFSPLUS_SB(sb)->flags) &&\n\t\t    (head->key_type == HFSPLUS_KEY_BINARY))\n\t\t\ttree->keycmp = hfsplus_cat_bin_cmp_key;\n\t\telse {\n\t\t\ttree->keycmp = hfsplus_cat_case_cmp_key;\n\t\t\tset_bit(HFSPLUS_SB_CASEFOLD, &HFSPLUS_SB(sb)->flags);\n\t\t}\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tif (tree->max_key_len != HFSPLUS_ATTR_KEYLEN - sizeof(u16)) {\n\t\t\tpr_err(\"invalid attributes max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\ttree->keycmp = hfsplus_attr_bin_cmp_key;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown B*Tree requested\\n\");\n\t\tgoto fail_page;\n\t}\n\n\tif (!(tree->attributes & HFS_TREE_BIGKEYS)) {\n\t\tpr_err(\"invalid btree flag\\n\");\n\t\tgoto fail_page;\n\t}\n\n\tsize = tree->node_size;\n\tif (!is_power_of_2(size))\n\t\tgoto fail_page;\n\tif (!tree->node_count)\n\t\tgoto fail_page;\n\n\ttree->node_size_shift = ffs(size) - 1;\n\n\ttree->pages_per_bnode =\n\t\t(tree->node_size + PAGE_CACHE_SIZE - 1) >>\n\t\tPAGE_CACHE_SHIFT;\n\n\tkunmap(page);\n\tpage_cache_release(page);\n\treturn tree;\n\n fail_page:\n\tpage_cache_release(page);\n free_inode:\n\ttree->inode->i_mapping->a_ops = &hfsplus_aops;\n\tiput(tree->inode);\n free_tree:\n\tkfree(tree);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sbi->attr_tree_state",
            "HFSPLUS_EMPTY_ATTR_TREE"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to load catalog file\\n\""
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to load extents file\\n\""
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"write access to a journaled filesystem is not supported, use the force option at your own risk, mounting read-only.\\n\""
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "HFSPLUS_VOL_JOURNALED"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Filesystem is marked locked, mounting read-only.\\n\""
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "HFSPLUS_VOL_SOFTLOCK"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "HFSPLUS_SB_FORCE",
            "&sbi->flags"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Filesystem was not cleanly unmounted, running fsck.hfsplus is recommended.  mounting read-only.\\n\""
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "HFSPLUS_VOL_UNMNT"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"filesystem size too large\\n\""
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "~0ULL"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "~0ULL"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "vhdr->rsrc_clump_sz"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "vhdr->data_clump_sz"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "vhdr->folder_count"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "vhdr->file_count"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "vhdr->next_cnid"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "vhdr->free_blocks"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "vhdr->total_blocks"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"wrong filesystem version\\n\""
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "vhdr->version"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "vhdr->version"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"unable to find HFS+ superblock\\n\""
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_read_wrapper",
          "args": [
            "sb"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_read_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/wrapper.c",
          "lines": "157-261",
          "snippet": "int hfsplus_read_wrapper(struct super_block *sb)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_wd wd;\n\tsector_t part_start, part_size;\n\tu32 blocksize;\n\tint error = 0;\n\n\terror = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, HFSPLUS_SECTOR_SIZE);\n\tif (!blocksize)\n\t\tgoto out;\n\n\tif (hfsplus_get_last_session(sb, &part_start, &part_size))\n\t\tgoto out;\n\n\terror = -ENOMEM;\n\tsbi->s_vhdr_buf = kmalloc(hfsplus_min_io_size(sb), GFP_KERNEL);\n\tif (!sbi->s_vhdr_buf)\n\t\tgoto out;\n\tsbi->s_backup_vhdr_buf = kmalloc(hfsplus_min_io_size(sb), GFP_KERNEL);\n\tif (!sbi->s_backup_vhdr_buf)\n\t\tgoto out_free_vhdr;\n\nreread:\n\terror = hfsplus_submit_bio(sb, part_start + HFSPLUS_VOLHEAD_SECTOR,\n\t\t\t\t   sbi->s_vhdr_buf, (void **)&sbi->s_vhdr,\n\t\t\t\t   READ);\n\tif (error)\n\t\tgoto out_free_backup_vhdr;\n\n\terror = -EINVAL;\n\tswitch (sbi->s_vhdr->signature) {\n\tcase cpu_to_be16(HFSPLUS_VOLHEAD_SIGX):\n\t\tset_bit(HFSPLUS_SB_HFSX, &sbi->flags);\n\t\t/*FALLTHRU*/\n\tcase cpu_to_be16(HFSPLUS_VOLHEAD_SIG):\n\t\tbreak;\n\tcase cpu_to_be16(HFSP_WRAP_MAGIC):\n\t\tif (!hfsplus_read_mdb(sbi->s_vhdr, &wd))\n\t\t\tgoto out_free_backup_vhdr;\n\t\twd.ablk_size >>= HFSPLUS_SECTOR_SHIFT;\n\t\tpart_start += (sector_t)wd.ablk_start +\n\t\t\t       (sector_t)wd.embed_start * wd.ablk_size;\n\t\tpart_size = (sector_t)wd.embed_count * wd.ablk_size;\n\t\tgoto reread;\n\tdefault:\n\t\t/*\n\t\t * Check for a partition block.\n\t\t *\n\t\t * (should do this only for cdrom/loop though)\n\t\t */\n\t\tif (hfs_part_find(sb, &part_start, &part_size))\n\t\t\tgoto out_free_backup_vhdr;\n\t\tgoto reread;\n\t}\n\n\terror = hfsplus_submit_bio(sb, part_start + part_size - 2,\n\t\t\t\t   sbi->s_backup_vhdr_buf,\n\t\t\t\t   (void **)&sbi->s_backup_vhdr, READ);\n\tif (error)\n\t\tgoto out_free_backup_vhdr;\n\n\terror = -EINVAL;\n\tif (sbi->s_backup_vhdr->signature != sbi->s_vhdr->signature) {\n\t\tpr_warn(\"invalid secondary volume header\\n\");\n\t\tgoto out_free_backup_vhdr;\n\t}\n\n\tblocksize = be32_to_cpu(sbi->s_vhdr->blocksize);\n\n\t/*\n\t * Block size must be at least as large as a sector and a multiple of 2.\n\t */\n\tif (blocksize < HFSPLUS_SECTOR_SIZE || ((blocksize - 1) & blocksize))\n\t\tgoto out_free_backup_vhdr;\n\tsbi->alloc_blksz = blocksize;\n\tsbi->alloc_blksz_shift = ilog2(blocksize);\n\tblocksize = min_t(u32, sbi->alloc_blksz, PAGE_SIZE);\n\n\t/*\n\t * Align block size to block offset.\n\t */\n\twhile (part_start & ((blocksize >> HFSPLUS_SECTOR_SHIFT) - 1))\n\t\tblocksize >>= 1;\n\n\tif (sb_set_blocksize(sb, blocksize) != blocksize) {\n\t\tpr_err(\"unable to set blocksize to %u!\\n\", blocksize);\n\t\tgoto out_free_backup_vhdr;\n\t}\n\n\tsbi->blockoffset =\n\t\tpart_start >> (sb->s_blocksize_bits - HFSPLUS_SECTOR_SHIFT);\n\tsbi->part_start = part_start;\n\tsbi->sect_count = part_size;\n\tsbi->fs_shift = sbi->alloc_blksz_shift - sb->s_blocksize_bits;\n\treturn 0;\n\nout_free_backup_vhdr:\n\tkfree(sbi->s_backup_vhdr_buf);\nout_free_vhdr:\n\tkfree(sbi->s_vhdr_buf);\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/genhd.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <asm/unaligned.h>\n#include <linux/genhd.h>\n#include <linux/cdrom.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint hfsplus_read_wrapper(struct super_block *sb)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_wd wd;\n\tsector_t part_start, part_size;\n\tu32 blocksize;\n\tint error = 0;\n\n\terror = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, HFSPLUS_SECTOR_SIZE);\n\tif (!blocksize)\n\t\tgoto out;\n\n\tif (hfsplus_get_last_session(sb, &part_start, &part_size))\n\t\tgoto out;\n\n\terror = -ENOMEM;\n\tsbi->s_vhdr_buf = kmalloc(hfsplus_min_io_size(sb), GFP_KERNEL);\n\tif (!sbi->s_vhdr_buf)\n\t\tgoto out;\n\tsbi->s_backup_vhdr_buf = kmalloc(hfsplus_min_io_size(sb), GFP_KERNEL);\n\tif (!sbi->s_backup_vhdr_buf)\n\t\tgoto out_free_vhdr;\n\nreread:\n\terror = hfsplus_submit_bio(sb, part_start + HFSPLUS_VOLHEAD_SECTOR,\n\t\t\t\t   sbi->s_vhdr_buf, (void **)&sbi->s_vhdr,\n\t\t\t\t   READ);\n\tif (error)\n\t\tgoto out_free_backup_vhdr;\n\n\terror = -EINVAL;\n\tswitch (sbi->s_vhdr->signature) {\n\tcase cpu_to_be16(HFSPLUS_VOLHEAD_SIGX):\n\t\tset_bit(HFSPLUS_SB_HFSX, &sbi->flags);\n\t\t/*FALLTHRU*/\n\tcase cpu_to_be16(HFSPLUS_VOLHEAD_SIG):\n\t\tbreak;\n\tcase cpu_to_be16(HFSP_WRAP_MAGIC):\n\t\tif (!hfsplus_read_mdb(sbi->s_vhdr, &wd))\n\t\t\tgoto out_free_backup_vhdr;\n\t\twd.ablk_size >>= HFSPLUS_SECTOR_SHIFT;\n\t\tpart_start += (sector_t)wd.ablk_start +\n\t\t\t       (sector_t)wd.embed_start * wd.ablk_size;\n\t\tpart_size = (sector_t)wd.embed_count * wd.ablk_size;\n\t\tgoto reread;\n\tdefault:\n\t\t/*\n\t\t * Check for a partition block.\n\t\t *\n\t\t * (should do this only for cdrom/loop though)\n\t\t */\n\t\tif (hfs_part_find(sb, &part_start, &part_size))\n\t\t\tgoto out_free_backup_vhdr;\n\t\tgoto reread;\n\t}\n\n\terror = hfsplus_submit_bio(sb, part_start + part_size - 2,\n\t\t\t\t   sbi->s_backup_vhdr_buf,\n\t\t\t\t   (void **)&sbi->s_backup_vhdr, READ);\n\tif (error)\n\t\tgoto out_free_backup_vhdr;\n\n\terror = -EINVAL;\n\tif (sbi->s_backup_vhdr->signature != sbi->s_vhdr->signature) {\n\t\tpr_warn(\"invalid secondary volume header\\n\");\n\t\tgoto out_free_backup_vhdr;\n\t}\n\n\tblocksize = be32_to_cpu(sbi->s_vhdr->blocksize);\n\n\t/*\n\t * Block size must be at least as large as a sector and a multiple of 2.\n\t */\n\tif (blocksize < HFSPLUS_SECTOR_SIZE || ((blocksize - 1) & blocksize))\n\t\tgoto out_free_backup_vhdr;\n\tsbi->alloc_blksz = blocksize;\n\tsbi->alloc_blksz_shift = ilog2(blocksize);\n\tblocksize = min_t(u32, sbi->alloc_blksz, PAGE_SIZE);\n\n\t/*\n\t * Align block size to block offset.\n\t */\n\twhile (part_start & ((blocksize >> HFSPLUS_SECTOR_SHIFT) - 1))\n\t\tblocksize >>= 1;\n\n\tif (sb_set_blocksize(sb, blocksize) != blocksize) {\n\t\tpr_err(\"unable to set blocksize to %u!\\n\", blocksize);\n\t\tgoto out_free_backup_vhdr;\n\t}\n\n\tsbi->blockoffset =\n\t\tpart_start >> (sb->s_blocksize_bits - HFSPLUS_SECTOR_SHIFT);\n\tsbi->part_start = part_start;\n\tsbi->sect_count = part_size;\n\tsbi->fs_shift = sbi->alloc_blksz_shift - sb->s_blocksize_bits;\n\treturn 0;\n\nout_free_backup_vhdr:\n\tkfree(sbi->s_backup_vhdr_buf);\nout_free_vhdr:\n\tkfree(sbi->s_vhdr_buf);\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unable to load nls for utf8\\n\""
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unable to parse mount options\\n\""
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_parse_options",
          "args": [
            "data",
            "sbi"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/options.c",
          "lines": "99-214",
          "snippet": "int hfsplus_parse_options(char *input, struct hfsplus_sb_info *sbi)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint tmp, token;\n\n\tif (!input)\n\t\tgoto done;\n\n\twhile ((p = strsep(&input, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase opt_creator:\n\t\t\tif (match_fourchar(&args[0], &sbi->creator)) {\n\t\t\t\tpr_err(\"creator requires a 4 character value\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase opt_type:\n\t\t\tif (match_fourchar(&args[0], &sbi->type)) {\n\t\t\t\tpr_err(\"type requires a 4 character value\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase opt_umask:\n\t\t\tif (match_octal(&args[0], &tmp)) {\n\t\t\t\tpr_err(\"umask requires a value\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->umask = (umode_t)tmp;\n\t\t\tbreak;\n\t\tcase opt_uid:\n\t\t\tif (match_int(&args[0], &tmp)) {\n\t\t\t\tpr_err(\"uid requires an argument\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->uid = make_kuid(current_user_ns(), (uid_t)tmp);\n\t\t\tif (!uid_valid(sbi->uid)) {\n\t\t\t\tpr_err(\"invalid uid specified\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase opt_gid:\n\t\t\tif (match_int(&args[0], &tmp)) {\n\t\t\t\tpr_err(\"gid requires an argument\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->gid = make_kgid(current_user_ns(), (gid_t)tmp);\n\t\t\tif (!gid_valid(sbi->gid)) {\n\t\t\t\tpr_err(\"invalid gid specified\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase opt_part:\n\t\t\tif (match_int(&args[0], &sbi->part)) {\n\t\t\t\tpr_err(\"part requires an argument\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase opt_session:\n\t\t\tif (match_int(&args[0], &sbi->session)) {\n\t\t\t\tpr_err(\"session requires an argument\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase opt_nls:\n\t\t\tif (sbi->nls) {\n\t\t\t\tpr_err(\"unable to change nls mapping\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tp = match_strdup(&args[0]);\n\t\t\tif (p)\n\t\t\t\tsbi->nls = load_nls(p);\n\t\t\tif (!sbi->nls) {\n\t\t\t\tpr_err(\"unable to load nls mapping \\\"%s\\\"\\n\",\n\t\t\t\t       p);\n\t\t\t\tkfree(p);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\tcase opt_decompose:\n\t\t\tclear_bit(HFSPLUS_SB_NODECOMPOSE, &sbi->flags);\n\t\t\tbreak;\n\t\tcase opt_nodecompose:\n\t\t\tset_bit(HFSPLUS_SB_NODECOMPOSE, &sbi->flags);\n\t\t\tbreak;\n\t\tcase opt_barrier:\n\t\t\tclear_bit(HFSPLUS_SB_NOBARRIER, &sbi->flags);\n\t\t\tbreak;\n\t\tcase opt_nobarrier:\n\t\t\tset_bit(HFSPLUS_SB_NOBARRIER, &sbi->flags);\n\t\t\tbreak;\n\t\tcase opt_force:\n\t\t\tset_bit(HFSPLUS_SB_FORCE, &sbi->flags);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\ndone:\n\tif (!sbi->nls) {\n\t\t/* try utf8 first, as this is the old default behaviour */\n\t\tsbi->nls = load_nls(\"utf8\");\n\t\tif (!sbi->nls)\n\t\t\tsbi->nls = load_nls_default();\n\t\tif (!sbi->nls)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/nls.h>",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{ opt_creator, \"creator=%s\" },\n\t{ opt_type, \"type=%s\" },\n\t{ opt_umask, \"umask=%o\" },\n\t{ opt_uid, \"uid=%u\" },\n\t{ opt_gid, \"gid=%u\" },\n\t{ opt_part, \"part=%u\" },\n\t{ opt_session, \"session=%u\" },\n\t{ opt_nls, \"nls=%s\" },\n\t{ opt_decompose, \"decompose\" },\n\t{ opt_nodecompose, \"nodecompose\" },\n\t{ opt_barrier, \"barrier\" },\n\t{ opt_nobarrier, \"nobarrier\" },\n\t{ opt_force, \"force\" },\n\t{ opt_err, NULL }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/nls.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nstatic const match_table_t tokens = {\n\t{ opt_creator, \"creator=%s\" },\n\t{ opt_type, \"type=%s\" },\n\t{ opt_umask, \"umask=%o\" },\n\t{ opt_uid, \"uid=%u\" },\n\t{ opt_gid, \"gid=%u\" },\n\t{ opt_part, \"part=%u\" },\n\t{ opt_session, \"session=%u\" },\n\t{ opt_nls, \"nls=%s\" },\n\t{ opt_decompose, \"decompose\" },\n\t{ opt_nodecompose, \"nodecompose\" },\n\t{ opt_barrier, \"barrier\" },\n\t{ opt_nobarrier, \"nobarrier\" },\n\t{ opt_force, \"force\" },\n\t{ opt_err, NULL }\n};\n\nint hfsplus_parse_options(char *input, struct hfsplus_sb_info *sbi)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint tmp, token;\n\n\tif (!input)\n\t\tgoto done;\n\n\twhile ((p = strsep(&input, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase opt_creator:\n\t\t\tif (match_fourchar(&args[0], &sbi->creator)) {\n\t\t\t\tpr_err(\"creator requires a 4 character value\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase opt_type:\n\t\t\tif (match_fourchar(&args[0], &sbi->type)) {\n\t\t\t\tpr_err(\"type requires a 4 character value\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase opt_umask:\n\t\t\tif (match_octal(&args[0], &tmp)) {\n\t\t\t\tpr_err(\"umask requires a value\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->umask = (umode_t)tmp;\n\t\t\tbreak;\n\t\tcase opt_uid:\n\t\t\tif (match_int(&args[0], &tmp)) {\n\t\t\t\tpr_err(\"uid requires an argument\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->uid = make_kuid(current_user_ns(), (uid_t)tmp);\n\t\t\tif (!uid_valid(sbi->uid)) {\n\t\t\t\tpr_err(\"invalid uid specified\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase opt_gid:\n\t\t\tif (match_int(&args[0], &tmp)) {\n\t\t\t\tpr_err(\"gid requires an argument\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->gid = make_kgid(current_user_ns(), (gid_t)tmp);\n\t\t\tif (!gid_valid(sbi->gid)) {\n\t\t\t\tpr_err(\"invalid gid specified\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase opt_part:\n\t\t\tif (match_int(&args[0], &sbi->part)) {\n\t\t\t\tpr_err(\"part requires an argument\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase opt_session:\n\t\t\tif (match_int(&args[0], &sbi->session)) {\n\t\t\t\tpr_err(\"session requires an argument\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase opt_nls:\n\t\t\tif (sbi->nls) {\n\t\t\t\tpr_err(\"unable to change nls mapping\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tp = match_strdup(&args[0]);\n\t\t\tif (p)\n\t\t\t\tsbi->nls = load_nls(p);\n\t\t\tif (!sbi->nls) {\n\t\t\t\tpr_err(\"unable to load nls mapping \\\"%s\\\"\\n\",\n\t\t\t\t       p);\n\t\t\t\tkfree(p);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\tcase opt_decompose:\n\t\t\tclear_bit(HFSPLUS_SB_NODECOMPOSE, &sbi->flags);\n\t\t\tbreak;\n\t\tcase opt_nodecompose:\n\t\t\tset_bit(HFSPLUS_SB_NODECOMPOSE, &sbi->flags);\n\t\t\tbreak;\n\t\tcase opt_barrier:\n\t\t\tclear_bit(HFSPLUS_SB_NOBARRIER, &sbi->flags);\n\t\t\tbreak;\n\t\tcase opt_nobarrier:\n\t\t\tset_bit(HFSPLUS_SB_NOBARRIER, &sbi->flags);\n\t\t\tbreak;\n\t\tcase opt_force:\n\t\t\tset_bit(HFSPLUS_SB_FORCE, &sbi->flags);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\ndone:\n\tif (!sbi->nls) {\n\t\t/* try utf8 first, as this is the old default behaviour */\n\t\tsbi->nls = load_nls(\"utf8\");\n\t\tif (!sbi->nls)\n\t\t\tsbi->nls = load_nls_default();\n\t\tif (!sbi->nls)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_fill_defaults",
          "args": [
            "sbi"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_fill_defaults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/options.c",
          "lines": "48-60",
          "snippet": "void hfsplus_fill_defaults(struct hfsplus_sb_info *opts)\n{\n\tif (!opts)\n\t\treturn;\n\n\topts->creator = HFSPLUS_DEF_CR_TYPE;\n\topts->type = HFSPLUS_DEF_CR_TYPE;\n\topts->umask = current_umask();\n\topts->uid = current_uid();\n\topts->gid = current_gid();\n\topts->part = -1;\n\topts->session = -1;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/nls.h>",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/nls.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nvoid hfsplus_fill_defaults(struct hfsplus_sb_info *opts)\n{\n\tif (!opts)\n\t\treturn;\n\n\topts->creator = HFSPLUS_DEF_CR_TYPE;\n\topts->type = HFSPLUS_DEF_CR_TYPE;\n\topts->umask = current_umask();\n\topts->uid = current_uid();\n\topts->gid = current_gid();\n\topts->part = -1;\n\topts->session = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&sbi->sync_work",
            "delayed_sync_fs"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sbi->work_lock"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sbi->vh_mutex"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sbi->alloc_mutex"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*sbi)",
            "GFP_KERNEL"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct inode *hfsplus_alloc_inode(struct super_block *sb);\nstatic void hfsplus_destroy_inode(struct inode *inode);\nstatic const struct super_operations hfsplus_sops = {\n\t.alloc_inode\t= hfsplus_alloc_inode,\n\t.destroy_inode\t= hfsplus_destroy_inode,\n\t.write_inode\t= hfsplus_write_inode,\n\t.evict_inode\t= hfsplus_evict_inode,\n\t.put_super\t= hfsplus_put_super,\n\t.sync_fs\t= hfsplus_sync_fs,\n\t.statfs\t\t= hfsplus_statfs,\n\t.remount_fs\t= hfsplus_remount,\n\t.show_options\t= hfsplus_show_options,\n};\n\nstatic int hfsplus_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct hfsplus_vh *vhdr;\n\tstruct hfsplus_sb_info *sbi;\n\thfsplus_cat_entry entry;\n\tstruct hfs_find_data fd;\n\tstruct inode *root, *inode;\n\tstruct qstr str;\n\tstruct nls_table *nls = NULL;\n\tu64 last_fs_block, last_fs_page;\n\tint err;\n\n\terr = -ENOMEM;\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\tgoto out;\n\n\tsb->s_fs_info = sbi;\n\tmutex_init(&sbi->alloc_mutex);\n\tmutex_init(&sbi->vh_mutex);\n\tspin_lock_init(&sbi->work_lock);\n\tINIT_DELAYED_WORK(&sbi->sync_work, delayed_sync_fs);\n\thfsplus_fill_defaults(sbi);\n\n\terr = -EINVAL;\n\tif (!hfsplus_parse_options(data, sbi)) {\n\t\tpr_err(\"unable to parse mount options\\n\");\n\t\tgoto out_unload_nls;\n\t}\n\n\t/* temporarily use utf8 to correctly find the hidden dir below */\n\tnls = sbi->nls;\n\tsbi->nls = load_nls(\"utf8\");\n\tif (!sbi->nls) {\n\t\tpr_err(\"unable to load nls for utf8\\n\");\n\t\tgoto out_unload_nls;\n\t}\n\n\t/* Grab the volume header */\n\tif (hfsplus_read_wrapper(sb)) {\n\t\tif (!silent)\n\t\t\tpr_warn(\"unable to find HFS+ superblock\\n\");\n\t\tgoto out_unload_nls;\n\t}\n\tvhdr = sbi->s_vhdr;\n\n\t/* Copy parts of the volume header into the superblock */\n\tsb->s_magic = HFSPLUS_VOLHEAD_SIG;\n\tif (be16_to_cpu(vhdr->version) < HFSPLUS_MIN_VERSION ||\n\t    be16_to_cpu(vhdr->version) > HFSPLUS_CURRENT_VERSION) {\n\t\tpr_err(\"wrong filesystem version\\n\");\n\t\tgoto out_free_vhdr;\n\t}\n\tsbi->total_blocks = be32_to_cpu(vhdr->total_blocks);\n\tsbi->free_blocks = be32_to_cpu(vhdr->free_blocks);\n\tsbi->next_cnid = be32_to_cpu(vhdr->next_cnid);\n\tsbi->file_count = be32_to_cpu(vhdr->file_count);\n\tsbi->folder_count = be32_to_cpu(vhdr->folder_count);\n\tsbi->data_clump_blocks =\n\t\tbe32_to_cpu(vhdr->data_clump_sz) >> sbi->alloc_blksz_shift;\n\tif (!sbi->data_clump_blocks)\n\t\tsbi->data_clump_blocks = 1;\n\tsbi->rsrc_clump_blocks =\n\t\tbe32_to_cpu(vhdr->rsrc_clump_sz) >> sbi->alloc_blksz_shift;\n\tif (!sbi->rsrc_clump_blocks)\n\t\tsbi->rsrc_clump_blocks = 1;\n\n\terr = -EFBIG;\n\tlast_fs_block = sbi->total_blocks - 1;\n\tlast_fs_page = (last_fs_block << sbi->alloc_blksz_shift) >>\n\t\t\tPAGE_CACHE_SHIFT;\n\n\tif ((last_fs_block > (sector_t)(~0ULL) >> (sbi->alloc_blksz_shift - 9)) ||\n\t    (last_fs_page > (pgoff_t)(~0ULL))) {\n\t\tpr_err(\"filesystem size too large\\n\");\n\t\tgoto out_free_vhdr;\n\t}\n\n\t/* Set up operations so we can load metadata */\n\tsb->s_op = &hfsplus_sops;\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\n\tif (!(vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_UNMNT))) {\n\t\tpr_warn(\"Filesystem was not cleanly unmounted, running fsck.hfsplus is recommended.  mounting read-only.\\n\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t} else if (test_and_clear_bit(HFSPLUS_SB_FORCE, &sbi->flags)) {\n\t\t/* nothing */\n\t} else if (vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_SOFTLOCK)) {\n\t\tpr_warn(\"Filesystem is marked locked, mounting read-only.\\n\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t} else if ((vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_JOURNALED)) &&\n\t\t\t!(sb->s_flags & MS_RDONLY)) {\n\t\tpr_warn(\"write access to a journaled filesystem is not supported, use the force option at your own risk, mounting read-only.\\n\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\n\terr = -EINVAL;\n\n\t/* Load metadata objects (B*Trees) */\n\tsbi->ext_tree = hfs_btree_open(sb, HFSPLUS_EXT_CNID);\n\tif (!sbi->ext_tree) {\n\t\tpr_err(\"failed to load extents file\\n\");\n\t\tgoto out_free_vhdr;\n\t}\n\tsbi->cat_tree = hfs_btree_open(sb, HFSPLUS_CAT_CNID);\n\tif (!sbi->cat_tree) {\n\t\tpr_err(\"failed to load catalog file\\n\");\n\t\tgoto out_close_ext_tree;\n\t}\n\tatomic_set(&sbi->attr_tree_state, HFSPLUS_EMPTY_ATTR_TREE);\n\tif (vhdr->attr_file.total_blocks != 0) {\n\t\tsbi->attr_tree = hfs_btree_open(sb, HFSPLUS_ATTR_CNID);\n\t\tif (!sbi->attr_tree) {\n\t\t\tpr_err(\"failed to load attributes file\\n\");\n\t\t\tgoto out_close_cat_tree;\n\t\t}\n\t\tatomic_set(&sbi->attr_tree_state, HFSPLUS_VALID_ATTR_TREE);\n\t}\n\tsb->s_xattr = hfsplus_xattr_handlers;\n\n\tinode = hfsplus_iget(sb, HFSPLUS_ALLOC_CNID);\n\tif (IS_ERR(inode)) {\n\t\tpr_err(\"failed to load allocation file\\n\");\n\t\terr = PTR_ERR(inode);\n\t\tgoto out_close_attr_tree;\n\t}\n\tsbi->alloc_file = inode;\n\n\t/* Load the root directory */\n\troot = hfsplus_iget(sb, HFSPLUS_ROOT_CNID);\n\tif (IS_ERR(root)) {\n\t\tpr_err(\"failed to load root directory\\n\");\n\t\terr = PTR_ERR(root);\n\t\tgoto out_put_alloc_file;\n\t}\n\n\tsb->s_d_op = &hfsplus_dentry_operations;\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_alloc_file;\n\t}\n\n\tstr.len = sizeof(HFSP_HIDDENDIR_NAME) - 1;\n\tstr.name = HFSP_HIDDENDIR_NAME;\n\terr = hfs_find_init(sbi->cat_tree, &fd);\n\tif (err)\n\t\tgoto out_put_root;\n\terr = hfsplus_cat_build_key(sb, fd.search_key, HFSPLUS_ROOT_CNID, &str);\n\tif (unlikely(err < 0))\n\t\tgoto out_put_root;\n\tif (!hfs_brec_read(&fd, &entry, sizeof(entry))) {\n\t\thfs_find_exit(&fd);\n\t\tif (entry.type != cpu_to_be16(HFSPLUS_FOLDER))\n\t\t\tgoto out_put_root;\n\t\tinode = hfsplus_iget(sb, be32_to_cpu(entry.folder.id));\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tgoto out_put_root;\n\t\t}\n\t\tsbi->hidden_dir = inode;\n\t} else\n\t\thfs_find_exit(&fd);\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t/*\n\t\t * H+LX == hfsplusutils, H+Lx == this driver, H+lx is unused\n\t\t * all three are registered with Apple for our use\n\t\t */\n\t\tvhdr->last_mount_vers = cpu_to_be32(HFSP_MOUNT_VERSION);\n\t\tvhdr->modify_date = hfsp_now2mt();\n\t\tbe32_add_cpu(&vhdr->write_count, 1);\n\t\tvhdr->attributes &= cpu_to_be32(~HFSPLUS_VOL_UNMNT);\n\t\tvhdr->attributes |= cpu_to_be32(HFSPLUS_VOL_INCNSTNT);\n\t\thfsplus_sync_fs(sb, 1);\n\n\t\tif (!sbi->hidden_dir) {\n\t\t\tmutex_lock(&sbi->vh_mutex);\n\t\t\tsbi->hidden_dir = hfsplus_new_inode(sb, S_IFDIR);\n\t\t\tif (!sbi->hidden_dir) {\n\t\t\t\tmutex_unlock(&sbi->vh_mutex);\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out_put_root;\n\t\t\t}\n\t\t\terr = hfsplus_create_cat(sbi->hidden_dir->i_ino, root,\n\t\t\t\t\t\t &str, sbi->hidden_dir);\n\t\t\tif (err) {\n\t\t\t\tmutex_unlock(&sbi->vh_mutex);\n\t\t\t\tgoto out_put_hidden_dir;\n\t\t\t}\n\n\t\t\terr = hfsplus_init_inode_security(sbi->hidden_dir,\n\t\t\t\t\t\t\t\troot, &str);\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\terr = 0; /* Operation is not supported. */\n\t\t\telse if (err) {\n\t\t\t\t/*\n\t\t\t\t * Try to delete anyway without\n\t\t\t\t * error analysis.\n\t\t\t\t */\n\t\t\t\thfsplus_delete_cat(sbi->hidden_dir->i_ino,\n\t\t\t\t\t\t\troot, &str);\n\t\t\t\tmutex_unlock(&sbi->vh_mutex);\n\t\t\t\tgoto out_put_hidden_dir;\n\t\t\t}\n\n\t\t\tmutex_unlock(&sbi->vh_mutex);\n\t\t\thfsplus_mark_inode_dirty(sbi->hidden_dir,\n\t\t\t\t\t\t HFSPLUS_I_CAT_DIRTY);\n\t\t}\n\t}\n\n\tunload_nls(sbi->nls);\n\tsbi->nls = nls;\n\treturn 0;\n\nout_put_hidden_dir:\n\tiput(sbi->hidden_dir);\nout_put_root:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nout_put_alloc_file:\n\tiput(sbi->alloc_file);\nout_close_attr_tree:\n\thfs_btree_close(sbi->attr_tree);\nout_close_cat_tree:\n\thfs_btree_close(sbi->cat_tree);\nout_close_ext_tree:\n\thfs_btree_close(sbi->ext_tree);\nout_free_vhdr:\n\tkfree(sbi->s_vhdr_buf);\n\tkfree(sbi->s_backup_vhdr_buf);\nout_unload_nls:\n\tunload_nls(sbi->nls);\n\tunload_nls(nls);\n\tkfree(sbi);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "hfsplus_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
    "lines": "325-356",
    "snippet": "static int hfsplus_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\tif ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))\n\t\treturn 0;\n\tif (!(*flags & MS_RDONLY)) {\n\t\tstruct hfsplus_vh *vhdr = HFSPLUS_SB(sb)->s_vhdr;\n\t\tint force = 0;\n\n\t\tif (!hfsplus_parse_options_remount(data, &force))\n\t\t\treturn -EINVAL;\n\n\t\tif (!(vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_UNMNT))) {\n\t\t\tpr_warn(\"filesystem was not cleanly unmounted, running fsck.hfsplus is recommended.  leaving read-only.\\n\");\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t\t*flags |= MS_RDONLY;\n\t\t} else if (force) {\n\t\t\t/* nothing */\n\t\t} else if (vhdr->attributes &\n\t\t\t\tcpu_to_be32(HFSPLUS_VOL_SOFTLOCK)) {\n\t\t\tpr_warn(\"filesystem is marked locked, leaving read-only.\\n\");\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t\t*flags |= MS_RDONLY;\n\t\t} else if (vhdr->attributes &\n\t\t\t\tcpu_to_be32(HFSPLUS_VOL_JOURNALED)) {\n\t\t\tpr_warn(\"filesystem is marked journaled, leaving read-only.\\n\");\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t\t*flags |= MS_RDONLY;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *hfsplus_alloc_inode(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"filesystem is marked journaled, leaving read-only.\\n\""
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "HFSPLUS_VOL_JOURNALED"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"filesystem is marked locked, leaving read-only.\\n\""
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "HFSPLUS_VOL_SOFTLOCK"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"filesystem was not cleanly unmounted, running fsck.hfsplus is recommended.  leaving read-only.\\n\""
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "HFSPLUS_VOL_UNMNT"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_parse_options_remount",
          "args": [
            "data",
            "&force"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_parse_options_remount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/options.c",
          "lines": "71-95",
          "snippet": "int hfsplus_parse_options_remount(char *input, int *force)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\n\tif (!input)\n\t\treturn 1;\n\n\twhile ((p = strsep(&input, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase opt_force:\n\t\t\t*force = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/nls.h>",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{ opt_creator, \"creator=%s\" },\n\t{ opt_type, \"type=%s\" },\n\t{ opt_umask, \"umask=%o\" },\n\t{ opt_uid, \"uid=%u\" },\n\t{ opt_gid, \"gid=%u\" },\n\t{ opt_part, \"part=%u\" },\n\t{ opt_session, \"session=%u\" },\n\t{ opt_nls, \"nls=%s\" },\n\t{ opt_decompose, \"decompose\" },\n\t{ opt_nodecompose, \"nodecompose\" },\n\t{ opt_barrier, \"barrier\" },\n\t{ opt_nobarrier, \"nobarrier\" },\n\t{ opt_force, \"force\" },\n\t{ opt_err, NULL }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/nls.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nstatic const match_table_t tokens = {\n\t{ opt_creator, \"creator=%s\" },\n\t{ opt_type, \"type=%s\" },\n\t{ opt_umask, \"umask=%o\" },\n\t{ opt_uid, \"uid=%u\" },\n\t{ opt_gid, \"gid=%u\" },\n\t{ opt_part, \"part=%u\" },\n\t{ opt_session, \"session=%u\" },\n\t{ opt_nls, \"nls=%s\" },\n\t{ opt_decompose, \"decompose\" },\n\t{ opt_nodecompose, \"nodecompose\" },\n\t{ opt_barrier, \"barrier\" },\n\t{ opt_nobarrier, \"nobarrier\" },\n\t{ opt_force, \"force\" },\n\t{ opt_err, NULL }\n};\n\nint hfsplus_parse_options_remount(char *input, int *force)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\n\tif (!input)\n\t\treturn 1;\n\n\twhile ((p = strsep(&input, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase opt_force:\n\t\t\t*force = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct inode *hfsplus_alloc_inode(struct super_block *sb);\n\nstatic int hfsplus_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\tif ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))\n\t\treturn 0;\n\tif (!(*flags & MS_RDONLY)) {\n\t\tstruct hfsplus_vh *vhdr = HFSPLUS_SB(sb)->s_vhdr;\n\t\tint force = 0;\n\n\t\tif (!hfsplus_parse_options_remount(data, &force))\n\t\t\treturn -EINVAL;\n\n\t\tif (!(vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_UNMNT))) {\n\t\t\tpr_warn(\"filesystem was not cleanly unmounted, running fsck.hfsplus is recommended.  leaving read-only.\\n\");\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t\t*flags |= MS_RDONLY;\n\t\t} else if (force) {\n\t\t\t/* nothing */\n\t\t} else if (vhdr->attributes &\n\t\t\t\tcpu_to_be32(HFSPLUS_VOL_SOFTLOCK)) {\n\t\t\tpr_warn(\"filesystem is marked locked, leaving read-only.\\n\");\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t\t*flags |= MS_RDONLY;\n\t\t} else if (vhdr->attributes &\n\t\t\t\tcpu_to_be32(HFSPLUS_VOL_JOURNALED)) {\n\t\t\tpr_warn(\"filesystem is marked journaled, leaving read-only.\\n\");\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t\t*flags |= MS_RDONLY;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "hfsplus_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
    "lines": "305-323",
    "snippet": "static int hfsplus_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbuf->f_type = HFSPLUS_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = sbi->total_blocks << sbi->fs_shift;\n\tbuf->f_bfree = sbi->free_blocks << sbi->fs_shift;\n\tbuf->f_bavail = buf->f_bfree;\n\tbuf->f_files = 0xFFFFFFFF;\n\tbuf->f_ffree = 0xFFFFFFFF - sbi->next_cnid;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\tbuf->f_namelen = HFSPLUS_MAX_STRLEN;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *hfsplus_alloc_inode(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "id >> 32"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_encode_dev",
          "args": [
            "sb->s_bdev->bd_dev"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct inode *hfsplus_alloc_inode(struct super_block *sb);\n\nstatic int hfsplus_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbuf->f_type = HFSPLUS_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = sbi->total_blocks << sbi->fs_shift;\n\tbuf->f_bfree = sbi->free_blocks << sbi->fs_shift;\n\tbuf->f_bavail = buf->f_bfree;\n\tbuf->f_files = 0xFFFFFFFF;\n\tbuf->f_ffree = 0xFFFFFFFF - sbi->next_cnid;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\tbuf->f_namelen = HFSPLUS_MAX_STRLEN;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hfsplus_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
    "lines": "275-303",
    "snippet": "static void hfsplus_put_super(struct super_block *sb)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\n\thfs_dbg(SUPER, \"hfsplus_put_super\\n\");\n\n\tcancel_delayed_work_sync(&sbi->sync_work);\n\n\tif (!(sb->s_flags & MS_RDONLY) && sbi->s_vhdr) {\n\t\tstruct hfsplus_vh *vhdr = sbi->s_vhdr;\n\n\t\tvhdr->modify_date = hfsp_now2mt();\n\t\tvhdr->attributes |= cpu_to_be32(HFSPLUS_VOL_UNMNT);\n\t\tvhdr->attributes &= cpu_to_be32(~HFSPLUS_VOL_INCNSTNT);\n\n\t\thfsplus_sync_fs(sb, 1);\n\t}\n\n\thfs_btree_close(sbi->attr_tree);\n\thfs_btree_close(sbi->cat_tree);\n\thfs_btree_close(sbi->ext_tree);\n\tiput(sbi->alloc_file);\n\tiput(sbi->hidden_dir);\n\tkfree(sbi->s_vhdr_buf);\n\tkfree(sbi->s_backup_vhdr_buf);\n\tunload_nls(sbi->nls);\n\tkfree(sb->s_fs_info);\n\tsb->s_fs_info = NULL;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *hfsplus_alloc_inode(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sb->s_fs_info"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unload_nls",
          "args": [
            "sbi->nls"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "unload_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "296-300",
          "snippet": "void unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_backup_vhdr_buf"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_vhdr_buf"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "sbi->hidden_dir"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_btree_close",
          "args": [
            "sbi->ext_tree"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_btree_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/btree.c",
          "lines": "257-279",
          "snippet": "void hfs_btree_close(struct hfs_btree *tree)\n{\n\tstruct hfs_bnode *node;\n\tint i;\n\n\tif (!tree)\n\t\treturn;\n\n\tfor (i = 0; i < NODE_HASH_SIZE; i++) {\n\t\twhile ((node = tree->node_hash[i])) {\n\t\t\ttree->node_hash[i] = node->next_hash;\n\t\t\tif (atomic_read(&node->refcnt))\n\t\t\t\tpr_crit(\"node %d:%d \"\n\t\t\t\t\t\t\"still has %d user(s)!\\n\",\n\t\t\t\t\tnode->tree->cnid, node->this,\n\t\t\t\t\tatomic_read(&node->refcnt));\n\t\t\thfs_bnode_free(node);\n\t\t\ttree->node_hash_cnt--;\n\t\t}\n\t}\n\tiput(tree->inode);\n\tkfree(tree);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/log2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/log2.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nvoid hfs_btree_close(struct hfs_btree *tree)\n{\n\tstruct hfs_bnode *node;\n\tint i;\n\n\tif (!tree)\n\t\treturn;\n\n\tfor (i = 0; i < NODE_HASH_SIZE; i++) {\n\t\twhile ((node = tree->node_hash[i])) {\n\t\t\ttree->node_hash[i] = node->next_hash;\n\t\t\tif (atomic_read(&node->refcnt))\n\t\t\t\tpr_crit(\"node %d:%d \"\n\t\t\t\t\t\t\"still has %d user(s)!\\n\",\n\t\t\t\t\tnode->tree->cnid, node->this,\n\t\t\t\t\tatomic_read(&node->refcnt));\n\t\t\thfs_bnode_free(node);\n\t\t\ttree->node_hash_cnt--;\n\t\t}\n\t}\n\tiput(tree->inode);\n\tkfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_sync_fs",
          "args": [
            "sb",
            "1"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_sync_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
          "lines": "173-240",
          "snippet": "static int hfsplus_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_vh *vhdr = sbi->s_vhdr;\n\tint write_backup = 0;\n\tint error, error2;\n\n\tif (!wait)\n\t\treturn 0;\n\n\thfs_dbg(SUPER, \"hfsplus_sync_fs\\n\");\n\n\t/*\n\t * Explicitly write out the special metadata inodes.\n\t *\n\t * While these special inodes are marked as hashed and written\n\t * out peridocically by the flusher threads we redirty them\n\t * during writeout of normal inodes, and thus the life lock\n\t * prevents us from getting the latest state to disk.\n\t */\n\terror = filemap_write_and_wait(sbi->cat_tree->inode->i_mapping);\n\terror2 = filemap_write_and_wait(sbi->ext_tree->inode->i_mapping);\n\tif (!error)\n\t\terror = error2;\n\tif (sbi->attr_tree) {\n\t\terror2 =\n\t\t    filemap_write_and_wait(sbi->attr_tree->inode->i_mapping);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\terror2 = filemap_write_and_wait(sbi->alloc_file->i_mapping);\n\tif (!error)\n\t\terror = error2;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tmutex_lock(&sbi->alloc_mutex);\n\tvhdr->free_blocks = cpu_to_be32(sbi->free_blocks);\n\tvhdr->next_cnid = cpu_to_be32(sbi->next_cnid);\n\tvhdr->folder_count = cpu_to_be32(sbi->folder_count);\n\tvhdr->file_count = cpu_to_be32(sbi->file_count);\n\n\tif (test_and_clear_bit(HFSPLUS_SB_WRITEBACKUP, &sbi->flags)) {\n\t\tmemcpy(sbi->s_backup_vhdr, sbi->s_vhdr, sizeof(*sbi->s_vhdr));\n\t\twrite_backup = 1;\n\t}\n\n\terror2 = hfsplus_submit_bio(sb,\n\t\t\t\t   sbi->part_start + HFSPLUS_VOLHEAD_SECTOR,\n\t\t\t\t   sbi->s_vhdr_buf, NULL, WRITE_SYNC);\n\tif (!error)\n\t\terror = error2;\n\tif (!write_backup)\n\t\tgoto out;\n\n\terror2 = hfsplus_submit_bio(sb,\n\t\t\t\t  sbi->part_start + sbi->sect_count - 2,\n\t\t\t\t  sbi->s_backup_vhdr_buf, NULL, WRITE_SYNC);\n\tif (!error)\n\t\terror2 = error;\nout:\n\tmutex_unlock(&sbi->alloc_mutex);\n\tmutex_unlock(&sbi->vh_mutex);\n\n\tif (!test_bit(HFSPLUS_SB_NOBARRIER, &sbi->flags))\n\t\tblkdev_issue_flush(sb->s_bdev, GFP_KERNEL, NULL);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode *hfsplus_alloc_inode(struct super_block *sb);",
            "static void hfsplus_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct inode *hfsplus_alloc_inode(struct super_block *sb);\nstatic void hfsplus_destroy_inode(struct inode *inode);\n\nstatic int hfsplus_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_vh *vhdr = sbi->s_vhdr;\n\tint write_backup = 0;\n\tint error, error2;\n\n\tif (!wait)\n\t\treturn 0;\n\n\thfs_dbg(SUPER, \"hfsplus_sync_fs\\n\");\n\n\t/*\n\t * Explicitly write out the special metadata inodes.\n\t *\n\t * While these special inodes are marked as hashed and written\n\t * out peridocically by the flusher threads we redirty them\n\t * during writeout of normal inodes, and thus the life lock\n\t * prevents us from getting the latest state to disk.\n\t */\n\terror = filemap_write_and_wait(sbi->cat_tree->inode->i_mapping);\n\terror2 = filemap_write_and_wait(sbi->ext_tree->inode->i_mapping);\n\tif (!error)\n\t\terror = error2;\n\tif (sbi->attr_tree) {\n\t\terror2 =\n\t\t    filemap_write_and_wait(sbi->attr_tree->inode->i_mapping);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\terror2 = filemap_write_and_wait(sbi->alloc_file->i_mapping);\n\tif (!error)\n\t\terror = error2;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tmutex_lock(&sbi->alloc_mutex);\n\tvhdr->free_blocks = cpu_to_be32(sbi->free_blocks);\n\tvhdr->next_cnid = cpu_to_be32(sbi->next_cnid);\n\tvhdr->folder_count = cpu_to_be32(sbi->folder_count);\n\tvhdr->file_count = cpu_to_be32(sbi->file_count);\n\n\tif (test_and_clear_bit(HFSPLUS_SB_WRITEBACKUP, &sbi->flags)) {\n\t\tmemcpy(sbi->s_backup_vhdr, sbi->s_vhdr, sizeof(*sbi->s_vhdr));\n\t\twrite_backup = 1;\n\t}\n\n\terror2 = hfsplus_submit_bio(sb,\n\t\t\t\t   sbi->part_start + HFSPLUS_VOLHEAD_SECTOR,\n\t\t\t\t   sbi->s_vhdr_buf, NULL, WRITE_SYNC);\n\tif (!error)\n\t\terror = error2;\n\tif (!write_backup)\n\t\tgoto out;\n\n\terror2 = hfsplus_submit_bio(sb,\n\t\t\t\t  sbi->part_start + sbi->sect_count - 2,\n\t\t\t\t  sbi->s_backup_vhdr_buf, NULL, WRITE_SYNC);\n\tif (!error)\n\t\terror2 = error;\nout:\n\tmutex_unlock(&sbi->alloc_mutex);\n\tmutex_unlock(&sbi->vh_mutex);\n\n\tif (!test_bit(HFSPLUS_SB_NOBARRIER, &sbi->flags))\n\t\tblkdev_issue_flush(sb->s_bdev, GFP_KERNEL, NULL);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "~HFSPLUS_VOL_INCNSTNT"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "HFSPLUS_VOL_UNMNT"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsp_now2mt",
          "args": [],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&sbi->sync_work"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "SUPER",
            "\"hfsplus_put_super\\n\""
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct inode *hfsplus_alloc_inode(struct super_block *sb);\n\nstatic void hfsplus_put_super(struct super_block *sb)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\n\thfs_dbg(SUPER, \"hfsplus_put_super\\n\");\n\n\tcancel_delayed_work_sync(&sbi->sync_work);\n\n\tif (!(sb->s_flags & MS_RDONLY) && sbi->s_vhdr) {\n\t\tstruct hfsplus_vh *vhdr = sbi->s_vhdr;\n\n\t\tvhdr->modify_date = hfsp_now2mt();\n\t\tvhdr->attributes |= cpu_to_be32(HFSPLUS_VOL_UNMNT);\n\t\tvhdr->attributes &= cpu_to_be32(~HFSPLUS_VOL_INCNSTNT);\n\n\t\thfsplus_sync_fs(sb, 1);\n\t}\n\n\thfs_btree_close(sbi->attr_tree);\n\thfs_btree_close(sbi->cat_tree);\n\thfs_btree_close(sbi->ext_tree);\n\tiput(sbi->alloc_file);\n\tiput(sbi->hidden_dir);\n\tkfree(sbi->s_vhdr_buf);\n\tkfree(sbi->s_backup_vhdr_buf);\n\tunload_nls(sbi->nls);\n\tkfree(sb->s_fs_info);\n\tsb->s_fs_info = NULL;\n}"
  },
  {
    "function_name": "hfsplus_mark_mdb_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
    "lines": "258-273",
    "snippet": "void hfsplus_mark_mdb_dirty(struct super_block *sb)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tunsigned long delay;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *hfsplus_alloc_inode(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->work_lock"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "system_long_wq",
            "&sbi->sync_work",
            "delay"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "dirty_writeback_interval * 10"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->work_lock"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct inode *hfsplus_alloc_inode(struct super_block *sb);\n\nvoid hfsplus_mark_mdb_dirty(struct super_block *sb)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tunsigned long delay;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}"
  },
  {
    "function_name": "delayed_sync_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
    "lines": "242-256",
    "snippet": "static void delayed_sync_fs(struct work_struct *work)\n{\n\tint err;\n\tstruct hfsplus_sb_info *sbi;\n\n\tsbi = container_of(work, struct hfsplus_sb_info, sync_work.work);\n\n\tspin_lock(&sbi->work_lock);\n\tsbi->work_queued = 0;\n\tspin_unlock(&sbi->work_lock);\n\n\terr = hfsplus_sync_fs(sbi->alloc_file->i_sb, 1);\n\tif (err)\n\t\tpr_err(\"delayed sync fs err %d\\n\", err);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"delayed sync fs err %d\\n\"",
            "err"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_sync_fs",
          "args": [
            "sbi->alloc_file->i_sb",
            "1"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_sync_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
          "lines": "173-240",
          "snippet": "static int hfsplus_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_vh *vhdr = sbi->s_vhdr;\n\tint write_backup = 0;\n\tint error, error2;\n\n\tif (!wait)\n\t\treturn 0;\n\n\thfs_dbg(SUPER, \"hfsplus_sync_fs\\n\");\n\n\t/*\n\t * Explicitly write out the special metadata inodes.\n\t *\n\t * While these special inodes are marked as hashed and written\n\t * out peridocically by the flusher threads we redirty them\n\t * during writeout of normal inodes, and thus the life lock\n\t * prevents us from getting the latest state to disk.\n\t */\n\terror = filemap_write_and_wait(sbi->cat_tree->inode->i_mapping);\n\terror2 = filemap_write_and_wait(sbi->ext_tree->inode->i_mapping);\n\tif (!error)\n\t\terror = error2;\n\tif (sbi->attr_tree) {\n\t\terror2 =\n\t\t    filemap_write_and_wait(sbi->attr_tree->inode->i_mapping);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\terror2 = filemap_write_and_wait(sbi->alloc_file->i_mapping);\n\tif (!error)\n\t\terror = error2;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tmutex_lock(&sbi->alloc_mutex);\n\tvhdr->free_blocks = cpu_to_be32(sbi->free_blocks);\n\tvhdr->next_cnid = cpu_to_be32(sbi->next_cnid);\n\tvhdr->folder_count = cpu_to_be32(sbi->folder_count);\n\tvhdr->file_count = cpu_to_be32(sbi->file_count);\n\n\tif (test_and_clear_bit(HFSPLUS_SB_WRITEBACKUP, &sbi->flags)) {\n\t\tmemcpy(sbi->s_backup_vhdr, sbi->s_vhdr, sizeof(*sbi->s_vhdr));\n\t\twrite_backup = 1;\n\t}\n\n\terror2 = hfsplus_submit_bio(sb,\n\t\t\t\t   sbi->part_start + HFSPLUS_VOLHEAD_SECTOR,\n\t\t\t\t   sbi->s_vhdr_buf, NULL, WRITE_SYNC);\n\tif (!error)\n\t\terror = error2;\n\tif (!write_backup)\n\t\tgoto out;\n\n\terror2 = hfsplus_submit_bio(sb,\n\t\t\t\t  sbi->part_start + sbi->sect_count - 2,\n\t\t\t\t  sbi->s_backup_vhdr_buf, NULL, WRITE_SYNC);\n\tif (!error)\n\t\terror2 = error;\nout:\n\tmutex_unlock(&sbi->alloc_mutex);\n\tmutex_unlock(&sbi->vh_mutex);\n\n\tif (!test_bit(HFSPLUS_SB_NOBARRIER, &sbi->flags))\n\t\tblkdev_issue_flush(sb->s_bdev, GFP_KERNEL, NULL);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode *hfsplus_alloc_inode(struct super_block *sb);",
            "static void hfsplus_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct inode *hfsplus_alloc_inode(struct super_block *sb);\nstatic void hfsplus_destroy_inode(struct inode *inode);\n\nstatic int hfsplus_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_vh *vhdr = sbi->s_vhdr;\n\tint write_backup = 0;\n\tint error, error2;\n\n\tif (!wait)\n\t\treturn 0;\n\n\thfs_dbg(SUPER, \"hfsplus_sync_fs\\n\");\n\n\t/*\n\t * Explicitly write out the special metadata inodes.\n\t *\n\t * While these special inodes are marked as hashed and written\n\t * out peridocically by the flusher threads we redirty them\n\t * during writeout of normal inodes, and thus the life lock\n\t * prevents us from getting the latest state to disk.\n\t */\n\terror = filemap_write_and_wait(sbi->cat_tree->inode->i_mapping);\n\terror2 = filemap_write_and_wait(sbi->ext_tree->inode->i_mapping);\n\tif (!error)\n\t\terror = error2;\n\tif (sbi->attr_tree) {\n\t\terror2 =\n\t\t    filemap_write_and_wait(sbi->attr_tree->inode->i_mapping);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\terror2 = filemap_write_and_wait(sbi->alloc_file->i_mapping);\n\tif (!error)\n\t\terror = error2;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tmutex_lock(&sbi->alloc_mutex);\n\tvhdr->free_blocks = cpu_to_be32(sbi->free_blocks);\n\tvhdr->next_cnid = cpu_to_be32(sbi->next_cnid);\n\tvhdr->folder_count = cpu_to_be32(sbi->folder_count);\n\tvhdr->file_count = cpu_to_be32(sbi->file_count);\n\n\tif (test_and_clear_bit(HFSPLUS_SB_WRITEBACKUP, &sbi->flags)) {\n\t\tmemcpy(sbi->s_backup_vhdr, sbi->s_vhdr, sizeof(*sbi->s_vhdr));\n\t\twrite_backup = 1;\n\t}\n\n\terror2 = hfsplus_submit_bio(sb,\n\t\t\t\t   sbi->part_start + HFSPLUS_VOLHEAD_SECTOR,\n\t\t\t\t   sbi->s_vhdr_buf, NULL, WRITE_SYNC);\n\tif (!error)\n\t\terror = error2;\n\tif (!write_backup)\n\t\tgoto out;\n\n\terror2 = hfsplus_submit_bio(sb,\n\t\t\t\t  sbi->part_start + sbi->sect_count - 2,\n\t\t\t\t  sbi->s_backup_vhdr_buf, NULL, WRITE_SYNC);\n\tif (!error)\n\t\terror2 = error;\nout:\n\tmutex_unlock(&sbi->alloc_mutex);\n\tmutex_unlock(&sbi->vh_mutex);\n\n\tif (!test_bit(HFSPLUS_SB_NOBARRIER, &sbi->flags))\n\t\tblkdev_issue_flush(sb->s_bdev, GFP_KERNEL, NULL);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->work_lock"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->work_lock"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structhfsplus_sb_info",
            "sync_work.work"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void delayed_sync_fs(struct work_struct *work)\n{\n\tint err;\n\tstruct hfsplus_sb_info *sbi;\n\n\tsbi = container_of(work, struct hfsplus_sb_info, sync_work.work);\n\n\tspin_lock(&sbi->work_lock);\n\tsbi->work_queued = 0;\n\tspin_unlock(&sbi->work_lock);\n\n\terr = hfsplus_sync_fs(sbi->alloc_file->i_sb, 1);\n\tif (err)\n\t\tpr_err(\"delayed sync fs err %d\\n\", err);\n}"
  },
  {
    "function_name": "hfsplus_sync_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
    "lines": "173-240",
    "snippet": "static int hfsplus_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_vh *vhdr = sbi->s_vhdr;\n\tint write_backup = 0;\n\tint error, error2;\n\n\tif (!wait)\n\t\treturn 0;\n\n\thfs_dbg(SUPER, \"hfsplus_sync_fs\\n\");\n\n\t/*\n\t * Explicitly write out the special metadata inodes.\n\t *\n\t * While these special inodes are marked as hashed and written\n\t * out peridocically by the flusher threads we redirty them\n\t * during writeout of normal inodes, and thus the life lock\n\t * prevents us from getting the latest state to disk.\n\t */\n\terror = filemap_write_and_wait(sbi->cat_tree->inode->i_mapping);\n\terror2 = filemap_write_and_wait(sbi->ext_tree->inode->i_mapping);\n\tif (!error)\n\t\terror = error2;\n\tif (sbi->attr_tree) {\n\t\terror2 =\n\t\t    filemap_write_and_wait(sbi->attr_tree->inode->i_mapping);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\terror2 = filemap_write_and_wait(sbi->alloc_file->i_mapping);\n\tif (!error)\n\t\terror = error2;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tmutex_lock(&sbi->alloc_mutex);\n\tvhdr->free_blocks = cpu_to_be32(sbi->free_blocks);\n\tvhdr->next_cnid = cpu_to_be32(sbi->next_cnid);\n\tvhdr->folder_count = cpu_to_be32(sbi->folder_count);\n\tvhdr->file_count = cpu_to_be32(sbi->file_count);\n\n\tif (test_and_clear_bit(HFSPLUS_SB_WRITEBACKUP, &sbi->flags)) {\n\t\tmemcpy(sbi->s_backup_vhdr, sbi->s_vhdr, sizeof(*sbi->s_vhdr));\n\t\twrite_backup = 1;\n\t}\n\n\terror2 = hfsplus_submit_bio(sb,\n\t\t\t\t   sbi->part_start + HFSPLUS_VOLHEAD_SECTOR,\n\t\t\t\t   sbi->s_vhdr_buf, NULL, WRITE_SYNC);\n\tif (!error)\n\t\terror = error2;\n\tif (!write_backup)\n\t\tgoto out;\n\n\terror2 = hfsplus_submit_bio(sb,\n\t\t\t\t  sbi->part_start + sbi->sect_count - 2,\n\t\t\t\t  sbi->s_backup_vhdr_buf, NULL, WRITE_SYNC);\n\tif (!error)\n\t\terror2 = error;\nout:\n\tmutex_unlock(&sbi->alloc_mutex);\n\tmutex_unlock(&sbi->vh_mutex);\n\n\tif (!test_bit(HFSPLUS_SB_NOBARRIER, &sbi->flags))\n\t\tblkdev_issue_flush(sb->s_bdev, GFP_KERNEL, NULL);\n\n\treturn error;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *hfsplus_alloc_inode(struct super_block *sb);",
      "static void hfsplus_destroy_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_issue_flush",
          "args": [
            "sb->s_bdev",
            "GFP_KERNEL",
            "NULL"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "HFSPLUS_SB_NOBARRIER",
            "&sbi->flags"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->vh_mutex"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->alloc_mutex"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_submit_bio",
          "args": [
            "sb",
            "sbi->part_start + sbi->sect_count - 2",
            "sbi->s_backup_vhdr_buf",
            "NULL",
            "WRITE_SYNC"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/wrapper.c",
          "lines": "46-90",
          "snippet": "int hfsplus_submit_bio(struct super_block *sb, sector_t sector,\n\t\tvoid *buf, void **data, int rw)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\tu64 io_size;\n\tloff_t start;\n\tint offset;\n\n\t/*\n\t * Align sector to hardware sector size and find offset. We\n\t * assume that io_size is a power of two, which _should_\n\t * be true.\n\t */\n\tio_size = hfsplus_min_io_size(sb);\n\tstart = (loff_t)sector << HFSPLUS_SECTOR_SHIFT;\n\toffset = start & (io_size - 1);\n\tsector &= ~((io_size >> HFSPLUS_SECTOR_SHIFT) - 1);\n\n\tbio = bio_alloc(GFP_NOIO, 1);\n\tbio->bi_iter.bi_sector = sector;\n\tbio->bi_bdev = sb->s_bdev;\n\n\tif (!(rw & WRITE) && data)\n\t\t*data = (u8 *)buf + offset;\n\n\twhile (io_size > 0) {\n\t\tunsigned int page_offset = offset_in_page(buf);\n\t\tunsigned int len = min_t(unsigned int, PAGE_SIZE - page_offset,\n\t\t\t\t\t io_size);\n\n\t\tret = bio_add_page(bio, virt_to_page(buf), len, page_offset);\n\t\tif (ret != len) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tio_size -= len;\n\t\tbuf = (u8 *)buf + len;\n\t}\n\n\tret = submit_bio_wait(rw, bio);\nout:\n\tbio_put(bio);\n\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/genhd.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <asm/unaligned.h>\n#include <linux/genhd.h>\n#include <linux/cdrom.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint hfsplus_submit_bio(struct super_block *sb, sector_t sector,\n\t\tvoid *buf, void **data, int rw)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\tu64 io_size;\n\tloff_t start;\n\tint offset;\n\n\t/*\n\t * Align sector to hardware sector size and find offset. We\n\t * assume that io_size is a power of two, which _should_\n\t * be true.\n\t */\n\tio_size = hfsplus_min_io_size(sb);\n\tstart = (loff_t)sector << HFSPLUS_SECTOR_SHIFT;\n\toffset = start & (io_size - 1);\n\tsector &= ~((io_size >> HFSPLUS_SECTOR_SHIFT) - 1);\n\n\tbio = bio_alloc(GFP_NOIO, 1);\n\tbio->bi_iter.bi_sector = sector;\n\tbio->bi_bdev = sb->s_bdev;\n\n\tif (!(rw & WRITE) && data)\n\t\t*data = (u8 *)buf + offset;\n\n\twhile (io_size > 0) {\n\t\tunsigned int page_offset = offset_in_page(buf);\n\t\tunsigned int len = min_t(unsigned int, PAGE_SIZE - page_offset,\n\t\t\t\t\t io_size);\n\n\t\tret = bio_add_page(bio, virt_to_page(buf), len, page_offset);\n\t\tif (ret != len) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tio_size -= len;\n\t\tbuf = (u8 *)buf + len;\n\t}\n\n\tret = submit_bio_wait(rw, bio);\nout:\n\tbio_put(bio);\n\treturn ret < 0 ? ret : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sbi->s_backup_vhdr",
            "sbi->s_vhdr",
            "sizeof(*sbi->s_vhdr)"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "HFSPLUS_SB_WRITEBACKUP",
            "&sbi->flags"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sbi->file_count"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sbi->folder_count"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sbi->next_cnid"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sbi->free_blocks"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->alloc_mutex"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->vh_mutex"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "sbi->alloc_file->i_mapping"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "sbi->attr_tree->inode->i_mapping"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "sbi->ext_tree->inode->i_mapping"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "sbi->cat_tree->inode->i_mapping"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "SUPER",
            "\"hfsplus_sync_fs\\n\""
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct inode *hfsplus_alloc_inode(struct super_block *sb);\nstatic void hfsplus_destroy_inode(struct inode *inode);\n\nstatic int hfsplus_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_vh *vhdr = sbi->s_vhdr;\n\tint write_backup = 0;\n\tint error, error2;\n\n\tif (!wait)\n\t\treturn 0;\n\n\thfs_dbg(SUPER, \"hfsplus_sync_fs\\n\");\n\n\t/*\n\t * Explicitly write out the special metadata inodes.\n\t *\n\t * While these special inodes are marked as hashed and written\n\t * out peridocically by the flusher threads we redirty them\n\t * during writeout of normal inodes, and thus the life lock\n\t * prevents us from getting the latest state to disk.\n\t */\n\terror = filemap_write_and_wait(sbi->cat_tree->inode->i_mapping);\n\terror2 = filemap_write_and_wait(sbi->ext_tree->inode->i_mapping);\n\tif (!error)\n\t\terror = error2;\n\tif (sbi->attr_tree) {\n\t\terror2 =\n\t\t    filemap_write_and_wait(sbi->attr_tree->inode->i_mapping);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\terror2 = filemap_write_and_wait(sbi->alloc_file->i_mapping);\n\tif (!error)\n\t\terror = error2;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tmutex_lock(&sbi->alloc_mutex);\n\tvhdr->free_blocks = cpu_to_be32(sbi->free_blocks);\n\tvhdr->next_cnid = cpu_to_be32(sbi->next_cnid);\n\tvhdr->folder_count = cpu_to_be32(sbi->folder_count);\n\tvhdr->file_count = cpu_to_be32(sbi->file_count);\n\n\tif (test_and_clear_bit(HFSPLUS_SB_WRITEBACKUP, &sbi->flags)) {\n\t\tmemcpy(sbi->s_backup_vhdr, sbi->s_vhdr, sizeof(*sbi->s_vhdr));\n\t\twrite_backup = 1;\n\t}\n\n\terror2 = hfsplus_submit_bio(sb,\n\t\t\t\t   sbi->part_start + HFSPLUS_VOLHEAD_SECTOR,\n\t\t\t\t   sbi->s_vhdr_buf, NULL, WRITE_SYNC);\n\tif (!error)\n\t\terror = error2;\n\tif (!write_backup)\n\t\tgoto out;\n\n\terror2 = hfsplus_submit_bio(sb,\n\t\t\t\t  sbi->part_start + sbi->sect_count - 2,\n\t\t\t\t  sbi->s_backup_vhdr_buf, NULL, WRITE_SYNC);\n\tif (!error)\n\t\terror2 = error;\nout:\n\tmutex_unlock(&sbi->alloc_mutex);\n\tmutex_unlock(&sbi->vh_mutex);\n\n\tif (!test_bit(HFSPLUS_SB_NOBARRIER, &sbi->flags))\n\t\tblkdev_issue_flush(sb->s_bdev, GFP_KERNEL, NULL);\n\n\treturn error;\n}"
  },
  {
    "function_name": "hfsplus_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
    "lines": "162-171",
    "snippet": "static void hfsplus_evict_inode(struct inode *inode)\n{\n\thfs_dbg(INODE, \"hfsplus_evict_inode: %lu\\n\", inode->i_ino);\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tif (HFSPLUS_IS_RSRC(inode)) {\n\t\tHFSPLUS_I(HFSPLUS_I(inode)->rsrc_inode)->rsrc_inode = NULL;\n\t\tiput(HFSPLUS_I(inode)->rsrc_inode);\n\t}\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void hfsplus_destroy_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "HFSPLUS_I(inode)->rsrc_inode"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_IS_RSRC",
          "args": [
            "inode"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "960-973",
          "snippet": "void ext4_clear_inode(struct inode *inode)\n{\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\tdquot_drop(inode);\n\text4_discard_preallocations(inode);\n\text4_es_remove_extent(inode, 0, EXT_MAX_BLOCKS);\n\tif (EXT4_I(inode)->jinode) {\n\t\tjbd2_journal_release_jbd_inode(EXT4_JOURNAL(inode),\n\t\t\t\t\t       EXT4_I(inode)->jinode);\n\t\tjbd2_free_inode(EXT4_I(inode)->jinode);\n\t\tEXT4_I(inode)->jinode = NULL;\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid ext4_clear_inode(struct inode *inode)\n{\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\tdquot_drop(inode);\n\text4_discard_preallocations(inode);\n\text4_es_remove_extent(inode, 0, EXT_MAX_BLOCKS);\n\tif (EXT4_I(inode)->jinode) {\n\t\tjbd2_journal_release_jbd_inode(EXT4_JOURNAL(inode),\n\t\t\t\t\t       EXT4_I(inode)->jinode);\n\t\tjbd2_free_inode(EXT4_I(inode)->jinode);\n\t\tEXT4_I(inode)->jinode = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "INODE",
            "\"hfsplus_evict_inode: %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void hfsplus_destroy_inode(struct inode *inode);\n\nstatic void hfsplus_evict_inode(struct inode *inode)\n{\n\thfs_dbg(INODE, \"hfsplus_evict_inode: %lu\\n\", inode->i_ino);\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tif (HFSPLUS_IS_RSRC(inode)) {\n\t\tHFSPLUS_I(HFSPLUS_I(inode)->rsrc_inode)->rsrc_inode = NULL;\n\t\tiput(HFSPLUS_I(inode)->rsrc_inode);\n\t}\n}"
  },
  {
    "function_name": "hfsplus_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
    "lines": "144-160",
    "snippet": "static int hfsplus_write_inode(struct inode *inode,\n\t\tstruct writeback_control *wbc)\n{\n\tint err;\n\n\thfs_dbg(INODE, \"hfsplus_write_inode: %lu\\n\", inode->i_ino);\n\n\terr = hfsplus_ext_write_extent(inode);\n\tif (err)\n\t\treturn err;\n\n\tif (inode->i_ino >= HFSPLUS_FIRSTUSER_CNID ||\n\t    inode->i_ino == HFSPLUS_ROOT_CNID)\n\t\treturn hfsplus_cat_write_inode(inode);\n\telse\n\t\treturn hfsplus_system_write_inode(inode);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void hfsplus_destroy_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfsplus_system_write_inode",
          "args": [
            "inode"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_system_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
          "lines": "97-142",
          "snippet": "static int hfsplus_system_write_inode(struct inode *inode)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);\n\tstruct hfsplus_vh *vhdr = sbi->s_vhdr;\n\tstruct hfsplus_fork_raw *fork;\n\tstruct hfs_btree *tree = NULL;\n\n\tswitch (inode->i_ino) {\n\tcase HFSPLUS_EXT_CNID:\n\t\tfork = &vhdr->ext_file;\n\t\ttree = sbi->ext_tree;\n\t\tbreak;\n\tcase HFSPLUS_CAT_CNID:\n\t\tfork = &vhdr->cat_file;\n\t\ttree = sbi->cat_tree;\n\t\tbreak;\n\tcase HFSPLUS_ALLOC_CNID:\n\t\tfork = &vhdr->alloc_file;\n\t\tbreak;\n\tcase HFSPLUS_START_CNID:\n\t\tfork = &vhdr->start_file;\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tfork = &vhdr->attr_file;\n\t\ttree = sbi->attr_tree;\n\t\tbreak;\n\tdefault:\n\t\treturn -EIO;\n\t}\n\n\tif (fork->total_size != cpu_to_be64(inode->i_size)) {\n\t\tset_bit(HFSPLUS_SB_WRITEBACKUP, &sbi->flags);\n\t\thfsplus_mark_mdb_dirty(inode->i_sb);\n\t}\n\thfsplus_inode_write_fork(inode, fork);\n\tif (tree) {\n\t\tint err = hfs_btree_write(tree);\n\n\t\tif (err) {\n\t\t\tpr_err(\"b-tree write err: %d, ino %lu\\n\",\n\t\t\t       err, inode->i_ino);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void hfsplus_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void hfsplus_destroy_inode(struct inode *inode);\n\nstatic int hfsplus_system_write_inode(struct inode *inode)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);\n\tstruct hfsplus_vh *vhdr = sbi->s_vhdr;\n\tstruct hfsplus_fork_raw *fork;\n\tstruct hfs_btree *tree = NULL;\n\n\tswitch (inode->i_ino) {\n\tcase HFSPLUS_EXT_CNID:\n\t\tfork = &vhdr->ext_file;\n\t\ttree = sbi->ext_tree;\n\t\tbreak;\n\tcase HFSPLUS_CAT_CNID:\n\t\tfork = &vhdr->cat_file;\n\t\ttree = sbi->cat_tree;\n\t\tbreak;\n\tcase HFSPLUS_ALLOC_CNID:\n\t\tfork = &vhdr->alloc_file;\n\t\tbreak;\n\tcase HFSPLUS_START_CNID:\n\t\tfork = &vhdr->start_file;\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tfork = &vhdr->attr_file;\n\t\ttree = sbi->attr_tree;\n\t\tbreak;\n\tdefault:\n\t\treturn -EIO;\n\t}\n\n\tif (fork->total_size != cpu_to_be64(inode->i_size)) {\n\t\tset_bit(HFSPLUS_SB_WRITEBACKUP, &sbi->flags);\n\t\thfsplus_mark_mdb_dirty(inode->i_sb);\n\t}\n\thfsplus_inode_write_fork(inode, fork);\n\tif (tree) {\n\t\tint err = hfs_btree_write(tree);\n\n\t\tif (err) {\n\t\t\tpr_err(\"b-tree write err: %d, ino %lu\\n\",\n\t\t\t       err, inode->i_ino);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_cat_write_inode",
          "args": [
            "inode"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_cat_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
          "lines": "542-614",
          "snippet": "int hfsplus_cat_write_inode(struct inode *inode)\n{\n\tstruct inode *main_inode = inode;\n\tstruct hfs_find_data fd;\n\thfsplus_cat_entry entry;\n\n\tif (HFSPLUS_IS_RSRC(inode))\n\t\tmain_inode = HFSPLUS_I(inode)->rsrc_inode;\n\n\tif (!main_inode->i_nlink)\n\t\treturn 0;\n\n\tif (hfs_find_init(HFSPLUS_SB(main_inode->i_sb)->cat_tree, &fd))\n\t\t/* panic? */\n\t\treturn -EIO;\n\n\tif (hfsplus_find_cat(main_inode->i_sb, main_inode->i_ino, &fd))\n\t\t/* panic? */\n\t\tgoto out;\n\n\tif (S_ISDIR(main_inode->i_mode)) {\n\t\tstruct hfsplus_cat_folder *folder = &entry.folder;\n\n\t\tif (fd.entrylength < sizeof(struct hfsplus_cat_folder))\n\t\t\t/* panic? */;\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder));\n\t\t/* simple node checks? */\n\t\thfsplus_cat_set_perms(inode, &folder->permissions);\n\t\tfolder->access_date = hfsp_ut2mt(inode->i_atime);\n\t\tfolder->content_mod_date = hfsp_ut2mt(inode->i_mtime);\n\t\tfolder->attribute_mod_date = hfsp_ut2mt(inode->i_ctime);\n\t\tfolder->valence = cpu_to_be32(inode->i_size - 2);\n\t\tif (folder->flags & cpu_to_be16(HFSPLUS_HAS_FOLDER_COUNT)) {\n\t\t\tfolder->subfolders =\n\t\t\t\tcpu_to_be32(HFSPLUS_I(inode)->subfolders);\n\t\t}\n\t\thfs_bnode_write(fd.bnode, &entry, fd.entryoffset,\n\t\t\t\t\t sizeof(struct hfsplus_cat_folder));\n\t} else if (HFSPLUS_IS_RSRC(inode)) {\n\t\tstruct hfsplus_cat_file *file = &entry.file;\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n\t\t\t       sizeof(struct hfsplus_cat_file));\n\t\thfsplus_inode_write_fork(inode, &file->rsrc_fork);\n\t\thfs_bnode_write(fd.bnode, &entry, fd.entryoffset,\n\t\t\t\tsizeof(struct hfsplus_cat_file));\n\t} else {\n\t\tstruct hfsplus_cat_file *file = &entry.file;\n\n\t\tif (fd.entrylength < sizeof(struct hfsplus_cat_file))\n\t\t\t/* panic? */;\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_file));\n\t\thfsplus_inode_write_fork(inode, &file->data_fork);\n\t\thfsplus_cat_set_perms(inode, &file->permissions);\n\t\tif (HFSPLUS_FLG_IMMUTABLE &\n\t\t\t\t(file->permissions.rootflags |\n\t\t\t\t\tfile->permissions.userflags))\n\t\t\tfile->flags |= cpu_to_be16(HFSPLUS_FILE_LOCKED);\n\t\telse\n\t\t\tfile->flags &= cpu_to_be16(~HFSPLUS_FILE_LOCKED);\n\t\tfile->access_date = hfsp_ut2mt(inode->i_atime);\n\t\tfile->content_mod_date = hfsp_ut2mt(inode->i_mtime);\n\t\tfile->attribute_mod_date = hfsp_ut2mt(inode->i_ctime);\n\t\thfs_bnode_write(fd.bnode, &entry, fd.entryoffset,\n\t\t\t\t\t sizeof(struct hfsplus_cat_file));\n\t}\n\n\tset_bit(HFSPLUS_I_CAT_DIRTY, &HFSPLUS_I(inode)->flags);\nout:\n\thfs_find_exit(&fd);\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nint hfsplus_cat_write_inode(struct inode *inode)\n{\n\tstruct inode *main_inode = inode;\n\tstruct hfs_find_data fd;\n\thfsplus_cat_entry entry;\n\n\tif (HFSPLUS_IS_RSRC(inode))\n\t\tmain_inode = HFSPLUS_I(inode)->rsrc_inode;\n\n\tif (!main_inode->i_nlink)\n\t\treturn 0;\n\n\tif (hfs_find_init(HFSPLUS_SB(main_inode->i_sb)->cat_tree, &fd))\n\t\t/* panic? */\n\t\treturn -EIO;\n\n\tif (hfsplus_find_cat(main_inode->i_sb, main_inode->i_ino, &fd))\n\t\t/* panic? */\n\t\tgoto out;\n\n\tif (S_ISDIR(main_inode->i_mode)) {\n\t\tstruct hfsplus_cat_folder *folder = &entry.folder;\n\n\t\tif (fd.entrylength < sizeof(struct hfsplus_cat_folder))\n\t\t\t/* panic? */;\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder));\n\t\t/* simple node checks? */\n\t\thfsplus_cat_set_perms(inode, &folder->permissions);\n\t\tfolder->access_date = hfsp_ut2mt(inode->i_atime);\n\t\tfolder->content_mod_date = hfsp_ut2mt(inode->i_mtime);\n\t\tfolder->attribute_mod_date = hfsp_ut2mt(inode->i_ctime);\n\t\tfolder->valence = cpu_to_be32(inode->i_size - 2);\n\t\tif (folder->flags & cpu_to_be16(HFSPLUS_HAS_FOLDER_COUNT)) {\n\t\t\tfolder->subfolders =\n\t\t\t\tcpu_to_be32(HFSPLUS_I(inode)->subfolders);\n\t\t}\n\t\thfs_bnode_write(fd.bnode, &entry, fd.entryoffset,\n\t\t\t\t\t sizeof(struct hfsplus_cat_folder));\n\t} else if (HFSPLUS_IS_RSRC(inode)) {\n\t\tstruct hfsplus_cat_file *file = &entry.file;\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n\t\t\t       sizeof(struct hfsplus_cat_file));\n\t\thfsplus_inode_write_fork(inode, &file->rsrc_fork);\n\t\thfs_bnode_write(fd.bnode, &entry, fd.entryoffset,\n\t\t\t\tsizeof(struct hfsplus_cat_file));\n\t} else {\n\t\tstruct hfsplus_cat_file *file = &entry.file;\n\n\t\tif (fd.entrylength < sizeof(struct hfsplus_cat_file))\n\t\t\t/* panic? */;\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_file));\n\t\thfsplus_inode_write_fork(inode, &file->data_fork);\n\t\thfsplus_cat_set_perms(inode, &file->permissions);\n\t\tif (HFSPLUS_FLG_IMMUTABLE &\n\t\t\t\t(file->permissions.rootflags |\n\t\t\t\t\tfile->permissions.userflags))\n\t\t\tfile->flags |= cpu_to_be16(HFSPLUS_FILE_LOCKED);\n\t\telse\n\t\t\tfile->flags &= cpu_to_be16(~HFSPLUS_FILE_LOCKED);\n\t\tfile->access_date = hfsp_ut2mt(inode->i_atime);\n\t\tfile->content_mod_date = hfsp_ut2mt(inode->i_mtime);\n\t\tfile->attribute_mod_date = hfsp_ut2mt(inode->i_ctime);\n\t\thfs_bnode_write(fd.bnode, &entry, fd.entryoffset,\n\t\t\t\t\t sizeof(struct hfsplus_cat_file));\n\t}\n\n\tset_bit(HFSPLUS_I_CAT_DIRTY, &HFSPLUS_I(inode)->flags);\nout:\n\thfs_find_exit(&fd);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_ext_write_extent",
          "args": [
            "inode"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_ext_write_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "140-149",
          "snippet": "int hfsplus_ext_write_extent(struct inode *inode)\n{\n\tint res;\n\n\tmutex_lock(&HFSPLUS_I(inode)->extents_lock);\n\tres = hfsplus_ext_write_extent_locked(inode);\n\tmutex_unlock(&HFSPLUS_I(inode)->extents_lock);\n\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nint hfsplus_ext_write_extent(struct inode *inode)\n{\n\tint res;\n\n\tmutex_lock(&HFSPLUS_I(inode)->extents_lock);\n\tres = hfsplus_ext_write_extent_locked(inode);\n\tmutex_unlock(&HFSPLUS_I(inode)->extents_lock);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "INODE",
            "\"hfsplus_write_inode: %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void hfsplus_destroy_inode(struct inode *inode);\n\nstatic int hfsplus_write_inode(struct inode *inode,\n\t\tstruct writeback_control *wbc)\n{\n\tint err;\n\n\thfs_dbg(INODE, \"hfsplus_write_inode: %lu\\n\", inode->i_ino);\n\n\terr = hfsplus_ext_write_extent(inode);\n\tif (err)\n\t\treturn err;\n\n\tif (inode->i_ino >= HFSPLUS_FIRSTUSER_CNID ||\n\t    inode->i_ino == HFSPLUS_ROOT_CNID)\n\t\treturn hfsplus_cat_write_inode(inode);\n\telse\n\t\treturn hfsplus_system_write_inode(inode);\n}"
  },
  {
    "function_name": "hfsplus_system_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
    "lines": "97-142",
    "snippet": "static int hfsplus_system_write_inode(struct inode *inode)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);\n\tstruct hfsplus_vh *vhdr = sbi->s_vhdr;\n\tstruct hfsplus_fork_raw *fork;\n\tstruct hfs_btree *tree = NULL;\n\n\tswitch (inode->i_ino) {\n\tcase HFSPLUS_EXT_CNID:\n\t\tfork = &vhdr->ext_file;\n\t\ttree = sbi->ext_tree;\n\t\tbreak;\n\tcase HFSPLUS_CAT_CNID:\n\t\tfork = &vhdr->cat_file;\n\t\ttree = sbi->cat_tree;\n\t\tbreak;\n\tcase HFSPLUS_ALLOC_CNID:\n\t\tfork = &vhdr->alloc_file;\n\t\tbreak;\n\tcase HFSPLUS_START_CNID:\n\t\tfork = &vhdr->start_file;\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tfork = &vhdr->attr_file;\n\t\ttree = sbi->attr_tree;\n\t\tbreak;\n\tdefault:\n\t\treturn -EIO;\n\t}\n\n\tif (fork->total_size != cpu_to_be64(inode->i_size)) {\n\t\tset_bit(HFSPLUS_SB_WRITEBACKUP, &sbi->flags);\n\t\thfsplus_mark_mdb_dirty(inode->i_sb);\n\t}\n\thfsplus_inode_write_fork(inode, fork);\n\tif (tree) {\n\t\tint err = hfs_btree_write(tree);\n\n\t\tif (err) {\n\t\t\tpr_err(\"b-tree write err: %d, ino %lu\\n\",\n\t\t\t       err, inode->i_ino);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void hfsplus_destroy_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"b-tree write err: %d, ino %lu\\n\"",
            "err",
            "inode->i_ino"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_btree_write",
          "args": [
            "tree"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_btree_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/btree.c",
          "lines": "281-309",
          "snippet": "int hfs_btree_write(struct hfs_btree *tree)\n{\n\tstruct hfs_btree_header_rec *head;\n\tstruct hfs_bnode *node;\n\tstruct page *page;\n\n\tnode = hfs_bnode_find(tree, 0);\n\tif (IS_ERR(node))\n\t\t/* panic? */\n\t\treturn -EIO;\n\t/* Load the header */\n\tpage = node->page[0];\n\thead = (struct hfs_btree_header_rec *)(kmap(page) +\n\t\tsizeof(struct hfs_bnode_desc));\n\n\thead->root = cpu_to_be32(tree->root);\n\thead->leaf_count = cpu_to_be32(tree->leaf_count);\n\thead->leaf_head = cpu_to_be32(tree->leaf_head);\n\thead->leaf_tail = cpu_to_be32(tree->leaf_tail);\n\thead->node_count = cpu_to_be32(tree->node_count);\n\thead->free_nodes = cpu_to_be32(tree->free_nodes);\n\thead->attributes = cpu_to_be32(tree->attributes);\n\thead->depth = cpu_to_be16(tree->depth);\n\n\tkunmap(page);\n\tset_page_dirty(page);\n\thfs_bnode_put(node);\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/log2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/log2.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nint hfs_btree_write(struct hfs_btree *tree)\n{\n\tstruct hfs_btree_header_rec *head;\n\tstruct hfs_bnode *node;\n\tstruct page *page;\n\n\tnode = hfs_bnode_find(tree, 0);\n\tif (IS_ERR(node))\n\t\t/* panic? */\n\t\treturn -EIO;\n\t/* Load the header */\n\tpage = node->page[0];\n\thead = (struct hfs_btree_header_rec *)(kmap(page) +\n\t\tsizeof(struct hfs_bnode_desc));\n\n\thead->root = cpu_to_be32(tree->root);\n\thead->leaf_count = cpu_to_be32(tree->leaf_count);\n\thead->leaf_head = cpu_to_be32(tree->leaf_head);\n\thead->leaf_tail = cpu_to_be32(tree->leaf_tail);\n\thead->node_count = cpu_to_be32(tree->node_count);\n\thead->free_nodes = cpu_to_be32(tree->free_nodes);\n\thead->attributes = cpu_to_be32(tree->attributes);\n\thead->depth = cpu_to_be16(tree->depth);\n\n\tkunmap(page);\n\tset_page_dirty(page);\n\thfs_bnode_put(node);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_inode_write_fork",
          "args": [
            "inode",
            "fork"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_inode_write_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
          "lines": "466-473",
          "snippet": "void hfsplus_inode_write_fork(struct inode *inode,\n\t\tstruct hfsplus_fork_raw *fork)\n{\n\tmemcpy(&fork->extents, &HFSPLUS_I(inode)->first_extents,\n\t       sizeof(hfsplus_extent_rec));\n\tfork->total_size = cpu_to_be64(inode->i_size);\n\tfork->total_blocks = cpu_to_be32(HFSPLUS_I(inode)->alloc_blocks);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nvoid hfsplus_inode_write_fork(struct inode *inode,\n\t\tstruct hfsplus_fork_raw *fork)\n{\n\tmemcpy(&fork->extents, &HFSPLUS_I(inode)->first_extents,\n\t       sizeof(hfsplus_extent_rec));\n\tfork->total_size = cpu_to_be64(inode->i_size);\n\tfork->total_blocks = cpu_to_be32(HFSPLUS_I(inode)->alloc_blocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_mark_mdb_dirty",
          "args": [
            "inode->i_sb"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_mark_mdb_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
          "lines": "258-273",
          "snippet": "void hfsplus_mark_mdb_dirty(struct super_block *sb)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tunsigned long delay;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode *hfsplus_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct inode *hfsplus_alloc_inode(struct super_block *sb);\n\nvoid hfsplus_mark_mdb_dirty(struct super_block *sb)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tunsigned long delay;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "HFSPLUS_SB_WRITEBACKUP",
            "&sbi->flags"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "inode->i_size"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void hfsplus_destroy_inode(struct inode *inode);\n\nstatic int hfsplus_system_write_inode(struct inode *inode)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);\n\tstruct hfsplus_vh *vhdr = sbi->s_vhdr;\n\tstruct hfsplus_fork_raw *fork;\n\tstruct hfs_btree *tree = NULL;\n\n\tswitch (inode->i_ino) {\n\tcase HFSPLUS_EXT_CNID:\n\t\tfork = &vhdr->ext_file;\n\t\ttree = sbi->ext_tree;\n\t\tbreak;\n\tcase HFSPLUS_CAT_CNID:\n\t\tfork = &vhdr->cat_file;\n\t\ttree = sbi->cat_tree;\n\t\tbreak;\n\tcase HFSPLUS_ALLOC_CNID:\n\t\tfork = &vhdr->alloc_file;\n\t\tbreak;\n\tcase HFSPLUS_START_CNID:\n\t\tfork = &vhdr->start_file;\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tfork = &vhdr->attr_file;\n\t\ttree = sbi->attr_tree;\n\t\tbreak;\n\tdefault:\n\t\treturn -EIO;\n\t}\n\n\tif (fork->total_size != cpu_to_be64(inode->i_size)) {\n\t\tset_bit(HFSPLUS_SB_WRITEBACKUP, &sbi->flags);\n\t\thfsplus_mark_mdb_dirty(inode->i_sb);\n\t}\n\thfsplus_inode_write_fork(inode, fork);\n\tif (tree) {\n\t\tint err = hfs_btree_write(tree);\n\n\t\tif (err) {\n\t\t\tpr_err(\"b-tree write err: %d, ino %lu\\n\",\n\t\t\t       err, inode->i_ino);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "hfsplus_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
    "lines": "56-95",
    "snippet": "struct inode *hfsplus_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct hfs_find_data fd;\n\tstruct inode *inode;\n\tint err;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tINIT_LIST_HEAD(&HFSPLUS_I(inode)->open_dir_list);\n\tmutex_init(&HFSPLUS_I(inode)->extents_lock);\n\tHFSPLUS_I(inode)->flags = 0;\n\tHFSPLUS_I(inode)->extent_state = 0;\n\tHFSPLUS_I(inode)->rsrc_inode = NULL;\n\tatomic_set(&HFSPLUS_I(inode)->opencnt, 0);\n\n\tif (inode->i_ino >= HFSPLUS_FIRSTUSER_CNID ||\n\t    inode->i_ino == HFSPLUS_ROOT_CNID) {\n\t\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &fd);\n\t\tif (!err) {\n\t\t\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd);\n\t\t\tif (!err)\n\t\t\t\terr = hfsplus_cat_read_inode(inode, &fd);\n\t\t\thfs_find_exit(&fd);\n\t\t}\n\t} else {\n\t\terr = hfsplus_system_read_inode(inode);\n\t}\n\n\tif (err) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct inode *hfsplus_alloc_inode(struct super_block *sb);",
      "static void hfsplus_destroy_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "inode"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_system_read_inode",
          "args": [
            "inode"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_system_read_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
          "lines": "25-54",
          "snippet": "static int hfsplus_system_read_inode(struct inode *inode)\n{\n\tstruct hfsplus_vh *vhdr = HFSPLUS_SB(inode->i_sb)->s_vhdr;\n\n\tswitch (inode->i_ino) {\n\tcase HFSPLUS_EXT_CNID:\n\t\thfsplus_inode_read_fork(inode, &vhdr->ext_file);\n\t\tinode->i_mapping->a_ops = &hfsplus_btree_aops;\n\t\tbreak;\n\tcase HFSPLUS_CAT_CNID:\n\t\thfsplus_inode_read_fork(inode, &vhdr->cat_file);\n\t\tinode->i_mapping->a_ops = &hfsplus_btree_aops;\n\t\tbreak;\n\tcase HFSPLUS_ALLOC_CNID:\n\t\thfsplus_inode_read_fork(inode, &vhdr->alloc_file);\n\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\tbreak;\n\tcase HFSPLUS_START_CNID:\n\t\thfsplus_inode_read_fork(inode, &vhdr->start_file);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\thfsplus_inode_read_fork(inode, &vhdr->attr_file);\n\t\tinode->i_mapping->a_ops = &hfsplus_btree_aops;\n\t\tbreak;\n\tdefault:\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void hfsplus_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void hfsplus_destroy_inode(struct inode *inode);\n\nstatic int hfsplus_system_read_inode(struct inode *inode)\n{\n\tstruct hfsplus_vh *vhdr = HFSPLUS_SB(inode->i_sb)->s_vhdr;\n\n\tswitch (inode->i_ino) {\n\tcase HFSPLUS_EXT_CNID:\n\t\thfsplus_inode_read_fork(inode, &vhdr->ext_file);\n\t\tinode->i_mapping->a_ops = &hfsplus_btree_aops;\n\t\tbreak;\n\tcase HFSPLUS_CAT_CNID:\n\t\thfsplus_inode_read_fork(inode, &vhdr->cat_file);\n\t\tinode->i_mapping->a_ops = &hfsplus_btree_aops;\n\t\tbreak;\n\tcase HFSPLUS_ALLOC_CNID:\n\t\thfsplus_inode_read_fork(inode, &vhdr->alloc_file);\n\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\tbreak;\n\tcase HFSPLUS_START_CNID:\n\t\thfsplus_inode_read_fork(inode, &vhdr->start_file);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\thfsplus_inode_read_fork(inode, &vhdr->attr_file);\n\t\tinode->i_mapping->a_ops = &hfsplus_btree_aops;\n\t\tbreak;\n\tdefault:\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "43-51",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_cat_read_inode",
          "args": [
            "inode",
            "&fd"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_cat_read_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
          "lines": "475-540",
          "snippet": "int hfsplus_cat_read_inode(struct inode *inode, struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry entry;\n\tint res = 0;\n\tu16 type;\n\n\ttype = hfs_bnode_read_u16(fd->bnode, fd->entryoffset);\n\n\tHFSPLUS_I(inode)->linkid = 0;\n\tif (type == HFSPLUS_FOLDER) {\n\t\tstruct hfsplus_cat_folder *folder = &entry.folder;\n\n\t\tif (fd->entrylength < sizeof(struct hfsplus_cat_folder))\n\t\t\t/* panic? */;\n\t\thfs_bnode_read(fd->bnode, &entry, fd->entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder));\n\t\thfsplus_get_perms(inode, &folder->permissions, 1);\n\t\tset_nlink(inode, 1);\n\t\tinode->i_size = 2 + be32_to_cpu(folder->valence);\n\t\tinode->i_atime = hfsp_mt2ut(folder->access_date);\n\t\tinode->i_mtime = hfsp_mt2ut(folder->content_mod_date);\n\t\tinode->i_ctime = hfsp_mt2ut(folder->attribute_mod_date);\n\t\tHFSPLUS_I(inode)->create_date = folder->create_date;\n\t\tHFSPLUS_I(inode)->fs_blocks = 0;\n\t\tif (folder->flags & cpu_to_be16(HFSPLUS_HAS_FOLDER_COUNT)) {\n\t\t\tHFSPLUS_I(inode)->subfolders =\n\t\t\t\tbe32_to_cpu(folder->subfolders);\n\t\t}\n\t\tinode->i_op = &hfsplus_dir_inode_operations;\n\t\tinode->i_fop = &hfsplus_dir_operations;\n\t} else if (type == HFSPLUS_FILE) {\n\t\tstruct hfsplus_cat_file *file = &entry.file;\n\n\t\tif (fd->entrylength < sizeof(struct hfsplus_cat_file))\n\t\t\t/* panic? */;\n\t\thfs_bnode_read(fd->bnode, &entry, fd->entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_file));\n\n\t\thfsplus_inode_read_fork(inode, HFSPLUS_IS_RSRC(inode) ?\n\t\t\t\t\t&file->rsrc_fork : &file->data_fork);\n\t\thfsplus_get_perms(inode, &file->permissions, 0);\n\t\tset_nlink(inode, 1);\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tif (file->permissions.dev)\n\t\t\t\tset_nlink(inode,\n\t\t\t\t\t  be32_to_cpu(file->permissions.dev));\n\t\t\tinode->i_op = &hfsplus_file_inode_operations;\n\t\t\tinode->i_fop = &hfsplus_file_operations;\n\t\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\t} else if (S_ISLNK(inode->i_mode)) {\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\t} else {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t\t   be32_to_cpu(file->permissions.dev));\n\t\t}\n\t\tinode->i_atime = hfsp_mt2ut(file->access_date);\n\t\tinode->i_mtime = hfsp_mt2ut(file->content_mod_date);\n\t\tinode->i_ctime = hfsp_mt2ut(file->attribute_mod_date);\n\t\tHFSPLUS_I(inode)->create_date = file->create_date;\n\t} else {\n\t\tpr_err(\"bad catalog entry used to create inode\\n\");\n\t\tres = -EIO;\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct address_space_operations hfsplus_aops = {\n\t.readpage\t= hfsplus_readpage,\n\t.writepage\t= hfsplus_writepage,\n\t.write_begin\t= hfsplus_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfsplus_bmap,\n\t.direct_IO\t= hfsplus_direct_IO,\n\t.writepages\t= hfsplus_writepages,\n};",
            "static const struct inode_operations hfsplus_file_inode_operations = {\n\t.setattr\t= hfsplus_setattr,\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= hfsplus_listxattr,\n\t.removexattr\t= generic_removexattr,\n#ifdef CONFIG_HFSPLUS_FS_POSIX_ACL\n\t.get_acl\t= hfsplus_get_posix_acl,\n\t.set_acl\t= hfsplus_set_posix_acl,\n#endif\n};",
            "static const struct file_operations hfsplus_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.splice_read\t= generic_file_splice_read,\n\t.fsync\t\t= hfsplus_file_fsync,\n\t.open\t\t= hfsplus_file_open,\n\t.release\t= hfsplus_file_release,\n\t.unlocked_ioctl = hfsplus_ioctl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nconst struct address_space_operations hfsplus_aops = {\n\t.readpage\t= hfsplus_readpage,\n\t.writepage\t= hfsplus_writepage,\n\t.write_begin\t= hfsplus_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfsplus_bmap,\n\t.direct_IO\t= hfsplus_direct_IO,\n\t.writepages\t= hfsplus_writepages,\n};\nstatic const struct inode_operations hfsplus_file_inode_operations = {\n\t.setattr\t= hfsplus_setattr,\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= hfsplus_listxattr,\n\t.removexattr\t= generic_removexattr,\n#ifdef CONFIG_HFSPLUS_FS_POSIX_ACL\n\t.get_acl\t= hfsplus_get_posix_acl,\n\t.set_acl\t= hfsplus_set_posix_acl,\n#endif\n};\nstatic const struct file_operations hfsplus_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.splice_read\t= generic_file_splice_read,\n\t.fsync\t\t= hfsplus_file_fsync,\n\t.open\t\t= hfsplus_file_open,\n\t.release\t= hfsplus_file_release,\n\t.unlocked_ioctl = hfsplus_ioctl,\n};\n\nint hfsplus_cat_read_inode(struct inode *inode, struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry entry;\n\tint res = 0;\n\tu16 type;\n\n\ttype = hfs_bnode_read_u16(fd->bnode, fd->entryoffset);\n\n\tHFSPLUS_I(inode)->linkid = 0;\n\tif (type == HFSPLUS_FOLDER) {\n\t\tstruct hfsplus_cat_folder *folder = &entry.folder;\n\n\t\tif (fd->entrylength < sizeof(struct hfsplus_cat_folder))\n\t\t\t/* panic? */;\n\t\thfs_bnode_read(fd->bnode, &entry, fd->entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder));\n\t\thfsplus_get_perms(inode, &folder->permissions, 1);\n\t\tset_nlink(inode, 1);\n\t\tinode->i_size = 2 + be32_to_cpu(folder->valence);\n\t\tinode->i_atime = hfsp_mt2ut(folder->access_date);\n\t\tinode->i_mtime = hfsp_mt2ut(folder->content_mod_date);\n\t\tinode->i_ctime = hfsp_mt2ut(folder->attribute_mod_date);\n\t\tHFSPLUS_I(inode)->create_date = folder->create_date;\n\t\tHFSPLUS_I(inode)->fs_blocks = 0;\n\t\tif (folder->flags & cpu_to_be16(HFSPLUS_HAS_FOLDER_COUNT)) {\n\t\t\tHFSPLUS_I(inode)->subfolders =\n\t\t\t\tbe32_to_cpu(folder->subfolders);\n\t\t}\n\t\tinode->i_op = &hfsplus_dir_inode_operations;\n\t\tinode->i_fop = &hfsplus_dir_operations;\n\t} else if (type == HFSPLUS_FILE) {\n\t\tstruct hfsplus_cat_file *file = &entry.file;\n\n\t\tif (fd->entrylength < sizeof(struct hfsplus_cat_file))\n\t\t\t/* panic? */;\n\t\thfs_bnode_read(fd->bnode, &entry, fd->entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_file));\n\n\t\thfsplus_inode_read_fork(inode, HFSPLUS_IS_RSRC(inode) ?\n\t\t\t\t\t&file->rsrc_fork : &file->data_fork);\n\t\thfsplus_get_perms(inode, &file->permissions, 0);\n\t\tset_nlink(inode, 1);\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tif (file->permissions.dev)\n\t\t\t\tset_nlink(inode,\n\t\t\t\t\t  be32_to_cpu(file->permissions.dev));\n\t\t\tinode->i_op = &hfsplus_file_inode_operations;\n\t\t\tinode->i_fop = &hfsplus_file_operations;\n\t\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\t} else if (S_ISLNK(inode->i_mode)) {\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\t} else {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t\t   be32_to_cpu(file->permissions.dev));\n\t\t}\n\t\tinode->i_atime = hfsp_mt2ut(file->access_date);\n\t\tinode->i_mtime = hfsp_mt2ut(file->content_mod_date);\n\t\tinode->i_ctime = hfsp_mt2ut(file->attribute_mod_date);\n\t\tHFSPLUS_I(inode)->create_date = file->create_date;\n\t} else {\n\t\tpr_err(\"bad catalog entry used to create inode\\n\");\n\t\tres = -EIO;\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_find_cat",
          "args": [
            "inode->i_sb",
            "inode->i_ino",
            "&fd"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_find_cat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "193-220",
          "snippet": "int hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd->search_key, cnid);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tpr_err(\"found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (be16_to_cpu(tmp.thread.nodeName.length) > 255) {\n\t\tpr_err(\"catalog name length corrupted\\n\");\n\t\treturn -EIO;\n\t}\n\n\thfsplus_cat_build_key_uni(fd->search_key,\n\t\tbe32_to_cpu(tmp.thread.parentID),\n\t\t&tmp.thread.nodeName);\n\treturn hfs_brec_find(fd, hfs_find_rec_by_key);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd->search_key, cnid);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tpr_err(\"found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (be16_to_cpu(tmp.thread.nodeName.length) > 255) {\n\t\tpr_err(\"catalog name length corrupted\\n\");\n\t\treturn -EIO;\n\t}\n\n\thfsplus_cat_build_key_uni(fd->search_key,\n\t\tbe32_to_cpu(tmp.thread.parentID),\n\t\t&tmp.thread.nodeName);\n\treturn hfs_brec_find(fd, hfs_find_rec_by_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFSPLUS_SB(inode->i_sb)->cat_tree",
            "&fd"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "14-41",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&HFSPLUS_I(inode)->opencnt",
            "0"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&HFSPLUS_I(inode)->extents_lock"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&HFSPLUS_I(inode)->open_dir_list"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_locked",
          "args": [
            "sb",
            "ino"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1063-1109",
          "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct inode *hfsplus_alloc_inode(struct super_block *sb);\nstatic void hfsplus_destroy_inode(struct inode *inode);\n\nstruct inode *hfsplus_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct hfs_find_data fd;\n\tstruct inode *inode;\n\tint err;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tINIT_LIST_HEAD(&HFSPLUS_I(inode)->open_dir_list);\n\tmutex_init(&HFSPLUS_I(inode)->extents_lock);\n\tHFSPLUS_I(inode)->flags = 0;\n\tHFSPLUS_I(inode)->extent_state = 0;\n\tHFSPLUS_I(inode)->rsrc_inode = NULL;\n\tatomic_set(&HFSPLUS_I(inode)->opencnt, 0);\n\n\tif (inode->i_ino >= HFSPLUS_FIRSTUSER_CNID ||\n\t    inode->i_ino == HFSPLUS_ROOT_CNID) {\n\t\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &fd);\n\t\tif (!err) {\n\t\t\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd);\n\t\t\tif (!err)\n\t\t\t\terr = hfsplus_cat_read_inode(inode, &fd);\n\t\t\thfs_find_exit(&fd);\n\t\t}\n\t} else {\n\t\terr = hfsplus_system_read_inode(inode);\n\t}\n\n\tif (err) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
  },
  {
    "function_name": "hfsplus_system_read_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
    "lines": "25-54",
    "snippet": "static int hfsplus_system_read_inode(struct inode *inode)\n{\n\tstruct hfsplus_vh *vhdr = HFSPLUS_SB(inode->i_sb)->s_vhdr;\n\n\tswitch (inode->i_ino) {\n\tcase HFSPLUS_EXT_CNID:\n\t\thfsplus_inode_read_fork(inode, &vhdr->ext_file);\n\t\tinode->i_mapping->a_ops = &hfsplus_btree_aops;\n\t\tbreak;\n\tcase HFSPLUS_CAT_CNID:\n\t\thfsplus_inode_read_fork(inode, &vhdr->cat_file);\n\t\tinode->i_mapping->a_ops = &hfsplus_btree_aops;\n\t\tbreak;\n\tcase HFSPLUS_ALLOC_CNID:\n\t\thfsplus_inode_read_fork(inode, &vhdr->alloc_file);\n\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\tbreak;\n\tcase HFSPLUS_START_CNID:\n\t\thfsplus_inode_read_fork(inode, &vhdr->start_file);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\thfsplus_inode_read_fork(inode, &vhdr->attr_file);\n\t\tinode->i_mapping->a_ops = &hfsplus_btree_aops;\n\t\tbreak;\n\tdefault:\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void hfsplus_destroy_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfsplus_inode_read_fork",
          "args": [
            "inode",
            "&vhdr->attr_file"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_inode_read_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
          "lines": "436-464",
          "snippet": "void hfsplus_inode_read_fork(struct inode *inode, struct hfsplus_fork_raw *fork)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tu32 count;\n\tint i;\n\n\tmemcpy(&hip->first_extents, &fork->extents, sizeof(hfsplus_extent_rec));\n\tfor (count = 0, i = 0; i < 8; i++)\n\t\tcount += be32_to_cpu(fork->extents[i].block_count);\n\thip->first_blocks = count;\n\tmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\n\thip->cached_start = 0;\n\thip->cached_blocks = 0;\n\n\thip->alloc_blocks = be32_to_cpu(fork->total_blocks);\n\thip->phys_size = inode->i_size = be64_to_cpu(fork->total_size);\n\thip->fs_blocks =\n\t\t(inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\tinode_set_bytes(inode, hip->fs_blocks << sb->s_blocksize_bits);\n\thip->clump_blocks =\n\t\tbe32_to_cpu(fork->clump_size) >> sbi->alloc_blksz_shift;\n\tif (!hip->clump_blocks) {\n\t\thip->clump_blocks = HFSPLUS_IS_RSRC(inode) ?\n\t\t\tsbi->rsrc_clump_blocks :\n\t\t\tsbi->data_clump_blocks;\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nvoid hfsplus_inode_read_fork(struct inode *inode, struct hfsplus_fork_raw *fork)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tu32 count;\n\tint i;\n\n\tmemcpy(&hip->first_extents, &fork->extents, sizeof(hfsplus_extent_rec));\n\tfor (count = 0, i = 0; i < 8; i++)\n\t\tcount += be32_to_cpu(fork->extents[i].block_count);\n\thip->first_blocks = count;\n\tmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\n\thip->cached_start = 0;\n\thip->cached_blocks = 0;\n\n\thip->alloc_blocks = be32_to_cpu(fork->total_blocks);\n\thip->phys_size = inode->i_size = be64_to_cpu(fork->total_size);\n\thip->fs_blocks =\n\t\t(inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;\n\tinode_set_bytes(inode, hip->fs_blocks << sb->s_blocksize_bits);\n\thip->clump_blocks =\n\t\tbe32_to_cpu(fork->clump_size) >> sbi->alloc_blksz_shift;\n\tif (!hip->clump_blocks) {\n\t\thip->clump_blocks = HFSPLUS_IS_RSRC(inode) ?\n\t\t\tsbi->rsrc_clump_blocks :\n\t\t\tsbi->data_clump_blocks;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void hfsplus_destroy_inode(struct inode *inode);\n\nstatic int hfsplus_system_read_inode(struct inode *inode)\n{\n\tstruct hfsplus_vh *vhdr = HFSPLUS_SB(inode->i_sb)->s_vhdr;\n\n\tswitch (inode->i_ino) {\n\tcase HFSPLUS_EXT_CNID:\n\t\thfsplus_inode_read_fork(inode, &vhdr->ext_file);\n\t\tinode->i_mapping->a_ops = &hfsplus_btree_aops;\n\t\tbreak;\n\tcase HFSPLUS_CAT_CNID:\n\t\thfsplus_inode_read_fork(inode, &vhdr->cat_file);\n\t\tinode->i_mapping->a_ops = &hfsplus_btree_aops;\n\t\tbreak;\n\tcase HFSPLUS_ALLOC_CNID:\n\t\thfsplus_inode_read_fork(inode, &vhdr->alloc_file);\n\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\tbreak;\n\tcase HFSPLUS_START_CNID:\n\t\thfsplus_inode_read_fork(inode, &vhdr->start_file);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\thfsplus_inode_read_fork(inode, &vhdr->attr_file);\n\t\tinode->i_mapping->a_ops = &hfsplus_btree_aops;\n\t\tbreak;\n\tdefault:\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
  }
]