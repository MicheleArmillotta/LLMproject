[
  {
    "function_name": "nfs4_callback_recallslot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
    "lines": "530-553",
    "snippet": "__be32 nfs4_callback_recallslot(struct cb_recallslotargs *args, void *dummy,\n\t\t\t\tstruct cb_process_state *cps)\n{\n\tstruct nfs4_slot_table *fc_tbl;\n\t__be32 status;\n\n\tstatus = htonl(NFS4ERR_OP_NOT_IN_SESSION);\n\tif (!cps->clp) /* set in cb_sequence */\n\t\tgoto out;\n\n\tdprintk_rcu(\"NFS: CB_RECALL_SLOT request from %s target highest slotid %u\\n\",\n\t\trpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR),\n\t\targs->crsa_target_highest_slotid);\n\n\tfc_tbl = &cps->clp->cl_session->fc_slot_table;\n\n\tstatus = htonl(NFS4_OK);\n\n\tnfs41_set_target_slotid(fc_tbl, args->crsa_target_highest_slotid);\n\tnfs41_server_notify_target_slotid_update(cps->clp);\nout:\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, ntohl(status));\n\treturn status;\n}",
    "includes": [
      "#include \"nfs4trace.h\"",
      "#include \"nfs4session.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: exit with status = %d\\n\"",
            "__func__",
            "ntohl(status)"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "status"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs41_server_notify_target_slotid_update",
          "args": [
            "cps->clp"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "nfs41_server_notify_target_slotid_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "2160-2163",
          "snippet": "void nfs41_server_notify_target_slotid_update(struct nfs_client *clp)\n{\n\tnfs41_ping_server(clp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs41_server_notify_target_slotid_update(struct nfs_client *clp)\n{\n\tnfs41_ping_server(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs41_set_target_slotid",
          "args": [
            "fc_tbl",
            "args->crsa_target_highest_slotid"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "nfs41_set_target_slotid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4session.c",
          "lines": "348-357",
          "snippet": "void nfs41_set_target_slotid(struct nfs4_slot_table *tbl,\n\t\tu32 target_highest_slotid)\n{\n\tspin_lock(&tbl->slot_tbl_lock);\n\tnfs41_set_target_slotid_locked(tbl, target_highest_slotid);\n\ttbl->d_target_highest_slotid = 0;\n\ttbl->d2_target_highest_slotid = 0;\n\tnfs41_set_max_slotid_locked(tbl, target_highest_slotid);\n\tspin_unlock(&tbl->slot_tbl_lock);\n}",
          "includes": [
            "#include \"callback.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"callback.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nvoid nfs41_set_target_slotid(struct nfs4_slot_table *tbl,\n\t\tu32 target_highest_slotid)\n{\n\tspin_lock(&tbl->slot_tbl_lock);\n\tnfs41_set_target_slotid_locked(tbl, target_highest_slotid);\n\ttbl->d_target_highest_slotid = 0;\n\ttbl->d2_target_highest_slotid = 0;\n\tnfs41_set_max_slotid_locked(tbl, target_highest_slotid);\n\tspin_unlock(&tbl->slot_tbl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4_OK"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk_rcu",
          "args": [
            "\"NFS: CB_RECALL_SLOT request from %s target highest slotid %u\\n\"",
            "rpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR)",
            "args->crsa_target_highest_slotid"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_peeraddr2str",
          "args": [
            "cps->clp->cl_rpcclient",
            "RPC_DISPLAY_ADDR"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_OP_NOT_IN_SESSION"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\n__be32 nfs4_callback_recallslot(struct cb_recallslotargs *args, void *dummy,\n\t\t\t\tstruct cb_process_state *cps)\n{\n\tstruct nfs4_slot_table *fc_tbl;\n\t__be32 status;\n\n\tstatus = htonl(NFS4ERR_OP_NOT_IN_SESSION);\n\tif (!cps->clp) /* set in cb_sequence */\n\t\tgoto out;\n\n\tdprintk_rcu(\"NFS: CB_RECALL_SLOT request from %s target highest slotid %u\\n\",\n\t\trpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR),\n\t\targs->crsa_target_highest_slotid);\n\n\tfc_tbl = &cps->clp->cl_session->fc_slot_table;\n\n\tstatus = htonl(NFS4_OK);\n\n\tnfs41_set_target_slotid(fc_tbl, args->crsa_target_highest_slotid);\n\tnfs41_server_notify_target_slotid_update(cps->clp);\nout:\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, ntohl(status));\n\treturn status;\n}"
  },
  {
    "function_name": "nfs4_callback_recallany",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
    "lines": "495-527",
    "snippet": "__be32 nfs4_callback_recallany(struct cb_recallanyargs *args, void *dummy,\n\t\t\t       struct cb_process_state *cps)\n{\n\t__be32 status;\n\tfmode_t flags = 0;\n\n\tstatus = cpu_to_be32(NFS4ERR_OP_NOT_IN_SESSION);\n\tif (!cps->clp) /* set in cb_sequence */\n\t\tgoto out;\n\n\tdprintk_rcu(\"NFS: RECALL_ANY callback request from %s\\n\",\n\t\trpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\n\tstatus = cpu_to_be32(NFS4ERR_INVAL);\n\tif (!validate_bitmap_values(args->craa_type_mask))\n\t\tgoto out;\n\n\tstatus = cpu_to_be32(NFS4_OK);\n\tif (test_bit(RCA4_TYPE_MASK_RDATA_DLG, (const unsigned long *)\n\t\t     &args->craa_type_mask))\n\t\tflags = FMODE_READ;\n\tif (test_bit(RCA4_TYPE_MASK_WDATA_DLG, (const unsigned long *)\n\t\t     &args->craa_type_mask))\n\t\tflags |= FMODE_WRITE;\n\tif (test_bit(RCA4_TYPE_MASK_FILE_LAYOUT, (const unsigned long *)\n\t\t     &args->craa_type_mask))\n\t\tpnfs_recall_all_layouts(cps->clp);\n\tif (flags)\n\t\tnfs_expire_unused_delegation_types(cps->clp, flags);\nout:\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, ntohl(status));\n\treturn status;\n}",
    "includes": [
      "#include \"nfs4trace.h\"",
      "#include \"nfs4session.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: exit with status = %d\\n\"",
            "__func__",
            "ntohl(status)"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "status"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_expire_unused_delegation_types",
          "args": [
            "cps->clp",
            "flags"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_expire_unused_delegation_types",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/delegation.c",
          "lines": "674-678",
          "snippet": "void nfs_expire_unused_delegation_types(struct nfs_client *clp, fmode_t flags)\n{\n\tnfs_client_mark_return_unused_delegation_types(clp, flags);\n\tnfs_delegation_run_state_manager(clp);\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n\nvoid nfs_expire_unused_delegation_types(struct nfs_client *clp, fmode_t flags)\n{\n\tnfs_client_mark_return_unused_delegation_types(clp, flags);\n\tnfs_delegation_run_state_manager(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_recall_all_layouts",
          "args": [
            "cps->clp"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_recall_all_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
          "lines": "247-256",
          "snippet": "static void pnfs_recall_all_layouts(struct nfs_client *clp)\n{\n\tstruct cb_layoutrecallargs args;\n\n\t/* Pretend we got a CB_LAYOUTRECALL(ALL) */\n\tmemset(&args, 0, sizeof(args));\n\targs.cbl_recall_type = RETURN_ALL;\n\t/* FIXME we ignore errors, what should we do? */\n\tdo_callback_layoutrecall(clp, &args);\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"nfs4session.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\nstatic void pnfs_recall_all_layouts(struct nfs_client *clp)\n{\n\tstruct cb_layoutrecallargs args;\n\n\t/* Pretend we got a CB_LAYOUTRECALL(ALL) */\n\tmemset(&args, 0, sizeof(args));\n\targs.cbl_recall_type = RETURN_ALL;\n\t/* FIXME we ignore errors, what should we do? */\n\tdo_callback_layoutrecall(clp, &args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "RCA4_TYPE_MASK_FILE_LAYOUT",
            "(const unsigned long *)\n\t\t     &args->craa_type_mask"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NFS4_OK"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_bitmap_values",
          "args": [
            "args->craa_type_mask"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "validate_bitmap_values",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
          "lines": "489-493",
          "snippet": "static bool\nvalidate_bitmap_values(unsigned long mask)\n{\n\treturn (mask & ~RCA4_TYPE_MASK_ALL) == 0;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"nfs4session.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\nstatic bool\nvalidate_bitmap_values(unsigned long mask)\n{\n\treturn (mask & ~RCA4_TYPE_MASK_ALL) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NFS4ERR_INVAL"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk_rcu",
          "args": [
            "\"NFS: RECALL_ANY callback request from %s\\n\"",
            "rpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR)"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_peeraddr2str",
          "args": [
            "cps->clp->cl_rpcclient",
            "RPC_DISPLAY_ADDR"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NFS4ERR_OP_NOT_IN_SESSION"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\n__be32 nfs4_callback_recallany(struct cb_recallanyargs *args, void *dummy,\n\t\t\t       struct cb_process_state *cps)\n{\n\t__be32 status;\n\tfmode_t flags = 0;\n\n\tstatus = cpu_to_be32(NFS4ERR_OP_NOT_IN_SESSION);\n\tif (!cps->clp) /* set in cb_sequence */\n\t\tgoto out;\n\n\tdprintk_rcu(\"NFS: RECALL_ANY callback request from %s\\n\",\n\t\trpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\n\tstatus = cpu_to_be32(NFS4ERR_INVAL);\n\tif (!validate_bitmap_values(args->craa_type_mask))\n\t\tgoto out;\n\n\tstatus = cpu_to_be32(NFS4_OK);\n\tif (test_bit(RCA4_TYPE_MASK_RDATA_DLG, (const unsigned long *)\n\t\t     &args->craa_type_mask))\n\t\tflags = FMODE_READ;\n\tif (test_bit(RCA4_TYPE_MASK_WDATA_DLG, (const unsigned long *)\n\t\t     &args->craa_type_mask))\n\t\tflags |= FMODE_WRITE;\n\tif (test_bit(RCA4_TYPE_MASK_FILE_LAYOUT, (const unsigned long *)\n\t\t     &args->craa_type_mask))\n\t\tpnfs_recall_all_layouts(cps->clp);\n\tif (flags)\n\t\tnfs_expire_unused_delegation_types(cps->clp, flags);\nout:\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, ntohl(status));\n\treturn status;\n}"
  },
  {
    "function_name": "validate_bitmap_values",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
    "lines": "489-493",
    "snippet": "static bool\nvalidate_bitmap_values(unsigned long mask)\n{\n\treturn (mask & ~RCA4_TYPE_MASK_ALL) == 0;\n}",
    "includes": [
      "#include \"nfs4trace.h\"",
      "#include \"nfs4session.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\nstatic bool\nvalidate_bitmap_values(unsigned long mask)\n{\n\treturn (mask & ~RCA4_TYPE_MASK_ALL) == 0;\n}"
  },
  {
    "function_name": "nfs4_callback_sequence",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
    "lines": "416-487",
    "snippet": "__be32 nfs4_callback_sequence(struct cb_sequenceargs *args,\n\t\t\t      struct cb_sequenceres *res,\n\t\t\t      struct cb_process_state *cps)\n{\n\tstruct nfs4_slot_table *tbl;\n\tstruct nfs_client *clp;\n\tint i;\n\t__be32 status = htonl(NFS4ERR_BADSESSION);\n\n\tclp = nfs4_find_client_sessionid(cps->net, args->csa_addr,\n\t\t\t\t\t &args->csa_sessionid, cps->minorversion);\n\tif (clp == NULL)\n\t\tgoto out;\n\n\tif (!(clp->cl_session->flags & SESSION4_BACK_CHAN))\n\t\tgoto out;\n\ttbl = &clp->cl_session->bc_slot_table;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\t/* state manager is resetting the session */\n\tif (test_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state)) {\n\t\tspin_unlock(&tbl->slot_tbl_lock);\n\t\tstatus = htonl(NFS4ERR_DELAY);\n\t\t/* Return NFS4ERR_BADSESSION if we're draining the session\n\t\t * in order to reset it.\n\t\t */\n\t\tif (test_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state))\n\t\t\tstatus = htonl(NFS4ERR_BADSESSION);\n\t\tgoto out;\n\t}\n\n\tstatus = validate_seqid(&clp->cl_session->bc_slot_table, args);\n\tspin_unlock(&tbl->slot_tbl_lock);\n\tif (status)\n\t\tgoto out;\n\n\tcps->slotid = args->csa_slotid;\n\n\t/*\n\t * Check for pending referring calls.  If a match is found, a\n\t * related callback was received before the response to the original\n\t * call.\n\t */\n\tif (referring_call_exists(clp, args->csa_nrclists, args->csa_rclists)) {\n\t\tstatus = htonl(NFS4ERR_DELAY);\n\t\tgoto out;\n\t}\n\n\tmemcpy(&res->csr_sessionid, &args->csa_sessionid,\n\t       sizeof(res->csr_sessionid));\n\tres->csr_sequenceid = args->csa_sequenceid;\n\tres->csr_slotid = args->csa_slotid;\n\tres->csr_highestslotid = NFS41_BC_MAX_CALLBACKS - 1;\n\tres->csr_target_highestslotid = NFS41_BC_MAX_CALLBACKS - 1;\n\nout:\n\tcps->clp = clp; /* put in nfs4_callback_compound */\n\tfor (i = 0; i < args->csa_nrclists; i++)\n\t\tkfree(args->csa_rclists[i].rcl_refcalls);\n\tkfree(args->csa_rclists);\n\n\tif (status == htonl(NFS4ERR_RETRY_UNCACHED_REP)) {\n\t\tcps->drc_status = status;\n\t\tstatus = 0;\n\t} else\n\t\tres->csr_status = status;\n\n\ttrace_nfs4_cb_sequence(args, res, status);\n\tdprintk(\"%s: exit with status = %d res->csr_status %d\\n\", __func__,\n\t\tntohl(status), ntohl(res->csr_status));\n\treturn status;\n}",
    "includes": [
      "#include \"nfs4trace.h\"",
      "#include \"nfs4session.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: exit with status = %d res->csr_status %d\\n\"",
            "__func__",
            "ntohl(status)",
            "ntohl(res->csr_status)"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "res->csr_status"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "status"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_nfs4_cb_sequence",
          "args": [
            "args",
            "res",
            "status"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RETRY_UNCACHED_REP"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "args->csa_rclists"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "args->csa_rclists[i].rcl_refcalls"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&res->csr_sessionid",
            "&args->csa_sessionid",
            "sizeof(res->csr_sessionid)"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_DELAY"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "referring_call_exists",
          "args": [
            "clp",
            "args->csa_nrclists",
            "args->csa_rclists"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "referring_call_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
          "lines": "366-414",
          "snippet": "static bool referring_call_exists(struct nfs_client *clp,\n\t\t\t\t  uint32_t nrclists,\n\t\t\t\t  struct referring_call_list *rclists)\n{\n\tbool status = 0;\n\tint i, j;\n\tstruct nfs4_session *session;\n\tstruct nfs4_slot_table *tbl;\n\tstruct referring_call_list *rclist;\n\tstruct referring_call *ref;\n\n\t/*\n\t * XXX When client trunking is implemented, this becomes\n\t * a session lookup from within the loop\n\t */\n\tsession = clp->cl_session;\n\ttbl = &session->fc_slot_table;\n\n\tfor (i = 0; i < nrclists; i++) {\n\t\trclist = &rclists[i];\n\t\tif (memcmp(session->sess_id.data,\n\t\t\t   rclist->rcl_sessionid.data,\n\t\t\t   NFS4_MAX_SESSIONID_LEN) != 0)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < rclist->rcl_nrefcalls; j++) {\n\t\t\tref = &rclist->rcl_refcalls[j];\n\n\t\t\tdprintk(\"%s: sessionid %x:%x:%x:%x sequenceid %u \"\n\t\t\t\t\"slotid %u\\n\", __func__,\n\t\t\t\t((u32 *)&rclist->rcl_sessionid.data)[0],\n\t\t\t\t((u32 *)&rclist->rcl_sessionid.data)[1],\n\t\t\t\t((u32 *)&rclist->rcl_sessionid.data)[2],\n\t\t\t\t((u32 *)&rclist->rcl_sessionid.data)[3],\n\t\t\t\tref->rc_sequenceid, ref->rc_slotid);\n\n\t\t\tspin_lock(&tbl->slot_tbl_lock);\n\t\t\tstatus = (test_bit(ref->rc_slotid, tbl->used_slots) &&\n\t\t\t\t  tbl->slots[ref->rc_slotid].seq_nr ==\n\t\t\t\t\tref->rc_sequenceid);\n\t\t\tspin_unlock(&tbl->slot_tbl_lock);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"nfs4session.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\nstatic bool referring_call_exists(struct nfs_client *clp,\n\t\t\t\t  uint32_t nrclists,\n\t\t\t\t  struct referring_call_list *rclists)\n{\n\tbool status = 0;\n\tint i, j;\n\tstruct nfs4_session *session;\n\tstruct nfs4_slot_table *tbl;\n\tstruct referring_call_list *rclist;\n\tstruct referring_call *ref;\n\n\t/*\n\t * XXX When client trunking is implemented, this becomes\n\t * a session lookup from within the loop\n\t */\n\tsession = clp->cl_session;\n\ttbl = &session->fc_slot_table;\n\n\tfor (i = 0; i < nrclists; i++) {\n\t\trclist = &rclists[i];\n\t\tif (memcmp(session->sess_id.data,\n\t\t\t   rclist->rcl_sessionid.data,\n\t\t\t   NFS4_MAX_SESSIONID_LEN) != 0)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < rclist->rcl_nrefcalls; j++) {\n\t\t\tref = &rclist->rcl_refcalls[j];\n\n\t\t\tdprintk(\"%s: sessionid %x:%x:%x:%x sequenceid %u \"\n\t\t\t\t\"slotid %u\\n\", __func__,\n\t\t\t\t((u32 *)&rclist->rcl_sessionid.data)[0],\n\t\t\t\t((u32 *)&rclist->rcl_sessionid.data)[1],\n\t\t\t\t((u32 *)&rclist->rcl_sessionid.data)[2],\n\t\t\t\t((u32 *)&rclist->rcl_sessionid.data)[3],\n\t\t\t\tref->rc_sequenceid, ref->rc_slotid);\n\n\t\t\tspin_lock(&tbl->slot_tbl_lock);\n\t\t\tstatus = (test_bit(ref->rc_slotid, tbl->used_slots) &&\n\t\t\t\t  tbl->slots[ref->rc_slotid].seq_nr ==\n\t\t\t\t\tref->rc_sequenceid);\n\t\t\tspin_unlock(&tbl->slot_tbl_lock);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tbl->slot_tbl_lock"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_seqid",
          "args": [
            "&clp->cl_session->bc_slot_table",
            "args"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "validate_seqid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
          "lines": "315-359",
          "snippet": "static __be32\nvalidate_seqid(struct nfs4_slot_table *tbl, struct cb_sequenceargs * args)\n{\n\tstruct nfs4_slot *slot;\n\n\tdprintk(\"%s enter. slotid %u seqid %u\\n\",\n\t\t__func__, args->csa_slotid, args->csa_sequenceid);\n\n\tif (args->csa_slotid >= NFS41_BC_MAX_CALLBACKS)\n\t\treturn htonl(NFS4ERR_BADSLOT);\n\n\tslot = tbl->slots + args->csa_slotid;\n\tdprintk(\"%s slot table seqid: %u\\n\", __func__, slot->seq_nr);\n\n\t/* Normal */\n\tif (likely(args->csa_sequenceid == slot->seq_nr + 1)) {\n\t\tslot->seq_nr++;\n\t\tgoto out_ok;\n\t}\n\n\t/* Replay */\n\tif (args->csa_sequenceid == slot->seq_nr) {\n\t\tdprintk(\"%s seqid %u is a replay\\n\",\n\t\t\t__func__, args->csa_sequenceid);\n\t\t/* Signal process_op to set this error on next op */\n\t\tif (args->csa_cachethis == 0)\n\t\t\treturn htonl(NFS4ERR_RETRY_UNCACHED_REP);\n\n\t\t/* The ca_maxresponsesize_cached is 0 with no DRC */\n\t\telse if (args->csa_cachethis == 1)\n\t\t\treturn htonl(NFS4ERR_REP_TOO_BIG_TO_CACHE);\n\t}\n\n\t/* Wraparound */\n\tif (args->csa_sequenceid == 1 && (slot->seq_nr + 1) == 0) {\n\t\tslot->seq_nr = 1;\n\t\tgoto out_ok;\n\t}\n\n\t/* Misordered request */\n\treturn htonl(NFS4ERR_SEQ_MISORDERED);\nout_ok:\n\ttbl->highest_used_slotid = args->csa_slotid;\n\treturn htonl(NFS4_OK);\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"nfs4session.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\nstatic __be32\nvalidate_seqid(struct nfs4_slot_table *tbl, struct cb_sequenceargs * args)\n{\n\tstruct nfs4_slot *slot;\n\n\tdprintk(\"%s enter. slotid %u seqid %u\\n\",\n\t\t__func__, args->csa_slotid, args->csa_sequenceid);\n\n\tif (args->csa_slotid >= NFS41_BC_MAX_CALLBACKS)\n\t\treturn htonl(NFS4ERR_BADSLOT);\n\n\tslot = tbl->slots + args->csa_slotid;\n\tdprintk(\"%s slot table seqid: %u\\n\", __func__, slot->seq_nr);\n\n\t/* Normal */\n\tif (likely(args->csa_sequenceid == slot->seq_nr + 1)) {\n\t\tslot->seq_nr++;\n\t\tgoto out_ok;\n\t}\n\n\t/* Replay */\n\tif (args->csa_sequenceid == slot->seq_nr) {\n\t\tdprintk(\"%s seqid %u is a replay\\n\",\n\t\t\t__func__, args->csa_sequenceid);\n\t\t/* Signal process_op to set this error on next op */\n\t\tif (args->csa_cachethis == 0)\n\t\t\treturn htonl(NFS4ERR_RETRY_UNCACHED_REP);\n\n\t\t/* The ca_maxresponsesize_cached is 0 with no DRC */\n\t\telse if (args->csa_cachethis == 1)\n\t\t\treturn htonl(NFS4ERR_REP_TOO_BIG_TO_CACHE);\n\t}\n\n\t/* Wraparound */\n\tif (args->csa_sequenceid == 1 && (slot->seq_nr + 1) == 0) {\n\t\tslot->seq_nr = 1;\n\t\tgoto out_ok;\n\t}\n\n\t/* Misordered request */\n\treturn htonl(NFS4ERR_SEQ_MISORDERED);\nout_ok:\n\ttbl->highest_used_slotid = args->csa_slotid;\n\treturn htonl(NFS4_OK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_BADSESSION"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS4CLNT_SESSION_RESET",
            "&clp->cl_state"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_DELAY"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tbl->slot_tbl_lock"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_find_client_sessionid",
          "args": [
            "cps->net",
            "args->csa_addr",
            "&args->csa_sessionid",
            "cps->minorversion"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_find_client_sessionid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4client.c",
          "lines": "776-781",
          "snippet": "struct nfs_client *\nnfs4_find_client_sessionid(struct net *net, const struct sockaddr *addr,\n\t\t\t   struct nfs4_sessionid *sid, u32 minorversion)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"internal.h\"",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/auth.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"internal.h\"\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/auth.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n\nstruct nfs_client *\nnfs4_find_client_sessionid(struct net *net, const struct sockaddr *addr,\n\t\t\t   struct nfs4_sessionid *sid, u32 minorversion)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_BADSESSION"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\n__be32 nfs4_callback_sequence(struct cb_sequenceargs *args,\n\t\t\t      struct cb_sequenceres *res,\n\t\t\t      struct cb_process_state *cps)\n{\n\tstruct nfs4_slot_table *tbl;\n\tstruct nfs_client *clp;\n\tint i;\n\t__be32 status = htonl(NFS4ERR_BADSESSION);\n\n\tclp = nfs4_find_client_sessionid(cps->net, args->csa_addr,\n\t\t\t\t\t &args->csa_sessionid, cps->minorversion);\n\tif (clp == NULL)\n\t\tgoto out;\n\n\tif (!(clp->cl_session->flags & SESSION4_BACK_CHAN))\n\t\tgoto out;\n\ttbl = &clp->cl_session->bc_slot_table;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\t/* state manager is resetting the session */\n\tif (test_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state)) {\n\t\tspin_unlock(&tbl->slot_tbl_lock);\n\t\tstatus = htonl(NFS4ERR_DELAY);\n\t\t/* Return NFS4ERR_BADSESSION if we're draining the session\n\t\t * in order to reset it.\n\t\t */\n\t\tif (test_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state))\n\t\t\tstatus = htonl(NFS4ERR_BADSESSION);\n\t\tgoto out;\n\t}\n\n\tstatus = validate_seqid(&clp->cl_session->bc_slot_table, args);\n\tspin_unlock(&tbl->slot_tbl_lock);\n\tif (status)\n\t\tgoto out;\n\n\tcps->slotid = args->csa_slotid;\n\n\t/*\n\t * Check for pending referring calls.  If a match is found, a\n\t * related callback was received before the response to the original\n\t * call.\n\t */\n\tif (referring_call_exists(clp, args->csa_nrclists, args->csa_rclists)) {\n\t\tstatus = htonl(NFS4ERR_DELAY);\n\t\tgoto out;\n\t}\n\n\tmemcpy(&res->csr_sessionid, &args->csa_sessionid,\n\t       sizeof(res->csr_sessionid));\n\tres->csr_sequenceid = args->csa_sequenceid;\n\tres->csr_slotid = args->csa_slotid;\n\tres->csr_highestslotid = NFS41_BC_MAX_CALLBACKS - 1;\n\tres->csr_target_highestslotid = NFS41_BC_MAX_CALLBACKS - 1;\n\nout:\n\tcps->clp = clp; /* put in nfs4_callback_compound */\n\tfor (i = 0; i < args->csa_nrclists; i++)\n\t\tkfree(args->csa_rclists[i].rcl_refcalls);\n\tkfree(args->csa_rclists);\n\n\tif (status == htonl(NFS4ERR_RETRY_UNCACHED_REP)) {\n\t\tcps->drc_status = status;\n\t\tstatus = 0;\n\t} else\n\t\tres->csr_status = status;\n\n\ttrace_nfs4_cb_sequence(args, res, status);\n\tdprintk(\"%s: exit with status = %d res->csr_status %d\\n\", __func__,\n\t\tntohl(status), ntohl(res->csr_status));\n\treturn status;\n}"
  },
  {
    "function_name": "referring_call_exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
    "lines": "366-414",
    "snippet": "static bool referring_call_exists(struct nfs_client *clp,\n\t\t\t\t  uint32_t nrclists,\n\t\t\t\t  struct referring_call_list *rclists)\n{\n\tbool status = 0;\n\tint i, j;\n\tstruct nfs4_session *session;\n\tstruct nfs4_slot_table *tbl;\n\tstruct referring_call_list *rclist;\n\tstruct referring_call *ref;\n\n\t/*\n\t * XXX When client trunking is implemented, this becomes\n\t * a session lookup from within the loop\n\t */\n\tsession = clp->cl_session;\n\ttbl = &session->fc_slot_table;\n\n\tfor (i = 0; i < nrclists; i++) {\n\t\trclist = &rclists[i];\n\t\tif (memcmp(session->sess_id.data,\n\t\t\t   rclist->rcl_sessionid.data,\n\t\t\t   NFS4_MAX_SESSIONID_LEN) != 0)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < rclist->rcl_nrefcalls; j++) {\n\t\t\tref = &rclist->rcl_refcalls[j];\n\n\t\t\tdprintk(\"%s: sessionid %x:%x:%x:%x sequenceid %u \"\n\t\t\t\t\"slotid %u\\n\", __func__,\n\t\t\t\t((u32 *)&rclist->rcl_sessionid.data)[0],\n\t\t\t\t((u32 *)&rclist->rcl_sessionid.data)[1],\n\t\t\t\t((u32 *)&rclist->rcl_sessionid.data)[2],\n\t\t\t\t((u32 *)&rclist->rcl_sessionid.data)[3],\n\t\t\t\tref->rc_sequenceid, ref->rc_slotid);\n\n\t\t\tspin_lock(&tbl->slot_tbl_lock);\n\t\t\tstatus = (test_bit(ref->rc_slotid, tbl->used_slots) &&\n\t\t\t\t  tbl->slots[ref->rc_slotid].seq_nr ==\n\t\t\t\t\tref->rc_sequenceid);\n\t\t\tspin_unlock(&tbl->slot_tbl_lock);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"nfs4trace.h\"",
      "#include \"nfs4session.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tbl->slot_tbl_lock"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "ref->rc_slotid",
            "tbl->used_slots"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tbl->slot_tbl_lock"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: sessionid %x:%x:%x:%x sequenceid %u \"\n\t\t\t\t\"slotid %u\\n\"",
            "__func__",
            "((u32 *)&rclist->rcl_sessionid.data)[0]",
            "((u32 *)&rclist->rcl_sessionid.data)[1]",
            "((u32 *)&rclist->rcl_sessionid.data)[2]",
            "((u32 *)&rclist->rcl_sessionid.data)[3]",
            "ref->rc_sequenceid",
            "ref->rc_slotid"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "session->sess_id.data",
            "rclist->rcl_sessionid.data",
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\nstatic bool referring_call_exists(struct nfs_client *clp,\n\t\t\t\t  uint32_t nrclists,\n\t\t\t\t  struct referring_call_list *rclists)\n{\n\tbool status = 0;\n\tint i, j;\n\tstruct nfs4_session *session;\n\tstruct nfs4_slot_table *tbl;\n\tstruct referring_call_list *rclist;\n\tstruct referring_call *ref;\n\n\t/*\n\t * XXX When client trunking is implemented, this becomes\n\t * a session lookup from within the loop\n\t */\n\tsession = clp->cl_session;\n\ttbl = &session->fc_slot_table;\n\n\tfor (i = 0; i < nrclists; i++) {\n\t\trclist = &rclists[i];\n\t\tif (memcmp(session->sess_id.data,\n\t\t\t   rclist->rcl_sessionid.data,\n\t\t\t   NFS4_MAX_SESSIONID_LEN) != 0)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < rclist->rcl_nrefcalls; j++) {\n\t\t\tref = &rclist->rcl_refcalls[j];\n\n\t\t\tdprintk(\"%s: sessionid %x:%x:%x:%x sequenceid %u \"\n\t\t\t\t\"slotid %u\\n\", __func__,\n\t\t\t\t((u32 *)&rclist->rcl_sessionid.data)[0],\n\t\t\t\t((u32 *)&rclist->rcl_sessionid.data)[1],\n\t\t\t\t((u32 *)&rclist->rcl_sessionid.data)[2],\n\t\t\t\t((u32 *)&rclist->rcl_sessionid.data)[3],\n\t\t\t\tref->rc_sequenceid, ref->rc_slotid);\n\n\t\t\tspin_lock(&tbl->slot_tbl_lock);\n\t\t\tstatus = (test_bit(ref->rc_slotid, tbl->used_slots) &&\n\t\t\t\t  tbl->slots[ref->rc_slotid].seq_nr ==\n\t\t\t\t\tref->rc_sequenceid);\n\t\t\tspin_unlock(&tbl->slot_tbl_lock);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "validate_seqid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
    "lines": "315-359",
    "snippet": "static __be32\nvalidate_seqid(struct nfs4_slot_table *tbl, struct cb_sequenceargs * args)\n{\n\tstruct nfs4_slot *slot;\n\n\tdprintk(\"%s enter. slotid %u seqid %u\\n\",\n\t\t__func__, args->csa_slotid, args->csa_sequenceid);\n\n\tif (args->csa_slotid >= NFS41_BC_MAX_CALLBACKS)\n\t\treturn htonl(NFS4ERR_BADSLOT);\n\n\tslot = tbl->slots + args->csa_slotid;\n\tdprintk(\"%s slot table seqid: %u\\n\", __func__, slot->seq_nr);\n\n\t/* Normal */\n\tif (likely(args->csa_sequenceid == slot->seq_nr + 1)) {\n\t\tslot->seq_nr++;\n\t\tgoto out_ok;\n\t}\n\n\t/* Replay */\n\tif (args->csa_sequenceid == slot->seq_nr) {\n\t\tdprintk(\"%s seqid %u is a replay\\n\",\n\t\t\t__func__, args->csa_sequenceid);\n\t\t/* Signal process_op to set this error on next op */\n\t\tif (args->csa_cachethis == 0)\n\t\t\treturn htonl(NFS4ERR_RETRY_UNCACHED_REP);\n\n\t\t/* The ca_maxresponsesize_cached is 0 with no DRC */\n\t\telse if (args->csa_cachethis == 1)\n\t\t\treturn htonl(NFS4ERR_REP_TOO_BIG_TO_CACHE);\n\t}\n\n\t/* Wraparound */\n\tif (args->csa_sequenceid == 1 && (slot->seq_nr + 1) == 0) {\n\t\tslot->seq_nr = 1;\n\t\tgoto out_ok;\n\t}\n\n\t/* Misordered request */\n\treturn htonl(NFS4ERR_SEQ_MISORDERED);\nout_ok:\n\ttbl->highest_used_slotid = args->csa_slotid;\n\treturn htonl(NFS4_OK);\n}",
    "includes": [
      "#include \"nfs4trace.h\"",
      "#include \"nfs4session.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4_OK"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_SEQ_MISORDERED"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_REP_TOO_BIG_TO_CACHE"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RETRY_UNCACHED_REP"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s seqid %u is a replay\\n\"",
            "__func__",
            "args->csa_sequenceid"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "args->csa_sequenceid == slot->seq_nr + 1"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s slot table seqid: %u\\n\"",
            "__func__",
            "slot->seq_nr"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_BADSLOT"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s enter. slotid %u seqid %u\\n\"",
            "__func__",
            "args->csa_slotid",
            "args->csa_sequenceid"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\nstatic __be32\nvalidate_seqid(struct nfs4_slot_table *tbl, struct cb_sequenceargs * args)\n{\n\tstruct nfs4_slot *slot;\n\n\tdprintk(\"%s enter. slotid %u seqid %u\\n\",\n\t\t__func__, args->csa_slotid, args->csa_sequenceid);\n\n\tif (args->csa_slotid >= NFS41_BC_MAX_CALLBACKS)\n\t\treturn htonl(NFS4ERR_BADSLOT);\n\n\tslot = tbl->slots + args->csa_slotid;\n\tdprintk(\"%s slot table seqid: %u\\n\", __func__, slot->seq_nr);\n\n\t/* Normal */\n\tif (likely(args->csa_sequenceid == slot->seq_nr + 1)) {\n\t\tslot->seq_nr++;\n\t\tgoto out_ok;\n\t}\n\n\t/* Replay */\n\tif (args->csa_sequenceid == slot->seq_nr) {\n\t\tdprintk(\"%s seqid %u is a replay\\n\",\n\t\t\t__func__, args->csa_sequenceid);\n\t\t/* Signal process_op to set this error on next op */\n\t\tif (args->csa_cachethis == 0)\n\t\t\treturn htonl(NFS4ERR_RETRY_UNCACHED_REP);\n\n\t\t/* The ca_maxresponsesize_cached is 0 with no DRC */\n\t\telse if (args->csa_cachethis == 1)\n\t\t\treturn htonl(NFS4ERR_REP_TOO_BIG_TO_CACHE);\n\t}\n\n\t/* Wraparound */\n\tif (args->csa_sequenceid == 1 && (slot->seq_nr + 1) == 0) {\n\t\tslot->seq_nr = 1;\n\t\tgoto out_ok;\n\t}\n\n\t/* Misordered request */\n\treturn htonl(NFS4ERR_SEQ_MISORDERED);\nout_ok:\n\ttbl->highest_used_slotid = args->csa_slotid;\n\treturn htonl(NFS4_OK);\n}"
  },
  {
    "function_name": "nfs4_callback_devicenotify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
    "lines": "258-300",
    "snippet": "__be32 nfs4_callback_devicenotify(struct cb_devicenotifyargs *args,\n\t\t\t\t  void *dummy, struct cb_process_state *cps)\n{\n\tint i;\n\t__be32 res = 0;\n\tstruct nfs_client *clp = cps->clp;\n\tstruct nfs_server *server = NULL;\n\n\tdprintk(\"%s: -->\\n\", __func__);\n\n\tif (!clp) {\n\t\tres = cpu_to_be32(NFS4ERR_OP_NOT_IN_SESSION);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < args->ndevs; i++) {\n\t\tstruct cb_devicenotifyitem *dev = &args->devs[i];\n\n\t\tif (!server ||\n\t\t    server->pnfs_curr_ld->id != dev->cbd_layout_type) {\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\t\t\tif (server->pnfs_curr_ld &&\n\t\t\t\t    server->pnfs_curr_ld->id == dev->cbd_layout_type) {\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\tgoto found;\n\t\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t\tdprintk(\"%s: layout type %u not found\\n\",\n\t\t\t\t__func__, dev->cbd_layout_type);\n\t\t\tcontinue;\n\t\t}\n\n\tfound:\n\t\tnfs4_delete_deviceid(server->pnfs_curr_ld, clp, &dev->cbd_dev_id);\n\t}\n\nout:\n\tkfree(args->devs);\n\tdprintk(\"%s: exit with status = %u\\n\",\n\t\t__func__, be32_to_cpu(res));\n\treturn res;\n}",
    "includes": [
      "#include \"nfs4trace.h\"",
      "#include \"nfs4session.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: exit with status = %u\\n\"",
            "__func__",
            "be32_to_cpu(res)"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "res"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "args->devs"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_delete_deviceid",
          "args": [
            "server->pnfs_curr_ld",
            "clp",
            "&dev->cbd_dev_id"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_delete_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "223-244",
          "snippet": "void\nnfs4_delete_deviceid(const struct pnfs_layoutdriver_type *ld,\n\t\t\t const struct nfs_client *clp, const struct nfs4_deviceid *id)\n{\n\tstruct nfs4_deviceid_node *d;\n\n\tspin_lock(&nfs4_deviceid_lock);\n\trcu_read_lock();\n\td = _lookup_deviceid(ld, clp, id, nfs4_deviceid_hash(id));\n\trcu_read_unlock();\n\tif (!d) {\n\t\tspin_unlock(&nfs4_deviceid_lock);\n\t\treturn;\n\t}\n\thlist_del_init_rcu(&d->node);\n\tspin_unlock(&nfs4_deviceid_lock);\n\tsynchronize_rcu();\n\n\t/* balance the initial ref set in pnfs_insert_deviceid */\n\tif (atomic_dec_and_test(&d->ref))\n\t\td->ld->free_deviceid_node(d);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(nfs4_deviceid_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_SPINLOCK(nfs4_deviceid_lock);\n\nvoid\nnfs4_delete_deviceid(const struct pnfs_layoutdriver_type *ld,\n\t\t\t const struct nfs_client *clp, const struct nfs4_deviceid *id)\n{\n\tstruct nfs4_deviceid_node *d;\n\n\tspin_lock(&nfs4_deviceid_lock);\n\trcu_read_lock();\n\td = _lookup_deviceid(ld, clp, id, nfs4_deviceid_hash(id));\n\trcu_read_unlock();\n\tif (!d) {\n\t\tspin_unlock(&nfs4_deviceid_lock);\n\t\treturn;\n\t}\n\thlist_del_init_rcu(&d->node);\n\tspin_unlock(&nfs4_deviceid_lock);\n\tsynchronize_rcu();\n\n\t/* balance the initial ref set in pnfs_insert_deviceid */\n\tif (atomic_dec_and_test(&d->ref))\n\t\td->ld->free_deviceid_node(d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: layout type %u not found\\n\"",
            "__func__",
            "dev->cbd_layout_type"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "server",
            "&clp->cl_superblocks",
            "client_link"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NFS4ERR_OP_NOT_IN_SESSION"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: -->\\n\"",
            "__func__"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\n__be32 nfs4_callback_devicenotify(struct cb_devicenotifyargs *args,\n\t\t\t\t  void *dummy, struct cb_process_state *cps)\n{\n\tint i;\n\t__be32 res = 0;\n\tstruct nfs_client *clp = cps->clp;\n\tstruct nfs_server *server = NULL;\n\n\tdprintk(\"%s: -->\\n\", __func__);\n\n\tif (!clp) {\n\t\tres = cpu_to_be32(NFS4ERR_OP_NOT_IN_SESSION);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < args->ndevs; i++) {\n\t\tstruct cb_devicenotifyitem *dev = &args->devs[i];\n\n\t\tif (!server ||\n\t\t    server->pnfs_curr_ld->id != dev->cbd_layout_type) {\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\n\t\t\t\tif (server->pnfs_curr_ld &&\n\t\t\t\t    server->pnfs_curr_ld->id == dev->cbd_layout_type) {\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\tgoto found;\n\t\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t\tdprintk(\"%s: layout type %u not found\\n\",\n\t\t\t\t__func__, dev->cbd_layout_type);\n\t\t\tcontinue;\n\t\t}\n\n\tfound:\n\t\tnfs4_delete_deviceid(server->pnfs_curr_ld, clp, &dev->cbd_dev_id);\n\t}\n\nout:\n\tkfree(args->devs);\n\tdprintk(\"%s: exit with status = %u\\n\",\n\t\t__func__, be32_to_cpu(res));\n\treturn res;\n}"
  },
  {
    "function_name": "pnfs_recall_all_layouts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
    "lines": "247-256",
    "snippet": "static void pnfs_recall_all_layouts(struct nfs_client *clp)\n{\n\tstruct cb_layoutrecallargs args;\n\n\t/* Pretend we got a CB_LAYOUTRECALL(ALL) */\n\tmemset(&args, 0, sizeof(args));\n\targs.cbl_recall_type = RETURN_ALL;\n\t/* FIXME we ignore errors, what should we do? */\n\tdo_callback_layoutrecall(clp, &args);\n}",
    "includes": [
      "#include \"nfs4trace.h\"",
      "#include \"nfs4session.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_callback_layoutrecall",
          "args": [
            "clp",
            "&args"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "do_callback_layoutrecall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
          "lines": "216-229",
          "snippet": "static u32 do_callback_layoutrecall(struct nfs_client *clp,\n\t\t\t\t    struct cb_layoutrecallargs *args)\n{\n\tu32 res;\n\n\tdprintk(\"%s enter, type=%i\\n\", __func__, args->cbl_recall_type);\n\tif (args->cbl_recall_type == RETURN_FILE)\n\t\tres = initiate_file_draining(clp, args);\n\telse\n\t\tres = initiate_bulk_draining(clp, args);\n\tdprintk(\"%s returning %i\\n\", __func__, res);\n\treturn res;\n\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"nfs4session.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\nstatic u32 do_callback_layoutrecall(struct nfs_client *clp,\n\t\t\t\t    struct cb_layoutrecallargs *args)\n{\n\tu32 res;\n\n\tdprintk(\"%s enter, type=%i\\n\", __func__, args->cbl_recall_type);\n\tif (args->cbl_recall_type == RETURN_FILE)\n\t\tres = initiate_file_draining(clp, args);\n\telse\n\t\tres = initiate_bulk_draining(clp, args);\n\tdprintk(\"%s returning %i\\n\", __func__, res);\n\treturn res;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "0",
            "sizeof(args)"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\nstatic void pnfs_recall_all_layouts(struct nfs_client *clp)\n{\n\tstruct cb_layoutrecallargs args;\n\n\t/* Pretend we got a CB_LAYOUTRECALL(ALL) */\n\tmemset(&args, 0, sizeof(args));\n\targs.cbl_recall_type = RETURN_ALL;\n\t/* FIXME we ignore errors, what should we do? */\n\tdo_callback_layoutrecall(clp, &args);\n}"
  },
  {
    "function_name": "nfs4_callback_layoutrecall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
    "lines": "231-245",
    "snippet": "__be32 nfs4_callback_layoutrecall(struct cb_layoutrecallargs *args,\n\t\t\t\t  void *dummy, struct cb_process_state *cps)\n{\n\tu32 res;\n\n\tdprintk(\"%s: -->\\n\", __func__);\n\n\tif (cps->clp)\n\t\tres = do_callback_layoutrecall(cps->clp, args);\n\telse\n\t\tres = NFS4ERR_OP_NOT_IN_SESSION;\n\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, res);\n\treturn cpu_to_be32(res);\n}",
    "includes": [
      "#include \"nfs4trace.h\"",
      "#include \"nfs4session.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "res"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: exit with status = %d\\n\"",
            "__func__",
            "res"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_callback_layoutrecall",
          "args": [
            "cps->clp",
            "args"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "do_callback_layoutrecall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
          "lines": "216-229",
          "snippet": "static u32 do_callback_layoutrecall(struct nfs_client *clp,\n\t\t\t\t    struct cb_layoutrecallargs *args)\n{\n\tu32 res;\n\n\tdprintk(\"%s enter, type=%i\\n\", __func__, args->cbl_recall_type);\n\tif (args->cbl_recall_type == RETURN_FILE)\n\t\tres = initiate_file_draining(clp, args);\n\telse\n\t\tres = initiate_bulk_draining(clp, args);\n\tdprintk(\"%s returning %i\\n\", __func__, res);\n\treturn res;\n\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"nfs4session.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\nstatic u32 do_callback_layoutrecall(struct nfs_client *clp,\n\t\t\t\t    struct cb_layoutrecallargs *args)\n{\n\tu32 res;\n\n\tdprintk(\"%s enter, type=%i\\n\", __func__, args->cbl_recall_type);\n\tif (args->cbl_recall_type == RETURN_FILE)\n\t\tres = initiate_file_draining(clp, args);\n\telse\n\t\tres = initiate_bulk_draining(clp, args);\n\tdprintk(\"%s returning %i\\n\", __func__, res);\n\treturn res;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: -->\\n\"",
            "__func__"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\n__be32 nfs4_callback_layoutrecall(struct cb_layoutrecallargs *args,\n\t\t\t\t  void *dummy, struct cb_process_state *cps)\n{\n\tu32 res;\n\n\tdprintk(\"%s: -->\\n\", __func__);\n\n\tif (cps->clp)\n\t\tres = do_callback_layoutrecall(cps->clp, args);\n\telse\n\t\tres = NFS4ERR_OP_NOT_IN_SESSION;\n\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, res);\n\treturn cpu_to_be32(res);\n}"
  },
  {
    "function_name": "do_callback_layoutrecall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
    "lines": "216-229",
    "snippet": "static u32 do_callback_layoutrecall(struct nfs_client *clp,\n\t\t\t\t    struct cb_layoutrecallargs *args)\n{\n\tu32 res;\n\n\tdprintk(\"%s enter, type=%i\\n\", __func__, args->cbl_recall_type);\n\tif (args->cbl_recall_type == RETURN_FILE)\n\t\tres = initiate_file_draining(clp, args);\n\telse\n\t\tres = initiate_bulk_draining(clp, args);\n\tdprintk(\"%s returning %i\\n\", __func__, res);\n\treturn res;\n\n}",
    "includes": [
      "#include \"nfs4trace.h\"",
      "#include \"nfs4session.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s returning %i\\n\"",
            "__func__",
            "res"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initiate_bulk_draining",
          "args": [
            "clp",
            "args"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "initiate_bulk_draining",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
          "lines": "202-214",
          "snippet": "static u32 initiate_bulk_draining(struct nfs_client *clp,\n\t\t\t\t  struct cb_layoutrecallargs *args)\n{\n\tint stat;\n\n\tif (args->cbl_recall_type == RETURN_FSID)\n\t\tstat = pnfs_destroy_layouts_byfsid(clp, &args->cbl_fsid, true);\n\telse\n\t\tstat = pnfs_destroy_layouts_byclid(clp, true);\n\tif (stat != 0)\n\t\treturn NFS4ERR_DELAY;\n\treturn NFS4ERR_NOMATCHING_LAYOUT;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"nfs4session.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\nstatic u32 initiate_bulk_draining(struct nfs_client *clp,\n\t\t\t\t  struct cb_layoutrecallargs *args)\n{\n\tint stat;\n\n\tif (args->cbl_recall_type == RETURN_FSID)\n\t\tstat = pnfs_destroy_layouts_byfsid(clp, &args->cbl_fsid, true);\n\telse\n\t\tstat = pnfs_destroy_layouts_byclid(clp, true);\n\tif (stat != 0)\n\t\treturn NFS4ERR_DELAY;\n\treturn NFS4ERR_NOMATCHING_LAYOUT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "initiate_file_draining",
          "args": [
            "clp",
            "args"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "initiate_file_draining",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
          "lines": "161-200",
          "snippet": "static u32 initiate_file_draining(struct nfs_client *clp,\n\t\t\t\t  struct cb_layoutrecallargs *args)\n{\n\tstruct inode *ino;\n\tstruct pnfs_layout_hdr *lo;\n\tu32 rv = NFS4ERR_NOMATCHING_LAYOUT;\n\tLIST_HEAD(free_me_list);\n\n\tlo = get_layout_by_fh(clp, &args->cbl_fh, &args->cbl_stateid);\n\tif (!lo)\n\t\tgoto out;\n\n\tino = lo->plh_inode;\n\n\tspin_lock(&ino->i_lock);\n\tpnfs_set_layout_stateid(lo, &args->cbl_stateid, true);\n\tspin_unlock(&ino->i_lock);\n\n\tpnfs_layoutcommit_inode(ino, false);\n\n\tspin_lock(&ino->i_lock);\n\tif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags) ||\n\t    pnfs_mark_matching_lsegs_invalid(lo, &free_me_list,\n\t\t\t\t\t&args->cbl_range)) {\n\t\trv = NFS4ERR_DELAY;\n\t\tgoto unlock;\n\t}\n\n\tif (NFS_SERVER(ino)->pnfs_curr_ld->return_range) {\n\t\tNFS_SERVER(ino)->pnfs_curr_ld->return_range(lo,\n\t\t\t&args->cbl_range);\n\t}\nunlock:\n\tspin_unlock(&ino->i_lock);\n\tpnfs_free_lseg_list(&free_me_list);\n\tpnfs_put_layout_hdr(lo);\n\tiput(ino);\nout:\n\treturn rv;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"nfs4session.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\nstatic u32 initiate_file_draining(struct nfs_client *clp,\n\t\t\t\t  struct cb_layoutrecallargs *args)\n{\n\tstruct inode *ino;\n\tstruct pnfs_layout_hdr *lo;\n\tu32 rv = NFS4ERR_NOMATCHING_LAYOUT;\n\tLIST_HEAD(free_me_list);\n\n\tlo = get_layout_by_fh(clp, &args->cbl_fh, &args->cbl_stateid);\n\tif (!lo)\n\t\tgoto out;\n\n\tino = lo->plh_inode;\n\n\tspin_lock(&ino->i_lock);\n\tpnfs_set_layout_stateid(lo, &args->cbl_stateid, true);\n\tspin_unlock(&ino->i_lock);\n\n\tpnfs_layoutcommit_inode(ino, false);\n\n\tspin_lock(&ino->i_lock);\n\tif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags) ||\n\t    pnfs_mark_matching_lsegs_invalid(lo, &free_me_list,\n\t\t\t\t\t&args->cbl_range)) {\n\t\trv = NFS4ERR_DELAY;\n\t\tgoto unlock;\n\t}\n\n\tif (NFS_SERVER(ino)->pnfs_curr_ld->return_range) {\n\t\tNFS_SERVER(ino)->pnfs_curr_ld->return_range(lo,\n\t\t\t&args->cbl_range);\n\t}\nunlock:\n\tspin_unlock(&ino->i_lock);\n\tpnfs_free_lseg_list(&free_me_list);\n\tpnfs_put_layout_hdr(lo);\n\tiput(ino);\nout:\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s enter, type=%i\\n\"",
            "__func__",
            "args->cbl_recall_type"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\nstatic u32 do_callback_layoutrecall(struct nfs_client *clp,\n\t\t\t\t    struct cb_layoutrecallargs *args)\n{\n\tu32 res;\n\n\tdprintk(\"%s enter, type=%i\\n\", __func__, args->cbl_recall_type);\n\tif (args->cbl_recall_type == RETURN_FILE)\n\t\tres = initiate_file_draining(clp, args);\n\telse\n\t\tres = initiate_bulk_draining(clp, args);\n\tdprintk(\"%s returning %i\\n\", __func__, res);\n\treturn res;\n\n}"
  },
  {
    "function_name": "initiate_bulk_draining",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
    "lines": "202-214",
    "snippet": "static u32 initiate_bulk_draining(struct nfs_client *clp,\n\t\t\t\t  struct cb_layoutrecallargs *args)\n{\n\tint stat;\n\n\tif (args->cbl_recall_type == RETURN_FSID)\n\t\tstat = pnfs_destroy_layouts_byfsid(clp, &args->cbl_fsid, true);\n\telse\n\t\tstat = pnfs_destroy_layouts_byclid(clp, true);\n\tif (stat != 0)\n\t\treturn NFS4ERR_DELAY;\n\treturn NFS4ERR_NOMATCHING_LAYOUT;\n}",
    "includes": [
      "#include \"nfs4trace.h\"",
      "#include \"nfs4session.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_destroy_layouts_byclid",
          "args": [
            "clp",
            "true"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_destroy_layouts_byclid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "722-744",
          "snippet": "int\npnfs_destroy_layouts_byclid(struct nfs_client *clp,\n\t\tbool is_recall)\n{\n\tstruct nfs_server *server;\n\tLIST_HEAD(layout_list);\n\n\tspin_lock(&clp->cl_lock);\n\trcu_read_lock();\nrestart:\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tif (pnfs_layout_bulk_destroy_byserver_locked(clp,\n\t\t\t\t\tserver,\n\t\t\t\t\t&layout_list) != 0)\n\t\t\tgoto restart;\n\t}\n\trcu_read_unlock();\n\tspin_unlock(&clp->cl_lock);\n\n\tif (list_empty(&layout_list))\n\t\treturn 0;\n\treturn pnfs_layout_free_bulk_destroy_list(&layout_list, is_recall);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint\npnfs_destroy_layouts_byclid(struct nfs_client *clp,\n\t\tbool is_recall)\n{\n\tstruct nfs_server *server;\n\tLIST_HEAD(layout_list);\n\n\tspin_lock(&clp->cl_lock);\n\trcu_read_lock();\nrestart:\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tif (pnfs_layout_bulk_destroy_byserver_locked(clp,\n\t\t\t\t\tserver,\n\t\t\t\t\t&layout_list) != 0)\n\t\t\tgoto restart;\n\t}\n\trcu_read_unlock();\n\tspin_unlock(&clp->cl_lock);\n\n\tif (list_empty(&layout_list))\n\t\treturn 0;\n\treturn pnfs_layout_free_bulk_destroy_list(&layout_list, is_recall);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_destroy_layouts_byfsid",
          "args": [
            "clp",
            "&args->cbl_fsid",
            "true"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_destroy_layouts_byfsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "695-720",
          "snippet": "int\npnfs_destroy_layouts_byfsid(struct nfs_client *clp,\n\t\tstruct nfs_fsid *fsid,\n\t\tbool is_recall)\n{\n\tstruct nfs_server *server;\n\tLIST_HEAD(layout_list);\n\n\tspin_lock(&clp->cl_lock);\n\trcu_read_lock();\nrestart:\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tif (memcmp(&server->fsid, fsid, sizeof(*fsid)) != 0)\n\t\t\tcontinue;\n\t\tif (pnfs_layout_bulk_destroy_byserver_locked(clp,\n\t\t\t\tserver,\n\t\t\t\t&layout_list) != 0)\n\t\t\tgoto restart;\n\t}\n\trcu_read_unlock();\n\tspin_unlock(&clp->cl_lock);\n\n\tif (list_empty(&layout_list))\n\t\treturn 0;\n\treturn pnfs_layout_free_bulk_destroy_list(&layout_list, is_recall);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint\npnfs_destroy_layouts_byfsid(struct nfs_client *clp,\n\t\tstruct nfs_fsid *fsid,\n\t\tbool is_recall)\n{\n\tstruct nfs_server *server;\n\tLIST_HEAD(layout_list);\n\n\tspin_lock(&clp->cl_lock);\n\trcu_read_lock();\nrestart:\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tif (memcmp(&server->fsid, fsid, sizeof(*fsid)) != 0)\n\t\t\tcontinue;\n\t\tif (pnfs_layout_bulk_destroy_byserver_locked(clp,\n\t\t\t\tserver,\n\t\t\t\t&layout_list) != 0)\n\t\t\tgoto restart;\n\t}\n\trcu_read_unlock();\n\tspin_unlock(&clp->cl_lock);\n\n\tif (list_empty(&layout_list))\n\t\treturn 0;\n\treturn pnfs_layout_free_bulk_destroy_list(&layout_list, is_recall);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\nstatic u32 initiate_bulk_draining(struct nfs_client *clp,\n\t\t\t\t  struct cb_layoutrecallargs *args)\n{\n\tint stat;\n\n\tif (args->cbl_recall_type == RETURN_FSID)\n\t\tstat = pnfs_destroy_layouts_byfsid(clp, &args->cbl_fsid, true);\n\telse\n\t\tstat = pnfs_destroy_layouts_byclid(clp, true);\n\tif (stat != 0)\n\t\treturn NFS4ERR_DELAY;\n\treturn NFS4ERR_NOMATCHING_LAYOUT;\n}"
  },
  {
    "function_name": "initiate_file_draining",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
    "lines": "161-200",
    "snippet": "static u32 initiate_file_draining(struct nfs_client *clp,\n\t\t\t\t  struct cb_layoutrecallargs *args)\n{\n\tstruct inode *ino;\n\tstruct pnfs_layout_hdr *lo;\n\tu32 rv = NFS4ERR_NOMATCHING_LAYOUT;\n\tLIST_HEAD(free_me_list);\n\n\tlo = get_layout_by_fh(clp, &args->cbl_fh, &args->cbl_stateid);\n\tif (!lo)\n\t\tgoto out;\n\n\tino = lo->plh_inode;\n\n\tspin_lock(&ino->i_lock);\n\tpnfs_set_layout_stateid(lo, &args->cbl_stateid, true);\n\tspin_unlock(&ino->i_lock);\n\n\tpnfs_layoutcommit_inode(ino, false);\n\n\tspin_lock(&ino->i_lock);\n\tif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags) ||\n\t    pnfs_mark_matching_lsegs_invalid(lo, &free_me_list,\n\t\t\t\t\t&args->cbl_range)) {\n\t\trv = NFS4ERR_DELAY;\n\t\tgoto unlock;\n\t}\n\n\tif (NFS_SERVER(ino)->pnfs_curr_ld->return_range) {\n\t\tNFS_SERVER(ino)->pnfs_curr_ld->return_range(lo,\n\t\t\t&args->cbl_range);\n\t}\nunlock:\n\tspin_unlock(&ino->i_lock);\n\tpnfs_free_lseg_list(&free_me_list);\n\tpnfs_put_layout_hdr(lo);\n\tiput(ino);\nout:\n\treturn rv;\n}",
    "includes": [
      "#include \"nfs4trace.h\"",
      "#include \"nfs4session.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "ino"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_iput_and_deactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "527-535",
          "snippet": "static inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);",
            "extern struct inode *nfs_alloc_inode(struct super_block *sb);",
            "extern void nfs_destroy_inode(struct inode *);",
            "extern int nfs_drop_inode(struct inode *);",
            "extern void nfs_clear_inode(struct inode *);",
            "extern void nfs_evict_inode(struct inode *);",
            "void nfs_zap_acl_cache(struct inode *inode);",
            "void nfs_initialise_sb(struct super_block *);",
            "void nfs_kill_super(struct super_block *);",
            "extern bool nfs_sb_active(struct super_block *sb);",
            "extern void nfs_sb_deactive(struct super_block *sb);",
            "void nfs_umount_begin(struct super_block *);",
            "int nfs_key_timeout_notify(struct file *filp, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nextern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);\nextern struct inode *nfs_alloc_inode(struct super_block *sb);\nextern void nfs_destroy_inode(struct inode *);\nextern int nfs_drop_inode(struct inode *);\nextern void nfs_clear_inode(struct inode *);\nextern void nfs_evict_inode(struct inode *);\nvoid nfs_zap_acl_cache(struct inode *inode);\nvoid nfs_initialise_sb(struct super_block *);\nvoid nfs_kill_super(struct super_block *);\nextern bool nfs_sb_active(struct super_block *sb);\nextern void nfs_sb_deactive(struct super_block *sb);\nvoid nfs_umount_begin(struct super_block *);\nint nfs_key_timeout_notify(struct file *filp, struct inode *inode);\n\nstatic inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_put_layout_hdr",
          "args": [
            "lo"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_put_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "240-252",
          "snippet": "void\npnfs_put_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tif (atomic_dec_and_lock(&lo->plh_refcount, &inode->i_lock)) {\n\t\tif (!list_empty(&lo->plh_segs))\n\t\t\tWARN_ONCE(1, \"NFS: BUG unfreed layout segments.\\n\");\n\t\tpnfs_detach_layout_hdr(lo);\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_layout_hdr(lo);\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_put_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct inode *inode = lo->plh_inode;\n\n\tif (atomic_dec_and_lock(&lo->plh_refcount, &inode->i_lock)) {\n\t\tif (!list_empty(&lo->plh_segs))\n\t\t\tWARN_ONCE(1, \"NFS: BUG unfreed layout segments.\\n\");\n\t\tpnfs_detach_layout_hdr(lo);\n\t\tspin_unlock(&inode->i_lock);\n\t\tpnfs_free_layout_hdr(lo);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_free_lseg_list",
          "args": [
            "&free_me_list"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_free_lseg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "576-588",
          "snippet": "void\npnfs_free_lseg_list(struct list_head *free_me)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (list_empty(free_me))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, tmp, free_me, pls_list) {\n\t\tlist_del(&lseg->pls_list);\n\t\tpnfs_free_lseg(lseg);\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_free_lseg_list(struct list_head *free_me)\n{\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\n\tif (list_empty(free_me))\n\t\treturn;\n\n\tlist_for_each_entry_safe(lseg, tmp, free_me, pls_list) {\n\t\tlist_del(&lseg->pls_list);\n\t\tpnfs_free_lseg(lseg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ino->i_lock"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "lo",
            "&args->cbl_range"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "ino"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "ino"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_mark_matching_lsegs_invalid",
          "args": [
            "lo",
            "&free_me_list",
            "&args->cbl_range"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_mark_matching_lsegs_invalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "549-573",
          "snippet": "int\npnfs_mark_matching_lsegs_invalid(struct pnfs_layout_hdr *lo,\n\t\t\t    struct list_head *tmp_list,\n\t\t\t    struct pnfs_layout_range *recall_range)\n{\n\tstruct pnfs_layout_segment *lseg, *next;\n\tint invalid = 0, removed = 0;\n\n\tdprintk(\"%s:Begin lo %p\\n\", __func__, lo);\n\n\tif (list_empty(&lo->plh_segs))\n\t\treturn 0;\n\tlist_for_each_entry_safe(lseg, next, &lo->plh_segs, pls_list)\n\t\tif (!recall_range ||\n\t\t    should_free_lseg(&lseg->pls_range, recall_range)) {\n\t\t\tdprintk(\"%s: freeing lseg %p iomode %d \"\n\t\t\t\t\"offset %llu length %llu\\n\", __func__,\n\t\t\t\tlseg, lseg->pls_range.iomode, lseg->pls_range.offset,\n\t\t\t\tlseg->pls_range.length);\n\t\t\tinvalid++;\n\t\t\tremoved += mark_lseg_invalid(lseg, tmp_list);\n\t\t}\n\tdprintk(\"%s:Return %i\\n\", __func__, invalid - removed);\n\treturn invalid - removed;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint\npnfs_mark_matching_lsegs_invalid(struct pnfs_layout_hdr *lo,\n\t\t\t    struct list_head *tmp_list,\n\t\t\t    struct pnfs_layout_range *recall_range)\n{\n\tstruct pnfs_layout_segment *lseg, *next;\n\tint invalid = 0, removed = 0;\n\n\tdprintk(\"%s:Begin lo %p\\n\", __func__, lo);\n\n\tif (list_empty(&lo->plh_segs))\n\t\treturn 0;\n\tlist_for_each_entry_safe(lseg, next, &lo->plh_segs, pls_list)\n\t\tif (!recall_range ||\n\t\t    should_free_lseg(&lseg->pls_range, recall_range)) {\n\t\t\tdprintk(\"%s: freeing lseg %p iomode %d \"\n\t\t\t\t\"offset %llu length %llu\\n\", __func__,\n\t\t\t\tlseg, lseg->pls_range.iomode, lseg->pls_range.offset,\n\t\t\t\tlseg->pls_range.length);\n\t\t\tinvalid++;\n\t\t\tremoved += mark_lseg_invalid(lseg, tmp_list);\n\t\t}\n\tdprintk(\"%s:Return %i\\n\", __func__, invalid - removed);\n\treturn invalid - removed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_LAYOUT_BULK_RECALL",
            "&lo->plh_flags"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ino->i_lock"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_layoutcommit_inode",
          "args": [
            "ino",
            "false"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layoutcommit_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "642-645",
          "snippet": "static inline int pnfs_layoutcommit_inode(struct inode *inode, bool sync)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline int pnfs_layoutcommit_inode(struct inode *inode, bool sync)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_set_layout_stateid",
          "args": [
            "lo",
            "&args->cbl_stateid",
            "true"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_set_layout_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "769-791",
          "snippet": "void\npnfs_set_layout_stateid(struct pnfs_layout_hdr *lo, const nfs4_stateid *new,\n\t\t\tbool update_barrier)\n{\n\tu32 oldseq, newseq, new_barrier;\n\tint empty = list_empty(&lo->plh_segs);\n\n\toldseq = be32_to_cpu(lo->plh_stateid.seqid);\n\tnewseq = be32_to_cpu(new->seqid);\n\tif (empty || pnfs_seqid_is_newer(newseq, oldseq)) {\n\t\tnfs4_stateid_copy(&lo->plh_stateid, new);\n\t\tif (update_barrier) {\n\t\t\tnew_barrier = be32_to_cpu(new->seqid);\n\t\t} else {\n\t\t\t/* Because of wraparound, we want to keep the barrier\n\t\t\t * \"close\" to the current seqids.\n\t\t\t */\n\t\t\tnew_barrier = newseq - atomic_read(&lo->plh_outstanding);\n\t\t}\n\t\tif (empty || pnfs_seqid_is_newer(new_barrier, lo->plh_barrier))\n\t\t\tlo->plh_barrier = new_barrier;\n\t}\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_set_layout_stateid(struct pnfs_layout_hdr *lo, const nfs4_stateid *new,\n\t\t\tbool update_barrier)\n{\n\tu32 oldseq, newseq, new_barrier;\n\tint empty = list_empty(&lo->plh_segs);\n\n\toldseq = be32_to_cpu(lo->plh_stateid.seqid);\n\tnewseq = be32_to_cpu(new->seqid);\n\tif (empty || pnfs_seqid_is_newer(newseq, oldseq)) {\n\t\tnfs4_stateid_copy(&lo->plh_stateid, new);\n\t\tif (update_barrier) {\n\t\t\tnew_barrier = be32_to_cpu(new->seqid);\n\t\t} else {\n\t\t\t/* Because of wraparound, we want to keep the barrier\n\t\t\t * \"close\" to the current seqids.\n\t\t\t */\n\t\t\tnew_barrier = newseq - atomic_read(&lo->plh_outstanding);\n\t\t}\n\t\tif (empty || pnfs_seqid_is_newer(new_barrier, lo->plh_barrier))\n\t\t\tlo->plh_barrier = new_barrier;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_layout_by_fh",
          "args": [
            "clp",
            "&args->cbl_fh",
            "&args->cbl_stateid"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "get_layout_by_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
          "lines": "147-159",
          "snippet": "static struct pnfs_layout_hdr * get_layout_by_fh(struct nfs_client *clp,\n\t\tstruct nfs_fh *fh, nfs4_stateid *stateid)\n{\n\tstruct pnfs_layout_hdr *lo;\n\n\tspin_lock(&clp->cl_lock);\n\trcu_read_lock();\n\tlo = get_layout_by_fh_locked(clp, fh, stateid);\n\trcu_read_unlock();\n\tspin_unlock(&clp->cl_lock);\n\n\treturn lo;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"nfs4session.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\nstatic struct pnfs_layout_hdr * get_layout_by_fh(struct nfs_client *clp,\n\t\tstruct nfs_fh *fh, nfs4_stateid *stateid)\n{\n\tstruct pnfs_layout_hdr *lo;\n\n\tspin_lock(&clp->cl_lock);\n\trcu_read_lock();\n\tlo = get_layout_by_fh_locked(clp, fh, stateid);\n\trcu_read_unlock();\n\tspin_unlock(&clp->cl_lock);\n\n\treturn lo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "free_me_list"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\nstatic u32 initiate_file_draining(struct nfs_client *clp,\n\t\t\t\t  struct cb_layoutrecallargs *args)\n{\n\tstruct inode *ino;\n\tstruct pnfs_layout_hdr *lo;\n\tu32 rv = NFS4ERR_NOMATCHING_LAYOUT;\n\tLIST_HEAD(free_me_list);\n\n\tlo = get_layout_by_fh(clp, &args->cbl_fh, &args->cbl_stateid);\n\tif (!lo)\n\t\tgoto out;\n\n\tino = lo->plh_inode;\n\n\tspin_lock(&ino->i_lock);\n\tpnfs_set_layout_stateid(lo, &args->cbl_stateid, true);\n\tspin_unlock(&ino->i_lock);\n\n\tpnfs_layoutcommit_inode(ino, false);\n\n\tspin_lock(&ino->i_lock);\n\tif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags) ||\n\t    pnfs_mark_matching_lsegs_invalid(lo, &free_me_list,\n\t\t\t\t\t&args->cbl_range)) {\n\t\trv = NFS4ERR_DELAY;\n\t\tgoto unlock;\n\t}\n\n\tif (NFS_SERVER(ino)->pnfs_curr_ld->return_range) {\n\t\tNFS_SERVER(ino)->pnfs_curr_ld->return_range(lo,\n\t\t\t&args->cbl_range);\n\t}\nunlock:\n\tspin_unlock(&ino->i_lock);\n\tpnfs_free_lseg_list(&free_me_list);\n\tpnfs_put_layout_hdr(lo);\n\tiput(ino);\nout:\n\treturn rv;\n}"
  },
  {
    "function_name": "get_layout_by_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
    "lines": "147-159",
    "snippet": "static struct pnfs_layout_hdr * get_layout_by_fh(struct nfs_client *clp,\n\t\tstruct nfs_fh *fh, nfs4_stateid *stateid)\n{\n\tstruct pnfs_layout_hdr *lo;\n\n\tspin_lock(&clp->cl_lock);\n\trcu_read_lock();\n\tlo = get_layout_by_fh_locked(clp, fh, stateid);\n\trcu_read_unlock();\n\tspin_unlock(&clp->cl_lock);\n\n\treturn lo;\n}",
    "includes": [
      "#include \"nfs4trace.h\"",
      "#include \"nfs4session.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_layout_by_fh_locked",
          "args": [
            "clp",
            "fh",
            "stateid"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "get_layout_by_fh_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
          "lines": "115-145",
          "snippet": "static struct pnfs_layout_hdr * get_layout_by_fh_locked(struct nfs_client *clp,\n\t\tstruct nfs_fh *fh, nfs4_stateid *stateid)\n{\n\tstruct nfs_server *server;\n\tstruct inode *ino;\n\tstruct pnfs_layout_hdr *lo;\n\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tlist_for_each_entry(lo, &server->layouts, plh_layouts) {\n\t\t\tif (!nfs4_stateid_match_other(&lo->plh_stateid, stateid))\n\t\t\t\tcontinue;\n\t\t\tif (nfs_compare_fh(fh, &NFS_I(lo->plh_inode)->fh))\n\t\t\t\tcontinue;\n\t\t\tino = igrab(lo->plh_inode);\n\t\t\tif (!ino)\n\t\t\t\tbreak;\n\t\t\tspin_lock(&ino->i_lock);\n\t\t\t/* Is this layout in the process of being freed? */\n\t\t\tif (NFS_I(ino)->layout != lo) {\n\t\t\t\tspin_unlock(&ino->i_lock);\n\t\t\t\tiput(ino);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpnfs_get_layout_hdr(lo);\n\t\t\tspin_unlock(&ino->i_lock);\n\t\t\treturn lo;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"nfs4session.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\nstatic struct pnfs_layout_hdr * get_layout_by_fh_locked(struct nfs_client *clp,\n\t\tstruct nfs_fh *fh, nfs4_stateid *stateid)\n{\n\tstruct nfs_server *server;\n\tstruct inode *ino;\n\tstruct pnfs_layout_hdr *lo;\n\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tlist_for_each_entry(lo, &server->layouts, plh_layouts) {\n\t\t\tif (!nfs4_stateid_match_other(&lo->plh_stateid, stateid))\n\t\t\t\tcontinue;\n\t\t\tif (nfs_compare_fh(fh, &NFS_I(lo->plh_inode)->fh))\n\t\t\t\tcontinue;\n\t\t\tino = igrab(lo->plh_inode);\n\t\t\tif (!ino)\n\t\t\t\tbreak;\n\t\t\tspin_lock(&ino->i_lock);\n\t\t\t/* Is this layout in the process of being freed? */\n\t\t\tif (NFS_I(ino)->layout != lo) {\n\t\t\t\tspin_unlock(&ino->i_lock);\n\t\t\t\tiput(ino);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpnfs_get_layout_hdr(lo);\n\t\t\tspin_unlock(&ino->i_lock);\n\t\t\treturn lo;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\nstatic struct pnfs_layout_hdr * get_layout_by_fh(struct nfs_client *clp,\n\t\tstruct nfs_fh *fh, nfs4_stateid *stateid)\n{\n\tstruct pnfs_layout_hdr *lo;\n\n\tspin_lock(&clp->cl_lock);\n\trcu_read_lock();\n\tlo = get_layout_by_fh_locked(clp, fh, stateid);\n\trcu_read_unlock();\n\tspin_unlock(&clp->cl_lock);\n\n\treturn lo;\n}"
  },
  {
    "function_name": "get_layout_by_fh_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
    "lines": "115-145",
    "snippet": "static struct pnfs_layout_hdr * get_layout_by_fh_locked(struct nfs_client *clp,\n\t\tstruct nfs_fh *fh, nfs4_stateid *stateid)\n{\n\tstruct nfs_server *server;\n\tstruct inode *ino;\n\tstruct pnfs_layout_hdr *lo;\n\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tlist_for_each_entry(lo, &server->layouts, plh_layouts) {\n\t\t\tif (!nfs4_stateid_match_other(&lo->plh_stateid, stateid))\n\t\t\t\tcontinue;\n\t\t\tif (nfs_compare_fh(fh, &NFS_I(lo->plh_inode)->fh))\n\t\t\t\tcontinue;\n\t\t\tino = igrab(lo->plh_inode);\n\t\t\tif (!ino)\n\t\t\t\tbreak;\n\t\t\tspin_lock(&ino->i_lock);\n\t\t\t/* Is this layout in the process of being freed? */\n\t\t\tif (NFS_I(ino)->layout != lo) {\n\t\t\t\tspin_unlock(&ino->i_lock);\n\t\t\t\tiput(ino);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpnfs_get_layout_hdr(lo);\n\t\t\tspin_unlock(&ino->i_lock);\n\t\t\treturn lo;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"nfs4trace.h\"",
      "#include \"nfs4session.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ino->i_lock"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_get_layout_hdr",
          "args": [
            "lo"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_get_layout_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "199-203",
          "snippet": "void\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tatomic_inc(&lo->plh_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "ino"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_iput_and_deactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "527-535",
          "snippet": "static inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);",
            "extern struct inode *nfs_alloc_inode(struct super_block *sb);",
            "extern void nfs_destroy_inode(struct inode *);",
            "extern int nfs_drop_inode(struct inode *);",
            "extern void nfs_clear_inode(struct inode *);",
            "extern void nfs_evict_inode(struct inode *);",
            "void nfs_zap_acl_cache(struct inode *inode);",
            "void nfs_initialise_sb(struct super_block *);",
            "void nfs_kill_super(struct super_block *);",
            "extern bool nfs_sb_active(struct super_block *sb);",
            "extern void nfs_sb_deactive(struct super_block *sb);",
            "void nfs_umount_begin(struct super_block *);",
            "int nfs_key_timeout_notify(struct file *filp, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nextern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);\nextern struct inode *nfs_alloc_inode(struct super_block *sb);\nextern void nfs_destroy_inode(struct inode *);\nextern int nfs_drop_inode(struct inode *);\nextern void nfs_clear_inode(struct inode *);\nextern void nfs_evict_inode(struct inode *);\nvoid nfs_zap_acl_cache(struct inode *inode);\nvoid nfs_initialise_sb(struct super_block *);\nvoid nfs_kill_super(struct super_block *);\nextern bool nfs_sb_active(struct super_block *sb);\nextern void nfs_sb_deactive(struct super_block *sb);\nvoid nfs_umount_begin(struct super_block *);\nint nfs_key_timeout_notify(struct file *filp, struct inode *inode);\n\nstatic inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "ino"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ino->i_lock"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "lo->plh_inode"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_igrab_and_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "517-525",
          "snippet": "static inline struct inode *nfs_igrab_and_active(struct inode *inode)\n{\n\tinode = igrab(inode);\n\tif (inode != NULL && !nfs_sb_active(inode->i_sb)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);",
            "extern void nfs_destroy_inode(struct inode *);",
            "extern int nfs_drop_inode(struct inode *);",
            "extern void nfs_clear_inode(struct inode *);",
            "extern void nfs_evict_inode(struct inode *);",
            "void nfs_zap_acl_cache(struct inode *inode);",
            "int nfs_key_timeout_notify(struct file *filp, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nextern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);\nextern void nfs_destroy_inode(struct inode *);\nextern int nfs_drop_inode(struct inode *);\nextern void nfs_clear_inode(struct inode *);\nextern void nfs_evict_inode(struct inode *);\nvoid nfs_zap_acl_cache(struct inode *inode);\nint nfs_key_timeout_notify(struct file *filp, struct inode *inode);\n\nstatic inline struct inode *nfs_igrab_and_active(struct inode *inode)\n{\n\tinode = igrab(inode);\n\tif (inode != NULL && !nfs_sb_active(inode->i_sb)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_compare_fh",
          "args": [
            "fh",
            "&NFS_I(lo->plh_inode)->fh"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "lo->plh_inode"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_stateid_match_other",
          "args": [
            "&lo->plh_stateid",
            "stateid"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_stateid_match_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4_fs.h",
          "lines": "506-509",
          "snippet": "static inline bool nfs4_stateid_match_other(const nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\treturn memcmp(dst->other, src->other, NFS4_STATEID_OTHER_SIZE) == 0;\n}",
          "includes": [
            "#include <linux/seqlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n\nstatic inline bool nfs4_stateid_match_other(const nfs4_stateid *dst, const nfs4_stateid *src)\n{\n\treturn memcmp(dst->other, src->other, NFS4_STATEID_OTHER_SIZE) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lo",
            "&server->layouts",
            "plh_layouts"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "server",
            "&clp->cl_superblocks",
            "client_link"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\nstatic struct pnfs_layout_hdr * get_layout_by_fh_locked(struct nfs_client *clp,\n\t\tstruct nfs_fh *fh, nfs4_stateid *stateid)\n{\n\tstruct nfs_server *server;\n\tstruct inode *ino;\n\tstruct pnfs_layout_hdr *lo;\n\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tlist_for_each_entry(lo, &server->layouts, plh_layouts) {\n\t\t\tif (!nfs4_stateid_match_other(&lo->plh_stateid, stateid))\n\t\t\t\tcontinue;\n\t\t\tif (nfs_compare_fh(fh, &NFS_I(lo->plh_inode)->fh))\n\t\t\t\tcontinue;\n\t\t\tino = igrab(lo->plh_inode);\n\t\t\tif (!ino)\n\t\t\t\tbreak;\n\t\t\tspin_lock(&ino->i_lock);\n\t\t\t/* Is this layout in the process of being freed? */\n\t\t\tif (NFS_I(ino)->layout != lo) {\n\t\t\t\tspin_unlock(&ino->i_lock);\n\t\t\t\tiput(ino);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpnfs_get_layout_hdr(lo);\n\t\t\tspin_unlock(&ino->i_lock);\n\t\t\treturn lo;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "nfs4_callback_recall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
    "lines": "69-102",
    "snippet": "__be32 nfs4_callback_recall(struct cb_recallargs *args, void *dummy,\n\t\t\t    struct cb_process_state *cps)\n{\n\tstruct inode *inode;\n\t__be32 res;\n\t\n\tres = htonl(NFS4ERR_OP_NOT_IN_SESSION);\n\tif (!cps->clp) /* Always set for v4.0. Set in cb_sequence for v4.1 */\n\t\tgoto out;\n\n\tdprintk_rcu(\"NFS: RECALL callback request from %s\\n\",\n\t\trpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\n\tres = htonl(NFS4ERR_BADHANDLE);\n\tinode = nfs_delegation_find_inode(cps->clp, &args->fh);\n\tif (inode == NULL)\n\t\tgoto out;\n\t/* Set up a helper thread to actually return the delegation */\n\tswitch (nfs_async_inode_return_delegation(inode, &args->stateid)) {\n\tcase 0:\n\t\tres = 0;\n\t\tbreak;\n\tcase -ENOENT:\n\t\tres = htonl(NFS4ERR_BAD_STATEID);\n\t\tbreak;\n\tdefault:\n\t\tres = htonl(NFS4ERR_RESOURCE);\n\t}\n\ttrace_nfs4_recall_delegation(inode, -ntohl(res));\n\tiput(inode);\nout:\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, ntohl(res));\n\treturn res;\n}",
    "includes": [
      "#include \"nfs4trace.h\"",
      "#include \"nfs4session.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: exit with status = %d\\n\"",
            "__func__",
            "ntohl(res)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "res"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_iput_and_deactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "527-535",
          "snippet": "static inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);",
            "extern struct inode *nfs_alloc_inode(struct super_block *sb);",
            "extern void nfs_destroy_inode(struct inode *);",
            "extern int nfs_drop_inode(struct inode *);",
            "extern void nfs_clear_inode(struct inode *);",
            "extern void nfs_evict_inode(struct inode *);",
            "void nfs_zap_acl_cache(struct inode *inode);",
            "void nfs_initialise_sb(struct super_block *);",
            "void nfs_kill_super(struct super_block *);",
            "extern bool nfs_sb_active(struct super_block *sb);",
            "extern void nfs_sb_deactive(struct super_block *sb);",
            "void nfs_umount_begin(struct super_block *);",
            "int nfs_key_timeout_notify(struct file *filp, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nextern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);\nextern struct inode *nfs_alloc_inode(struct super_block *sb);\nextern void nfs_destroy_inode(struct inode *);\nextern int nfs_drop_inode(struct inode *);\nextern void nfs_clear_inode(struct inode *);\nextern void nfs_evict_inode(struct inode *);\nvoid nfs_zap_acl_cache(struct inode *inode);\nvoid nfs_initialise_sb(struct super_block *);\nvoid nfs_kill_super(struct super_block *);\nextern bool nfs_sb_active(struct super_block *sb);\nextern void nfs_sb_deactive(struct super_block *sb);\nvoid nfs_umount_begin(struct super_block *);\nint nfs_key_timeout_notify(struct file *filp, struct inode *inode);\n\nstatic inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_nfs4_recall_delegation",
          "args": [
            "inode",
            "-ntohl(res)"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "res"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_BAD_STATEID"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_async_inode_return_delegation",
          "args": [
            "inode",
            "&args->stateid"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_async_inode_return_delegation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/delegation.c",
          "lines": "715-739",
          "snippet": "int nfs_async_inode_return_delegation(struct inode *inode,\n\t\t\t\t      const nfs4_stateid *stateid)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs_delegation *delegation;\n\n\tfilemap_flush(inode->i_mapping);\n\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (delegation == NULL)\n\t\tgoto out_enoent;\n\n\tif (!clp->cl_mvops->match_stateid(&delegation->stateid, stateid))\n\t\tgoto out_enoent;\n\tnfs_mark_return_delegation(server, delegation);\n\trcu_read_unlock();\n\n\tnfs_delegation_run_state_manager(clp);\n\treturn 0;\nout_enoent:\n\trcu_read_unlock();\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n\nint nfs_async_inode_return_delegation(struct inode *inode,\n\t\t\t\t      const nfs4_stateid *stateid)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs_delegation *delegation;\n\n\tfilemap_flush(inode->i_mapping);\n\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (delegation == NULL)\n\t\tgoto out_enoent;\n\n\tif (!clp->cl_mvops->match_stateid(&delegation->stateid, stateid))\n\t\tgoto out_enoent;\n\tnfs_mark_return_delegation(server, delegation);\n\trcu_read_unlock();\n\n\tnfs_delegation_run_state_manager(clp);\n\treturn 0;\nout_enoent:\n\trcu_read_unlock();\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_delegation_find_inode",
          "args": [
            "cps->clp",
            "&args->fh"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_delegation_find_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/delegation.c",
          "lines": "769-783",
          "snippet": "struct inode *nfs_delegation_find_inode(struct nfs_client *clp,\n\t\t\t\t\tconst struct nfs_fh *fhandle)\n{\n\tstruct nfs_server *server;\n\tstruct inode *res = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tres = nfs_delegation_find_inode_server(server, fhandle);\n\t\tif (res != NULL)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn res;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n\nstruct inode *nfs_delegation_find_inode(struct nfs_client *clp,\n\t\t\t\t\tconst struct nfs_fh *fhandle)\n{\n\tstruct nfs_server *server;\n\tstruct inode *res = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tres = nfs_delegation_find_inode_server(server, fhandle);\n\t\tif (res != NULL)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_BADHANDLE"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk_rcu",
          "args": [
            "\"NFS: RECALL callback request from %s\\n\"",
            "rpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_peeraddr2str",
          "args": [
            "cps->clp->cl_rpcclient",
            "RPC_DISPLAY_ADDR"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_OP_NOT_IN_SESSION"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\n__be32 nfs4_callback_recall(struct cb_recallargs *args, void *dummy,\n\t\t\t    struct cb_process_state *cps)\n{\n\tstruct inode *inode;\n\t__be32 res;\n\t\n\tres = htonl(NFS4ERR_OP_NOT_IN_SESSION);\n\tif (!cps->clp) /* Always set for v4.0. Set in cb_sequence for v4.1 */\n\t\tgoto out;\n\n\tdprintk_rcu(\"NFS: RECALL callback request from %s\\n\",\n\t\trpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\n\tres = htonl(NFS4ERR_BADHANDLE);\n\tinode = nfs_delegation_find_inode(cps->clp, &args->fh);\n\tif (inode == NULL)\n\t\tgoto out;\n\t/* Set up a helper thread to actually return the delegation */\n\tswitch (nfs_async_inode_return_delegation(inode, &args->stateid)) {\n\tcase 0:\n\t\tres = 0;\n\t\tbreak;\n\tcase -ENOENT:\n\t\tres = htonl(NFS4ERR_BAD_STATEID);\n\t\tbreak;\n\tdefault:\n\t\tres = htonl(NFS4ERR_RESOURCE);\n\t}\n\ttrace_nfs4_recall_delegation(inode, -ntohl(res));\n\tiput(inode);\nout:\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, ntohl(res));\n\treturn res;\n}"
  },
  {
    "function_name": "nfs4_callback_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_proc.c",
    "lines": "24-67",
    "snippet": "__be32 nfs4_callback_getattr(struct cb_getattrargs *args,\n\t\t\t     struct cb_getattrres *res,\n\t\t\t     struct cb_process_state *cps)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct nfs_inode *nfsi;\n\tstruct inode *inode;\n\n\tres->status = htonl(NFS4ERR_OP_NOT_IN_SESSION);\n\tif (!cps->clp) /* Always set for v4.0. Set in cb_sequence for v4.1 */\n\t\tgoto out;\n\n\tres->bitmap[0] = res->bitmap[1] = 0;\n\tres->status = htonl(NFS4ERR_BADHANDLE);\n\n\tdprintk_rcu(\"NFS: GETATTR callback request from %s\\n\",\n\t\trpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\n\tinode = nfs_delegation_find_inode(cps->clp, &args->fh);\n\tif (inode == NULL)\n\t\tgoto out;\n\tnfsi = NFS_I(inode);\n\trcu_read_lock();\n\tdelegation = rcu_dereference(nfsi->delegation);\n\tif (delegation == NULL || (delegation->type & FMODE_WRITE) == 0)\n\t\tgoto out_iput;\n\tres->size = i_size_read(inode);\n\tres->change_attr = delegation->change_attr;\n\tif (nfsi->nrequests != 0)\n\t\tres->change_attr++;\n\tres->ctime = inode->i_ctime;\n\tres->mtime = inode->i_mtime;\n\tres->bitmap[0] = (FATTR4_WORD0_CHANGE|FATTR4_WORD0_SIZE) &\n\t\targs->bitmap[0];\n\tres->bitmap[1] = (FATTR4_WORD1_TIME_METADATA|FATTR4_WORD1_TIME_MODIFY) &\n\t\targs->bitmap[1];\n\tres->status = 0;\nout_iput:\n\trcu_read_unlock();\n\tiput(inode);\nout:\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, ntohl(res->status));\n\treturn res->status;\n}",
    "includes": [
      "#include \"nfs4trace.h\"",
      "#include \"nfs4session.h\"",
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: exit with status = %d\\n\"",
            "__func__",
            "ntohl(res->status)"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "res->status"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_iput_and_deactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "527-535",
          "snippet": "static inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);",
            "extern struct inode *nfs_alloc_inode(struct super_block *sb);",
            "extern void nfs_destroy_inode(struct inode *);",
            "extern int nfs_drop_inode(struct inode *);",
            "extern void nfs_clear_inode(struct inode *);",
            "extern void nfs_evict_inode(struct inode *);",
            "void nfs_zap_acl_cache(struct inode *inode);",
            "void nfs_initialise_sb(struct super_block *);",
            "void nfs_kill_super(struct super_block *);",
            "extern bool nfs_sb_active(struct super_block *sb);",
            "extern void nfs_sb_deactive(struct super_block *sb);",
            "void nfs_umount_begin(struct super_block *);",
            "int nfs_key_timeout_notify(struct file *filp, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nextern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);\nextern struct inode *nfs_alloc_inode(struct super_block *sb);\nextern void nfs_destroy_inode(struct inode *);\nextern int nfs_drop_inode(struct inode *);\nextern void nfs_clear_inode(struct inode *);\nextern void nfs_evict_inode(struct inode *);\nvoid nfs_zap_acl_cache(struct inode *inode);\nvoid nfs_initialise_sb(struct super_block *);\nvoid nfs_kill_super(struct super_block *);\nextern bool nfs_sb_active(struct super_block *sb);\nextern void nfs_sb_deactive(struct super_block *sb);\nvoid nfs_umount_begin(struct super_block *);\nint nfs_key_timeout_notify(struct file *filp, struct inode *inode);\n\nstatic inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "nfsi->delegation"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_delegation_find_inode",
          "args": [
            "cps->clp",
            "&args->fh"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_delegation_find_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/delegation.c",
          "lines": "769-783",
          "snippet": "struct inode *nfs_delegation_find_inode(struct nfs_client *clp,\n\t\t\t\t\tconst struct nfs_fh *fhandle)\n{\n\tstruct nfs_server *server;\n\tstruct inode *res = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tres = nfs_delegation_find_inode_server(server, fhandle);\n\t\tif (res != NULL)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn res;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n\nstruct inode *nfs_delegation_find_inode(struct nfs_client *clp,\n\t\t\t\t\tconst struct nfs_fh *fhandle)\n{\n\tstruct nfs_server *server;\n\tstruct inode *res = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\n\t\tres = nfs_delegation_find_inode_server(server, fhandle);\n\t\tif (res != NULL)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk_rcu",
          "args": [
            "\"NFS: GETATTR callback request from %s\\n\"",
            "rpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR)"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_peeraddr2str",
          "args": [
            "cps->clp->cl_rpcclient",
            "RPC_DISPLAY_ADDR"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_BADHANDLE"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_OP_NOT_IN_SESSION"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"nfs4session.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n\n__be32 nfs4_callback_getattr(struct cb_getattrargs *args,\n\t\t\t     struct cb_getattrres *res,\n\t\t\t     struct cb_process_state *cps)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct nfs_inode *nfsi;\n\tstruct inode *inode;\n\n\tres->status = htonl(NFS4ERR_OP_NOT_IN_SESSION);\n\tif (!cps->clp) /* Always set for v4.0. Set in cb_sequence for v4.1 */\n\t\tgoto out;\n\n\tres->bitmap[0] = res->bitmap[1] = 0;\n\tres->status = htonl(NFS4ERR_BADHANDLE);\n\n\tdprintk_rcu(\"NFS: GETATTR callback request from %s\\n\",\n\t\trpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR));\n\n\tinode = nfs_delegation_find_inode(cps->clp, &args->fh);\n\tif (inode == NULL)\n\t\tgoto out;\n\tnfsi = NFS_I(inode);\n\trcu_read_lock();\n\tdelegation = rcu_dereference(nfsi->delegation);\n\tif (delegation == NULL || (delegation->type & FMODE_WRITE) == 0)\n\t\tgoto out_iput;\n\tres->size = i_size_read(inode);\n\tres->change_attr = delegation->change_attr;\n\tif (nfsi->nrequests != 0)\n\t\tres->change_attr++;\n\tres->ctime = inode->i_ctime;\n\tres->mtime = inode->i_mtime;\n\tres->bitmap[0] = (FATTR4_WORD0_CHANGE|FATTR4_WORD0_SIZE) &\n\t\targs->bitmap[0];\n\tres->bitmap[1] = (FATTR4_WORD1_TIME_METADATA|FATTR4_WORD1_TIME_MODIFY) &\n\t\targs->bitmap[1];\n\tres->status = 0;\nout_iput:\n\trcu_read_unlock();\n\tiput(inode);\nout:\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, ntohl(res->status));\n\treturn res->status;\n}"
  }
]