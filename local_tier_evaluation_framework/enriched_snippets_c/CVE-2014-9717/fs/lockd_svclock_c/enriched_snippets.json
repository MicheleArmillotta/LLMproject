[
  {
    "function_name": "nlmsvc_retry_blocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "908-939",
    "snippet": "unsigned long\nnlmsvc_retry_blocked(void)\n{\n\tunsigned long\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\tstruct nlm_block *block;\n\n\tspin_lock(&nlm_blocked_lock);\n\twhile (!list_empty(&nlm_blocked) && !kthread_should_stop()) {\n\t\tblock = list_entry(nlm_blocked.next, struct nlm_block, b_list);\n\n\t\tif (block->b_when == NLM_NEVER)\n\t\t\tbreak;\n\t\tif (time_after(block->b_when, jiffies)) {\n\t\t\ttimeout = block->b_when - jiffies;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&nlm_blocked_lock);\n\n\t\tdprintk(\"nlmsvc_retry_blocked(%p, when=%ld)\\n\",\n\t\t\tblock, block->b_when);\n\t\tif (block->b_flags & B_QUEUED) {\n\t\t\tdprintk(\"nlmsvc_retry_blocked delete block (%p, granted=%d, flags=%d)\\n\",\n\t\t\t\tblock, block->b_granted, block->b_flags);\n\t\t\tretry_deferred_block(block);\n\t\t} else\n\t\t\tnlmsvc_grant_blocked(block);\n\t\tspin_lock(&nlm_blocked_lock);\n\t}\n\tspin_unlock(&nlm_blocked_lock);\n\n\treturn timeout;\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nlmsvc_release_block(struct nlm_block *block);",
      "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
      "static void\tnlmsvc_remove_block(struct nlm_block *block);",
      "static LIST_HEAD(nlm_blocked);",
      "static DEFINE_SPINLOCK(nlm_blocked_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nlm_blocked_lock"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nlm_blocked_lock"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_grant_blocked",
          "args": [
            "block"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_grant_blocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "728-798",
          "snippet": "static void\nnlmsvc_grant_blocked(struct nlm_block *block)\n{\n\tstruct nlm_file\t\t*file = block->b_file;\n\tstruct nlm_lock\t\t*lock = &block->b_call->a_args.lock;\n\tint\t\t\terror;\n\tloff_t\t\t\tfl_start, fl_end;\n\n\tdprintk(\"lockd: grant blocked lock %p\\n\", block);\n\n\tkref_get(&block->b_count);\n\n\t/* Unlink block request from list */\n\tnlmsvc_unlink_block(block);\n\n\t/* If b_granted is true this means we've been here before.\n\t * Just retry the grant callback, possibly refreshing the RPC\n\t * binding */\n\tif (block->b_granted) {\n\t\tnlm_rebind_host(block->b_host);\n\t\tgoto callback;\n\t}\n\n\t/* Try the lock operation again */\n\t/* vfs_lock_file() can mangle fl_start and fl_end, but we need\n\t * them unchanged for the GRANT_MSG\n\t */\n\tlock->fl.fl_flags |= FL_SLEEP;\n\tfl_start = lock->fl.fl_start;\n\tfl_end = lock->fl.fl_end;\n\terror = vfs_lock_file(file->f_file, F_SETLK, &lock->fl, NULL);\n\tlock->fl.fl_flags &= ~FL_SLEEP;\n\tlock->fl.fl_start = fl_start;\n\tlock->fl.fl_end = fl_end;\n\n\tswitch (error) {\n\tcase 0:\n\t\tbreak;\n\tcase FILE_LOCK_DEFERRED:\n\t\tdprintk(\"lockd: lock still blocked error %d\\n\", error);\n\t\tnlmsvc_insert_block(block, NLM_NEVER);\n\t\tnlmsvc_release_block(block);\n\t\treturn;\n\tdefault:\n\t\tprintk(KERN_WARNING \"lockd: unexpected error %d in %s!\\n\",\n\t\t\t\t-error, __func__);\n\t\tnlmsvc_insert_block(block, 10 * HZ);\n\t\tnlmsvc_release_block(block);\n\t\treturn;\n\t}\n\ncallback:\n\t/* Lock was granted by VFS. */\n\tdprintk(\"lockd: GRANTing blocked lock.\\n\");\n\tblock->b_granted = 1;\n\n\t/* keep block on the list, but don't reattempt until the RPC\n\t * completes or the submission fails\n\t */\n\tnlmsvc_insert_block(block, NLM_NEVER);\n\n\t/* Call the client -- use a soft RPC task since nlmsvc_retry_blocked\n\t * will queue up a new one if this one times out\n\t */\n\terror = nlm_async_call(block->b_call, NLMPROC_GRANTED_MSG,\n\t\t\t\t&nlmsvc_grant_ops);\n\n\t/* RPC submission failed, wait a bit and retry */\n\tif (error < 0)\n\t\tnlmsvc_insert_block(block, 10 * HZ);\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);",
            "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);",
            "static const struct rpc_call_ops nlmsvc_grant_ops;",
            "static const struct rpc_call_ops nlmsvc_grant_ops = {\n\t.rpc_call_done = nlmsvc_grant_callback,\n\t.rpc_release = nlmsvc_grant_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\nstatic const struct rpc_call_ops nlmsvc_grant_ops;\nstatic const struct rpc_call_ops nlmsvc_grant_ops = {\n\t.rpc_call_done = nlmsvc_grant_callback,\n\t.rpc_release = nlmsvc_grant_release,\n};\n\nstatic void\nnlmsvc_grant_blocked(struct nlm_block *block)\n{\n\tstruct nlm_file\t\t*file = block->b_file;\n\tstruct nlm_lock\t\t*lock = &block->b_call->a_args.lock;\n\tint\t\t\terror;\n\tloff_t\t\t\tfl_start, fl_end;\n\n\tdprintk(\"lockd: grant blocked lock %p\\n\", block);\n\n\tkref_get(&block->b_count);\n\n\t/* Unlink block request from list */\n\tnlmsvc_unlink_block(block);\n\n\t/* If b_granted is true this means we've been here before.\n\t * Just retry the grant callback, possibly refreshing the RPC\n\t * binding */\n\tif (block->b_granted) {\n\t\tnlm_rebind_host(block->b_host);\n\t\tgoto callback;\n\t}\n\n\t/* Try the lock operation again */\n\t/* vfs_lock_file() can mangle fl_start and fl_end, but we need\n\t * them unchanged for the GRANT_MSG\n\t */\n\tlock->fl.fl_flags |= FL_SLEEP;\n\tfl_start = lock->fl.fl_start;\n\tfl_end = lock->fl.fl_end;\n\terror = vfs_lock_file(file->f_file, F_SETLK, &lock->fl, NULL);\n\tlock->fl.fl_flags &= ~FL_SLEEP;\n\tlock->fl.fl_start = fl_start;\n\tlock->fl.fl_end = fl_end;\n\n\tswitch (error) {\n\tcase 0:\n\t\tbreak;\n\tcase FILE_LOCK_DEFERRED:\n\t\tdprintk(\"lockd: lock still blocked error %d\\n\", error);\n\t\tnlmsvc_insert_block(block, NLM_NEVER);\n\t\tnlmsvc_release_block(block);\n\t\treturn;\n\tdefault:\n\t\tprintk(KERN_WARNING \"lockd: unexpected error %d in %s!\\n\",\n\t\t\t\t-error, __func__);\n\t\tnlmsvc_insert_block(block, 10 * HZ);\n\t\tnlmsvc_release_block(block);\n\t\treturn;\n\t}\n\ncallback:\n\t/* Lock was granted by VFS. */\n\tdprintk(\"lockd: GRANTing blocked lock.\\n\");\n\tblock->b_granted = 1;\n\n\t/* keep block on the list, but don't reattempt until the RPC\n\t * completes or the submission fails\n\t */\n\tnlmsvc_insert_block(block, NLM_NEVER);\n\n\t/* Call the client -- use a soft RPC task since nlmsvc_retry_blocked\n\t * will queue up a new one if this one times out\n\t */\n\terror = nlm_async_call(block->b_call, NLMPROC_GRANTED_MSG,\n\t\t\t\t&nlmsvc_grant_ops);\n\n\t/* RPC submission failed, wait a bit and retry */\n\tif (error < 0)\n\t\tnlmsvc_insert_block(block, 10 * HZ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "retry_deferred_block",
          "args": [
            "block"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "retry_deferred_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "890-901",
          "snippet": "static void\nretry_deferred_block(struct nlm_block *block)\n{\n\tif (!(block->b_flags & B_GOT_CALLBACK))\n\t\tblock->b_flags |= B_TIMED_OUT;\n\tnlmsvc_insert_block(block, NLM_TIMEOUT);\n\tdprintk(\"revisit block %p flags %d\\n\",\tblock, block->b_flags);\n\tif (block->b_deferred_req) {\n\t\tblock->b_deferred_req->revisit(block->b_deferred_req, 0);\n\t\tblock->b_deferred_req = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\n\nstatic void\nretry_deferred_block(struct nlm_block *block)\n{\n\tif (!(block->b_flags & B_GOT_CALLBACK))\n\t\tblock->b_flags |= B_TIMED_OUT;\n\tnlmsvc_insert_block(block, NLM_TIMEOUT);\n\tdprintk(\"revisit block %p flags %d\\n\",\tblock, block->b_flags);\n\tif (block->b_deferred_req) {\n\t\tblock->b_deferred_req->revisit(block->b_deferred_req, 0);\n\t\tblock->b_deferred_req = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nlmsvc_retry_blocked delete block (%p, granted=%d, flags=%d)\\n\"",
            "block",
            "block->b_granted",
            "block->b_flags"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nlmsvc_retry_blocked(%p, when=%ld)\\n\"",
            "block",
            "block->b_when"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "block->b_when",
            "jiffies"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "nlm_blocked.next",
            "structnlm_block",
            "b_list"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&nlm_blocked"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic LIST_HEAD(nlm_blocked);\nstatic DEFINE_SPINLOCK(nlm_blocked_lock);\n\nunsigned long\nnlmsvc_retry_blocked(void)\n{\n\tunsigned long\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\tstruct nlm_block *block;\n\n\tspin_lock(&nlm_blocked_lock);\n\twhile (!list_empty(&nlm_blocked) && !kthread_should_stop()) {\n\t\tblock = list_entry(nlm_blocked.next, struct nlm_block, b_list);\n\n\t\tif (block->b_when == NLM_NEVER)\n\t\t\tbreak;\n\t\tif (time_after(block->b_when, jiffies)) {\n\t\t\ttimeout = block->b_when - jiffies;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&nlm_blocked_lock);\n\n\t\tdprintk(\"nlmsvc_retry_blocked(%p, when=%ld)\\n\",\n\t\t\tblock, block->b_when);\n\t\tif (block->b_flags & B_QUEUED) {\n\t\t\tdprintk(\"nlmsvc_retry_blocked delete block (%p, granted=%d, flags=%d)\\n\",\n\t\t\t\tblock, block->b_granted, block->b_flags);\n\t\t\tretry_deferred_block(block);\n\t\t} else\n\t\t\tnlmsvc_grant_blocked(block);\n\t\tspin_lock(&nlm_blocked_lock);\n\t}\n\tspin_unlock(&nlm_blocked_lock);\n\n\treturn timeout;\n}"
  },
  {
    "function_name": "retry_deferred_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "890-901",
    "snippet": "static void\nretry_deferred_block(struct nlm_block *block)\n{\n\tif (!(block->b_flags & B_GOT_CALLBACK))\n\t\tblock->b_flags |= B_TIMED_OUT;\n\tnlmsvc_insert_block(block, NLM_TIMEOUT);\n\tdprintk(\"revisit block %p flags %d\\n\",\tblock, block->b_flags);\n\tif (block->b_deferred_req) {\n\t\tblock->b_deferred_req->revisit(block->b_deferred_req, 0);\n\t\tblock->b_deferred_req = NULL;\n\t}\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nlmsvc_release_block(struct nlm_block *block);",
      "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
      "static void\tnlmsvc_remove_block(struct nlm_block *block);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "block->b_deferred_req->revisit",
          "args": [
            "block->b_deferred_req",
            "0"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"revisit block %p flags %d\\n\"",
            "block",
            "block->b_flags"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsvc_insert_block",
          "args": [
            "block",
            "NLM_TIMEOUT"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_insert_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "119-124",
          "snippet": "static void nlmsvc_insert_block(struct nlm_block *block, unsigned long when)\n{\n\tspin_lock(&nlm_blocked_lock);\n\tnlmsvc_insert_block_locked(block, when);\n\tspin_unlock(&nlm_blocked_lock);\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);",
            "static DEFINE_SPINLOCK(nlm_blocked_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic DEFINE_SPINLOCK(nlm_blocked_lock);\n\nstatic void nlmsvc_insert_block(struct nlm_block *block, unsigned long when)\n{\n\tspin_lock(&nlm_blocked_lock);\n\tnlmsvc_insert_block_locked(block, when);\n\tspin_unlock(&nlm_blocked_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\n\nstatic void\nretry_deferred_block(struct nlm_block *block)\n{\n\tif (!(block->b_flags & B_GOT_CALLBACK))\n\t\tblock->b_flags |= B_TIMED_OUT;\n\tnlmsvc_insert_block(block, NLM_TIMEOUT);\n\tdprintk(\"revisit block %p flags %d\\n\",\tblock, block->b_flags);\n\tif (block->b_deferred_req) {\n\t\tblock->b_deferred_req->revisit(block->b_deferred_req, 0);\n\t\tblock->b_deferred_req = NULL;\n\t}\n}"
  },
  {
    "function_name": "nlmsvc_grant_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "863-884",
    "snippet": "void\nnlmsvc_grant_reply(struct nlm_cookie *cookie, __be32 status)\n{\n\tstruct nlm_block\t*block;\n\n\tdprintk(\"grant_reply: looking for cookie %x, s=%d \\n\",\n\t\t*(unsigned int *)(cookie->data), status);\n\tif (!(block = nlmsvc_find_block(cookie)))\n\t\treturn;\n\n\tif (block) {\n\t\tif (status == nlm_lck_denied_grace_period) {\n\t\t\t/* Try again in a couple of seconds */\n\t\t\tnlmsvc_insert_block(block, 10 * HZ);\n\t\t} else {\n\t\t\t/* Lock is now held by client, or has been rejected.\n\t\t\t * In both cases, the block should be removed. */\n\t\t\tnlmsvc_unlink_block(block);\n\t\t}\n\t}\n\tnlmsvc_release_block(block);\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nlmsvc_release_block(struct nlm_block *block);",
      "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
      "static void\tnlmsvc_remove_block(struct nlm_block *block);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsvc_release_block",
          "args": [
            "block"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_release_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "300-304",
          "snippet": "static void nlmsvc_release_block(struct nlm_block *block)\n{\n\tif (block != NULL)\n\t\tkref_put_mutex(&block->b_count, nlmsvc_free_block, &block->b_file->f_mutex);\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\n\nstatic void nlmsvc_release_block(struct nlm_block *block)\n{\n\tif (block != NULL)\n\t\tkref_put_mutex(&block->b_count, nlmsvc_free_block, &block->b_file->f_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_unlink_block",
          "args": [
            "block"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_unlink_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "272-281",
          "snippet": "static int nlmsvc_unlink_block(struct nlm_block *block)\n{\n\tint status;\n\tdprintk(\"lockd: unlinking block %p...\\n\", block);\n\n\t/* Remove block from list */\n\tstatus = posix_unblock_lock(&block->b_call->a_args.lock.fl);\n\tnlmsvc_remove_block(block);\n\treturn status;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);",
            "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\n\nstatic int nlmsvc_unlink_block(struct nlm_block *block)\n{\n\tint status;\n\tdprintk(\"lockd: unlinking block %p...\\n\", block);\n\n\t/* Remove block from list */\n\tstatus = posix_unblock_lock(&block->b_call->a_args.lock.fl);\n\tnlmsvc_remove_block(block);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_insert_block",
          "args": [
            "block",
            "10 * HZ"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_insert_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "119-124",
          "snippet": "static void nlmsvc_insert_block(struct nlm_block *block, unsigned long when)\n{\n\tspin_lock(&nlm_blocked_lock);\n\tnlmsvc_insert_block_locked(block, when);\n\tspin_unlock(&nlm_blocked_lock);\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);",
            "static DEFINE_SPINLOCK(nlm_blocked_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic DEFINE_SPINLOCK(nlm_blocked_lock);\n\nstatic void nlmsvc_insert_block(struct nlm_block *block, unsigned long when)\n{\n\tspin_lock(&nlm_blocked_lock);\n\tnlmsvc_insert_block_locked(block, when);\n\tspin_unlock(&nlm_blocked_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_find_block",
          "args": [
            "cookie"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_find_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "181-197",
          "snippet": "static inline struct nlm_block *\nnlmsvc_find_block(struct nlm_cookie *cookie)\n{\n\tstruct nlm_block *block;\n\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tif (nlm_cookie_match(&block->b_call->a_args.cookie,cookie))\n\t\t\tgoto found;\n\t}\n\n\treturn NULL;\n\nfound:\n\tdprintk(\"nlmsvc_find_block(%s): block=%p\\n\", nlmdbg_cookie2a(cookie), block);\n\tkref_get(&block->b_count);\n\treturn block;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);",
            "static LIST_HEAD(nlm_blocked);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic LIST_HEAD(nlm_blocked);\n\nstatic inline struct nlm_block *\nnlmsvc_find_block(struct nlm_cookie *cookie)\n{\n\tstruct nlm_block *block;\n\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tif (nlm_cookie_match(&block->b_call->a_args.cookie,cookie))\n\t\t\tgoto found;\n\t}\n\n\treturn NULL;\n\nfound:\n\tdprintk(\"nlmsvc_find_block(%s): block=%p\\n\", nlmdbg_cookie2a(cookie), block);\n\tkref_get(&block->b_count);\n\treturn block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"grant_reply: looking for cookie %x, s=%d \\n\"",
            "*(unsigned int *)(cookie->data)",
            "status"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\n\nvoid\nnlmsvc_grant_reply(struct nlm_cookie *cookie, __be32 status)\n{\n\tstruct nlm_block\t*block;\n\n\tdprintk(\"grant_reply: looking for cookie %x, s=%d \\n\",\n\t\t*(unsigned int *)(cookie->data), status);\n\tif (!(block = nlmsvc_find_block(cookie)))\n\t\treturn;\n\n\tif (block) {\n\t\tif (status == nlm_lck_denied_grace_period) {\n\t\t\t/* Try again in a couple of seconds */\n\t\t\tnlmsvc_insert_block(block, 10 * HZ);\n\t\t} else {\n\t\t\t/* Lock is now held by client, or has been rejected.\n\t\t\t * In both cases, the block should be removed. */\n\t\t\tnlmsvc_unlink_block(block);\n\t\t}\n\t}\n\tnlmsvc_release_block(block);\n}"
  },
  {
    "function_name": "nlmsvc_grant_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "848-852",
    "snippet": "static void nlmsvc_grant_release(void *data)\n{\n\tstruct nlm_rqst\t\t*call = data;\n\tnlmsvc_release_block(call->a_block);\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nlmsvc_freegrantargs(struct nlm_rqst *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsvc_release_block",
          "args": [
            "call->a_block"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_release_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "300-304",
          "snippet": "static void nlmsvc_release_block(struct nlm_block *block)\n{\n\tif (block != NULL)\n\t\tkref_put_mutex(&block->b_count, nlmsvc_free_block, &block->b_file->f_mutex);\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\n\nstatic void nlmsvc_release_block(struct nlm_block *block)\n{\n\tif (block != NULL)\n\t\tkref_put_mutex(&block->b_count, nlmsvc_free_block, &block->b_file->f_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_freegrantargs(struct nlm_rqst *call);\n\nstatic void nlmsvc_grant_release(void *data)\n{\n\tstruct nlm_rqst\t\t*call = data;\n\tnlmsvc_release_block(call->a_block);\n}"
  },
  {
    "function_name": "nlmsvc_grant_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "808-842",
    "snippet": "static void nlmsvc_grant_callback(struct rpc_task *task, void *data)\n{\n\tstruct nlm_rqst\t\t*call = data;\n\tstruct nlm_block\t*block = call->a_block;\n\tunsigned long\t\ttimeout;\n\n\tdprintk(\"lockd: GRANT_MSG RPC callback\\n\");\n\n\tspin_lock(&nlm_blocked_lock);\n\t/* if the block is not on a list at this point then it has\n\t * been invalidated. Don't try to requeue it.\n\t *\n\t * FIXME: it's possible that the block is removed from the list\n\t * after this check but before the nlmsvc_insert_block. In that\n\t * case it will be added back. Perhaps we need better locking\n\t * for nlm_blocked?\n\t */\n\tif (list_empty(&block->b_list))\n\t\tgoto out;\n\n\t/* Technically, we should down the file semaphore here. Since we\n\t * move the block towards the head of the queue only, no harm\n\t * can be done, though. */\n\tif (task->tk_status < 0) {\n\t\t/* RPC error: Re-insert for retransmission */\n\t\ttimeout = 10 * HZ;\n\t} else {\n\t\t/* Call was successful, now wait for client callback */\n\t\ttimeout = 60 * HZ;\n\t}\n\tnlmsvc_insert_block_locked(block, timeout);\n\tsvc_wake_up(block->b_daemon);\nout:\n\tspin_unlock(&nlm_blocked_lock);\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nlmsvc_release_block(struct nlm_block *block);",
      "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
      "static void\tnlmsvc_remove_block(struct nlm_block *block);",
      "static void nlmsvc_freegrantargs(struct nlm_rqst *call);",
      "static LIST_HEAD(nlm_blocked);",
      "static DEFINE_SPINLOCK(nlm_blocked_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nlm_blocked_lock"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_wake_up",
          "args": [
            "block->b_daemon"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsvc_insert_block_locked",
          "args": [
            "block",
            "timeout"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_insert_block_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "88-117",
          "snippet": "static void\nnlmsvc_insert_block_locked(struct nlm_block *block, unsigned long when)\n{\n\tstruct nlm_block *b;\n\tstruct list_head *pos;\n\n\tdprintk(\"lockd: nlmsvc_insert_block(%p, %ld)\\n\", block, when);\n\tif (list_empty(&block->b_list)) {\n\t\tkref_get(&block->b_count);\n\t} else {\n\t\tlist_del_init(&block->b_list);\n\t}\n\n\tpos = &nlm_blocked;\n\tif (when != NLM_NEVER) {\n\t\tif ((when += jiffies) == NLM_NEVER)\n\t\t\twhen ++;\n\t\tlist_for_each(pos, &nlm_blocked) {\n\t\t\tb = list_entry(pos, struct nlm_block, b_list);\n\t\t\tif (time_after(b->b_when,when) || b->b_when == NLM_NEVER)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* On normal exit from the loop, pos == &nlm_blocked,\n\t\t * so we will be adding to the end of the list - good\n\t\t */\n\t}\n\n\tlist_add_tail(&block->b_list, pos);\n\tblock->b_when = when;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);",
            "static LIST_HEAD(nlm_blocked);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic LIST_HEAD(nlm_blocked);\n\nstatic void\nnlmsvc_insert_block_locked(struct nlm_block *block, unsigned long when)\n{\n\tstruct nlm_block *b;\n\tstruct list_head *pos;\n\n\tdprintk(\"lockd: nlmsvc_insert_block(%p, %ld)\\n\", block, when);\n\tif (list_empty(&block->b_list)) {\n\t\tkref_get(&block->b_count);\n\t} else {\n\t\tlist_del_init(&block->b_list);\n\t}\n\n\tpos = &nlm_blocked;\n\tif (when != NLM_NEVER) {\n\t\tif ((when += jiffies) == NLM_NEVER)\n\t\t\twhen ++;\n\t\tlist_for_each(pos, &nlm_blocked) {\n\t\t\tb = list_entry(pos, struct nlm_block, b_list);\n\t\t\tif (time_after(b->b_when,when) || b->b_when == NLM_NEVER)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* On normal exit from the loop, pos == &nlm_blocked,\n\t\t * so we will be adding to the end of the list - good\n\t\t */\n\t}\n\n\tlist_add_tail(&block->b_list, pos);\n\tblock->b_when = when;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&block->b_list"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nlm_blocked_lock"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: GRANT_MSG RPC callback\\n\""
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic void nlmsvc_freegrantargs(struct nlm_rqst *call);\nstatic LIST_HEAD(nlm_blocked);\nstatic DEFINE_SPINLOCK(nlm_blocked_lock);\n\nstatic void nlmsvc_grant_callback(struct rpc_task *task, void *data)\n{\n\tstruct nlm_rqst\t\t*call = data;\n\tstruct nlm_block\t*block = call->a_block;\n\tunsigned long\t\ttimeout;\n\n\tdprintk(\"lockd: GRANT_MSG RPC callback\\n\");\n\n\tspin_lock(&nlm_blocked_lock);\n\t/* if the block is not on a list at this point then it has\n\t * been invalidated. Don't try to requeue it.\n\t *\n\t * FIXME: it's possible that the block is removed from the list\n\t * after this check but before the nlmsvc_insert_block. In that\n\t * case it will be added back. Perhaps we need better locking\n\t * for nlm_blocked?\n\t */\n\tif (list_empty(&block->b_list))\n\t\tgoto out;\n\n\t/* Technically, we should down the file semaphore here. Since we\n\t * move the block towards the head of the queue only, no harm\n\t * can be done, though. */\n\tif (task->tk_status < 0) {\n\t\t/* RPC error: Re-insert for retransmission */\n\t\ttimeout = 10 * HZ;\n\t} else {\n\t\t/* Call was successful, now wait for client callback */\n\t\ttimeout = 60 * HZ;\n\t}\n\tnlmsvc_insert_block_locked(block, timeout);\n\tsvc_wake_up(block->b_daemon);\nout:\n\tspin_unlock(&nlm_blocked_lock);\n}"
  },
  {
    "function_name": "nlmsvc_grant_blocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "728-798",
    "snippet": "static void\nnlmsvc_grant_blocked(struct nlm_block *block)\n{\n\tstruct nlm_file\t\t*file = block->b_file;\n\tstruct nlm_lock\t\t*lock = &block->b_call->a_args.lock;\n\tint\t\t\terror;\n\tloff_t\t\t\tfl_start, fl_end;\n\n\tdprintk(\"lockd: grant blocked lock %p\\n\", block);\n\n\tkref_get(&block->b_count);\n\n\t/* Unlink block request from list */\n\tnlmsvc_unlink_block(block);\n\n\t/* If b_granted is true this means we've been here before.\n\t * Just retry the grant callback, possibly refreshing the RPC\n\t * binding */\n\tif (block->b_granted) {\n\t\tnlm_rebind_host(block->b_host);\n\t\tgoto callback;\n\t}\n\n\t/* Try the lock operation again */\n\t/* vfs_lock_file() can mangle fl_start and fl_end, but we need\n\t * them unchanged for the GRANT_MSG\n\t */\n\tlock->fl.fl_flags |= FL_SLEEP;\n\tfl_start = lock->fl.fl_start;\n\tfl_end = lock->fl.fl_end;\n\terror = vfs_lock_file(file->f_file, F_SETLK, &lock->fl, NULL);\n\tlock->fl.fl_flags &= ~FL_SLEEP;\n\tlock->fl.fl_start = fl_start;\n\tlock->fl.fl_end = fl_end;\n\n\tswitch (error) {\n\tcase 0:\n\t\tbreak;\n\tcase FILE_LOCK_DEFERRED:\n\t\tdprintk(\"lockd: lock still blocked error %d\\n\", error);\n\t\tnlmsvc_insert_block(block, NLM_NEVER);\n\t\tnlmsvc_release_block(block);\n\t\treturn;\n\tdefault:\n\t\tprintk(KERN_WARNING \"lockd: unexpected error %d in %s!\\n\",\n\t\t\t\t-error, __func__);\n\t\tnlmsvc_insert_block(block, 10 * HZ);\n\t\tnlmsvc_release_block(block);\n\t\treturn;\n\t}\n\ncallback:\n\t/* Lock was granted by VFS. */\n\tdprintk(\"lockd: GRANTing blocked lock.\\n\");\n\tblock->b_granted = 1;\n\n\t/* keep block on the list, but don't reattempt until the RPC\n\t * completes or the submission fails\n\t */\n\tnlmsvc_insert_block(block, NLM_NEVER);\n\n\t/* Call the client -- use a soft RPC task since nlmsvc_retry_blocked\n\t * will queue up a new one if this one times out\n\t */\n\terror = nlm_async_call(block->b_call, NLMPROC_GRANTED_MSG,\n\t\t\t\t&nlmsvc_grant_ops);\n\n\t/* RPC submission failed, wait a bit and retry */\n\tif (error < 0)\n\t\tnlmsvc_insert_block(block, 10 * HZ);\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nlmsvc_release_block(struct nlm_block *block);",
      "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
      "static void\tnlmsvc_remove_block(struct nlm_block *block);",
      "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);",
      "static const struct rpc_call_ops nlmsvc_grant_ops;",
      "static const struct rpc_call_ops nlmsvc_grant_ops = {\n\t.rpc_call_done = nlmsvc_grant_callback,\n\t.rpc_release = nlmsvc_grant_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsvc_insert_block",
          "args": [
            "block",
            "10 * HZ"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_insert_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "119-124",
          "snippet": "static void nlmsvc_insert_block(struct nlm_block *block, unsigned long when)\n{\n\tspin_lock(&nlm_blocked_lock);\n\tnlmsvc_insert_block_locked(block, when);\n\tspin_unlock(&nlm_blocked_lock);\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);",
            "static DEFINE_SPINLOCK(nlm_blocked_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic DEFINE_SPINLOCK(nlm_blocked_lock);\n\nstatic void nlmsvc_insert_block(struct nlm_block *block, unsigned long when)\n{\n\tspin_lock(&nlm_blocked_lock);\n\tnlmsvc_insert_block_locked(block, when);\n\tspin_unlock(&nlm_blocked_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlm_async_call",
          "args": [
            "block->b_call",
            "NLMPROC_GRANTED_MSG",
            "&nlmsvc_grant_ops"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_async_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "369-376",
          "snippet": "int nlm_async_call(struct nlm_rqst *req, u32 proc, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &req->a_args,\n\t\t.rpc_resp\t= &req->a_res,\n\t};\n\treturn nlm_do_async_call(req, proc, &msg, tk_ops);\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint nlm_async_call(struct nlm_rqst *req, u32 proc, const struct rpc_call_ops *tk_ops)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &req->a_args,\n\t\t.rpc_resp\t= &req->a_res,\n\t};\n\treturn nlm_do_async_call(req, proc, &msg, tk_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: GRANTing blocked lock.\\n\""
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsvc_release_block",
          "args": [
            "block"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_release_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "300-304",
          "snippet": "static void nlmsvc_release_block(struct nlm_block *block)\n{\n\tif (block != NULL)\n\t\tkref_put_mutex(&block->b_count, nlmsvc_free_block, &block->b_file->f_mutex);\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\n\nstatic void nlmsvc_release_block(struct nlm_block *block)\n{\n\tif (block != NULL)\n\t\tkref_put_mutex(&block->b_count, nlmsvc_free_block, &block->b_file->f_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"lockd: unexpected error %d in %s!\\n\"",
            "-error",
            "__func__"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: lock still blocked error %d\\n\"",
            "error"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_lock_file",
          "args": [
            "file->f_file",
            "F_SETLK",
            "&lock->fl",
            "NULL"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_lock_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "2077-2083",
          "snippet": "int vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, cmd, fl);\n\telse\n\t\treturn posix_lock_file(filp, fl, conf);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, cmd, fl);\n\telse\n\t\treturn posix_lock_file(filp, fl, conf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlm_rebind_host",
          "args": [
            "block->b_host"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_rebind_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/host.c",
          "lines": "488-496",
          "snippet": "void\nnlm_rebind_host(struct nlm_host *host)\n{\n\tdprintk(\"lockd: rebind host %s\\n\", host->h_name);\n\tif (host->h_rpcclnt && time_after_eq(jiffies, host->h_nextrebind)) {\n\t\trpc_force_rebind(host->h_rpcclnt);\n\t\thost->h_nextrebind = jiffies + NLM_HOST_REBIND;\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NLM_HOST_REBIND\t\t(60 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include <net/ipv6.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/mutex.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NLM_HOST_REBIND\t\t(60 * HZ)\n\nvoid\nnlm_rebind_host(struct nlm_host *host)\n{\n\tdprintk(\"lockd: rebind host %s\\n\", host->h_name);\n\tif (host->h_rpcclnt && time_after_eq(jiffies, host->h_nextrebind)) {\n\t\trpc_force_rebind(host->h_rpcclnt);\n\t\thost->h_nextrebind = jiffies + NLM_HOST_REBIND;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_unlink_block",
          "args": [
            "block"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_unlink_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "272-281",
          "snippet": "static int nlmsvc_unlink_block(struct nlm_block *block)\n{\n\tint status;\n\tdprintk(\"lockd: unlinking block %p...\\n\", block);\n\n\t/* Remove block from list */\n\tstatus = posix_unblock_lock(&block->b_call->a_args.lock.fl);\n\tnlmsvc_remove_block(block);\n\treturn status;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);",
            "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\n\nstatic int nlmsvc_unlink_block(struct nlm_block *block)\n{\n\tint status;\n\tdprintk(\"lockd: unlinking block %p...\\n\", block);\n\n\t/* Remove block from list */\n\tstatus = posix_unblock_lock(&block->b_call->a_args.lock.fl);\n\tnlmsvc_remove_block(block);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&block->b_count"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: grant blocked lock %p\\n\"",
            "block"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\nstatic const struct rpc_call_ops nlmsvc_grant_ops;\nstatic const struct rpc_call_ops nlmsvc_grant_ops = {\n\t.rpc_call_done = nlmsvc_grant_callback,\n\t.rpc_release = nlmsvc_grant_release,\n};\n\nstatic void\nnlmsvc_grant_blocked(struct nlm_block *block)\n{\n\tstruct nlm_file\t\t*file = block->b_file;\n\tstruct nlm_lock\t\t*lock = &block->b_call->a_args.lock;\n\tint\t\t\terror;\n\tloff_t\t\t\tfl_start, fl_end;\n\n\tdprintk(\"lockd: grant blocked lock %p\\n\", block);\n\n\tkref_get(&block->b_count);\n\n\t/* Unlink block request from list */\n\tnlmsvc_unlink_block(block);\n\n\t/* If b_granted is true this means we've been here before.\n\t * Just retry the grant callback, possibly refreshing the RPC\n\t * binding */\n\tif (block->b_granted) {\n\t\tnlm_rebind_host(block->b_host);\n\t\tgoto callback;\n\t}\n\n\t/* Try the lock operation again */\n\t/* vfs_lock_file() can mangle fl_start and fl_end, but we need\n\t * them unchanged for the GRANT_MSG\n\t */\n\tlock->fl.fl_flags |= FL_SLEEP;\n\tfl_start = lock->fl.fl_start;\n\tfl_end = lock->fl.fl_end;\n\terror = vfs_lock_file(file->f_file, F_SETLK, &lock->fl, NULL);\n\tlock->fl.fl_flags &= ~FL_SLEEP;\n\tlock->fl.fl_start = fl_start;\n\tlock->fl.fl_end = fl_end;\n\n\tswitch (error) {\n\tcase 0:\n\t\tbreak;\n\tcase FILE_LOCK_DEFERRED:\n\t\tdprintk(\"lockd: lock still blocked error %d\\n\", error);\n\t\tnlmsvc_insert_block(block, NLM_NEVER);\n\t\tnlmsvc_release_block(block);\n\t\treturn;\n\tdefault:\n\t\tprintk(KERN_WARNING \"lockd: unexpected error %d in %s!\\n\",\n\t\t\t\t-error, __func__);\n\t\tnlmsvc_insert_block(block, 10 * HZ);\n\t\tnlmsvc_release_block(block);\n\t\treturn;\n\t}\n\ncallback:\n\t/* Lock was granted by VFS. */\n\tdprintk(\"lockd: GRANTing blocked lock.\\n\");\n\tblock->b_granted = 1;\n\n\t/* keep block on the list, but don't reattempt until the RPC\n\t * completes or the submission fails\n\t */\n\tnlmsvc_insert_block(block, NLM_NEVER);\n\n\t/* Call the client -- use a soft RPC task since nlmsvc_retry_blocked\n\t * will queue up a new one if this one times out\n\t */\n\terror = nlm_async_call(block->b_call, NLMPROC_GRANTED_MSG,\n\t\t\t\t&nlmsvc_grant_ops);\n\n\t/* RPC submission failed, wait a bit and retry */\n\tif (error < 0)\n\t\tnlmsvc_insert_block(block, 10 * HZ);\n}"
  },
  {
    "function_name": "nlmsvc_owner_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "704-708",
    "snippet": "static unsigned long\nnlmsvc_owner_key(struct file_lock *fl)\n{\n\treturn (unsigned long)fl->fl_owner ^ (unsigned long)fl->fl_pid;\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic unsigned long\nnlmsvc_owner_key(struct file_lock *fl)\n{\n\treturn (unsigned long)fl->fl_owner ^ (unsigned long)fl->fl_pid;\n}"
  },
  {
    "function_name": "nlmsvc_same_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "694-697",
    "snippet": "static int nlmsvc_same_owner(struct file_lock *fl1, struct file_lock *fl2)\n{\n\treturn fl1->fl_owner == fl2->fl_owner && fl1->fl_pid == fl2->fl_pid;\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int nlmsvc_same_owner(struct file_lock *fl1, struct file_lock *fl2)\n{\n\treturn fl1->fl_owner == fl2->fl_owner && fl1->fl_pid == fl2->fl_pid;\n}"
  },
  {
    "function_name": "nlmsvc_notify_blocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "675-692",
    "snippet": "static void\nnlmsvc_notify_blocked(struct file_lock *fl)\n{\n\tstruct nlm_block\t*block;\n\n\tdprintk(\"lockd: VFS unblock notification for block %p\\n\", fl);\n\tspin_lock(&nlm_blocked_lock);\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tif (nlm_compare_locks(&block->b_call->a_args.lock.fl, fl)) {\n\t\t\tnlmsvc_insert_block_locked(block, 0);\n\t\t\tspin_unlock(&nlm_blocked_lock);\n\t\t\tsvc_wake_up(block->b_daemon);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&nlm_blocked_lock);\n\tprintk(KERN_WARNING \"lockd: notification for unknown block!\\n\");\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nlmsvc_release_block(struct nlm_block *block);",
      "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
      "static void\tnlmsvc_remove_block(struct nlm_block *block);",
      "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);",
      "static LIST_HEAD(nlm_blocked);",
      "static DEFINE_SPINLOCK(nlm_blocked_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"lockd: notification for unknown block!\\n\""
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nlm_blocked_lock"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_wake_up",
          "args": [
            "block->b_daemon"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsvc_insert_block_locked",
          "args": [
            "block",
            "0"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_insert_block_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "88-117",
          "snippet": "static void\nnlmsvc_insert_block_locked(struct nlm_block *block, unsigned long when)\n{\n\tstruct nlm_block *b;\n\tstruct list_head *pos;\n\n\tdprintk(\"lockd: nlmsvc_insert_block(%p, %ld)\\n\", block, when);\n\tif (list_empty(&block->b_list)) {\n\t\tkref_get(&block->b_count);\n\t} else {\n\t\tlist_del_init(&block->b_list);\n\t}\n\n\tpos = &nlm_blocked;\n\tif (when != NLM_NEVER) {\n\t\tif ((when += jiffies) == NLM_NEVER)\n\t\t\twhen ++;\n\t\tlist_for_each(pos, &nlm_blocked) {\n\t\t\tb = list_entry(pos, struct nlm_block, b_list);\n\t\t\tif (time_after(b->b_when,when) || b->b_when == NLM_NEVER)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* On normal exit from the loop, pos == &nlm_blocked,\n\t\t * so we will be adding to the end of the list - good\n\t\t */\n\t}\n\n\tlist_add_tail(&block->b_list, pos);\n\tblock->b_when = when;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);",
            "static LIST_HEAD(nlm_blocked);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic LIST_HEAD(nlm_blocked);\n\nstatic void\nnlmsvc_insert_block_locked(struct nlm_block *block, unsigned long when)\n{\n\tstruct nlm_block *b;\n\tstruct list_head *pos;\n\n\tdprintk(\"lockd: nlmsvc_insert_block(%p, %ld)\\n\", block, when);\n\tif (list_empty(&block->b_list)) {\n\t\tkref_get(&block->b_count);\n\t} else {\n\t\tlist_del_init(&block->b_list);\n\t}\n\n\tpos = &nlm_blocked;\n\tif (when != NLM_NEVER) {\n\t\tif ((when += jiffies) == NLM_NEVER)\n\t\t\twhen ++;\n\t\tlist_for_each(pos, &nlm_blocked) {\n\t\t\tb = list_entry(pos, struct nlm_block, b_list);\n\t\t\tif (time_after(b->b_when,when) || b->b_when == NLM_NEVER)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* On normal exit from the loop, pos == &nlm_blocked,\n\t\t * so we will be adding to the end of the list - good\n\t\t */\n\t}\n\n\tlist_add_tail(&block->b_list, pos);\n\tblock->b_when = when;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlm_compare_locks",
          "args": [
            "&block->b_call->a_args.lock.fl",
            "fl"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "block",
            "&nlm_blocked",
            "b_list"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nlm_blocked_lock"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: VFS unblock notification for block %p\\n\"",
            "fl"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\nstatic LIST_HEAD(nlm_blocked);\nstatic DEFINE_SPINLOCK(nlm_blocked_lock);\n\nstatic void\nnlmsvc_notify_blocked(struct file_lock *fl)\n{\n\tstruct nlm_block\t*block;\n\n\tdprintk(\"lockd: VFS unblock notification for block %p\\n\", fl);\n\tspin_lock(&nlm_blocked_lock);\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tif (nlm_compare_locks(&block->b_call->a_args.lock.fl, fl)) {\n\t\t\tnlmsvc_insert_block_locked(block, 0);\n\t\t\tspin_unlock(&nlm_blocked_lock);\n\t\t\tsvc_wake_up(block->b_daemon);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&nlm_blocked_lock);\n\tprintk(KERN_WARNING \"lockd: notification for unknown block!\\n\");\n}"
  },
  {
    "function_name": "nlmsvc_grant_deferred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "637-666",
    "snippet": "static int nlmsvc_grant_deferred(struct file_lock *fl, int result)\n{\n\tstruct nlm_block *block;\n\tint rc = -ENOENT;\n\n\tspin_lock(&nlm_blocked_lock);\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tif (nlm_compare_locks(&block->b_call->a_args.lock.fl, fl)) {\n\t\t\tdprintk(\"lockd: nlmsvc_notify_blocked block %p flags %d\\n\",\n\t\t\t\t\t\t\tblock, block->b_flags);\n\t\t\tif (block->b_flags & B_QUEUED) {\n\t\t\t\tif (block->b_flags & B_TIMED_OUT) {\n\t\t\t\t\trc = -ENOLCK;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnlmsvc_update_deferred_block(block, result);\n\t\t\t} else if (result == 0)\n\t\t\t\tblock->b_granted = 1;\n\n\t\t\tnlmsvc_insert_block_locked(block, 0);\n\t\t\tsvc_wake_up(block->b_daemon);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&nlm_blocked_lock);\n\tif (rc == -ENOENT)\n\t\tprintk(KERN_WARNING \"lockd: grant for unknown block\\n\");\n\treturn rc;\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nlmsvc_release_block(struct nlm_block *block);",
      "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
      "static void\tnlmsvc_remove_block(struct nlm_block *block);",
      "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);",
      "static LIST_HEAD(nlm_blocked);",
      "static DEFINE_SPINLOCK(nlm_blocked_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"lockd: grant for unknown block\\n\""
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nlm_blocked_lock"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_wake_up",
          "args": [
            "block->b_daemon"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsvc_insert_block_locked",
          "args": [
            "block",
            "0"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_insert_block_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "88-117",
          "snippet": "static void\nnlmsvc_insert_block_locked(struct nlm_block *block, unsigned long when)\n{\n\tstruct nlm_block *b;\n\tstruct list_head *pos;\n\n\tdprintk(\"lockd: nlmsvc_insert_block(%p, %ld)\\n\", block, when);\n\tif (list_empty(&block->b_list)) {\n\t\tkref_get(&block->b_count);\n\t} else {\n\t\tlist_del_init(&block->b_list);\n\t}\n\n\tpos = &nlm_blocked;\n\tif (when != NLM_NEVER) {\n\t\tif ((when += jiffies) == NLM_NEVER)\n\t\t\twhen ++;\n\t\tlist_for_each(pos, &nlm_blocked) {\n\t\t\tb = list_entry(pos, struct nlm_block, b_list);\n\t\t\tif (time_after(b->b_when,when) || b->b_when == NLM_NEVER)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* On normal exit from the loop, pos == &nlm_blocked,\n\t\t * so we will be adding to the end of the list - good\n\t\t */\n\t}\n\n\tlist_add_tail(&block->b_list, pos);\n\tblock->b_when = when;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);",
            "static LIST_HEAD(nlm_blocked);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic LIST_HEAD(nlm_blocked);\n\nstatic void\nnlmsvc_insert_block_locked(struct nlm_block *block, unsigned long when)\n{\n\tstruct nlm_block *b;\n\tstruct list_head *pos;\n\n\tdprintk(\"lockd: nlmsvc_insert_block(%p, %ld)\\n\", block, when);\n\tif (list_empty(&block->b_list)) {\n\t\tkref_get(&block->b_count);\n\t} else {\n\t\tlist_del_init(&block->b_list);\n\t}\n\n\tpos = &nlm_blocked;\n\tif (when != NLM_NEVER) {\n\t\tif ((when += jiffies) == NLM_NEVER)\n\t\t\twhen ++;\n\t\tlist_for_each(pos, &nlm_blocked) {\n\t\t\tb = list_entry(pos, struct nlm_block, b_list);\n\t\t\tif (time_after(b->b_when,when) || b->b_when == NLM_NEVER)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* On normal exit from the loop, pos == &nlm_blocked,\n\t\t * so we will be adding to the end of the list - good\n\t\t */\n\t}\n\n\tlist_add_tail(&block->b_list, pos);\n\tblock->b_when = when;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_update_deferred_block",
          "args": [
            "block",
            "result"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_update_deferred_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "627-635",
          "snippet": "static void\nnlmsvc_update_deferred_block(struct nlm_block *block, int result)\n{\n\tblock->b_flags |= B_GOT_CALLBACK;\n\tif (result == 0)\n\t\tblock->b_granted = 1;\n\telse\n\t\tblock->b_flags |= B_TIMED_OUT;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\n\nstatic void\nnlmsvc_update_deferred_block(struct nlm_block *block, int result)\n{\n\tblock->b_flags |= B_GOT_CALLBACK;\n\tif (result == 0)\n\t\tblock->b_granted = 1;\n\telse\n\t\tblock->b_flags |= B_TIMED_OUT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: nlmsvc_notify_blocked block %p flags %d\\n\"",
            "block",
            "block->b_flags"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_compare_locks",
          "args": [
            "&block->b_call->a_args.lock.fl",
            "fl"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "block",
            "&nlm_blocked",
            "b_list"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nlm_blocked_lock"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\nstatic LIST_HEAD(nlm_blocked);\nstatic DEFINE_SPINLOCK(nlm_blocked_lock);\n\nstatic int nlmsvc_grant_deferred(struct file_lock *fl, int result)\n{\n\tstruct nlm_block *block;\n\tint rc = -ENOENT;\n\n\tspin_lock(&nlm_blocked_lock);\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tif (nlm_compare_locks(&block->b_call->a_args.lock.fl, fl)) {\n\t\t\tdprintk(\"lockd: nlmsvc_notify_blocked block %p flags %d\\n\",\n\t\t\t\t\t\t\tblock, block->b_flags);\n\t\t\tif (block->b_flags & B_QUEUED) {\n\t\t\t\tif (block->b_flags & B_TIMED_OUT) {\n\t\t\t\t\trc = -ENOLCK;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnlmsvc_update_deferred_block(block, result);\n\t\t\t} else if (result == 0)\n\t\t\t\tblock->b_granted = 1;\n\n\t\t\tnlmsvc_insert_block_locked(block, 0);\n\t\t\tsvc_wake_up(block->b_daemon);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&nlm_blocked_lock);\n\tif (rc == -ENOENT)\n\t\tprintk(KERN_WARNING \"lockd: grant for unknown block\\n\");\n\treturn rc;\n}"
  },
  {
    "function_name": "nlmsvc_update_deferred_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "627-635",
    "snippet": "static void\nnlmsvc_update_deferred_block(struct nlm_block *block, int result)\n{\n\tblock->b_flags |= B_GOT_CALLBACK;\n\tif (result == 0)\n\t\tblock->b_granted = 1;\n\telse\n\t\tblock->b_flags |= B_TIMED_OUT;\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nlmsvc_release_block(struct nlm_block *block);",
      "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
      "static void\tnlmsvc_remove_block(struct nlm_block *block);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\n\nstatic void\nnlmsvc_update_deferred_block(struct nlm_block *block, int result)\n{\n\tblock->b_flags |= B_GOT_CALLBACK;\n\tif (result == 0)\n\t\tblock->b_granted = 1;\n\telse\n\t\tblock->b_flags |= B_TIMED_OUT;\n}"
  },
  {
    "function_name": "nlmsvc_cancel_blocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "590-616",
    "snippet": "__be32\nnlmsvc_cancel_blocked(struct net *net, struct nlm_file *file, struct nlm_lock *lock)\n{\n\tstruct nlm_block\t*block;\n\tint status = 0;\n\n\tdprintk(\"lockd: nlmsvc_cancel(%s/%ld, pi=%d, %Ld-%Ld)\\n\",\n\t\t\t\tfile_inode(file->f_file)->i_sb->s_id,\n\t\t\t\tfile_inode(file->f_file)->i_ino,\n\t\t\t\tlock->fl.fl_pid,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end);\n\n\tif (locks_in_grace(net))\n\t\treturn nlm_lck_denied_grace_period;\n\n\tmutex_lock(&file->f_mutex);\n\tblock = nlmsvc_lookup_block(file, lock);\n\tmutex_unlock(&file->f_mutex);\n\tif (block != NULL) {\n\t\tvfs_cancel_lock(block->b_file->f_file,\n\t\t\t\t&block->b_call->a_args.lock.fl);\n\t\tstatus = nlmsvc_unlink_block(block);\n\t\tnlmsvc_release_block(block);\n\t}\n\treturn status ? nlm_lck_denied : nlm_granted;\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nlmsvc_release_block(struct nlm_block *block);",
      "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
      "static void\tnlmsvc_remove_block(struct nlm_block *block);",
      "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsvc_release_block",
          "args": [
            "block"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_release_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "300-304",
          "snippet": "static void nlmsvc_release_block(struct nlm_block *block)\n{\n\tif (block != NULL)\n\t\tkref_put_mutex(&block->b_count, nlmsvc_free_block, &block->b_file->f_mutex);\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\n\nstatic void nlmsvc_release_block(struct nlm_block *block)\n{\n\tif (block != NULL)\n\t\tkref_put_mutex(&block->b_count, nlmsvc_free_block, &block->b_file->f_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_unlink_block",
          "args": [
            "block"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_unlink_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "272-281",
          "snippet": "static int nlmsvc_unlink_block(struct nlm_block *block)\n{\n\tint status;\n\tdprintk(\"lockd: unlinking block %p...\\n\", block);\n\n\t/* Remove block from list */\n\tstatus = posix_unblock_lock(&block->b_call->a_args.lock.fl);\n\tnlmsvc_remove_block(block);\n\treturn status;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);",
            "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\n\nstatic int nlmsvc_unlink_block(struct nlm_block *block)\n{\n\tint status;\n\tdprintk(\"lockd: unlinking block %p...\\n\", block);\n\n\t/* Remove block from list */\n\tstatus = posix_unblock_lock(&block->b_call->a_args.lock.fl);\n\tnlmsvc_remove_block(block);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_cancel_lock",
          "args": [
            "block->b_file->f_file",
            "&block->b_call->a_args.lock.fl"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_cancel_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "2482-2487",
          "snippet": "int vfs_cancel_lock(struct file *filp, struct file_lock *fl)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, F_CANCELLK, fl);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint vfs_cancel_lock(struct file *filp, struct file_lock *fl)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, F_CANCELLK, fl);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&file->f_mutex"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsvc_lookup_block",
          "args": [
            "file",
            "lock"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_lookup_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "143-167",
          "snippet": "static struct nlm_block *\nnlmsvc_lookup_block(struct nlm_file *file, struct nlm_lock *lock)\n{\n\tstruct nlm_block\t*block;\n\tstruct file_lock\t*fl;\n\n\tdprintk(\"lockd: nlmsvc_lookup_block f=%p pd=%d %Ld-%Ld ty=%d\\n\",\n\t\t\t\tfile, lock->fl.fl_pid,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end, lock->fl.fl_type);\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tfl = &block->b_call->a_args.lock.fl;\n\t\tdprintk(\"lockd: check f=%p pd=%d %Ld-%Ld ty=%d cookie=%s\\n\",\n\t\t\t\tblock->b_file, fl->fl_pid,\n\t\t\t\t(long long)fl->fl_start,\n\t\t\t\t(long long)fl->fl_end, fl->fl_type,\n\t\t\t\tnlmdbg_cookie2a(&block->b_call->a_args.cookie));\n\t\tif (block->b_file == file && nlm_compare_locks(fl, &lock->fl)) {\n\t\t\tkref_get(&block->b_count);\n\t\t\treturn block;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);",
            "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);",
            "static LIST_HEAD(nlm_blocked);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\nstatic LIST_HEAD(nlm_blocked);\n\nstatic struct nlm_block *\nnlmsvc_lookup_block(struct nlm_file *file, struct nlm_lock *lock)\n{\n\tstruct nlm_block\t*block;\n\tstruct file_lock\t*fl;\n\n\tdprintk(\"lockd: nlmsvc_lookup_block f=%p pd=%d %Ld-%Ld ty=%d\\n\",\n\t\t\t\tfile, lock->fl.fl_pid,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end, lock->fl.fl_type);\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tfl = &block->b_call->a_args.lock.fl;\n\t\tdprintk(\"lockd: check f=%p pd=%d %Ld-%Ld ty=%d cookie=%s\\n\",\n\t\t\t\tblock->b_file, fl->fl_pid,\n\t\t\t\t(long long)fl->fl_start,\n\t\t\t\t(long long)fl->fl_end, fl->fl_type,\n\t\t\t\tnlmdbg_cookie2a(&block->b_call->a_args.cookie));\n\t\tif (block->b_file == file && nlm_compare_locks(fl, &lock->fl)) {\n\t\t\tkref_get(&block->b_count);\n\t\t\treturn block;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&file->f_mutex"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_in_grace",
          "args": [
            "net"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "locks_in_grace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/grace.c",
          "lines": "65-71",
          "snippet": "int\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <net/netns/generic.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int grace_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <net/netns/generic.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n\nstatic int grace_net_id;\n\nint\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: nlmsvc_cancel(%s/%ld, pi=%d, %Ld-%Ld)\\n\"",
            "file_inode(file->f_file)->i_sb->s_id",
            "file_inode(file->f_file)->i_ino",
            "lock->fl.fl_pid",
            "(long long)lock->fl.fl_start",
            "(long long)lock->fl.fl_end"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file->f_file"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\n\n__be32\nnlmsvc_cancel_blocked(struct net *net, struct nlm_file *file, struct nlm_lock *lock)\n{\n\tstruct nlm_block\t*block;\n\tint status = 0;\n\n\tdprintk(\"lockd: nlmsvc_cancel(%s/%ld, pi=%d, %Ld-%Ld)\\n\",\n\t\t\t\tfile_inode(file->f_file)->i_sb->s_id,\n\t\t\t\tfile_inode(file->f_file)->i_ino,\n\t\t\t\tlock->fl.fl_pid,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end);\n\n\tif (locks_in_grace(net))\n\t\treturn nlm_lck_denied_grace_period;\n\n\tmutex_lock(&file->f_mutex);\n\tblock = nlmsvc_lookup_block(file, lock);\n\tmutex_unlock(&file->f_mutex);\n\tif (block != NULL) {\n\t\tvfs_cancel_lock(block->b_file->f_file,\n\t\t\t\t&block->b_call->a_args.lock.fl);\n\t\tstatus = nlmsvc_unlink_block(block);\n\t\tnlmsvc_release_block(block);\n\t}\n\treturn status ? nlm_lck_denied : nlm_granted;\n}"
  },
  {
    "function_name": "nlmsvc_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "562-581",
    "snippet": "__be32\nnlmsvc_unlock(struct net *net, struct nlm_file *file, struct nlm_lock *lock)\n{\n\tint\terror;\n\n\tdprintk(\"lockd: nlmsvc_unlock(%s/%ld, pi=%d, %Ld-%Ld)\\n\",\n\t\t\t\tfile_inode(file->f_file)->i_sb->s_id,\n\t\t\t\tfile_inode(file->f_file)->i_ino,\n\t\t\t\tlock->fl.fl_pid,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end);\n\n\t/* First, cancel any lock that might be there */\n\tnlmsvc_cancel_blocked(net, file, lock);\n\n\tlock->fl.fl_type = F_UNLCK;\n\terror = vfs_lock_file(file->f_file, F_SETLK, &lock->fl, NULL);\n\n\treturn (error < 0)? nlm_lck_denied_nolocks : nlm_granted;\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfs_lock_file",
          "args": [
            "file->f_file",
            "F_SETLK",
            "&lock->fl",
            "NULL"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_lock_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "2077-2083",
          "snippet": "int vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, cmd, fl);\n\telse\n\t\treturn posix_lock_file(filp, fl, conf);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, cmd, fl);\n\telse\n\t\treturn posix_lock_file(filp, fl, conf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_cancel_blocked",
          "args": [
            "net",
            "file",
            "lock"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_cancel_blocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "590-616",
          "snippet": "__be32\nnlmsvc_cancel_blocked(struct net *net, struct nlm_file *file, struct nlm_lock *lock)\n{\n\tstruct nlm_block\t*block;\n\tint status = 0;\n\n\tdprintk(\"lockd: nlmsvc_cancel(%s/%ld, pi=%d, %Ld-%Ld)\\n\",\n\t\t\t\tfile_inode(file->f_file)->i_sb->s_id,\n\t\t\t\tfile_inode(file->f_file)->i_ino,\n\t\t\t\tlock->fl.fl_pid,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end);\n\n\tif (locks_in_grace(net))\n\t\treturn nlm_lck_denied_grace_period;\n\n\tmutex_lock(&file->f_mutex);\n\tblock = nlmsvc_lookup_block(file, lock);\n\tmutex_unlock(&file->f_mutex);\n\tif (block != NULL) {\n\t\tvfs_cancel_lock(block->b_file->f_file,\n\t\t\t\t&block->b_call->a_args.lock.fl);\n\t\tstatus = nlmsvc_unlink_block(block);\n\t\tnlmsvc_release_block(block);\n\t}\n\treturn status ? nlm_lck_denied : nlm_granted;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);",
            "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\n\n__be32\nnlmsvc_cancel_blocked(struct net *net, struct nlm_file *file, struct nlm_lock *lock)\n{\n\tstruct nlm_block\t*block;\n\tint status = 0;\n\n\tdprintk(\"lockd: nlmsvc_cancel(%s/%ld, pi=%d, %Ld-%Ld)\\n\",\n\t\t\t\tfile_inode(file->f_file)->i_sb->s_id,\n\t\t\t\tfile_inode(file->f_file)->i_ino,\n\t\t\t\tlock->fl.fl_pid,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end);\n\n\tif (locks_in_grace(net))\n\t\treturn nlm_lck_denied_grace_period;\n\n\tmutex_lock(&file->f_mutex);\n\tblock = nlmsvc_lookup_block(file, lock);\n\tmutex_unlock(&file->f_mutex);\n\tif (block != NULL) {\n\t\tvfs_cancel_lock(block->b_file->f_file,\n\t\t\t\t&block->b_call->a_args.lock.fl);\n\t\tstatus = nlmsvc_unlink_block(block);\n\t\tnlmsvc_release_block(block);\n\t}\n\treturn status ? nlm_lck_denied : nlm_granted;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: nlmsvc_unlock(%s/%ld, pi=%d, %Ld-%Ld)\\n\"",
            "file_inode(file->f_file)->i_sb->s_id",
            "file_inode(file->f_file)->i_ino",
            "lock->fl.fl_pid",
            "(long long)lock->fl.fl_start",
            "(long long)lock->fl.fl_end"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file->f_file"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\n\n__be32\nnlmsvc_unlock(struct net *net, struct nlm_file *file, struct nlm_lock *lock)\n{\n\tint\terror;\n\n\tdprintk(\"lockd: nlmsvc_unlock(%s/%ld, pi=%d, %Ld-%Ld)\\n\",\n\t\t\t\tfile_inode(file->f_file)->i_sb->s_id,\n\t\t\t\tfile_inode(file->f_file)->i_ino,\n\t\t\t\tlock->fl.fl_pid,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end);\n\n\t/* First, cancel any lock that might be there */\n\tnlmsvc_cancel_blocked(net, file, lock);\n\n\tlock->fl.fl_type = F_UNLCK;\n\terror = vfs_lock_file(file->f_file, F_SETLK, &lock->fl, NULL);\n\n\treturn (error < 0)? nlm_lck_denied_nolocks : nlm_granted;\n}"
  },
  {
    "function_name": "nlmsvc_testlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "504-553",
    "snippet": "__be32\nnlmsvc_testlock(struct svc_rqst *rqstp, struct nlm_file *file,\n\t\tstruct nlm_host *host, struct nlm_lock *lock,\n\t\tstruct nlm_lock *conflock, struct nlm_cookie *cookie)\n{\n\tint\t\t\terror;\n\t__be32\t\t\tret;\n\n\tdprintk(\"lockd: nlmsvc_testlock(%s/%ld, ty=%d, %Ld-%Ld)\\n\",\n\t\t\t\tfile_inode(file->f_file)->i_sb->s_id,\n\t\t\t\tfile_inode(file->f_file)->i_ino,\n\t\t\t\tlock->fl.fl_type,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end);\n\n\tif (locks_in_grace(SVC_NET(rqstp))) {\n\t\tret = nlm_lck_denied_grace_period;\n\t\tgoto out;\n\t}\n\n\terror = vfs_test_lock(file->f_file, &lock->fl);\n\tif (error) {\n\t\t/* We can't currently deal with deferred test requests */\n\t\tif (error == FILE_LOCK_DEFERRED)\n\t\t\tWARN_ON_ONCE(1);\n\n\t\tret = nlm_lck_denied_nolocks;\n\t\tgoto out;\n\t}\n\n\tif (lock->fl.fl_type == F_UNLCK) {\n\t\tret = nlm_granted;\n\t\tgoto out;\n\t}\n\n\tdprintk(\"lockd: conflicting lock(ty=%d, %Ld-%Ld)\\n\",\n\t\tlock->fl.fl_type, (long long)lock->fl.fl_start,\n\t\t(long long)lock->fl.fl_end);\n\tconflock->caller = \"somehost\";\t/* FIXME */\n\tconflock->len = strlen(conflock->caller);\n\tconflock->oh.len = 0;\t\t/* don't return OH info */\n\tconflock->svid = lock->fl.fl_pid;\n\tconflock->fl.fl_type = lock->fl.fl_type;\n\tconflock->fl.fl_start = lock->fl.fl_start;\n\tconflock->fl.fl_end = lock->fl.fl_end;\n\tlocks_release_private(&lock->fl);\n\tret = nlm_lck_denied;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_release_private",
          "args": [
            "&lock->fl"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_locks_release_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "454-460",
          "snippet": "static void nlmclnt_locks_release_private(struct file_lock *fl)\n{\n\tspin_lock(&fl->fl_u.nfs_fl.owner->host->h_lock);\n\tlist_del(&fl->fl_u.nfs_fl.list);\n\tspin_unlock(&fl->fl_u.nfs_fl.owner->host->h_lock);\n\tnlm_put_lockowner(fl->fl_u.nfs_fl.owner);\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);",
            "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);",
            "static int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\nstatic int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);\n\nstatic void nlmclnt_locks_release_private(struct file_lock *fl)\n{\n\tspin_lock(&fl->fl_u.nfs_fl.owner->host->h_lock);\n\tlist_del(&fl->fl_u.nfs_fl.list);\n\tspin_unlock(&fl->fl_u.nfs_fl.owner->host->h_lock);\n\tnlm_put_lockowner(fl->fl_u.nfs_fl.owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "conflock->caller"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: conflicting lock(ty=%d, %Ld-%Ld)\\n\"",
            "lock->fl.fl_type",
            "(long long)lock->fl.fl_start",
            "(long long)lock->fl.fl_end"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_test_lock",
          "args": [
            "file->f_file",
            "&lock->fl"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_test_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1953-1959",
          "snippet": "int vfs_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, F_GETLK, fl);\n\tposix_test_lock(filp, fl);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint vfs_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, F_GETLK, fl);\n\tposix_test_lock(filp, fl);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_in_grace",
          "args": [
            "SVC_NET(rqstp)"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "locks_in_grace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/grace.c",
          "lines": "65-71",
          "snippet": "int\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <net/netns/generic.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int grace_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <net/netns/generic.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n\nstatic int grace_net_id;\n\nint\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: nlmsvc_testlock(%s/%ld, ty=%d, %Ld-%Ld)\\n\"",
            "file_inode(file->f_file)->i_sb->s_id",
            "file_inode(file->f_file)->i_ino",
            "lock->fl.fl_type",
            "(long long)lock->fl.fl_start",
            "(long long)lock->fl.fl_end"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file->f_file"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\n\n__be32\nnlmsvc_testlock(struct svc_rqst *rqstp, struct nlm_file *file,\n\t\tstruct nlm_host *host, struct nlm_lock *lock,\n\t\tstruct nlm_lock *conflock, struct nlm_cookie *cookie)\n{\n\tint\t\t\terror;\n\t__be32\t\t\tret;\n\n\tdprintk(\"lockd: nlmsvc_testlock(%s/%ld, ty=%d, %Ld-%Ld)\\n\",\n\t\t\t\tfile_inode(file->f_file)->i_sb->s_id,\n\t\t\t\tfile_inode(file->f_file)->i_ino,\n\t\t\t\tlock->fl.fl_type,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end);\n\n\tif (locks_in_grace(SVC_NET(rqstp))) {\n\t\tret = nlm_lck_denied_grace_period;\n\t\tgoto out;\n\t}\n\n\terror = vfs_test_lock(file->f_file, &lock->fl);\n\tif (error) {\n\t\t/* We can't currently deal with deferred test requests */\n\t\tif (error == FILE_LOCK_DEFERRED)\n\t\t\tWARN_ON_ONCE(1);\n\n\t\tret = nlm_lck_denied_nolocks;\n\t\tgoto out;\n\t}\n\n\tif (lock->fl.fl_type == F_UNLCK) {\n\t\tret = nlm_granted;\n\t\tgoto out;\n\t}\n\n\tdprintk(\"lockd: conflicting lock(ty=%d, %Ld-%Ld)\\n\",\n\t\tlock->fl.fl_type, (long long)lock->fl.fl_start,\n\t\t(long long)lock->fl.fl_end);\n\tconflock->caller = \"somehost\";\t/* FIXME */\n\tconflock->len = strlen(conflock->caller);\n\tconflock->oh.len = 0;\t\t/* don't return OH info */\n\tconflock->svid = lock->fl.fl_pid;\n\tconflock->fl.fl_type = lock->fl.fl_type;\n\tconflock->fl.fl_start = lock->fl.fl_start;\n\tconflock->fl.fl_end = lock->fl.fl_end;\n\tlocks_release_private(&lock->fl);\n\tret = nlm_lck_denied;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "nlmsvc_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "397-499",
    "snippet": "__be32\nnlmsvc_lock(struct svc_rqst *rqstp, struct nlm_file *file,\n\t    struct nlm_host *host, struct nlm_lock *lock, int wait,\n\t    struct nlm_cookie *cookie, int reclaim)\n{\n\tstruct nlm_block\t*block = NULL;\n\tint\t\t\terror;\n\t__be32\t\t\tret;\n\n\tdprintk(\"lockd: nlmsvc_lock(%s/%ld, ty=%d, pi=%d, %Ld-%Ld, bl=%d)\\n\",\n\t\t\t\tfile_inode(file->f_file)->i_sb->s_id,\n\t\t\t\tfile_inode(file->f_file)->i_ino,\n\t\t\t\tlock->fl.fl_type, lock->fl.fl_pid,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end,\n\t\t\t\twait);\n\n\t/* Lock file against concurrent access */\n\tmutex_lock(&file->f_mutex);\n\t/* Get existing block (in case client is busy-waiting)\n\t * or create new block\n\t */\n\tblock = nlmsvc_lookup_block(file, lock);\n\tif (block == NULL) {\n\t\tblock = nlmsvc_create_block(rqstp, host, file, lock, cookie);\n\t\tret = nlm_lck_denied_nolocks;\n\t\tif (block == NULL)\n\t\t\tgoto out;\n\t\tlock = &block->b_call->a_args.lock;\n\t} else\n\t\tlock->fl.fl_flags &= ~FL_SLEEP;\n\n\tif (block->b_flags & B_QUEUED) {\n\t\tdprintk(\"lockd: nlmsvc_lock deferred block %p flags %d\\n\",\n\t\t\t\t\t\t\tblock, block->b_flags);\n\t\tif (block->b_granted) {\n\t\t\tnlmsvc_unlink_block(block);\n\t\t\tret = nlm_granted;\n\t\t\tgoto out;\n\t\t}\n\t\tif (block->b_flags & B_TIMED_OUT) {\n\t\t\tnlmsvc_unlink_block(block);\n\t\t\tret = nlm_lck_denied;\n\t\t\tgoto out;\n\t\t}\n\t\tret = nlm_drop_reply;\n\t\tgoto out;\n\t}\n\n\tif (locks_in_grace(SVC_NET(rqstp)) && !reclaim) {\n\t\tret = nlm_lck_denied_grace_period;\n\t\tgoto out;\n\t}\n\tif (reclaim && !locks_in_grace(SVC_NET(rqstp))) {\n\t\tret = nlm_lck_denied_grace_period;\n\t\tgoto out;\n\t}\n\n\tif (!wait)\n\t\tlock->fl.fl_flags &= ~FL_SLEEP;\n\terror = vfs_lock_file(file->f_file, F_SETLK, &lock->fl, NULL);\n\tlock->fl.fl_flags &= ~FL_SLEEP;\n\n\tdprintk(\"lockd: vfs_lock_file returned %d\\n\", error);\n\tswitch (error) {\n\t\tcase 0:\n\t\t\tret = nlm_granted;\n\t\t\tgoto out;\n\t\tcase -EAGAIN:\n\t\t\t/*\n\t\t\t * If this is a blocking request for an\n\t\t\t * already pending lock request then we need\n\t\t\t * to put it back on lockd's block list\n\t\t\t */\n\t\t\tif (wait)\n\t\t\t\tbreak;\n\t\t\tret = nlm_lck_denied;\n\t\t\tgoto out;\n\t\tcase FILE_LOCK_DEFERRED:\n\t\t\tif (wait)\n\t\t\t\tbreak;\n\t\t\t/* Filesystem lock operation is in progress\n\t\t\t   Add it to the queue waiting for callback */\n\t\t\tret = nlmsvc_defer_lock_rqst(rqstp, block);\n\t\t\tgoto out;\n\t\tcase -EDEADLK:\n\t\t\tret = nlm_deadlock;\n\t\t\tgoto out;\n\t\tdefault:\t\t\t/* includes ENOLCK */\n\t\t\tret = nlm_lck_denied_nolocks;\n\t\t\tgoto out;\n\t}\n\n\tret = nlm_lck_blocked;\n\n\t/* Append to list of blocked */\n\tnlmsvc_insert_block(block, NLM_NEVER);\nout:\n\tmutex_unlock(&file->f_mutex);\n\tnlmsvc_release_block(block);\n\tdprintk(\"lockd: nlmsvc_lock returned %u\\n\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define nlm_deadlock\tnlm_lck_denied",
      "#define nlm_deadlock\tnlm4_deadlock"
    ],
    "globals_used": [
      "static void nlmsvc_release_block(struct nlm_block *block);",
      "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
      "static void\tnlmsvc_remove_block(struct nlm_block *block);",
      "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: nlmsvc_lock returned %u\\n\"",
            "ret"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsvc_release_block",
          "args": [
            "block"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_release_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "300-304",
          "snippet": "static void nlmsvc_release_block(struct nlm_block *block)\n{\n\tif (block != NULL)\n\t\tkref_put_mutex(&block->b_count, nlmsvc_free_block, &block->b_file->f_mutex);\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\n\nstatic void nlmsvc_release_block(struct nlm_block *block)\n{\n\tif (block != NULL)\n\t\tkref_put_mutex(&block->b_count, nlmsvc_free_block, &block->b_file->f_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&file->f_mutex"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsvc_insert_block",
          "args": [
            "block",
            "NLM_NEVER"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_insert_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "119-124",
          "snippet": "static void nlmsvc_insert_block(struct nlm_block *block, unsigned long when)\n{\n\tspin_lock(&nlm_blocked_lock);\n\tnlmsvc_insert_block_locked(block, when);\n\tspin_unlock(&nlm_blocked_lock);\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);",
            "static DEFINE_SPINLOCK(nlm_blocked_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic DEFINE_SPINLOCK(nlm_blocked_lock);\n\nstatic void nlmsvc_insert_block(struct nlm_block *block, unsigned long when)\n{\n\tspin_lock(&nlm_blocked_lock);\n\tnlmsvc_insert_block_locked(block, when);\n\tspin_unlock(&nlm_blocked_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_defer_lock_rqst",
          "args": [
            "rqstp",
            "block"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_defer_lock_rqst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "371-391",
          "snippet": "static __be32\nnlmsvc_defer_lock_rqst(struct svc_rqst *rqstp, struct nlm_block *block)\n{\n\t__be32 status = nlm_lck_denied_nolocks;\n\n\tblock->b_flags |= B_QUEUED;\n\n\tnlmsvc_insert_block(block, NLM_TIMEOUT);\n\n\tblock->b_cache_req = &rqstp->rq_chandle;\n\tif (rqstp->rq_chandle.defer) {\n\t\tblock->b_deferred_req =\n\t\t\trqstp->rq_chandle.defer(block->b_cache_req);\n\t\tif (block->b_deferred_req != NULL)\n\t\t\tstatus = nlm_drop_reply;\n\t}\n\tdprintk(\"lockd: nlmsvc_defer_lock_rqst block %p flags %d status %d\\n\",\n\t\tblock, block->b_flags, ntohl(status));\n\n\treturn status;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\n\nstatic __be32\nnlmsvc_defer_lock_rqst(struct svc_rqst *rqstp, struct nlm_block *block)\n{\n\t__be32 status = nlm_lck_denied_nolocks;\n\n\tblock->b_flags |= B_QUEUED;\n\n\tnlmsvc_insert_block(block, NLM_TIMEOUT);\n\n\tblock->b_cache_req = &rqstp->rq_chandle;\n\tif (rqstp->rq_chandle.defer) {\n\t\tblock->b_deferred_req =\n\t\t\trqstp->rq_chandle.defer(block->b_cache_req);\n\t\tif (block->b_deferred_req != NULL)\n\t\t\tstatus = nlm_drop_reply;\n\t}\n\tdprintk(\"lockd: nlmsvc_defer_lock_rqst block %p flags %d status %d\\n\",\n\t\tblock, block->b_flags, ntohl(status));\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: vfs_lock_file returned %d\\n\"",
            "error"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_lock_file",
          "args": [
            "file->f_file",
            "F_SETLK",
            "&lock->fl",
            "NULL"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_lock_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "2077-2083",
          "snippet": "int vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, cmd, fl);\n\telse\n\t\treturn posix_lock_file(filp, fl, conf);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, cmd, fl);\n\telse\n\t\treturn posix_lock_file(filp, fl, conf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_in_grace",
          "args": [
            "SVC_NET(rqstp)"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "locks_in_grace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/grace.c",
          "lines": "65-71",
          "snippet": "int\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <net/netns/generic.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int grace_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <net/netns/generic.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n\nstatic int grace_net_id;\n\nint\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsvc_unlink_block",
          "args": [
            "block"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_unlink_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "272-281",
          "snippet": "static int nlmsvc_unlink_block(struct nlm_block *block)\n{\n\tint status;\n\tdprintk(\"lockd: unlinking block %p...\\n\", block);\n\n\t/* Remove block from list */\n\tstatus = posix_unblock_lock(&block->b_call->a_args.lock.fl);\n\tnlmsvc_remove_block(block);\n\treturn status;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);",
            "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\n\nstatic int nlmsvc_unlink_block(struct nlm_block *block)\n{\n\tint status;\n\tdprintk(\"lockd: unlinking block %p...\\n\", block);\n\n\t/* Remove block from list */\n\tstatus = posix_unblock_lock(&block->b_call->a_args.lock.fl);\n\tnlmsvc_remove_block(block);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: nlmsvc_lock deferred block %p flags %d\\n\"",
            "block",
            "block->b_flags"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsvc_create_block",
          "args": [
            "rqstp",
            "host",
            "file",
            "lock",
            "cookie"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_create_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "214-265",
          "snippet": "static struct nlm_block *\nnlmsvc_create_block(struct svc_rqst *rqstp, struct nlm_host *host,\n\t\t    struct nlm_file *file, struct nlm_lock *lock,\n\t\t    struct nlm_cookie *cookie)\n{\n\tstruct nlm_block\t*block;\n\tstruct nlm_rqst\t\t*call = NULL;\n\n\tcall = nlm_alloc_call(host);\n\tif (call == NULL)\n\t\treturn NULL;\n\n\t/* Allocate memory for block, and initialize arguments */\n\tblock = kzalloc(sizeof(*block), GFP_KERNEL);\n\tif (block == NULL)\n\t\tgoto failed;\n\tkref_init(&block->b_count);\n\tINIT_LIST_HEAD(&block->b_list);\n\tINIT_LIST_HEAD(&block->b_flist);\n\n\tif (!nlmsvc_setgrantargs(call, lock))\n\t\tgoto failed_free;\n\n\t/* Set notifier function for VFS, and init args */\n\tcall->a_args.lock.fl.fl_flags |= FL_SLEEP;\n\tcall->a_args.lock.fl.fl_lmops = &nlmsvc_lock_operations;\n\tnlmclnt_next_cookie(&call->a_args.cookie);\n\n\tdprintk(\"lockd: created block %p...\\n\", block);\n\n\t/* Create and initialize the block */\n\tblock->b_daemon = rqstp->rq_server;\n\tblock->b_host   = host;\n\tblock->b_file   = file;\n\tfile->f_count++;\n\n\t/* Add to file's list of blocks */\n\tlist_add(&block->b_flist, &file->f_blocks);\n\n\t/* Set up RPC arguments for callback */\n\tblock->b_call = call;\n\tcall->a_flags   = RPC_TASK_ASYNC;\n\tcall->a_block = block;\n\n\treturn block;\n\nfailed_free:\n\tkfree(block);\nfailed:\n\tnlmsvc_release_call(call);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);",
            "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);",
            "static void nlmsvc_freegrantargs(struct nlm_rqst *call);",
            "const struct lock_manager_operations nlmsvc_lock_operations = {\n\t.lm_compare_owner = nlmsvc_same_owner,\n\t.lm_owner_key = nlmsvc_owner_key,\n\t.lm_notify = nlmsvc_notify_blocked,\n\t.lm_grant = nlmsvc_grant_deferred,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\nstatic void nlmsvc_freegrantargs(struct nlm_rqst *call);\nconst struct lock_manager_operations nlmsvc_lock_operations = {\n\t.lm_compare_owner = nlmsvc_same_owner,\n\t.lm_owner_key = nlmsvc_owner_key,\n\t.lm_notify = nlmsvc_notify_blocked,\n\t.lm_grant = nlmsvc_grant_deferred,\n};\n\nstatic struct nlm_block *\nnlmsvc_create_block(struct svc_rqst *rqstp, struct nlm_host *host,\n\t\t    struct nlm_file *file, struct nlm_lock *lock,\n\t\t    struct nlm_cookie *cookie)\n{\n\tstruct nlm_block\t*block;\n\tstruct nlm_rqst\t\t*call = NULL;\n\n\tcall = nlm_alloc_call(host);\n\tif (call == NULL)\n\t\treturn NULL;\n\n\t/* Allocate memory for block, and initialize arguments */\n\tblock = kzalloc(sizeof(*block), GFP_KERNEL);\n\tif (block == NULL)\n\t\tgoto failed;\n\tkref_init(&block->b_count);\n\tINIT_LIST_HEAD(&block->b_list);\n\tINIT_LIST_HEAD(&block->b_flist);\n\n\tif (!nlmsvc_setgrantargs(call, lock))\n\t\tgoto failed_free;\n\n\t/* Set notifier function for VFS, and init args */\n\tcall->a_args.lock.fl.fl_flags |= FL_SLEEP;\n\tcall->a_args.lock.fl.fl_lmops = &nlmsvc_lock_operations;\n\tnlmclnt_next_cookie(&call->a_args.cookie);\n\n\tdprintk(\"lockd: created block %p...\\n\", block);\n\n\t/* Create and initialize the block */\n\tblock->b_daemon = rqstp->rq_server;\n\tblock->b_host   = host;\n\tblock->b_file   = file;\n\tfile->f_count++;\n\n\t/* Add to file's list of blocks */\n\tlist_add(&block->b_flist, &file->f_blocks);\n\n\t/* Set up RPC arguments for callback */\n\tblock->b_call = call;\n\tcall->a_flags   = RPC_TASK_ASYNC;\n\tcall->a_block = block;\n\n\treturn block;\n\nfailed_free:\n\tkfree(block);\nfailed:\n\tnlmsvc_release_call(call);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_lookup_block",
          "args": [
            "file",
            "lock"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_lookup_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "143-167",
          "snippet": "static struct nlm_block *\nnlmsvc_lookup_block(struct nlm_file *file, struct nlm_lock *lock)\n{\n\tstruct nlm_block\t*block;\n\tstruct file_lock\t*fl;\n\n\tdprintk(\"lockd: nlmsvc_lookup_block f=%p pd=%d %Ld-%Ld ty=%d\\n\",\n\t\t\t\tfile, lock->fl.fl_pid,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end, lock->fl.fl_type);\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tfl = &block->b_call->a_args.lock.fl;\n\t\tdprintk(\"lockd: check f=%p pd=%d %Ld-%Ld ty=%d cookie=%s\\n\",\n\t\t\t\tblock->b_file, fl->fl_pid,\n\t\t\t\t(long long)fl->fl_start,\n\t\t\t\t(long long)fl->fl_end, fl->fl_type,\n\t\t\t\tnlmdbg_cookie2a(&block->b_call->a_args.cookie));\n\t\tif (block->b_file == file && nlm_compare_locks(fl, &lock->fl)) {\n\t\t\tkref_get(&block->b_count);\n\t\t\treturn block;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);",
            "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);",
            "static LIST_HEAD(nlm_blocked);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\nstatic LIST_HEAD(nlm_blocked);\n\nstatic struct nlm_block *\nnlmsvc_lookup_block(struct nlm_file *file, struct nlm_lock *lock)\n{\n\tstruct nlm_block\t*block;\n\tstruct file_lock\t*fl;\n\n\tdprintk(\"lockd: nlmsvc_lookup_block f=%p pd=%d %Ld-%Ld ty=%d\\n\",\n\t\t\t\tfile, lock->fl.fl_pid,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end, lock->fl.fl_type);\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tfl = &block->b_call->a_args.lock.fl;\n\t\tdprintk(\"lockd: check f=%p pd=%d %Ld-%Ld ty=%d cookie=%s\\n\",\n\t\t\t\tblock->b_file, fl->fl_pid,\n\t\t\t\t(long long)fl->fl_start,\n\t\t\t\t(long long)fl->fl_end, fl->fl_type,\n\t\t\t\tnlmdbg_cookie2a(&block->b_call->a_args.cookie));\n\t\tif (block->b_file == file && nlm_compare_locks(fl, &lock->fl)) {\n\t\t\tkref_get(&block->b_count);\n\t\t\treturn block;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&file->f_mutex"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: nlmsvc_lock(%s/%ld, ty=%d, pi=%d, %Ld-%Ld, bl=%d)\\n\"",
            "file_inode(file->f_file)->i_sb->s_id",
            "file_inode(file->f_file)->i_ino",
            "lock->fl.fl_type",
            "lock->fl.fl_pid",
            "(long long)lock->fl.fl_start",
            "(long long)lock->fl.fl_end",
            "wait"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file->f_file"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define nlm_deadlock\tnlm_lck_denied\n#define nlm_deadlock\tnlm4_deadlock\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\n\n__be32\nnlmsvc_lock(struct svc_rqst *rqstp, struct nlm_file *file,\n\t    struct nlm_host *host, struct nlm_lock *lock, int wait,\n\t    struct nlm_cookie *cookie, int reclaim)\n{\n\tstruct nlm_block\t*block = NULL;\n\tint\t\t\terror;\n\t__be32\t\t\tret;\n\n\tdprintk(\"lockd: nlmsvc_lock(%s/%ld, ty=%d, pi=%d, %Ld-%Ld, bl=%d)\\n\",\n\t\t\t\tfile_inode(file->f_file)->i_sb->s_id,\n\t\t\t\tfile_inode(file->f_file)->i_ino,\n\t\t\t\tlock->fl.fl_type, lock->fl.fl_pid,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end,\n\t\t\t\twait);\n\n\t/* Lock file against concurrent access */\n\tmutex_lock(&file->f_mutex);\n\t/* Get existing block (in case client is busy-waiting)\n\t * or create new block\n\t */\n\tblock = nlmsvc_lookup_block(file, lock);\n\tif (block == NULL) {\n\t\tblock = nlmsvc_create_block(rqstp, host, file, lock, cookie);\n\t\tret = nlm_lck_denied_nolocks;\n\t\tif (block == NULL)\n\t\t\tgoto out;\n\t\tlock = &block->b_call->a_args.lock;\n\t} else\n\t\tlock->fl.fl_flags &= ~FL_SLEEP;\n\n\tif (block->b_flags & B_QUEUED) {\n\t\tdprintk(\"lockd: nlmsvc_lock deferred block %p flags %d\\n\",\n\t\t\t\t\t\t\tblock, block->b_flags);\n\t\tif (block->b_granted) {\n\t\t\tnlmsvc_unlink_block(block);\n\t\t\tret = nlm_granted;\n\t\t\tgoto out;\n\t\t}\n\t\tif (block->b_flags & B_TIMED_OUT) {\n\t\t\tnlmsvc_unlink_block(block);\n\t\t\tret = nlm_lck_denied;\n\t\t\tgoto out;\n\t\t}\n\t\tret = nlm_drop_reply;\n\t\tgoto out;\n\t}\n\n\tif (locks_in_grace(SVC_NET(rqstp)) && !reclaim) {\n\t\tret = nlm_lck_denied_grace_period;\n\t\tgoto out;\n\t}\n\tif (reclaim && !locks_in_grace(SVC_NET(rqstp))) {\n\t\tret = nlm_lck_denied_grace_period;\n\t\tgoto out;\n\t}\n\n\tif (!wait)\n\t\tlock->fl.fl_flags &= ~FL_SLEEP;\n\terror = vfs_lock_file(file->f_file, F_SETLK, &lock->fl, NULL);\n\tlock->fl.fl_flags &= ~FL_SLEEP;\n\n\tdprintk(\"lockd: vfs_lock_file returned %d\\n\", error);\n\tswitch (error) {\n\t\tcase 0:\n\t\t\tret = nlm_granted;\n\t\t\tgoto out;\n\t\tcase -EAGAIN:\n\t\t\t/*\n\t\t\t * If this is a blocking request for an\n\t\t\t * already pending lock request then we need\n\t\t\t * to put it back on lockd's block list\n\t\t\t */\n\t\t\tif (wait)\n\t\t\t\tbreak;\n\t\t\tret = nlm_lck_denied;\n\t\t\tgoto out;\n\t\tcase FILE_LOCK_DEFERRED:\n\t\t\tif (wait)\n\t\t\t\tbreak;\n\t\t\t/* Filesystem lock operation is in progress\n\t\t\t   Add it to the queue waiting for callback */\n\t\t\tret = nlmsvc_defer_lock_rqst(rqstp, block);\n\t\t\tgoto out;\n\t\tcase -EDEADLK:\n\t\t\tret = nlm_deadlock;\n\t\t\tgoto out;\n\t\tdefault:\t\t\t/* includes ENOLCK */\n\t\t\tret = nlm_lck_denied_nolocks;\n\t\t\tgoto out;\n\t}\n\n\tret = nlm_lck_blocked;\n\n\t/* Append to list of blocked */\n\tnlmsvc_insert_block(block, NLM_NEVER);\nout:\n\tmutex_unlock(&file->f_mutex);\n\tnlmsvc_release_block(block);\n\tdprintk(\"lockd: nlmsvc_lock returned %u\\n\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "nlmsvc_defer_lock_rqst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "371-391",
    "snippet": "static __be32\nnlmsvc_defer_lock_rqst(struct svc_rqst *rqstp, struct nlm_block *block)\n{\n\t__be32 status = nlm_lck_denied_nolocks;\n\n\tblock->b_flags |= B_QUEUED;\n\n\tnlmsvc_insert_block(block, NLM_TIMEOUT);\n\n\tblock->b_cache_req = &rqstp->rq_chandle;\n\tif (rqstp->rq_chandle.defer) {\n\t\tblock->b_deferred_req =\n\t\t\trqstp->rq_chandle.defer(block->b_cache_req);\n\t\tif (block->b_deferred_req != NULL)\n\t\t\tstatus = nlm_drop_reply;\n\t}\n\tdprintk(\"lockd: nlmsvc_defer_lock_rqst block %p flags %d status %d\\n\",\n\t\tblock, block->b_flags, ntohl(status));\n\n\treturn status;\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nlmsvc_release_block(struct nlm_block *block);",
      "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
      "static void\tnlmsvc_remove_block(struct nlm_block *block);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: nlmsvc_defer_lock_rqst block %p flags %d status %d\\n\"",
            "block",
            "block->b_flags",
            "ntohl(status)"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "status"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rqstp->rq_chandle.defer",
          "args": [
            "block->b_cache_req"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsvc_insert_block",
          "args": [
            "block",
            "NLM_TIMEOUT"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_insert_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "119-124",
          "snippet": "static void nlmsvc_insert_block(struct nlm_block *block, unsigned long when)\n{\n\tspin_lock(&nlm_blocked_lock);\n\tnlmsvc_insert_block_locked(block, when);\n\tspin_unlock(&nlm_blocked_lock);\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);",
            "static DEFINE_SPINLOCK(nlm_blocked_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic DEFINE_SPINLOCK(nlm_blocked_lock);\n\nstatic void nlmsvc_insert_block(struct nlm_block *block, unsigned long when)\n{\n\tspin_lock(&nlm_blocked_lock);\n\tnlmsvc_insert_block_locked(block, when);\n\tspin_unlock(&nlm_blocked_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\n\nstatic __be32\nnlmsvc_defer_lock_rqst(struct svc_rqst *rqstp, struct nlm_block *block)\n{\n\t__be32 status = nlm_lck_denied_nolocks;\n\n\tblock->b_flags |= B_QUEUED;\n\n\tnlmsvc_insert_block(block, NLM_TIMEOUT);\n\n\tblock->b_cache_req = &rqstp->rq_chandle;\n\tif (rqstp->rq_chandle.defer) {\n\t\tblock->b_deferred_req =\n\t\t\trqstp->rq_chandle.defer(block->b_cache_req);\n\t\tif (block->b_deferred_req != NULL)\n\t\t\tstatus = nlm_drop_reply;\n\t}\n\tdprintk(\"lockd: nlmsvc_defer_lock_rqst block %p flags %d status %d\\n\",\n\t\tblock, block->b_flags, ntohl(status));\n\n\treturn status;\n}"
  },
  {
    "function_name": "nlmsvc_freegrantargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "360-366",
    "snippet": "static void nlmsvc_freegrantargs(struct nlm_rqst *call)\n{\n\tif (call->a_args.lock.oh.data != call->a_owner)\n\t\tkfree(call->a_args.lock.oh.data);\n\n\tlocks_release_private(&call->a_args.lock.fl);\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);",
      "static void nlmsvc_freegrantargs(struct nlm_rqst *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_release_private",
          "args": [
            "&call->a_args.lock.fl"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_locks_release_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "454-460",
          "snippet": "static void nlmclnt_locks_release_private(struct file_lock *fl)\n{\n\tspin_lock(&fl->fl_u.nfs_fl.owner->host->h_lock);\n\tlist_del(&fl->fl_u.nfs_fl.list);\n\tspin_unlock(&fl->fl_u.nfs_fl.owner->host->h_lock);\n\tnlm_put_lockowner(fl->fl_u.nfs_fl.owner);\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);",
            "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);",
            "static int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\nstatic int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);\n\nstatic void nlmclnt_locks_release_private(struct file_lock *fl)\n{\n\tspin_lock(&fl->fl_u.nfs_fl.owner->host->h_lock);\n\tlist_del(&fl->fl_u.nfs_fl.list);\n\tspin_unlock(&fl->fl_u.nfs_fl.owner->host->h_lock);\n\tnlm_put_lockowner(fl->fl_u.nfs_fl.owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "call->a_args.lock.oh.data"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\nstatic void nlmsvc_freegrantargs(struct nlm_rqst *call);\n\nstatic void nlmsvc_freegrantargs(struct nlm_rqst *call)\n{\n\tif (call->a_args.lock.oh.data != call->a_owner)\n\t\tkfree(call->a_args.lock.oh.data);\n\n\tlocks_release_private(&call->a_args.lock.fl);\n}"
  },
  {
    "function_name": "nlmsvc_setgrantargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "338-358",
    "snippet": "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock)\n{\n\tlocks_copy_lock(&call->a_args.lock.fl, &lock->fl);\n\tmemcpy(&call->a_args.lock.fh, &lock->fh, sizeof(call->a_args.lock.fh));\n\tcall->a_args.lock.caller = utsname()->nodename;\n\tcall->a_args.lock.oh.len = lock->oh.len;\n\n\t/* set default data area */\n\tcall->a_args.lock.oh.data = call->a_owner;\n\tcall->a_args.lock.svid = lock->fl.fl_pid;\n\n\tif (lock->oh.len > NLMCLNT_OHSIZE) {\n\t\tvoid *data = kmalloc(lock->oh.len, GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn 0;\n\t\tcall->a_args.lock.oh.data = (u8 *) data;\n\t}\n\n\tmemcpy(call->a_args.lock.oh.data, lock->oh.data, lock->oh.len);\n\treturn 1;\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);",
      "static void nlmsvc_freegrantargs(struct nlm_rqst *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "call->a_args.lock.oh.data",
            "lock->oh.data",
            "lock->oh.len"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "lock->oh.len",
            "GFP_KERNEL"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "utsname",
          "args": [],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&call->a_args.lock.fh",
            "&lock->fh",
            "sizeof(call->a_args.lock.fh)"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_copy_lock",
          "args": [
            "&call->a_args.lock.fl",
            "&lock->fl"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_locks_copy_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "445-452",
          "snippet": "static void nlmclnt_locks_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\tspin_lock(&fl->fl_u.nfs_fl.owner->host->h_lock);\n\tnew->fl_u.nfs_fl.state = fl->fl_u.nfs_fl.state;\n\tnew->fl_u.nfs_fl.owner = nlm_get_lockowner(fl->fl_u.nfs_fl.owner);\n\tlist_add_tail(&new->fl_u.nfs_fl.list, &fl->fl_u.nfs_fl.owner->host->h_granted);\n\tspin_unlock(&fl->fl_u.nfs_fl.owner->host->h_lock);\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);",
            "static int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);",
            "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);",
            "static int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int\tnlmclnt_test(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_lock(struct nlm_rqst *, struct file_lock *);\nstatic int\tnlmclnt_unlock(struct nlm_rqst *, struct file_lock *);\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\nstatic int\tnlmclnt_cancel(struct nlm_host *, int , struct file_lock *);\n\nstatic void nlmclnt_locks_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\tspin_lock(&fl->fl_u.nfs_fl.owner->host->h_lock);\n\tnew->fl_u.nfs_fl.state = fl->fl_u.nfs_fl.state;\n\tnew->fl_u.nfs_fl.owner = nlm_get_lockowner(fl->fl_u.nfs_fl.owner);\n\tlist_add_tail(&new->fl_u.nfs_fl.list, &fl->fl_u.nfs_fl.owner->host->h_granted);\n\tspin_unlock(&fl->fl_u.nfs_fl.owner->host->h_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\nstatic void nlmsvc_freegrantargs(struct nlm_rqst *call);\n\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock)\n{\n\tlocks_copy_lock(&call->a_args.lock.fl, &lock->fl);\n\tmemcpy(&call->a_args.lock.fh, &lock->fh, sizeof(call->a_args.lock.fh));\n\tcall->a_args.lock.caller = utsname()->nodename;\n\tcall->a_args.lock.oh.len = lock->oh.len;\n\n\t/* set default data area */\n\tcall->a_args.lock.oh.data = call->a_owner;\n\tcall->a_args.lock.svid = lock->fl.fl_pid;\n\n\tif (lock->oh.len > NLMCLNT_OHSIZE) {\n\t\tvoid *data = kmalloc(lock->oh.len, GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn 0;\n\t\tcall->a_args.lock.oh.data = (u8 *) data;\n\t}\n\n\tmemcpy(call->a_args.lock.oh.data, lock->oh.data, lock->oh.len);\n\treturn 1;\n}"
  },
  {
    "function_name": "nlmsvc_traverse_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "310-332",
    "snippet": "void nlmsvc_traverse_blocks(struct nlm_host *host,\n\t\t\tstruct nlm_file *file,\n\t\t\tnlm_host_match_fn_t match)\n{\n\tstruct nlm_block *block, *next;\n\nrestart:\n\tmutex_lock(&file->f_mutex);\n\tlist_for_each_entry_safe(block, next, &file->f_blocks, b_flist) {\n\t\tif (!match(block->b_host, host))\n\t\t\tcontinue;\n\t\t/* Do not destroy blocks that are not on\n\t\t * the global retry list - why? */\n\t\tif (list_empty(&block->b_list))\n\t\t\tcontinue;\n\t\tkref_get(&block->b_count);\n\t\tmutex_unlock(&file->f_mutex);\n\t\tnlmsvc_unlink_block(block);\n\t\tnlmsvc_release_block(block);\n\t\tgoto restart;\n\t}\n\tmutex_unlock(&file->f_mutex);\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nlmsvc_release_block(struct nlm_block *block);",
      "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
      "static void\tnlmsvc_remove_block(struct nlm_block *block);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&file->f_mutex"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsvc_release_block",
          "args": [
            "block"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_release_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "300-304",
          "snippet": "static void nlmsvc_release_block(struct nlm_block *block)\n{\n\tif (block != NULL)\n\t\tkref_put_mutex(&block->b_count, nlmsvc_free_block, &block->b_file->f_mutex);\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\n\nstatic void nlmsvc_release_block(struct nlm_block *block)\n{\n\tif (block != NULL)\n\t\tkref_put_mutex(&block->b_count, nlmsvc_free_block, &block->b_file->f_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_unlink_block",
          "args": [
            "block"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_unlink_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "272-281",
          "snippet": "static int nlmsvc_unlink_block(struct nlm_block *block)\n{\n\tint status;\n\tdprintk(\"lockd: unlinking block %p...\\n\", block);\n\n\t/* Remove block from list */\n\tstatus = posix_unblock_lock(&block->b_call->a_args.lock.fl);\n\tnlmsvc_remove_block(block);\n\treturn status;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);",
            "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\n\nstatic int nlmsvc_unlink_block(struct nlm_block *block)\n{\n\tint status;\n\tdprintk(\"lockd: unlinking block %p...\\n\", block);\n\n\t/* Remove block from list */\n\tstatus = posix_unblock_lock(&block->b_call->a_args.lock.fl);\n\tnlmsvc_remove_block(block);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&file->f_mutex"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&block->b_count"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&block->b_list"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match",
          "args": [
            "block->b_host",
            "host"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_cookie_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "169-176",
          "snippet": "static inline int nlm_cookie_match(struct nlm_cookie *a, struct nlm_cookie *b)\n{\n\tif (a->len != b->len)\n\t\treturn 0;\n\tif (memcmp(a->data, b->data, a->len))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline int nlm_cookie_match(struct nlm_cookie *a, struct nlm_cookie *b)\n{\n\tif (a->len != b->len)\n\t\treturn 0;\n\tif (memcmp(a->data, b->data, a->len))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "block",
            "next",
            "&file->f_blocks",
            "b_flist"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&file->f_mutex"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\n\nvoid nlmsvc_traverse_blocks(struct nlm_host *host,\n\t\t\tstruct nlm_file *file,\n\t\t\tnlm_host_match_fn_t match)\n{\n\tstruct nlm_block *block, *next;\n\nrestart:\n\tmutex_lock(&file->f_mutex);\n\tlist_for_each_entry_safe(block, next, &file->f_blocks, b_flist) {\n\t\tif (!match(block->b_host, host))\n\t\t\tcontinue;\n\t\t/* Do not destroy blocks that are not on\n\t\t * the global retry list - why? */\n\t\tif (list_empty(&block->b_list))\n\t\t\tcontinue;\n\t\tkref_get(&block->b_count);\n\t\tmutex_unlock(&file->f_mutex);\n\t\tnlmsvc_unlink_block(block);\n\t\tnlmsvc_release_block(block);\n\t\tgoto restart;\n\t}\n\tmutex_unlock(&file->f_mutex);\n}"
  },
  {
    "function_name": "nlmsvc_release_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "300-304",
    "snippet": "static void nlmsvc_release_block(struct nlm_block *block)\n{\n\tif (block != NULL)\n\t\tkref_put_mutex(&block->b_count, nlmsvc_free_block, &block->b_file->f_mutex);\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nlmsvc_release_block(struct nlm_block *block);",
      "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
      "static void\tnlmsvc_remove_block(struct nlm_block *block);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put_mutex",
          "args": [
            "&block->b_count",
            "nlmsvc_free_block",
            "&block->b_file->f_mutex"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\n\nstatic void nlmsvc_release_block(struct nlm_block *block)\n{\n\tif (block != NULL)\n\t\tkref_put_mutex(&block->b_count, nlmsvc_free_block, &block->b_file->f_mutex);\n}"
  },
  {
    "function_name": "nlmsvc_free_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "283-298",
    "snippet": "static void nlmsvc_free_block(struct kref *kref)\n{\n\tstruct nlm_block *block = container_of(kref, struct nlm_block, b_count);\n\tstruct nlm_file\t\t*file = block->b_file;\n\n\tdprintk(\"lockd: freeing block %p...\\n\", block);\n\n\t/* Remove block from file's list of blocks */\n\tlist_del_init(&block->b_flist);\n\tmutex_unlock(&file->f_mutex);\n\n\tnlmsvc_freegrantargs(block->b_call);\n\tnlmsvc_release_call(block->b_call);\n\tnlm_release_file(block->b_file);\n\tkfree(block);\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nlmsvc_release_block(struct nlm_block *block);",
      "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
      "static void\tnlmsvc_remove_block(struct nlm_block *block);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "block"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_release_file",
          "args": [
            "block->b_file"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_release_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svcsubs.c",
          "lines": "296-310",
          "snippet": "void\nnlm_release_file(struct nlm_file *file)\n{\n\tdprintk(\"lockd: nlm_release_file(%p, ct = %d)\\n\",\n\t\t\t\tfile, file->f_count);\n\n\t/* Lock file table */\n\tmutex_lock(&nlm_file_mutex);\n\n\t/* If there are no more locks etc, delete the file */\n\tif (--file->f_count == 0 && !nlm_file_inuse(file))\n\t\tnlm_delete_file(file);\n\n\tmutex_unlock(&nlm_file_mutex);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/in.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nlm_file_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/in.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(nlm_file_mutex);\n\nvoid\nnlm_release_file(struct nlm_file *file)\n{\n\tdprintk(\"lockd: nlm_release_file(%p, ct = %d)\\n\",\n\t\t\t\tfile, file->f_count);\n\n\t/* Lock file table */\n\tmutex_lock(&nlm_file_mutex);\n\n\t/* If there are no more locks etc, delete the file */\n\tif (--file->f_count == 0 && !nlm_file_inuse(file))\n\t\tnlm_delete_file(file);\n\n\tmutex_unlock(&nlm_file_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_release_call",
          "args": [
            "block->b_call"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_release_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svcproc.c",
          "lines": "264-270",
          "snippet": "void nlmsvc_release_call(struct nlm_rqst *call)\n{\n\tif (!atomic_dec_and_test(&call->a_count))\n\t\treturn;\n\tnlmsvc_release_host(call->a_host);\n\tkfree(call);\n}",
          "includes": [
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/time.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nvoid nlmsvc_release_call(struct nlm_rqst *call)\n{\n\tif (!atomic_dec_and_test(&call->a_count))\n\t\treturn;\n\tnlmsvc_release_host(call->a_host);\n\tkfree(call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_freegrantargs",
          "args": [
            "block->b_call"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_freegrantargs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "360-366",
          "snippet": "static void nlmsvc_freegrantargs(struct nlm_rqst *call)\n{\n\tif (call->a_args.lock.oh.data != call->a_owner)\n\t\tkfree(call->a_args.lock.oh.data);\n\n\tlocks_release_private(&call->a_args.lock.fl);\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);",
            "static void nlmsvc_freegrantargs(struct nlm_rqst *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\nstatic void nlmsvc_freegrantargs(struct nlm_rqst *call);\n\nstatic void nlmsvc_freegrantargs(struct nlm_rqst *call)\n{\n\tif (call->a_args.lock.oh.data != call->a_owner)\n\t\tkfree(call->a_args.lock.oh.data);\n\n\tlocks_release_private(&call->a_args.lock.fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&file->f_mutex"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&block->b_flist"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: freeing block %p...\\n\"",
            "block"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structnlm_block",
            "b_count"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\n\nstatic void nlmsvc_free_block(struct kref *kref)\n{\n\tstruct nlm_block *block = container_of(kref, struct nlm_block, b_count);\n\tstruct nlm_file\t\t*file = block->b_file;\n\n\tdprintk(\"lockd: freeing block %p...\\n\", block);\n\n\t/* Remove block from file's list of blocks */\n\tlist_del_init(&block->b_flist);\n\tmutex_unlock(&file->f_mutex);\n\n\tnlmsvc_freegrantargs(block->b_call);\n\tnlmsvc_release_call(block->b_call);\n\tnlm_release_file(block->b_file);\n\tkfree(block);\n}"
  },
  {
    "function_name": "nlmsvc_unlink_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "272-281",
    "snippet": "static int nlmsvc_unlink_block(struct nlm_block *block)\n{\n\tint status;\n\tdprintk(\"lockd: unlinking block %p...\\n\", block);\n\n\t/* Remove block from list */\n\tstatus = posix_unblock_lock(&block->b_call->a_args.lock.fl);\n\tnlmsvc_remove_block(block);\n\treturn status;\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nlmsvc_release_block(struct nlm_block *block);",
      "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
      "static void\tnlmsvc_remove_block(struct nlm_block *block);",
      "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsvc_remove_block",
          "args": [
            "block"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_remove_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "129-138",
          "snippet": "static inline void\nnlmsvc_remove_block(struct nlm_block *block)\n{\n\tif (!list_empty(&block->b_list)) {\n\t\tspin_lock(&nlm_blocked_lock);\n\t\tlist_del_init(&block->b_list);\n\t\tspin_unlock(&nlm_blocked_lock);\n\t\tnlmsvc_release_block(block);\n\t}\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);",
            "static DEFINE_SPINLOCK(nlm_blocked_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic DEFINE_SPINLOCK(nlm_blocked_lock);\n\nstatic inline void\nnlmsvc_remove_block(struct nlm_block *block)\n{\n\tif (!list_empty(&block->b_list)) {\n\t\tspin_lock(&nlm_blocked_lock);\n\t\tlist_del_init(&block->b_list);\n\t\tspin_unlock(&nlm_blocked_lock);\n\t\tnlmsvc_release_block(block);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_unblock_lock",
          "args": [
            "&block->b_call->a_args.lock.fl"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "posix_unblock_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "2460-2472",
          "snippet": "int\nposix_unblock_lock(struct file_lock *waiter)\n{\n\tint status = 0;\n\n\tspin_lock(&blocked_lock_lock);\n\tif (waiter->fl_next)\n\t\t__locks_delete_block(waiter);\n\telse\n\t\tstatus = -ENOENT;\n\tspin_unlock(&blocked_lock_lock);\n\treturn status;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nint\nposix_unblock_lock(struct file_lock *waiter)\n{\n\tint status = 0;\n\n\tspin_lock(&blocked_lock_lock);\n\tif (waiter->fl_next)\n\t\t__locks_delete_block(waiter);\n\telse\n\t\tstatus = -ENOENT;\n\tspin_unlock(&blocked_lock_lock);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: unlinking block %p...\\n\"",
            "block"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\n\nstatic int nlmsvc_unlink_block(struct nlm_block *block)\n{\n\tint status;\n\tdprintk(\"lockd: unlinking block %p...\\n\", block);\n\n\t/* Remove block from list */\n\tstatus = posix_unblock_lock(&block->b_call->a_args.lock.fl);\n\tnlmsvc_remove_block(block);\n\treturn status;\n}"
  },
  {
    "function_name": "nlmsvc_create_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "214-265",
    "snippet": "static struct nlm_block *\nnlmsvc_create_block(struct svc_rqst *rqstp, struct nlm_host *host,\n\t\t    struct nlm_file *file, struct nlm_lock *lock,\n\t\t    struct nlm_cookie *cookie)\n{\n\tstruct nlm_block\t*block;\n\tstruct nlm_rqst\t\t*call = NULL;\n\n\tcall = nlm_alloc_call(host);\n\tif (call == NULL)\n\t\treturn NULL;\n\n\t/* Allocate memory for block, and initialize arguments */\n\tblock = kzalloc(sizeof(*block), GFP_KERNEL);\n\tif (block == NULL)\n\t\tgoto failed;\n\tkref_init(&block->b_count);\n\tINIT_LIST_HEAD(&block->b_list);\n\tINIT_LIST_HEAD(&block->b_flist);\n\n\tif (!nlmsvc_setgrantargs(call, lock))\n\t\tgoto failed_free;\n\n\t/* Set notifier function for VFS, and init args */\n\tcall->a_args.lock.fl.fl_flags |= FL_SLEEP;\n\tcall->a_args.lock.fl.fl_lmops = &nlmsvc_lock_operations;\n\tnlmclnt_next_cookie(&call->a_args.cookie);\n\n\tdprintk(\"lockd: created block %p...\\n\", block);\n\n\t/* Create and initialize the block */\n\tblock->b_daemon = rqstp->rq_server;\n\tblock->b_host   = host;\n\tblock->b_file   = file;\n\tfile->f_count++;\n\n\t/* Add to file's list of blocks */\n\tlist_add(&block->b_flist, &file->f_blocks);\n\n\t/* Set up RPC arguments for callback */\n\tblock->b_call = call;\n\tcall->a_flags   = RPC_TASK_ASYNC;\n\tcall->a_block = block;\n\n\treturn block;\n\nfailed_free:\n\tkfree(block);\nfailed:\n\tnlmsvc_release_call(call);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nlmsvc_release_block(struct nlm_block *block);",
      "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
      "static void\tnlmsvc_remove_block(struct nlm_block *block);",
      "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);",
      "static void nlmsvc_freegrantargs(struct nlm_rqst *call);",
      "const struct lock_manager_operations nlmsvc_lock_operations = {\n\t.lm_compare_owner = nlmsvc_same_owner,\n\t.lm_owner_key = nlmsvc_owner_key,\n\t.lm_notify = nlmsvc_notify_blocked,\n\t.lm_grant = nlmsvc_grant_deferred,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsvc_release_call",
          "args": [
            "call"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_release_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svcproc.c",
          "lines": "264-270",
          "snippet": "void nlmsvc_release_call(struct nlm_rqst *call)\n{\n\tif (!atomic_dec_and_test(&call->a_count))\n\t\treturn;\n\tnlmsvc_release_host(call->a_host);\n\tkfree(call);\n}",
          "includes": [
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/time.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nvoid nlmsvc_release_call(struct nlm_rqst *call)\n{\n\tif (!atomic_dec_and_test(&call->a_count))\n\t\treturn;\n\tnlmsvc_release_host(call->a_host);\n\tkfree(call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "block"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&block->b_flist",
            "&file->f_blocks"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: created block %p...\\n\"",
            "block"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmclnt_next_cookie",
          "args": [
            "&call->a_args.cookie"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "nlmclnt_next_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "41-47",
          "snippet": "void nlmclnt_next_cookie(struct nlm_cookie *c)\n{\n\tu32\tcookie = atomic_inc_return(&nlm_cookie);\n\n\tmemcpy(c->data, &cookie, 4);\n\tc->len=4;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t\tnlm_cookie = ATOMIC_INIT(0x1234);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic atomic_t\tnlm_cookie = ATOMIC_INIT(0x1234);\n\nvoid nlmclnt_next_cookie(struct nlm_cookie *c)\n{\n\tu32\tcookie = atomic_inc_return(&nlm_cookie);\n\n\tmemcpy(c->data, &cookie, 4);\n\tc->len=4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_setgrantargs",
          "args": [
            "call",
            "lock"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_setgrantargs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "338-358",
          "snippet": "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock)\n{\n\tlocks_copy_lock(&call->a_args.lock.fl, &lock->fl);\n\tmemcpy(&call->a_args.lock.fh, &lock->fh, sizeof(call->a_args.lock.fh));\n\tcall->a_args.lock.caller = utsname()->nodename;\n\tcall->a_args.lock.oh.len = lock->oh.len;\n\n\t/* set default data area */\n\tcall->a_args.lock.oh.data = call->a_owner;\n\tcall->a_args.lock.svid = lock->fl.fl_pid;\n\n\tif (lock->oh.len > NLMCLNT_OHSIZE) {\n\t\tvoid *data = kmalloc(lock->oh.len, GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn 0;\n\t\tcall->a_args.lock.oh.data = (u8 *) data;\n\t}\n\n\tmemcpy(call->a_args.lock.oh.data, lock->oh.data, lock->oh.len);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);",
            "static void nlmsvc_freegrantargs(struct nlm_rqst *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\nstatic void nlmsvc_freegrantargs(struct nlm_rqst *call);\n\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock)\n{\n\tlocks_copy_lock(&call->a_args.lock.fl, &lock->fl);\n\tmemcpy(&call->a_args.lock.fh, &lock->fh, sizeof(call->a_args.lock.fh));\n\tcall->a_args.lock.caller = utsname()->nodename;\n\tcall->a_args.lock.oh.len = lock->oh.len;\n\n\t/* set default data area */\n\tcall->a_args.lock.oh.data = call->a_owner;\n\tcall->a_args.lock.svid = lock->fl.fl_pid;\n\n\tif (lock->oh.len > NLMCLNT_OHSIZE) {\n\t\tvoid *data = kmalloc(lock->oh.len, GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn 0;\n\t\tcall->a_args.lock.oh.data = (u8 *) data;\n\t}\n\n\tmemcpy(call->a_args.lock.oh.data, lock->oh.data, lock->oh.len);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&block->b_flist"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&block->b_list"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&block->b_count"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*block)",
            "GFP_KERNEL"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_alloc_call",
          "args": [
            "host"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_alloc_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntproc.c",
          "lines": "194-213",
          "snippet": "struct nlm_rqst *nlm_alloc_call(struct nlm_host *host)\n{\n\tstruct nlm_rqst\t*call;\n\n\tfor(;;) {\n\t\tcall = kzalloc(sizeof(*call), GFP_KERNEL);\n\t\tif (call != NULL) {\n\t\t\tatomic_set(&call->a_count, 1);\n\t\t\tlocks_init_lock(&call->a_args.lock.fl);\n\t\t\tlocks_init_lock(&call->a_res.lock.fl);\n\t\t\tcall->a_host = nlm_get_host(host);\n\t\t\treturn call;\n\t\t}\n\t\tif (signalled())\n\t\t\tbreak;\n\t\tprintk(\"nlm_alloc_call: failed, waiting for memory\\n\");\n\t\tschedule_timeout_interruptible(5*HZ);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void\tnlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host);\n\nstruct nlm_rqst *nlm_alloc_call(struct nlm_host *host)\n{\n\tstruct nlm_rqst\t*call;\n\n\tfor(;;) {\n\t\tcall = kzalloc(sizeof(*call), GFP_KERNEL);\n\t\tif (call != NULL) {\n\t\t\tatomic_set(&call->a_count, 1);\n\t\t\tlocks_init_lock(&call->a_args.lock.fl);\n\t\t\tlocks_init_lock(&call->a_res.lock.fl);\n\t\t\tcall->a_host = nlm_get_host(host);\n\t\t\treturn call;\n\t\t}\n\t\tif (signalled())\n\t\t\tbreak;\n\t\tprintk(\"nlm_alloc_call: failed, waiting for memory\\n\");\n\t\tschedule_timeout_interruptible(5*HZ);\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\nstatic void nlmsvc_freegrantargs(struct nlm_rqst *call);\nconst struct lock_manager_operations nlmsvc_lock_operations = {\n\t.lm_compare_owner = nlmsvc_same_owner,\n\t.lm_owner_key = nlmsvc_owner_key,\n\t.lm_notify = nlmsvc_notify_blocked,\n\t.lm_grant = nlmsvc_grant_deferred,\n};\n\nstatic struct nlm_block *\nnlmsvc_create_block(struct svc_rqst *rqstp, struct nlm_host *host,\n\t\t    struct nlm_file *file, struct nlm_lock *lock,\n\t\t    struct nlm_cookie *cookie)\n{\n\tstruct nlm_block\t*block;\n\tstruct nlm_rqst\t\t*call = NULL;\n\n\tcall = nlm_alloc_call(host);\n\tif (call == NULL)\n\t\treturn NULL;\n\n\t/* Allocate memory for block, and initialize arguments */\n\tblock = kzalloc(sizeof(*block), GFP_KERNEL);\n\tif (block == NULL)\n\t\tgoto failed;\n\tkref_init(&block->b_count);\n\tINIT_LIST_HEAD(&block->b_list);\n\tINIT_LIST_HEAD(&block->b_flist);\n\n\tif (!nlmsvc_setgrantargs(call, lock))\n\t\tgoto failed_free;\n\n\t/* Set notifier function for VFS, and init args */\n\tcall->a_args.lock.fl.fl_flags |= FL_SLEEP;\n\tcall->a_args.lock.fl.fl_lmops = &nlmsvc_lock_operations;\n\tnlmclnt_next_cookie(&call->a_args.cookie);\n\n\tdprintk(\"lockd: created block %p...\\n\", block);\n\n\t/* Create and initialize the block */\n\tblock->b_daemon = rqstp->rq_server;\n\tblock->b_host   = host;\n\tblock->b_file   = file;\n\tfile->f_count++;\n\n\t/* Add to file's list of blocks */\n\tlist_add(&block->b_flist, &file->f_blocks);\n\n\t/* Set up RPC arguments for callback */\n\tblock->b_call = call;\n\tcall->a_flags   = RPC_TASK_ASYNC;\n\tcall->a_block = block;\n\n\treturn block;\n\nfailed_free:\n\tkfree(block);\nfailed:\n\tnlmsvc_release_call(call);\n\treturn NULL;\n}"
  },
  {
    "function_name": "nlmsvc_find_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "181-197",
    "snippet": "static inline struct nlm_block *\nnlmsvc_find_block(struct nlm_cookie *cookie)\n{\n\tstruct nlm_block *block;\n\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tif (nlm_cookie_match(&block->b_call->a_args.cookie,cookie))\n\t\t\tgoto found;\n\t}\n\n\treturn NULL;\n\nfound:\n\tdprintk(\"nlmsvc_find_block(%s): block=%p\\n\", nlmdbg_cookie2a(cookie), block);\n\tkref_get(&block->b_count);\n\treturn block;\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nlmsvc_release_block(struct nlm_block *block);",
      "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
      "static void\tnlmsvc_remove_block(struct nlm_block *block);",
      "static LIST_HEAD(nlm_blocked);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&block->b_count"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nlmsvc_find_block(%s): block=%p\\n\"",
            "nlmdbg_cookie2a(cookie)",
            "block"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmdbg_cookie2a",
          "args": [
            "cookie"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "nlmdbg_cookie2a",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "57-82",
          "snippet": "static const char *nlmdbg_cookie2a(const struct nlm_cookie *cookie)\n{\n\t/*\n\t * We can get away with a static buffer because this is only called\n\t * from lockd, which is single-threaded.\n\t */\n\tstatic char buf[2*NLM_MAXCOOKIELEN+1];\n\tunsigned int i, len = sizeof(buf);\n\tchar *p = buf;\n\n\tlen--;\t/* allow for trailing \\0 */\n\tif (len < 3)\n\t\treturn \"???\";\n\tfor (i = 0 ; i < cookie->len ; i++) {\n\t\tif (len < 2) {\n\t\t\tstrcpy(p-3, \"...\");\n\t\t\tbreak;\n\t\t}\n\t\tsprintf(p, \"%02x\", cookie->data[i]);\n\t\tp += 2;\n\t\tlen -= 2;\n\t}\n\t*p = '\\0';\n\n\treturn buf;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic const char *nlmdbg_cookie2a(const struct nlm_cookie *cookie)\n{\n\t/*\n\t * We can get away with a static buffer because this is only called\n\t * from lockd, which is single-threaded.\n\t */\n\tstatic char buf[2*NLM_MAXCOOKIELEN+1];\n\tunsigned int i, len = sizeof(buf);\n\tchar *p = buf;\n\n\tlen--;\t/* allow for trailing \\0 */\n\tif (len < 3)\n\t\treturn \"???\";\n\tfor (i = 0 ; i < cookie->len ; i++) {\n\t\tif (len < 2) {\n\t\t\tstrcpy(p-3, \"...\");\n\t\t\tbreak;\n\t\t}\n\t\tsprintf(p, \"%02x\", cookie->data[i]);\n\t\tp += 2;\n\t\tlen -= 2;\n\t}\n\t*p = '\\0';\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlm_cookie_match",
          "args": [
            "&block->b_call->a_args.cookie",
            "cookie"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_cookie_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "169-176",
          "snippet": "static inline int nlm_cookie_match(struct nlm_cookie *a, struct nlm_cookie *b)\n{\n\tif (a->len != b->len)\n\t\treturn 0;\n\tif (memcmp(a->data, b->data, a->len))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline int nlm_cookie_match(struct nlm_cookie *a, struct nlm_cookie *b)\n{\n\tif (a->len != b->len)\n\t\treturn 0;\n\tif (memcmp(a->data, b->data, a->len))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "block",
            "&nlm_blocked",
            "b_list"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic LIST_HEAD(nlm_blocked);\n\nstatic inline struct nlm_block *\nnlmsvc_find_block(struct nlm_cookie *cookie)\n{\n\tstruct nlm_block *block;\n\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tif (nlm_cookie_match(&block->b_call->a_args.cookie,cookie))\n\t\t\tgoto found;\n\t}\n\n\treturn NULL;\n\nfound:\n\tdprintk(\"nlmsvc_find_block(%s): block=%p\\n\", nlmdbg_cookie2a(cookie), block);\n\tkref_get(&block->b_count);\n\treturn block;\n}"
  },
  {
    "function_name": "nlm_cookie_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "169-176",
    "snippet": "static inline int nlm_cookie_match(struct nlm_cookie *a, struct nlm_cookie *b)\n{\n\tif (a->len != b->len)\n\t\treturn 0;\n\tif (memcmp(a->data, b->data, a->len))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "a->data",
            "b->data",
            "a->len"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline int nlm_cookie_match(struct nlm_cookie *a, struct nlm_cookie *b)\n{\n\tif (a->len != b->len)\n\t\treturn 0;\n\tif (memcmp(a->data, b->data, a->len))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "nlmsvc_lookup_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "143-167",
    "snippet": "static struct nlm_block *\nnlmsvc_lookup_block(struct nlm_file *file, struct nlm_lock *lock)\n{\n\tstruct nlm_block\t*block;\n\tstruct file_lock\t*fl;\n\n\tdprintk(\"lockd: nlmsvc_lookup_block f=%p pd=%d %Ld-%Ld ty=%d\\n\",\n\t\t\t\tfile, lock->fl.fl_pid,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end, lock->fl.fl_type);\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tfl = &block->b_call->a_args.lock.fl;\n\t\tdprintk(\"lockd: check f=%p pd=%d %Ld-%Ld ty=%d cookie=%s\\n\",\n\t\t\t\tblock->b_file, fl->fl_pid,\n\t\t\t\t(long long)fl->fl_start,\n\t\t\t\t(long long)fl->fl_end, fl->fl_type,\n\t\t\t\tnlmdbg_cookie2a(&block->b_call->a_args.cookie));\n\t\tif (block->b_file == file && nlm_compare_locks(fl, &lock->fl)) {\n\t\t\tkref_get(&block->b_count);\n\t\t\treturn block;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nlmsvc_release_block(struct nlm_block *block);",
      "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
      "static void\tnlmsvc_remove_block(struct nlm_block *block);",
      "static int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);",
      "static LIST_HEAD(nlm_blocked);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&block->b_count"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_compare_locks",
          "args": [
            "fl",
            "&lock->fl"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: check f=%p pd=%d %Ld-%Ld ty=%d cookie=%s\\n\"",
            "block->b_file",
            "fl->fl_pid",
            "(long long)fl->fl_start",
            "(long long)fl->fl_end",
            "fl->fl_type",
            "nlmdbg_cookie2a(&block->b_call->a_args.cookie)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmdbg_cookie2a",
          "args": [
            "&block->b_call->a_args.cookie"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "nlmdbg_cookie2a",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "57-82",
          "snippet": "static const char *nlmdbg_cookie2a(const struct nlm_cookie *cookie)\n{\n\t/*\n\t * We can get away with a static buffer because this is only called\n\t * from lockd, which is single-threaded.\n\t */\n\tstatic char buf[2*NLM_MAXCOOKIELEN+1];\n\tunsigned int i, len = sizeof(buf);\n\tchar *p = buf;\n\n\tlen--;\t/* allow for trailing \\0 */\n\tif (len < 3)\n\t\treturn \"???\";\n\tfor (i = 0 ; i < cookie->len ; i++) {\n\t\tif (len < 2) {\n\t\t\tstrcpy(p-3, \"...\");\n\t\t\tbreak;\n\t\t}\n\t\tsprintf(p, \"%02x\", cookie->data[i]);\n\t\tp += 2;\n\t\tlen -= 2;\n\t}\n\t*p = '\\0';\n\n\treturn buf;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic const char *nlmdbg_cookie2a(const struct nlm_cookie *cookie)\n{\n\t/*\n\t * We can get away with a static buffer because this is only called\n\t * from lockd, which is single-threaded.\n\t */\n\tstatic char buf[2*NLM_MAXCOOKIELEN+1];\n\tunsigned int i, len = sizeof(buf);\n\tchar *p = buf;\n\n\tlen--;\t/* allow for trailing \\0 */\n\tif (len < 3)\n\t\treturn \"???\";\n\tfor (i = 0 ; i < cookie->len ; i++) {\n\t\tif (len < 2) {\n\t\t\tstrcpy(p-3, \"...\");\n\t\t\tbreak;\n\t\t}\n\t\tsprintf(p, \"%02x\", cookie->data[i]);\n\t\tp += 2;\n\t\tlen -= 2;\n\t}\n\t*p = '\\0';\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "block",
            "&nlm_blocked",
            "b_list"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: nlmsvc_lookup_block f=%p pd=%d %Ld-%Ld ty=%d\\n\"",
            "file",
            "lock->fl.fl_pid",
            "(long long)lock->fl.fl_start",
            "(long long)lock->fl.fl_end",
            "lock->fl.fl_type"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic int nlmsvc_setgrantargs(struct nlm_rqst *call, struct nlm_lock *lock);\nstatic LIST_HEAD(nlm_blocked);\n\nstatic struct nlm_block *\nnlmsvc_lookup_block(struct nlm_file *file, struct nlm_lock *lock)\n{\n\tstruct nlm_block\t*block;\n\tstruct file_lock\t*fl;\n\n\tdprintk(\"lockd: nlmsvc_lookup_block f=%p pd=%d %Ld-%Ld ty=%d\\n\",\n\t\t\t\tfile, lock->fl.fl_pid,\n\t\t\t\t(long long)lock->fl.fl_start,\n\t\t\t\t(long long)lock->fl.fl_end, lock->fl.fl_type);\n\tlist_for_each_entry(block, &nlm_blocked, b_list) {\n\t\tfl = &block->b_call->a_args.lock.fl;\n\t\tdprintk(\"lockd: check f=%p pd=%d %Ld-%Ld ty=%d cookie=%s\\n\",\n\t\t\t\tblock->b_file, fl->fl_pid,\n\t\t\t\t(long long)fl->fl_start,\n\t\t\t\t(long long)fl->fl_end, fl->fl_type,\n\t\t\t\tnlmdbg_cookie2a(&block->b_call->a_args.cookie));\n\t\tif (block->b_file == file && nlm_compare_locks(fl, &lock->fl)) {\n\t\t\tkref_get(&block->b_count);\n\t\t\treturn block;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "nlmsvc_remove_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "129-138",
    "snippet": "static inline void\nnlmsvc_remove_block(struct nlm_block *block)\n{\n\tif (!list_empty(&block->b_list)) {\n\t\tspin_lock(&nlm_blocked_lock);\n\t\tlist_del_init(&block->b_list);\n\t\tspin_unlock(&nlm_blocked_lock);\n\t\tnlmsvc_release_block(block);\n\t}\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nlmsvc_release_block(struct nlm_block *block);",
      "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
      "static void\tnlmsvc_remove_block(struct nlm_block *block);",
      "static DEFINE_SPINLOCK(nlm_blocked_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsvc_release_block",
          "args": [
            "block"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_release_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "300-304",
          "snippet": "static void nlmsvc_release_block(struct nlm_block *block)\n{\n\tif (block != NULL)\n\t\tkref_put_mutex(&block->b_count, nlmsvc_free_block, &block->b_file->f_mutex);\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\n\nstatic void nlmsvc_release_block(struct nlm_block *block)\n{\n\tif (block != NULL)\n\t\tkref_put_mutex(&block->b_count, nlmsvc_free_block, &block->b_file->f_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nlm_blocked_lock"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&block->b_list"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nlm_blocked_lock"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&block->b_list"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic DEFINE_SPINLOCK(nlm_blocked_lock);\n\nstatic inline void\nnlmsvc_remove_block(struct nlm_block *block)\n{\n\tif (!list_empty(&block->b_list)) {\n\t\tspin_lock(&nlm_blocked_lock);\n\t\tlist_del_init(&block->b_list);\n\t\tspin_unlock(&nlm_blocked_lock);\n\t\tnlmsvc_release_block(block);\n\t}\n}"
  },
  {
    "function_name": "nlmsvc_insert_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "119-124",
    "snippet": "static void nlmsvc_insert_block(struct nlm_block *block, unsigned long when)\n{\n\tspin_lock(&nlm_blocked_lock);\n\tnlmsvc_insert_block_locked(block, when);\n\tspin_unlock(&nlm_blocked_lock);\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nlmsvc_release_block(struct nlm_block *block);",
      "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
      "static void\tnlmsvc_remove_block(struct nlm_block *block);",
      "static DEFINE_SPINLOCK(nlm_blocked_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nlm_blocked_lock"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsvc_insert_block_locked",
          "args": [
            "block",
            "when"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "nlmsvc_insert_block_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
          "lines": "88-117",
          "snippet": "static void\nnlmsvc_insert_block_locked(struct nlm_block *block, unsigned long when)\n{\n\tstruct nlm_block *b;\n\tstruct list_head *pos;\n\n\tdprintk(\"lockd: nlmsvc_insert_block(%p, %ld)\\n\", block, when);\n\tif (list_empty(&block->b_list)) {\n\t\tkref_get(&block->b_count);\n\t} else {\n\t\tlist_del_init(&block->b_list);\n\t}\n\n\tpos = &nlm_blocked;\n\tif (when != NLM_NEVER) {\n\t\tif ((when += jiffies) == NLM_NEVER)\n\t\t\twhen ++;\n\t\tlist_for_each(pos, &nlm_blocked) {\n\t\t\tb = list_entry(pos, struct nlm_block, b_list);\n\t\t\tif (time_after(b->b_when,when) || b->b_when == NLM_NEVER)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* On normal exit from the loop, pos == &nlm_blocked,\n\t\t * so we will be adding to the end of the list - good\n\t\t */\n\t}\n\n\tlist_add_tail(&block->b_list, pos);\n\tblock->b_when = when;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/lockd/nlm.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nlmsvc_release_block(struct nlm_block *block);",
            "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
            "static void\tnlmsvc_remove_block(struct nlm_block *block);",
            "static LIST_HEAD(nlm_blocked);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic LIST_HEAD(nlm_blocked);\n\nstatic void\nnlmsvc_insert_block_locked(struct nlm_block *block, unsigned long when)\n{\n\tstruct nlm_block *b;\n\tstruct list_head *pos;\n\n\tdprintk(\"lockd: nlmsvc_insert_block(%p, %ld)\\n\", block, when);\n\tif (list_empty(&block->b_list)) {\n\t\tkref_get(&block->b_count);\n\t} else {\n\t\tlist_del_init(&block->b_list);\n\t}\n\n\tpos = &nlm_blocked;\n\tif (when != NLM_NEVER) {\n\t\tif ((when += jiffies) == NLM_NEVER)\n\t\t\twhen ++;\n\t\tlist_for_each(pos, &nlm_blocked) {\n\t\t\tb = list_entry(pos, struct nlm_block, b_list);\n\t\t\tif (time_after(b->b_when,when) || b->b_when == NLM_NEVER)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* On normal exit from the loop, pos == &nlm_blocked,\n\t\t * so we will be adding to the end of the list - good\n\t\t */\n\t}\n\n\tlist_add_tail(&block->b_list, pos);\n\tblock->b_when = when;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nlm_blocked_lock"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic DEFINE_SPINLOCK(nlm_blocked_lock);\n\nstatic void nlmsvc_insert_block(struct nlm_block *block, unsigned long when)\n{\n\tspin_lock(&nlm_blocked_lock);\n\tnlmsvc_insert_block_locked(block, when);\n\tspin_unlock(&nlm_blocked_lock);\n}"
  },
  {
    "function_name": "nlmsvc_insert_block_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "88-117",
    "snippet": "static void\nnlmsvc_insert_block_locked(struct nlm_block *block, unsigned long when)\n{\n\tstruct nlm_block *b;\n\tstruct list_head *pos;\n\n\tdprintk(\"lockd: nlmsvc_insert_block(%p, %ld)\\n\", block, when);\n\tif (list_empty(&block->b_list)) {\n\t\tkref_get(&block->b_count);\n\t} else {\n\t\tlist_del_init(&block->b_list);\n\t}\n\n\tpos = &nlm_blocked;\n\tif (when != NLM_NEVER) {\n\t\tif ((when += jiffies) == NLM_NEVER)\n\t\t\twhen ++;\n\t\tlist_for_each(pos, &nlm_blocked) {\n\t\t\tb = list_entry(pos, struct nlm_block, b_list);\n\t\t\tif (time_after(b->b_when,when) || b->b_when == NLM_NEVER)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* On normal exit from the loop, pos == &nlm_blocked,\n\t\t * so we will be adding to the end of the list - good\n\t\t */\n\t}\n\n\tlist_add_tail(&block->b_list, pos);\n\tblock->b_when = when;\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nlmsvc_release_block(struct nlm_block *block);",
      "static void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);",
      "static void\tnlmsvc_remove_block(struct nlm_block *block);",
      "static LIST_HEAD(nlm_blocked);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&block->b_list",
            "pos"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "b->b_when",
            "when"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structnlm_block",
            "b_list"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "pos",
            "&nlm_blocked"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&block->b_list"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&block->b_count"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&block->b_list"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: nlmsvc_insert_block(%p, %ld)\\n\"",
            "block",
            "when"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nlmsvc_release_block(struct nlm_block *block);\nstatic void\tnlmsvc_insert_block(struct nlm_block *block, unsigned long);\nstatic void\tnlmsvc_remove_block(struct nlm_block *block);\nstatic LIST_HEAD(nlm_blocked);\n\nstatic void\nnlmsvc_insert_block_locked(struct nlm_block *block, unsigned long when)\n{\n\tstruct nlm_block *b;\n\tstruct list_head *pos;\n\n\tdprintk(\"lockd: nlmsvc_insert_block(%p, %ld)\\n\", block, when);\n\tif (list_empty(&block->b_list)) {\n\t\tkref_get(&block->b_count);\n\t} else {\n\t\tlist_del_init(&block->b_list);\n\t}\n\n\tpos = &nlm_blocked;\n\tif (when != NLM_NEVER) {\n\t\tif ((when += jiffies) == NLM_NEVER)\n\t\t\twhen ++;\n\t\tlist_for_each(pos, &nlm_blocked) {\n\t\t\tb = list_entry(pos, struct nlm_block, b_list);\n\t\t\tif (time_after(b->b_when,when) || b->b_when == NLM_NEVER)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* On normal exit from the loop, pos == &nlm_blocked,\n\t\t * so we will be adding to the end of the list - good\n\t\t */\n\t}\n\n\tlist_add_tail(&block->b_list, pos);\n\tblock->b_when = when;\n}"
  },
  {
    "function_name": "nlmdbg_cookie2a",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svclock.c",
    "lines": "57-82",
    "snippet": "static const char *nlmdbg_cookie2a(const struct nlm_cookie *cookie)\n{\n\t/*\n\t * We can get away with a static buffer because this is only called\n\t * from lockd, which is single-threaded.\n\t */\n\tstatic char buf[2*NLM_MAXCOOKIELEN+1];\n\tunsigned int i, len = sizeof(buf);\n\tchar *p = buf;\n\n\tlen--;\t/* allow for trailing \\0 */\n\tif (len < 3)\n\t\treturn \"???\";\n\tfor (i = 0 ; i < cookie->len ; i++) {\n\t\tif (len < 2) {\n\t\t\tstrcpy(p-3, \"...\");\n\t\t\tbreak;\n\t\t}\n\t\tsprintf(p, \"%02x\", cookie->data[i]);\n\t\tp += 2;\n\t\tlen -= 2;\n\t}\n\t*p = '\\0';\n\n\treturn buf;\n}",
    "includes": [
      "#include <linux/kthread.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/lockd/nlm.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "p",
            "\"%02x\"",
            "cookie->data[i]"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "p-3",
            "\"...\""
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/lockd/lockd.h>\n#include <linux/lockd/nlm.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic const char *nlmdbg_cookie2a(const struct nlm_cookie *cookie)\n{\n\t/*\n\t * We can get away with a static buffer because this is only called\n\t * from lockd, which is single-threaded.\n\t */\n\tstatic char buf[2*NLM_MAXCOOKIELEN+1];\n\tunsigned int i, len = sizeof(buf);\n\tchar *p = buf;\n\n\tlen--;\t/* allow for trailing \\0 */\n\tif (len < 3)\n\t\treturn \"???\";\n\tfor (i = 0 ; i < cookie->len ; i++) {\n\t\tif (len < 2) {\n\t\t\tstrcpy(p-3, \"...\");\n\t\t\tbreak;\n\t\t}\n\t\tsprintf(p, \"%02x\", cookie->data[i]);\n\t\tp += 2;\n\t\tlen -= 2;\n\t}\n\t*p = '\\0';\n\n\treturn buf;\n}"
  }
]