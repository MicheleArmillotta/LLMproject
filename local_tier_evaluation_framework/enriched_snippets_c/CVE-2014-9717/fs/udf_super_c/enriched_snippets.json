[
  {
    "function_name": "udf_count_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "2426-2470",
    "snippet": "static unsigned int udf_count_free(struct super_block *sb)\n{\n\tunsigned int accum = 0;\n\tstruct udf_sb_info *sbi;\n\tstruct udf_part_map *map;\n\n\tsbi = UDF_SB(sb);\n\tif (sbi->s_lvid_bh) {\n\t\tstruct logicalVolIntegrityDesc *lvid =\n\t\t\t(struct logicalVolIntegrityDesc *)\n\t\t\tsbi->s_lvid_bh->b_data;\n\t\tif (le32_to_cpu(lvid->numOfPartitions) > sbi->s_partition) {\n\t\t\taccum = le32_to_cpu(\n\t\t\t\t\tlvid->freeSpaceTable[sbi->s_partition]);\n\t\t\tif (accum == 0xFFFFFFFF)\n\t\t\t\taccum = 0;\n\t\t}\n\t}\n\n\tif (accum)\n\t\treturn accum;\n\n\tmap = &sbi->s_partmaps[sbi->s_partition];\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP) {\n\t\taccum += udf_count_free_bitmap(sb,\n\t\t\t\t\t       map->s_uspace.s_bitmap);\n\t}\n\tif (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP) {\n\t\taccum += udf_count_free_bitmap(sb,\n\t\t\t\t\t       map->s_fspace.s_bitmap);\n\t}\n\tif (accum)\n\t\treturn accum;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE) {\n\t\taccum += udf_count_free_table(sb,\n\t\t\t\t\t      map->s_uspace.s_table);\n\t}\n\tif (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE) {\n\t\taccum += udf_count_free_table(sb,\n\t\t\t\t\t      map->s_fspace.s_table);\n\t}\n\n\treturn accum;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_count_free_table",
          "args": [
            "sb",
            "map->s_fspace.s_table"
          ],
          "line": 2465
        },
        "resolved": true,
        "details": {
          "function_name": "udf_count_free_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "2403-2424",
          "snippet": "static unsigned int udf_count_free_table(struct super_block *sb,\n\t\t\t\t\t struct inode *table)\n{\n\tunsigned int accum = 0;\n\tuint32_t elen;\n\tstruct kernel_lb_addr eloc;\n\tint8_t etype;\n\tstruct extent_position epos;\n\n\tmutex_lock(&UDF_SB(sb)->s_alloc_mutex);\n\tepos.block = UDF_I(table)->i_location;\n\tepos.offset = sizeof(struct unallocSpaceEntry);\n\tepos.bh = NULL;\n\n\twhile ((etype = udf_next_aext(table, &epos, &eloc, &elen, 1)) != -1)\n\t\taccum += (elen >> table->i_sb->s_blocksize_bits);\n\n\tbrelse(epos.bh);\n\tmutex_unlock(&UDF_SB(sb)->s_alloc_mutex);\n\n\treturn accum;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
            "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic unsigned int udf_count_free_table(struct super_block *sb,\n\t\t\t\t\t struct inode *table)\n{\n\tunsigned int accum = 0;\n\tuint32_t elen;\n\tstruct kernel_lb_addr eloc;\n\tint8_t etype;\n\tstruct extent_position epos;\n\n\tmutex_lock(&UDF_SB(sb)->s_alloc_mutex);\n\tepos.block = UDF_I(table)->i_location;\n\tepos.offset = sizeof(struct unallocSpaceEntry);\n\tepos.bh = NULL;\n\n\twhile ((etype = udf_next_aext(table, &epos, &eloc, &elen, 1)) != -1)\n\t\taccum += (elen >> table->i_sb->s_blocksize_bits);\n\n\tbrelse(epos.bh);\n\tmutex_unlock(&UDF_SB(sb)->s_alloc_mutex);\n\n\treturn accum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_count_free_bitmap",
          "args": [
            "sb",
            "map->s_fspace.s_bitmap"
          ],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "udf_count_free_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "2350-2401",
          "snippet": "static unsigned int udf_count_free_bitmap(struct super_block *sb,\n\t\t\t\t\t  struct udf_bitmap *bitmap)\n{\n\tstruct buffer_head *bh = NULL;\n\tunsigned int accum = 0;\n\tint index;\n\tint block = 0, newblock;\n\tstruct kernel_lb_addr loc;\n\tuint32_t bytes;\n\tuint8_t *ptr;\n\tuint16_t ident;\n\tstruct spaceBitmapDesc *bm;\n\n\tloc.logicalBlockNum = bitmap->s_extPosition;\n\tloc.partitionReferenceNum = UDF_SB(sb)->s_partition;\n\tbh = udf_read_ptagged(sb, &loc, 0, &ident);\n\n\tif (!bh) {\n\t\tudf_err(sb, \"udf_count_free failed\\n\");\n\t\tgoto out;\n\t} else if (ident != TAG_IDENT_SBD) {\n\t\tbrelse(bh);\n\t\tudf_err(sb, \"udf_count_free failed\\n\");\n\t\tgoto out;\n\t}\n\n\tbm = (struct spaceBitmapDesc *)bh->b_data;\n\tbytes = le32_to_cpu(bm->numOfBytes);\n\tindex = sizeof(struct spaceBitmapDesc); /* offset in first block only */\n\tptr = (uint8_t *)bh->b_data;\n\n\twhile (bytes > 0) {\n\t\tu32 cur_bytes = min_t(u32, bytes, sb->s_blocksize - index);\n\t\taccum += bitmap_weight((const unsigned long *)(ptr + index),\n\t\t\t\t\tcur_bytes * 8);\n\t\tbytes -= cur_bytes;\n\t\tif (bytes) {\n\t\t\tbrelse(bh);\n\t\t\tnewblock = udf_get_lb_pblock(sb, &loc, ++block);\n\t\t\tbh = udf_tread(sb, newblock);\n\t\t\tif (!bh) {\n\t\t\t\tudf_debug(\"read failed\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tindex = 0;\n\t\t\tptr = (uint8_t *)bh->b_data;\n\t\t}\n\t}\n\tbrelse(bh);\nout:\n\treturn accum;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
            "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic unsigned int udf_count_free_bitmap(struct super_block *sb,\n\t\t\t\t\t  struct udf_bitmap *bitmap)\n{\n\tstruct buffer_head *bh = NULL;\n\tunsigned int accum = 0;\n\tint index;\n\tint block = 0, newblock;\n\tstruct kernel_lb_addr loc;\n\tuint32_t bytes;\n\tuint8_t *ptr;\n\tuint16_t ident;\n\tstruct spaceBitmapDesc *bm;\n\n\tloc.logicalBlockNum = bitmap->s_extPosition;\n\tloc.partitionReferenceNum = UDF_SB(sb)->s_partition;\n\tbh = udf_read_ptagged(sb, &loc, 0, &ident);\n\n\tif (!bh) {\n\t\tudf_err(sb, \"udf_count_free failed\\n\");\n\t\tgoto out;\n\t} else if (ident != TAG_IDENT_SBD) {\n\t\tbrelse(bh);\n\t\tudf_err(sb, \"udf_count_free failed\\n\");\n\t\tgoto out;\n\t}\n\n\tbm = (struct spaceBitmapDesc *)bh->b_data;\n\tbytes = le32_to_cpu(bm->numOfBytes);\n\tindex = sizeof(struct spaceBitmapDesc); /* offset in first block only */\n\tptr = (uint8_t *)bh->b_data;\n\n\twhile (bytes > 0) {\n\t\tu32 cur_bytes = min_t(u32, bytes, sb->s_blocksize - index);\n\t\taccum += bitmap_weight((const unsigned long *)(ptr + index),\n\t\t\t\t\tcur_bytes * 8);\n\t\tbytes -= cur_bytes;\n\t\tif (bytes) {\n\t\t\tbrelse(bh);\n\t\t\tnewblock = udf_get_lb_pblock(sb, &loc, ++block);\n\t\t\tbh = udf_tread(sb, newblock);\n\t\t\tif (!bh) {\n\t\t\t\tudf_debug(\"read failed\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tindex = 0;\n\t\t\tptr = (uint8_t *)bh->b_data;\n\t\t}\n\t}\n\tbrelse(bh);\nout:\n\treturn accum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "lvid->freeSpaceTable[sbi->s_partition]"
          ],
          "line": 2438
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic unsigned int udf_count_free(struct super_block *sb)\n{\n\tunsigned int accum = 0;\n\tstruct udf_sb_info *sbi;\n\tstruct udf_part_map *map;\n\n\tsbi = UDF_SB(sb);\n\tif (sbi->s_lvid_bh) {\n\t\tstruct logicalVolIntegrityDesc *lvid =\n\t\t\t(struct logicalVolIntegrityDesc *)\n\t\t\tsbi->s_lvid_bh->b_data;\n\t\tif (le32_to_cpu(lvid->numOfPartitions) > sbi->s_partition) {\n\t\t\taccum = le32_to_cpu(\n\t\t\t\t\tlvid->freeSpaceTable[sbi->s_partition]);\n\t\t\tif (accum == 0xFFFFFFFF)\n\t\t\t\taccum = 0;\n\t\t}\n\t}\n\n\tif (accum)\n\t\treturn accum;\n\n\tmap = &sbi->s_partmaps[sbi->s_partition];\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP) {\n\t\taccum += udf_count_free_bitmap(sb,\n\t\t\t\t\t       map->s_uspace.s_bitmap);\n\t}\n\tif (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP) {\n\t\taccum += udf_count_free_bitmap(sb,\n\t\t\t\t\t       map->s_fspace.s_bitmap);\n\t}\n\tif (accum)\n\t\treturn accum;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE) {\n\t\taccum += udf_count_free_table(sb,\n\t\t\t\t\t      map->s_uspace.s_table);\n\t}\n\tif (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE) {\n\t\taccum += udf_count_free_table(sb,\n\t\t\t\t\t      map->s_fspace.s_table);\n\t}\n\n\treturn accum;\n}"
  },
  {
    "function_name": "udf_count_free_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "2403-2424",
    "snippet": "static unsigned int udf_count_free_table(struct super_block *sb,\n\t\t\t\t\t struct inode *table)\n{\n\tunsigned int accum = 0;\n\tuint32_t elen;\n\tstruct kernel_lb_addr eloc;\n\tint8_t etype;\n\tstruct extent_position epos;\n\n\tmutex_lock(&UDF_SB(sb)->s_alloc_mutex);\n\tepos.block = UDF_I(table)->i_location;\n\tepos.offset = sizeof(struct unallocSpaceEntry);\n\tepos.bh = NULL;\n\n\twhile ((etype = udf_next_aext(table, &epos, &eloc, &elen, 1)) != -1)\n\t\taccum += (elen >> table->i_sb->s_blocksize_bits);\n\n\tbrelse(epos.bh);\n\tmutex_unlock(&UDF_SB(sb)->s_alloc_mutex);\n\n\treturn accum;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
      "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&UDF_SB(sb)->s_alloc_mutex"
          ],
          "line": 2421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 2421
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "epos.bh"
          ],
          "line": 2420
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_next_aext",
          "args": [
            "table",
            "&epos",
            "&eloc",
            "&elen",
            "1"
          ],
          "line": 2417
        },
        "resolved": true,
        "details": {
          "function_name": "udf_next_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2057-2077",
          "snippet": "int8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "table"
          ],
          "line": 2413
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&UDF_SB(sb)->s_alloc_mutex"
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic unsigned int udf_count_free_table(struct super_block *sb,\n\t\t\t\t\t struct inode *table)\n{\n\tunsigned int accum = 0;\n\tuint32_t elen;\n\tstruct kernel_lb_addr eloc;\n\tint8_t etype;\n\tstruct extent_position epos;\n\n\tmutex_lock(&UDF_SB(sb)->s_alloc_mutex);\n\tepos.block = UDF_I(table)->i_location;\n\tepos.offset = sizeof(struct unallocSpaceEntry);\n\tepos.bh = NULL;\n\n\twhile ((etype = udf_next_aext(table, &epos, &eloc, &elen, 1)) != -1)\n\t\taccum += (elen >> table->i_sb->s_blocksize_bits);\n\n\tbrelse(epos.bh);\n\tmutex_unlock(&UDF_SB(sb)->s_alloc_mutex);\n\n\treturn accum;\n}"
  },
  {
    "function_name": "udf_count_free_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "2350-2401",
    "snippet": "static unsigned int udf_count_free_bitmap(struct super_block *sb,\n\t\t\t\t\t  struct udf_bitmap *bitmap)\n{\n\tstruct buffer_head *bh = NULL;\n\tunsigned int accum = 0;\n\tint index;\n\tint block = 0, newblock;\n\tstruct kernel_lb_addr loc;\n\tuint32_t bytes;\n\tuint8_t *ptr;\n\tuint16_t ident;\n\tstruct spaceBitmapDesc *bm;\n\n\tloc.logicalBlockNum = bitmap->s_extPosition;\n\tloc.partitionReferenceNum = UDF_SB(sb)->s_partition;\n\tbh = udf_read_ptagged(sb, &loc, 0, &ident);\n\n\tif (!bh) {\n\t\tudf_err(sb, \"udf_count_free failed\\n\");\n\t\tgoto out;\n\t} else if (ident != TAG_IDENT_SBD) {\n\t\tbrelse(bh);\n\t\tudf_err(sb, \"udf_count_free failed\\n\");\n\t\tgoto out;\n\t}\n\n\tbm = (struct spaceBitmapDesc *)bh->b_data;\n\tbytes = le32_to_cpu(bm->numOfBytes);\n\tindex = sizeof(struct spaceBitmapDesc); /* offset in first block only */\n\tptr = (uint8_t *)bh->b_data;\n\n\twhile (bytes > 0) {\n\t\tu32 cur_bytes = min_t(u32, bytes, sb->s_blocksize - index);\n\t\taccum += bitmap_weight((const unsigned long *)(ptr + index),\n\t\t\t\t\tcur_bytes * 8);\n\t\tbytes -= cur_bytes;\n\t\tif (bytes) {\n\t\t\tbrelse(bh);\n\t\t\tnewblock = udf_get_lb_pblock(sb, &loc, ++block);\n\t\t\tbh = udf_tread(sb, newblock);\n\t\t\tif (!bh) {\n\t\t\t\tudf_debug(\"read failed\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tindex = 0;\n\t\t\tptr = (uint8_t *)bh->b_data;\n\t\t}\n\t}\n\tbrelse(bh);\nout:\n\treturn accum;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
      "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 2398
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"read failed\\n\""
          ],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_tread",
          "args": [
            "sb",
            "newblock"
          ],
          "line": 2389
        },
        "resolved": true,
        "details": {
          "function_name": "udf_tread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "40-46",
          "snippet": "struct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_lb_pblock",
          "args": [
            "sb",
            "&loc",
            "++block"
          ],
          "line": 2388
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_lb_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "205-211",
          "snippet": "static inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_weight",
          "args": [
            "(const unsigned long *)(ptr + index)",
            "cur_bytes * 8"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "bytes",
            "sb->s_blocksize - index"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "bm->numOfBytes"
          ],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_err",
          "args": [
            "sb",
            "\"udf_count_free failed\\n\""
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_err",
          "args": [
            "sb",
            "\"udf_count_free failed\\n\""
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_read_ptagged",
          "args": [
            "sb",
            "&loc",
            "0",
            "&ident"
          ],
          "line": 2365
        },
        "resolved": true,
        "details": {
          "function_name": "udf_read_ptagged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "261-267",
          "snippet": "struct buffer_head *udf_read_ptagged(struct super_block *sb,\n\t\t\t\t     struct kernel_lb_addr *loc,\n\t\t\t\t     uint32_t offset, uint16_t *ident)\n{\n\treturn udf_read_tagged(sb, udf_get_lb_pblock(sb, loc, offset),\n\t\t\t       loc->logicalBlockNum + offset, ident);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_read_ptagged(struct super_block *sb,\n\t\t\t\t     struct kernel_lb_addr *loc,\n\t\t\t\t     uint32_t offset, uint16_t *ident)\n{\n\treturn udf_read_tagged(sb, udf_get_lb_pblock(sb, loc, offset),\n\t\t\t       loc->logicalBlockNum + offset, ident);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 2364
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic unsigned int udf_count_free_bitmap(struct super_block *sb,\n\t\t\t\t\t  struct udf_bitmap *bitmap)\n{\n\tstruct buffer_head *bh = NULL;\n\tunsigned int accum = 0;\n\tint index;\n\tint block = 0, newblock;\n\tstruct kernel_lb_addr loc;\n\tuint32_t bytes;\n\tuint8_t *ptr;\n\tuint16_t ident;\n\tstruct spaceBitmapDesc *bm;\n\n\tloc.logicalBlockNum = bitmap->s_extPosition;\n\tloc.partitionReferenceNum = UDF_SB(sb)->s_partition;\n\tbh = udf_read_ptagged(sb, &loc, 0, &ident);\n\n\tif (!bh) {\n\t\tudf_err(sb, \"udf_count_free failed\\n\");\n\t\tgoto out;\n\t} else if (ident != TAG_IDENT_SBD) {\n\t\tbrelse(bh);\n\t\tudf_err(sb, \"udf_count_free failed\\n\");\n\t\tgoto out;\n\t}\n\n\tbm = (struct spaceBitmapDesc *)bh->b_data;\n\tbytes = le32_to_cpu(bm->numOfBytes);\n\tindex = sizeof(struct spaceBitmapDesc); /* offset in first block only */\n\tptr = (uint8_t *)bh->b_data;\n\n\twhile (bytes > 0) {\n\t\tu32 cur_bytes = min_t(u32, bytes, sb->s_blocksize - index);\n\t\taccum += bitmap_weight((const unsigned long *)(ptr + index),\n\t\t\t\t\tcur_bytes * 8);\n\t\tbytes -= cur_bytes;\n\t\tif (bytes) {\n\t\t\tbrelse(bh);\n\t\t\tnewblock = udf_get_lb_pblock(sb, &loc, ++block);\n\t\t\tbh = udf_tread(sb, newblock);\n\t\t\tif (!bh) {\n\t\t\t\tudf_debug(\"read failed\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tindex = 0;\n\t\t\tptr = (uint8_t *)bh->b_data;\n\t\t}\n\t}\n\tbrelse(bh);\nout:\n\treturn accum;\n}"
  },
  {
    "function_name": "udf_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "2326-2348",
    "snippet": "static int udf_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tlvidiu = udf_sb_lvidiu(sb);\n\tbuf->f_type = UDF_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = sbi->s_partmaps[sbi->s_partition].s_partition_len;\n\tbuf->f_bfree = udf_count_free(sb);\n\tbuf->f_bavail = buf->f_bfree;\n\tbuf->f_files = (lvidiu != NULL ? (le32_to_cpu(lvidiu->numFiles) +\n\t\t\t\t\t  le32_to_cpu(lvidiu->numDirs)) : 0)\n\t\t\t+ buf->f_bfree;\n\tbuf->f_ffree = buf->f_bfree;\n\tbuf->f_namelen = UDF_NAME_LEN - 2;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);",
      "static int udf_statfs(struct dentry *, struct kstatfs *);",
      "static int udf_show_options(struct seq_file *, struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "id >> 32"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "lvidiu->numDirs"
          ],
          "line": 2340
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_count_free",
          "args": [
            "sb"
          ],
          "line": 2337
        },
        "resolved": true,
        "details": {
          "function_name": "udf_count_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "2426-2470",
          "snippet": "static unsigned int udf_count_free(struct super_block *sb)\n{\n\tunsigned int accum = 0;\n\tstruct udf_sb_info *sbi;\n\tstruct udf_part_map *map;\n\n\tsbi = UDF_SB(sb);\n\tif (sbi->s_lvid_bh) {\n\t\tstruct logicalVolIntegrityDesc *lvid =\n\t\t\t(struct logicalVolIntegrityDesc *)\n\t\t\tsbi->s_lvid_bh->b_data;\n\t\tif (le32_to_cpu(lvid->numOfPartitions) > sbi->s_partition) {\n\t\t\taccum = le32_to_cpu(\n\t\t\t\t\tlvid->freeSpaceTable[sbi->s_partition]);\n\t\t\tif (accum == 0xFFFFFFFF)\n\t\t\t\taccum = 0;\n\t\t}\n\t}\n\n\tif (accum)\n\t\treturn accum;\n\n\tmap = &sbi->s_partmaps[sbi->s_partition];\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP) {\n\t\taccum += udf_count_free_bitmap(sb,\n\t\t\t\t\t       map->s_uspace.s_bitmap);\n\t}\n\tif (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP) {\n\t\taccum += udf_count_free_bitmap(sb,\n\t\t\t\t\t       map->s_fspace.s_bitmap);\n\t}\n\tif (accum)\n\t\treturn accum;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE) {\n\t\taccum += udf_count_free_table(sb,\n\t\t\t\t\t      map->s_uspace.s_table);\n\t}\n\tif (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE) {\n\t\taccum += udf_count_free_table(sb,\n\t\t\t\t\t      map->s_fspace.s_table);\n\t}\n\n\treturn accum;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic unsigned int udf_count_free(struct super_block *sb)\n{\n\tunsigned int accum = 0;\n\tstruct udf_sb_info *sbi;\n\tstruct udf_part_map *map;\n\n\tsbi = UDF_SB(sb);\n\tif (sbi->s_lvid_bh) {\n\t\tstruct logicalVolIntegrityDesc *lvid =\n\t\t\t(struct logicalVolIntegrityDesc *)\n\t\t\tsbi->s_lvid_bh->b_data;\n\t\tif (le32_to_cpu(lvid->numOfPartitions) > sbi->s_partition) {\n\t\t\taccum = le32_to_cpu(\n\t\t\t\t\tlvid->freeSpaceTable[sbi->s_partition]);\n\t\t\tif (accum == 0xFFFFFFFF)\n\t\t\t\taccum = 0;\n\t\t}\n\t}\n\n\tif (accum)\n\t\treturn accum;\n\n\tmap = &sbi->s_partmaps[sbi->s_partition];\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP) {\n\t\taccum += udf_count_free_bitmap(sb,\n\t\t\t\t\t       map->s_uspace.s_bitmap);\n\t}\n\tif (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP) {\n\t\taccum += udf_count_free_bitmap(sb,\n\t\t\t\t\t       map->s_fspace.s_bitmap);\n\t}\n\tif (accum)\n\t\treturn accum;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE) {\n\t\taccum += udf_count_free_table(sb,\n\t\t\t\t\t      map->s_uspace.s_table);\n\t}\n\tif (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE) {\n\t\taccum += udf_count_free_table(sb,\n\t\t\t\t\t      map->s_fspace.s_table);\n\t}\n\n\treturn accum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_sb_lvidiu",
          "args": [
            "sb"
          ],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "udf_sb_lvidiu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "100-120",
          "snippet": "struct logicalVolIntegrityDescImpUse *udf_sb_lvidiu(struct super_block *sb)\n{\n\tstruct logicalVolIntegrityDesc *lvid;\n\tunsigned int partnum;\n\tunsigned int offset;\n\n\tif (!UDF_SB(sb)->s_lvid_bh)\n\t\treturn NULL;\n\tlvid = (struct logicalVolIntegrityDesc *)UDF_SB(sb)->s_lvid_bh->b_data;\n\tpartnum = le32_to_cpu(lvid->numOfPartitions);\n\tif ((sb->s_blocksize - sizeof(struct logicalVolIntegrityDescImpUse) -\n\t     offsetof(struct logicalVolIntegrityDesc, impUse)) /\n\t     (2 * sizeof(uint32_t)) < partnum) {\n\t\tudf_err(sb, \"Logical volume integrity descriptor corrupted \"\n\t\t\t\"(numOfPartitions = %u)!\\n\", partnum);\n\t\treturn NULL;\n\t}\n\t/* The offset is to skip freeSpaceTable and sizeTable arrays */\n\toffset = partnum * 2 * sizeof(uint32_t);\n\treturn (struct logicalVolIntegrityDescImpUse *)&(lvid->impUse[offset]);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstruct logicalVolIntegrityDescImpUse *udf_sb_lvidiu(struct super_block *sb)\n{\n\tstruct logicalVolIntegrityDesc *lvid;\n\tunsigned int partnum;\n\tunsigned int offset;\n\n\tif (!UDF_SB(sb)->s_lvid_bh)\n\t\treturn NULL;\n\tlvid = (struct logicalVolIntegrityDesc *)UDF_SB(sb)->s_lvid_bh->b_data;\n\tpartnum = le32_to_cpu(lvid->numOfPartitions);\n\tif ((sb->s_blocksize - sizeof(struct logicalVolIntegrityDescImpUse) -\n\t     offsetof(struct logicalVolIntegrityDesc, impUse)) /\n\t     (2 * sizeof(uint32_t)) < partnum) {\n\t\tudf_err(sb, \"Logical volume integrity descriptor corrupted \"\n\t\t\t\"(numOfPartitions = %u)!\\n\", partnum);\n\t\treturn NULL;\n\t}\n\t/* The offset is to skip freeSpaceTable and sizeTable arrays */\n\toffset = partnum * 2 * sizeof(uint32_t);\n\treturn (struct logicalVolIntegrityDescImpUse *)&(lvid->impUse[offset]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_encode_dev",
          "args": [
            "sb->s_bdev->bd_dev"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 2329
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\nstatic int udf_statfs(struct dentry *, struct kstatfs *);\nstatic int udf_show_options(struct seq_file *, struct dentry *);\n\nstatic int udf_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tlvidiu = udf_sb_lvidiu(sb);\n\tbuf->f_type = UDF_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = sbi->s_partmaps[sbi->s_partition].s_partition_len;\n\tbuf->f_bfree = udf_count_free(sb);\n\tbuf->f_bavail = buf->f_bfree;\n\tbuf->f_files = (lvidiu != NULL ? (le32_to_cpu(lvidiu->numFiles) +\n\t\t\t\t\t  le32_to_cpu(lvidiu->numDirs)) : 0)\n\t\t\t+ buf->f_bfree;\n\tbuf->f_ffree = buf->f_bfree;\n\tbuf->f_namelen = UDF_NAME_LEN - 2;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "udf_sync_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "2308-2324",
    "snippet": "static int udf_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tif (sbi->s_lvid_dirty) {\n\t\t/*\n\t\t * Blockdevice will be synced later so we don't have to submit\n\t\t * the buffer for IO\n\t\t */\n\t\tmark_buffer_dirty(sbi->s_lvid_bh);\n\t\tsbi->s_lvid_dirty = 0;\n\t}\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "sbi->s_lvid_bh"
          ],
          "line": 2318
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 2310
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tif (sbi->s_lvid_dirty) {\n\t\t/*\n\t\t * Blockdevice will be synced later so we don't have to submit\n\t\t * the buffer for IO\n\t\t */\n\t\tmark_buffer_dirty(sbi->s_lvid_bh);\n\t\tsbi->s_lvid_dirty = 0;\n\t}\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "udf_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "2288-2306",
    "snippet": "static void udf_put_super(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi;\n\n\tsbi = UDF_SB(sb);\n\n\tiput(sbi->s_vat_inode);\n#ifdef CONFIG_UDF_NLS\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP))\n\t\tunload_nls(sbi->s_nls_map);\n#endif\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tudf_close_lvid(sb);\n\tbrelse(sbi->s_lvid_bh);\n\tudf_sb_free_partitions(sb);\n\tmutex_destroy(&sbi->s_alloc_mutex);\n\tkfree(sb->s_fs_info);\n\tsb->s_fs_info = NULL;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sb->s_fs_info"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_sb_free_partitions",
          "args": [
            "sb"
          ],
          "line": 2302
        },
        "resolved": true,
        "details": {
          "function_name": "udf_sb_free_partitions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "324-334",
          "snippet": "static void udf_sb_free_partitions(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint i;\n\tif (sbi->s_partmaps == NULL)\n\t\treturn;\n\tfor (i = 0; i < sbi->s_partitions; i++)\n\t\tudf_free_partition(&sbi->s_partmaps[i]);\n\tkfree(sbi->s_partmaps);\n\tsbi->s_partmaps = NULL;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic void udf_sb_free_partitions(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint i;\n\tif (sbi->s_partmaps == NULL)\n\t\treturn;\n\tfor (i = 0; i < sbi->s_partitions; i++)\n\t\tudf_free_partition(&sbi->s_partmaps[i]);\n\tkfree(sbi->s_partmaps);\n\tsbi->s_partmaps = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "sbi->s_lvid_bh"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_close_lvid",
          "args": [
            "sb"
          ],
          "line": 2300
        },
        "resolved": true,
        "details": {
          "function_name": "udf_close_lvid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "1990-2032",
          "snippet": "static void udf_close_lvid(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct buffer_head *bh = sbi->s_lvid_bh;\n\tstruct logicalVolIntegrityDesc *lvid;\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\n\tif (!bh)\n\t\treturn;\n\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (!lvidiu)\n\t\treturn;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tlvidiu->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\tlvidiu->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\tudf_time_to_disk_stamp(&lvid->recordingDateAndTime, CURRENT_TIME);\n\tif (UDF_MAX_WRITE_VERSION > le16_to_cpu(lvidiu->maxUDFWriteRev))\n\t\tlvidiu->maxUDFWriteRev = cpu_to_le16(UDF_MAX_WRITE_VERSION);\n\tif (sbi->s_udfrev > le16_to_cpu(lvidiu->minUDFReadRev))\n\t\tlvidiu->minUDFReadRev = cpu_to_le16(sbi->s_udfrev);\n\tif (sbi->s_udfrev > le16_to_cpu(lvidiu->minUDFWriteRev))\n\t\tlvidiu->minUDFWriteRev = cpu_to_le16(sbi->s_udfrev);\n\tlvid->integrityType = cpu_to_le32(LVID_INTEGRITY_TYPE_CLOSE);\n\n\tlvid->descTag.descCRC = cpu_to_le16(\n\t\t\tcrc_itu_t(0, (char *)lvid + sizeof(struct tag),\n\t\t\t\tle16_to_cpu(lvid->descTag.descCRCLength)));\n\n\tlvid->descTag.tagChecksum = udf_tag_checksum(&lvid->descTag);\n\t/*\n\t * We set buffer uptodate unconditionally here to avoid spurious\n\t * warnings from mark_buffer_dirty() when previous EIO has marked\n\t * the buffer as !uptodate\n\t */\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\tsbi->s_lvid_dirty = 0;\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t/* Make closing of filesystem visible on the media immediately */\n\tsync_dirty_buffer(bh);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic void udf_close_lvid(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct buffer_head *bh = sbi->s_lvid_bh;\n\tstruct logicalVolIntegrityDesc *lvid;\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\n\tif (!bh)\n\t\treturn;\n\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (!lvidiu)\n\t\treturn;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tlvidiu->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\tlvidiu->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\tudf_time_to_disk_stamp(&lvid->recordingDateAndTime, CURRENT_TIME);\n\tif (UDF_MAX_WRITE_VERSION > le16_to_cpu(lvidiu->maxUDFWriteRev))\n\t\tlvidiu->maxUDFWriteRev = cpu_to_le16(UDF_MAX_WRITE_VERSION);\n\tif (sbi->s_udfrev > le16_to_cpu(lvidiu->minUDFReadRev))\n\t\tlvidiu->minUDFReadRev = cpu_to_le16(sbi->s_udfrev);\n\tif (sbi->s_udfrev > le16_to_cpu(lvidiu->minUDFWriteRev))\n\t\tlvidiu->minUDFWriteRev = cpu_to_le16(sbi->s_udfrev);\n\tlvid->integrityType = cpu_to_le32(LVID_INTEGRITY_TYPE_CLOSE);\n\n\tlvid->descTag.descCRC = cpu_to_le16(\n\t\t\tcrc_itu_t(0, (char *)lvid + sizeof(struct tag),\n\t\t\t\tle16_to_cpu(lvid->descTag.descCRCLength)));\n\n\tlvid->descTag.tagChecksum = udf_tag_checksum(&lvid->descTag);\n\t/*\n\t * We set buffer uptodate unconditionally here to avoid spurious\n\t * warnings from mark_buffer_dirty() when previous EIO has marked\n\t * the buffer as !uptodate\n\t */\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\tsbi->s_lvid_dirty = 0;\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t/* Make closing of filesystem visible on the media immediately */\n\tsync_dirty_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unload_nls",
          "args": [
            "sbi->s_nls_map"
          ],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "unload_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "296-300",
          "snippet": "void unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_QUERY_FLAG",
          "args": [
            "sb",
            "UDF_FLAG_NLS_MAP"
          ],
          "line": 2296
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_QUERY_FLAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "169-172",
          "snippet": "static inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "sbi->s_vat_inode"
          ],
          "line": 2294
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 2292
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic void udf_put_super(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi;\n\n\tsbi = UDF_SB(sb);\n\n\tiput(sbi->s_vat_inode);\n#ifdef CONFIG_UDF_NLS\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP))\n\t\tunload_nls(sbi->s_nls_map);\n#endif\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tudf_close_lvid(sb);\n\tbrelse(sbi->s_lvid_bh);\n\tudf_sb_free_partitions(sb);\n\tmutex_destroy(&sbi->s_alloc_mutex);\n\tkfree(sb->s_fs_info);\n\tsb->s_fs_info = NULL;\n}"
  },
  {
    "function_name": "_udf_warn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "2272-2286",
    "snippet": "void _udf_warn(struct super_block *sb, const char *function,\n\t       const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_warn(\"warning (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"warning (device %s): %s: %pV\"",
            "sb->s_id",
            "function",
            "&vaf"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nvoid _udf_warn(struct super_block *sb, const char *function,\n\t       const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_warn(\"warning (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
  },
  {
    "function_name": "_udf_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "2256-2270",
    "snippet": "void _udf_err(struct super_block *sb, const char *function,\n\t      const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"error (device %s): %s: %pV\"",
            "sb->s_id",
            "function",
            "&vaf"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nvoid _udf_err(struct super_block *sb, const char *function,\n\t      const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
  },
  {
    "function_name": "udf_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "2061-2254",
    "snippet": "static int udf_fill_super(struct super_block *sb, void *options, int silent)\n{\n\tint ret = -EINVAL;\n\tstruct inode *inode = NULL;\n\tstruct udf_options uopt;\n\tstruct kernel_lb_addr rootdir, fileset;\n\tstruct udf_sb_info *sbi;\n\n\tuopt.flags = (1 << UDF_FLAG_USE_AD_IN_ICB) | (1 << UDF_FLAG_STRICT);\n\tuopt.uid = INVALID_UID;\n\tuopt.gid = INVALID_GID;\n\tuopt.umask = 0;\n\tuopt.fmode = UDF_INVALID_MODE;\n\tuopt.dmode = UDF_INVALID_MODE;\n\n\tsbi = kzalloc(sizeof(struct udf_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = sbi;\n\n\tmutex_init(&sbi->s_alloc_mutex);\n\n\tif (!udf_parse_options((char *)options, &uopt, false))\n\t\tgoto parse_options_failure;\n\n\tif (uopt.flags & (1 << UDF_FLAG_UTF8) &&\n\t    uopt.flags & (1 << UDF_FLAG_NLS_MAP)) {\n\t\tudf_err(sb, \"utf8 cannot be combined with iocharset\\n\");\n\t\tgoto parse_options_failure;\n\t}\n#ifdef CONFIG_UDF_NLS\n\tif ((uopt.flags & (1 << UDF_FLAG_NLS_MAP)) && !uopt.nls_map) {\n\t\tuopt.nls_map = load_nls_default();\n\t\tif (!uopt.nls_map)\n\t\t\tuopt.flags &= ~(1 << UDF_FLAG_NLS_MAP);\n\t\telse\n\t\t\tudf_debug(\"Using default NLS map\\n\");\n\t}\n#endif\n\tif (!(uopt.flags & (1 << UDF_FLAG_NLS_MAP)))\n\t\tuopt.flags |= (1 << UDF_FLAG_UTF8);\n\n\tfileset.logicalBlockNum = 0xFFFFFFFF;\n\tfileset.partitionReferenceNum = 0xFFFF;\n\n\tsbi->s_flags = uopt.flags;\n\tsbi->s_uid = uopt.uid;\n\tsbi->s_gid = uopt.gid;\n\tsbi->s_umask = uopt.umask;\n\tsbi->s_fmode = uopt.fmode;\n\tsbi->s_dmode = uopt.dmode;\n\tsbi->s_nls_map = uopt.nls_map;\n\trwlock_init(&sbi->s_cred_lock);\n\n\tif (uopt.session == 0xFFFFFFFF)\n\t\tsbi->s_session = udf_get_last_session(sb);\n\telse\n\t\tsbi->s_session = uopt.session;\n\n\tudf_debug(\"Multi-session=%d\\n\", sbi->s_session);\n\n\t/* Fill in the rest of the superblock */\n\tsb->s_op = &udf_sb_ops;\n\tsb->s_export_op = &udf_export_ops;\n\n\tsb->s_magic = UDF_SUPER_MAGIC;\n\tsb->s_time_gran = 1000;\n\n\tif (uopt.flags & (1 << UDF_FLAG_BLOCKSIZE_SET)) {\n\t\tret = udf_load_vrs(sb, &uopt, silent, &fileset);\n\t} else {\n\t\tuopt.blocksize = bdev_logical_block_size(sb->s_bdev);\n\t\tret = udf_load_vrs(sb, &uopt, silent, &fileset);\n\t\tif (ret == -EAGAIN && uopt.blocksize != UDF_DEFAULT_BLOCKSIZE) {\n\t\t\tif (!silent)\n\t\t\t\tpr_notice(\"Rescanning with blocksize %d\\n\",\n\t\t\t\t\t  UDF_DEFAULT_BLOCKSIZE);\n\t\t\tbrelse(sbi->s_lvid_bh);\n\t\t\tsbi->s_lvid_bh = NULL;\n\t\t\tuopt.blocksize = UDF_DEFAULT_BLOCKSIZE;\n\t\t\tret = udf_load_vrs(sb, &uopt, silent, &fileset);\n\t\t}\n\t}\n\tif (ret < 0) {\n\t\tif (ret == -EAGAIN) {\n\t\t\tudf_warn(sb, \"No partition found (1)\\n\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tgoto error_out;\n\t}\n\n\tudf_debug(\"Lastblock=%d\\n\", sbi->s_last_block);\n\n\tif (sbi->s_lvid_bh) {\n\t\tstruct logicalVolIntegrityDescImpUse *lvidiu =\n\t\t\t\t\t\t\tudf_sb_lvidiu(sb);\n\t\tuint16_t minUDFReadRev;\n\t\tuint16_t minUDFWriteRev;\n\n\t\tif (!lvidiu) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto error_out;\n\t\t}\n\t\tminUDFReadRev = le16_to_cpu(lvidiu->minUDFReadRev);\n\t\tminUDFWriteRev = le16_to_cpu(lvidiu->minUDFWriteRev);\n\t\tif (minUDFReadRev > UDF_MAX_READ_VERSION) {\n\t\t\tudf_err(sb, \"minUDFReadRev=%x (max is %x)\\n\",\n\t\t\t\tminUDFReadRev,\n\t\t\t\tUDF_MAX_READ_VERSION);\n\t\t\tret = -EINVAL;\n\t\t\tgoto error_out;\n\t\t} else if (minUDFWriteRev > UDF_MAX_WRITE_VERSION &&\n\t\t\t   !(sb->s_flags & MS_RDONLY)) {\n\t\t\tret = -EACCES;\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tsbi->s_udfrev = minUDFWriteRev;\n\n\t\tif (minUDFReadRev >= UDF_VERS_USE_EXTENDED_FE)\n\t\t\tUDF_SET_FLAG(sb, UDF_FLAG_USE_EXTENDED_FE);\n\t\tif (minUDFReadRev >= UDF_VERS_USE_STREAMS)\n\t\t\tUDF_SET_FLAG(sb, UDF_FLAG_USE_STREAMS);\n\t}\n\n\tif (!sbi->s_partitions) {\n\t\tudf_warn(sb, \"No partition found (2)\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error_out;\n\t}\n\n\tif (sbi->s_partmaps[sbi->s_partition].s_partition_flags &\n\t\t\tUDF_PART_FLAG_READ_ONLY &&\n\t    !(sb->s_flags & MS_RDONLY)) {\n\t\tret = -EACCES;\n\t\tgoto error_out;\n\t}\n\n\tif (udf_find_fileset(sb, &fileset, &rootdir)) {\n\t\tudf_warn(sb, \"No fileset found\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error_out;\n\t}\n\n\tif (!silent) {\n\t\tstruct timestamp ts;\n\t\tudf_time_to_disk_stamp(&ts, sbi->s_record_time);\n\t\tudf_info(\"Mounting volume '%s', timestamp %04u/%02u/%02u %02u:%02u (%x)\\n\",\n\t\t\t sbi->s_volume_ident,\n\t\t\t le16_to_cpu(ts.year), ts.month, ts.day,\n\t\t\t ts.hour, ts.minute, le16_to_cpu(ts.typeAndTimezone));\n\t}\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tudf_open_lvid(sb);\n\n\t/* Assign the root inode */\n\t/* assign inodes by physical block number */\n\t/* perhaps it's not extensible enough, but for now ... */\n\tinode = udf_iget(sb, &rootdir);\n\tif (IS_ERR(inode)) {\n\t\tudf_err(sb, \"Error in udf_iget, block=%d, partition=%d\\n\",\n\t\t       rootdir.logicalBlockNum, rootdir.partitionReferenceNum);\n\t\tret = PTR_ERR(inode);\n\t\tgoto error_out;\n\t}\n\n\t/* Allocate a dentry for the root inode */\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root) {\n\t\tudf_err(sb, \"Couldn't allocate root dentry\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error_out;\n\t}\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_max_links = UDF_MAX_LINKS;\n\treturn 0;\n\nerror_out:\n\tiput(sbi->s_vat_inode);\nparse_options_failure:\n#ifdef CONFIG_UDF_NLS\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP))\n\t\tunload_nls(sbi->s_nls_map);\n#endif\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tudf_close_lvid(sb);\n\tbrelse(sbi->s_lvid_bh);\n\tudf_sb_free_partitions(sb);\n\tkfree(sbi);\n\tsb->s_fs_info = NULL;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [
      "#define UDF_DEFAULT_BLOCKSIZE 2048"
    ],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
      "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);",
      "static int udf_show_options(struct seq_file *, struct dentry *);",
      "static const struct super_operations udf_sb_ops = {\n\t.alloc_inode\t= udf_alloc_inode,\n\t.destroy_inode\t= udf_destroy_inode,\n\t.write_inode\t= udf_write_inode,\n\t.evict_inode\t= udf_evict_inode,\n\t.put_super\t= udf_put_super,\n\t.sync_fs\t= udf_sync_fs,\n\t.statfs\t\t= udf_statfs,\n\t.remount_fs\t= udf_remount_fs,\n\t.show_options\t= udf_show_options,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_sb_free_partitions",
          "args": [
            "sb"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "udf_sb_free_partitions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "324-334",
          "snippet": "static void udf_sb_free_partitions(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint i;\n\tif (sbi->s_partmaps == NULL)\n\t\treturn;\n\tfor (i = 0; i < sbi->s_partitions; i++)\n\t\tudf_free_partition(&sbi->s_partmaps[i]);\n\tkfree(sbi->s_partmaps);\n\tsbi->s_partmaps = NULL;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic void udf_sb_free_partitions(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint i;\n\tif (sbi->s_partmaps == NULL)\n\t\treturn;\n\tfor (i = 0; i < sbi->s_partitions; i++)\n\t\tudf_free_partition(&sbi->s_partmaps[i]);\n\tkfree(sbi->s_partmaps);\n\tsbi->s_partmaps = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "sbi->s_lvid_bh"
          ],
          "line": 2248
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_close_lvid",
          "args": [
            "sb"
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "udf_close_lvid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "1990-2032",
          "snippet": "static void udf_close_lvid(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct buffer_head *bh = sbi->s_lvid_bh;\n\tstruct logicalVolIntegrityDesc *lvid;\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\n\tif (!bh)\n\t\treturn;\n\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (!lvidiu)\n\t\treturn;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tlvidiu->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\tlvidiu->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\tudf_time_to_disk_stamp(&lvid->recordingDateAndTime, CURRENT_TIME);\n\tif (UDF_MAX_WRITE_VERSION > le16_to_cpu(lvidiu->maxUDFWriteRev))\n\t\tlvidiu->maxUDFWriteRev = cpu_to_le16(UDF_MAX_WRITE_VERSION);\n\tif (sbi->s_udfrev > le16_to_cpu(lvidiu->minUDFReadRev))\n\t\tlvidiu->minUDFReadRev = cpu_to_le16(sbi->s_udfrev);\n\tif (sbi->s_udfrev > le16_to_cpu(lvidiu->minUDFWriteRev))\n\t\tlvidiu->minUDFWriteRev = cpu_to_le16(sbi->s_udfrev);\n\tlvid->integrityType = cpu_to_le32(LVID_INTEGRITY_TYPE_CLOSE);\n\n\tlvid->descTag.descCRC = cpu_to_le16(\n\t\t\tcrc_itu_t(0, (char *)lvid + sizeof(struct tag),\n\t\t\t\tle16_to_cpu(lvid->descTag.descCRCLength)));\n\n\tlvid->descTag.tagChecksum = udf_tag_checksum(&lvid->descTag);\n\t/*\n\t * We set buffer uptodate unconditionally here to avoid spurious\n\t * warnings from mark_buffer_dirty() when previous EIO has marked\n\t * the buffer as !uptodate\n\t */\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\tsbi->s_lvid_dirty = 0;\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t/* Make closing of filesystem visible on the media immediately */\n\tsync_dirty_buffer(bh);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic void udf_close_lvid(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct buffer_head *bh = sbi->s_lvid_bh;\n\tstruct logicalVolIntegrityDesc *lvid;\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\n\tif (!bh)\n\t\treturn;\n\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (!lvidiu)\n\t\treturn;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tlvidiu->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\tlvidiu->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\tudf_time_to_disk_stamp(&lvid->recordingDateAndTime, CURRENT_TIME);\n\tif (UDF_MAX_WRITE_VERSION > le16_to_cpu(lvidiu->maxUDFWriteRev))\n\t\tlvidiu->maxUDFWriteRev = cpu_to_le16(UDF_MAX_WRITE_VERSION);\n\tif (sbi->s_udfrev > le16_to_cpu(lvidiu->minUDFReadRev))\n\t\tlvidiu->minUDFReadRev = cpu_to_le16(sbi->s_udfrev);\n\tif (sbi->s_udfrev > le16_to_cpu(lvidiu->minUDFWriteRev))\n\t\tlvidiu->minUDFWriteRev = cpu_to_le16(sbi->s_udfrev);\n\tlvid->integrityType = cpu_to_le32(LVID_INTEGRITY_TYPE_CLOSE);\n\n\tlvid->descTag.descCRC = cpu_to_le16(\n\t\t\tcrc_itu_t(0, (char *)lvid + sizeof(struct tag),\n\t\t\t\tle16_to_cpu(lvid->descTag.descCRCLength)));\n\n\tlvid->descTag.tagChecksum = udf_tag_checksum(&lvid->descTag);\n\t/*\n\t * We set buffer uptodate unconditionally here to avoid spurious\n\t * warnings from mark_buffer_dirty() when previous EIO has marked\n\t * the buffer as !uptodate\n\t */\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\tsbi->s_lvid_dirty = 0;\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t/* Make closing of filesystem visible on the media immediately */\n\tsync_dirty_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unload_nls",
          "args": [
            "sbi->s_nls_map"
          ],
          "line": 2244
        },
        "resolved": true,
        "details": {
          "function_name": "unload_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "296-300",
          "snippet": "void unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_QUERY_FLAG",
          "args": [
            "sb",
            "UDF_FLAG_NLS_MAP"
          ],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_QUERY_FLAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "169-172",
          "snippet": "static inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "sbi->s_vat_inode"
          ],
          "line": 2240
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_err",
          "args": [
            "sb",
            "\"Couldn't allocate root dentry\\n\""
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "inode"
          ],
          "line": 2229
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 2224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_err",
          "args": [
            "sb",
            "\"Error in udf_iget, block=%d, partition=%d\\n\"",
            "rootdir.logicalBlockNum",
            "rootdir.partitionReferenceNum"
          ],
          "line": 2222
        },
        "resolved": true,
        "details": {
          "function_name": "_udf_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "2256-2270",
          "snippet": "void _udf_err(struct super_block *sb, const char *function,\n\t      const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nvoid _udf_err(struct super_block *sb, const char *function,\n\t      const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_iget",
          "args": [
            "sb",
            "&rootdir"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "udf_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "148-152",
          "snippet": "static inline struct inode *udf_iget(struct super_block *sb,\n\t\t\t\t     struct kernel_lb_addr *ino)\n{\n\treturn __udf_iget(sb, ino, false);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline struct inode *udf_iget(struct super_block *sb,\n\t\t\t\t     struct kernel_lb_addr *ino)\n{\n\treturn __udf_iget(sb, ino, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_open_lvid",
          "args": [
            "sb"
          ],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "udf_open_lvid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "1957-1988",
          "snippet": "static void udf_open_lvid(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct buffer_head *bh = sbi->s_lvid_bh;\n\tstruct logicalVolIntegrityDesc *lvid;\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\n\tif (!bh)\n\t\treturn;\n\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (!lvidiu)\n\t\treturn;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tlvidiu->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\tlvidiu->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\tudf_time_to_disk_stamp(&lvid->recordingDateAndTime,\n\t\t\t\tCURRENT_TIME);\n\tlvid->integrityType = cpu_to_le32(LVID_INTEGRITY_TYPE_OPEN);\n\n\tlvid->descTag.descCRC = cpu_to_le16(\n\t\tcrc_itu_t(0, (char *)lvid + sizeof(struct tag),\n\t\t\tle16_to_cpu(lvid->descTag.descCRCLength)));\n\n\tlvid->descTag.tagChecksum = udf_tag_checksum(&lvid->descTag);\n\tmark_buffer_dirty(bh);\n\tsbi->s_lvid_dirty = 0;\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t/* Make opening of filesystem visible on the media immediately */\n\tsync_dirty_buffer(bh);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic void udf_open_lvid(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct buffer_head *bh = sbi->s_lvid_bh;\n\tstruct logicalVolIntegrityDesc *lvid;\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\n\tif (!bh)\n\t\treturn;\n\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (!lvidiu)\n\t\treturn;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tlvidiu->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\tlvidiu->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\tudf_time_to_disk_stamp(&lvid->recordingDateAndTime,\n\t\t\t\tCURRENT_TIME);\n\tlvid->integrityType = cpu_to_le32(LVID_INTEGRITY_TYPE_OPEN);\n\n\tlvid->descTag.descCRC = cpu_to_le16(\n\t\tcrc_itu_t(0, (char *)lvid + sizeof(struct tag),\n\t\t\tle16_to_cpu(lvid->descTag.descCRCLength)));\n\n\tlvid->descTag.tagChecksum = udf_tag_checksum(&lvid->descTag);\n\tmark_buffer_dirty(bh);\n\tsbi->s_lvid_dirty = 0;\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t/* Make opening of filesystem visible on the media immediately */\n\tsync_dirty_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_info",
          "args": [
            "\"Mounting volume '%s', timestamp %04u/%02u/%02u %02u:%02u (%x)\\n\"",
            "sbi->s_volume_ident",
            "le16_to_cpu(ts.year)",
            "ts.month",
            "ts.day",
            "ts.hour",
            "ts.minute",
            "le16_to_cpu(ts.typeAndTimezone)"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ts.typeAndTimezone"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_time_to_disk_stamp",
          "args": [
            "&ts",
            "sbi->s_record_time"
          ],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "udf_time_to_disk_stamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udftime.c",
          "lines": "119-168",
          "snippet": "struct timestamp *\nudf_time_to_disk_stamp(struct timestamp *dest, struct timespec ts)\n{\n\tlong int days, rem, y;\n\tconst unsigned short int *ip;\n\tint16_t offset;\n\n\toffset = -sys_tz.tz_minuteswest;\n\n\tif (!dest)\n\t\treturn NULL;\n\n\tdest->typeAndTimezone = cpu_to_le16(0x1000 | (offset & 0x0FFF));\n\n\tts.tv_sec += offset * 60;\n\tdays = ts.tv_sec / SECS_PER_DAY;\n\trem = ts.tv_sec % SECS_PER_DAY;\n\tdest->hour = rem / SECS_PER_HOUR;\n\trem %= SECS_PER_HOUR;\n\tdest->minute = rem / 60;\n\tdest->second = rem % 60;\n\ty = 1970;\n\n#define DIV(a, b) ((a) / (b) - ((a) % (b) < 0))\n#define LEAPS_THRU_END_OF(y) (DIV (y, 4) - DIV (y, 100) + DIV (y, 400))\n\n\twhile (days < 0 || days >= (__isleap(y) ? 366 : 365)) {\n\t\tlong int yg = y + days / 365 - (days % 365 < 0);\n\n\t\t/* Adjust DAYS and Y to match the guessed year.  */\n\t\tdays -= ((yg - y) * 365\n\t\t\t + LEAPS_THRU_END_OF(yg - 1)\n\t\t\t - LEAPS_THRU_END_OF(y - 1));\n\t\ty = yg;\n\t}\n\tdest->year = cpu_to_le16(y);\n\tip = __mon_yday[__isleap(y)];\n\tfor (y = 11; days < (long int)ip[y]; --y)\n\t\tcontinue;\n\tdays -= ip[y];\n\tdest->month = y + 1;\n\tdest->day = days + 1;\n\n\tdest->centiseconds = ts.tv_nsec / 10000000;\n\tdest->hundredsOfMicroseconds = (ts.tv_nsec / 1000 -\n\t\t\t\t\tdest->centiseconds * 10000) / 100;\n\tdest->microseconds = (ts.tv_nsec / 1000 - dest->centiseconds * 10000 -\n\t\t\t      dest->hundredsOfMicroseconds * 100);\n\treturn dest;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [
            "#define SECS_PER_DAY\t(SECS_PER_HOUR * 24)",
            "#define SECS_PER_HOUR\t(60 * 60)"
          ],
          "globals_used": [
            "static const unsigned short int __mon_yday[2][13] = {\n\t/* Normal years.  */\n\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t/* Leap years.  */\n\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/types.h>\n#include \"udfdecl.h\"\n\n#define SECS_PER_DAY\t(SECS_PER_HOUR * 24)\n#define SECS_PER_HOUR\t(60 * 60)\n\nstatic const unsigned short int __mon_yday[2][13] = {\n\t/* Normal years.  */\n\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t/* Leap years.  */\n\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}\n};\n\nstruct timestamp *\nudf_time_to_disk_stamp(struct timestamp *dest, struct timespec ts)\n{\n\tlong int days, rem, y;\n\tconst unsigned short int *ip;\n\tint16_t offset;\n\n\toffset = -sys_tz.tz_minuteswest;\n\n\tif (!dest)\n\t\treturn NULL;\n\n\tdest->typeAndTimezone = cpu_to_le16(0x1000 | (offset & 0x0FFF));\n\n\tts.tv_sec += offset * 60;\n\tdays = ts.tv_sec / SECS_PER_DAY;\n\trem = ts.tv_sec % SECS_PER_DAY;\n\tdest->hour = rem / SECS_PER_HOUR;\n\trem %= SECS_PER_HOUR;\n\tdest->minute = rem / 60;\n\tdest->second = rem % 60;\n\ty = 1970;\n\n#define DIV(a, b) ((a) / (b) - ((a) % (b) < 0))\n#define LEAPS_THRU_END_OF(y) (DIV (y, 4) - DIV (y, 100) + DIV (y, 400))\n\n\twhile (days < 0 || days >= (__isleap(y) ? 366 : 365)) {\n\t\tlong int yg = y + days / 365 - (days % 365 < 0);\n\n\t\t/* Adjust DAYS and Y to match the guessed year.  */\n\t\tdays -= ((yg - y) * 365\n\t\t\t + LEAPS_THRU_END_OF(yg - 1)\n\t\t\t - LEAPS_THRU_END_OF(y - 1));\n\t\ty = yg;\n\t}\n\tdest->year = cpu_to_le16(y);\n\tip = __mon_yday[__isleap(y)];\n\tfor (y = 11; days < (long int)ip[y]; --y)\n\t\tcontinue;\n\tdays -= ip[y];\n\tdest->month = y + 1;\n\tdest->day = days + 1;\n\n\tdest->centiseconds = ts.tv_nsec / 10000000;\n\tdest->hundredsOfMicroseconds = (ts.tv_nsec / 1000 -\n\t\t\t\t\tdest->centiseconds * 10000) / 100;\n\tdest->microseconds = (ts.tv_nsec / 1000 - dest->centiseconds * 10000 -\n\t\t\t      dest->hundredsOfMicroseconds * 100);\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_warn",
          "args": [
            "sb",
            "\"No fileset found\\n\""
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_find_fileset",
          "args": [
            "sb",
            "&fileset",
            "&rootdir"
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "udf_find_fileset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "796-884",
          "snippet": "static int udf_find_fileset(struct super_block *sb,\n\t\t\t    struct kernel_lb_addr *fileset,\n\t\t\t    struct kernel_lb_addr *root)\n{\n\tstruct buffer_head *bh = NULL;\n\tlong lastblock;\n\tuint16_t ident;\n\tstruct udf_sb_info *sbi;\n\n\tif (fileset->logicalBlockNum != 0xFFFFFFFF ||\n\t    fileset->partitionReferenceNum != 0xFFFF) {\n\t\tbh = udf_read_ptagged(sb, fileset, 0, &ident);\n\n\t\tif (!bh) {\n\t\t\treturn 1;\n\t\t} else if (ident != TAG_IDENT_FSD) {\n\t\t\tbrelse(bh);\n\t\t\treturn 1;\n\t\t}\n\n\t}\n\n\tsbi = UDF_SB(sb);\n\tif (!bh) {\n\t\t/* Search backwards through the partitions */\n\t\tstruct kernel_lb_addr newfileset;\n\n/* --> cvg: FIXME - is it reasonable? */\n\t\treturn 1;\n\n\t\tfor (newfileset.partitionReferenceNum = sbi->s_partitions - 1;\n\t\t     (newfileset.partitionReferenceNum != 0xFFFF &&\n\t\t      fileset->logicalBlockNum == 0xFFFFFFFF &&\n\t\t      fileset->partitionReferenceNum == 0xFFFF);\n\t\t     newfileset.partitionReferenceNum--) {\n\t\t\tlastblock = sbi->s_partmaps\n\t\t\t\t\t[newfileset.partitionReferenceNum]\n\t\t\t\t\t\t.s_partition_len;\n\t\t\tnewfileset.logicalBlockNum = 0;\n\n\t\t\tdo {\n\t\t\t\tbh = udf_read_ptagged(sb, &newfileset, 0,\n\t\t\t\t\t\t      &ident);\n\t\t\t\tif (!bh) {\n\t\t\t\t\tnewfileset.logicalBlockNum++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tswitch (ident) {\n\t\t\t\tcase TAG_IDENT_SBD:\n\t\t\t\t{\n\t\t\t\t\tstruct spaceBitmapDesc *sp;\n\t\t\t\t\tsp = (struct spaceBitmapDesc *)\n\t\t\t\t\t\t\t\tbh->b_data;\n\t\t\t\t\tnewfileset.logicalBlockNum += 1 +\n\t\t\t\t\t\t((le32_to_cpu(sp->numOfBytes) +\n\t\t\t\t\t\t  sizeof(struct spaceBitmapDesc)\n\t\t\t\t\t\t  - 1) >> sb->s_blocksize_bits);\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase TAG_IDENT_FSD:\n\t\t\t\t\t*fileset = newfileset;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tnewfileset.logicalBlockNum++;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tbh = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (newfileset.logicalBlockNum < lastblock &&\n\t\t\t\t fileset->logicalBlockNum == 0xFFFFFFFF &&\n\t\t\t\t fileset->partitionReferenceNum == 0xFFFF);\n\t\t}\n\t}\n\n\tif ((fileset->logicalBlockNum != 0xFFFFFFFF ||\n\t     fileset->partitionReferenceNum != 0xFFFF) && bh) {\n\t\tudf_debug(\"Fileset at block=%d, partition=%d\\n\",\n\t\t\t  fileset->logicalBlockNum,\n\t\t\t  fileset->partitionReferenceNum);\n\n\t\tsbi->s_partition = fileset->partitionReferenceNum;\n\t\tudf_load_fileset(sb, bh, root);\n\t\tbrelse(bh);\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
            "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_find_fileset(struct super_block *sb,\n\t\t\t    struct kernel_lb_addr *fileset,\n\t\t\t    struct kernel_lb_addr *root)\n{\n\tstruct buffer_head *bh = NULL;\n\tlong lastblock;\n\tuint16_t ident;\n\tstruct udf_sb_info *sbi;\n\n\tif (fileset->logicalBlockNum != 0xFFFFFFFF ||\n\t    fileset->partitionReferenceNum != 0xFFFF) {\n\t\tbh = udf_read_ptagged(sb, fileset, 0, &ident);\n\n\t\tif (!bh) {\n\t\t\treturn 1;\n\t\t} else if (ident != TAG_IDENT_FSD) {\n\t\t\tbrelse(bh);\n\t\t\treturn 1;\n\t\t}\n\n\t}\n\n\tsbi = UDF_SB(sb);\n\tif (!bh) {\n\t\t/* Search backwards through the partitions */\n\t\tstruct kernel_lb_addr newfileset;\n\n/* --> cvg: FIXME - is it reasonable? */\n\t\treturn 1;\n\n\t\tfor (newfileset.partitionReferenceNum = sbi->s_partitions - 1;\n\t\t     (newfileset.partitionReferenceNum != 0xFFFF &&\n\t\t      fileset->logicalBlockNum == 0xFFFFFFFF &&\n\t\t      fileset->partitionReferenceNum == 0xFFFF);\n\t\t     newfileset.partitionReferenceNum--) {\n\t\t\tlastblock = sbi->s_partmaps\n\t\t\t\t\t[newfileset.partitionReferenceNum]\n\t\t\t\t\t\t.s_partition_len;\n\t\t\tnewfileset.logicalBlockNum = 0;\n\n\t\t\tdo {\n\t\t\t\tbh = udf_read_ptagged(sb, &newfileset, 0,\n\t\t\t\t\t\t      &ident);\n\t\t\t\tif (!bh) {\n\t\t\t\t\tnewfileset.logicalBlockNum++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tswitch (ident) {\n\t\t\t\tcase TAG_IDENT_SBD:\n\t\t\t\t{\n\t\t\t\t\tstruct spaceBitmapDesc *sp;\n\t\t\t\t\tsp = (struct spaceBitmapDesc *)\n\t\t\t\t\t\t\t\tbh->b_data;\n\t\t\t\t\tnewfileset.logicalBlockNum += 1 +\n\t\t\t\t\t\t((le32_to_cpu(sp->numOfBytes) +\n\t\t\t\t\t\t  sizeof(struct spaceBitmapDesc)\n\t\t\t\t\t\t  - 1) >> sb->s_blocksize_bits);\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase TAG_IDENT_FSD:\n\t\t\t\t\t*fileset = newfileset;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tnewfileset.logicalBlockNum++;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tbh = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (newfileset.logicalBlockNum < lastblock &&\n\t\t\t\t fileset->logicalBlockNum == 0xFFFFFFFF &&\n\t\t\t\t fileset->partitionReferenceNum == 0xFFFF);\n\t\t}\n\t}\n\n\tif ((fileset->logicalBlockNum != 0xFFFFFFFF ||\n\t     fileset->partitionReferenceNum != 0xFFFF) && bh) {\n\t\tudf_debug(\"Fileset at block=%d, partition=%d\\n\",\n\t\t\t  fileset->logicalBlockNum,\n\t\t\t  fileset->partitionReferenceNum);\n\n\t\tsbi->s_partition = fileset->partitionReferenceNum;\n\t\tudf_load_fileset(sb, bh, root);\n\t\tbrelse(bh);\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_warn",
          "args": [
            "sb",
            "\"No partition found (2)\\n\""
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_SET_FLAG",
          "args": [
            "sb",
            "UDF_FLAG_USE_STREAMS"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SET_FLAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "174-177",
          "snippet": "static inline void UDF_SET_FLAG(struct super_block *sb, int flag)\n{\n\tset_bit(flag, &UDF_SB(sb)->s_flags);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline void UDF_SET_FLAG(struct super_block *sb, int flag)\n{\n\tset_bit(flag, &UDF_SB(sb)->s_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_sb_lvidiu",
          "args": [
            "sb"
          ],
          "line": 2157
        },
        "resolved": true,
        "details": {
          "function_name": "udf_sb_lvidiu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "100-120",
          "snippet": "struct logicalVolIntegrityDescImpUse *udf_sb_lvidiu(struct super_block *sb)\n{\n\tstruct logicalVolIntegrityDesc *lvid;\n\tunsigned int partnum;\n\tunsigned int offset;\n\n\tif (!UDF_SB(sb)->s_lvid_bh)\n\t\treturn NULL;\n\tlvid = (struct logicalVolIntegrityDesc *)UDF_SB(sb)->s_lvid_bh->b_data;\n\tpartnum = le32_to_cpu(lvid->numOfPartitions);\n\tif ((sb->s_blocksize - sizeof(struct logicalVolIntegrityDescImpUse) -\n\t     offsetof(struct logicalVolIntegrityDesc, impUse)) /\n\t     (2 * sizeof(uint32_t)) < partnum) {\n\t\tudf_err(sb, \"Logical volume integrity descriptor corrupted \"\n\t\t\t\"(numOfPartitions = %u)!\\n\", partnum);\n\t\treturn NULL;\n\t}\n\t/* The offset is to skip freeSpaceTable and sizeTable arrays */\n\toffset = partnum * 2 * sizeof(uint32_t);\n\treturn (struct logicalVolIntegrityDescImpUse *)&(lvid->impUse[offset]);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstruct logicalVolIntegrityDescImpUse *udf_sb_lvidiu(struct super_block *sb)\n{\n\tstruct logicalVolIntegrityDesc *lvid;\n\tunsigned int partnum;\n\tunsigned int offset;\n\n\tif (!UDF_SB(sb)->s_lvid_bh)\n\t\treturn NULL;\n\tlvid = (struct logicalVolIntegrityDesc *)UDF_SB(sb)->s_lvid_bh->b_data;\n\tpartnum = le32_to_cpu(lvid->numOfPartitions);\n\tif ((sb->s_blocksize - sizeof(struct logicalVolIntegrityDescImpUse) -\n\t     offsetof(struct logicalVolIntegrityDesc, impUse)) /\n\t     (2 * sizeof(uint32_t)) < partnum) {\n\t\tudf_err(sb, \"Logical volume integrity descriptor corrupted \"\n\t\t\t\"(numOfPartitions = %u)!\\n\", partnum);\n\t\treturn NULL;\n\t}\n\t/* The offset is to skip freeSpaceTable and sizeTable arrays */\n\toffset = partnum * 2 * sizeof(uint32_t);\n\treturn (struct logicalVolIntegrityDescImpUse *)&(lvid->impUse[offset]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Lastblock=%d\\n\"",
            "sbi->s_last_block"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_warn",
          "args": [
            "sb",
            "\"No partition found (1)\\n\""
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_load_vrs",
          "args": [
            "sb",
            "&uopt",
            "silent",
            "&fileset"
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "udf_load_vrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "1915-1955",
          "snippet": "static int udf_load_vrs(struct super_block *sb, struct udf_options *uopt,\n\t\t\tint silent, struct kernel_lb_addr *fileset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tloff_t nsr_off;\n\tint ret;\n\n\tif (!sb_set_blocksize(sb, uopt->blocksize)) {\n\t\tif (!silent)\n\t\t\tudf_warn(sb, \"Bad block size\\n\");\n\t\treturn -EINVAL;\n\t}\n\tsbi->s_last_block = uopt->lastblock;\n\tif (!uopt->novrs) {\n\t\t/* Check that it is NSR02 compliant */\n\t\tnsr_off = udf_check_vsd(sb);\n\t\tif (!nsr_off) {\n\t\t\tif (!silent)\n\t\t\t\tudf_warn(sb, \"No VRS found\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (nsr_off == -1)\n\t\t\tudf_debug(\"Failed to read sector at offset %d. \"\n\t\t\t\t  \"Assuming open disc. Skipping validity \"\n\t\t\t\t  \"check\\n\", VSD_FIRST_SECTOR_OFFSET);\n\t\tif (!sbi->s_last_block)\n\t\t\tsbi->s_last_block = udf_get_last_block(sb);\n\t} else {\n\t\tudf_debug(\"Validity check skipped because of novrs option\\n\");\n\t}\n\n\t/* Look for anchor block and load Volume Descriptor Sequence */\n\tsbi->s_anchor = uopt->anchor;\n\tret = udf_find_anchor(sb, fileset);\n\tif (ret < 0) {\n\t\tif (!silent && ret == -EAGAIN)\n\t\t\tudf_warn(sb, \"No anchor found\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [
            "#define VSD_FIRST_SECTOR_OFFSET\t\t32768"
          ],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
            "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\n#define VSD_FIRST_SECTOR_OFFSET\t\t32768\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_load_vrs(struct super_block *sb, struct udf_options *uopt,\n\t\t\tint silent, struct kernel_lb_addr *fileset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tloff_t nsr_off;\n\tint ret;\n\n\tif (!sb_set_blocksize(sb, uopt->blocksize)) {\n\t\tif (!silent)\n\t\t\tudf_warn(sb, \"Bad block size\\n\");\n\t\treturn -EINVAL;\n\t}\n\tsbi->s_last_block = uopt->lastblock;\n\tif (!uopt->novrs) {\n\t\t/* Check that it is NSR02 compliant */\n\t\tnsr_off = udf_check_vsd(sb);\n\t\tif (!nsr_off) {\n\t\t\tif (!silent)\n\t\t\t\tudf_warn(sb, \"No VRS found\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (nsr_off == -1)\n\t\t\tudf_debug(\"Failed to read sector at offset %d. \"\n\t\t\t\t  \"Assuming open disc. Skipping validity \"\n\t\t\t\t  \"check\\n\", VSD_FIRST_SECTOR_OFFSET);\n\t\tif (!sbi->s_last_block)\n\t\t\tsbi->s_last_block = udf_get_last_block(sb);\n\t} else {\n\t\tudf_debug(\"Validity check skipped because of novrs option\\n\");\n\t}\n\n\t/* Look for anchor block and load Volume Descriptor Sequence */\n\tsbi->s_anchor = uopt->anchor;\n\tret = udf_find_anchor(sb, fileset);\n\tif (ret < 0) {\n\t\tif (!silent && ret == -EAGAIN)\n\t\t\tudf_warn(sb, \"No anchor found\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"Rescanning with blocksize %d\\n\"",
            "UDF_DEFAULT_BLOCKSIZE"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "sb->s_bdev"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Multi-session=%d\\n\"",
            "sbi->s_session"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_get_last_session",
          "args": [
            "sb"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_last_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/lowlevel.c",
          "lines": "28-48",
          "snippet": "unsigned int udf_get_last_session(struct super_block *sb)\n{\n\tstruct cdrom_multisession ms_info;\n\tunsigned int vol_desc_start;\n\tstruct block_device *bdev = sb->s_bdev;\n\tint i;\n\n\tvol_desc_start = 0;\n\tms_info.addr_format = CDROM_LBA;\n\ti = ioctl_by_bdev(bdev, CDROMMULTISESSION, (unsigned long)&ms_info);\n\n\tif (i == 0) {\n\t\tudf_debug(\"XA disk: %s, vol_desc_start=%d\\n\",\n\t\t\t  ms_info.xa_flag ? \"yes\" : \"no\", ms_info.addr.lba);\n\t\tif (ms_info.xa_flag) /* necessary for a valid ms_info.addr */\n\t\t\tvol_desc_start = ms_info.addr.lba;\n\t} else {\n\t\tudf_debug(\"CDROMMULTISESSION not supported: rc=%d\\n\", i);\n\t}\n\treturn vol_desc_start;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include <linux/uaccess.h>\n#include <linux/cdrom.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nunsigned int udf_get_last_session(struct super_block *sb)\n{\n\tstruct cdrom_multisession ms_info;\n\tunsigned int vol_desc_start;\n\tstruct block_device *bdev = sb->s_bdev;\n\tint i;\n\n\tvol_desc_start = 0;\n\tms_info.addr_format = CDROM_LBA;\n\ti = ioctl_by_bdev(bdev, CDROMMULTISESSION, (unsigned long)&ms_info);\n\n\tif (i == 0) {\n\t\tudf_debug(\"XA disk: %s, vol_desc_start=%d\\n\",\n\t\t\t  ms_info.xa_flag ? \"yes\" : \"no\", ms_info.addr.lba);\n\t\tif (ms_info.xa_flag) /* necessary for a valid ms_info.addr */\n\t\t\tvol_desc_start = ms_info.addr.lba;\n\t} else {\n\t\tudf_debug(\"CDROMMULTISESSION not supported: rc=%d\\n\", i);\n\t}\n\treturn vol_desc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rwlock_init",
          "args": [
            "&sbi->s_cred_lock"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Using default NLS map\\n\""
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_nls_default",
          "args": [],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "load_nls_default",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "532-541",
          "snippet": "struct nls_table *load_nls_default(void)\n{\n\tstruct nls_table *default_nls;\n\t\n\tdefault_nls = load_nls(CONFIG_NLS_DEFAULT);\n\tif (default_nls != NULL)\n\t\treturn default_nls;\n\telse\n\t\treturn &default_table;\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nls_table default_table;",
            "static struct nls_table default_table = {\n\t.charset\t= \"default\",\n\t.uni2char\t= uni2char,\n\t.char2uni\t= char2uni,\n\t.charset2lower\t= charset2lower,\n\t.charset2upper\t= charset2upper,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct nls_table default_table;\nstatic struct nls_table default_table = {\n\t.charset\t= \"default\",\n\t.uni2char\t= uni2char,\n\t.char2uni\t= char2uni,\n\t.charset2lower\t= charset2lower,\n\t.charset2upper\t= charset2upper,\n};\n\nstruct nls_table *load_nls_default(void)\n{\n\tstruct nls_table *default_nls;\n\t\n\tdefault_nls = load_nls(CONFIG_NLS_DEFAULT);\n\tif (default_nls != NULL)\n\t\treturn default_nls;\n\telse\n\t\treturn &default_table;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_err",
          "args": [
            "sb",
            "\"utf8 cannot be combined with iocharset\\n\""
          ],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_parse_options",
          "args": [
            "(char *)options",
            "&uopt",
            "false"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "udf_parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "486-644",
          "snippet": "static int udf_parse_options(char *options, struct udf_options *uopt,\n\t\t\t     bool remount)\n{\n\tchar *p;\n\tint option;\n\n\tuopt->novrs = 0;\n\tuopt->partition = 0xFFFF;\n\tuopt->session = 0xFFFFFFFF;\n\tuopt->lastblock = 0;\n\tuopt->anchor = 0;\n\tuopt->volume = 0xFFFFFFFF;\n\tuopt->rootdir = 0xFFFFFFFF;\n\tuopt->fileset = 0xFFFFFFFF;\n\tuopt->nls_map = NULL;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tunsigned n;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_novrs:\n\t\t\tuopt->novrs = 1;\n\t\t\tbreak;\n\t\tcase Opt_bs:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tn = option;\n\t\t\tif (n != 512 && n != 1024 && n != 2048 && n != 4096)\n\t\t\t\treturn 0;\n\t\t\tuopt->blocksize = n;\n\t\t\tuopt->flags |= (1 << UDF_FLAG_BLOCKSIZE_SET);\n\t\t\tbreak;\n\t\tcase Opt_unhide:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UNHIDE);\n\t\t\tbreak;\n\t\tcase Opt_undelete:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UNDELETE);\n\t\t\tbreak;\n\t\tcase Opt_noadinicb:\n\t\t\tuopt->flags &= ~(1 << UDF_FLAG_USE_AD_IN_ICB);\n\t\t\tbreak;\n\t\tcase Opt_adinicb:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_USE_AD_IN_ICB);\n\t\t\tbreak;\n\t\tcase Opt_shortad:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_USE_SHORT_AD);\n\t\t\tbreak;\n\t\tcase Opt_longad:\n\t\t\tuopt->flags &= ~(1 << UDF_FLAG_USE_SHORT_AD);\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(uopt->gid))\n\t\t\t\treturn 0;\n\t\t\tuopt->flags |= (1 << UDF_FLAG_GID_SET);\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uopt->uid))\n\t\t\t\treturn 0;\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UID_SET);\n\t\t\tbreak;\n\t\tcase Opt_umask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->umask = option;\n\t\t\tbreak;\n\t\tcase Opt_nostrict:\n\t\t\tuopt->flags &= ~(1 << UDF_FLAG_STRICT);\n\t\t\tbreak;\n\t\tcase Opt_session:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->session = option;\n\t\t\tif (!remount)\n\t\t\t\tuopt->flags |= (1 << UDF_FLAG_SESSION_SET);\n\t\t\tbreak;\n\t\tcase Opt_lastblock:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->lastblock = option;\n\t\t\tif (!remount)\n\t\t\t\tuopt->flags |= (1 << UDF_FLAG_LASTBLOCK_SET);\n\t\t\tbreak;\n\t\tcase Opt_anchor:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->anchor = option;\n\t\t\tbreak;\n\t\tcase Opt_volume:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->volume = option;\n\t\t\tbreak;\n\t\tcase Opt_partition:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->partition = option;\n\t\t\tbreak;\n\t\tcase Opt_fileset:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->fileset = option;\n\t\t\tbreak;\n\t\tcase Opt_rootdir:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->rootdir = option;\n\t\t\tbreak;\n\t\tcase Opt_utf8:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UTF8);\n\t\t\tbreak;\n#ifdef CONFIG_UDF_NLS\n\t\tcase Opt_iocharset:\n\t\t\tuopt->nls_map = load_nls(args[0].from);\n\t\t\tuopt->flags |= (1 << UDF_FLAG_NLS_MAP);\n\t\t\tbreak;\n#endif\n\t\tcase Opt_uignore:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UID_IGNORE);\n\t\t\tbreak;\n\t\tcase Opt_uforget:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UID_FORGET);\n\t\t\tbreak;\n\t\tcase Opt_gignore:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_GID_IGNORE);\n\t\t\tbreak;\n\t\tcase Opt_gforget:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_GID_FORGET);\n\t\t\tbreak;\n\t\tcase Opt_fmode:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->fmode = option & 0777;\n\t\t\tbreak;\n\t\tcase Opt_dmode:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->dmode = option & 0777;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"bad mount option \\\"%s\\\" or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_novrs,\t\"novrs\"},\n\t{Opt_nostrict,\t\"nostrict\"},\n\t{Opt_bs,\t\"bs=%u\"},\n\t{Opt_unhide,\t\"unhide\"},\n\t{Opt_undelete,\t\"undelete\"},\n\t{Opt_noadinicb,\t\"noadinicb\"},\n\t{Opt_adinicb,\t\"adinicb\"},\n\t{Opt_shortad,\t\"shortad\"},\n\t{Opt_longad,\t\"longad\"},\n\t{Opt_uforget,\t\"uid=forget\"},\n\t{Opt_uignore,\t\"uid=ignore\"},\n\t{Opt_gforget,\t\"gid=forget\"},\n\t{Opt_gignore,\t\"gid=ignore\"},\n\t{Opt_gid,\t\"gid=%u\"},\n\t{Opt_uid,\t\"uid=%u\"},\n\t{Opt_umask,\t\"umask=%o\"},\n\t{Opt_session,\t\"session=%u\"},\n\t{Opt_lastblock,\t\"lastblock=%u\"},\n\t{Opt_anchor,\t\"anchor=%u\"},\n\t{Opt_volume,\t\"volume=%u\"},\n\t{Opt_partition,\t\"partition=%u\"},\n\t{Opt_fileset,\t\"fileset=%u\"},\n\t{Opt_rootdir,\t\"rootdir=%u\"},\n\t{Opt_utf8,\t\"utf8\"},\n\t{Opt_iocharset,\t\"iocharset=%s\"},\n\t{Opt_fmode,     \"mode=%o\"},\n\t{Opt_dmode,     \"dmode=%o\"},\n\t{Opt_err,\tNULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic const match_table_t tokens = {\n\t{Opt_novrs,\t\"novrs\"},\n\t{Opt_nostrict,\t\"nostrict\"},\n\t{Opt_bs,\t\"bs=%u\"},\n\t{Opt_unhide,\t\"unhide\"},\n\t{Opt_undelete,\t\"undelete\"},\n\t{Opt_noadinicb,\t\"noadinicb\"},\n\t{Opt_adinicb,\t\"adinicb\"},\n\t{Opt_shortad,\t\"shortad\"},\n\t{Opt_longad,\t\"longad\"},\n\t{Opt_uforget,\t\"uid=forget\"},\n\t{Opt_uignore,\t\"uid=ignore\"},\n\t{Opt_gforget,\t\"gid=forget\"},\n\t{Opt_gignore,\t\"gid=ignore\"},\n\t{Opt_gid,\t\"gid=%u\"},\n\t{Opt_uid,\t\"uid=%u\"},\n\t{Opt_umask,\t\"umask=%o\"},\n\t{Opt_session,\t\"session=%u\"},\n\t{Opt_lastblock,\t\"lastblock=%u\"},\n\t{Opt_anchor,\t\"anchor=%u\"},\n\t{Opt_volume,\t\"volume=%u\"},\n\t{Opt_partition,\t\"partition=%u\"},\n\t{Opt_fileset,\t\"fileset=%u\"},\n\t{Opt_rootdir,\t\"rootdir=%u\"},\n\t{Opt_utf8,\t\"utf8\"},\n\t{Opt_iocharset,\t\"iocharset=%s\"},\n\t{Opt_fmode,     \"mode=%o\"},\n\t{Opt_dmode,     \"dmode=%o\"},\n\t{Opt_err,\tNULL}\n};\n\nstatic int udf_parse_options(char *options, struct udf_options *uopt,\n\t\t\t     bool remount)\n{\n\tchar *p;\n\tint option;\n\n\tuopt->novrs = 0;\n\tuopt->partition = 0xFFFF;\n\tuopt->session = 0xFFFFFFFF;\n\tuopt->lastblock = 0;\n\tuopt->anchor = 0;\n\tuopt->volume = 0xFFFFFFFF;\n\tuopt->rootdir = 0xFFFFFFFF;\n\tuopt->fileset = 0xFFFFFFFF;\n\tuopt->nls_map = NULL;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tunsigned n;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_novrs:\n\t\t\tuopt->novrs = 1;\n\t\t\tbreak;\n\t\tcase Opt_bs:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tn = option;\n\t\t\tif (n != 512 && n != 1024 && n != 2048 && n != 4096)\n\t\t\t\treturn 0;\n\t\t\tuopt->blocksize = n;\n\t\t\tuopt->flags |= (1 << UDF_FLAG_BLOCKSIZE_SET);\n\t\t\tbreak;\n\t\tcase Opt_unhide:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UNHIDE);\n\t\t\tbreak;\n\t\tcase Opt_undelete:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UNDELETE);\n\t\t\tbreak;\n\t\tcase Opt_noadinicb:\n\t\t\tuopt->flags &= ~(1 << UDF_FLAG_USE_AD_IN_ICB);\n\t\t\tbreak;\n\t\tcase Opt_adinicb:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_USE_AD_IN_ICB);\n\t\t\tbreak;\n\t\tcase Opt_shortad:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_USE_SHORT_AD);\n\t\t\tbreak;\n\t\tcase Opt_longad:\n\t\t\tuopt->flags &= ~(1 << UDF_FLAG_USE_SHORT_AD);\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(uopt->gid))\n\t\t\t\treturn 0;\n\t\t\tuopt->flags |= (1 << UDF_FLAG_GID_SET);\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uopt->uid))\n\t\t\t\treturn 0;\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UID_SET);\n\t\t\tbreak;\n\t\tcase Opt_umask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->umask = option;\n\t\t\tbreak;\n\t\tcase Opt_nostrict:\n\t\t\tuopt->flags &= ~(1 << UDF_FLAG_STRICT);\n\t\t\tbreak;\n\t\tcase Opt_session:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->session = option;\n\t\t\tif (!remount)\n\t\t\t\tuopt->flags |= (1 << UDF_FLAG_SESSION_SET);\n\t\t\tbreak;\n\t\tcase Opt_lastblock:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->lastblock = option;\n\t\t\tif (!remount)\n\t\t\t\tuopt->flags |= (1 << UDF_FLAG_LASTBLOCK_SET);\n\t\t\tbreak;\n\t\tcase Opt_anchor:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->anchor = option;\n\t\t\tbreak;\n\t\tcase Opt_volume:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->volume = option;\n\t\t\tbreak;\n\t\tcase Opt_partition:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->partition = option;\n\t\t\tbreak;\n\t\tcase Opt_fileset:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->fileset = option;\n\t\t\tbreak;\n\t\tcase Opt_rootdir:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->rootdir = option;\n\t\t\tbreak;\n\t\tcase Opt_utf8:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UTF8);\n\t\t\tbreak;\n#ifdef CONFIG_UDF_NLS\n\t\tcase Opt_iocharset:\n\t\t\tuopt->nls_map = load_nls(args[0].from);\n\t\t\tuopt->flags |= (1 << UDF_FLAG_NLS_MAP);\n\t\t\tbreak;\n#endif\n\t\tcase Opt_uignore:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UID_IGNORE);\n\t\t\tbreak;\n\t\tcase Opt_uforget:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UID_FORGET);\n\t\t\tbreak;\n\t\tcase Opt_gignore:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_GID_IGNORE);\n\t\t\tbreak;\n\t\tcase Opt_gforget:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_GID_FORGET);\n\t\t\tbreak;\n\t\tcase Opt_fmode:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->fmode = option & 0777;\n\t\t\tbreak;\n\t\tcase Opt_dmode:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->dmode = option & 0777;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"bad mount option \\\"%s\\\" or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct udf_sb_info)",
            "GFP_KERNEL"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\n#define UDF_DEFAULT_BLOCKSIZE 2048\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\nstatic int udf_show_options(struct seq_file *, struct dentry *);\nstatic const struct super_operations udf_sb_ops = {\n\t.alloc_inode\t= udf_alloc_inode,\n\t.destroy_inode\t= udf_destroy_inode,\n\t.write_inode\t= udf_write_inode,\n\t.evict_inode\t= udf_evict_inode,\n\t.put_super\t= udf_put_super,\n\t.sync_fs\t= udf_sync_fs,\n\t.statfs\t\t= udf_statfs,\n\t.remount_fs\t= udf_remount_fs,\n\t.show_options\t= udf_show_options,\n};\n\nstatic int udf_fill_super(struct super_block *sb, void *options, int silent)\n{\n\tint ret = -EINVAL;\n\tstruct inode *inode = NULL;\n\tstruct udf_options uopt;\n\tstruct kernel_lb_addr rootdir, fileset;\n\tstruct udf_sb_info *sbi;\n\n\tuopt.flags = (1 << UDF_FLAG_USE_AD_IN_ICB) | (1 << UDF_FLAG_STRICT);\n\tuopt.uid = INVALID_UID;\n\tuopt.gid = INVALID_GID;\n\tuopt.umask = 0;\n\tuopt.fmode = UDF_INVALID_MODE;\n\tuopt.dmode = UDF_INVALID_MODE;\n\n\tsbi = kzalloc(sizeof(struct udf_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = sbi;\n\n\tmutex_init(&sbi->s_alloc_mutex);\n\n\tif (!udf_parse_options((char *)options, &uopt, false))\n\t\tgoto parse_options_failure;\n\n\tif (uopt.flags & (1 << UDF_FLAG_UTF8) &&\n\t    uopt.flags & (1 << UDF_FLAG_NLS_MAP)) {\n\t\tudf_err(sb, \"utf8 cannot be combined with iocharset\\n\");\n\t\tgoto parse_options_failure;\n\t}\n#ifdef CONFIG_UDF_NLS\n\tif ((uopt.flags & (1 << UDF_FLAG_NLS_MAP)) && !uopt.nls_map) {\n\t\tuopt.nls_map = load_nls_default();\n\t\tif (!uopt.nls_map)\n\t\t\tuopt.flags &= ~(1 << UDF_FLAG_NLS_MAP);\n\t\telse\n\t\t\tudf_debug(\"Using default NLS map\\n\");\n\t}\n#endif\n\tif (!(uopt.flags & (1 << UDF_FLAG_NLS_MAP)))\n\t\tuopt.flags |= (1 << UDF_FLAG_UTF8);\n\n\tfileset.logicalBlockNum = 0xFFFFFFFF;\n\tfileset.partitionReferenceNum = 0xFFFF;\n\n\tsbi->s_flags = uopt.flags;\n\tsbi->s_uid = uopt.uid;\n\tsbi->s_gid = uopt.gid;\n\tsbi->s_umask = uopt.umask;\n\tsbi->s_fmode = uopt.fmode;\n\tsbi->s_dmode = uopt.dmode;\n\tsbi->s_nls_map = uopt.nls_map;\n\trwlock_init(&sbi->s_cred_lock);\n\n\tif (uopt.session == 0xFFFFFFFF)\n\t\tsbi->s_session = udf_get_last_session(sb);\n\telse\n\t\tsbi->s_session = uopt.session;\n\n\tudf_debug(\"Multi-session=%d\\n\", sbi->s_session);\n\n\t/* Fill in the rest of the superblock */\n\tsb->s_op = &udf_sb_ops;\n\tsb->s_export_op = &udf_export_ops;\n\n\tsb->s_magic = UDF_SUPER_MAGIC;\n\tsb->s_time_gran = 1000;\n\n\tif (uopt.flags & (1 << UDF_FLAG_BLOCKSIZE_SET)) {\n\t\tret = udf_load_vrs(sb, &uopt, silent, &fileset);\n\t} else {\n\t\tuopt.blocksize = bdev_logical_block_size(sb->s_bdev);\n\t\tret = udf_load_vrs(sb, &uopt, silent, &fileset);\n\t\tif (ret == -EAGAIN && uopt.blocksize != UDF_DEFAULT_BLOCKSIZE) {\n\t\t\tif (!silent)\n\t\t\t\tpr_notice(\"Rescanning with blocksize %d\\n\",\n\t\t\t\t\t  UDF_DEFAULT_BLOCKSIZE);\n\t\t\tbrelse(sbi->s_lvid_bh);\n\t\t\tsbi->s_lvid_bh = NULL;\n\t\t\tuopt.blocksize = UDF_DEFAULT_BLOCKSIZE;\n\t\t\tret = udf_load_vrs(sb, &uopt, silent, &fileset);\n\t\t}\n\t}\n\tif (ret < 0) {\n\t\tif (ret == -EAGAIN) {\n\t\t\tudf_warn(sb, \"No partition found (1)\\n\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tgoto error_out;\n\t}\n\n\tudf_debug(\"Lastblock=%d\\n\", sbi->s_last_block);\n\n\tif (sbi->s_lvid_bh) {\n\t\tstruct logicalVolIntegrityDescImpUse *lvidiu =\n\t\t\t\t\t\t\tudf_sb_lvidiu(sb);\n\t\tuint16_t minUDFReadRev;\n\t\tuint16_t minUDFWriteRev;\n\n\t\tif (!lvidiu) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto error_out;\n\t\t}\n\t\tminUDFReadRev = le16_to_cpu(lvidiu->minUDFReadRev);\n\t\tminUDFWriteRev = le16_to_cpu(lvidiu->minUDFWriteRev);\n\t\tif (minUDFReadRev > UDF_MAX_READ_VERSION) {\n\t\t\tudf_err(sb, \"minUDFReadRev=%x (max is %x)\\n\",\n\t\t\t\tminUDFReadRev,\n\t\t\t\tUDF_MAX_READ_VERSION);\n\t\t\tret = -EINVAL;\n\t\t\tgoto error_out;\n\t\t} else if (minUDFWriteRev > UDF_MAX_WRITE_VERSION &&\n\t\t\t   !(sb->s_flags & MS_RDONLY)) {\n\t\t\tret = -EACCES;\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tsbi->s_udfrev = minUDFWriteRev;\n\n\t\tif (minUDFReadRev >= UDF_VERS_USE_EXTENDED_FE)\n\t\t\tUDF_SET_FLAG(sb, UDF_FLAG_USE_EXTENDED_FE);\n\t\tif (minUDFReadRev >= UDF_VERS_USE_STREAMS)\n\t\t\tUDF_SET_FLAG(sb, UDF_FLAG_USE_STREAMS);\n\t}\n\n\tif (!sbi->s_partitions) {\n\t\tudf_warn(sb, \"No partition found (2)\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error_out;\n\t}\n\n\tif (sbi->s_partmaps[sbi->s_partition].s_partition_flags &\n\t\t\tUDF_PART_FLAG_READ_ONLY &&\n\t    !(sb->s_flags & MS_RDONLY)) {\n\t\tret = -EACCES;\n\t\tgoto error_out;\n\t}\n\n\tif (udf_find_fileset(sb, &fileset, &rootdir)) {\n\t\tudf_warn(sb, \"No fileset found\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error_out;\n\t}\n\n\tif (!silent) {\n\t\tstruct timestamp ts;\n\t\tudf_time_to_disk_stamp(&ts, sbi->s_record_time);\n\t\tudf_info(\"Mounting volume '%s', timestamp %04u/%02u/%02u %02u:%02u (%x)\\n\",\n\t\t\t sbi->s_volume_ident,\n\t\t\t le16_to_cpu(ts.year), ts.month, ts.day,\n\t\t\t ts.hour, ts.minute, le16_to_cpu(ts.typeAndTimezone));\n\t}\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tudf_open_lvid(sb);\n\n\t/* Assign the root inode */\n\t/* assign inodes by physical block number */\n\t/* perhaps it's not extensible enough, but for now ... */\n\tinode = udf_iget(sb, &rootdir);\n\tif (IS_ERR(inode)) {\n\t\tudf_err(sb, \"Error in udf_iget, block=%d, partition=%d\\n\",\n\t\t       rootdir.logicalBlockNum, rootdir.partitionReferenceNum);\n\t\tret = PTR_ERR(inode);\n\t\tgoto error_out;\n\t}\n\n\t/* Allocate a dentry for the root inode */\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root) {\n\t\tudf_err(sb, \"Couldn't allocate root dentry\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error_out;\n\t}\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_max_links = UDF_MAX_LINKS;\n\treturn 0;\n\nerror_out:\n\tiput(sbi->s_vat_inode);\nparse_options_failure:\n#ifdef CONFIG_UDF_NLS\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP))\n\t\tunload_nls(sbi->s_nls_map);\n#endif\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tudf_close_lvid(sb);\n\tbrelse(sbi->s_lvid_bh);\n\tudf_sb_free_partitions(sb);\n\tkfree(sbi);\n\tsb->s_fs_info = NULL;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "lvid_get_unique_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "2034-2059",
    "snippet": "u64 lvid_get_unique_id(struct super_block *sb)\n{\n\tstruct buffer_head *bh;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\tstruct logicalVolHeaderDesc *lvhd;\n\tu64 uniqueID;\n\tu64 ret;\n\n\tbh = sbi->s_lvid_bh;\n\tif (!bh)\n\t\treturn 0;\n\n\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\tlvhd = (struct logicalVolHeaderDesc *)lvid->logicalVolContentsUse;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tret = uniqueID = le64_to_cpu(lvhd->uniqueID);\n\tif (!(++uniqueID & 0xFFFFFFFF))\n\t\tuniqueID += 16;\n\tlvhd->uniqueID = cpu_to_le64(uniqueID);\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\tmark_buffer_dirty(bh);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "uniqueID"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "lvhd->uniqueID"
          ],
          "line": 2051
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nu64 lvid_get_unique_id(struct super_block *sb)\n{\n\tstruct buffer_head *bh;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\tstruct logicalVolHeaderDesc *lvhd;\n\tu64 uniqueID;\n\tu64 ret;\n\n\tbh = sbi->s_lvid_bh;\n\tif (!bh)\n\t\treturn 0;\n\n\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\tlvhd = (struct logicalVolHeaderDesc *)lvid->logicalVolContentsUse;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tret = uniqueID = le64_to_cpu(lvhd->uniqueID);\n\tif (!(++uniqueID & 0xFFFFFFFF))\n\t\tuniqueID += 16;\n\tlvhd->uniqueID = cpu_to_le64(uniqueID);\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\tmark_buffer_dirty(bh);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "udf_close_lvid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "1990-2032",
    "snippet": "static void udf_close_lvid(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct buffer_head *bh = sbi->s_lvid_bh;\n\tstruct logicalVolIntegrityDesc *lvid;\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\n\tif (!bh)\n\t\treturn;\n\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (!lvidiu)\n\t\treturn;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tlvidiu->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\tlvidiu->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\tudf_time_to_disk_stamp(&lvid->recordingDateAndTime, CURRENT_TIME);\n\tif (UDF_MAX_WRITE_VERSION > le16_to_cpu(lvidiu->maxUDFWriteRev))\n\t\tlvidiu->maxUDFWriteRev = cpu_to_le16(UDF_MAX_WRITE_VERSION);\n\tif (sbi->s_udfrev > le16_to_cpu(lvidiu->minUDFReadRev))\n\t\tlvidiu->minUDFReadRev = cpu_to_le16(sbi->s_udfrev);\n\tif (sbi->s_udfrev > le16_to_cpu(lvidiu->minUDFWriteRev))\n\t\tlvidiu->minUDFWriteRev = cpu_to_le16(sbi->s_udfrev);\n\tlvid->integrityType = cpu_to_le32(LVID_INTEGRITY_TYPE_CLOSE);\n\n\tlvid->descTag.descCRC = cpu_to_le16(\n\t\t\tcrc_itu_t(0, (char *)lvid + sizeof(struct tag),\n\t\t\t\tle16_to_cpu(lvid->descTag.descCRCLength)));\n\n\tlvid->descTag.tagChecksum = udf_tag_checksum(&lvid->descTag);\n\t/*\n\t * We set buffer uptodate unconditionally here to avoid spurious\n\t * warnings from mark_buffer_dirty() when previous EIO has marked\n\t * the buffer as !uptodate\n\t */\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\tsbi->s_lvid_dirty = 0;\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t/* Make closing of filesystem visible on the media immediately */\n\tsync_dirty_buffer(bh);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 2026
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_tag_checksum",
          "args": [
            "&lvid->descTag"
          ],
          "line": 2020
        },
        "resolved": true,
        "details": {
          "function_name": "udf_tag_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "290-299",
          "snippet": "u8 udf_tag_checksum(const struct tag *t)\n{\n\tu8 *data = (u8 *)t;\n\tu8 checksum = 0;\n\tint i;\n\tfor (i = 0; i < sizeof(struct tag); ++i)\n\t\tif (i != 4) /* position of checksum */\n\t\t\tchecksum += data[i];\n\treturn checksum;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nu8 udf_tag_checksum(const struct tag *t)\n{\n\tu8 *data = (u8 *)t;\n\tu8 checksum = 0;\n\tint i;\n\tfor (i = 0; i < sizeof(struct tag); ++i)\n\t\tif (i != 4) /* position of checksum */\n\t\t\tchecksum += data[i];\n\treturn checksum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "crc_itu_t(0, (char *)lvid + sizeof(struct tag),\n\t\t\t\tle16_to_cpu(lvid->descTag.descCRCLength))"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc_itu_t",
          "args": [
            "0",
            "(char *)lvid + sizeof(struct tag)",
            "le16_to_cpu(lvid->descTag.descCRCLength)"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "lvid->descTag.descCRCLength"
          ],
          "line": 2018
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "LVID_INTEGRITY_TYPE_CLOSE"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sbi->s_udfrev"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sbi->s_udfrev"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "UDF_MAX_WRITE_VERSION"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_time_to_disk_stamp",
          "args": [
            "&lvid->recordingDateAndTime",
            "CURRENT_TIME"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "udf_time_to_disk_stamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udftime.c",
          "lines": "119-168",
          "snippet": "struct timestamp *\nudf_time_to_disk_stamp(struct timestamp *dest, struct timespec ts)\n{\n\tlong int days, rem, y;\n\tconst unsigned short int *ip;\n\tint16_t offset;\n\n\toffset = -sys_tz.tz_minuteswest;\n\n\tif (!dest)\n\t\treturn NULL;\n\n\tdest->typeAndTimezone = cpu_to_le16(0x1000 | (offset & 0x0FFF));\n\n\tts.tv_sec += offset * 60;\n\tdays = ts.tv_sec / SECS_PER_DAY;\n\trem = ts.tv_sec % SECS_PER_DAY;\n\tdest->hour = rem / SECS_PER_HOUR;\n\trem %= SECS_PER_HOUR;\n\tdest->minute = rem / 60;\n\tdest->second = rem % 60;\n\ty = 1970;\n\n#define DIV(a, b) ((a) / (b) - ((a) % (b) < 0))\n#define LEAPS_THRU_END_OF(y) (DIV (y, 4) - DIV (y, 100) + DIV (y, 400))\n\n\twhile (days < 0 || days >= (__isleap(y) ? 366 : 365)) {\n\t\tlong int yg = y + days / 365 - (days % 365 < 0);\n\n\t\t/* Adjust DAYS and Y to match the guessed year.  */\n\t\tdays -= ((yg - y) * 365\n\t\t\t + LEAPS_THRU_END_OF(yg - 1)\n\t\t\t - LEAPS_THRU_END_OF(y - 1));\n\t\ty = yg;\n\t}\n\tdest->year = cpu_to_le16(y);\n\tip = __mon_yday[__isleap(y)];\n\tfor (y = 11; days < (long int)ip[y]; --y)\n\t\tcontinue;\n\tdays -= ip[y];\n\tdest->month = y + 1;\n\tdest->day = days + 1;\n\n\tdest->centiseconds = ts.tv_nsec / 10000000;\n\tdest->hundredsOfMicroseconds = (ts.tv_nsec / 1000 -\n\t\t\t\t\tdest->centiseconds * 10000) / 100;\n\tdest->microseconds = (ts.tv_nsec / 1000 - dest->centiseconds * 10000 -\n\t\t\t      dest->hundredsOfMicroseconds * 100);\n\treturn dest;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [
            "#define SECS_PER_DAY\t(SECS_PER_HOUR * 24)",
            "#define SECS_PER_HOUR\t(60 * 60)"
          ],
          "globals_used": [
            "static const unsigned short int __mon_yday[2][13] = {\n\t/* Normal years.  */\n\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t/* Leap years.  */\n\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/types.h>\n#include \"udfdecl.h\"\n\n#define SECS_PER_DAY\t(SECS_PER_HOUR * 24)\n#define SECS_PER_HOUR\t(60 * 60)\n\nstatic const unsigned short int __mon_yday[2][13] = {\n\t/* Normal years.  */\n\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t/* Leap years.  */\n\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}\n};\n\nstruct timestamp *\nudf_time_to_disk_stamp(struct timestamp *dest, struct timespec ts)\n{\n\tlong int days, rem, y;\n\tconst unsigned short int *ip;\n\tint16_t offset;\n\n\toffset = -sys_tz.tz_minuteswest;\n\n\tif (!dest)\n\t\treturn NULL;\n\n\tdest->typeAndTimezone = cpu_to_le16(0x1000 | (offset & 0x0FFF));\n\n\tts.tv_sec += offset * 60;\n\tdays = ts.tv_sec / SECS_PER_DAY;\n\trem = ts.tv_sec % SECS_PER_DAY;\n\tdest->hour = rem / SECS_PER_HOUR;\n\trem %= SECS_PER_HOUR;\n\tdest->minute = rem / 60;\n\tdest->second = rem % 60;\n\ty = 1970;\n\n#define DIV(a, b) ((a) / (b) - ((a) % (b) < 0))\n#define LEAPS_THRU_END_OF(y) (DIV (y, 4) - DIV (y, 100) + DIV (y, 400))\n\n\twhile (days < 0 || days >= (__isleap(y) ? 366 : 365)) {\n\t\tlong int yg = y + days / 365 - (days % 365 < 0);\n\n\t\t/* Adjust DAYS and Y to match the guessed year.  */\n\t\tdays -= ((yg - y) * 365\n\t\t\t + LEAPS_THRU_END_OF(yg - 1)\n\t\t\t - LEAPS_THRU_END_OF(y - 1));\n\t\ty = yg;\n\t}\n\tdest->year = cpu_to_le16(y);\n\tip = __mon_yday[__isleap(y)];\n\tfor (y = 11; days < (long int)ip[y]; --y)\n\t\tcontinue;\n\tdays -= ip[y];\n\tdest->month = y + 1;\n\tdest->day = days + 1;\n\n\tdest->centiseconds = ts.tv_nsec / 10000000;\n\tdest->hundredsOfMicroseconds = (ts.tv_nsec / 1000 -\n\t\t\t\t\tdest->centiseconds * 10000) / 100;\n\tdest->microseconds = (ts.tv_nsec / 1000 - dest->centiseconds * 10000 -\n\t\t\t      dest->hundredsOfMicroseconds * 100);\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_sb_lvidiu",
          "args": [
            "sb"
          ],
          "line": 2000
        },
        "resolved": true,
        "details": {
          "function_name": "udf_sb_lvidiu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "100-120",
          "snippet": "struct logicalVolIntegrityDescImpUse *udf_sb_lvidiu(struct super_block *sb)\n{\n\tstruct logicalVolIntegrityDesc *lvid;\n\tunsigned int partnum;\n\tunsigned int offset;\n\n\tif (!UDF_SB(sb)->s_lvid_bh)\n\t\treturn NULL;\n\tlvid = (struct logicalVolIntegrityDesc *)UDF_SB(sb)->s_lvid_bh->b_data;\n\tpartnum = le32_to_cpu(lvid->numOfPartitions);\n\tif ((sb->s_blocksize - sizeof(struct logicalVolIntegrityDescImpUse) -\n\t     offsetof(struct logicalVolIntegrityDesc, impUse)) /\n\t     (2 * sizeof(uint32_t)) < partnum) {\n\t\tudf_err(sb, \"Logical volume integrity descriptor corrupted \"\n\t\t\t\"(numOfPartitions = %u)!\\n\", partnum);\n\t\treturn NULL;\n\t}\n\t/* The offset is to skip freeSpaceTable and sizeTable arrays */\n\toffset = partnum * 2 * sizeof(uint32_t);\n\treturn (struct logicalVolIntegrityDescImpUse *)&(lvid->impUse[offset]);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstruct logicalVolIntegrityDescImpUse *udf_sb_lvidiu(struct super_block *sb)\n{\n\tstruct logicalVolIntegrityDesc *lvid;\n\tunsigned int partnum;\n\tunsigned int offset;\n\n\tif (!UDF_SB(sb)->s_lvid_bh)\n\t\treturn NULL;\n\tlvid = (struct logicalVolIntegrityDesc *)UDF_SB(sb)->s_lvid_bh->b_data;\n\tpartnum = le32_to_cpu(lvid->numOfPartitions);\n\tif ((sb->s_blocksize - sizeof(struct logicalVolIntegrityDescImpUse) -\n\t     offsetof(struct logicalVolIntegrityDesc, impUse)) /\n\t     (2 * sizeof(uint32_t)) < partnum) {\n\t\tudf_err(sb, \"Logical volume integrity descriptor corrupted \"\n\t\t\t\"(numOfPartitions = %u)!\\n\", partnum);\n\t\treturn NULL;\n\t}\n\t/* The offset is to skip freeSpaceTable and sizeTable arrays */\n\toffset = partnum * 2 * sizeof(uint32_t);\n\treturn (struct logicalVolIntegrityDescImpUse *)&(lvid->impUse[offset]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic void udf_close_lvid(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct buffer_head *bh = sbi->s_lvid_bh;\n\tstruct logicalVolIntegrityDesc *lvid;\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\n\tif (!bh)\n\t\treturn;\n\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (!lvidiu)\n\t\treturn;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tlvidiu->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\tlvidiu->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\tudf_time_to_disk_stamp(&lvid->recordingDateAndTime, CURRENT_TIME);\n\tif (UDF_MAX_WRITE_VERSION > le16_to_cpu(lvidiu->maxUDFWriteRev))\n\t\tlvidiu->maxUDFWriteRev = cpu_to_le16(UDF_MAX_WRITE_VERSION);\n\tif (sbi->s_udfrev > le16_to_cpu(lvidiu->minUDFReadRev))\n\t\tlvidiu->minUDFReadRev = cpu_to_le16(sbi->s_udfrev);\n\tif (sbi->s_udfrev > le16_to_cpu(lvidiu->minUDFWriteRev))\n\t\tlvidiu->minUDFWriteRev = cpu_to_le16(sbi->s_udfrev);\n\tlvid->integrityType = cpu_to_le32(LVID_INTEGRITY_TYPE_CLOSE);\n\n\tlvid->descTag.descCRC = cpu_to_le16(\n\t\t\tcrc_itu_t(0, (char *)lvid + sizeof(struct tag),\n\t\t\t\tle16_to_cpu(lvid->descTag.descCRCLength)));\n\n\tlvid->descTag.tagChecksum = udf_tag_checksum(&lvid->descTag);\n\t/*\n\t * We set buffer uptodate unconditionally here to avoid spurious\n\t * warnings from mark_buffer_dirty() when previous EIO has marked\n\t * the buffer as !uptodate\n\t */\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\tsbi->s_lvid_dirty = 0;\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t/* Make closing of filesystem visible on the media immediately */\n\tsync_dirty_buffer(bh);\n}"
  },
  {
    "function_name": "udf_open_lvid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "1957-1988",
    "snippet": "static void udf_open_lvid(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct buffer_head *bh = sbi->s_lvid_bh;\n\tstruct logicalVolIntegrityDesc *lvid;\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\n\tif (!bh)\n\t\treturn;\n\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (!lvidiu)\n\t\treturn;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tlvidiu->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\tlvidiu->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\tudf_time_to_disk_stamp(&lvid->recordingDateAndTime,\n\t\t\t\tCURRENT_TIME);\n\tlvid->integrityType = cpu_to_le32(LVID_INTEGRITY_TYPE_OPEN);\n\n\tlvid->descTag.descCRC = cpu_to_le16(\n\t\tcrc_itu_t(0, (char *)lvid + sizeof(struct tag),\n\t\t\tle16_to_cpu(lvid->descTag.descCRCLength)));\n\n\tlvid->descTag.tagChecksum = udf_tag_checksum(&lvid->descTag);\n\tmark_buffer_dirty(bh);\n\tsbi->s_lvid_dirty = 0;\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t/* Make opening of filesystem visible on the media immediately */\n\tsync_dirty_buffer(bh);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_tag_checksum",
          "args": [
            "&lvid->descTag"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "udf_tag_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "290-299",
          "snippet": "u8 udf_tag_checksum(const struct tag *t)\n{\n\tu8 *data = (u8 *)t;\n\tu8 checksum = 0;\n\tint i;\n\tfor (i = 0; i < sizeof(struct tag); ++i)\n\t\tif (i != 4) /* position of checksum */\n\t\t\tchecksum += data[i];\n\treturn checksum;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nu8 udf_tag_checksum(const struct tag *t)\n{\n\tu8 *data = (u8 *)t;\n\tu8 checksum = 0;\n\tint i;\n\tfor (i = 0; i < sizeof(struct tag); ++i)\n\t\tif (i != 4) /* position of checksum */\n\t\t\tchecksum += data[i];\n\treturn checksum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "crc_itu_t(0, (char *)lvid + sizeof(struct tag),\n\t\t\tle16_to_cpu(lvid->descTag.descCRCLength))"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc_itu_t",
          "args": [
            "0",
            "(char *)lvid + sizeof(struct tag)",
            "le16_to_cpu(lvid->descTag.descCRCLength)"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "lvid->descTag.descCRCLength"
          ],
          "line": 1980
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "LVID_INTEGRITY_TYPE_OPEN"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_time_to_disk_stamp",
          "args": [
            "&lvid->recordingDateAndTime",
            "CURRENT_TIME"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "udf_time_to_disk_stamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udftime.c",
          "lines": "119-168",
          "snippet": "struct timestamp *\nudf_time_to_disk_stamp(struct timestamp *dest, struct timespec ts)\n{\n\tlong int days, rem, y;\n\tconst unsigned short int *ip;\n\tint16_t offset;\n\n\toffset = -sys_tz.tz_minuteswest;\n\n\tif (!dest)\n\t\treturn NULL;\n\n\tdest->typeAndTimezone = cpu_to_le16(0x1000 | (offset & 0x0FFF));\n\n\tts.tv_sec += offset * 60;\n\tdays = ts.tv_sec / SECS_PER_DAY;\n\trem = ts.tv_sec % SECS_PER_DAY;\n\tdest->hour = rem / SECS_PER_HOUR;\n\trem %= SECS_PER_HOUR;\n\tdest->minute = rem / 60;\n\tdest->second = rem % 60;\n\ty = 1970;\n\n#define DIV(a, b) ((a) / (b) - ((a) % (b) < 0))\n#define LEAPS_THRU_END_OF(y) (DIV (y, 4) - DIV (y, 100) + DIV (y, 400))\n\n\twhile (days < 0 || days >= (__isleap(y) ? 366 : 365)) {\n\t\tlong int yg = y + days / 365 - (days % 365 < 0);\n\n\t\t/* Adjust DAYS and Y to match the guessed year.  */\n\t\tdays -= ((yg - y) * 365\n\t\t\t + LEAPS_THRU_END_OF(yg - 1)\n\t\t\t - LEAPS_THRU_END_OF(y - 1));\n\t\ty = yg;\n\t}\n\tdest->year = cpu_to_le16(y);\n\tip = __mon_yday[__isleap(y)];\n\tfor (y = 11; days < (long int)ip[y]; --y)\n\t\tcontinue;\n\tdays -= ip[y];\n\tdest->month = y + 1;\n\tdest->day = days + 1;\n\n\tdest->centiseconds = ts.tv_nsec / 10000000;\n\tdest->hundredsOfMicroseconds = (ts.tv_nsec / 1000 -\n\t\t\t\t\tdest->centiseconds * 10000) / 100;\n\tdest->microseconds = (ts.tv_nsec / 1000 - dest->centiseconds * 10000 -\n\t\t\t      dest->hundredsOfMicroseconds * 100);\n\treturn dest;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [
            "#define SECS_PER_DAY\t(SECS_PER_HOUR * 24)",
            "#define SECS_PER_HOUR\t(60 * 60)"
          ],
          "globals_used": [
            "static const unsigned short int __mon_yday[2][13] = {\n\t/* Normal years.  */\n\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t/* Leap years.  */\n\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/types.h>\n#include \"udfdecl.h\"\n\n#define SECS_PER_DAY\t(SECS_PER_HOUR * 24)\n#define SECS_PER_HOUR\t(60 * 60)\n\nstatic const unsigned short int __mon_yday[2][13] = {\n\t/* Normal years.  */\n\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t/* Leap years.  */\n\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}\n};\n\nstruct timestamp *\nudf_time_to_disk_stamp(struct timestamp *dest, struct timespec ts)\n{\n\tlong int days, rem, y;\n\tconst unsigned short int *ip;\n\tint16_t offset;\n\n\toffset = -sys_tz.tz_minuteswest;\n\n\tif (!dest)\n\t\treturn NULL;\n\n\tdest->typeAndTimezone = cpu_to_le16(0x1000 | (offset & 0x0FFF));\n\n\tts.tv_sec += offset * 60;\n\tdays = ts.tv_sec / SECS_PER_DAY;\n\trem = ts.tv_sec % SECS_PER_DAY;\n\tdest->hour = rem / SECS_PER_HOUR;\n\trem %= SECS_PER_HOUR;\n\tdest->minute = rem / 60;\n\tdest->second = rem % 60;\n\ty = 1970;\n\n#define DIV(a, b) ((a) / (b) - ((a) % (b) < 0))\n#define LEAPS_THRU_END_OF(y) (DIV (y, 4) - DIV (y, 100) + DIV (y, 400))\n\n\twhile (days < 0 || days >= (__isleap(y) ? 366 : 365)) {\n\t\tlong int yg = y + days / 365 - (days % 365 < 0);\n\n\t\t/* Adjust DAYS and Y to match the guessed year.  */\n\t\tdays -= ((yg - y) * 365\n\t\t\t + LEAPS_THRU_END_OF(yg - 1)\n\t\t\t - LEAPS_THRU_END_OF(y - 1));\n\t\ty = yg;\n\t}\n\tdest->year = cpu_to_le16(y);\n\tip = __mon_yday[__isleap(y)];\n\tfor (y = 11; days < (long int)ip[y]; --y)\n\t\tcontinue;\n\tdays -= ip[y];\n\tdest->month = y + 1;\n\tdest->day = days + 1;\n\n\tdest->centiseconds = ts.tv_nsec / 10000000;\n\tdest->hundredsOfMicroseconds = (ts.tv_nsec / 1000 -\n\t\t\t\t\tdest->centiseconds * 10000) / 100;\n\tdest->microseconds = (ts.tv_nsec / 1000 - dest->centiseconds * 10000 -\n\t\t\t      dest->hundredsOfMicroseconds * 100);\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_sb_lvidiu",
          "args": [
            "sb"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "udf_sb_lvidiu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "100-120",
          "snippet": "struct logicalVolIntegrityDescImpUse *udf_sb_lvidiu(struct super_block *sb)\n{\n\tstruct logicalVolIntegrityDesc *lvid;\n\tunsigned int partnum;\n\tunsigned int offset;\n\n\tif (!UDF_SB(sb)->s_lvid_bh)\n\t\treturn NULL;\n\tlvid = (struct logicalVolIntegrityDesc *)UDF_SB(sb)->s_lvid_bh->b_data;\n\tpartnum = le32_to_cpu(lvid->numOfPartitions);\n\tif ((sb->s_blocksize - sizeof(struct logicalVolIntegrityDescImpUse) -\n\t     offsetof(struct logicalVolIntegrityDesc, impUse)) /\n\t     (2 * sizeof(uint32_t)) < partnum) {\n\t\tudf_err(sb, \"Logical volume integrity descriptor corrupted \"\n\t\t\t\"(numOfPartitions = %u)!\\n\", partnum);\n\t\treturn NULL;\n\t}\n\t/* The offset is to skip freeSpaceTable and sizeTable arrays */\n\toffset = partnum * 2 * sizeof(uint32_t);\n\treturn (struct logicalVolIntegrityDescImpUse *)&(lvid->impUse[offset]);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstruct logicalVolIntegrityDescImpUse *udf_sb_lvidiu(struct super_block *sb)\n{\n\tstruct logicalVolIntegrityDesc *lvid;\n\tunsigned int partnum;\n\tunsigned int offset;\n\n\tif (!UDF_SB(sb)->s_lvid_bh)\n\t\treturn NULL;\n\tlvid = (struct logicalVolIntegrityDesc *)UDF_SB(sb)->s_lvid_bh->b_data;\n\tpartnum = le32_to_cpu(lvid->numOfPartitions);\n\tif ((sb->s_blocksize - sizeof(struct logicalVolIntegrityDescImpUse) -\n\t     offsetof(struct logicalVolIntegrityDesc, impUse)) /\n\t     (2 * sizeof(uint32_t)) < partnum) {\n\t\tudf_err(sb, \"Logical volume integrity descriptor corrupted \"\n\t\t\t\"(numOfPartitions = %u)!\\n\", partnum);\n\t\treturn NULL;\n\t}\n\t/* The offset is to skip freeSpaceTable and sizeTable arrays */\n\toffset = partnum * 2 * sizeof(uint32_t);\n\treturn (struct logicalVolIntegrityDescImpUse *)&(lvid->impUse[offset]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 1959
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic void udf_open_lvid(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct buffer_head *bh = sbi->s_lvid_bh;\n\tstruct logicalVolIntegrityDesc *lvid;\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\n\tif (!bh)\n\t\treturn;\n\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (!lvidiu)\n\t\treturn;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tlvidiu->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\tlvidiu->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\tudf_time_to_disk_stamp(&lvid->recordingDateAndTime,\n\t\t\t\tCURRENT_TIME);\n\tlvid->integrityType = cpu_to_le32(LVID_INTEGRITY_TYPE_OPEN);\n\n\tlvid->descTag.descCRC = cpu_to_le16(\n\t\tcrc_itu_t(0, (char *)lvid + sizeof(struct tag),\n\t\t\tle16_to_cpu(lvid->descTag.descCRCLength)));\n\n\tlvid->descTag.tagChecksum = udf_tag_checksum(&lvid->descTag);\n\tmark_buffer_dirty(bh);\n\tsbi->s_lvid_dirty = 0;\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t/* Make opening of filesystem visible on the media immediately */\n\tsync_dirty_buffer(bh);\n}"
  },
  {
    "function_name": "udf_load_vrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "1915-1955",
    "snippet": "static int udf_load_vrs(struct super_block *sb, struct udf_options *uopt,\n\t\t\tint silent, struct kernel_lb_addr *fileset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tloff_t nsr_off;\n\tint ret;\n\n\tif (!sb_set_blocksize(sb, uopt->blocksize)) {\n\t\tif (!silent)\n\t\t\tudf_warn(sb, \"Bad block size\\n\");\n\t\treturn -EINVAL;\n\t}\n\tsbi->s_last_block = uopt->lastblock;\n\tif (!uopt->novrs) {\n\t\t/* Check that it is NSR02 compliant */\n\t\tnsr_off = udf_check_vsd(sb);\n\t\tif (!nsr_off) {\n\t\t\tif (!silent)\n\t\t\t\tudf_warn(sb, \"No VRS found\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (nsr_off == -1)\n\t\t\tudf_debug(\"Failed to read sector at offset %d. \"\n\t\t\t\t  \"Assuming open disc. Skipping validity \"\n\t\t\t\t  \"check\\n\", VSD_FIRST_SECTOR_OFFSET);\n\t\tif (!sbi->s_last_block)\n\t\t\tsbi->s_last_block = udf_get_last_block(sb);\n\t} else {\n\t\tudf_debug(\"Validity check skipped because of novrs option\\n\");\n\t}\n\n\t/* Look for anchor block and load Volume Descriptor Sequence */\n\tsbi->s_anchor = uopt->anchor;\n\tret = udf_find_anchor(sb, fileset);\n\tif (ret < 0) {\n\t\tif (!silent && ret == -EAGAIN)\n\t\t\tudf_warn(sb, \"No anchor found\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [
      "#define VSD_FIRST_SECTOR_OFFSET\t\t32768"
    ],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
      "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_warn",
          "args": [
            "sb",
            "\"No anchor found\\n\""
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_find_anchor",
          "args": [
            "sb",
            "fileset"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "udf_find_anchor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "1876-1906",
          "snippet": "static int udf_find_anchor(struct super_block *sb,\n\t\t\t   struct kernel_lb_addr *fileset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tsector_t lastblock = sbi->s_last_block;\n\tint ret;\n\n\tret = udf_scan_anchors(sb, &lastblock, fileset);\n\tif (ret != -EAGAIN)\n\t\tgoto out;\n\n\t/* No anchor found? Try VARCONV conversion of block numbers */\n\tUDF_SET_FLAG(sb, UDF_FLAG_VARCONV);\n\tlastblock = udf_variable_to_fixed(sbi->s_last_block);\n\t/* Firstly, we try to not convert number of the last block */\n\tret = udf_scan_anchors(sb, &lastblock, fileset);\n\tif (ret != -EAGAIN)\n\t\tgoto out;\n\n\tlastblock = sbi->s_last_block;\n\t/* Secondly, we try with converted number of the last block */\n\tret = udf_scan_anchors(sb, &lastblock, fileset);\n\tif (ret < 0) {\n\t\t/* VARCONV didn't help. Clear it. */\n\t\tUDF_CLEAR_FLAG(sb, UDF_FLAG_VARCONV);\n\t}\nout:\n\tif (ret == 0)\n\t\tsbi->s_last_block = lastblock;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
            "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_find_anchor(struct super_block *sb,\n\t\t\t   struct kernel_lb_addr *fileset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tsector_t lastblock = sbi->s_last_block;\n\tint ret;\n\n\tret = udf_scan_anchors(sb, &lastblock, fileset);\n\tif (ret != -EAGAIN)\n\t\tgoto out;\n\n\t/* No anchor found? Try VARCONV conversion of block numbers */\n\tUDF_SET_FLAG(sb, UDF_FLAG_VARCONV);\n\tlastblock = udf_variable_to_fixed(sbi->s_last_block);\n\t/* Firstly, we try to not convert number of the last block */\n\tret = udf_scan_anchors(sb, &lastblock, fileset);\n\tif (ret != -EAGAIN)\n\t\tgoto out;\n\n\tlastblock = sbi->s_last_block;\n\t/* Secondly, we try with converted number of the last block */\n\tret = udf_scan_anchors(sb, &lastblock, fileset);\n\tif (ret < 0) {\n\t\t/* VARCONV didn't help. Clear it. */\n\t\tUDF_CLEAR_FLAG(sb, UDF_FLAG_VARCONV);\n\t}\nout:\n\tif (ret == 0)\n\t\tsbi->s_last_block = lastblock;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Validity check skipped because of novrs option\\n\""
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_get_last_block",
          "args": [
            "sb"
          ],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_last_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/lowlevel.c",
          "lines": "50-67",
          "snippet": "unsigned long udf_get_last_block(struct super_block *sb)\n{\n\tstruct block_device *bdev = sb->s_bdev;\n\tunsigned long lblock = 0;\n\n\t/*\n\t * ioctl failed or returned obviously bogus value?\n\t * Try using the device size...\n\t */\n\tif (ioctl_by_bdev(bdev, CDROM_LAST_WRITTEN, (unsigned long) &lblock) ||\n\t    lblock == 0)\n\t\tlblock = bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\n\tif (lblock)\n\t\treturn lblock - 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include <linux/uaccess.h>\n#include <linux/cdrom.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nunsigned long udf_get_last_block(struct super_block *sb)\n{\n\tstruct block_device *bdev = sb->s_bdev;\n\tunsigned long lblock = 0;\n\n\t/*\n\t * ioctl failed or returned obviously bogus value?\n\t * Try using the device size...\n\t */\n\tif (ioctl_by_bdev(bdev, CDROM_LAST_WRITTEN, (unsigned long) &lblock) ||\n\t    lblock == 0)\n\t\tlblock = bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\n\tif (lblock)\n\t\treturn lblock - 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Failed to read sector at offset %d. \"\n\t\t\t\t  \"Assuming open disc. Skipping validity \"\n\t\t\t\t  \"check\\n\"",
            "VSD_FIRST_SECTOR_OFFSET"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_warn",
          "args": [
            "sb",
            "\"No VRS found\\n\""
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_check_vsd",
          "args": [
            "sb"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "udf_check_vsd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "693-794",
          "snippet": "static loff_t udf_check_vsd(struct super_block *sb)\n{\n\tstruct volStructDesc *vsd = NULL;\n\tloff_t sector = VSD_FIRST_SECTOR_OFFSET;\n\tint sectorsize;\n\tstruct buffer_head *bh = NULL;\n\tint nsr02 = 0;\n\tint nsr03 = 0;\n\tstruct udf_sb_info *sbi;\n\n\tsbi = UDF_SB(sb);\n\tif (sb->s_blocksize < sizeof(struct volStructDesc))\n\t\tsectorsize = sizeof(struct volStructDesc);\n\telse\n\t\tsectorsize = sb->s_blocksize;\n\n\tsector += (sbi->s_session << sb->s_blocksize_bits);\n\n\tudf_debug(\"Starting at sector %u (%ld byte sectors)\\n\",\n\t\t  (unsigned int)(sector >> sb->s_blocksize_bits),\n\t\t  sb->s_blocksize);\n\t/* Process the sequence (if applicable). The hard limit on the sector\n\t * offset is arbitrary, hopefully large enough so that all valid UDF\n\t * filesystems will be recognised. There is no mention of an upper\n\t * bound to the size of the volume recognition area in the standard.\n\t *  The limit will prevent the code to read all the sectors of a\n\t * specially crafted image (like a bluray disc full of CD001 sectors),\n\t * potentially causing minutes or even hours of uninterruptible I/O\n\t * activity. This actually happened with uninitialised SSD partitions\n\t * (all 0xFF) before the check for the limit and all valid IDs were\n\t * added */\n\tfor (; !nsr02 && !nsr03 && sector < VSD_MAX_SECTOR_OFFSET;\n\t     sector += sectorsize) {\n\t\t/* Read a block */\n\t\tbh = udf_tread(sb, sector >> sb->s_blocksize_bits);\n\t\tif (!bh)\n\t\t\tbreak;\n\n\t\t/* Look for ISO  descriptors */\n\t\tvsd = (struct volStructDesc *)(bh->b_data +\n\t\t\t\t\t      (sector & (sb->s_blocksize - 1)));\n\n\t\tif (!strncmp(vsd->stdIdent, VSD_STD_ID_CD001,\n\t\t\t\t    VSD_STD_ID_LEN)) {\n\t\t\tswitch (vsd->structType) {\n\t\t\tcase 0:\n\t\t\t\tudf_debug(\"ISO9660 Boot Record found\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tudf_debug(\"ISO9660 Primary Volume Descriptor found\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tudf_debug(\"ISO9660 Supplementary Volume Descriptor found\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tudf_debug(\"ISO9660 Volume Partition Descriptor found\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 255:\n\t\t\t\tudf_debug(\"ISO9660 Volume Descriptor Set Terminator found\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tudf_debug(\"ISO9660 VRS (%u) found\\n\",\n\t\t\t\t\t  vsd->structType);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!strncmp(vsd->stdIdent, VSD_STD_ID_BEA01,\n\t\t\t\t    VSD_STD_ID_LEN))\n\t\t\t; /* nothing */\n\t\telse if (!strncmp(vsd->stdIdent, VSD_STD_ID_TEA01,\n\t\t\t\t    VSD_STD_ID_LEN)) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t} else if (!strncmp(vsd->stdIdent, VSD_STD_ID_NSR02,\n\t\t\t\t    VSD_STD_ID_LEN))\n\t\t\tnsr02 = sector;\n\t\telse if (!strncmp(vsd->stdIdent, VSD_STD_ID_NSR03,\n\t\t\t\t    VSD_STD_ID_LEN))\n\t\t\tnsr03 = sector;\n\t\telse if (!strncmp(vsd->stdIdent, VSD_STD_ID_BOOT2,\n\t\t\t\t    VSD_STD_ID_LEN))\n\t\t\t; /* nothing */\n\t\telse if (!strncmp(vsd->stdIdent, VSD_STD_ID_CDW02,\n\t\t\t\t    VSD_STD_ID_LEN))\n\t\t\t; /* nothing */\n\t\telse {\n\t\t\t/* invalid id : end of volume recognition area */\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\t\tbrelse(bh);\n\t}\n\n\tif (nsr03)\n\t\treturn nsr03;\n\telse if (nsr02)\n\t\treturn nsr02;\n\telse if (!bh && sector - (sbi->s_session << sb->s_blocksize_bits) ==\n\t\t\tVSD_FIRST_SECTOR_OFFSET)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [
            "#define VSD_MAX_SECTOR_OFFSET\t\t0x800000",
            "#define VSD_FIRST_SECTOR_OFFSET\t\t32768"
          ],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\n#define VSD_MAX_SECTOR_OFFSET\t\t0x800000\n#define VSD_FIRST_SECTOR_OFFSET\t\t32768\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic loff_t udf_check_vsd(struct super_block *sb)\n{\n\tstruct volStructDesc *vsd = NULL;\n\tloff_t sector = VSD_FIRST_SECTOR_OFFSET;\n\tint sectorsize;\n\tstruct buffer_head *bh = NULL;\n\tint nsr02 = 0;\n\tint nsr03 = 0;\n\tstruct udf_sb_info *sbi;\n\n\tsbi = UDF_SB(sb);\n\tif (sb->s_blocksize < sizeof(struct volStructDesc))\n\t\tsectorsize = sizeof(struct volStructDesc);\n\telse\n\t\tsectorsize = sb->s_blocksize;\n\n\tsector += (sbi->s_session << sb->s_blocksize_bits);\n\n\tudf_debug(\"Starting at sector %u (%ld byte sectors)\\n\",\n\t\t  (unsigned int)(sector >> sb->s_blocksize_bits),\n\t\t  sb->s_blocksize);\n\t/* Process the sequence (if applicable). The hard limit on the sector\n\t * offset is arbitrary, hopefully large enough so that all valid UDF\n\t * filesystems will be recognised. There is no mention of an upper\n\t * bound to the size of the volume recognition area in the standard.\n\t *  The limit will prevent the code to read all the sectors of a\n\t * specially crafted image (like a bluray disc full of CD001 sectors),\n\t * potentially causing minutes or even hours of uninterruptible I/O\n\t * activity. This actually happened with uninitialised SSD partitions\n\t * (all 0xFF) before the check for the limit and all valid IDs were\n\t * added */\n\tfor (; !nsr02 && !nsr03 && sector < VSD_MAX_SECTOR_OFFSET;\n\t     sector += sectorsize) {\n\t\t/* Read a block */\n\t\tbh = udf_tread(sb, sector >> sb->s_blocksize_bits);\n\t\tif (!bh)\n\t\t\tbreak;\n\n\t\t/* Look for ISO  descriptors */\n\t\tvsd = (struct volStructDesc *)(bh->b_data +\n\t\t\t\t\t      (sector & (sb->s_blocksize - 1)));\n\n\t\tif (!strncmp(vsd->stdIdent, VSD_STD_ID_CD001,\n\t\t\t\t    VSD_STD_ID_LEN)) {\n\t\t\tswitch (vsd->structType) {\n\t\t\tcase 0:\n\t\t\t\tudf_debug(\"ISO9660 Boot Record found\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tudf_debug(\"ISO9660 Primary Volume Descriptor found\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tudf_debug(\"ISO9660 Supplementary Volume Descriptor found\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tudf_debug(\"ISO9660 Volume Partition Descriptor found\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 255:\n\t\t\t\tudf_debug(\"ISO9660 Volume Descriptor Set Terminator found\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tudf_debug(\"ISO9660 VRS (%u) found\\n\",\n\t\t\t\t\t  vsd->structType);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!strncmp(vsd->stdIdent, VSD_STD_ID_BEA01,\n\t\t\t\t    VSD_STD_ID_LEN))\n\t\t\t; /* nothing */\n\t\telse if (!strncmp(vsd->stdIdent, VSD_STD_ID_TEA01,\n\t\t\t\t    VSD_STD_ID_LEN)) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t} else if (!strncmp(vsd->stdIdent, VSD_STD_ID_NSR02,\n\t\t\t\t    VSD_STD_ID_LEN))\n\t\t\tnsr02 = sector;\n\t\telse if (!strncmp(vsd->stdIdent, VSD_STD_ID_NSR03,\n\t\t\t\t    VSD_STD_ID_LEN))\n\t\t\tnsr03 = sector;\n\t\telse if (!strncmp(vsd->stdIdent, VSD_STD_ID_BOOT2,\n\t\t\t\t    VSD_STD_ID_LEN))\n\t\t\t; /* nothing */\n\t\telse if (!strncmp(vsd->stdIdent, VSD_STD_ID_CDW02,\n\t\t\t\t    VSD_STD_ID_LEN))\n\t\t\t; /* nothing */\n\t\telse {\n\t\t\t/* invalid id : end of volume recognition area */\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\t\tbrelse(bh);\n\t}\n\n\tif (nsr03)\n\t\treturn nsr03;\n\telse if (nsr02)\n\t\treturn nsr02;\n\telse if (!bh && sector - (sbi->s_session << sb->s_blocksize_bits) ==\n\t\t\tVSD_FIRST_SECTOR_OFFSET)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_warn",
          "args": [
            "sb",
            "\"Bad block size\\n\""
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "sb",
            "uopt->blocksize"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\n#define VSD_FIRST_SECTOR_OFFSET\t\t32768\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_load_vrs(struct super_block *sb, struct udf_options *uopt,\n\t\t\tint silent, struct kernel_lb_addr *fileset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tloff_t nsr_off;\n\tint ret;\n\n\tif (!sb_set_blocksize(sb, uopt->blocksize)) {\n\t\tif (!silent)\n\t\t\tudf_warn(sb, \"Bad block size\\n\");\n\t\treturn -EINVAL;\n\t}\n\tsbi->s_last_block = uopt->lastblock;\n\tif (!uopt->novrs) {\n\t\t/* Check that it is NSR02 compliant */\n\t\tnsr_off = udf_check_vsd(sb);\n\t\tif (!nsr_off) {\n\t\t\tif (!silent)\n\t\t\t\tudf_warn(sb, \"No VRS found\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (nsr_off == -1)\n\t\t\tudf_debug(\"Failed to read sector at offset %d. \"\n\t\t\t\t  \"Assuming open disc. Skipping validity \"\n\t\t\t\t  \"check\\n\", VSD_FIRST_SECTOR_OFFSET);\n\t\tif (!sbi->s_last_block)\n\t\t\tsbi->s_last_block = udf_get_last_block(sb);\n\t} else {\n\t\tudf_debug(\"Validity check skipped because of novrs option\\n\");\n\t}\n\n\t/* Look for anchor block and load Volume Descriptor Sequence */\n\tsbi->s_anchor = uopt->anchor;\n\tret = udf_find_anchor(sb, fileset);\n\tif (ret < 0) {\n\t\tif (!silent && ret == -EAGAIN)\n\t\t\tudf_warn(sb, \"No anchor found\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "udf_find_anchor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "1876-1906",
    "snippet": "static int udf_find_anchor(struct super_block *sb,\n\t\t\t   struct kernel_lb_addr *fileset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tsector_t lastblock = sbi->s_last_block;\n\tint ret;\n\n\tret = udf_scan_anchors(sb, &lastblock, fileset);\n\tif (ret != -EAGAIN)\n\t\tgoto out;\n\n\t/* No anchor found? Try VARCONV conversion of block numbers */\n\tUDF_SET_FLAG(sb, UDF_FLAG_VARCONV);\n\tlastblock = udf_variable_to_fixed(sbi->s_last_block);\n\t/* Firstly, we try to not convert number of the last block */\n\tret = udf_scan_anchors(sb, &lastblock, fileset);\n\tif (ret != -EAGAIN)\n\t\tgoto out;\n\n\tlastblock = sbi->s_last_block;\n\t/* Secondly, we try with converted number of the last block */\n\tret = udf_scan_anchors(sb, &lastblock, fileset);\n\tif (ret < 0) {\n\t\t/* VARCONV didn't help. Clear it. */\n\t\tUDF_CLEAR_FLAG(sb, UDF_FLAG_VARCONV);\n\t}\nout:\n\tif (ret == 0)\n\t\tsbi->s_last_block = lastblock;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
      "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UDF_CLEAR_FLAG",
          "args": [
            "sb",
            "UDF_FLAG_VARCONV"
          ],
          "line": 1900
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_CLEAR_FLAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "179-182",
          "snippet": "static inline void UDF_CLEAR_FLAG(struct super_block *sb, int flag)\n{\n\tclear_bit(flag, &UDF_SB(sb)->s_flags);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline void UDF_CLEAR_FLAG(struct super_block *sb, int flag)\n{\n\tclear_bit(flag, &UDF_SB(sb)->s_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_scan_anchors",
          "args": [
            "sb",
            "&lastblock",
            "fileset"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "udf_scan_anchors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "1804-1866",
          "snippet": "static int udf_scan_anchors(struct super_block *sb, sector_t *lastblock,\n\t\t\t    struct kernel_lb_addr *fileset)\n{\n\tsector_t last[6];\n\tint i;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint last_count = 0;\n\tint ret;\n\n\t/* First try user provided anchor */\n\tif (sbi->s_anchor) {\n\t\tret = udf_check_anchor_block(sb, sbi->s_anchor, fileset);\n\t\tif (ret != -EAGAIN)\n\t\t\treturn ret;\n\t}\n\t/*\n\t * according to spec, anchor is in either:\n\t *     block 256\n\t *     lastblock-256\n\t *     lastblock\n\t *  however, if the disc isn't closed, it could be 512.\n\t */\n\tret = udf_check_anchor_block(sb, sbi->s_session + 256, fileset);\n\tif (ret != -EAGAIN)\n\t\treturn ret;\n\t/*\n\t * The trouble is which block is the last one. Drives often misreport\n\t * this so we try various possibilities.\n\t */\n\tlast[last_count++] = *lastblock;\n\tif (*lastblock >= 1)\n\t\tlast[last_count++] = *lastblock - 1;\n\tlast[last_count++] = *lastblock + 1;\n\tif (*lastblock >= 2)\n\t\tlast[last_count++] = *lastblock - 2;\n\tif (*lastblock >= 150)\n\t\tlast[last_count++] = *lastblock - 150;\n\tif (*lastblock >= 152)\n\t\tlast[last_count++] = *lastblock - 152;\n\n\tfor (i = 0; i < last_count; i++) {\n\t\tif (last[i] >= sb->s_bdev->bd_inode->i_size >>\n\t\t\t\tsb->s_blocksize_bits)\n\t\t\tcontinue;\n\t\tret = udf_check_anchor_block(sb, last[i], fileset);\n\t\tif (ret != -EAGAIN) {\n\t\t\tif (!ret)\n\t\t\t\t*lastblock = last[i];\n\t\t\treturn ret;\n\t\t}\n\t\tif (last[i] < 256)\n\t\t\tcontinue;\n\t\tret = udf_check_anchor_block(sb, last[i] - 256, fileset);\n\t\tif (ret != -EAGAIN) {\n\t\t\tif (!ret)\n\t\t\t\t*lastblock = last[i];\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Finally try block 512 in case media is open */\n\treturn udf_check_anchor_block(sb, sbi->s_session + 512, fileset);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
            "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_scan_anchors(struct super_block *sb, sector_t *lastblock,\n\t\t\t    struct kernel_lb_addr *fileset)\n{\n\tsector_t last[6];\n\tint i;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint last_count = 0;\n\tint ret;\n\n\t/* First try user provided anchor */\n\tif (sbi->s_anchor) {\n\t\tret = udf_check_anchor_block(sb, sbi->s_anchor, fileset);\n\t\tif (ret != -EAGAIN)\n\t\t\treturn ret;\n\t}\n\t/*\n\t * according to spec, anchor is in either:\n\t *     block 256\n\t *     lastblock-256\n\t *     lastblock\n\t *  however, if the disc isn't closed, it could be 512.\n\t */\n\tret = udf_check_anchor_block(sb, sbi->s_session + 256, fileset);\n\tif (ret != -EAGAIN)\n\t\treturn ret;\n\t/*\n\t * The trouble is which block is the last one. Drives often misreport\n\t * this so we try various possibilities.\n\t */\n\tlast[last_count++] = *lastblock;\n\tif (*lastblock >= 1)\n\t\tlast[last_count++] = *lastblock - 1;\n\tlast[last_count++] = *lastblock + 1;\n\tif (*lastblock >= 2)\n\t\tlast[last_count++] = *lastblock - 2;\n\tif (*lastblock >= 150)\n\t\tlast[last_count++] = *lastblock - 150;\n\tif (*lastblock >= 152)\n\t\tlast[last_count++] = *lastblock - 152;\n\n\tfor (i = 0; i < last_count; i++) {\n\t\tif (last[i] >= sb->s_bdev->bd_inode->i_size >>\n\t\t\t\tsb->s_blocksize_bits)\n\t\t\tcontinue;\n\t\tret = udf_check_anchor_block(sb, last[i], fileset);\n\t\tif (ret != -EAGAIN) {\n\t\t\tif (!ret)\n\t\t\t\t*lastblock = last[i];\n\t\t\treturn ret;\n\t\t}\n\t\tif (last[i] < 256)\n\t\t\tcontinue;\n\t\tret = udf_check_anchor_block(sb, last[i] - 256, fileset);\n\t\tif (ret != -EAGAIN) {\n\t\t\tif (!ret)\n\t\t\t\t*lastblock = last[i];\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Finally try block 512 in case media is open */\n\treturn udf_check_anchor_block(sb, sbi->s_session + 512, fileset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_variable_to_fixed",
          "args": [
            "sbi->s_last_block"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_SET_FLAG",
          "args": [
            "sb",
            "UDF_FLAG_VARCONV"
          ],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SET_FLAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "174-177",
          "snippet": "static inline void UDF_SET_FLAG(struct super_block *sb, int flag)\n{\n\tset_bit(flag, &UDF_SB(sb)->s_flags);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline void UDF_SET_FLAG(struct super_block *sb, int flag)\n{\n\tset_bit(flag, &UDF_SB(sb)->s_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_find_anchor(struct super_block *sb,\n\t\t\t   struct kernel_lb_addr *fileset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tsector_t lastblock = sbi->s_last_block;\n\tint ret;\n\n\tret = udf_scan_anchors(sb, &lastblock, fileset);\n\tif (ret != -EAGAIN)\n\t\tgoto out;\n\n\t/* No anchor found? Try VARCONV conversion of block numbers */\n\tUDF_SET_FLAG(sb, UDF_FLAG_VARCONV);\n\tlastblock = udf_variable_to_fixed(sbi->s_last_block);\n\t/* Firstly, we try to not convert number of the last block */\n\tret = udf_scan_anchors(sb, &lastblock, fileset);\n\tif (ret != -EAGAIN)\n\t\tgoto out;\n\n\tlastblock = sbi->s_last_block;\n\t/* Secondly, we try with converted number of the last block */\n\tret = udf_scan_anchors(sb, &lastblock, fileset);\n\tif (ret < 0) {\n\t\t/* VARCONV didn't help. Clear it. */\n\t\tUDF_CLEAR_FLAG(sb, UDF_FLAG_VARCONV);\n\t}\nout:\n\tif (ret == 0)\n\t\tsbi->s_last_block = lastblock;\n\treturn ret;\n}"
  },
  {
    "function_name": "udf_scan_anchors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "1804-1866",
    "snippet": "static int udf_scan_anchors(struct super_block *sb, sector_t *lastblock,\n\t\t\t    struct kernel_lb_addr *fileset)\n{\n\tsector_t last[6];\n\tint i;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint last_count = 0;\n\tint ret;\n\n\t/* First try user provided anchor */\n\tif (sbi->s_anchor) {\n\t\tret = udf_check_anchor_block(sb, sbi->s_anchor, fileset);\n\t\tif (ret != -EAGAIN)\n\t\t\treturn ret;\n\t}\n\t/*\n\t * according to spec, anchor is in either:\n\t *     block 256\n\t *     lastblock-256\n\t *     lastblock\n\t *  however, if the disc isn't closed, it could be 512.\n\t */\n\tret = udf_check_anchor_block(sb, sbi->s_session + 256, fileset);\n\tif (ret != -EAGAIN)\n\t\treturn ret;\n\t/*\n\t * The trouble is which block is the last one. Drives often misreport\n\t * this so we try various possibilities.\n\t */\n\tlast[last_count++] = *lastblock;\n\tif (*lastblock >= 1)\n\t\tlast[last_count++] = *lastblock - 1;\n\tlast[last_count++] = *lastblock + 1;\n\tif (*lastblock >= 2)\n\t\tlast[last_count++] = *lastblock - 2;\n\tif (*lastblock >= 150)\n\t\tlast[last_count++] = *lastblock - 150;\n\tif (*lastblock >= 152)\n\t\tlast[last_count++] = *lastblock - 152;\n\n\tfor (i = 0; i < last_count; i++) {\n\t\tif (last[i] >= sb->s_bdev->bd_inode->i_size >>\n\t\t\t\tsb->s_blocksize_bits)\n\t\t\tcontinue;\n\t\tret = udf_check_anchor_block(sb, last[i], fileset);\n\t\tif (ret != -EAGAIN) {\n\t\t\tif (!ret)\n\t\t\t\t*lastblock = last[i];\n\t\t\treturn ret;\n\t\t}\n\t\tif (last[i] < 256)\n\t\t\tcontinue;\n\t\tret = udf_check_anchor_block(sb, last[i] - 256, fileset);\n\t\tif (ret != -EAGAIN) {\n\t\t\tif (!ret)\n\t\t\t\t*lastblock = last[i];\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Finally try block 512 in case media is open */\n\treturn udf_check_anchor_block(sb, sbi->s_session + 512, fileset);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
      "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_check_anchor_block",
          "args": [
            "sb",
            "sbi->s_session + 512",
            "fileset"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "udf_check_anchor_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "1774-1796",
          "snippet": "static int udf_check_anchor_block(struct super_block *sb, sector_t block,\n\t\t\t\t  struct kernel_lb_addr *fileset)\n{\n\tstruct buffer_head *bh;\n\tuint16_t ident;\n\tint ret;\n\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV) &&\n\t    udf_fixed_to_variable(block) >=\n\t    sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits)\n\t\treturn -EAGAIN;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh)\n\t\treturn -EAGAIN;\n\tif (ident != TAG_IDENT_AVDP) {\n\t\tbrelse(bh);\n\t\treturn -EAGAIN;\n\t}\n\tret = udf_load_sequence(sb, bh, fileset);\n\tbrelse(bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
            "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_check_anchor_block(struct super_block *sb, sector_t block,\n\t\t\t\t  struct kernel_lb_addr *fileset)\n{\n\tstruct buffer_head *bh;\n\tuint16_t ident;\n\tint ret;\n\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV) &&\n\t    udf_fixed_to_variable(block) >=\n\t    sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits)\n\t\treturn -EAGAIN;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh)\n\t\treturn -EAGAIN;\n\tif (ident != TAG_IDENT_AVDP) {\n\t\tbrelse(bh);\n\t\treturn -EAGAIN;\n\t}\n\tret = udf_load_sequence(sb, bh, fileset);\n\tbrelse(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_scan_anchors(struct super_block *sb, sector_t *lastblock,\n\t\t\t    struct kernel_lb_addr *fileset)\n{\n\tsector_t last[6];\n\tint i;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint last_count = 0;\n\tint ret;\n\n\t/* First try user provided anchor */\n\tif (sbi->s_anchor) {\n\t\tret = udf_check_anchor_block(sb, sbi->s_anchor, fileset);\n\t\tif (ret != -EAGAIN)\n\t\t\treturn ret;\n\t}\n\t/*\n\t * according to spec, anchor is in either:\n\t *     block 256\n\t *     lastblock-256\n\t *     lastblock\n\t *  however, if the disc isn't closed, it could be 512.\n\t */\n\tret = udf_check_anchor_block(sb, sbi->s_session + 256, fileset);\n\tif (ret != -EAGAIN)\n\t\treturn ret;\n\t/*\n\t * The trouble is which block is the last one. Drives often misreport\n\t * this so we try various possibilities.\n\t */\n\tlast[last_count++] = *lastblock;\n\tif (*lastblock >= 1)\n\t\tlast[last_count++] = *lastblock - 1;\n\tlast[last_count++] = *lastblock + 1;\n\tif (*lastblock >= 2)\n\t\tlast[last_count++] = *lastblock - 2;\n\tif (*lastblock >= 150)\n\t\tlast[last_count++] = *lastblock - 150;\n\tif (*lastblock >= 152)\n\t\tlast[last_count++] = *lastblock - 152;\n\n\tfor (i = 0; i < last_count; i++) {\n\t\tif (last[i] >= sb->s_bdev->bd_inode->i_size >>\n\t\t\t\tsb->s_blocksize_bits)\n\t\t\tcontinue;\n\t\tret = udf_check_anchor_block(sb, last[i], fileset);\n\t\tif (ret != -EAGAIN) {\n\t\t\tif (!ret)\n\t\t\t\t*lastblock = last[i];\n\t\t\treturn ret;\n\t\t}\n\t\tif (last[i] < 256)\n\t\t\tcontinue;\n\t\tret = udf_check_anchor_block(sb, last[i] - 256, fileset);\n\t\tif (ret != -EAGAIN) {\n\t\t\tif (!ret)\n\t\t\t\t*lastblock = last[i];\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Finally try block 512 in case media is open */\n\treturn udf_check_anchor_block(sb, sbi->s_session + 512, fileset);\n}"
  },
  {
    "function_name": "udf_check_anchor_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "1774-1796",
    "snippet": "static int udf_check_anchor_block(struct super_block *sb, sector_t block,\n\t\t\t\t  struct kernel_lb_addr *fileset)\n{\n\tstruct buffer_head *bh;\n\tuint16_t ident;\n\tint ret;\n\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV) &&\n\t    udf_fixed_to_variable(block) >=\n\t    sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits)\n\t\treturn -EAGAIN;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh)\n\t\treturn -EAGAIN;\n\tif (ident != TAG_IDENT_AVDP) {\n\t\tbrelse(bh);\n\t\treturn -EAGAIN;\n\t}\n\tret = udf_load_sequence(sb, bh, fileset);\n\tbrelse(bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
      "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_load_sequence",
          "args": [
            "sb",
            "bh",
            "fileset"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "udf_load_sequence",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "1730-1765",
          "snippet": "static int udf_load_sequence(struct super_block *sb, struct buffer_head *bh,\n\t\t\t     struct kernel_lb_addr *fileset)\n{\n\tstruct anchorVolDescPtr *anchor;\n\tsector_t main_s, main_e, reserve_s, reserve_e;\n\tint ret;\n\n\tanchor = (struct anchorVolDescPtr *)bh->b_data;\n\n\t/* Locate the main sequence */\n\tmain_s = le32_to_cpu(anchor->mainVolDescSeqExt.extLocation);\n\tmain_e = le32_to_cpu(anchor->mainVolDescSeqExt.extLength);\n\tmain_e = main_e >> sb->s_blocksize_bits;\n\tmain_e += main_s;\n\n\t/* Locate the reserve sequence */\n\treserve_s = le32_to_cpu(anchor->reserveVolDescSeqExt.extLocation);\n\treserve_e = le32_to_cpu(anchor->reserveVolDescSeqExt.extLength);\n\treserve_e = reserve_e >> sb->s_blocksize_bits;\n\treserve_e += reserve_s;\n\n\t/* Process the main & reserve sequences */\n\t/* responsible for finding the PartitionDesc(s) */\n\tret = udf_process_sequence(sb, main_s, main_e, fileset);\n\tif (ret != -EAGAIN)\n\t\treturn ret;\n\tudf_sb_free_partitions(sb);\n\tret = udf_process_sequence(sb, reserve_s, reserve_e, fileset);\n\tif (ret < 0) {\n\t\tudf_sb_free_partitions(sb);\n\t\t/* No sequence was OK, return -EIO */\n\t\tif (ret == -EAGAIN)\n\t\t\tret = -EIO;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
            "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_load_sequence(struct super_block *sb, struct buffer_head *bh,\n\t\t\t     struct kernel_lb_addr *fileset)\n{\n\tstruct anchorVolDescPtr *anchor;\n\tsector_t main_s, main_e, reserve_s, reserve_e;\n\tint ret;\n\n\tanchor = (struct anchorVolDescPtr *)bh->b_data;\n\n\t/* Locate the main sequence */\n\tmain_s = le32_to_cpu(anchor->mainVolDescSeqExt.extLocation);\n\tmain_e = le32_to_cpu(anchor->mainVolDescSeqExt.extLength);\n\tmain_e = main_e >> sb->s_blocksize_bits;\n\tmain_e += main_s;\n\n\t/* Locate the reserve sequence */\n\treserve_s = le32_to_cpu(anchor->reserveVolDescSeqExt.extLocation);\n\treserve_e = le32_to_cpu(anchor->reserveVolDescSeqExt.extLength);\n\treserve_e = reserve_e >> sb->s_blocksize_bits;\n\treserve_e += reserve_s;\n\n\t/* Process the main & reserve sequences */\n\t/* responsible for finding the PartitionDesc(s) */\n\tret = udf_process_sequence(sb, main_s, main_e, fileset);\n\tif (ret != -EAGAIN)\n\t\treturn ret;\n\tudf_sb_free_partitions(sb);\n\tret = udf_process_sequence(sb, reserve_s, reserve_e, fileset);\n\tif (ret < 0) {\n\t\tudf_sb_free_partitions(sb);\n\t\t/* No sequence was OK, return -EIO */\n\t\tif (ret == -EAGAIN)\n\t\t\tret = -EIO;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_read_tagged",
          "args": [
            "sb",
            "block",
            "block",
            "&ident"
          ],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "udf_read_tagged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "202-259",
          "snippet": "struct buffer_head *udf_read_tagged(struct super_block *sb, uint32_t block,\n\t\t\t\t    uint32_t location, uint16_t *ident)\n{\n\tstruct tag *tag_p;\n\tstruct buffer_head *bh = NULL;\n\tu8 checksum;\n\n\t/* Read the block */\n\tif (block == 0xFFFFFFFF)\n\t\treturn NULL;\n\n\tbh = udf_tread(sb, block);\n\tif (!bh) {\n\t\tudf_err(sb, \"read failed, block=%u, location=%d\\n\",\n\t\t\tblock, location);\n\t\treturn NULL;\n\t}\n\n\ttag_p = (struct tag *)(bh->b_data);\n\n\t*ident = le16_to_cpu(tag_p->tagIdent);\n\n\tif (location != le32_to_cpu(tag_p->tagLocation)) {\n\t\tudf_debug(\"location mismatch block %u, tag %u != %u\\n\",\n\t\t\t  block, le32_to_cpu(tag_p->tagLocation), location);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag checksum */\n\tchecksum = udf_tag_checksum(tag_p);\n\tif (checksum != tag_p->tagChecksum) {\n\t\tudf_err(sb, \"tag checksum failed, block %u: 0x%02x != 0x%02x\\n\",\n\t\t\tblock, checksum, tag_p->tagChecksum);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag version */\n\tif (tag_p->descVersion != cpu_to_le16(0x0002U) &&\n\t    tag_p->descVersion != cpu_to_le16(0x0003U)) {\n\t\tudf_err(sb, \"tag version 0x%04x != 0x0002 || 0x0003, block %u\\n\",\n\t\t\tle16_to_cpu(tag_p->descVersion), block);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the descriptor CRC */\n\tif (le16_to_cpu(tag_p->descCRCLength) + sizeof(struct tag) > sb->s_blocksize ||\n\t    le16_to_cpu(tag_p->descCRC) == crc_itu_t(0,\n\t\t\t\t\tbh->b_data + sizeof(struct tag),\n\t\t\t\t\tle16_to_cpu(tag_p->descCRCLength)))\n\t\treturn bh;\n\n\tudf_debug(\"Crc failure block %d: crc = %d, crclen = %d\\n\", block,\n\t\t  le16_to_cpu(tag_p->descCRC),\n\t\t  le16_to_cpu(tag_p->descCRCLength));\nerror_out:\n\tbrelse(bh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_read_tagged(struct super_block *sb, uint32_t block,\n\t\t\t\t    uint32_t location, uint16_t *ident)\n{\n\tstruct tag *tag_p;\n\tstruct buffer_head *bh = NULL;\n\tu8 checksum;\n\n\t/* Read the block */\n\tif (block == 0xFFFFFFFF)\n\t\treturn NULL;\n\n\tbh = udf_tread(sb, block);\n\tif (!bh) {\n\t\tudf_err(sb, \"read failed, block=%u, location=%d\\n\",\n\t\t\tblock, location);\n\t\treturn NULL;\n\t}\n\n\ttag_p = (struct tag *)(bh->b_data);\n\n\t*ident = le16_to_cpu(tag_p->tagIdent);\n\n\tif (location != le32_to_cpu(tag_p->tagLocation)) {\n\t\tudf_debug(\"location mismatch block %u, tag %u != %u\\n\",\n\t\t\t  block, le32_to_cpu(tag_p->tagLocation), location);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag checksum */\n\tchecksum = udf_tag_checksum(tag_p);\n\tif (checksum != tag_p->tagChecksum) {\n\t\tudf_err(sb, \"tag checksum failed, block %u: 0x%02x != 0x%02x\\n\",\n\t\t\tblock, checksum, tag_p->tagChecksum);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag version */\n\tif (tag_p->descVersion != cpu_to_le16(0x0002U) &&\n\t    tag_p->descVersion != cpu_to_le16(0x0003U)) {\n\t\tudf_err(sb, \"tag version 0x%04x != 0x0002 || 0x0003, block %u\\n\",\n\t\t\tle16_to_cpu(tag_p->descVersion), block);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the descriptor CRC */\n\tif (le16_to_cpu(tag_p->descCRCLength) + sizeof(struct tag) > sb->s_blocksize ||\n\t    le16_to_cpu(tag_p->descCRC) == crc_itu_t(0,\n\t\t\t\t\tbh->b_data + sizeof(struct tag),\n\t\t\t\t\tle16_to_cpu(tag_p->descCRCLength)))\n\t\treturn bh;\n\n\tudf_debug(\"Crc failure block %d: crc = %d, crclen = %d\\n\", block,\n\t\t  le16_to_cpu(tag_p->descCRC),\n\t\t  le16_to_cpu(tag_p->descCRCLength));\nerror_out:\n\tbrelse(bh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_fixed_to_variable",
          "args": [
            "block"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_QUERY_FLAG",
          "args": [
            "sb",
            "UDF_FLAG_VARCONV"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_QUERY_FLAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "169-172",
          "snippet": "static inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_check_anchor_block(struct super_block *sb, sector_t block,\n\t\t\t\t  struct kernel_lb_addr *fileset)\n{\n\tstruct buffer_head *bh;\n\tuint16_t ident;\n\tint ret;\n\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV) &&\n\t    udf_fixed_to_variable(block) >=\n\t    sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits)\n\t\treturn -EAGAIN;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh)\n\t\treturn -EAGAIN;\n\tif (ident != TAG_IDENT_AVDP) {\n\t\tbrelse(bh);\n\t\treturn -EAGAIN;\n\t}\n\tret = udf_load_sequence(sb, bh, fileset);\n\tbrelse(bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "udf_load_sequence",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "1730-1765",
    "snippet": "static int udf_load_sequence(struct super_block *sb, struct buffer_head *bh,\n\t\t\t     struct kernel_lb_addr *fileset)\n{\n\tstruct anchorVolDescPtr *anchor;\n\tsector_t main_s, main_e, reserve_s, reserve_e;\n\tint ret;\n\n\tanchor = (struct anchorVolDescPtr *)bh->b_data;\n\n\t/* Locate the main sequence */\n\tmain_s = le32_to_cpu(anchor->mainVolDescSeqExt.extLocation);\n\tmain_e = le32_to_cpu(anchor->mainVolDescSeqExt.extLength);\n\tmain_e = main_e >> sb->s_blocksize_bits;\n\tmain_e += main_s;\n\n\t/* Locate the reserve sequence */\n\treserve_s = le32_to_cpu(anchor->reserveVolDescSeqExt.extLocation);\n\treserve_e = le32_to_cpu(anchor->reserveVolDescSeqExt.extLength);\n\treserve_e = reserve_e >> sb->s_blocksize_bits;\n\treserve_e += reserve_s;\n\n\t/* Process the main & reserve sequences */\n\t/* responsible for finding the PartitionDesc(s) */\n\tret = udf_process_sequence(sb, main_s, main_e, fileset);\n\tif (ret != -EAGAIN)\n\t\treturn ret;\n\tudf_sb_free_partitions(sb);\n\tret = udf_process_sequence(sb, reserve_s, reserve_e, fileset);\n\tif (ret < 0) {\n\t\tudf_sb_free_partitions(sb);\n\t\t/* No sequence was OK, return -EIO */\n\t\tif (ret == -EAGAIN)\n\t\t\tret = -EIO;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
      "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_sb_free_partitions",
          "args": [
            "sb"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "udf_sb_free_partitions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "324-334",
          "snippet": "static void udf_sb_free_partitions(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint i;\n\tif (sbi->s_partmaps == NULL)\n\t\treturn;\n\tfor (i = 0; i < sbi->s_partitions; i++)\n\t\tudf_free_partition(&sbi->s_partmaps[i]);\n\tkfree(sbi->s_partmaps);\n\tsbi->s_partmaps = NULL;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic void udf_sb_free_partitions(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint i;\n\tif (sbi->s_partmaps == NULL)\n\t\treturn;\n\tfor (i = 0; i < sbi->s_partitions; i++)\n\t\tudf_free_partition(&sbi->s_partmaps[i]);\n\tkfree(sbi->s_partmaps);\n\tsbi->s_partmaps = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_process_sequence",
          "args": [
            "sb",
            "reserve_s",
            "reserve_e",
            "fileset"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "udf_process_sequence",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "1592-1723",
          "snippet": "static noinline int udf_process_sequence(\n\t\tstruct super_block *sb,\n\t\tsector_t block, sector_t lastblock,\n\t\tstruct kernel_lb_addr *fileset)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct udf_vds_record vds[VDS_POS_LENGTH];\n\tstruct udf_vds_record *curr;\n\tstruct generic_desc *gd;\n\tstruct volDescPtr *vdp;\n\tbool done = false;\n\tuint32_t vdsn;\n\tuint16_t ident;\n\tlong next_s = 0, next_e = 0;\n\tint ret;\n\n\tmemset(vds, 0, sizeof(struct udf_vds_record) * VDS_POS_LENGTH);\n\n\t/*\n\t * Read the main descriptor sequence and find which descriptors\n\t * are in it.\n\t */\n\tfor (; (!done && block <= lastblock); block++) {\n\n\t\tbh = udf_read_tagged(sb, block, block, &ident);\n\t\tif (!bh) {\n\t\t\tudf_err(sb,\n\t\t\t\t\"Block %llu of volume descriptor sequence is corrupted or we could not read it\\n\",\n\t\t\t\t(unsigned long long)block);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\t/* Process each descriptor (ISO 13346 3/8.3-8.4) */\n\t\tgd = (struct generic_desc *)bh->b_data;\n\t\tvdsn = le32_to_cpu(gd->volDescSeqNum);\n\t\tswitch (ident) {\n\t\tcase TAG_IDENT_PVD: /* ISO 13346 3/10.1 */\n\t\t\tcurr = &vds[VDS_POS_PRIMARY_VOL_DESC];\n\t\t\tif (vdsn >= curr->volDescSeqNum) {\n\t\t\t\tcurr->volDescSeqNum = vdsn;\n\t\t\t\tcurr->block = block;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_IDENT_VDP: /* ISO 13346 3/10.3 */\n\t\t\tcurr = &vds[VDS_POS_VOL_DESC_PTR];\n\t\t\tif (vdsn >= curr->volDescSeqNum) {\n\t\t\t\tcurr->volDescSeqNum = vdsn;\n\t\t\t\tcurr->block = block;\n\n\t\t\t\tvdp = (struct volDescPtr *)bh->b_data;\n\t\t\t\tnext_s = le32_to_cpu(\n\t\t\t\t\tvdp->nextVolDescSeqExt.extLocation);\n\t\t\t\tnext_e = le32_to_cpu(\n\t\t\t\t\tvdp->nextVolDescSeqExt.extLength);\n\t\t\t\tnext_e = next_e >> sb->s_blocksize_bits;\n\t\t\t\tnext_e += next_s;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_IDENT_IUVD: /* ISO 13346 3/10.4 */\n\t\t\tcurr = &vds[VDS_POS_IMP_USE_VOL_DESC];\n\t\t\tif (vdsn >= curr->volDescSeqNum) {\n\t\t\t\tcurr->volDescSeqNum = vdsn;\n\t\t\t\tcurr->block = block;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_IDENT_PD: /* ISO 13346 3/10.5 */\n\t\t\tcurr = &vds[VDS_POS_PARTITION_DESC];\n\t\t\tif (!curr->block)\n\t\t\t\tcurr->block = block;\n\t\t\tbreak;\n\t\tcase TAG_IDENT_LVD: /* ISO 13346 3/10.6 */\n\t\t\tcurr = &vds[VDS_POS_LOGICAL_VOL_DESC];\n\t\t\tif (vdsn >= curr->volDescSeqNum) {\n\t\t\t\tcurr->volDescSeqNum = vdsn;\n\t\t\t\tcurr->block = block;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_IDENT_USD: /* ISO 13346 3/10.8 */\n\t\t\tcurr = &vds[VDS_POS_UNALLOC_SPACE_DESC];\n\t\t\tif (vdsn >= curr->volDescSeqNum) {\n\t\t\t\tcurr->volDescSeqNum = vdsn;\n\t\t\t\tcurr->block = block;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_IDENT_TD: /* ISO 13346 3/10.9 */\n\t\t\tvds[VDS_POS_TERMINATING_DESC].block = block;\n\t\t\tif (next_e) {\n\t\t\t\tblock = next_s;\n\t\t\t\tlastblock = next_e;\n\t\t\t\tnext_s = next_e = 0;\n\t\t\t} else\n\t\t\t\tdone = true;\n\t\t\tbreak;\n\t\t}\n\t\tbrelse(bh);\n\t}\n\t/*\n\t * Now read interesting descriptors again and process them\n\t * in a suitable order\n\t */\n\tif (!vds[VDS_POS_PRIMARY_VOL_DESC].block) {\n\t\tudf_err(sb, \"Primary Volume Descriptor not found!\\n\");\n\t\treturn -EAGAIN;\n\t}\n\tret = udf_load_pvoldesc(sb, vds[VDS_POS_PRIMARY_VOL_DESC].block);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (vds[VDS_POS_LOGICAL_VOL_DESC].block) {\n\t\tret = udf_load_logicalvol(sb,\n\t\t\t\t\t  vds[VDS_POS_LOGICAL_VOL_DESC].block,\n\t\t\t\t\t  fileset);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (vds[VDS_POS_PARTITION_DESC].block) {\n\t\t/*\n\t\t * We rescan the whole descriptor sequence to find\n\t\t * partition descriptor blocks and process them.\n\t\t */\n\t\tfor (block = vds[VDS_POS_PARTITION_DESC].block;\n\t\t     block < vds[VDS_POS_TERMINATING_DESC].block;\n\t\t     block++) {\n\t\t\tret = udf_load_partdesc(sb, block);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [
            "#define VDS_POS_LENGTH\t\t\t7",
            "#define VDS_POS_TERMINATING_DESC\t6",
            "#define VDS_POS_VOL_DESC_PTR\t\t5",
            "#define VDS_POS_IMP_USE_VOL_DESC\t4",
            "#define VDS_POS_PARTITION_DESC\t\t3",
            "#define VDS_POS_LOGICAL_VOL_DESC\t2",
            "#define VDS_POS_UNALLOC_SPACE_DESC\t1",
            "#define VDS_POS_PRIMARY_VOL_DESC\t0"
          ],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
            "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\n#define VDS_POS_LENGTH\t\t\t7\n#define VDS_POS_TERMINATING_DESC\t6\n#define VDS_POS_VOL_DESC_PTR\t\t5\n#define VDS_POS_IMP_USE_VOL_DESC\t4\n#define VDS_POS_PARTITION_DESC\t\t3\n#define VDS_POS_LOGICAL_VOL_DESC\t2\n#define VDS_POS_UNALLOC_SPACE_DESC\t1\n#define VDS_POS_PRIMARY_VOL_DESC\t0\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic noinline int udf_process_sequence(\n\t\tstruct super_block *sb,\n\t\tsector_t block, sector_t lastblock,\n\t\tstruct kernel_lb_addr *fileset)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct udf_vds_record vds[VDS_POS_LENGTH];\n\tstruct udf_vds_record *curr;\n\tstruct generic_desc *gd;\n\tstruct volDescPtr *vdp;\n\tbool done = false;\n\tuint32_t vdsn;\n\tuint16_t ident;\n\tlong next_s = 0, next_e = 0;\n\tint ret;\n\n\tmemset(vds, 0, sizeof(struct udf_vds_record) * VDS_POS_LENGTH);\n\n\t/*\n\t * Read the main descriptor sequence and find which descriptors\n\t * are in it.\n\t */\n\tfor (; (!done && block <= lastblock); block++) {\n\n\t\tbh = udf_read_tagged(sb, block, block, &ident);\n\t\tif (!bh) {\n\t\t\tudf_err(sb,\n\t\t\t\t\"Block %llu of volume descriptor sequence is corrupted or we could not read it\\n\",\n\t\t\t\t(unsigned long long)block);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\t/* Process each descriptor (ISO 13346 3/8.3-8.4) */\n\t\tgd = (struct generic_desc *)bh->b_data;\n\t\tvdsn = le32_to_cpu(gd->volDescSeqNum);\n\t\tswitch (ident) {\n\t\tcase TAG_IDENT_PVD: /* ISO 13346 3/10.1 */\n\t\t\tcurr = &vds[VDS_POS_PRIMARY_VOL_DESC];\n\t\t\tif (vdsn >= curr->volDescSeqNum) {\n\t\t\t\tcurr->volDescSeqNum = vdsn;\n\t\t\t\tcurr->block = block;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_IDENT_VDP: /* ISO 13346 3/10.3 */\n\t\t\tcurr = &vds[VDS_POS_VOL_DESC_PTR];\n\t\t\tif (vdsn >= curr->volDescSeqNum) {\n\t\t\t\tcurr->volDescSeqNum = vdsn;\n\t\t\t\tcurr->block = block;\n\n\t\t\t\tvdp = (struct volDescPtr *)bh->b_data;\n\t\t\t\tnext_s = le32_to_cpu(\n\t\t\t\t\tvdp->nextVolDescSeqExt.extLocation);\n\t\t\t\tnext_e = le32_to_cpu(\n\t\t\t\t\tvdp->nextVolDescSeqExt.extLength);\n\t\t\t\tnext_e = next_e >> sb->s_blocksize_bits;\n\t\t\t\tnext_e += next_s;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_IDENT_IUVD: /* ISO 13346 3/10.4 */\n\t\t\tcurr = &vds[VDS_POS_IMP_USE_VOL_DESC];\n\t\t\tif (vdsn >= curr->volDescSeqNum) {\n\t\t\t\tcurr->volDescSeqNum = vdsn;\n\t\t\t\tcurr->block = block;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_IDENT_PD: /* ISO 13346 3/10.5 */\n\t\t\tcurr = &vds[VDS_POS_PARTITION_DESC];\n\t\t\tif (!curr->block)\n\t\t\t\tcurr->block = block;\n\t\t\tbreak;\n\t\tcase TAG_IDENT_LVD: /* ISO 13346 3/10.6 */\n\t\t\tcurr = &vds[VDS_POS_LOGICAL_VOL_DESC];\n\t\t\tif (vdsn >= curr->volDescSeqNum) {\n\t\t\t\tcurr->volDescSeqNum = vdsn;\n\t\t\t\tcurr->block = block;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_IDENT_USD: /* ISO 13346 3/10.8 */\n\t\t\tcurr = &vds[VDS_POS_UNALLOC_SPACE_DESC];\n\t\t\tif (vdsn >= curr->volDescSeqNum) {\n\t\t\t\tcurr->volDescSeqNum = vdsn;\n\t\t\t\tcurr->block = block;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_IDENT_TD: /* ISO 13346 3/10.9 */\n\t\t\tvds[VDS_POS_TERMINATING_DESC].block = block;\n\t\t\tif (next_e) {\n\t\t\t\tblock = next_s;\n\t\t\t\tlastblock = next_e;\n\t\t\t\tnext_s = next_e = 0;\n\t\t\t} else\n\t\t\t\tdone = true;\n\t\t\tbreak;\n\t\t}\n\t\tbrelse(bh);\n\t}\n\t/*\n\t * Now read interesting descriptors again and process them\n\t * in a suitable order\n\t */\n\tif (!vds[VDS_POS_PRIMARY_VOL_DESC].block) {\n\t\tudf_err(sb, \"Primary Volume Descriptor not found!\\n\");\n\t\treturn -EAGAIN;\n\t}\n\tret = udf_load_pvoldesc(sb, vds[VDS_POS_PRIMARY_VOL_DESC].block);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (vds[VDS_POS_LOGICAL_VOL_DESC].block) {\n\t\tret = udf_load_logicalvol(sb,\n\t\t\t\t\t  vds[VDS_POS_LOGICAL_VOL_DESC].block,\n\t\t\t\t\t  fileset);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (vds[VDS_POS_PARTITION_DESC].block) {\n\t\t/*\n\t\t * We rescan the whole descriptor sequence to find\n\t\t * partition descriptor blocks and process them.\n\t\t */\n\t\tfor (block = vds[VDS_POS_PARTITION_DESC].block;\n\t\t     block < vds[VDS_POS_TERMINATING_DESC].block;\n\t\t     block++) {\n\t\t\tret = udf_load_partdesc(sb, block);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "anchor->reserveVolDescSeqExt.extLength"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_load_sequence(struct super_block *sb, struct buffer_head *bh,\n\t\t\t     struct kernel_lb_addr *fileset)\n{\n\tstruct anchorVolDescPtr *anchor;\n\tsector_t main_s, main_e, reserve_s, reserve_e;\n\tint ret;\n\n\tanchor = (struct anchorVolDescPtr *)bh->b_data;\n\n\t/* Locate the main sequence */\n\tmain_s = le32_to_cpu(anchor->mainVolDescSeqExt.extLocation);\n\tmain_e = le32_to_cpu(anchor->mainVolDescSeqExt.extLength);\n\tmain_e = main_e >> sb->s_blocksize_bits;\n\tmain_e += main_s;\n\n\t/* Locate the reserve sequence */\n\treserve_s = le32_to_cpu(anchor->reserveVolDescSeqExt.extLocation);\n\treserve_e = le32_to_cpu(anchor->reserveVolDescSeqExt.extLength);\n\treserve_e = reserve_e >> sb->s_blocksize_bits;\n\treserve_e += reserve_s;\n\n\t/* Process the main & reserve sequences */\n\t/* responsible for finding the PartitionDesc(s) */\n\tret = udf_process_sequence(sb, main_s, main_e, fileset);\n\tif (ret != -EAGAIN)\n\t\treturn ret;\n\tudf_sb_free_partitions(sb);\n\tret = udf_process_sequence(sb, reserve_s, reserve_e, fileset);\n\tif (ret < 0) {\n\t\tudf_sb_free_partitions(sb);\n\t\t/* No sequence was OK, return -EIO */\n\t\tif (ret == -EAGAIN)\n\t\t\tret = -EIO;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "udf_process_sequence",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "1592-1723",
    "snippet": "static noinline int udf_process_sequence(\n\t\tstruct super_block *sb,\n\t\tsector_t block, sector_t lastblock,\n\t\tstruct kernel_lb_addr *fileset)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct udf_vds_record vds[VDS_POS_LENGTH];\n\tstruct udf_vds_record *curr;\n\tstruct generic_desc *gd;\n\tstruct volDescPtr *vdp;\n\tbool done = false;\n\tuint32_t vdsn;\n\tuint16_t ident;\n\tlong next_s = 0, next_e = 0;\n\tint ret;\n\n\tmemset(vds, 0, sizeof(struct udf_vds_record) * VDS_POS_LENGTH);\n\n\t/*\n\t * Read the main descriptor sequence and find which descriptors\n\t * are in it.\n\t */\n\tfor (; (!done && block <= lastblock); block++) {\n\n\t\tbh = udf_read_tagged(sb, block, block, &ident);\n\t\tif (!bh) {\n\t\t\tudf_err(sb,\n\t\t\t\t\"Block %llu of volume descriptor sequence is corrupted or we could not read it\\n\",\n\t\t\t\t(unsigned long long)block);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\t/* Process each descriptor (ISO 13346 3/8.3-8.4) */\n\t\tgd = (struct generic_desc *)bh->b_data;\n\t\tvdsn = le32_to_cpu(gd->volDescSeqNum);\n\t\tswitch (ident) {\n\t\tcase TAG_IDENT_PVD: /* ISO 13346 3/10.1 */\n\t\t\tcurr = &vds[VDS_POS_PRIMARY_VOL_DESC];\n\t\t\tif (vdsn >= curr->volDescSeqNum) {\n\t\t\t\tcurr->volDescSeqNum = vdsn;\n\t\t\t\tcurr->block = block;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_IDENT_VDP: /* ISO 13346 3/10.3 */\n\t\t\tcurr = &vds[VDS_POS_VOL_DESC_PTR];\n\t\t\tif (vdsn >= curr->volDescSeqNum) {\n\t\t\t\tcurr->volDescSeqNum = vdsn;\n\t\t\t\tcurr->block = block;\n\n\t\t\t\tvdp = (struct volDescPtr *)bh->b_data;\n\t\t\t\tnext_s = le32_to_cpu(\n\t\t\t\t\tvdp->nextVolDescSeqExt.extLocation);\n\t\t\t\tnext_e = le32_to_cpu(\n\t\t\t\t\tvdp->nextVolDescSeqExt.extLength);\n\t\t\t\tnext_e = next_e >> sb->s_blocksize_bits;\n\t\t\t\tnext_e += next_s;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_IDENT_IUVD: /* ISO 13346 3/10.4 */\n\t\t\tcurr = &vds[VDS_POS_IMP_USE_VOL_DESC];\n\t\t\tif (vdsn >= curr->volDescSeqNum) {\n\t\t\t\tcurr->volDescSeqNum = vdsn;\n\t\t\t\tcurr->block = block;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_IDENT_PD: /* ISO 13346 3/10.5 */\n\t\t\tcurr = &vds[VDS_POS_PARTITION_DESC];\n\t\t\tif (!curr->block)\n\t\t\t\tcurr->block = block;\n\t\t\tbreak;\n\t\tcase TAG_IDENT_LVD: /* ISO 13346 3/10.6 */\n\t\t\tcurr = &vds[VDS_POS_LOGICAL_VOL_DESC];\n\t\t\tif (vdsn >= curr->volDescSeqNum) {\n\t\t\t\tcurr->volDescSeqNum = vdsn;\n\t\t\t\tcurr->block = block;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_IDENT_USD: /* ISO 13346 3/10.8 */\n\t\t\tcurr = &vds[VDS_POS_UNALLOC_SPACE_DESC];\n\t\t\tif (vdsn >= curr->volDescSeqNum) {\n\t\t\t\tcurr->volDescSeqNum = vdsn;\n\t\t\t\tcurr->block = block;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_IDENT_TD: /* ISO 13346 3/10.9 */\n\t\t\tvds[VDS_POS_TERMINATING_DESC].block = block;\n\t\t\tif (next_e) {\n\t\t\t\tblock = next_s;\n\t\t\t\tlastblock = next_e;\n\t\t\t\tnext_s = next_e = 0;\n\t\t\t} else\n\t\t\t\tdone = true;\n\t\t\tbreak;\n\t\t}\n\t\tbrelse(bh);\n\t}\n\t/*\n\t * Now read interesting descriptors again and process them\n\t * in a suitable order\n\t */\n\tif (!vds[VDS_POS_PRIMARY_VOL_DESC].block) {\n\t\tudf_err(sb, \"Primary Volume Descriptor not found!\\n\");\n\t\treturn -EAGAIN;\n\t}\n\tret = udf_load_pvoldesc(sb, vds[VDS_POS_PRIMARY_VOL_DESC].block);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (vds[VDS_POS_LOGICAL_VOL_DESC].block) {\n\t\tret = udf_load_logicalvol(sb,\n\t\t\t\t\t  vds[VDS_POS_LOGICAL_VOL_DESC].block,\n\t\t\t\t\t  fileset);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (vds[VDS_POS_PARTITION_DESC].block) {\n\t\t/*\n\t\t * We rescan the whole descriptor sequence to find\n\t\t * partition descriptor blocks and process them.\n\t\t */\n\t\tfor (block = vds[VDS_POS_PARTITION_DESC].block;\n\t\t     block < vds[VDS_POS_TERMINATING_DESC].block;\n\t\t     block++) {\n\t\t\tret = udf_load_partdesc(sb, block);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [
      "#define VDS_POS_LENGTH\t\t\t7",
      "#define VDS_POS_TERMINATING_DESC\t6",
      "#define VDS_POS_VOL_DESC_PTR\t\t5",
      "#define VDS_POS_IMP_USE_VOL_DESC\t4",
      "#define VDS_POS_PARTITION_DESC\t\t3",
      "#define VDS_POS_LOGICAL_VOL_DESC\t2",
      "#define VDS_POS_UNALLOC_SPACE_DESC\t1",
      "#define VDS_POS_PRIMARY_VOL_DESC\t0"
    ],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
      "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_load_partdesc",
          "args": [
            "sb",
            "block"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "udf_load_partdesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "1264-1361",
          "snippet": "static int udf_load_partdesc(struct super_block *sb, sector_t block)\n{\n\tstruct buffer_head *bh;\n\tstruct partitionDesc *p;\n\tstruct udf_part_map *map;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint i, type1_idx;\n\tuint16_t partitionNumber;\n\tuint16_t ident;\n\tint ret;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh)\n\t\treturn -EAGAIN;\n\tif (ident != TAG_IDENT_PD) {\n\t\tret = 0;\n\t\tgoto out_bh;\n\t}\n\n\tp = (struct partitionDesc *)bh->b_data;\n\tpartitionNumber = le16_to_cpu(p->partitionNumber);\n\n\t/* First scan for TYPE1, SPARABLE and METADATA partitions */\n\tfor (i = 0; i < sbi->s_partitions; i++) {\n\t\tmap = &sbi->s_partmaps[i];\n\t\tudf_debug(\"Searching map: (%d == %d)\\n\",\n\t\t\t  map->s_partition_num, partitionNumber);\n\t\tif (map->s_partition_num == partitionNumber &&\n\t\t    (map->s_partition_type == UDF_TYPE1_MAP15 ||\n\t\t     map->s_partition_type == UDF_SPARABLE_MAP15))\n\t\t\tbreak;\n\t}\n\n\tif (i >= sbi->s_partitions) {\n\t\tudf_debug(\"Partition (%d) not found in partition map\\n\",\n\t\t\t  partitionNumber);\n\t\tret = 0;\n\t\tgoto out_bh;\n\t}\n\n\tret = udf_fill_partdesc_info(sb, p, i);\n\tif (ret < 0)\n\t\tgoto out_bh;\n\n\t/*\n\t * Now rescan for VIRTUAL or METADATA partitions when SPARABLE and\n\t * PHYSICAL partitions are already set up\n\t */\n\ttype1_idx = i;\n#ifdef UDFFS_DEBUG\n\tmap = NULL; /* supress 'maybe used uninitialized' warning */\n#endif\n\tfor (i = 0; i < sbi->s_partitions; i++) {\n\t\tmap = &sbi->s_partmaps[i];\n\n\t\tif (map->s_partition_num == partitionNumber &&\n\t\t    (map->s_partition_type == UDF_VIRTUAL_MAP15 ||\n\t\t     map->s_partition_type == UDF_VIRTUAL_MAP20 ||\n\t\t     map->s_partition_type == UDF_METADATA_MAP25))\n\t\t\tbreak;\n\t}\n\n\tif (i >= sbi->s_partitions) {\n\t\tret = 0;\n\t\tgoto out_bh;\n\t}\n\n\tret = udf_fill_partdesc_info(sb, p, i);\n\tif (ret < 0)\n\t\tgoto out_bh;\n\n\tif (map->s_partition_type == UDF_METADATA_MAP25) {\n\t\tret = udf_load_metadata_files(sb, i);\n\t\tif (ret < 0) {\n\t\t\tudf_err(sb, \"error loading MetaData partition map %d\\n\",\n\t\t\t\ti);\n\t\t\tgoto out_bh;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * If we have a partition with virtual map, we don't handle\n\t\t * writing to it (we overwrite blocks instead of relocating\n\t\t * them).\n\t\t */\n\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\tret = -EACCES;\n\t\t\tgoto out_bh;\n\t\t}\n\t\tret = udf_load_vat(sb, i, type1_idx);\n\t\tif (ret < 0)\n\t\t\tgoto out_bh;\n\t}\n\tret = 0;\nout_bh:\n\t/* In case loading failed, we handle cleanup in udf_fill_super */\n\tbrelse(bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_load_partdesc(struct super_block *sb, sector_t block)\n{\n\tstruct buffer_head *bh;\n\tstruct partitionDesc *p;\n\tstruct udf_part_map *map;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint i, type1_idx;\n\tuint16_t partitionNumber;\n\tuint16_t ident;\n\tint ret;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh)\n\t\treturn -EAGAIN;\n\tif (ident != TAG_IDENT_PD) {\n\t\tret = 0;\n\t\tgoto out_bh;\n\t}\n\n\tp = (struct partitionDesc *)bh->b_data;\n\tpartitionNumber = le16_to_cpu(p->partitionNumber);\n\n\t/* First scan for TYPE1, SPARABLE and METADATA partitions */\n\tfor (i = 0; i < sbi->s_partitions; i++) {\n\t\tmap = &sbi->s_partmaps[i];\n\t\tudf_debug(\"Searching map: (%d == %d)\\n\",\n\t\t\t  map->s_partition_num, partitionNumber);\n\t\tif (map->s_partition_num == partitionNumber &&\n\t\t    (map->s_partition_type == UDF_TYPE1_MAP15 ||\n\t\t     map->s_partition_type == UDF_SPARABLE_MAP15))\n\t\t\tbreak;\n\t}\n\n\tif (i >= sbi->s_partitions) {\n\t\tudf_debug(\"Partition (%d) not found in partition map\\n\",\n\t\t\t  partitionNumber);\n\t\tret = 0;\n\t\tgoto out_bh;\n\t}\n\n\tret = udf_fill_partdesc_info(sb, p, i);\n\tif (ret < 0)\n\t\tgoto out_bh;\n\n\t/*\n\t * Now rescan for VIRTUAL or METADATA partitions when SPARABLE and\n\t * PHYSICAL partitions are already set up\n\t */\n\ttype1_idx = i;\n#ifdef UDFFS_DEBUG\n\tmap = NULL; /* supress 'maybe used uninitialized' warning */\n#endif\n\tfor (i = 0; i < sbi->s_partitions; i++) {\n\t\tmap = &sbi->s_partmaps[i];\n\n\t\tif (map->s_partition_num == partitionNumber &&\n\t\t    (map->s_partition_type == UDF_VIRTUAL_MAP15 ||\n\t\t     map->s_partition_type == UDF_VIRTUAL_MAP20 ||\n\t\t     map->s_partition_type == UDF_METADATA_MAP25))\n\t\t\tbreak;\n\t}\n\n\tif (i >= sbi->s_partitions) {\n\t\tret = 0;\n\t\tgoto out_bh;\n\t}\n\n\tret = udf_fill_partdesc_info(sb, p, i);\n\tif (ret < 0)\n\t\tgoto out_bh;\n\n\tif (map->s_partition_type == UDF_METADATA_MAP25) {\n\t\tret = udf_load_metadata_files(sb, i);\n\t\tif (ret < 0) {\n\t\t\tudf_err(sb, \"error loading MetaData partition map %d\\n\",\n\t\t\t\ti);\n\t\t\tgoto out_bh;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * If we have a partition with virtual map, we don't handle\n\t\t * writing to it (we overwrite blocks instead of relocating\n\t\t * them).\n\t\t */\n\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\tret = -EACCES;\n\t\t\tgoto out_bh;\n\t\t}\n\t\tret = udf_load_vat(sb, i, type1_idx);\n\t\tif (ret < 0)\n\t\t\tgoto out_bh;\n\t}\n\tret = 0;\nout_bh:\n\t/* In case loading failed, we handle cleanup in udf_fill_super */\n\tbrelse(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_load_logicalvol",
          "args": [
            "sb",
            "vds[VDS_POS_LOGICAL_VOL_DESC].block",
            "fileset"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "udf_load_logicalvol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "1411-1550",
          "snippet": "static int udf_load_logicalvol(struct super_block *sb, sector_t block,\n\t\t\t       struct kernel_lb_addr *fileset)\n{\n\tstruct logicalVolDesc *lvd;\n\tint i, offset;\n\tuint8_t type;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct genericPartitionMap *gpm;\n\tuint16_t ident;\n\tstruct buffer_head *bh;\n\tunsigned int table_len;\n\tint ret;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh)\n\t\treturn -EAGAIN;\n\tBUG_ON(ident != TAG_IDENT_LVD);\n\tlvd = (struct logicalVolDesc *)bh->b_data;\n\ttable_len = le32_to_cpu(lvd->mapTableLength);\n\tif (table_len > sb->s_blocksize - sizeof(*lvd)) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Partition table too long (%u > %lu)\\n\", table_len,\n\t\t\tsb->s_blocksize - sizeof(*lvd));\n\t\tret = -EIO;\n\t\tgoto out_bh;\n\t}\n\n\tret = udf_sb_alloc_partition_maps(sb, le32_to_cpu(lvd->numPartitionMaps));\n\tif (ret)\n\t\tgoto out_bh;\n\n\tfor (i = 0, offset = 0;\n\t     i < sbi->s_partitions && offset < table_len;\n\t     i++, offset += gpm->partitionMapLength) {\n\t\tstruct udf_part_map *map = &sbi->s_partmaps[i];\n\t\tgpm = (struct genericPartitionMap *)\n\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\ttype = gpm->partitionMapType;\n\t\tif (type == 1) {\n\t\t\tstruct genericPartitionMap1 *gpm1 =\n\t\t\t\t(struct genericPartitionMap1 *)gpm;\n\t\t\tmap->s_partition_type = UDF_TYPE1_MAP15;\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(gpm1->volSeqNum);\n\t\t\tmap->s_partition_num = le16_to_cpu(gpm1->partitionNum);\n\t\t\tmap->s_partition_func = NULL;\n\t\t} else if (type == 2) {\n\t\t\tstruct udfPartitionMap2 *upm2 =\n\t\t\t\t\t\t(struct udfPartitionMap2 *)gpm;\n\t\t\tif (!strncmp(upm2->partIdent.ident, UDF_ID_VIRTUAL,\n\t\t\t\t\t\tstrlen(UDF_ID_VIRTUAL))) {\n\t\t\t\tu16 suf =\n\t\t\t\t\tle16_to_cpu(((__le16 *)upm2->partIdent.\n\t\t\t\t\t\t\tidentSuffix)[0]);\n\t\t\t\tif (suf < 0x0200) {\n\t\t\t\t\tmap->s_partition_type =\n\t\t\t\t\t\t\tUDF_VIRTUAL_MAP15;\n\t\t\t\t\tmap->s_partition_func =\n\t\t\t\t\t\t\tudf_get_pblock_virt15;\n\t\t\t\t} else {\n\t\t\t\t\tmap->s_partition_type =\n\t\t\t\t\t\t\tUDF_VIRTUAL_MAP20;\n\t\t\t\t\tmap->s_partition_func =\n\t\t\t\t\t\t\tudf_get_pblock_virt20;\n\t\t\t\t}\n\t\t\t} else if (!strncmp(upm2->partIdent.ident,\n\t\t\t\t\t\tUDF_ID_SPARABLE,\n\t\t\t\t\t\tstrlen(UDF_ID_SPARABLE))) {\n\t\t\t\tret = udf_load_sparable_map(sb, map,\n\t\t\t\t\t(struct sparablePartitionMap *)gpm);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out_bh;\n\t\t\t} else if (!strncmp(upm2->partIdent.ident,\n\t\t\t\t\t\tUDF_ID_METADATA,\n\t\t\t\t\t\tstrlen(UDF_ID_METADATA))) {\n\t\t\t\tstruct udf_meta_data *mdata =\n\t\t\t\t\t&map->s_type_specific.s_metadata;\n\t\t\t\tstruct metadataPartitionMap *mdm =\n\t\t\t\t\t\t(struct metadataPartitionMap *)\n\t\t\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\t\t\tudf_debug(\"Parsing Logical vol part %d type %d  id=%s\\n\",\n\t\t\t\t\t  i, type, UDF_ID_METADATA);\n\n\t\t\t\tmap->s_partition_type = UDF_METADATA_MAP25;\n\t\t\t\tmap->s_partition_func = udf_get_pblock_meta25;\n\n\t\t\t\tmdata->s_meta_file_loc   =\n\t\t\t\t\tle32_to_cpu(mdm->metadataFileLoc);\n\t\t\t\tmdata->s_mirror_file_loc =\n\t\t\t\t\tle32_to_cpu(mdm->metadataMirrorFileLoc);\n\t\t\t\tmdata->s_bitmap_file_loc =\n\t\t\t\t\tle32_to_cpu(mdm->metadataBitmapFileLoc);\n\t\t\t\tmdata->s_alloc_unit_size =\n\t\t\t\t\tle32_to_cpu(mdm->allocUnitSize);\n\t\t\t\tmdata->s_align_unit_size =\n\t\t\t\t\tle16_to_cpu(mdm->alignUnitSize);\n\t\t\t\tif (mdm->flags & 0x01)\n\t\t\t\t\tmdata->s_flags |= MF_DUPLICATE_MD;\n\n\t\t\t\tudf_debug(\"Metadata Ident suffix=0x%x\\n\",\n\t\t\t\t\t  le16_to_cpu(*(__le16 *)\n\t\t\t\t\t\t      mdm->partIdent.identSuffix));\n\t\t\t\tudf_debug(\"Metadata part num=%d\\n\",\n\t\t\t\t\t  le16_to_cpu(mdm->partitionNum));\n\t\t\t\tudf_debug(\"Metadata part alloc unit size=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->allocUnitSize));\n\t\t\t\tudf_debug(\"Metadata file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataFileLoc));\n\t\t\t\tudf_debug(\"Mirror file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataMirrorFileLoc));\n\t\t\t\tudf_debug(\"Bitmap file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataBitmapFileLoc));\n\t\t\t\tudf_debug(\"Flags: %d %d\\n\",\n\t\t\t\t\t  mdata->s_flags, mdm->flags);\n\t\t\t} else {\n\t\t\t\tudf_debug(\"Unknown ident: %s\\n\",\n\t\t\t\t\t  upm2->partIdent.ident);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(upm2->volSeqNum);\n\t\t\tmap->s_partition_num = le16_to_cpu(upm2->partitionNum);\n\t\t}\n\t\tudf_debug(\"Partition (%d:%d) type %d on volume %d\\n\",\n\t\t\t  i, map->s_partition_num, type, map->s_volumeseqnum);\n\t}\n\n\tif (fileset) {\n\t\tstruct long_ad *la = (struct long_ad *)&(lvd->logicalVolContentsUse[0]);\n\n\t\t*fileset = lelb_to_cpu(la->extLocation);\n\t\tudf_debug(\"FileSet found in LogicalVolDesc at block=%d, partition=%d\\n\",\n\t\t\t  fileset->logicalBlockNum,\n\t\t\t  fileset->partitionReferenceNum);\n\t}\n\tif (lvd->integritySeqExt.extLength)\n\t\tudf_load_logicalvolint(sb, leea_to_cpu(lvd->integritySeqExt));\n\tret = 0;\nout_bh:\n\tbrelse(bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
            "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_load_logicalvol(struct super_block *sb, sector_t block,\n\t\t\t       struct kernel_lb_addr *fileset)\n{\n\tstruct logicalVolDesc *lvd;\n\tint i, offset;\n\tuint8_t type;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct genericPartitionMap *gpm;\n\tuint16_t ident;\n\tstruct buffer_head *bh;\n\tunsigned int table_len;\n\tint ret;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh)\n\t\treturn -EAGAIN;\n\tBUG_ON(ident != TAG_IDENT_LVD);\n\tlvd = (struct logicalVolDesc *)bh->b_data;\n\ttable_len = le32_to_cpu(lvd->mapTableLength);\n\tif (table_len > sb->s_blocksize - sizeof(*lvd)) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Partition table too long (%u > %lu)\\n\", table_len,\n\t\t\tsb->s_blocksize - sizeof(*lvd));\n\t\tret = -EIO;\n\t\tgoto out_bh;\n\t}\n\n\tret = udf_sb_alloc_partition_maps(sb, le32_to_cpu(lvd->numPartitionMaps));\n\tif (ret)\n\t\tgoto out_bh;\n\n\tfor (i = 0, offset = 0;\n\t     i < sbi->s_partitions && offset < table_len;\n\t     i++, offset += gpm->partitionMapLength) {\n\t\tstruct udf_part_map *map = &sbi->s_partmaps[i];\n\t\tgpm = (struct genericPartitionMap *)\n\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\ttype = gpm->partitionMapType;\n\t\tif (type == 1) {\n\t\t\tstruct genericPartitionMap1 *gpm1 =\n\t\t\t\t(struct genericPartitionMap1 *)gpm;\n\t\t\tmap->s_partition_type = UDF_TYPE1_MAP15;\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(gpm1->volSeqNum);\n\t\t\tmap->s_partition_num = le16_to_cpu(gpm1->partitionNum);\n\t\t\tmap->s_partition_func = NULL;\n\t\t} else if (type == 2) {\n\t\t\tstruct udfPartitionMap2 *upm2 =\n\t\t\t\t\t\t(struct udfPartitionMap2 *)gpm;\n\t\t\tif (!strncmp(upm2->partIdent.ident, UDF_ID_VIRTUAL,\n\t\t\t\t\t\tstrlen(UDF_ID_VIRTUAL))) {\n\t\t\t\tu16 suf =\n\t\t\t\t\tle16_to_cpu(((__le16 *)upm2->partIdent.\n\t\t\t\t\t\t\tidentSuffix)[0]);\n\t\t\t\tif (suf < 0x0200) {\n\t\t\t\t\tmap->s_partition_type =\n\t\t\t\t\t\t\tUDF_VIRTUAL_MAP15;\n\t\t\t\t\tmap->s_partition_func =\n\t\t\t\t\t\t\tudf_get_pblock_virt15;\n\t\t\t\t} else {\n\t\t\t\t\tmap->s_partition_type =\n\t\t\t\t\t\t\tUDF_VIRTUAL_MAP20;\n\t\t\t\t\tmap->s_partition_func =\n\t\t\t\t\t\t\tudf_get_pblock_virt20;\n\t\t\t\t}\n\t\t\t} else if (!strncmp(upm2->partIdent.ident,\n\t\t\t\t\t\tUDF_ID_SPARABLE,\n\t\t\t\t\t\tstrlen(UDF_ID_SPARABLE))) {\n\t\t\t\tret = udf_load_sparable_map(sb, map,\n\t\t\t\t\t(struct sparablePartitionMap *)gpm);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out_bh;\n\t\t\t} else if (!strncmp(upm2->partIdent.ident,\n\t\t\t\t\t\tUDF_ID_METADATA,\n\t\t\t\t\t\tstrlen(UDF_ID_METADATA))) {\n\t\t\t\tstruct udf_meta_data *mdata =\n\t\t\t\t\t&map->s_type_specific.s_metadata;\n\t\t\t\tstruct metadataPartitionMap *mdm =\n\t\t\t\t\t\t(struct metadataPartitionMap *)\n\t\t\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\t\t\tudf_debug(\"Parsing Logical vol part %d type %d  id=%s\\n\",\n\t\t\t\t\t  i, type, UDF_ID_METADATA);\n\n\t\t\t\tmap->s_partition_type = UDF_METADATA_MAP25;\n\t\t\t\tmap->s_partition_func = udf_get_pblock_meta25;\n\n\t\t\t\tmdata->s_meta_file_loc   =\n\t\t\t\t\tle32_to_cpu(mdm->metadataFileLoc);\n\t\t\t\tmdata->s_mirror_file_loc =\n\t\t\t\t\tle32_to_cpu(mdm->metadataMirrorFileLoc);\n\t\t\t\tmdata->s_bitmap_file_loc =\n\t\t\t\t\tle32_to_cpu(mdm->metadataBitmapFileLoc);\n\t\t\t\tmdata->s_alloc_unit_size =\n\t\t\t\t\tle32_to_cpu(mdm->allocUnitSize);\n\t\t\t\tmdata->s_align_unit_size =\n\t\t\t\t\tle16_to_cpu(mdm->alignUnitSize);\n\t\t\t\tif (mdm->flags & 0x01)\n\t\t\t\t\tmdata->s_flags |= MF_DUPLICATE_MD;\n\n\t\t\t\tudf_debug(\"Metadata Ident suffix=0x%x\\n\",\n\t\t\t\t\t  le16_to_cpu(*(__le16 *)\n\t\t\t\t\t\t      mdm->partIdent.identSuffix));\n\t\t\t\tudf_debug(\"Metadata part num=%d\\n\",\n\t\t\t\t\t  le16_to_cpu(mdm->partitionNum));\n\t\t\t\tudf_debug(\"Metadata part alloc unit size=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->allocUnitSize));\n\t\t\t\tudf_debug(\"Metadata file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataFileLoc));\n\t\t\t\tudf_debug(\"Mirror file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataMirrorFileLoc));\n\t\t\t\tudf_debug(\"Bitmap file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataBitmapFileLoc));\n\t\t\t\tudf_debug(\"Flags: %d %d\\n\",\n\t\t\t\t\t  mdata->s_flags, mdm->flags);\n\t\t\t} else {\n\t\t\t\tudf_debug(\"Unknown ident: %s\\n\",\n\t\t\t\t\t  upm2->partIdent.ident);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(upm2->volSeqNum);\n\t\t\tmap->s_partition_num = le16_to_cpu(upm2->partitionNum);\n\t\t}\n\t\tudf_debug(\"Partition (%d:%d) type %d on volume %d\\n\",\n\t\t\t  i, map->s_partition_num, type, map->s_volumeseqnum);\n\t}\n\n\tif (fileset) {\n\t\tstruct long_ad *la = (struct long_ad *)&(lvd->logicalVolContentsUse[0]);\n\n\t\t*fileset = lelb_to_cpu(la->extLocation);\n\t\tudf_debug(\"FileSet found in LogicalVolDesc at block=%d, partition=%d\\n\",\n\t\t\t  fileset->logicalBlockNum,\n\t\t\t  fileset->partitionReferenceNum);\n\t}\n\tif (lvd->integritySeqExt.extLength)\n\t\tudf_load_logicalvolint(sb, leea_to_cpu(lvd->integritySeqExt));\n\tret = 0;\nout_bh:\n\tbrelse(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_load_pvoldesc",
          "args": [
            "sb",
            "vds[VDS_POS_PRIMARY_VOL_DESC].block"
          ],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "udf_load_pvoldesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "892-951",
          "snippet": "static int udf_load_pvoldesc(struct super_block *sb, sector_t block)\n{\n\tstruct primaryVolDesc *pvoldesc;\n\tstruct ustr *instr, *outstr;\n\tstruct buffer_head *bh;\n\tuint16_t ident;\n\tint ret = -ENOMEM;\n\n\tinstr = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!instr)\n\t\treturn -ENOMEM;\n\n\toutstr = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!outstr)\n\t\tgoto out1;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh) {\n\t\tret = -EAGAIN;\n\t\tgoto out2;\n\t}\n\n\tif (ident != TAG_IDENT_PVD) {\n\t\tret = -EIO;\n\t\tgoto out_bh;\n\t}\n\n\tpvoldesc = (struct primaryVolDesc *)bh->b_data;\n\n\tif (udf_disk_stamp_to_time(&UDF_SB(sb)->s_record_time,\n\t\t\t      pvoldesc->recordingDateAndTime)) {\n#ifdef UDFFS_DEBUG\n\t\tstruct timestamp *ts = &pvoldesc->recordingDateAndTime;\n\t\tudf_debug(\"recording time %04u/%02u/%02u %02u:%02u (%x)\\n\",\n\t\t\t  le16_to_cpu(ts->year), ts->month, ts->day, ts->hour,\n\t\t\t  ts->minute, le16_to_cpu(ts->typeAndTimezone));\n#endif\n\t}\n\n\tif (!udf_build_ustr(instr, pvoldesc->volIdent, 32))\n\t\tif (udf_CS0toUTF8(outstr, instr)) {\n\t\t\tstrncpy(UDF_SB(sb)->s_volume_ident, outstr->u_name,\n\t\t\t\toutstr->u_len > 31 ? 31 : outstr->u_len);\n\t\t\tudf_debug(\"volIdent[] = '%s'\\n\",\n\t\t\t\t  UDF_SB(sb)->s_volume_ident);\n\t\t}\n\n\tif (!udf_build_ustr(instr, pvoldesc->volSetIdent, 128))\n\t\tif (udf_CS0toUTF8(outstr, instr))\n\t\t\tudf_debug(\"volSetIdent[] = '%s'\\n\", outstr->u_name);\n\n\tret = 0;\nout_bh:\n\tbrelse(bh);\nout2:\n\tkfree(outstr);\nout1:\n\tkfree(instr);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_load_pvoldesc(struct super_block *sb, sector_t block)\n{\n\tstruct primaryVolDesc *pvoldesc;\n\tstruct ustr *instr, *outstr;\n\tstruct buffer_head *bh;\n\tuint16_t ident;\n\tint ret = -ENOMEM;\n\n\tinstr = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!instr)\n\t\treturn -ENOMEM;\n\n\toutstr = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!outstr)\n\t\tgoto out1;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh) {\n\t\tret = -EAGAIN;\n\t\tgoto out2;\n\t}\n\n\tif (ident != TAG_IDENT_PVD) {\n\t\tret = -EIO;\n\t\tgoto out_bh;\n\t}\n\n\tpvoldesc = (struct primaryVolDesc *)bh->b_data;\n\n\tif (udf_disk_stamp_to_time(&UDF_SB(sb)->s_record_time,\n\t\t\t      pvoldesc->recordingDateAndTime)) {\n#ifdef UDFFS_DEBUG\n\t\tstruct timestamp *ts = &pvoldesc->recordingDateAndTime;\n\t\tudf_debug(\"recording time %04u/%02u/%02u %02u:%02u (%x)\\n\",\n\t\t\t  le16_to_cpu(ts->year), ts->month, ts->day, ts->hour,\n\t\t\t  ts->minute, le16_to_cpu(ts->typeAndTimezone));\n#endif\n\t}\n\n\tif (!udf_build_ustr(instr, pvoldesc->volIdent, 32))\n\t\tif (udf_CS0toUTF8(outstr, instr)) {\n\t\t\tstrncpy(UDF_SB(sb)->s_volume_ident, outstr->u_name,\n\t\t\t\toutstr->u_len > 31 ? 31 : outstr->u_len);\n\t\t\tudf_debug(\"volIdent[] = '%s'\\n\",\n\t\t\t\t  UDF_SB(sb)->s_volume_ident);\n\t\t}\n\n\tif (!udf_build_ustr(instr, pvoldesc->volSetIdent, 128))\n\t\tif (udf_CS0toUTF8(outstr, instr))\n\t\t\tudf_debug(\"volSetIdent[] = '%s'\\n\", outstr->u_name);\n\n\tret = 0;\nout_bh:\n\tbrelse(bh);\nout2:\n\tkfree(outstr);\nout1:\n\tkfree(instr);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_err",
          "args": [
            "sb",
            "\"Primary Volume Descriptor not found!\\n\""
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "vdp->nextVolDescSeqExt.extLength"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_err",
          "args": [
            "sb",
            "\"Block %llu of volume descriptor sequence is corrupted or we could not read it\\n\"",
            "(unsigned long long)block"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "_udf_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "2256-2270",
          "snippet": "void _udf_err(struct super_block *sb, const char *function,\n\t      const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nvoid _udf_err(struct super_block *sb, const char *function,\n\t      const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_read_tagged",
          "args": [
            "sb",
            "block",
            "block",
            "&ident"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "udf_read_tagged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "202-259",
          "snippet": "struct buffer_head *udf_read_tagged(struct super_block *sb, uint32_t block,\n\t\t\t\t    uint32_t location, uint16_t *ident)\n{\n\tstruct tag *tag_p;\n\tstruct buffer_head *bh = NULL;\n\tu8 checksum;\n\n\t/* Read the block */\n\tif (block == 0xFFFFFFFF)\n\t\treturn NULL;\n\n\tbh = udf_tread(sb, block);\n\tif (!bh) {\n\t\tudf_err(sb, \"read failed, block=%u, location=%d\\n\",\n\t\t\tblock, location);\n\t\treturn NULL;\n\t}\n\n\ttag_p = (struct tag *)(bh->b_data);\n\n\t*ident = le16_to_cpu(tag_p->tagIdent);\n\n\tif (location != le32_to_cpu(tag_p->tagLocation)) {\n\t\tudf_debug(\"location mismatch block %u, tag %u != %u\\n\",\n\t\t\t  block, le32_to_cpu(tag_p->tagLocation), location);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag checksum */\n\tchecksum = udf_tag_checksum(tag_p);\n\tif (checksum != tag_p->tagChecksum) {\n\t\tudf_err(sb, \"tag checksum failed, block %u: 0x%02x != 0x%02x\\n\",\n\t\t\tblock, checksum, tag_p->tagChecksum);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag version */\n\tif (tag_p->descVersion != cpu_to_le16(0x0002U) &&\n\t    tag_p->descVersion != cpu_to_le16(0x0003U)) {\n\t\tudf_err(sb, \"tag version 0x%04x != 0x0002 || 0x0003, block %u\\n\",\n\t\t\tle16_to_cpu(tag_p->descVersion), block);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the descriptor CRC */\n\tif (le16_to_cpu(tag_p->descCRCLength) + sizeof(struct tag) > sb->s_blocksize ||\n\t    le16_to_cpu(tag_p->descCRC) == crc_itu_t(0,\n\t\t\t\t\tbh->b_data + sizeof(struct tag),\n\t\t\t\t\tle16_to_cpu(tag_p->descCRCLength)))\n\t\treturn bh;\n\n\tudf_debug(\"Crc failure block %d: crc = %d, crclen = %d\\n\", block,\n\t\t  le16_to_cpu(tag_p->descCRC),\n\t\t  le16_to_cpu(tag_p->descCRCLength));\nerror_out:\n\tbrelse(bh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_read_tagged(struct super_block *sb, uint32_t block,\n\t\t\t\t    uint32_t location, uint16_t *ident)\n{\n\tstruct tag *tag_p;\n\tstruct buffer_head *bh = NULL;\n\tu8 checksum;\n\n\t/* Read the block */\n\tif (block == 0xFFFFFFFF)\n\t\treturn NULL;\n\n\tbh = udf_tread(sb, block);\n\tif (!bh) {\n\t\tudf_err(sb, \"read failed, block=%u, location=%d\\n\",\n\t\t\tblock, location);\n\t\treturn NULL;\n\t}\n\n\ttag_p = (struct tag *)(bh->b_data);\n\n\t*ident = le16_to_cpu(tag_p->tagIdent);\n\n\tif (location != le32_to_cpu(tag_p->tagLocation)) {\n\t\tudf_debug(\"location mismatch block %u, tag %u != %u\\n\",\n\t\t\t  block, le32_to_cpu(tag_p->tagLocation), location);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag checksum */\n\tchecksum = udf_tag_checksum(tag_p);\n\tif (checksum != tag_p->tagChecksum) {\n\t\tudf_err(sb, \"tag checksum failed, block %u: 0x%02x != 0x%02x\\n\",\n\t\t\tblock, checksum, tag_p->tagChecksum);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag version */\n\tif (tag_p->descVersion != cpu_to_le16(0x0002U) &&\n\t    tag_p->descVersion != cpu_to_le16(0x0003U)) {\n\t\tudf_err(sb, \"tag version 0x%04x != 0x0002 || 0x0003, block %u\\n\",\n\t\t\tle16_to_cpu(tag_p->descVersion), block);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the descriptor CRC */\n\tif (le16_to_cpu(tag_p->descCRCLength) + sizeof(struct tag) > sb->s_blocksize ||\n\t    le16_to_cpu(tag_p->descCRC) == crc_itu_t(0,\n\t\t\t\t\tbh->b_data + sizeof(struct tag),\n\t\t\t\t\tle16_to_cpu(tag_p->descCRCLength)))\n\t\treturn bh;\n\n\tudf_debug(\"Crc failure block %d: crc = %d, crclen = %d\\n\", block,\n\t\t  le16_to_cpu(tag_p->descCRC),\n\t\t  le16_to_cpu(tag_p->descCRCLength));\nerror_out:\n\tbrelse(bh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "vds",
            "0",
            "sizeof(struct udf_vds_record) * VDS_POS_LENGTH"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\n#define VDS_POS_LENGTH\t\t\t7\n#define VDS_POS_TERMINATING_DESC\t6\n#define VDS_POS_VOL_DESC_PTR\t\t5\n#define VDS_POS_IMP_USE_VOL_DESC\t4\n#define VDS_POS_PARTITION_DESC\t\t3\n#define VDS_POS_LOGICAL_VOL_DESC\t2\n#define VDS_POS_UNALLOC_SPACE_DESC\t1\n#define VDS_POS_PRIMARY_VOL_DESC\t0\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic noinline int udf_process_sequence(\n\t\tstruct super_block *sb,\n\t\tsector_t block, sector_t lastblock,\n\t\tstruct kernel_lb_addr *fileset)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct udf_vds_record vds[VDS_POS_LENGTH];\n\tstruct udf_vds_record *curr;\n\tstruct generic_desc *gd;\n\tstruct volDescPtr *vdp;\n\tbool done = false;\n\tuint32_t vdsn;\n\tuint16_t ident;\n\tlong next_s = 0, next_e = 0;\n\tint ret;\n\n\tmemset(vds, 0, sizeof(struct udf_vds_record) * VDS_POS_LENGTH);\n\n\t/*\n\t * Read the main descriptor sequence and find which descriptors\n\t * are in it.\n\t */\n\tfor (; (!done && block <= lastblock); block++) {\n\n\t\tbh = udf_read_tagged(sb, block, block, &ident);\n\t\tif (!bh) {\n\t\t\tudf_err(sb,\n\t\t\t\t\"Block %llu of volume descriptor sequence is corrupted or we could not read it\\n\",\n\t\t\t\t(unsigned long long)block);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\t/* Process each descriptor (ISO 13346 3/8.3-8.4) */\n\t\tgd = (struct generic_desc *)bh->b_data;\n\t\tvdsn = le32_to_cpu(gd->volDescSeqNum);\n\t\tswitch (ident) {\n\t\tcase TAG_IDENT_PVD: /* ISO 13346 3/10.1 */\n\t\t\tcurr = &vds[VDS_POS_PRIMARY_VOL_DESC];\n\t\t\tif (vdsn >= curr->volDescSeqNum) {\n\t\t\t\tcurr->volDescSeqNum = vdsn;\n\t\t\t\tcurr->block = block;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_IDENT_VDP: /* ISO 13346 3/10.3 */\n\t\t\tcurr = &vds[VDS_POS_VOL_DESC_PTR];\n\t\t\tif (vdsn >= curr->volDescSeqNum) {\n\t\t\t\tcurr->volDescSeqNum = vdsn;\n\t\t\t\tcurr->block = block;\n\n\t\t\t\tvdp = (struct volDescPtr *)bh->b_data;\n\t\t\t\tnext_s = le32_to_cpu(\n\t\t\t\t\tvdp->nextVolDescSeqExt.extLocation);\n\t\t\t\tnext_e = le32_to_cpu(\n\t\t\t\t\tvdp->nextVolDescSeqExt.extLength);\n\t\t\t\tnext_e = next_e >> sb->s_blocksize_bits;\n\t\t\t\tnext_e += next_s;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_IDENT_IUVD: /* ISO 13346 3/10.4 */\n\t\t\tcurr = &vds[VDS_POS_IMP_USE_VOL_DESC];\n\t\t\tif (vdsn >= curr->volDescSeqNum) {\n\t\t\t\tcurr->volDescSeqNum = vdsn;\n\t\t\t\tcurr->block = block;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_IDENT_PD: /* ISO 13346 3/10.5 */\n\t\t\tcurr = &vds[VDS_POS_PARTITION_DESC];\n\t\t\tif (!curr->block)\n\t\t\t\tcurr->block = block;\n\t\t\tbreak;\n\t\tcase TAG_IDENT_LVD: /* ISO 13346 3/10.6 */\n\t\t\tcurr = &vds[VDS_POS_LOGICAL_VOL_DESC];\n\t\t\tif (vdsn >= curr->volDescSeqNum) {\n\t\t\t\tcurr->volDescSeqNum = vdsn;\n\t\t\t\tcurr->block = block;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_IDENT_USD: /* ISO 13346 3/10.8 */\n\t\t\tcurr = &vds[VDS_POS_UNALLOC_SPACE_DESC];\n\t\t\tif (vdsn >= curr->volDescSeqNum) {\n\t\t\t\tcurr->volDescSeqNum = vdsn;\n\t\t\t\tcurr->block = block;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_IDENT_TD: /* ISO 13346 3/10.9 */\n\t\t\tvds[VDS_POS_TERMINATING_DESC].block = block;\n\t\t\tif (next_e) {\n\t\t\t\tblock = next_s;\n\t\t\t\tlastblock = next_e;\n\t\t\t\tnext_s = next_e = 0;\n\t\t\t} else\n\t\t\t\tdone = true;\n\t\t\tbreak;\n\t\t}\n\t\tbrelse(bh);\n\t}\n\t/*\n\t * Now read interesting descriptors again and process them\n\t * in a suitable order\n\t */\n\tif (!vds[VDS_POS_PRIMARY_VOL_DESC].block) {\n\t\tudf_err(sb, \"Primary Volume Descriptor not found!\\n\");\n\t\treturn -EAGAIN;\n\t}\n\tret = udf_load_pvoldesc(sb, vds[VDS_POS_PRIMARY_VOL_DESC].block);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (vds[VDS_POS_LOGICAL_VOL_DESC].block) {\n\t\tret = udf_load_logicalvol(sb,\n\t\t\t\t\t  vds[VDS_POS_LOGICAL_VOL_DESC].block,\n\t\t\t\t\t  fileset);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (vds[VDS_POS_PARTITION_DESC].block) {\n\t\t/*\n\t\t * We rescan the whole descriptor sequence to find\n\t\t * partition descriptor blocks and process them.\n\t\t */\n\t\tfor (block = vds[VDS_POS_PARTITION_DESC].block;\n\t\t     block < vds[VDS_POS_TERMINATING_DESC].block;\n\t\t     block++) {\n\t\t\tret = udf_load_partdesc(sb, block);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "udf_load_logicalvolint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "1556-1581",
    "snippet": "static void udf_load_logicalvolint(struct super_block *sb, struct kernel_extent_ad loc)\n{\n\tstruct buffer_head *bh = NULL;\n\tuint16_t ident;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\n\twhile (loc.extLength > 0 &&\n\t       (bh = udf_read_tagged(sb, loc.extLocation,\n\t\t\t\t     loc.extLocation, &ident)) &&\n\t       ident == TAG_IDENT_LVID) {\n\t\tsbi->s_lvid_bh = bh;\n\t\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\n\t\tif (lvid->nextIntegrityExt.extLength)\n\t\t\tudf_load_logicalvolint(sb,\n\t\t\t\tleea_to_cpu(lvid->nextIntegrityExt));\n\n\t\tif (sbi->s_lvid_bh != bh)\n\t\t\tbrelse(bh);\n\t\tloc.extLength -= sb->s_blocksize;\n\t\tloc.extLocation++;\n\t}\n\tif (sbi->s_lvid_bh != bh)\n\t\tbrelse(bh);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static void udf_load_logicalvolint(struct super_block *, struct kernel_extent_ad);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_load_logicalvolint",
          "args": [
            "sb",
            "leea_to_cpu(lvid->nextIntegrityExt)"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "udf_load_logicalvolint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "1556-1581",
          "snippet": "static void udf_load_logicalvolint(struct super_block *sb, struct kernel_extent_ad loc)\n{\n\tstruct buffer_head *bh = NULL;\n\tuint16_t ident;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\n\twhile (loc.extLength > 0 &&\n\t       (bh = udf_read_tagged(sb, loc.extLocation,\n\t\t\t\t     loc.extLocation, &ident)) &&\n\t       ident == TAG_IDENT_LVID) {\n\t\tsbi->s_lvid_bh = bh;\n\t\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\n\t\tif (lvid->nextIntegrityExt.extLength)\n\t\t\tudf_load_logicalvolint(sb,\n\t\t\t\tleea_to_cpu(lvid->nextIntegrityExt));\n\n\t\tif (sbi->s_lvid_bh != bh)\n\t\t\tbrelse(bh);\n\t\tloc.extLength -= sb->s_blocksize;\n\t\tloc.extLocation++;\n\t}\n\tif (sbi->s_lvid_bh != bh)\n\t\tbrelse(bh);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "leea_to_cpu",
          "args": [
            "lvid->nextIntegrityExt"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "leea_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfend.h",
          "lines": "67-75",
          "snippet": "static inline struct kernel_extent_ad leea_to_cpu(struct extent_ad in)\n{\n\tstruct kernel_extent_ad out;\n\n\tout.extLength = le32_to_cpu(in.extLength);\n\tout.extLocation = le32_to_cpu(in.extLocation);\n\n\treturn out;\n}",
          "includes": [
            "#include <linux/string.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/string.h>\n#include <asm/byteorder.h>\n\nstatic inline struct kernel_extent_ad leea_to_cpu(struct extent_ad in)\n{\n\tstruct kernel_extent_ad out;\n\n\tout.extLength = le32_to_cpu(in.extLength);\n\tout.extLocation = le32_to_cpu(in.extLocation);\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_read_tagged",
          "args": [
            "sb",
            "loc.extLocation",
            "loc.extLocation",
            "&ident"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "udf_read_tagged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "202-259",
          "snippet": "struct buffer_head *udf_read_tagged(struct super_block *sb, uint32_t block,\n\t\t\t\t    uint32_t location, uint16_t *ident)\n{\n\tstruct tag *tag_p;\n\tstruct buffer_head *bh = NULL;\n\tu8 checksum;\n\n\t/* Read the block */\n\tif (block == 0xFFFFFFFF)\n\t\treturn NULL;\n\n\tbh = udf_tread(sb, block);\n\tif (!bh) {\n\t\tudf_err(sb, \"read failed, block=%u, location=%d\\n\",\n\t\t\tblock, location);\n\t\treturn NULL;\n\t}\n\n\ttag_p = (struct tag *)(bh->b_data);\n\n\t*ident = le16_to_cpu(tag_p->tagIdent);\n\n\tif (location != le32_to_cpu(tag_p->tagLocation)) {\n\t\tudf_debug(\"location mismatch block %u, tag %u != %u\\n\",\n\t\t\t  block, le32_to_cpu(tag_p->tagLocation), location);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag checksum */\n\tchecksum = udf_tag_checksum(tag_p);\n\tif (checksum != tag_p->tagChecksum) {\n\t\tudf_err(sb, \"tag checksum failed, block %u: 0x%02x != 0x%02x\\n\",\n\t\t\tblock, checksum, tag_p->tagChecksum);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag version */\n\tif (tag_p->descVersion != cpu_to_le16(0x0002U) &&\n\t    tag_p->descVersion != cpu_to_le16(0x0003U)) {\n\t\tudf_err(sb, \"tag version 0x%04x != 0x0002 || 0x0003, block %u\\n\",\n\t\t\tle16_to_cpu(tag_p->descVersion), block);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the descriptor CRC */\n\tif (le16_to_cpu(tag_p->descCRCLength) + sizeof(struct tag) > sb->s_blocksize ||\n\t    le16_to_cpu(tag_p->descCRC) == crc_itu_t(0,\n\t\t\t\t\tbh->b_data + sizeof(struct tag),\n\t\t\t\t\tle16_to_cpu(tag_p->descCRCLength)))\n\t\treturn bh;\n\n\tudf_debug(\"Crc failure block %d: crc = %d, crclen = %d\\n\", block,\n\t\t  le16_to_cpu(tag_p->descCRC),\n\t\t  le16_to_cpu(tag_p->descCRCLength));\nerror_out:\n\tbrelse(bh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_read_tagged(struct super_block *sb, uint32_t block,\n\t\t\t\t    uint32_t location, uint16_t *ident)\n{\n\tstruct tag *tag_p;\n\tstruct buffer_head *bh = NULL;\n\tu8 checksum;\n\n\t/* Read the block */\n\tif (block == 0xFFFFFFFF)\n\t\treturn NULL;\n\n\tbh = udf_tread(sb, block);\n\tif (!bh) {\n\t\tudf_err(sb, \"read failed, block=%u, location=%d\\n\",\n\t\t\tblock, location);\n\t\treturn NULL;\n\t}\n\n\ttag_p = (struct tag *)(bh->b_data);\n\n\t*ident = le16_to_cpu(tag_p->tagIdent);\n\n\tif (location != le32_to_cpu(tag_p->tagLocation)) {\n\t\tudf_debug(\"location mismatch block %u, tag %u != %u\\n\",\n\t\t\t  block, le32_to_cpu(tag_p->tagLocation), location);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag checksum */\n\tchecksum = udf_tag_checksum(tag_p);\n\tif (checksum != tag_p->tagChecksum) {\n\t\tudf_err(sb, \"tag checksum failed, block %u: 0x%02x != 0x%02x\\n\",\n\t\t\tblock, checksum, tag_p->tagChecksum);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag version */\n\tif (tag_p->descVersion != cpu_to_le16(0x0002U) &&\n\t    tag_p->descVersion != cpu_to_le16(0x0003U)) {\n\t\tudf_err(sb, \"tag version 0x%04x != 0x0002 || 0x0003, block %u\\n\",\n\t\t\tle16_to_cpu(tag_p->descVersion), block);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the descriptor CRC */\n\tif (le16_to_cpu(tag_p->descCRCLength) + sizeof(struct tag) > sb->s_blocksize ||\n\t    le16_to_cpu(tag_p->descCRC) == crc_itu_t(0,\n\t\t\t\t\tbh->b_data + sizeof(struct tag),\n\t\t\t\t\tle16_to_cpu(tag_p->descCRCLength)))\n\t\treturn bh;\n\n\tudf_debug(\"Crc failure block %d: crc = %d, crclen = %d\\n\", block,\n\t\t  le16_to_cpu(tag_p->descCRC),\n\t\t  le16_to_cpu(tag_p->descCRCLength));\nerror_out:\n\tbrelse(bh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_load_logicalvolint(struct super_block *, struct kernel_extent_ad);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic void udf_load_logicalvolint(struct super_block *sb, struct kernel_extent_ad loc)\n{\n\tstruct buffer_head *bh = NULL;\n\tuint16_t ident;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\n\twhile (loc.extLength > 0 &&\n\t       (bh = udf_read_tagged(sb, loc.extLocation,\n\t\t\t\t     loc.extLocation, &ident)) &&\n\t       ident == TAG_IDENT_LVID) {\n\t\tsbi->s_lvid_bh = bh;\n\t\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\n\t\tif (lvid->nextIntegrityExt.extLength)\n\t\t\tudf_load_logicalvolint(sb,\n\t\t\t\tleea_to_cpu(lvid->nextIntegrityExt));\n\n\t\tif (sbi->s_lvid_bh != bh)\n\t\t\tbrelse(bh);\n\t\tloc.extLength -= sb->s_blocksize;\n\t\tloc.extLocation++;\n\t}\n\tif (sbi->s_lvid_bh != bh)\n\t\tbrelse(bh);\n}"
  },
  {
    "function_name": "udf_load_logicalvol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "1411-1550",
    "snippet": "static int udf_load_logicalvol(struct super_block *sb, sector_t block,\n\t\t\t       struct kernel_lb_addr *fileset)\n{\n\tstruct logicalVolDesc *lvd;\n\tint i, offset;\n\tuint8_t type;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct genericPartitionMap *gpm;\n\tuint16_t ident;\n\tstruct buffer_head *bh;\n\tunsigned int table_len;\n\tint ret;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh)\n\t\treturn -EAGAIN;\n\tBUG_ON(ident != TAG_IDENT_LVD);\n\tlvd = (struct logicalVolDesc *)bh->b_data;\n\ttable_len = le32_to_cpu(lvd->mapTableLength);\n\tif (table_len > sb->s_blocksize - sizeof(*lvd)) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Partition table too long (%u > %lu)\\n\", table_len,\n\t\t\tsb->s_blocksize - sizeof(*lvd));\n\t\tret = -EIO;\n\t\tgoto out_bh;\n\t}\n\n\tret = udf_sb_alloc_partition_maps(sb, le32_to_cpu(lvd->numPartitionMaps));\n\tif (ret)\n\t\tgoto out_bh;\n\n\tfor (i = 0, offset = 0;\n\t     i < sbi->s_partitions && offset < table_len;\n\t     i++, offset += gpm->partitionMapLength) {\n\t\tstruct udf_part_map *map = &sbi->s_partmaps[i];\n\t\tgpm = (struct genericPartitionMap *)\n\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\ttype = gpm->partitionMapType;\n\t\tif (type == 1) {\n\t\t\tstruct genericPartitionMap1 *gpm1 =\n\t\t\t\t(struct genericPartitionMap1 *)gpm;\n\t\t\tmap->s_partition_type = UDF_TYPE1_MAP15;\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(gpm1->volSeqNum);\n\t\t\tmap->s_partition_num = le16_to_cpu(gpm1->partitionNum);\n\t\t\tmap->s_partition_func = NULL;\n\t\t} else if (type == 2) {\n\t\t\tstruct udfPartitionMap2 *upm2 =\n\t\t\t\t\t\t(struct udfPartitionMap2 *)gpm;\n\t\t\tif (!strncmp(upm2->partIdent.ident, UDF_ID_VIRTUAL,\n\t\t\t\t\t\tstrlen(UDF_ID_VIRTUAL))) {\n\t\t\t\tu16 suf =\n\t\t\t\t\tle16_to_cpu(((__le16 *)upm2->partIdent.\n\t\t\t\t\t\t\tidentSuffix)[0]);\n\t\t\t\tif (suf < 0x0200) {\n\t\t\t\t\tmap->s_partition_type =\n\t\t\t\t\t\t\tUDF_VIRTUAL_MAP15;\n\t\t\t\t\tmap->s_partition_func =\n\t\t\t\t\t\t\tudf_get_pblock_virt15;\n\t\t\t\t} else {\n\t\t\t\t\tmap->s_partition_type =\n\t\t\t\t\t\t\tUDF_VIRTUAL_MAP20;\n\t\t\t\t\tmap->s_partition_func =\n\t\t\t\t\t\t\tudf_get_pblock_virt20;\n\t\t\t\t}\n\t\t\t} else if (!strncmp(upm2->partIdent.ident,\n\t\t\t\t\t\tUDF_ID_SPARABLE,\n\t\t\t\t\t\tstrlen(UDF_ID_SPARABLE))) {\n\t\t\t\tret = udf_load_sparable_map(sb, map,\n\t\t\t\t\t(struct sparablePartitionMap *)gpm);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out_bh;\n\t\t\t} else if (!strncmp(upm2->partIdent.ident,\n\t\t\t\t\t\tUDF_ID_METADATA,\n\t\t\t\t\t\tstrlen(UDF_ID_METADATA))) {\n\t\t\t\tstruct udf_meta_data *mdata =\n\t\t\t\t\t&map->s_type_specific.s_metadata;\n\t\t\t\tstruct metadataPartitionMap *mdm =\n\t\t\t\t\t\t(struct metadataPartitionMap *)\n\t\t\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\t\t\tudf_debug(\"Parsing Logical vol part %d type %d  id=%s\\n\",\n\t\t\t\t\t  i, type, UDF_ID_METADATA);\n\n\t\t\t\tmap->s_partition_type = UDF_METADATA_MAP25;\n\t\t\t\tmap->s_partition_func = udf_get_pblock_meta25;\n\n\t\t\t\tmdata->s_meta_file_loc   =\n\t\t\t\t\tle32_to_cpu(mdm->metadataFileLoc);\n\t\t\t\tmdata->s_mirror_file_loc =\n\t\t\t\t\tle32_to_cpu(mdm->metadataMirrorFileLoc);\n\t\t\t\tmdata->s_bitmap_file_loc =\n\t\t\t\t\tle32_to_cpu(mdm->metadataBitmapFileLoc);\n\t\t\t\tmdata->s_alloc_unit_size =\n\t\t\t\t\tle32_to_cpu(mdm->allocUnitSize);\n\t\t\t\tmdata->s_align_unit_size =\n\t\t\t\t\tle16_to_cpu(mdm->alignUnitSize);\n\t\t\t\tif (mdm->flags & 0x01)\n\t\t\t\t\tmdata->s_flags |= MF_DUPLICATE_MD;\n\n\t\t\t\tudf_debug(\"Metadata Ident suffix=0x%x\\n\",\n\t\t\t\t\t  le16_to_cpu(*(__le16 *)\n\t\t\t\t\t\t      mdm->partIdent.identSuffix));\n\t\t\t\tudf_debug(\"Metadata part num=%d\\n\",\n\t\t\t\t\t  le16_to_cpu(mdm->partitionNum));\n\t\t\t\tudf_debug(\"Metadata part alloc unit size=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->allocUnitSize));\n\t\t\t\tudf_debug(\"Metadata file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataFileLoc));\n\t\t\t\tudf_debug(\"Mirror file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataMirrorFileLoc));\n\t\t\t\tudf_debug(\"Bitmap file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataBitmapFileLoc));\n\t\t\t\tudf_debug(\"Flags: %d %d\\n\",\n\t\t\t\t\t  mdata->s_flags, mdm->flags);\n\t\t\t} else {\n\t\t\t\tudf_debug(\"Unknown ident: %s\\n\",\n\t\t\t\t\t  upm2->partIdent.ident);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(upm2->volSeqNum);\n\t\t\tmap->s_partition_num = le16_to_cpu(upm2->partitionNum);\n\t\t}\n\t\tudf_debug(\"Partition (%d:%d) type %d on volume %d\\n\",\n\t\t\t  i, map->s_partition_num, type, map->s_volumeseqnum);\n\t}\n\n\tif (fileset) {\n\t\tstruct long_ad *la = (struct long_ad *)&(lvd->logicalVolContentsUse[0]);\n\n\t\t*fileset = lelb_to_cpu(la->extLocation);\n\t\tudf_debug(\"FileSet found in LogicalVolDesc at block=%d, partition=%d\\n\",\n\t\t\t  fileset->logicalBlockNum,\n\t\t\t  fileset->partitionReferenceNum);\n\t}\n\tif (lvd->integritySeqExt.extLength)\n\t\tudf_load_logicalvolint(sb, leea_to_cpu(lvd->integritySeqExt));\n\tret = 0;\nout_bh:\n\tbrelse(bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
      "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_load_logicalvolint",
          "args": [
            "sb",
            "leea_to_cpu(lvd->integritySeqExt)"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "udf_load_logicalvolint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "1556-1581",
          "snippet": "static void udf_load_logicalvolint(struct super_block *sb, struct kernel_extent_ad loc)\n{\n\tstruct buffer_head *bh = NULL;\n\tuint16_t ident;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\n\twhile (loc.extLength > 0 &&\n\t       (bh = udf_read_tagged(sb, loc.extLocation,\n\t\t\t\t     loc.extLocation, &ident)) &&\n\t       ident == TAG_IDENT_LVID) {\n\t\tsbi->s_lvid_bh = bh;\n\t\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\n\t\tif (lvid->nextIntegrityExt.extLength)\n\t\t\tudf_load_logicalvolint(sb,\n\t\t\t\tleea_to_cpu(lvid->nextIntegrityExt));\n\n\t\tif (sbi->s_lvid_bh != bh)\n\t\t\tbrelse(bh);\n\t\tloc.extLength -= sb->s_blocksize;\n\t\tloc.extLocation++;\n\t}\n\tif (sbi->s_lvid_bh != bh)\n\t\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_load_logicalvolint(struct super_block *, struct kernel_extent_ad);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_load_logicalvolint(struct super_block *, struct kernel_extent_ad);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic void udf_load_logicalvolint(struct super_block *sb, struct kernel_extent_ad loc)\n{\n\tstruct buffer_head *bh = NULL;\n\tuint16_t ident;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\n\twhile (loc.extLength > 0 &&\n\t       (bh = udf_read_tagged(sb, loc.extLocation,\n\t\t\t\t     loc.extLocation, &ident)) &&\n\t       ident == TAG_IDENT_LVID) {\n\t\tsbi->s_lvid_bh = bh;\n\t\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\n\t\tif (lvid->nextIntegrityExt.extLength)\n\t\t\tudf_load_logicalvolint(sb,\n\t\t\t\tleea_to_cpu(lvid->nextIntegrityExt));\n\n\t\tif (sbi->s_lvid_bh != bh)\n\t\t\tbrelse(bh);\n\t\tloc.extLength -= sb->s_blocksize;\n\t\tloc.extLocation++;\n\t}\n\tif (sbi->s_lvid_bh != bh)\n\t\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "leea_to_cpu",
          "args": [
            "lvd->integritySeqExt"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "leea_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfend.h",
          "lines": "67-75",
          "snippet": "static inline struct kernel_extent_ad leea_to_cpu(struct extent_ad in)\n{\n\tstruct kernel_extent_ad out;\n\n\tout.extLength = le32_to_cpu(in.extLength);\n\tout.extLocation = le32_to_cpu(in.extLocation);\n\n\treturn out;\n}",
          "includes": [
            "#include <linux/string.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/string.h>\n#include <asm/byteorder.h>\n\nstatic inline struct kernel_extent_ad leea_to_cpu(struct extent_ad in)\n{\n\tstruct kernel_extent_ad out;\n\n\tout.extLength = le32_to_cpu(in.extLength);\n\tout.extLocation = le32_to_cpu(in.extLocation);\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"FileSet found in LogicalVolDesc at block=%d, partition=%d\\n\"",
            "fileset->logicalBlockNum",
            "fileset->partitionReferenceNum"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lelb_to_cpu",
          "args": [
            "la->extLocation"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "lelb_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfend.h",
          "lines": "7-15",
          "snippet": "static inline struct kernel_lb_addr lelb_to_cpu(struct lb_addr in)\n{\n\tstruct kernel_lb_addr out;\n\n\tout.logicalBlockNum = le32_to_cpu(in.logicalBlockNum);\n\tout.partitionReferenceNum = le16_to_cpu(in.partitionReferenceNum);\n\n\treturn out;\n}",
          "includes": [
            "#include <linux/string.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/string.h>\n#include <asm/byteorder.h>\n\nstatic inline struct kernel_lb_addr lelb_to_cpu(struct lb_addr in)\n{\n\tstruct kernel_lb_addr out;\n\n\tout.logicalBlockNum = le32_to_cpu(in.logicalBlockNum);\n\tout.partitionReferenceNum = le16_to_cpu(in.partitionReferenceNum);\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Partition (%d:%d) type %d on volume %d\\n\"",
            "i",
            "map->s_partition_num",
            "type",
            "map->s_volumeseqnum"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "upm2->partitionNum"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Unknown ident: %s\\n\"",
            "upm2->partIdent.ident"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Flags: %d %d\\n\"",
            "mdata->s_flags",
            "mdm->flags"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Bitmap file loc=%d\\n\"",
            "le32_to_cpu(mdm->metadataBitmapFileLoc)"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "mdm->metadataBitmapFileLoc"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Mirror file loc=%d\\n\"",
            "le32_to_cpu(mdm->metadataMirrorFileLoc)"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Metadata file loc=%d\\n\"",
            "le32_to_cpu(mdm->metadataFileLoc)"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Metadata part alloc unit size=%d\\n\"",
            "le32_to_cpu(mdm->allocUnitSize)"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Metadata part num=%d\\n\"",
            "le16_to_cpu(mdm->partitionNum)"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Metadata Ident suffix=0x%x\\n\"",
            "le16_to_cpu(*(__le16 *)\n\t\t\t\t\t\t      mdm->partIdent.identSuffix)"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Parsing Logical vol part %d type %d  id=%s\\n\"",
            "i",
            "type",
            "UDF_ID_METADATA"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "upm2->partIdent.ident",
            "UDF_ID_METADATA",
            "strlen(UDF_ID_METADATA)"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "UDF_ID_METADATA"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_load_sparable_map",
          "args": [
            "sb",
            "map",
            "(struct sparablePartitionMap *)gpm"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "udf_load_sparable_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "1363-1409",
          "snippet": "static int udf_load_sparable_map(struct super_block *sb,\n\t\t\t\t struct udf_part_map *map,\n\t\t\t\t struct sparablePartitionMap *spm)\n{\n\tuint32_t loc;\n\tuint16_t ident;\n\tstruct sparingTable *st;\n\tstruct udf_sparing_data *sdata = &map->s_type_specific.s_sparing;\n\tint i;\n\tstruct buffer_head *bh;\n\n\tmap->s_partition_type = UDF_SPARABLE_MAP15;\n\tsdata->s_packet_len = le16_to_cpu(spm->packetLength);\n\tif (!is_power_of_2(sdata->s_packet_len)) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Invalid packet length %u\\n\",\n\t\t\t(unsigned)sdata->s_packet_len);\n\t\treturn -EIO;\n\t}\n\tif (spm->numSparingTables > 4) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Too many sparing tables (%d)\\n\",\n\t\t\t(int)spm->numSparingTables);\n\t\treturn -EIO;\n\t}\n\n\tfor (i = 0; i < spm->numSparingTables; i++) {\n\t\tloc = le32_to_cpu(spm->locSparingTable[i]);\n\t\tbh = udf_read_tagged(sb, loc, loc, &ident);\n\t\tif (!bh)\n\t\t\tcontinue;\n\n\t\tst = (struct sparingTable *)bh->b_data;\n\t\tif (ident != 0 ||\n\t\t    strncmp(st->sparingIdent.ident, UDF_ID_SPARING,\n\t\t\t    strlen(UDF_ID_SPARING)) ||\n\t\t    sizeof(*st) + le16_to_cpu(st->reallocationTableLen) >\n\t\t\t\t\t\t\tsb->s_blocksize) {\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsdata->s_spar_map[i] = bh;\n\t}\n\tmap->s_partition_func = udf_get_pblock_spar15;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_load_sparable_map(struct super_block *sb,\n\t\t\t\t struct udf_part_map *map,\n\t\t\t\t struct sparablePartitionMap *spm)\n{\n\tuint32_t loc;\n\tuint16_t ident;\n\tstruct sparingTable *st;\n\tstruct udf_sparing_data *sdata = &map->s_type_specific.s_sparing;\n\tint i;\n\tstruct buffer_head *bh;\n\n\tmap->s_partition_type = UDF_SPARABLE_MAP15;\n\tsdata->s_packet_len = le16_to_cpu(spm->packetLength);\n\tif (!is_power_of_2(sdata->s_packet_len)) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Invalid packet length %u\\n\",\n\t\t\t(unsigned)sdata->s_packet_len);\n\t\treturn -EIO;\n\t}\n\tif (spm->numSparingTables > 4) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Too many sparing tables (%d)\\n\",\n\t\t\t(int)spm->numSparingTables);\n\t\treturn -EIO;\n\t}\n\n\tfor (i = 0; i < spm->numSparingTables; i++) {\n\t\tloc = le32_to_cpu(spm->locSparingTable[i]);\n\t\tbh = udf_read_tagged(sb, loc, loc, &ident);\n\t\tif (!bh)\n\t\t\tcontinue;\n\n\t\tst = (struct sparingTable *)bh->b_data;\n\t\tif (ident != 0 ||\n\t\t    strncmp(st->sparingIdent.ident, UDF_ID_SPARING,\n\t\t\t    strlen(UDF_ID_SPARING)) ||\n\t\t    sizeof(*st) + le16_to_cpu(st->reallocationTableLen) >\n\t\t\t\t\t\t\tsb->s_blocksize) {\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsdata->s_spar_map[i] = bh;\n\t}\n\tmap->s_partition_func = udf_get_pblock_spar15;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "upm2->partIdent.ident",
            "UDF_ID_SPARABLE",
            "strlen(UDF_ID_SPARABLE)"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "upm2->partIdent.ident",
            "UDF_ID_VIRTUAL",
            "strlen(UDF_ID_VIRTUAL)"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_sb_alloc_partition_maps",
          "args": [
            "sb",
            "le32_to_cpu(lvd->numPartitionMaps)"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_err",
          "args": [
            "sb",
            "\"error loading logical volume descriptor: \"\n\t\t\t\"Partition table too long (%u > %lu)\\n\"",
            "table_len",
            "sb->s_blocksize - sizeof(*lvd)"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "_udf_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "2256-2270",
          "snippet": "void _udf_err(struct super_block *sb, const char *function,\n\t      const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nvoid _udf_err(struct super_block *sb, const char *function,\n\t      const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ident != TAG_IDENT_LVD"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_read_tagged",
          "args": [
            "sb",
            "block",
            "block",
            "&ident"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "udf_read_tagged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "202-259",
          "snippet": "struct buffer_head *udf_read_tagged(struct super_block *sb, uint32_t block,\n\t\t\t\t    uint32_t location, uint16_t *ident)\n{\n\tstruct tag *tag_p;\n\tstruct buffer_head *bh = NULL;\n\tu8 checksum;\n\n\t/* Read the block */\n\tif (block == 0xFFFFFFFF)\n\t\treturn NULL;\n\n\tbh = udf_tread(sb, block);\n\tif (!bh) {\n\t\tudf_err(sb, \"read failed, block=%u, location=%d\\n\",\n\t\t\tblock, location);\n\t\treturn NULL;\n\t}\n\n\ttag_p = (struct tag *)(bh->b_data);\n\n\t*ident = le16_to_cpu(tag_p->tagIdent);\n\n\tif (location != le32_to_cpu(tag_p->tagLocation)) {\n\t\tudf_debug(\"location mismatch block %u, tag %u != %u\\n\",\n\t\t\t  block, le32_to_cpu(tag_p->tagLocation), location);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag checksum */\n\tchecksum = udf_tag_checksum(tag_p);\n\tif (checksum != tag_p->tagChecksum) {\n\t\tudf_err(sb, \"tag checksum failed, block %u: 0x%02x != 0x%02x\\n\",\n\t\t\tblock, checksum, tag_p->tagChecksum);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag version */\n\tif (tag_p->descVersion != cpu_to_le16(0x0002U) &&\n\t    tag_p->descVersion != cpu_to_le16(0x0003U)) {\n\t\tudf_err(sb, \"tag version 0x%04x != 0x0002 || 0x0003, block %u\\n\",\n\t\t\tle16_to_cpu(tag_p->descVersion), block);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the descriptor CRC */\n\tif (le16_to_cpu(tag_p->descCRCLength) + sizeof(struct tag) > sb->s_blocksize ||\n\t    le16_to_cpu(tag_p->descCRC) == crc_itu_t(0,\n\t\t\t\t\tbh->b_data + sizeof(struct tag),\n\t\t\t\t\tle16_to_cpu(tag_p->descCRCLength)))\n\t\treturn bh;\n\n\tudf_debug(\"Crc failure block %d: crc = %d, crclen = %d\\n\", block,\n\t\t  le16_to_cpu(tag_p->descCRC),\n\t\t  le16_to_cpu(tag_p->descCRCLength));\nerror_out:\n\tbrelse(bh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_read_tagged(struct super_block *sb, uint32_t block,\n\t\t\t\t    uint32_t location, uint16_t *ident)\n{\n\tstruct tag *tag_p;\n\tstruct buffer_head *bh = NULL;\n\tu8 checksum;\n\n\t/* Read the block */\n\tif (block == 0xFFFFFFFF)\n\t\treturn NULL;\n\n\tbh = udf_tread(sb, block);\n\tif (!bh) {\n\t\tudf_err(sb, \"read failed, block=%u, location=%d\\n\",\n\t\t\tblock, location);\n\t\treturn NULL;\n\t}\n\n\ttag_p = (struct tag *)(bh->b_data);\n\n\t*ident = le16_to_cpu(tag_p->tagIdent);\n\n\tif (location != le32_to_cpu(tag_p->tagLocation)) {\n\t\tudf_debug(\"location mismatch block %u, tag %u != %u\\n\",\n\t\t\t  block, le32_to_cpu(tag_p->tagLocation), location);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag checksum */\n\tchecksum = udf_tag_checksum(tag_p);\n\tif (checksum != tag_p->tagChecksum) {\n\t\tudf_err(sb, \"tag checksum failed, block %u: 0x%02x != 0x%02x\\n\",\n\t\t\tblock, checksum, tag_p->tagChecksum);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag version */\n\tif (tag_p->descVersion != cpu_to_le16(0x0002U) &&\n\t    tag_p->descVersion != cpu_to_le16(0x0003U)) {\n\t\tudf_err(sb, \"tag version 0x%04x != 0x0002 || 0x0003, block %u\\n\",\n\t\t\tle16_to_cpu(tag_p->descVersion), block);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the descriptor CRC */\n\tif (le16_to_cpu(tag_p->descCRCLength) + sizeof(struct tag) > sb->s_blocksize ||\n\t    le16_to_cpu(tag_p->descCRC) == crc_itu_t(0,\n\t\t\t\t\tbh->b_data + sizeof(struct tag),\n\t\t\t\t\tle16_to_cpu(tag_p->descCRCLength)))\n\t\treturn bh;\n\n\tudf_debug(\"Crc failure block %d: crc = %d, crclen = %d\\n\", block,\n\t\t  le16_to_cpu(tag_p->descCRC),\n\t\t  le16_to_cpu(tag_p->descCRCLength));\nerror_out:\n\tbrelse(bh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_load_logicalvol(struct super_block *sb, sector_t block,\n\t\t\t       struct kernel_lb_addr *fileset)\n{\n\tstruct logicalVolDesc *lvd;\n\tint i, offset;\n\tuint8_t type;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct genericPartitionMap *gpm;\n\tuint16_t ident;\n\tstruct buffer_head *bh;\n\tunsigned int table_len;\n\tint ret;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh)\n\t\treturn -EAGAIN;\n\tBUG_ON(ident != TAG_IDENT_LVD);\n\tlvd = (struct logicalVolDesc *)bh->b_data;\n\ttable_len = le32_to_cpu(lvd->mapTableLength);\n\tif (table_len > sb->s_blocksize - sizeof(*lvd)) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Partition table too long (%u > %lu)\\n\", table_len,\n\t\t\tsb->s_blocksize - sizeof(*lvd));\n\t\tret = -EIO;\n\t\tgoto out_bh;\n\t}\n\n\tret = udf_sb_alloc_partition_maps(sb, le32_to_cpu(lvd->numPartitionMaps));\n\tif (ret)\n\t\tgoto out_bh;\n\n\tfor (i = 0, offset = 0;\n\t     i < sbi->s_partitions && offset < table_len;\n\t     i++, offset += gpm->partitionMapLength) {\n\t\tstruct udf_part_map *map = &sbi->s_partmaps[i];\n\t\tgpm = (struct genericPartitionMap *)\n\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\ttype = gpm->partitionMapType;\n\t\tif (type == 1) {\n\t\t\tstruct genericPartitionMap1 *gpm1 =\n\t\t\t\t(struct genericPartitionMap1 *)gpm;\n\t\t\tmap->s_partition_type = UDF_TYPE1_MAP15;\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(gpm1->volSeqNum);\n\t\t\tmap->s_partition_num = le16_to_cpu(gpm1->partitionNum);\n\t\t\tmap->s_partition_func = NULL;\n\t\t} else if (type == 2) {\n\t\t\tstruct udfPartitionMap2 *upm2 =\n\t\t\t\t\t\t(struct udfPartitionMap2 *)gpm;\n\t\t\tif (!strncmp(upm2->partIdent.ident, UDF_ID_VIRTUAL,\n\t\t\t\t\t\tstrlen(UDF_ID_VIRTUAL))) {\n\t\t\t\tu16 suf =\n\t\t\t\t\tle16_to_cpu(((__le16 *)upm2->partIdent.\n\t\t\t\t\t\t\tidentSuffix)[0]);\n\t\t\t\tif (suf < 0x0200) {\n\t\t\t\t\tmap->s_partition_type =\n\t\t\t\t\t\t\tUDF_VIRTUAL_MAP15;\n\t\t\t\t\tmap->s_partition_func =\n\t\t\t\t\t\t\tudf_get_pblock_virt15;\n\t\t\t\t} else {\n\t\t\t\t\tmap->s_partition_type =\n\t\t\t\t\t\t\tUDF_VIRTUAL_MAP20;\n\t\t\t\t\tmap->s_partition_func =\n\t\t\t\t\t\t\tudf_get_pblock_virt20;\n\t\t\t\t}\n\t\t\t} else if (!strncmp(upm2->partIdent.ident,\n\t\t\t\t\t\tUDF_ID_SPARABLE,\n\t\t\t\t\t\tstrlen(UDF_ID_SPARABLE))) {\n\t\t\t\tret = udf_load_sparable_map(sb, map,\n\t\t\t\t\t(struct sparablePartitionMap *)gpm);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out_bh;\n\t\t\t} else if (!strncmp(upm2->partIdent.ident,\n\t\t\t\t\t\tUDF_ID_METADATA,\n\t\t\t\t\t\tstrlen(UDF_ID_METADATA))) {\n\t\t\t\tstruct udf_meta_data *mdata =\n\t\t\t\t\t&map->s_type_specific.s_metadata;\n\t\t\t\tstruct metadataPartitionMap *mdm =\n\t\t\t\t\t\t(struct metadataPartitionMap *)\n\t\t\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\t\t\tudf_debug(\"Parsing Logical vol part %d type %d  id=%s\\n\",\n\t\t\t\t\t  i, type, UDF_ID_METADATA);\n\n\t\t\t\tmap->s_partition_type = UDF_METADATA_MAP25;\n\t\t\t\tmap->s_partition_func = udf_get_pblock_meta25;\n\n\t\t\t\tmdata->s_meta_file_loc   =\n\t\t\t\t\tle32_to_cpu(mdm->metadataFileLoc);\n\t\t\t\tmdata->s_mirror_file_loc =\n\t\t\t\t\tle32_to_cpu(mdm->metadataMirrorFileLoc);\n\t\t\t\tmdata->s_bitmap_file_loc =\n\t\t\t\t\tle32_to_cpu(mdm->metadataBitmapFileLoc);\n\t\t\t\tmdata->s_alloc_unit_size =\n\t\t\t\t\tle32_to_cpu(mdm->allocUnitSize);\n\t\t\t\tmdata->s_align_unit_size =\n\t\t\t\t\tle16_to_cpu(mdm->alignUnitSize);\n\t\t\t\tif (mdm->flags & 0x01)\n\t\t\t\t\tmdata->s_flags |= MF_DUPLICATE_MD;\n\n\t\t\t\tudf_debug(\"Metadata Ident suffix=0x%x\\n\",\n\t\t\t\t\t  le16_to_cpu(*(__le16 *)\n\t\t\t\t\t\t      mdm->partIdent.identSuffix));\n\t\t\t\tudf_debug(\"Metadata part num=%d\\n\",\n\t\t\t\t\t  le16_to_cpu(mdm->partitionNum));\n\t\t\t\tudf_debug(\"Metadata part alloc unit size=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->allocUnitSize));\n\t\t\t\tudf_debug(\"Metadata file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataFileLoc));\n\t\t\t\tudf_debug(\"Mirror file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataMirrorFileLoc));\n\t\t\t\tudf_debug(\"Bitmap file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataBitmapFileLoc));\n\t\t\t\tudf_debug(\"Flags: %d %d\\n\",\n\t\t\t\t\t  mdata->s_flags, mdm->flags);\n\t\t\t} else {\n\t\t\t\tudf_debug(\"Unknown ident: %s\\n\",\n\t\t\t\t\t  upm2->partIdent.ident);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(upm2->volSeqNum);\n\t\t\tmap->s_partition_num = le16_to_cpu(upm2->partitionNum);\n\t\t}\n\t\tudf_debug(\"Partition (%d:%d) type %d on volume %d\\n\",\n\t\t\t  i, map->s_partition_num, type, map->s_volumeseqnum);\n\t}\n\n\tif (fileset) {\n\t\tstruct long_ad *la = (struct long_ad *)&(lvd->logicalVolContentsUse[0]);\n\n\t\t*fileset = lelb_to_cpu(la->extLocation);\n\t\tudf_debug(\"FileSet found in LogicalVolDesc at block=%d, partition=%d\\n\",\n\t\t\t  fileset->logicalBlockNum,\n\t\t\t  fileset->partitionReferenceNum);\n\t}\n\tif (lvd->integritySeqExt.extLength)\n\t\tudf_load_logicalvolint(sb, leea_to_cpu(lvd->integritySeqExt));\n\tret = 0;\nout_bh:\n\tbrelse(bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "udf_load_sparable_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "1363-1409",
    "snippet": "static int udf_load_sparable_map(struct super_block *sb,\n\t\t\t\t struct udf_part_map *map,\n\t\t\t\t struct sparablePartitionMap *spm)\n{\n\tuint32_t loc;\n\tuint16_t ident;\n\tstruct sparingTable *st;\n\tstruct udf_sparing_data *sdata = &map->s_type_specific.s_sparing;\n\tint i;\n\tstruct buffer_head *bh;\n\n\tmap->s_partition_type = UDF_SPARABLE_MAP15;\n\tsdata->s_packet_len = le16_to_cpu(spm->packetLength);\n\tif (!is_power_of_2(sdata->s_packet_len)) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Invalid packet length %u\\n\",\n\t\t\t(unsigned)sdata->s_packet_len);\n\t\treturn -EIO;\n\t}\n\tif (spm->numSparingTables > 4) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Too many sparing tables (%d)\\n\",\n\t\t\t(int)spm->numSparingTables);\n\t\treturn -EIO;\n\t}\n\n\tfor (i = 0; i < spm->numSparingTables; i++) {\n\t\tloc = le32_to_cpu(spm->locSparingTable[i]);\n\t\tbh = udf_read_tagged(sb, loc, loc, &ident);\n\t\tif (!bh)\n\t\t\tcontinue;\n\n\t\tst = (struct sparingTable *)bh->b_data;\n\t\tif (ident != 0 ||\n\t\t    strncmp(st->sparingIdent.ident, UDF_ID_SPARING,\n\t\t\t    strlen(UDF_ID_SPARING)) ||\n\t\t    sizeof(*st) + le16_to_cpu(st->reallocationTableLen) >\n\t\t\t\t\t\t\tsb->s_blocksize) {\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsdata->s_spar_map[i] = bh;\n\t}\n\tmap->s_partition_func = udf_get_pblock_spar15;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "st->reallocationTableLen"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "st->sparingIdent.ident",
            "UDF_ID_SPARING",
            "strlen(UDF_ID_SPARING)"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "UDF_ID_SPARING"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_read_tagged",
          "args": [
            "sb",
            "loc",
            "loc",
            "&ident"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "udf_read_tagged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "202-259",
          "snippet": "struct buffer_head *udf_read_tagged(struct super_block *sb, uint32_t block,\n\t\t\t\t    uint32_t location, uint16_t *ident)\n{\n\tstruct tag *tag_p;\n\tstruct buffer_head *bh = NULL;\n\tu8 checksum;\n\n\t/* Read the block */\n\tif (block == 0xFFFFFFFF)\n\t\treturn NULL;\n\n\tbh = udf_tread(sb, block);\n\tif (!bh) {\n\t\tudf_err(sb, \"read failed, block=%u, location=%d\\n\",\n\t\t\tblock, location);\n\t\treturn NULL;\n\t}\n\n\ttag_p = (struct tag *)(bh->b_data);\n\n\t*ident = le16_to_cpu(tag_p->tagIdent);\n\n\tif (location != le32_to_cpu(tag_p->tagLocation)) {\n\t\tudf_debug(\"location mismatch block %u, tag %u != %u\\n\",\n\t\t\t  block, le32_to_cpu(tag_p->tagLocation), location);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag checksum */\n\tchecksum = udf_tag_checksum(tag_p);\n\tif (checksum != tag_p->tagChecksum) {\n\t\tudf_err(sb, \"tag checksum failed, block %u: 0x%02x != 0x%02x\\n\",\n\t\t\tblock, checksum, tag_p->tagChecksum);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag version */\n\tif (tag_p->descVersion != cpu_to_le16(0x0002U) &&\n\t    tag_p->descVersion != cpu_to_le16(0x0003U)) {\n\t\tudf_err(sb, \"tag version 0x%04x != 0x0002 || 0x0003, block %u\\n\",\n\t\t\tle16_to_cpu(tag_p->descVersion), block);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the descriptor CRC */\n\tif (le16_to_cpu(tag_p->descCRCLength) + sizeof(struct tag) > sb->s_blocksize ||\n\t    le16_to_cpu(tag_p->descCRC) == crc_itu_t(0,\n\t\t\t\t\tbh->b_data + sizeof(struct tag),\n\t\t\t\t\tle16_to_cpu(tag_p->descCRCLength)))\n\t\treturn bh;\n\n\tudf_debug(\"Crc failure block %d: crc = %d, crclen = %d\\n\", block,\n\t\t  le16_to_cpu(tag_p->descCRC),\n\t\t  le16_to_cpu(tag_p->descCRCLength));\nerror_out:\n\tbrelse(bh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_read_tagged(struct super_block *sb, uint32_t block,\n\t\t\t\t    uint32_t location, uint16_t *ident)\n{\n\tstruct tag *tag_p;\n\tstruct buffer_head *bh = NULL;\n\tu8 checksum;\n\n\t/* Read the block */\n\tif (block == 0xFFFFFFFF)\n\t\treturn NULL;\n\n\tbh = udf_tread(sb, block);\n\tif (!bh) {\n\t\tudf_err(sb, \"read failed, block=%u, location=%d\\n\",\n\t\t\tblock, location);\n\t\treturn NULL;\n\t}\n\n\ttag_p = (struct tag *)(bh->b_data);\n\n\t*ident = le16_to_cpu(tag_p->tagIdent);\n\n\tif (location != le32_to_cpu(tag_p->tagLocation)) {\n\t\tudf_debug(\"location mismatch block %u, tag %u != %u\\n\",\n\t\t\t  block, le32_to_cpu(tag_p->tagLocation), location);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag checksum */\n\tchecksum = udf_tag_checksum(tag_p);\n\tif (checksum != tag_p->tagChecksum) {\n\t\tudf_err(sb, \"tag checksum failed, block %u: 0x%02x != 0x%02x\\n\",\n\t\t\tblock, checksum, tag_p->tagChecksum);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag version */\n\tif (tag_p->descVersion != cpu_to_le16(0x0002U) &&\n\t    tag_p->descVersion != cpu_to_le16(0x0003U)) {\n\t\tudf_err(sb, \"tag version 0x%04x != 0x0002 || 0x0003, block %u\\n\",\n\t\t\tle16_to_cpu(tag_p->descVersion), block);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the descriptor CRC */\n\tif (le16_to_cpu(tag_p->descCRCLength) + sizeof(struct tag) > sb->s_blocksize ||\n\t    le16_to_cpu(tag_p->descCRC) == crc_itu_t(0,\n\t\t\t\t\tbh->b_data + sizeof(struct tag),\n\t\t\t\t\tle16_to_cpu(tag_p->descCRCLength)))\n\t\treturn bh;\n\n\tudf_debug(\"Crc failure block %d: crc = %d, crclen = %d\\n\", block,\n\t\t  le16_to_cpu(tag_p->descCRC),\n\t\t  le16_to_cpu(tag_p->descCRCLength));\nerror_out:\n\tbrelse(bh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "spm->locSparingTable[i]"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_err",
          "args": [
            "sb",
            "\"error loading logical volume descriptor: \"\n\t\t\t\"Too many sparing tables (%d)\\n\"",
            "(int)spm->numSparingTables"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "_udf_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "2256-2270",
          "snippet": "void _udf_err(struct super_block *sb, const char *function,\n\t      const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nvoid _udf_err(struct super_block *sb, const char *function,\n\t      const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "sdata->s_packet_len"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_load_sparable_map(struct super_block *sb,\n\t\t\t\t struct udf_part_map *map,\n\t\t\t\t struct sparablePartitionMap *spm)\n{\n\tuint32_t loc;\n\tuint16_t ident;\n\tstruct sparingTable *st;\n\tstruct udf_sparing_data *sdata = &map->s_type_specific.s_sparing;\n\tint i;\n\tstruct buffer_head *bh;\n\n\tmap->s_partition_type = UDF_SPARABLE_MAP15;\n\tsdata->s_packet_len = le16_to_cpu(spm->packetLength);\n\tif (!is_power_of_2(sdata->s_packet_len)) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Invalid packet length %u\\n\",\n\t\t\t(unsigned)sdata->s_packet_len);\n\t\treturn -EIO;\n\t}\n\tif (spm->numSparingTables > 4) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Too many sparing tables (%d)\\n\",\n\t\t\t(int)spm->numSparingTables);\n\t\treturn -EIO;\n\t}\n\n\tfor (i = 0; i < spm->numSparingTables; i++) {\n\t\tloc = le32_to_cpu(spm->locSparingTable[i]);\n\t\tbh = udf_read_tagged(sb, loc, loc, &ident);\n\t\tif (!bh)\n\t\t\tcontinue;\n\n\t\tst = (struct sparingTable *)bh->b_data;\n\t\tif (ident != 0 ||\n\t\t    strncmp(st->sparingIdent.ident, UDF_ID_SPARING,\n\t\t\t    strlen(UDF_ID_SPARING)) ||\n\t\t    sizeof(*st) + le16_to_cpu(st->reallocationTableLen) >\n\t\t\t\t\t\t\tsb->s_blocksize) {\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsdata->s_spar_map[i] = bh;\n\t}\n\tmap->s_partition_func = udf_get_pblock_spar15;\n\treturn 0;\n}"
  },
  {
    "function_name": "udf_load_partdesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "1264-1361",
    "snippet": "static int udf_load_partdesc(struct super_block *sb, sector_t block)\n{\n\tstruct buffer_head *bh;\n\tstruct partitionDesc *p;\n\tstruct udf_part_map *map;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint i, type1_idx;\n\tuint16_t partitionNumber;\n\tuint16_t ident;\n\tint ret;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh)\n\t\treturn -EAGAIN;\n\tif (ident != TAG_IDENT_PD) {\n\t\tret = 0;\n\t\tgoto out_bh;\n\t}\n\n\tp = (struct partitionDesc *)bh->b_data;\n\tpartitionNumber = le16_to_cpu(p->partitionNumber);\n\n\t/* First scan for TYPE1, SPARABLE and METADATA partitions */\n\tfor (i = 0; i < sbi->s_partitions; i++) {\n\t\tmap = &sbi->s_partmaps[i];\n\t\tudf_debug(\"Searching map: (%d == %d)\\n\",\n\t\t\t  map->s_partition_num, partitionNumber);\n\t\tif (map->s_partition_num == partitionNumber &&\n\t\t    (map->s_partition_type == UDF_TYPE1_MAP15 ||\n\t\t     map->s_partition_type == UDF_SPARABLE_MAP15))\n\t\t\tbreak;\n\t}\n\n\tif (i >= sbi->s_partitions) {\n\t\tudf_debug(\"Partition (%d) not found in partition map\\n\",\n\t\t\t  partitionNumber);\n\t\tret = 0;\n\t\tgoto out_bh;\n\t}\n\n\tret = udf_fill_partdesc_info(sb, p, i);\n\tif (ret < 0)\n\t\tgoto out_bh;\n\n\t/*\n\t * Now rescan for VIRTUAL or METADATA partitions when SPARABLE and\n\t * PHYSICAL partitions are already set up\n\t */\n\ttype1_idx = i;\n#ifdef UDFFS_DEBUG\n\tmap = NULL; /* supress 'maybe used uninitialized' warning */\n#endif\n\tfor (i = 0; i < sbi->s_partitions; i++) {\n\t\tmap = &sbi->s_partmaps[i];\n\n\t\tif (map->s_partition_num == partitionNumber &&\n\t\t    (map->s_partition_type == UDF_VIRTUAL_MAP15 ||\n\t\t     map->s_partition_type == UDF_VIRTUAL_MAP20 ||\n\t\t     map->s_partition_type == UDF_METADATA_MAP25))\n\t\t\tbreak;\n\t}\n\n\tif (i >= sbi->s_partitions) {\n\t\tret = 0;\n\t\tgoto out_bh;\n\t}\n\n\tret = udf_fill_partdesc_info(sb, p, i);\n\tif (ret < 0)\n\t\tgoto out_bh;\n\n\tif (map->s_partition_type == UDF_METADATA_MAP25) {\n\t\tret = udf_load_metadata_files(sb, i);\n\t\tif (ret < 0) {\n\t\t\tudf_err(sb, \"error loading MetaData partition map %d\\n\",\n\t\t\t\ti);\n\t\t\tgoto out_bh;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * If we have a partition with virtual map, we don't handle\n\t\t * writing to it (we overwrite blocks instead of relocating\n\t\t * them).\n\t\t */\n\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\tret = -EACCES;\n\t\t\tgoto out_bh;\n\t\t}\n\t\tret = udf_load_vat(sb, i, type1_idx);\n\t\tif (ret < 0)\n\t\t\tgoto out_bh;\n\t}\n\tret = 0;\nout_bh:\n\t/* In case loading failed, we handle cleanup in udf_fill_super */\n\tbrelse(bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_load_vat",
          "args": [
            "sb",
            "i",
            "type1_idx"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "udf_load_vat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "1209-1256",
          "snippet": "static int udf_load_vat(struct super_block *sb, int p_index, int type1_index)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map = &sbi->s_partmaps[p_index];\n\tstruct buffer_head *bh = NULL;\n\tstruct udf_inode_info *vati;\n\tuint32_t pos;\n\tstruct virtualAllocationTable20 *vat20;\n\tsector_t blocks = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\n\tudf_find_vat_block(sb, p_index, type1_index, sbi->s_last_block);\n\tif (!sbi->s_vat_inode &&\n\t    sbi->s_last_block != blocks - 1) {\n\t\tpr_notice(\"Failed to read VAT inode from the last recorded block (%lu), retrying with the last block of the device (%lu).\\n\",\n\t\t\t  (unsigned long)sbi->s_last_block,\n\t\t\t  (unsigned long)blocks - 1);\n\t\tudf_find_vat_block(sb, p_index, type1_index, blocks - 1);\n\t}\n\tif (!sbi->s_vat_inode)\n\t\treturn -EIO;\n\n\tif (map->s_partition_type == UDF_VIRTUAL_MAP15) {\n\t\tmap->s_type_specific.s_virtual.s_start_offset = 0;\n\t\tmap->s_type_specific.s_virtual.s_num_entries =\n\t\t\t(sbi->s_vat_inode->i_size - 36) >> 2;\n\t} else if (map->s_partition_type == UDF_VIRTUAL_MAP20) {\n\t\tvati = UDF_I(sbi->s_vat_inode);\n\t\tif (vati->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tpos = udf_block_map(sbi->s_vat_inode, 0);\n\t\t\tbh = sb_bread(sb, pos);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tvat20 = (struct virtualAllocationTable20 *)bh->b_data;\n\t\t} else {\n\t\t\tvat20 = (struct virtualAllocationTable20 *)\n\t\t\t\t\t\t\tvati->i_ext.i_data;\n\t\t}\n\n\t\tmap->s_type_specific.s_virtual.s_start_offset =\n\t\t\tle16_to_cpu(vat20->lengthHeader);\n\t\tmap->s_type_specific.s_virtual.s_num_entries =\n\t\t\t(sbi->s_vat_inode->i_size -\n\t\t\t\tmap->s_type_specific.s_virtual.\n\t\t\t\t\ts_start_offset) >> 2;\n\t\tbrelse(bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_load_vat(struct super_block *sb, int p_index, int type1_index)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map = &sbi->s_partmaps[p_index];\n\tstruct buffer_head *bh = NULL;\n\tstruct udf_inode_info *vati;\n\tuint32_t pos;\n\tstruct virtualAllocationTable20 *vat20;\n\tsector_t blocks = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\n\tudf_find_vat_block(sb, p_index, type1_index, sbi->s_last_block);\n\tif (!sbi->s_vat_inode &&\n\t    sbi->s_last_block != blocks - 1) {\n\t\tpr_notice(\"Failed to read VAT inode from the last recorded block (%lu), retrying with the last block of the device (%lu).\\n\",\n\t\t\t  (unsigned long)sbi->s_last_block,\n\t\t\t  (unsigned long)blocks - 1);\n\t\tudf_find_vat_block(sb, p_index, type1_index, blocks - 1);\n\t}\n\tif (!sbi->s_vat_inode)\n\t\treturn -EIO;\n\n\tif (map->s_partition_type == UDF_VIRTUAL_MAP15) {\n\t\tmap->s_type_specific.s_virtual.s_start_offset = 0;\n\t\tmap->s_type_specific.s_virtual.s_num_entries =\n\t\t\t(sbi->s_vat_inode->i_size - 36) >> 2;\n\t} else if (map->s_partition_type == UDF_VIRTUAL_MAP20) {\n\t\tvati = UDF_I(sbi->s_vat_inode);\n\t\tif (vati->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tpos = udf_block_map(sbi->s_vat_inode, 0);\n\t\t\tbh = sb_bread(sb, pos);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tvat20 = (struct virtualAllocationTable20 *)bh->b_data;\n\t\t} else {\n\t\t\tvat20 = (struct virtualAllocationTable20 *)\n\t\t\t\t\t\t\tvati->i_ext.i_data;\n\t\t}\n\n\t\tmap->s_type_specific.s_virtual.s_start_offset =\n\t\t\tle16_to_cpu(vat20->lengthHeader);\n\t\tmap->s_type_specific.s_virtual.s_num_entries =\n\t\t\t(sbi->s_vat_inode->i_size -\n\t\t\t\tmap->s_type_specific.s_virtual.\n\t\t\t\t\ts_start_offset) >> 2;\n\t\tbrelse(bh);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_err",
          "args": [
            "sb",
            "\"error loading MetaData partition map %d\\n\"",
            "i"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "_udf_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "2256-2270",
          "snippet": "void _udf_err(struct super_block *sb, const char *function,\n\t      const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nvoid _udf_err(struct super_block *sb, const char *function,\n\t      const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_load_metadata_files",
          "args": [
            "sb",
            "i"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "udf_load_metadata_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "977-1037",
          "snippet": "static int udf_load_metadata_files(struct super_block *sb, int partition)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tstruct udf_meta_data *mdata;\n\tstruct kernel_lb_addr addr;\n\tstruct inode *fe;\n\n\tmap = &sbi->s_partmaps[partition];\n\tmdata = &map->s_type_specific.s_metadata;\n\n\t/* metadata address */\n\tudf_debug(\"Metadata file location: block = %d part = %d\\n\",\n\t\t  mdata->s_meta_file_loc, map->s_partition_num);\n\n\tfe = udf_find_metadata_inode_efe(sb, mdata->s_meta_file_loc,\n\t\t\t\t\t map->s_partition_num);\n\tif (IS_ERR(fe)) {\n\t\t/* mirror file entry */\n\t\tudf_debug(\"Mirror metadata file location: block = %d part = %d\\n\",\n\t\t\t  mdata->s_mirror_file_loc, map->s_partition_num);\n\n\t\tfe = udf_find_metadata_inode_efe(sb, mdata->s_mirror_file_loc,\n\t\t\t\t\t\t map->s_partition_num);\n\n\t\tif (IS_ERR(fe)) {\n\t\t\tudf_err(sb, \"Both metadata and mirror metadata inode efe can not found\\n\");\n\t\t\treturn PTR_ERR(fe);\n\t\t}\n\t\tmdata->s_mirror_fe = fe;\n\t} else\n\t\tmdata->s_metadata_fe = fe;\n\n\n\t/*\n\t * bitmap file entry\n\t * Note:\n\t * Load only if bitmap file location differs from 0xFFFFFFFF (DCN-5102)\n\t*/\n\tif (mdata->s_bitmap_file_loc != 0xFFFFFFFF) {\n\t\taddr.logicalBlockNum = mdata->s_bitmap_file_loc;\n\t\taddr.partitionReferenceNum = map->s_partition_num;\n\n\t\tudf_debug(\"Bitmap file location: block = %d part = %d\\n\",\n\t\t\t  addr.logicalBlockNum, addr.partitionReferenceNum);\n\n\t\tfe = udf_iget_special(sb, &addr);\n\t\tif (IS_ERR(fe)) {\n\t\t\tif (sb->s_flags & MS_RDONLY)\n\t\t\t\tudf_warn(sb, \"bitmap inode efe not found but it's ok since the disc is mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tudf_err(sb, \"bitmap inode efe not found and attempted read-write mount\\n\");\n\t\t\t\treturn PTR_ERR(fe);\n\t\t\t}\n\t\t} else\n\t\t\tmdata->s_bitmap_fe = fe;\n\t}\n\n\tudf_debug(\"udf_load_metadata_files Ok\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
            "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_load_metadata_files(struct super_block *sb, int partition)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tstruct udf_meta_data *mdata;\n\tstruct kernel_lb_addr addr;\n\tstruct inode *fe;\n\n\tmap = &sbi->s_partmaps[partition];\n\tmdata = &map->s_type_specific.s_metadata;\n\n\t/* metadata address */\n\tudf_debug(\"Metadata file location: block = %d part = %d\\n\",\n\t\t  mdata->s_meta_file_loc, map->s_partition_num);\n\n\tfe = udf_find_metadata_inode_efe(sb, mdata->s_meta_file_loc,\n\t\t\t\t\t map->s_partition_num);\n\tif (IS_ERR(fe)) {\n\t\t/* mirror file entry */\n\t\tudf_debug(\"Mirror metadata file location: block = %d part = %d\\n\",\n\t\t\t  mdata->s_mirror_file_loc, map->s_partition_num);\n\n\t\tfe = udf_find_metadata_inode_efe(sb, mdata->s_mirror_file_loc,\n\t\t\t\t\t\t map->s_partition_num);\n\n\t\tif (IS_ERR(fe)) {\n\t\t\tudf_err(sb, \"Both metadata and mirror metadata inode efe can not found\\n\");\n\t\t\treturn PTR_ERR(fe);\n\t\t}\n\t\tmdata->s_mirror_fe = fe;\n\t} else\n\t\tmdata->s_metadata_fe = fe;\n\n\n\t/*\n\t * bitmap file entry\n\t * Note:\n\t * Load only if bitmap file location differs from 0xFFFFFFFF (DCN-5102)\n\t*/\n\tif (mdata->s_bitmap_file_loc != 0xFFFFFFFF) {\n\t\taddr.logicalBlockNum = mdata->s_bitmap_file_loc;\n\t\taddr.partitionReferenceNum = map->s_partition_num;\n\n\t\tudf_debug(\"Bitmap file location: block = %d part = %d\\n\",\n\t\t\t  addr.logicalBlockNum, addr.partitionReferenceNum);\n\n\t\tfe = udf_iget_special(sb, &addr);\n\t\tif (IS_ERR(fe)) {\n\t\t\tif (sb->s_flags & MS_RDONLY)\n\t\t\t\tudf_warn(sb, \"bitmap inode efe not found but it's ok since the disc is mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tudf_err(sb, \"bitmap inode efe not found and attempted read-write mount\\n\");\n\t\t\t\treturn PTR_ERR(fe);\n\t\t\t}\n\t\t} else\n\t\t\tmdata->s_bitmap_fe = fe;\n\t}\n\n\tudf_debug(\"udf_load_metadata_files Ok\\n\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_fill_partdesc_info",
          "args": [
            "sb",
            "p",
            "i"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "udf_fill_partdesc_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "1084-1181",
          "snippet": "static int udf_fill_partdesc_info(struct super_block *sb,\n\t\tstruct partitionDesc *p, int p_index)\n{\n\tstruct udf_part_map *map;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct partitionHeaderDesc *phd;\n\n\tmap = &sbi->s_partmaps[p_index];\n\n\tmap->s_partition_len = le32_to_cpu(p->partitionLength); /* blocks */\n\tmap->s_partition_root = le32_to_cpu(p->partitionStartingLocation);\n\n\tif (p->accessType == cpu_to_le32(PD_ACCESS_TYPE_READ_ONLY))\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_READ_ONLY;\n\tif (p->accessType == cpu_to_le32(PD_ACCESS_TYPE_WRITE_ONCE))\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_WRITE_ONCE;\n\tif (p->accessType == cpu_to_le32(PD_ACCESS_TYPE_REWRITABLE))\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_REWRITABLE;\n\tif (p->accessType == cpu_to_le32(PD_ACCESS_TYPE_OVERWRITABLE))\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_OVERWRITABLE;\n\n\tudf_debug(\"Partition (%d type %x) starts at physical %d, block length %d\\n\",\n\t\t  p_index, map->s_partition_type,\n\t\t  map->s_partition_root, map->s_partition_len);\n\n\tif (strcmp(p->partitionContents.ident, PD_PARTITION_CONTENTS_NSR02) &&\n\t    strcmp(p->partitionContents.ident, PD_PARTITION_CONTENTS_NSR03))\n\t\treturn 0;\n\n\tphd = (struct partitionHeaderDesc *)p->partitionContentsUse;\n\tif (phd->unallocSpaceTable.extLength) {\n\t\tstruct kernel_lb_addr loc = {\n\t\t\t.logicalBlockNum = le32_to_cpu(\n\t\t\t\tphd->unallocSpaceTable.extPosition),\n\t\t\t.partitionReferenceNum = p_index,\n\t\t};\n\t\tstruct inode *inode;\n\n\t\tinode = udf_iget_special(sb, &loc);\n\t\tif (IS_ERR(inode)) {\n\t\t\tudf_debug(\"cannot load unallocSpaceTable (part %d)\\n\",\n\t\t\t\t  p_index);\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t\tmap->s_uspace.s_table = inode;\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_UNALLOC_TABLE;\n\t\tudf_debug(\"unallocSpaceTable (part %d) @ %ld\\n\",\n\t\t\t  p_index, map->s_uspace.s_table->i_ino);\n\t}\n\n\tif (phd->unallocSpaceBitmap.extLength) {\n\t\tstruct udf_bitmap *bitmap = udf_sb_alloc_bitmap(sb, p_index);\n\t\tif (!bitmap)\n\t\t\treturn -ENOMEM;\n\t\tmap->s_uspace.s_bitmap = bitmap;\n\t\tbitmap->s_extPosition = le32_to_cpu(\n\t\t\t\tphd->unallocSpaceBitmap.extPosition);\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_UNALLOC_BITMAP;\n\t\tudf_debug(\"unallocSpaceBitmap (part %d) @ %d\\n\",\n\t\t\t  p_index, bitmap->s_extPosition);\n\t}\n\n\tif (phd->partitionIntegrityTable.extLength)\n\t\tudf_debug(\"partitionIntegrityTable (part %d)\\n\", p_index);\n\n\tif (phd->freedSpaceTable.extLength) {\n\t\tstruct kernel_lb_addr loc = {\n\t\t\t.logicalBlockNum = le32_to_cpu(\n\t\t\t\tphd->freedSpaceTable.extPosition),\n\t\t\t.partitionReferenceNum = p_index,\n\t\t};\n\t\tstruct inode *inode;\n\n\t\tinode = udf_iget_special(sb, &loc);\n\t\tif (IS_ERR(inode)) {\n\t\t\tudf_debug(\"cannot load freedSpaceTable (part %d)\\n\",\n\t\t\t\t  p_index);\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t\tmap->s_fspace.s_table = inode;\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_FREED_TABLE;\n\t\tudf_debug(\"freedSpaceTable (part %d) @ %ld\\n\",\n\t\t\t  p_index, map->s_fspace.s_table->i_ino);\n\t}\n\n\tif (phd->freedSpaceBitmap.extLength) {\n\t\tstruct udf_bitmap *bitmap = udf_sb_alloc_bitmap(sb, p_index);\n\t\tif (!bitmap)\n\t\t\treturn -ENOMEM;\n\t\tmap->s_fspace.s_bitmap = bitmap;\n\t\tbitmap->s_extPosition = le32_to_cpu(\n\t\t\t\tphd->freedSpaceBitmap.extPosition);\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_FREED_BITMAP;\n\t\tudf_debug(\"freedSpaceBitmap (part %d) @ %d\\n\",\n\t\t\t  p_index, bitmap->s_extPosition);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
            "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_fill_partdesc_info(struct super_block *sb,\n\t\tstruct partitionDesc *p, int p_index)\n{\n\tstruct udf_part_map *map;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct partitionHeaderDesc *phd;\n\n\tmap = &sbi->s_partmaps[p_index];\n\n\tmap->s_partition_len = le32_to_cpu(p->partitionLength); /* blocks */\n\tmap->s_partition_root = le32_to_cpu(p->partitionStartingLocation);\n\n\tif (p->accessType == cpu_to_le32(PD_ACCESS_TYPE_READ_ONLY))\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_READ_ONLY;\n\tif (p->accessType == cpu_to_le32(PD_ACCESS_TYPE_WRITE_ONCE))\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_WRITE_ONCE;\n\tif (p->accessType == cpu_to_le32(PD_ACCESS_TYPE_REWRITABLE))\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_REWRITABLE;\n\tif (p->accessType == cpu_to_le32(PD_ACCESS_TYPE_OVERWRITABLE))\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_OVERWRITABLE;\n\n\tudf_debug(\"Partition (%d type %x) starts at physical %d, block length %d\\n\",\n\t\t  p_index, map->s_partition_type,\n\t\t  map->s_partition_root, map->s_partition_len);\n\n\tif (strcmp(p->partitionContents.ident, PD_PARTITION_CONTENTS_NSR02) &&\n\t    strcmp(p->partitionContents.ident, PD_PARTITION_CONTENTS_NSR03))\n\t\treturn 0;\n\n\tphd = (struct partitionHeaderDesc *)p->partitionContentsUse;\n\tif (phd->unallocSpaceTable.extLength) {\n\t\tstruct kernel_lb_addr loc = {\n\t\t\t.logicalBlockNum = le32_to_cpu(\n\t\t\t\tphd->unallocSpaceTable.extPosition),\n\t\t\t.partitionReferenceNum = p_index,\n\t\t};\n\t\tstruct inode *inode;\n\n\t\tinode = udf_iget_special(sb, &loc);\n\t\tif (IS_ERR(inode)) {\n\t\t\tudf_debug(\"cannot load unallocSpaceTable (part %d)\\n\",\n\t\t\t\t  p_index);\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t\tmap->s_uspace.s_table = inode;\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_UNALLOC_TABLE;\n\t\tudf_debug(\"unallocSpaceTable (part %d) @ %ld\\n\",\n\t\t\t  p_index, map->s_uspace.s_table->i_ino);\n\t}\n\n\tif (phd->unallocSpaceBitmap.extLength) {\n\t\tstruct udf_bitmap *bitmap = udf_sb_alloc_bitmap(sb, p_index);\n\t\tif (!bitmap)\n\t\t\treturn -ENOMEM;\n\t\tmap->s_uspace.s_bitmap = bitmap;\n\t\tbitmap->s_extPosition = le32_to_cpu(\n\t\t\t\tphd->unallocSpaceBitmap.extPosition);\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_UNALLOC_BITMAP;\n\t\tudf_debug(\"unallocSpaceBitmap (part %d) @ %d\\n\",\n\t\t\t  p_index, bitmap->s_extPosition);\n\t}\n\n\tif (phd->partitionIntegrityTable.extLength)\n\t\tudf_debug(\"partitionIntegrityTable (part %d)\\n\", p_index);\n\n\tif (phd->freedSpaceTable.extLength) {\n\t\tstruct kernel_lb_addr loc = {\n\t\t\t.logicalBlockNum = le32_to_cpu(\n\t\t\t\tphd->freedSpaceTable.extPosition),\n\t\t\t.partitionReferenceNum = p_index,\n\t\t};\n\t\tstruct inode *inode;\n\n\t\tinode = udf_iget_special(sb, &loc);\n\t\tif (IS_ERR(inode)) {\n\t\t\tudf_debug(\"cannot load freedSpaceTable (part %d)\\n\",\n\t\t\t\t  p_index);\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t\tmap->s_fspace.s_table = inode;\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_FREED_TABLE;\n\t\tudf_debug(\"freedSpaceTable (part %d) @ %ld\\n\",\n\t\t\t  p_index, map->s_fspace.s_table->i_ino);\n\t}\n\n\tif (phd->freedSpaceBitmap.extLength) {\n\t\tstruct udf_bitmap *bitmap = udf_sb_alloc_bitmap(sb, p_index);\n\t\tif (!bitmap)\n\t\t\treturn -ENOMEM;\n\t\tmap->s_fspace.s_bitmap = bitmap;\n\t\tbitmap->s_extPosition = le32_to_cpu(\n\t\t\t\tphd->freedSpaceBitmap.extPosition);\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_FREED_BITMAP;\n\t\tudf_debug(\"freedSpaceBitmap (part %d) @ %d\\n\",\n\t\t\t  p_index, bitmap->s_extPosition);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Partition (%d) not found in partition map\\n\"",
            "partitionNumber"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Searching map: (%d == %d)\\n\"",
            "map->s_partition_num",
            "partitionNumber"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "p->partitionNumber"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_read_tagged",
          "args": [
            "sb",
            "block",
            "block",
            "&ident"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "udf_read_tagged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "202-259",
          "snippet": "struct buffer_head *udf_read_tagged(struct super_block *sb, uint32_t block,\n\t\t\t\t    uint32_t location, uint16_t *ident)\n{\n\tstruct tag *tag_p;\n\tstruct buffer_head *bh = NULL;\n\tu8 checksum;\n\n\t/* Read the block */\n\tif (block == 0xFFFFFFFF)\n\t\treturn NULL;\n\n\tbh = udf_tread(sb, block);\n\tif (!bh) {\n\t\tudf_err(sb, \"read failed, block=%u, location=%d\\n\",\n\t\t\tblock, location);\n\t\treturn NULL;\n\t}\n\n\ttag_p = (struct tag *)(bh->b_data);\n\n\t*ident = le16_to_cpu(tag_p->tagIdent);\n\n\tif (location != le32_to_cpu(tag_p->tagLocation)) {\n\t\tudf_debug(\"location mismatch block %u, tag %u != %u\\n\",\n\t\t\t  block, le32_to_cpu(tag_p->tagLocation), location);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag checksum */\n\tchecksum = udf_tag_checksum(tag_p);\n\tif (checksum != tag_p->tagChecksum) {\n\t\tudf_err(sb, \"tag checksum failed, block %u: 0x%02x != 0x%02x\\n\",\n\t\t\tblock, checksum, tag_p->tagChecksum);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag version */\n\tif (tag_p->descVersion != cpu_to_le16(0x0002U) &&\n\t    tag_p->descVersion != cpu_to_le16(0x0003U)) {\n\t\tudf_err(sb, \"tag version 0x%04x != 0x0002 || 0x0003, block %u\\n\",\n\t\t\tle16_to_cpu(tag_p->descVersion), block);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the descriptor CRC */\n\tif (le16_to_cpu(tag_p->descCRCLength) + sizeof(struct tag) > sb->s_blocksize ||\n\t    le16_to_cpu(tag_p->descCRC) == crc_itu_t(0,\n\t\t\t\t\tbh->b_data + sizeof(struct tag),\n\t\t\t\t\tle16_to_cpu(tag_p->descCRCLength)))\n\t\treturn bh;\n\n\tudf_debug(\"Crc failure block %d: crc = %d, crclen = %d\\n\", block,\n\t\t  le16_to_cpu(tag_p->descCRC),\n\t\t  le16_to_cpu(tag_p->descCRCLength));\nerror_out:\n\tbrelse(bh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_read_tagged(struct super_block *sb, uint32_t block,\n\t\t\t\t    uint32_t location, uint16_t *ident)\n{\n\tstruct tag *tag_p;\n\tstruct buffer_head *bh = NULL;\n\tu8 checksum;\n\n\t/* Read the block */\n\tif (block == 0xFFFFFFFF)\n\t\treturn NULL;\n\n\tbh = udf_tread(sb, block);\n\tif (!bh) {\n\t\tudf_err(sb, \"read failed, block=%u, location=%d\\n\",\n\t\t\tblock, location);\n\t\treturn NULL;\n\t}\n\n\ttag_p = (struct tag *)(bh->b_data);\n\n\t*ident = le16_to_cpu(tag_p->tagIdent);\n\n\tif (location != le32_to_cpu(tag_p->tagLocation)) {\n\t\tudf_debug(\"location mismatch block %u, tag %u != %u\\n\",\n\t\t\t  block, le32_to_cpu(tag_p->tagLocation), location);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag checksum */\n\tchecksum = udf_tag_checksum(tag_p);\n\tif (checksum != tag_p->tagChecksum) {\n\t\tudf_err(sb, \"tag checksum failed, block %u: 0x%02x != 0x%02x\\n\",\n\t\t\tblock, checksum, tag_p->tagChecksum);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag version */\n\tif (tag_p->descVersion != cpu_to_le16(0x0002U) &&\n\t    tag_p->descVersion != cpu_to_le16(0x0003U)) {\n\t\tudf_err(sb, \"tag version 0x%04x != 0x0002 || 0x0003, block %u\\n\",\n\t\t\tle16_to_cpu(tag_p->descVersion), block);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the descriptor CRC */\n\tif (le16_to_cpu(tag_p->descCRCLength) + sizeof(struct tag) > sb->s_blocksize ||\n\t    le16_to_cpu(tag_p->descCRC) == crc_itu_t(0,\n\t\t\t\t\tbh->b_data + sizeof(struct tag),\n\t\t\t\t\tle16_to_cpu(tag_p->descCRCLength)))\n\t\treturn bh;\n\n\tudf_debug(\"Crc failure block %d: crc = %d, crclen = %d\\n\", block,\n\t\t  le16_to_cpu(tag_p->descCRC),\n\t\t  le16_to_cpu(tag_p->descCRCLength));\nerror_out:\n\tbrelse(bh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_load_partdesc(struct super_block *sb, sector_t block)\n{\n\tstruct buffer_head *bh;\n\tstruct partitionDesc *p;\n\tstruct udf_part_map *map;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint i, type1_idx;\n\tuint16_t partitionNumber;\n\tuint16_t ident;\n\tint ret;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh)\n\t\treturn -EAGAIN;\n\tif (ident != TAG_IDENT_PD) {\n\t\tret = 0;\n\t\tgoto out_bh;\n\t}\n\n\tp = (struct partitionDesc *)bh->b_data;\n\tpartitionNumber = le16_to_cpu(p->partitionNumber);\n\n\t/* First scan for TYPE1, SPARABLE and METADATA partitions */\n\tfor (i = 0; i < sbi->s_partitions; i++) {\n\t\tmap = &sbi->s_partmaps[i];\n\t\tudf_debug(\"Searching map: (%d == %d)\\n\",\n\t\t\t  map->s_partition_num, partitionNumber);\n\t\tif (map->s_partition_num == partitionNumber &&\n\t\t    (map->s_partition_type == UDF_TYPE1_MAP15 ||\n\t\t     map->s_partition_type == UDF_SPARABLE_MAP15))\n\t\t\tbreak;\n\t}\n\n\tif (i >= sbi->s_partitions) {\n\t\tudf_debug(\"Partition (%d) not found in partition map\\n\",\n\t\t\t  partitionNumber);\n\t\tret = 0;\n\t\tgoto out_bh;\n\t}\n\n\tret = udf_fill_partdesc_info(sb, p, i);\n\tif (ret < 0)\n\t\tgoto out_bh;\n\n\t/*\n\t * Now rescan for VIRTUAL or METADATA partitions when SPARABLE and\n\t * PHYSICAL partitions are already set up\n\t */\n\ttype1_idx = i;\n#ifdef UDFFS_DEBUG\n\tmap = NULL; /* supress 'maybe used uninitialized' warning */\n#endif\n\tfor (i = 0; i < sbi->s_partitions; i++) {\n\t\tmap = &sbi->s_partmaps[i];\n\n\t\tif (map->s_partition_num == partitionNumber &&\n\t\t    (map->s_partition_type == UDF_VIRTUAL_MAP15 ||\n\t\t     map->s_partition_type == UDF_VIRTUAL_MAP20 ||\n\t\t     map->s_partition_type == UDF_METADATA_MAP25))\n\t\t\tbreak;\n\t}\n\n\tif (i >= sbi->s_partitions) {\n\t\tret = 0;\n\t\tgoto out_bh;\n\t}\n\n\tret = udf_fill_partdesc_info(sb, p, i);\n\tif (ret < 0)\n\t\tgoto out_bh;\n\n\tif (map->s_partition_type == UDF_METADATA_MAP25) {\n\t\tret = udf_load_metadata_files(sb, i);\n\t\tif (ret < 0) {\n\t\t\tudf_err(sb, \"error loading MetaData partition map %d\\n\",\n\t\t\t\ti);\n\t\t\tgoto out_bh;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * If we have a partition with virtual map, we don't handle\n\t\t * writing to it (we overwrite blocks instead of relocating\n\t\t * them).\n\t\t */\n\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\tret = -EACCES;\n\t\t\tgoto out_bh;\n\t\t}\n\t\tret = udf_load_vat(sb, i, type1_idx);\n\t\tif (ret < 0)\n\t\t\tgoto out_bh;\n\t}\n\tret = 0;\nout_bh:\n\t/* In case loading failed, we handle cleanup in udf_fill_super */\n\tbrelse(bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "udf_load_vat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "1209-1256",
    "snippet": "static int udf_load_vat(struct super_block *sb, int p_index, int type1_index)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map = &sbi->s_partmaps[p_index];\n\tstruct buffer_head *bh = NULL;\n\tstruct udf_inode_info *vati;\n\tuint32_t pos;\n\tstruct virtualAllocationTable20 *vat20;\n\tsector_t blocks = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\n\tudf_find_vat_block(sb, p_index, type1_index, sbi->s_last_block);\n\tif (!sbi->s_vat_inode &&\n\t    sbi->s_last_block != blocks - 1) {\n\t\tpr_notice(\"Failed to read VAT inode from the last recorded block (%lu), retrying with the last block of the device (%lu).\\n\",\n\t\t\t  (unsigned long)sbi->s_last_block,\n\t\t\t  (unsigned long)blocks - 1);\n\t\tudf_find_vat_block(sb, p_index, type1_index, blocks - 1);\n\t}\n\tif (!sbi->s_vat_inode)\n\t\treturn -EIO;\n\n\tif (map->s_partition_type == UDF_VIRTUAL_MAP15) {\n\t\tmap->s_type_specific.s_virtual.s_start_offset = 0;\n\t\tmap->s_type_specific.s_virtual.s_num_entries =\n\t\t\t(sbi->s_vat_inode->i_size - 36) >> 2;\n\t} else if (map->s_partition_type == UDF_VIRTUAL_MAP20) {\n\t\tvati = UDF_I(sbi->s_vat_inode);\n\t\tif (vati->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tpos = udf_block_map(sbi->s_vat_inode, 0);\n\t\t\tbh = sb_bread(sb, pos);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tvat20 = (struct virtualAllocationTable20 *)bh->b_data;\n\t\t} else {\n\t\t\tvat20 = (struct virtualAllocationTable20 *)\n\t\t\t\t\t\t\tvati->i_ext.i_data;\n\t\t}\n\n\t\tmap->s_type_specific.s_virtual.s_start_offset =\n\t\t\tle16_to_cpu(vat20->lengthHeader);\n\t\tmap->s_type_specific.s_virtual.s_num_entries =\n\t\t\t(sbi->s_vat_inode->i_size -\n\t\t\t\tmap->s_type_specific.s_virtual.\n\t\t\t\t\ts_start_offset) >> 2;\n\t\tbrelse(bh);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "vat20->lengthHeader"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "pos"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_block_map",
          "args": [
            "sbi->s_vat_inode",
            "0"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "udf_block_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2270-2293",
          "snippet": "long udf_block_map(struct inode *inode, sector_t block)\n{\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tint ret;\n\n\tdown_read(&UDF_I(inode)->i_data_sem);\n\n\tif (inode_bmap(inode, block, &epos, &eloc, &elen, &offset) ==\n\t\t\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\tret = udf_get_lb_pblock(inode->i_sb, &eloc, offset);\n\telse\n\t\tret = 0;\n\n\tup_read(&UDF_I(inode)->i_data_sem);\n\tbrelse(epos.bh);\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_VARCONV))\n\t\treturn udf_fixed_to_variable(ret);\n\telse\n\t\treturn ret;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static sector_t inode_getblk(struct inode *, sector_t, int *, int *);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic sector_t inode_getblk(struct inode *, sector_t, int *, int *);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nlong udf_block_map(struct inode *inode, sector_t block)\n{\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tint ret;\n\n\tdown_read(&UDF_I(inode)->i_data_sem);\n\n\tif (inode_bmap(inode, block, &epos, &eloc, &elen, &offset) ==\n\t\t\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\tret = udf_get_lb_pblock(inode->i_sb, &eloc, offset);\n\telse\n\t\tret = 0;\n\n\tup_read(&UDF_I(inode)->i_data_sem);\n\tbrelse(epos.bh);\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_VARCONV))\n\t\treturn udf_fixed_to_variable(ret);\n\telse\n\t\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "sbi->s_vat_inode"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_find_vat_block",
          "args": [
            "sb",
            "p_index",
            "type1_index",
            "blocks - 1"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "udf_find_vat_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "1183-1207",
          "snippet": "static void udf_find_vat_block(struct super_block *sb, int p_index,\n\t\t\t       int type1_index, sector_t start_block)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map = &sbi->s_partmaps[p_index];\n\tsector_t vat_block;\n\tstruct kernel_lb_addr ino;\n\tstruct inode *inode;\n\n\t/*\n\t * VAT file entry is in the last recorded block. Some broken disks have\n\t * it a few blocks before so try a bit harder...\n\t */\n\tino.partitionReferenceNum = type1_index;\n\tfor (vat_block = start_block;\n\t     vat_block >= map->s_partition_root &&\n\t     vat_block >= start_block - 3; vat_block--) {\n\t\tino.logicalBlockNum = vat_block - map->s_partition_root;\n\t\tinode = udf_iget_special(sb, &ino);\n\t\tif (!IS_ERR(inode)) {\n\t\t\tsbi->s_vat_inode = inode;\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
            "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic void udf_find_vat_block(struct super_block *sb, int p_index,\n\t\t\t       int type1_index, sector_t start_block)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map = &sbi->s_partmaps[p_index];\n\tsector_t vat_block;\n\tstruct kernel_lb_addr ino;\n\tstruct inode *inode;\n\n\t/*\n\t * VAT file entry is in the last recorded block. Some broken disks have\n\t * it a few blocks before so try a bit harder...\n\t */\n\tino.partitionReferenceNum = type1_index;\n\tfor (vat_block = start_block;\n\t     vat_block >= map->s_partition_root &&\n\t     vat_block >= start_block - 3; vat_block--) {\n\t\tino.logicalBlockNum = vat_block - map->s_partition_root;\n\t\tinode = udf_iget_special(sb, &ino);\n\t\tif (!IS_ERR(inode)) {\n\t\t\tsbi->s_vat_inode = inode;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"Failed to read VAT inode from the last recorded block (%lu), retrying with the last block of the device (%lu).\\n\"",
            "(unsigned long)sbi->s_last_block",
            "(unsigned long)blocks - 1"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_load_vat(struct super_block *sb, int p_index, int type1_index)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map = &sbi->s_partmaps[p_index];\n\tstruct buffer_head *bh = NULL;\n\tstruct udf_inode_info *vati;\n\tuint32_t pos;\n\tstruct virtualAllocationTable20 *vat20;\n\tsector_t blocks = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\n\tudf_find_vat_block(sb, p_index, type1_index, sbi->s_last_block);\n\tif (!sbi->s_vat_inode &&\n\t    sbi->s_last_block != blocks - 1) {\n\t\tpr_notice(\"Failed to read VAT inode from the last recorded block (%lu), retrying with the last block of the device (%lu).\\n\",\n\t\t\t  (unsigned long)sbi->s_last_block,\n\t\t\t  (unsigned long)blocks - 1);\n\t\tudf_find_vat_block(sb, p_index, type1_index, blocks - 1);\n\t}\n\tif (!sbi->s_vat_inode)\n\t\treturn -EIO;\n\n\tif (map->s_partition_type == UDF_VIRTUAL_MAP15) {\n\t\tmap->s_type_specific.s_virtual.s_start_offset = 0;\n\t\tmap->s_type_specific.s_virtual.s_num_entries =\n\t\t\t(sbi->s_vat_inode->i_size - 36) >> 2;\n\t} else if (map->s_partition_type == UDF_VIRTUAL_MAP20) {\n\t\tvati = UDF_I(sbi->s_vat_inode);\n\t\tif (vati->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tpos = udf_block_map(sbi->s_vat_inode, 0);\n\t\t\tbh = sb_bread(sb, pos);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tvat20 = (struct virtualAllocationTable20 *)bh->b_data;\n\t\t} else {\n\t\t\tvat20 = (struct virtualAllocationTable20 *)\n\t\t\t\t\t\t\tvati->i_ext.i_data;\n\t\t}\n\n\t\tmap->s_type_specific.s_virtual.s_start_offset =\n\t\t\tle16_to_cpu(vat20->lengthHeader);\n\t\tmap->s_type_specific.s_virtual.s_num_entries =\n\t\t\t(sbi->s_vat_inode->i_size -\n\t\t\t\tmap->s_type_specific.s_virtual.\n\t\t\t\t\ts_start_offset) >> 2;\n\t\tbrelse(bh);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "udf_find_vat_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "1183-1207",
    "snippet": "static void udf_find_vat_block(struct super_block *sb, int p_index,\n\t\t\t       int type1_index, sector_t start_block)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map = &sbi->s_partmaps[p_index];\n\tsector_t vat_block;\n\tstruct kernel_lb_addr ino;\n\tstruct inode *inode;\n\n\t/*\n\t * VAT file entry is in the last recorded block. Some broken disks have\n\t * it a few blocks before so try a bit harder...\n\t */\n\tino.partitionReferenceNum = type1_index;\n\tfor (vat_block = start_block;\n\t     vat_block >= map->s_partition_root &&\n\t     vat_block >= start_block - 3; vat_block--) {\n\t\tino.logicalBlockNum = vat_block - map->s_partition_root;\n\t\tinode = udf_iget_special(sb, &ino);\n\t\tif (!IS_ERR(inode)) {\n\t\t\tsbi->s_vat_inode = inode;\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
      "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_iget_special",
          "args": [
            "sb",
            "&ino"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "udf_iget_special",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "143-147",
          "snippet": "static inline struct inode *udf_iget_special(struct super_block *sb,\n\t\t\t\t\t     struct kernel_lb_addr *ino)\n{\n\treturn __udf_iget(sb, ino, true);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline struct inode *udf_iget_special(struct super_block *sb,\n\t\t\t\t\t     struct kernel_lb_addr *ino)\n{\n\treturn __udf_iget(sb, ino, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic void udf_find_vat_block(struct super_block *sb, int p_index,\n\t\t\t       int type1_index, sector_t start_block)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map = &sbi->s_partmaps[p_index];\n\tsector_t vat_block;\n\tstruct kernel_lb_addr ino;\n\tstruct inode *inode;\n\n\t/*\n\t * VAT file entry is in the last recorded block. Some broken disks have\n\t * it a few blocks before so try a bit harder...\n\t */\n\tino.partitionReferenceNum = type1_index;\n\tfor (vat_block = start_block;\n\t     vat_block >= map->s_partition_root &&\n\t     vat_block >= start_block - 3; vat_block--) {\n\t\tino.logicalBlockNum = vat_block - map->s_partition_root;\n\t\tinode = udf_iget_special(sb, &ino);\n\t\tif (!IS_ERR(inode)) {\n\t\t\tsbi->s_vat_inode = inode;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "udf_fill_partdesc_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "1084-1181",
    "snippet": "static int udf_fill_partdesc_info(struct super_block *sb,\n\t\tstruct partitionDesc *p, int p_index)\n{\n\tstruct udf_part_map *map;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct partitionHeaderDesc *phd;\n\n\tmap = &sbi->s_partmaps[p_index];\n\n\tmap->s_partition_len = le32_to_cpu(p->partitionLength); /* blocks */\n\tmap->s_partition_root = le32_to_cpu(p->partitionStartingLocation);\n\n\tif (p->accessType == cpu_to_le32(PD_ACCESS_TYPE_READ_ONLY))\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_READ_ONLY;\n\tif (p->accessType == cpu_to_le32(PD_ACCESS_TYPE_WRITE_ONCE))\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_WRITE_ONCE;\n\tif (p->accessType == cpu_to_le32(PD_ACCESS_TYPE_REWRITABLE))\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_REWRITABLE;\n\tif (p->accessType == cpu_to_le32(PD_ACCESS_TYPE_OVERWRITABLE))\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_OVERWRITABLE;\n\n\tudf_debug(\"Partition (%d type %x) starts at physical %d, block length %d\\n\",\n\t\t  p_index, map->s_partition_type,\n\t\t  map->s_partition_root, map->s_partition_len);\n\n\tif (strcmp(p->partitionContents.ident, PD_PARTITION_CONTENTS_NSR02) &&\n\t    strcmp(p->partitionContents.ident, PD_PARTITION_CONTENTS_NSR03))\n\t\treturn 0;\n\n\tphd = (struct partitionHeaderDesc *)p->partitionContentsUse;\n\tif (phd->unallocSpaceTable.extLength) {\n\t\tstruct kernel_lb_addr loc = {\n\t\t\t.logicalBlockNum = le32_to_cpu(\n\t\t\t\tphd->unallocSpaceTable.extPosition),\n\t\t\t.partitionReferenceNum = p_index,\n\t\t};\n\t\tstruct inode *inode;\n\n\t\tinode = udf_iget_special(sb, &loc);\n\t\tif (IS_ERR(inode)) {\n\t\t\tudf_debug(\"cannot load unallocSpaceTable (part %d)\\n\",\n\t\t\t\t  p_index);\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t\tmap->s_uspace.s_table = inode;\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_UNALLOC_TABLE;\n\t\tudf_debug(\"unallocSpaceTable (part %d) @ %ld\\n\",\n\t\t\t  p_index, map->s_uspace.s_table->i_ino);\n\t}\n\n\tif (phd->unallocSpaceBitmap.extLength) {\n\t\tstruct udf_bitmap *bitmap = udf_sb_alloc_bitmap(sb, p_index);\n\t\tif (!bitmap)\n\t\t\treturn -ENOMEM;\n\t\tmap->s_uspace.s_bitmap = bitmap;\n\t\tbitmap->s_extPosition = le32_to_cpu(\n\t\t\t\tphd->unallocSpaceBitmap.extPosition);\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_UNALLOC_BITMAP;\n\t\tudf_debug(\"unallocSpaceBitmap (part %d) @ %d\\n\",\n\t\t\t  p_index, bitmap->s_extPosition);\n\t}\n\n\tif (phd->partitionIntegrityTable.extLength)\n\t\tudf_debug(\"partitionIntegrityTable (part %d)\\n\", p_index);\n\n\tif (phd->freedSpaceTable.extLength) {\n\t\tstruct kernel_lb_addr loc = {\n\t\t\t.logicalBlockNum = le32_to_cpu(\n\t\t\t\tphd->freedSpaceTable.extPosition),\n\t\t\t.partitionReferenceNum = p_index,\n\t\t};\n\t\tstruct inode *inode;\n\n\t\tinode = udf_iget_special(sb, &loc);\n\t\tif (IS_ERR(inode)) {\n\t\t\tudf_debug(\"cannot load freedSpaceTable (part %d)\\n\",\n\t\t\t\t  p_index);\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t\tmap->s_fspace.s_table = inode;\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_FREED_TABLE;\n\t\tudf_debug(\"freedSpaceTable (part %d) @ %ld\\n\",\n\t\t\t  p_index, map->s_fspace.s_table->i_ino);\n\t}\n\n\tif (phd->freedSpaceBitmap.extLength) {\n\t\tstruct udf_bitmap *bitmap = udf_sb_alloc_bitmap(sb, p_index);\n\t\tif (!bitmap)\n\t\t\treturn -ENOMEM;\n\t\tmap->s_fspace.s_bitmap = bitmap;\n\t\tbitmap->s_extPosition = le32_to_cpu(\n\t\t\t\tphd->freedSpaceBitmap.extPosition);\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_FREED_BITMAP;\n\t\tudf_debug(\"freedSpaceBitmap (part %d) @ %d\\n\",\n\t\t\t  p_index, bitmap->s_extPosition);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
      "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"freedSpaceBitmap (part %d) @ %d\\n\"",
            "p_index",
            "bitmap->s_extPosition"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "phd->freedSpaceBitmap.extPosition"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_sb_alloc_bitmap",
          "args": [
            "sb",
            "p_index"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "udf_sb_alloc_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "1062-1082",
          "snippet": "static struct udf_bitmap *udf_sb_alloc_bitmap(struct super_block *sb, u32 index)\n{\n\tstruct udf_bitmap *bitmap;\n\tint nr_groups;\n\tint size;\n\n\tnr_groups = udf_compute_nr_groups(sb, index);\n\tsize = sizeof(struct udf_bitmap) +\n\t\t(sizeof(struct buffer_head *) * nr_groups);\n\n\tif (size <= PAGE_SIZE)\n\t\tbitmap = kzalloc(size, GFP_KERNEL);\n\telse\n\t\tbitmap = vzalloc(size); /* TODO: get rid of vzalloc */\n\n\tif (bitmap == NULL)\n\t\treturn NULL;\n\n\tbitmap->s_nr_groups = nr_groups;\n\treturn bitmap;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic struct udf_bitmap *udf_sb_alloc_bitmap(struct super_block *sb, u32 index)\n{\n\tstruct udf_bitmap *bitmap;\n\tint nr_groups;\n\tint size;\n\n\tnr_groups = udf_compute_nr_groups(sb, index);\n\tsize = sizeof(struct udf_bitmap) +\n\t\t(sizeof(struct buffer_head *) * nr_groups);\n\n\tif (size <= PAGE_SIZE)\n\t\tbitmap = kzalloc(size, GFP_KERNEL);\n\telse\n\t\tbitmap = vzalloc(size); /* TODO: get rid of vzalloc */\n\n\tif (bitmap == NULL)\n\t\treturn NULL;\n\n\tbitmap->s_nr_groups = nr_groups;\n\treturn bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"freedSpaceTable (part %d) @ %ld\\n\"",
            "p_index",
            "map->s_fspace.s_table->i_ino"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"cannot load freedSpaceTable (part %d)\\n\"",
            "p_index"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_iget_special",
          "args": [
            "sb",
            "&loc"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "udf_iget_special",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "143-147",
          "snippet": "static inline struct inode *udf_iget_special(struct super_block *sb,\n\t\t\t\t\t     struct kernel_lb_addr *ino)\n{\n\treturn __udf_iget(sb, ino, true);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline struct inode *udf_iget_special(struct super_block *sb,\n\t\t\t\t\t     struct kernel_lb_addr *ino)\n{\n\treturn __udf_iget(sb, ino, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"partitionIntegrityTable (part %d)\\n\"",
            "p_index"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"unallocSpaceBitmap (part %d) @ %d\\n\"",
            "p_index",
            "bitmap->s_extPosition"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"unallocSpaceTable (part %d) @ %ld\\n\"",
            "p_index",
            "map->s_uspace.s_table->i_ino"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"cannot load unallocSpaceTable (part %d)\\n\"",
            "p_index"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p->partitionContents.ident",
            "PD_PARTITION_CONTENTS_NSR03"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "292-301",
          "snippet": "static int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Partition (%d type %x) starts at physical %d, block length %d\\n\"",
            "p_index",
            "map->s_partition_type",
            "map->s_partition_root",
            "map->s_partition_len"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "PD_ACCESS_TYPE_OVERWRITABLE"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "PD_ACCESS_TYPE_REWRITABLE"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "PD_ACCESS_TYPE_WRITE_ONCE"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "PD_ACCESS_TYPE_READ_ONLY"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_fill_partdesc_info(struct super_block *sb,\n\t\tstruct partitionDesc *p, int p_index)\n{\n\tstruct udf_part_map *map;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct partitionHeaderDesc *phd;\n\n\tmap = &sbi->s_partmaps[p_index];\n\n\tmap->s_partition_len = le32_to_cpu(p->partitionLength); /* blocks */\n\tmap->s_partition_root = le32_to_cpu(p->partitionStartingLocation);\n\n\tif (p->accessType == cpu_to_le32(PD_ACCESS_TYPE_READ_ONLY))\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_READ_ONLY;\n\tif (p->accessType == cpu_to_le32(PD_ACCESS_TYPE_WRITE_ONCE))\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_WRITE_ONCE;\n\tif (p->accessType == cpu_to_le32(PD_ACCESS_TYPE_REWRITABLE))\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_REWRITABLE;\n\tif (p->accessType == cpu_to_le32(PD_ACCESS_TYPE_OVERWRITABLE))\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_OVERWRITABLE;\n\n\tudf_debug(\"Partition (%d type %x) starts at physical %d, block length %d\\n\",\n\t\t  p_index, map->s_partition_type,\n\t\t  map->s_partition_root, map->s_partition_len);\n\n\tif (strcmp(p->partitionContents.ident, PD_PARTITION_CONTENTS_NSR02) &&\n\t    strcmp(p->partitionContents.ident, PD_PARTITION_CONTENTS_NSR03))\n\t\treturn 0;\n\n\tphd = (struct partitionHeaderDesc *)p->partitionContentsUse;\n\tif (phd->unallocSpaceTable.extLength) {\n\t\tstruct kernel_lb_addr loc = {\n\t\t\t.logicalBlockNum = le32_to_cpu(\n\t\t\t\tphd->unallocSpaceTable.extPosition),\n\t\t\t.partitionReferenceNum = p_index,\n\t\t};\n\t\tstruct inode *inode;\n\n\t\tinode = udf_iget_special(sb, &loc);\n\t\tif (IS_ERR(inode)) {\n\t\t\tudf_debug(\"cannot load unallocSpaceTable (part %d)\\n\",\n\t\t\t\t  p_index);\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t\tmap->s_uspace.s_table = inode;\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_UNALLOC_TABLE;\n\t\tudf_debug(\"unallocSpaceTable (part %d) @ %ld\\n\",\n\t\t\t  p_index, map->s_uspace.s_table->i_ino);\n\t}\n\n\tif (phd->unallocSpaceBitmap.extLength) {\n\t\tstruct udf_bitmap *bitmap = udf_sb_alloc_bitmap(sb, p_index);\n\t\tif (!bitmap)\n\t\t\treturn -ENOMEM;\n\t\tmap->s_uspace.s_bitmap = bitmap;\n\t\tbitmap->s_extPosition = le32_to_cpu(\n\t\t\t\tphd->unallocSpaceBitmap.extPosition);\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_UNALLOC_BITMAP;\n\t\tudf_debug(\"unallocSpaceBitmap (part %d) @ %d\\n\",\n\t\t\t  p_index, bitmap->s_extPosition);\n\t}\n\n\tif (phd->partitionIntegrityTable.extLength)\n\t\tudf_debug(\"partitionIntegrityTable (part %d)\\n\", p_index);\n\n\tif (phd->freedSpaceTable.extLength) {\n\t\tstruct kernel_lb_addr loc = {\n\t\t\t.logicalBlockNum = le32_to_cpu(\n\t\t\t\tphd->freedSpaceTable.extPosition),\n\t\t\t.partitionReferenceNum = p_index,\n\t\t};\n\t\tstruct inode *inode;\n\n\t\tinode = udf_iget_special(sb, &loc);\n\t\tif (IS_ERR(inode)) {\n\t\t\tudf_debug(\"cannot load freedSpaceTable (part %d)\\n\",\n\t\t\t\t  p_index);\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t\tmap->s_fspace.s_table = inode;\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_FREED_TABLE;\n\t\tudf_debug(\"freedSpaceTable (part %d) @ %ld\\n\",\n\t\t\t  p_index, map->s_fspace.s_table->i_ino);\n\t}\n\n\tif (phd->freedSpaceBitmap.extLength) {\n\t\tstruct udf_bitmap *bitmap = udf_sb_alloc_bitmap(sb, p_index);\n\t\tif (!bitmap)\n\t\t\treturn -ENOMEM;\n\t\tmap->s_fspace.s_bitmap = bitmap;\n\t\tbitmap->s_extPosition = le32_to_cpu(\n\t\t\t\tphd->freedSpaceBitmap.extPosition);\n\t\tmap->s_partition_flags |= UDF_PART_FLAG_FREED_BITMAP;\n\t\tudf_debug(\"freedSpaceBitmap (part %d) @ %d\\n\",\n\t\t\t  p_index, bitmap->s_extPosition);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "udf_sb_alloc_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "1062-1082",
    "snippet": "static struct udf_bitmap *udf_sb_alloc_bitmap(struct super_block *sb, u32 index)\n{\n\tstruct udf_bitmap *bitmap;\n\tint nr_groups;\n\tint size;\n\n\tnr_groups = udf_compute_nr_groups(sb, index);\n\tsize = sizeof(struct udf_bitmap) +\n\t\t(sizeof(struct buffer_head *) * nr_groups);\n\n\tif (size <= PAGE_SIZE)\n\t\tbitmap = kzalloc(size, GFP_KERNEL);\n\telse\n\t\tbitmap = vzalloc(size); /* TODO: get rid of vzalloc */\n\n\tif (bitmap == NULL)\n\t\treturn NULL;\n\n\tbitmap->s_nr_groups = nr_groups;\n\treturn bitmap;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vzalloc",
          "args": [
            "size"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_compute_nr_groups",
          "args": [
            "sb",
            "index"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "udf_compute_nr_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "1054-1060",
          "snippet": "int udf_compute_nr_groups(struct super_block *sb, u32 partition)\n{\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\treturn DIV_ROUND_UP(map->s_partition_len +\n\t\t\t    (sizeof(struct spaceBitmapDesc) << 3),\n\t\t\t    sb->s_blocksize * 8);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nint udf_compute_nr_groups(struct super_block *sb, u32 partition)\n{\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\treturn DIV_ROUND_UP(map->s_partition_len +\n\t\t\t    (sizeof(struct spaceBitmapDesc) << 3),\n\t\t\t    sb->s_blocksize * 8);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic struct udf_bitmap *udf_sb_alloc_bitmap(struct super_block *sb, u32 index)\n{\n\tstruct udf_bitmap *bitmap;\n\tint nr_groups;\n\tint size;\n\n\tnr_groups = udf_compute_nr_groups(sb, index);\n\tsize = sizeof(struct udf_bitmap) +\n\t\t(sizeof(struct buffer_head *) * nr_groups);\n\n\tif (size <= PAGE_SIZE)\n\t\tbitmap = kzalloc(size, GFP_KERNEL);\n\telse\n\t\tbitmap = vzalloc(size); /* TODO: get rid of vzalloc */\n\n\tif (bitmap == NULL)\n\t\treturn NULL;\n\n\tbitmap->s_nr_groups = nr_groups;\n\treturn bitmap;\n}"
  },
  {
    "function_name": "udf_compute_nr_groups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "1054-1060",
    "snippet": "int udf_compute_nr_groups(struct super_block *sb, u32 partition)\n{\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\treturn DIV_ROUND_UP(map->s_partition_len +\n\t\t\t    (sizeof(struct spaceBitmapDesc) << 3),\n\t\t\t    sb->s_blocksize * 8);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "map->s_partition_len +\n\t\t\t    (sizeof(struct spaceBitmapDesc) << 3)",
            "sb->s_blocksize * 8"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nint udf_compute_nr_groups(struct super_block *sb, u32 partition)\n{\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\treturn DIV_ROUND_UP(map->s_partition_len +\n\t\t\t    (sizeof(struct spaceBitmapDesc) << 3),\n\t\t\t    sb->s_blocksize * 8);\n}"
  },
  {
    "function_name": "udf_load_fileset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "1039-1052",
    "snippet": "static void udf_load_fileset(struct super_block *sb, struct buffer_head *bh,\n\t\t\t     struct kernel_lb_addr *root)\n{\n\tstruct fileSetDesc *fset;\n\n\tfset = (struct fileSetDesc *)bh->b_data;\n\n\t*root = lelb_to_cpu(fset->rootDirectoryICB.extLocation);\n\n\tUDF_SB(sb)->s_serial_number = le16_to_cpu(fset->descTag.tagSerialNum);\n\n\tudf_debug(\"Rootdir at block=%d, partition=%d\\n\",\n\t\t  root->logicalBlockNum, root->partitionReferenceNum);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
      "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Rootdir at block=%d, partition=%d\\n\"",
            "root->logicalBlockNum",
            "root->partitionReferenceNum"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "fset->descTag.tagSerialNum"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lelb_to_cpu",
          "args": [
            "fset->rootDirectoryICB.extLocation"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "lelb_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfend.h",
          "lines": "7-15",
          "snippet": "static inline struct kernel_lb_addr lelb_to_cpu(struct lb_addr in)\n{\n\tstruct kernel_lb_addr out;\n\n\tout.logicalBlockNum = le32_to_cpu(in.logicalBlockNum);\n\tout.partitionReferenceNum = le16_to_cpu(in.partitionReferenceNum);\n\n\treturn out;\n}",
          "includes": [
            "#include <linux/string.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/string.h>\n#include <asm/byteorder.h>\n\nstatic inline struct kernel_lb_addr lelb_to_cpu(struct lb_addr in)\n{\n\tstruct kernel_lb_addr out;\n\n\tout.logicalBlockNum = le32_to_cpu(in.logicalBlockNum);\n\tout.partitionReferenceNum = le16_to_cpu(in.partitionReferenceNum);\n\n\treturn out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic void udf_load_fileset(struct super_block *sb, struct buffer_head *bh,\n\t\t\t     struct kernel_lb_addr *root)\n{\n\tstruct fileSetDesc *fset;\n\n\tfset = (struct fileSetDesc *)bh->b_data;\n\n\t*root = lelb_to_cpu(fset->rootDirectoryICB.extLocation);\n\n\tUDF_SB(sb)->s_serial_number = le16_to_cpu(fset->descTag.tagSerialNum);\n\n\tudf_debug(\"Rootdir at block=%d, partition=%d\\n\",\n\t\t  root->logicalBlockNum, root->partitionReferenceNum);\n}"
  },
  {
    "function_name": "udf_load_metadata_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "977-1037",
    "snippet": "static int udf_load_metadata_files(struct super_block *sb, int partition)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tstruct udf_meta_data *mdata;\n\tstruct kernel_lb_addr addr;\n\tstruct inode *fe;\n\n\tmap = &sbi->s_partmaps[partition];\n\tmdata = &map->s_type_specific.s_metadata;\n\n\t/* metadata address */\n\tudf_debug(\"Metadata file location: block = %d part = %d\\n\",\n\t\t  mdata->s_meta_file_loc, map->s_partition_num);\n\n\tfe = udf_find_metadata_inode_efe(sb, mdata->s_meta_file_loc,\n\t\t\t\t\t map->s_partition_num);\n\tif (IS_ERR(fe)) {\n\t\t/* mirror file entry */\n\t\tudf_debug(\"Mirror metadata file location: block = %d part = %d\\n\",\n\t\t\t  mdata->s_mirror_file_loc, map->s_partition_num);\n\n\t\tfe = udf_find_metadata_inode_efe(sb, mdata->s_mirror_file_loc,\n\t\t\t\t\t\t map->s_partition_num);\n\n\t\tif (IS_ERR(fe)) {\n\t\t\tudf_err(sb, \"Both metadata and mirror metadata inode efe can not found\\n\");\n\t\t\treturn PTR_ERR(fe);\n\t\t}\n\t\tmdata->s_mirror_fe = fe;\n\t} else\n\t\tmdata->s_metadata_fe = fe;\n\n\n\t/*\n\t * bitmap file entry\n\t * Note:\n\t * Load only if bitmap file location differs from 0xFFFFFFFF (DCN-5102)\n\t*/\n\tif (mdata->s_bitmap_file_loc != 0xFFFFFFFF) {\n\t\taddr.logicalBlockNum = mdata->s_bitmap_file_loc;\n\t\taddr.partitionReferenceNum = map->s_partition_num;\n\n\t\tudf_debug(\"Bitmap file location: block = %d part = %d\\n\",\n\t\t\t  addr.logicalBlockNum, addr.partitionReferenceNum);\n\n\t\tfe = udf_iget_special(sb, &addr);\n\t\tif (IS_ERR(fe)) {\n\t\t\tif (sb->s_flags & MS_RDONLY)\n\t\t\t\tudf_warn(sb, \"bitmap inode efe not found but it's ok since the disc is mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tudf_err(sb, \"bitmap inode efe not found and attempted read-write mount\\n\");\n\t\t\t\treturn PTR_ERR(fe);\n\t\t\t}\n\t\t} else\n\t\t\tmdata->s_bitmap_fe = fe;\n\t}\n\n\tudf_debug(\"udf_load_metadata_files Ok\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
      "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"udf_load_metadata_files Ok\\n\""
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fe"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_err",
          "args": [
            "sb",
            "\"bitmap inode efe not found and attempted read-write mount\\n\""
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_warn",
          "args": [
            "sb",
            "\"bitmap inode efe not found but it's ok since the disc is mounted read-only\\n\""
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fe"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_iget_special",
          "args": [
            "sb",
            "&addr"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "udf_iget_special",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "143-147",
          "snippet": "static inline struct inode *udf_iget_special(struct super_block *sb,\n\t\t\t\t\t     struct kernel_lb_addr *ino)\n{\n\treturn __udf_iget(sb, ino, true);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline struct inode *udf_iget_special(struct super_block *sb,\n\t\t\t\t\t     struct kernel_lb_addr *ino)\n{\n\treturn __udf_iget(sb, ino, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Bitmap file location: block = %d part = %d\\n\"",
            "addr.logicalBlockNum",
            "addr.partitionReferenceNum"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fe"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_err",
          "args": [
            "sb",
            "\"Both metadata and mirror metadata inode efe can not found\\n\""
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fe"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_find_metadata_inode_efe",
          "args": [
            "sb",
            "mdata->s_mirror_file_loc",
            "map->s_partition_num"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "udf_find_metadata_inode_efe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "953-975",
          "snippet": "struct inode *udf_find_metadata_inode_efe(struct super_block *sb,\n\t\t\t\t\tu32 meta_file_loc, u32 partition_num)\n{\n\tstruct kernel_lb_addr addr;\n\tstruct inode *metadata_fe;\n\n\taddr.logicalBlockNum = meta_file_loc;\n\taddr.partitionReferenceNum = partition_num;\n\n\tmetadata_fe = udf_iget_special(sb, &addr);\n\n\tif (IS_ERR(metadata_fe)) {\n\t\tudf_warn(sb, \"metadata inode efe not found\\n\");\n\t\treturn metadata_fe;\n\t}\n\tif (UDF_I(metadata_fe)->i_alloc_type != ICBTAG_FLAG_AD_SHORT) {\n\t\tudf_warn(sb, \"metadata inode efe does not have short allocation descriptors!\\n\");\n\t\tiput(metadata_fe);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn metadata_fe;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
            "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstruct inode *udf_find_metadata_inode_efe(struct super_block *sb,\n\t\t\t\t\tu32 meta_file_loc, u32 partition_num)\n{\n\tstruct kernel_lb_addr addr;\n\tstruct inode *metadata_fe;\n\n\taddr.logicalBlockNum = meta_file_loc;\n\taddr.partitionReferenceNum = partition_num;\n\n\tmetadata_fe = udf_iget_special(sb, &addr);\n\n\tif (IS_ERR(metadata_fe)) {\n\t\tudf_warn(sb, \"metadata inode efe not found\\n\");\n\t\treturn metadata_fe;\n\t}\n\tif (UDF_I(metadata_fe)->i_alloc_type != ICBTAG_FLAG_AD_SHORT) {\n\t\tudf_warn(sb, \"metadata inode efe does not have short allocation descriptors!\\n\");\n\t\tiput(metadata_fe);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn metadata_fe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Mirror metadata file location: block = %d part = %d\\n\"",
            "mdata->s_mirror_file_loc",
            "map->s_partition_num"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fe"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Metadata file location: block = %d part = %d\\n\"",
            "mdata->s_meta_file_loc",
            "map->s_partition_num"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_load_metadata_files(struct super_block *sb, int partition)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tstruct udf_meta_data *mdata;\n\tstruct kernel_lb_addr addr;\n\tstruct inode *fe;\n\n\tmap = &sbi->s_partmaps[partition];\n\tmdata = &map->s_type_specific.s_metadata;\n\n\t/* metadata address */\n\tudf_debug(\"Metadata file location: block = %d part = %d\\n\",\n\t\t  mdata->s_meta_file_loc, map->s_partition_num);\n\n\tfe = udf_find_metadata_inode_efe(sb, mdata->s_meta_file_loc,\n\t\t\t\t\t map->s_partition_num);\n\tif (IS_ERR(fe)) {\n\t\t/* mirror file entry */\n\t\tudf_debug(\"Mirror metadata file location: block = %d part = %d\\n\",\n\t\t\t  mdata->s_mirror_file_loc, map->s_partition_num);\n\n\t\tfe = udf_find_metadata_inode_efe(sb, mdata->s_mirror_file_loc,\n\t\t\t\t\t\t map->s_partition_num);\n\n\t\tif (IS_ERR(fe)) {\n\t\t\tudf_err(sb, \"Both metadata and mirror metadata inode efe can not found\\n\");\n\t\t\treturn PTR_ERR(fe);\n\t\t}\n\t\tmdata->s_mirror_fe = fe;\n\t} else\n\t\tmdata->s_metadata_fe = fe;\n\n\n\t/*\n\t * bitmap file entry\n\t * Note:\n\t * Load only if bitmap file location differs from 0xFFFFFFFF (DCN-5102)\n\t*/\n\tif (mdata->s_bitmap_file_loc != 0xFFFFFFFF) {\n\t\taddr.logicalBlockNum = mdata->s_bitmap_file_loc;\n\t\taddr.partitionReferenceNum = map->s_partition_num;\n\n\t\tudf_debug(\"Bitmap file location: block = %d part = %d\\n\",\n\t\t\t  addr.logicalBlockNum, addr.partitionReferenceNum);\n\n\t\tfe = udf_iget_special(sb, &addr);\n\t\tif (IS_ERR(fe)) {\n\t\t\tif (sb->s_flags & MS_RDONLY)\n\t\t\t\tudf_warn(sb, \"bitmap inode efe not found but it's ok since the disc is mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tudf_err(sb, \"bitmap inode efe not found and attempted read-write mount\\n\");\n\t\t\t\treturn PTR_ERR(fe);\n\t\t\t}\n\t\t} else\n\t\t\tmdata->s_bitmap_fe = fe;\n\t}\n\n\tudf_debug(\"udf_load_metadata_files Ok\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "udf_find_metadata_inode_efe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "953-975",
    "snippet": "struct inode *udf_find_metadata_inode_efe(struct super_block *sb,\n\t\t\t\t\tu32 meta_file_loc, u32 partition_num)\n{\n\tstruct kernel_lb_addr addr;\n\tstruct inode *metadata_fe;\n\n\taddr.logicalBlockNum = meta_file_loc;\n\taddr.partitionReferenceNum = partition_num;\n\n\tmetadata_fe = udf_iget_special(sb, &addr);\n\n\tif (IS_ERR(metadata_fe)) {\n\t\tudf_warn(sb, \"metadata inode efe not found\\n\");\n\t\treturn metadata_fe;\n\t}\n\tif (UDF_I(metadata_fe)->i_alloc_type != ICBTAG_FLAG_AD_SHORT) {\n\t\tudf_warn(sb, \"metadata inode efe does not have short allocation descriptors!\\n\");\n\t\tiput(metadata_fe);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn metadata_fe;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
      "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "metadata_fe"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_warn",
          "args": [
            "sb",
            "\"metadata inode efe does not have short allocation descriptors!\\n\""
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "metadata_fe"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_warn",
          "args": [
            "sb",
            "\"metadata inode efe not found\\n\""
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "metadata_fe"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_iget_special",
          "args": [
            "sb",
            "&addr"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "udf_iget_special",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "143-147",
          "snippet": "static inline struct inode *udf_iget_special(struct super_block *sb,\n\t\t\t\t\t     struct kernel_lb_addr *ino)\n{\n\treturn __udf_iget(sb, ino, true);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline struct inode *udf_iget_special(struct super_block *sb,\n\t\t\t\t\t     struct kernel_lb_addr *ino)\n{\n\treturn __udf_iget(sb, ino, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstruct inode *udf_find_metadata_inode_efe(struct super_block *sb,\n\t\t\t\t\tu32 meta_file_loc, u32 partition_num)\n{\n\tstruct kernel_lb_addr addr;\n\tstruct inode *metadata_fe;\n\n\taddr.logicalBlockNum = meta_file_loc;\n\taddr.partitionReferenceNum = partition_num;\n\n\tmetadata_fe = udf_iget_special(sb, &addr);\n\n\tif (IS_ERR(metadata_fe)) {\n\t\tudf_warn(sb, \"metadata inode efe not found\\n\");\n\t\treturn metadata_fe;\n\t}\n\tif (UDF_I(metadata_fe)->i_alloc_type != ICBTAG_FLAG_AD_SHORT) {\n\t\tudf_warn(sb, \"metadata inode efe does not have short allocation descriptors!\\n\");\n\t\tiput(metadata_fe);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn metadata_fe;\n}"
  },
  {
    "function_name": "udf_load_pvoldesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "892-951",
    "snippet": "static int udf_load_pvoldesc(struct super_block *sb, sector_t block)\n{\n\tstruct primaryVolDesc *pvoldesc;\n\tstruct ustr *instr, *outstr;\n\tstruct buffer_head *bh;\n\tuint16_t ident;\n\tint ret = -ENOMEM;\n\n\tinstr = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!instr)\n\t\treturn -ENOMEM;\n\n\toutstr = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!outstr)\n\t\tgoto out1;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh) {\n\t\tret = -EAGAIN;\n\t\tgoto out2;\n\t}\n\n\tif (ident != TAG_IDENT_PVD) {\n\t\tret = -EIO;\n\t\tgoto out_bh;\n\t}\n\n\tpvoldesc = (struct primaryVolDesc *)bh->b_data;\n\n\tif (udf_disk_stamp_to_time(&UDF_SB(sb)->s_record_time,\n\t\t\t      pvoldesc->recordingDateAndTime)) {\n#ifdef UDFFS_DEBUG\n\t\tstruct timestamp *ts = &pvoldesc->recordingDateAndTime;\n\t\tudf_debug(\"recording time %04u/%02u/%02u %02u:%02u (%x)\\n\",\n\t\t\t  le16_to_cpu(ts->year), ts->month, ts->day, ts->hour,\n\t\t\t  ts->minute, le16_to_cpu(ts->typeAndTimezone));\n#endif\n\t}\n\n\tif (!udf_build_ustr(instr, pvoldesc->volIdent, 32))\n\t\tif (udf_CS0toUTF8(outstr, instr)) {\n\t\t\tstrncpy(UDF_SB(sb)->s_volume_ident, outstr->u_name,\n\t\t\t\toutstr->u_len > 31 ? 31 : outstr->u_len);\n\t\t\tudf_debug(\"volIdent[] = '%s'\\n\",\n\t\t\t\t  UDF_SB(sb)->s_volume_ident);\n\t\t}\n\n\tif (!udf_build_ustr(instr, pvoldesc->volSetIdent, 128))\n\t\tif (udf_CS0toUTF8(outstr, instr))\n\t\t\tudf_debug(\"volSetIdent[] = '%s'\\n\", outstr->u_name);\n\n\tret = 0;\nout_bh:\n\tbrelse(bh);\nout2:\n\tkfree(outstr);\nout1:\n\tkfree(instr);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "instr"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "outstr"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"volSetIdent[] = '%s'\\n\"",
            "outstr->u_name"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_CS0toUTF8",
          "args": [
            "outstr",
            "instr"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "udf_CS0toUTF8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/unicode.c",
          "lines": "103-153",
          "snippet": "int udf_CS0toUTF8(struct ustr *utf_o, const struct ustr *ocu_i)\n{\n\tconst uint8_t *ocu;\n\tuint8_t cmp_id, ocu_len;\n\tint i;\n\n\tocu_len = ocu_i->u_len;\n\tif (ocu_len == 0) {\n\t\tmemset(utf_o, 0, sizeof(struct ustr));\n\t\treturn 0;\n\t}\n\n\tcmp_id = ocu_i->u_cmpID;\n\tif (cmp_id != 8 && cmp_id != 16) {\n\t\tmemset(utf_o, 0, sizeof(struct ustr));\n\t\tpr_err(\"unknown compression code (%d) stri=%s\\n\",\n\t\t       cmp_id, ocu_i->u_name);\n\t\treturn 0;\n\t}\n\n\tocu = ocu_i->u_name;\n\tutf_o->u_len = 0;\n\tfor (i = 0; (i < ocu_len) && (utf_o->u_len <= (UDF_NAME_LEN - 3));) {\n\n\t\t/* Expand OSTA compressed Unicode to Unicode */\n\t\tuint32_t c = ocu[i++];\n\t\tif (cmp_id == 16)\n\t\t\tc = (c << 8) | ocu[i++];\n\n\t\t/* Compress Unicode to UTF-8 */\n\t\tif (c < 0x80U)\n\t\t\tutf_o->u_name[utf_o->u_len++] = (uint8_t)c;\n\t\telse if (c < 0x800U) {\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0xc0 | (c >> 6));\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0x80 | (c & 0x3f));\n\t\t} else {\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0xe0 | (c >> 12));\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0x80 |\n\t\t\t\t\t\t\t  ((c >> 6) & 0x3f));\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0x80 | (c & 0x3f));\n\t\t}\n\t}\n\tutf_o->u_cmpID = 8;\n\n\treturn utf_o->u_len;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>\t/* for memset */",
            "#include <linux/kernel.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include <linux/slab.h>\n#include <linux/crc-itu-t.h>\n#include <linux/nls.h>\n#include <linux/string.h>\t/* for memset */\n#include <linux/kernel.h>\n#include \"udfdecl.h\"\n\nstatic int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);\n\nint udf_CS0toUTF8(struct ustr *utf_o, const struct ustr *ocu_i)\n{\n\tconst uint8_t *ocu;\n\tuint8_t cmp_id, ocu_len;\n\tint i;\n\n\tocu_len = ocu_i->u_len;\n\tif (ocu_len == 0) {\n\t\tmemset(utf_o, 0, sizeof(struct ustr));\n\t\treturn 0;\n\t}\n\n\tcmp_id = ocu_i->u_cmpID;\n\tif (cmp_id != 8 && cmp_id != 16) {\n\t\tmemset(utf_o, 0, sizeof(struct ustr));\n\t\tpr_err(\"unknown compression code (%d) stri=%s\\n\",\n\t\t       cmp_id, ocu_i->u_name);\n\t\treturn 0;\n\t}\n\n\tocu = ocu_i->u_name;\n\tutf_o->u_len = 0;\n\tfor (i = 0; (i < ocu_len) && (utf_o->u_len <= (UDF_NAME_LEN - 3));) {\n\n\t\t/* Expand OSTA compressed Unicode to Unicode */\n\t\tuint32_t c = ocu[i++];\n\t\tif (cmp_id == 16)\n\t\t\tc = (c << 8) | ocu[i++];\n\n\t\t/* Compress Unicode to UTF-8 */\n\t\tif (c < 0x80U)\n\t\t\tutf_o->u_name[utf_o->u_len++] = (uint8_t)c;\n\t\telse if (c < 0x800U) {\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0xc0 | (c >> 6));\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0x80 | (c & 0x3f));\n\t\t} else {\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0xe0 | (c >> 12));\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0x80 |\n\t\t\t\t\t\t\t  ((c >> 6) & 0x3f));\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0x80 | (c & 0x3f));\n\t\t}\n\t}\n\tutf_o->u_cmpID = 8;\n\n\treturn utf_o->u_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_build_ustr",
          "args": [
            "instr",
            "pvoldesc->volSetIdent",
            "128"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "udf_build_ustr_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/unicode.c",
          "lines": "71-82",
          "snippet": "static int udf_build_ustr_exact(struct ustr *dest, dstring *ptr, int exactsize)\n{\n\tif ((!dest) || (!ptr) || (!exactsize))\n\t\treturn -1;\n\n\tmemset(dest, 0, sizeof(struct ustr));\n\tdest->u_cmpID = ptr[0];\n\tdest->u_len = exactsize - 1;\n\tmemcpy(dest->u_name, ptr + 1, exactsize - 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>\t/* for memset */",
            "#include <linux/kernel.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include <linux/slab.h>\n#include <linux/crc-itu-t.h>\n#include <linux/nls.h>\n#include <linux/string.h>\t/* for memset */\n#include <linux/kernel.h>\n#include \"udfdecl.h\"\n\nstatic int udf_build_ustr_exact(struct ustr *dest, dstring *ptr, int exactsize)\n{\n\tif ((!dest) || (!ptr) || (!exactsize))\n\t\treturn -1;\n\n\tmemset(dest, 0, sizeof(struct ustr));\n\tdest->u_cmpID = ptr[0];\n\tdest->u_len = exactsize - 1;\n\tmemcpy(dest->u_name, ptr + 1, exactsize - 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"volIdent[] = '%s'\\n\"",
            "UDF_SB(sb)->s_volume_ident"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "UDF_SB(sb)->s_volume_ident",
            "outstr->u_name",
            "outstr->u_len > 31 ? 31 : outstr->u_len"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"recording time %04u/%02u/%02u %02u:%02u (%x)\\n\"",
            "le16_to_cpu(ts->year)",
            "ts->month",
            "ts->day",
            "ts->hour",
            "ts->minute",
            "le16_to_cpu(ts->typeAndTimezone)"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ts->typeAndTimezone"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_disk_stamp_to_time",
          "args": [
            "&UDF_SB(sb)->s_record_time",
            "pvoldesc->recordingDateAndTime"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "udf_disk_stamp_to_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udftime.c",
          "lines": "87-117",
          "snippet": "struct timespec *\nudf_disk_stamp_to_time(struct timespec *dest, struct timestamp src)\n{\n\tint yday;\n\tu16 typeAndTimezone = le16_to_cpu(src.typeAndTimezone);\n\tu16 year = le16_to_cpu(src.year);\n\tuint8_t type = typeAndTimezone >> 12;\n\tint16_t offset;\n\n\tif (type == 1) {\n\t\toffset = typeAndTimezone << 4;\n\t\t/* sign extent offset */\n\t\toffset = (offset >> 4);\n\t\tif (offset == -2047) /* unspecified offset */\n\t\t\toffset = 0;\n\t} else\n\t\toffset = 0;\n\n\tif ((year < EPOCH_YEAR) ||\n\t    (year >= EPOCH_YEAR + MAX_YEAR_SECONDS)) {\n\t\treturn NULL;\n\t}\n\tdest->tv_sec = year_seconds[year - EPOCH_YEAR];\n\tdest->tv_sec -= offset * 60;\n\n\tyday = ((__mon_yday[__isleap(year)][src.month - 1]) + src.day - 1);\n\tdest->tv_sec += (((yday * 24) + src.hour) * 60 + src.minute) * 60 + src.second;\n\tdest->tv_nsec = 1000 * (src.centiseconds * 10000 +\n\t\t\tsrc.hundredsOfMicroseconds * 100 + src.microseconds);\n\treturn dest;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [
            "#define MAX_YEAR_SECONDS\t69",
            "#define EPOCH_YEAR 1970"
          ],
          "globals_used": [
            "static const unsigned short int __mon_yday[2][13] = {\n\t/* Normal years.  */\n\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t/* Leap years.  */\n\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}\n};",
            "static time_t year_seconds[MAX_YEAR_SECONDS] = {\n/*1970*/ SPY(0,   0, 0), SPY(1,   0, 0), SPY(2,   0, 0), SPY(3,   1, 0),\n/*1974*/ SPY(4,   1, 0), SPY(5,   1, 0), SPY(6,   1, 0), SPY(7,   2, 0),\n/*1978*/ SPY(8,   2, 0), SPY(9,   2, 0), SPY(10,  2, 0), SPY(11,  3, 0),\n/*1982*/ SPY(12,  3, 0), SPY(13,  3, 0), SPY(14,  3, 0), SPY(15,  4, 0),\n/*1986*/ SPY(16,  4, 0), SPY(17,  4, 0), SPY(18,  4, 0), SPY(19,  5, 0),\n/*1990*/ SPY(20,  5, 0), SPY(21,  5, 0), SPY(22,  5, 0), SPY(23,  6, 0),\n/*1994*/ SPY(24,  6, 0), SPY(25,  6, 0), SPY(26,  6, 0), SPY(27,  7, 0),\n/*1998*/ SPY(28,  7, 0), SPY(29,  7, 0), SPY(30,  7, 0), SPY(31,  8, 0),\n/*2002*/ SPY(32,  8, 0), SPY(33,  8, 0), SPY(34,  8, 0), SPY(35,  9, 0),\n/*2006*/ SPY(36,  9, 0), SPY(37,  9, 0), SPY(38,  9, 0), SPY(39, 10, 0),\n/*2010*/ SPY(40, 10, 0), SPY(41, 10, 0), SPY(42, 10, 0), SPY(43, 11, 0),\n/*2014*/ SPY(44, 11, 0), SPY(45, 11, 0), SPY(46, 11, 0), SPY(47, 12, 0),\n/*2018*/ SPY(48, 12, 0), SPY(49, 12, 0), SPY(50, 12, 0), SPY(51, 13, 0),\n/*2022*/ SPY(52, 13, 0), SPY(53, 13, 0), SPY(54, 13, 0), SPY(55, 14, 0),\n/*2026*/ SPY(56, 14, 0), SPY(57, 14, 0), SPY(58, 14, 0), SPY(59, 15, 0),\n/*2030*/ SPY(60, 15, 0), SPY(61, 15, 0), SPY(62, 15, 0), SPY(63, 16, 0),\n/*2034*/ SPY(64, 16, 0), SPY(65, 16, 0), SPY(66, 16, 0), SPY(67, 17, 0),\n/*2038*/ SPY(68, 17, 0)\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/types.h>\n#include \"udfdecl.h\"\n\n#define MAX_YEAR_SECONDS\t69\n#define EPOCH_YEAR 1970\n\nstatic const unsigned short int __mon_yday[2][13] = {\n\t/* Normal years.  */\n\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t/* Leap years.  */\n\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}\n};\nstatic time_t year_seconds[MAX_YEAR_SECONDS] = {\n/*1970*/ SPY(0,   0, 0), SPY(1,   0, 0), SPY(2,   0, 0), SPY(3,   1, 0),\n/*1974*/ SPY(4,   1, 0), SPY(5,   1, 0), SPY(6,   1, 0), SPY(7,   2, 0),\n/*1978*/ SPY(8,   2, 0), SPY(9,   2, 0), SPY(10,  2, 0), SPY(11,  3, 0),\n/*1982*/ SPY(12,  3, 0), SPY(13,  3, 0), SPY(14,  3, 0), SPY(15,  4, 0),\n/*1986*/ SPY(16,  4, 0), SPY(17,  4, 0), SPY(18,  4, 0), SPY(19,  5, 0),\n/*1990*/ SPY(20,  5, 0), SPY(21,  5, 0), SPY(22,  5, 0), SPY(23,  6, 0),\n/*1994*/ SPY(24,  6, 0), SPY(25,  6, 0), SPY(26,  6, 0), SPY(27,  7, 0),\n/*1998*/ SPY(28,  7, 0), SPY(29,  7, 0), SPY(30,  7, 0), SPY(31,  8, 0),\n/*2002*/ SPY(32,  8, 0), SPY(33,  8, 0), SPY(34,  8, 0), SPY(35,  9, 0),\n/*2006*/ SPY(36,  9, 0), SPY(37,  9, 0), SPY(38,  9, 0), SPY(39, 10, 0),\n/*2010*/ SPY(40, 10, 0), SPY(41, 10, 0), SPY(42, 10, 0), SPY(43, 11, 0),\n/*2014*/ SPY(44, 11, 0), SPY(45, 11, 0), SPY(46, 11, 0), SPY(47, 12, 0),\n/*2018*/ SPY(48, 12, 0), SPY(49, 12, 0), SPY(50, 12, 0), SPY(51, 13, 0),\n/*2022*/ SPY(52, 13, 0), SPY(53, 13, 0), SPY(54, 13, 0), SPY(55, 14, 0),\n/*2026*/ SPY(56, 14, 0), SPY(57, 14, 0), SPY(58, 14, 0), SPY(59, 15, 0),\n/*2030*/ SPY(60, 15, 0), SPY(61, 15, 0), SPY(62, 15, 0), SPY(63, 16, 0),\n/*2034*/ SPY(64, 16, 0), SPY(65, 16, 0), SPY(66, 16, 0), SPY(67, 17, 0),\n/*2038*/ SPY(68, 17, 0)\n};\n\nstruct timespec *\nudf_disk_stamp_to_time(struct timespec *dest, struct timestamp src)\n{\n\tint yday;\n\tu16 typeAndTimezone = le16_to_cpu(src.typeAndTimezone);\n\tu16 year = le16_to_cpu(src.year);\n\tuint8_t type = typeAndTimezone >> 12;\n\tint16_t offset;\n\n\tif (type == 1) {\n\t\toffset = typeAndTimezone << 4;\n\t\t/* sign extent offset */\n\t\toffset = (offset >> 4);\n\t\tif (offset == -2047) /* unspecified offset */\n\t\t\toffset = 0;\n\t} else\n\t\toffset = 0;\n\n\tif ((year < EPOCH_YEAR) ||\n\t    (year >= EPOCH_YEAR + MAX_YEAR_SECONDS)) {\n\t\treturn NULL;\n\t}\n\tdest->tv_sec = year_seconds[year - EPOCH_YEAR];\n\tdest->tv_sec -= offset * 60;\n\n\tyday = ((__mon_yday[__isleap(year)][src.month - 1]) + src.day - 1);\n\tdest->tv_sec += (((yday * 24) + src.hour) * 60 + src.minute) * 60 + src.second;\n\tdest->tv_nsec = 1000 * (src.centiseconds * 10000 +\n\t\t\tsrc.hundredsOfMicroseconds * 100 + src.microseconds);\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_read_tagged",
          "args": [
            "sb",
            "block",
            "block",
            "&ident"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "udf_read_tagged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "202-259",
          "snippet": "struct buffer_head *udf_read_tagged(struct super_block *sb, uint32_t block,\n\t\t\t\t    uint32_t location, uint16_t *ident)\n{\n\tstruct tag *tag_p;\n\tstruct buffer_head *bh = NULL;\n\tu8 checksum;\n\n\t/* Read the block */\n\tif (block == 0xFFFFFFFF)\n\t\treturn NULL;\n\n\tbh = udf_tread(sb, block);\n\tif (!bh) {\n\t\tudf_err(sb, \"read failed, block=%u, location=%d\\n\",\n\t\t\tblock, location);\n\t\treturn NULL;\n\t}\n\n\ttag_p = (struct tag *)(bh->b_data);\n\n\t*ident = le16_to_cpu(tag_p->tagIdent);\n\n\tif (location != le32_to_cpu(tag_p->tagLocation)) {\n\t\tudf_debug(\"location mismatch block %u, tag %u != %u\\n\",\n\t\t\t  block, le32_to_cpu(tag_p->tagLocation), location);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag checksum */\n\tchecksum = udf_tag_checksum(tag_p);\n\tif (checksum != tag_p->tagChecksum) {\n\t\tudf_err(sb, \"tag checksum failed, block %u: 0x%02x != 0x%02x\\n\",\n\t\t\tblock, checksum, tag_p->tagChecksum);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag version */\n\tif (tag_p->descVersion != cpu_to_le16(0x0002U) &&\n\t    tag_p->descVersion != cpu_to_le16(0x0003U)) {\n\t\tudf_err(sb, \"tag version 0x%04x != 0x0002 || 0x0003, block %u\\n\",\n\t\t\tle16_to_cpu(tag_p->descVersion), block);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the descriptor CRC */\n\tif (le16_to_cpu(tag_p->descCRCLength) + sizeof(struct tag) > sb->s_blocksize ||\n\t    le16_to_cpu(tag_p->descCRC) == crc_itu_t(0,\n\t\t\t\t\tbh->b_data + sizeof(struct tag),\n\t\t\t\t\tle16_to_cpu(tag_p->descCRCLength)))\n\t\treturn bh;\n\n\tudf_debug(\"Crc failure block %d: crc = %d, crclen = %d\\n\", block,\n\t\t  le16_to_cpu(tag_p->descCRC),\n\t\t  le16_to_cpu(tag_p->descCRCLength));\nerror_out:\n\tbrelse(bh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_read_tagged(struct super_block *sb, uint32_t block,\n\t\t\t\t    uint32_t location, uint16_t *ident)\n{\n\tstruct tag *tag_p;\n\tstruct buffer_head *bh = NULL;\n\tu8 checksum;\n\n\t/* Read the block */\n\tif (block == 0xFFFFFFFF)\n\t\treturn NULL;\n\n\tbh = udf_tread(sb, block);\n\tif (!bh) {\n\t\tudf_err(sb, \"read failed, block=%u, location=%d\\n\",\n\t\t\tblock, location);\n\t\treturn NULL;\n\t}\n\n\ttag_p = (struct tag *)(bh->b_data);\n\n\t*ident = le16_to_cpu(tag_p->tagIdent);\n\n\tif (location != le32_to_cpu(tag_p->tagLocation)) {\n\t\tudf_debug(\"location mismatch block %u, tag %u != %u\\n\",\n\t\t\t  block, le32_to_cpu(tag_p->tagLocation), location);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag checksum */\n\tchecksum = udf_tag_checksum(tag_p);\n\tif (checksum != tag_p->tagChecksum) {\n\t\tudf_err(sb, \"tag checksum failed, block %u: 0x%02x != 0x%02x\\n\",\n\t\t\tblock, checksum, tag_p->tagChecksum);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag version */\n\tif (tag_p->descVersion != cpu_to_le16(0x0002U) &&\n\t    tag_p->descVersion != cpu_to_le16(0x0003U)) {\n\t\tudf_err(sb, \"tag version 0x%04x != 0x0002 || 0x0003, block %u\\n\",\n\t\t\tle16_to_cpu(tag_p->descVersion), block);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the descriptor CRC */\n\tif (le16_to_cpu(tag_p->descCRCLength) + sizeof(struct tag) > sb->s_blocksize ||\n\t    le16_to_cpu(tag_p->descCRC) == crc_itu_t(0,\n\t\t\t\t\tbh->b_data + sizeof(struct tag),\n\t\t\t\t\tle16_to_cpu(tag_p->descCRCLength)))\n\t\treturn bh;\n\n\tudf_debug(\"Crc failure block %d: crc = %d, crclen = %d\\n\", block,\n\t\t  le16_to_cpu(tag_p->descCRC),\n\t\t  le16_to_cpu(tag_p->descCRCLength));\nerror_out:\n\tbrelse(bh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct ustr)",
            "GFP_NOFS"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_load_pvoldesc(struct super_block *sb, sector_t block)\n{\n\tstruct primaryVolDesc *pvoldesc;\n\tstruct ustr *instr, *outstr;\n\tstruct buffer_head *bh;\n\tuint16_t ident;\n\tint ret = -ENOMEM;\n\n\tinstr = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!instr)\n\t\treturn -ENOMEM;\n\n\toutstr = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!outstr)\n\t\tgoto out1;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh) {\n\t\tret = -EAGAIN;\n\t\tgoto out2;\n\t}\n\n\tif (ident != TAG_IDENT_PVD) {\n\t\tret = -EIO;\n\t\tgoto out_bh;\n\t}\n\n\tpvoldesc = (struct primaryVolDesc *)bh->b_data;\n\n\tif (udf_disk_stamp_to_time(&UDF_SB(sb)->s_record_time,\n\t\t\t      pvoldesc->recordingDateAndTime)) {\n#ifdef UDFFS_DEBUG\n\t\tstruct timestamp *ts = &pvoldesc->recordingDateAndTime;\n\t\tudf_debug(\"recording time %04u/%02u/%02u %02u:%02u (%x)\\n\",\n\t\t\t  le16_to_cpu(ts->year), ts->month, ts->day, ts->hour,\n\t\t\t  ts->minute, le16_to_cpu(ts->typeAndTimezone));\n#endif\n\t}\n\n\tif (!udf_build_ustr(instr, pvoldesc->volIdent, 32))\n\t\tif (udf_CS0toUTF8(outstr, instr)) {\n\t\t\tstrncpy(UDF_SB(sb)->s_volume_ident, outstr->u_name,\n\t\t\t\toutstr->u_len > 31 ? 31 : outstr->u_len);\n\t\t\tudf_debug(\"volIdent[] = '%s'\\n\",\n\t\t\t\t  UDF_SB(sb)->s_volume_ident);\n\t\t}\n\n\tif (!udf_build_ustr(instr, pvoldesc->volSetIdent, 128))\n\t\tif (udf_CS0toUTF8(outstr, instr))\n\t\t\tudf_debug(\"volSetIdent[] = '%s'\\n\", outstr->u_name);\n\n\tret = 0;\nout_bh:\n\tbrelse(bh);\nout2:\n\tkfree(outstr);\nout1:\n\tkfree(instr);\n\treturn ret;\n}"
  },
  {
    "function_name": "udf_find_fileset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "796-884",
    "snippet": "static int udf_find_fileset(struct super_block *sb,\n\t\t\t    struct kernel_lb_addr *fileset,\n\t\t\t    struct kernel_lb_addr *root)\n{\n\tstruct buffer_head *bh = NULL;\n\tlong lastblock;\n\tuint16_t ident;\n\tstruct udf_sb_info *sbi;\n\n\tif (fileset->logicalBlockNum != 0xFFFFFFFF ||\n\t    fileset->partitionReferenceNum != 0xFFFF) {\n\t\tbh = udf_read_ptagged(sb, fileset, 0, &ident);\n\n\t\tif (!bh) {\n\t\t\treturn 1;\n\t\t} else if (ident != TAG_IDENT_FSD) {\n\t\t\tbrelse(bh);\n\t\t\treturn 1;\n\t\t}\n\n\t}\n\n\tsbi = UDF_SB(sb);\n\tif (!bh) {\n\t\t/* Search backwards through the partitions */\n\t\tstruct kernel_lb_addr newfileset;\n\n/* --> cvg: FIXME - is it reasonable? */\n\t\treturn 1;\n\n\t\tfor (newfileset.partitionReferenceNum = sbi->s_partitions - 1;\n\t\t     (newfileset.partitionReferenceNum != 0xFFFF &&\n\t\t      fileset->logicalBlockNum == 0xFFFFFFFF &&\n\t\t      fileset->partitionReferenceNum == 0xFFFF);\n\t\t     newfileset.partitionReferenceNum--) {\n\t\t\tlastblock = sbi->s_partmaps\n\t\t\t\t\t[newfileset.partitionReferenceNum]\n\t\t\t\t\t\t.s_partition_len;\n\t\t\tnewfileset.logicalBlockNum = 0;\n\n\t\t\tdo {\n\t\t\t\tbh = udf_read_ptagged(sb, &newfileset, 0,\n\t\t\t\t\t\t      &ident);\n\t\t\t\tif (!bh) {\n\t\t\t\t\tnewfileset.logicalBlockNum++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tswitch (ident) {\n\t\t\t\tcase TAG_IDENT_SBD:\n\t\t\t\t{\n\t\t\t\t\tstruct spaceBitmapDesc *sp;\n\t\t\t\t\tsp = (struct spaceBitmapDesc *)\n\t\t\t\t\t\t\t\tbh->b_data;\n\t\t\t\t\tnewfileset.logicalBlockNum += 1 +\n\t\t\t\t\t\t((le32_to_cpu(sp->numOfBytes) +\n\t\t\t\t\t\t  sizeof(struct spaceBitmapDesc)\n\t\t\t\t\t\t  - 1) >> sb->s_blocksize_bits);\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase TAG_IDENT_FSD:\n\t\t\t\t\t*fileset = newfileset;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tnewfileset.logicalBlockNum++;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tbh = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (newfileset.logicalBlockNum < lastblock &&\n\t\t\t\t fileset->logicalBlockNum == 0xFFFFFFFF &&\n\t\t\t\t fileset->partitionReferenceNum == 0xFFFF);\n\t\t}\n\t}\n\n\tif ((fileset->logicalBlockNum != 0xFFFFFFFF ||\n\t     fileset->partitionReferenceNum != 0xFFFF) && bh) {\n\t\tudf_debug(\"Fileset at block=%d, partition=%d\\n\",\n\t\t\t  fileset->logicalBlockNum,\n\t\t\t  fileset->partitionReferenceNum);\n\n\t\tsbi->s_partition = fileset->partitionReferenceNum;\n\t\tudf_load_fileset(sb, bh, root);\n\t\tbrelse(bh);\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
      "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_load_fileset",
          "args": [
            "sb",
            "bh",
            "root"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "udf_load_fileset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "1039-1052",
          "snippet": "static void udf_load_fileset(struct super_block *sb, struct buffer_head *bh,\n\t\t\t     struct kernel_lb_addr *root)\n{\n\tstruct fileSetDesc *fset;\n\n\tfset = (struct fileSetDesc *)bh->b_data;\n\n\t*root = lelb_to_cpu(fset->rootDirectoryICB.extLocation);\n\n\tUDF_SB(sb)->s_serial_number = le16_to_cpu(fset->descTag.tagSerialNum);\n\n\tudf_debug(\"Rootdir at block=%d, partition=%d\\n\",\n\t\t  root->logicalBlockNum, root->partitionReferenceNum);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
            "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic void udf_load_fileset(struct super_block *sb, struct buffer_head *bh,\n\t\t\t     struct kernel_lb_addr *root)\n{\n\tstruct fileSetDesc *fset;\n\n\tfset = (struct fileSetDesc *)bh->b_data;\n\n\t*root = lelb_to_cpu(fset->rootDirectoryICB.extLocation);\n\n\tUDF_SB(sb)->s_serial_number = le16_to_cpu(fset->descTag.tagSerialNum);\n\n\tudf_debug(\"Rootdir at block=%d, partition=%d\\n\",\n\t\t  root->logicalBlockNum, root->partitionReferenceNum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Fileset at block=%d, partition=%d\\n\"",
            "fileset->logicalBlockNum",
            "fileset->partitionReferenceNum"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sp->numOfBytes"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_read_ptagged",
          "args": [
            "sb",
            "&newfileset",
            "0",
            "&ident"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "udf_read_ptagged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "261-267",
          "snippet": "struct buffer_head *udf_read_ptagged(struct super_block *sb,\n\t\t\t\t     struct kernel_lb_addr *loc,\n\t\t\t\t     uint32_t offset, uint16_t *ident)\n{\n\treturn udf_read_tagged(sb, udf_get_lb_pblock(sb, loc, offset),\n\t\t\t       loc->logicalBlockNum + offset, ident);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_read_ptagged(struct super_block *sb,\n\t\t\t\t     struct kernel_lb_addr *loc,\n\t\t\t\t     uint32_t offset, uint16_t *ident)\n{\n\treturn udf_read_tagged(sb, udf_get_lb_pblock(sb, loc, offset),\n\t\t\t       loc->logicalBlockNum + offset, ident);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_find_fileset(struct super_block *sb,\n\t\t\t    struct kernel_lb_addr *fileset,\n\t\t\t    struct kernel_lb_addr *root)\n{\n\tstruct buffer_head *bh = NULL;\n\tlong lastblock;\n\tuint16_t ident;\n\tstruct udf_sb_info *sbi;\n\n\tif (fileset->logicalBlockNum != 0xFFFFFFFF ||\n\t    fileset->partitionReferenceNum != 0xFFFF) {\n\t\tbh = udf_read_ptagged(sb, fileset, 0, &ident);\n\n\t\tif (!bh) {\n\t\t\treturn 1;\n\t\t} else if (ident != TAG_IDENT_FSD) {\n\t\t\tbrelse(bh);\n\t\t\treturn 1;\n\t\t}\n\n\t}\n\n\tsbi = UDF_SB(sb);\n\tif (!bh) {\n\t\t/* Search backwards through the partitions */\n\t\tstruct kernel_lb_addr newfileset;\n\n/* --> cvg: FIXME - is it reasonable? */\n\t\treturn 1;\n\n\t\tfor (newfileset.partitionReferenceNum = sbi->s_partitions - 1;\n\t\t     (newfileset.partitionReferenceNum != 0xFFFF &&\n\t\t      fileset->logicalBlockNum == 0xFFFFFFFF &&\n\t\t      fileset->partitionReferenceNum == 0xFFFF);\n\t\t     newfileset.partitionReferenceNum--) {\n\t\t\tlastblock = sbi->s_partmaps\n\t\t\t\t\t[newfileset.partitionReferenceNum]\n\t\t\t\t\t\t.s_partition_len;\n\t\t\tnewfileset.logicalBlockNum = 0;\n\n\t\t\tdo {\n\t\t\t\tbh = udf_read_ptagged(sb, &newfileset, 0,\n\t\t\t\t\t\t      &ident);\n\t\t\t\tif (!bh) {\n\t\t\t\t\tnewfileset.logicalBlockNum++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tswitch (ident) {\n\t\t\t\tcase TAG_IDENT_SBD:\n\t\t\t\t{\n\t\t\t\t\tstruct spaceBitmapDesc *sp;\n\t\t\t\t\tsp = (struct spaceBitmapDesc *)\n\t\t\t\t\t\t\t\tbh->b_data;\n\t\t\t\t\tnewfileset.logicalBlockNum += 1 +\n\t\t\t\t\t\t((le32_to_cpu(sp->numOfBytes) +\n\t\t\t\t\t\t  sizeof(struct spaceBitmapDesc)\n\t\t\t\t\t\t  - 1) >> sb->s_blocksize_bits);\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase TAG_IDENT_FSD:\n\t\t\t\t\t*fileset = newfileset;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tnewfileset.logicalBlockNum++;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tbh = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (newfileset.logicalBlockNum < lastblock &&\n\t\t\t\t fileset->logicalBlockNum == 0xFFFFFFFF &&\n\t\t\t\t fileset->partitionReferenceNum == 0xFFFF);\n\t\t}\n\t}\n\n\tif ((fileset->logicalBlockNum != 0xFFFFFFFF ||\n\t     fileset->partitionReferenceNum != 0xFFFF) && bh) {\n\t\tudf_debug(\"Fileset at block=%d, partition=%d\\n\",\n\t\t\t  fileset->logicalBlockNum,\n\t\t\t  fileset->partitionReferenceNum);\n\n\t\tsbi->s_partition = fileset->partitionReferenceNum;\n\t\tudf_load_fileset(sb, bh, root);\n\t\tbrelse(bh);\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "udf_check_vsd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "693-794",
    "snippet": "static loff_t udf_check_vsd(struct super_block *sb)\n{\n\tstruct volStructDesc *vsd = NULL;\n\tloff_t sector = VSD_FIRST_SECTOR_OFFSET;\n\tint sectorsize;\n\tstruct buffer_head *bh = NULL;\n\tint nsr02 = 0;\n\tint nsr03 = 0;\n\tstruct udf_sb_info *sbi;\n\n\tsbi = UDF_SB(sb);\n\tif (sb->s_blocksize < sizeof(struct volStructDesc))\n\t\tsectorsize = sizeof(struct volStructDesc);\n\telse\n\t\tsectorsize = sb->s_blocksize;\n\n\tsector += (sbi->s_session << sb->s_blocksize_bits);\n\n\tudf_debug(\"Starting at sector %u (%ld byte sectors)\\n\",\n\t\t  (unsigned int)(sector >> sb->s_blocksize_bits),\n\t\t  sb->s_blocksize);\n\t/* Process the sequence (if applicable). The hard limit on the sector\n\t * offset is arbitrary, hopefully large enough so that all valid UDF\n\t * filesystems will be recognised. There is no mention of an upper\n\t * bound to the size of the volume recognition area in the standard.\n\t *  The limit will prevent the code to read all the sectors of a\n\t * specially crafted image (like a bluray disc full of CD001 sectors),\n\t * potentially causing minutes or even hours of uninterruptible I/O\n\t * activity. This actually happened with uninitialised SSD partitions\n\t * (all 0xFF) before the check for the limit and all valid IDs were\n\t * added */\n\tfor (; !nsr02 && !nsr03 && sector < VSD_MAX_SECTOR_OFFSET;\n\t     sector += sectorsize) {\n\t\t/* Read a block */\n\t\tbh = udf_tread(sb, sector >> sb->s_blocksize_bits);\n\t\tif (!bh)\n\t\t\tbreak;\n\n\t\t/* Look for ISO  descriptors */\n\t\tvsd = (struct volStructDesc *)(bh->b_data +\n\t\t\t\t\t      (sector & (sb->s_blocksize - 1)));\n\n\t\tif (!strncmp(vsd->stdIdent, VSD_STD_ID_CD001,\n\t\t\t\t    VSD_STD_ID_LEN)) {\n\t\t\tswitch (vsd->structType) {\n\t\t\tcase 0:\n\t\t\t\tudf_debug(\"ISO9660 Boot Record found\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tudf_debug(\"ISO9660 Primary Volume Descriptor found\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tudf_debug(\"ISO9660 Supplementary Volume Descriptor found\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tudf_debug(\"ISO9660 Volume Partition Descriptor found\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 255:\n\t\t\t\tudf_debug(\"ISO9660 Volume Descriptor Set Terminator found\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tudf_debug(\"ISO9660 VRS (%u) found\\n\",\n\t\t\t\t\t  vsd->structType);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!strncmp(vsd->stdIdent, VSD_STD_ID_BEA01,\n\t\t\t\t    VSD_STD_ID_LEN))\n\t\t\t; /* nothing */\n\t\telse if (!strncmp(vsd->stdIdent, VSD_STD_ID_TEA01,\n\t\t\t\t    VSD_STD_ID_LEN)) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t} else if (!strncmp(vsd->stdIdent, VSD_STD_ID_NSR02,\n\t\t\t\t    VSD_STD_ID_LEN))\n\t\t\tnsr02 = sector;\n\t\telse if (!strncmp(vsd->stdIdent, VSD_STD_ID_NSR03,\n\t\t\t\t    VSD_STD_ID_LEN))\n\t\t\tnsr03 = sector;\n\t\telse if (!strncmp(vsd->stdIdent, VSD_STD_ID_BOOT2,\n\t\t\t\t    VSD_STD_ID_LEN))\n\t\t\t; /* nothing */\n\t\telse if (!strncmp(vsd->stdIdent, VSD_STD_ID_CDW02,\n\t\t\t\t    VSD_STD_ID_LEN))\n\t\t\t; /* nothing */\n\t\telse {\n\t\t\t/* invalid id : end of volume recognition area */\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\t\tbrelse(bh);\n\t}\n\n\tif (nsr03)\n\t\treturn nsr03;\n\telse if (nsr02)\n\t\treturn nsr02;\n\telse if (!bh && sector - (sbi->s_session << sb->s_blocksize_bits) ==\n\t\t\tVSD_FIRST_SECTOR_OFFSET)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [
      "#define VSD_MAX_SECTOR_OFFSET\t\t0x800000",
      "#define VSD_FIRST_SECTOR_OFFSET\t\t32768"
    ],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "vsd->stdIdent",
            "VSD_STD_ID_CDW02",
            "VSD_STD_ID_LEN"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "vsd->stdIdent",
            "VSD_STD_ID_BOOT2",
            "VSD_STD_ID_LEN"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "vsd->stdIdent",
            "VSD_STD_ID_NSR03",
            "VSD_STD_ID_LEN"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "vsd->stdIdent",
            "VSD_STD_ID_NSR02",
            "VSD_STD_ID_LEN"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "vsd->stdIdent",
            "VSD_STD_ID_TEA01",
            "VSD_STD_ID_LEN"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "vsd->stdIdent",
            "VSD_STD_ID_BEA01",
            "VSD_STD_ID_LEN"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"ISO9660 VRS (%u) found\\n\"",
            "vsd->structType"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"ISO9660 Volume Descriptor Set Terminator found\\n\""
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"ISO9660 Volume Partition Descriptor found\\n\""
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"ISO9660 Supplementary Volume Descriptor found\\n\""
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"ISO9660 Primary Volume Descriptor found\\n\""
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"ISO9660 Boot Record found\\n\""
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "vsd->stdIdent",
            "VSD_STD_ID_CD001",
            "VSD_STD_ID_LEN"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_tread",
          "args": [
            "sb",
            "sector >> sb->s_blocksize_bits"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "udf_tread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "40-46",
          "snippet": "struct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Starting at sector %u (%ld byte sectors)\\n\"",
            "(unsigned int)(sector >> sb->s_blocksize_bits)",
            "sb->s_blocksize"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\n#define VSD_MAX_SECTOR_OFFSET\t\t0x800000\n#define VSD_FIRST_SECTOR_OFFSET\t\t32768\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic loff_t udf_check_vsd(struct super_block *sb)\n{\n\tstruct volStructDesc *vsd = NULL;\n\tloff_t sector = VSD_FIRST_SECTOR_OFFSET;\n\tint sectorsize;\n\tstruct buffer_head *bh = NULL;\n\tint nsr02 = 0;\n\tint nsr03 = 0;\n\tstruct udf_sb_info *sbi;\n\n\tsbi = UDF_SB(sb);\n\tif (sb->s_blocksize < sizeof(struct volStructDesc))\n\t\tsectorsize = sizeof(struct volStructDesc);\n\telse\n\t\tsectorsize = sb->s_blocksize;\n\n\tsector += (sbi->s_session << sb->s_blocksize_bits);\n\n\tudf_debug(\"Starting at sector %u (%ld byte sectors)\\n\",\n\t\t  (unsigned int)(sector >> sb->s_blocksize_bits),\n\t\t  sb->s_blocksize);\n\t/* Process the sequence (if applicable). The hard limit on the sector\n\t * offset is arbitrary, hopefully large enough so that all valid UDF\n\t * filesystems will be recognised. There is no mention of an upper\n\t * bound to the size of the volume recognition area in the standard.\n\t *  The limit will prevent the code to read all the sectors of a\n\t * specially crafted image (like a bluray disc full of CD001 sectors),\n\t * potentially causing minutes or even hours of uninterruptible I/O\n\t * activity. This actually happened with uninitialised SSD partitions\n\t * (all 0xFF) before the check for the limit and all valid IDs were\n\t * added */\n\tfor (; !nsr02 && !nsr03 && sector < VSD_MAX_SECTOR_OFFSET;\n\t     sector += sectorsize) {\n\t\t/* Read a block */\n\t\tbh = udf_tread(sb, sector >> sb->s_blocksize_bits);\n\t\tif (!bh)\n\t\t\tbreak;\n\n\t\t/* Look for ISO  descriptors */\n\t\tvsd = (struct volStructDesc *)(bh->b_data +\n\t\t\t\t\t      (sector & (sb->s_blocksize - 1)));\n\n\t\tif (!strncmp(vsd->stdIdent, VSD_STD_ID_CD001,\n\t\t\t\t    VSD_STD_ID_LEN)) {\n\t\t\tswitch (vsd->structType) {\n\t\t\tcase 0:\n\t\t\t\tudf_debug(\"ISO9660 Boot Record found\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tudf_debug(\"ISO9660 Primary Volume Descriptor found\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tudf_debug(\"ISO9660 Supplementary Volume Descriptor found\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tudf_debug(\"ISO9660 Volume Partition Descriptor found\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 255:\n\t\t\t\tudf_debug(\"ISO9660 Volume Descriptor Set Terminator found\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tudf_debug(\"ISO9660 VRS (%u) found\\n\",\n\t\t\t\t\t  vsd->structType);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!strncmp(vsd->stdIdent, VSD_STD_ID_BEA01,\n\t\t\t\t    VSD_STD_ID_LEN))\n\t\t\t; /* nothing */\n\t\telse if (!strncmp(vsd->stdIdent, VSD_STD_ID_TEA01,\n\t\t\t\t    VSD_STD_ID_LEN)) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t} else if (!strncmp(vsd->stdIdent, VSD_STD_ID_NSR02,\n\t\t\t\t    VSD_STD_ID_LEN))\n\t\t\tnsr02 = sector;\n\t\telse if (!strncmp(vsd->stdIdent, VSD_STD_ID_NSR03,\n\t\t\t\t    VSD_STD_ID_LEN))\n\t\t\tnsr03 = sector;\n\t\telse if (!strncmp(vsd->stdIdent, VSD_STD_ID_BOOT2,\n\t\t\t\t    VSD_STD_ID_LEN))\n\t\t\t; /* nothing */\n\t\telse if (!strncmp(vsd->stdIdent, VSD_STD_ID_CDW02,\n\t\t\t\t    VSD_STD_ID_LEN))\n\t\t\t; /* nothing */\n\t\telse {\n\t\t\t/* invalid id : end of volume recognition area */\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\t\tbrelse(bh);\n\t}\n\n\tif (nsr03)\n\t\treturn nsr03;\n\telse if (nsr02)\n\t\treturn nsr02;\n\telse if (!bh && sector - (sbi->s_session << sb->s_blocksize_bits) ==\n\t\t\tVSD_FIRST_SECTOR_OFFSET)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}"
  },
  {
    "function_name": "udf_remount_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "646-689",
    "snippet": "static int udf_remount_fs(struct super_block *sb, int *flags, char *options)\n{\n\tstruct udf_options uopt;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint error = 0;\n\tstruct logicalVolIntegrityDescImpUse *lvidiu = udf_sb_lvidiu(sb);\n\n\tsync_filesystem(sb);\n\tif (lvidiu) {\n\t\tint write_rev = le16_to_cpu(lvidiu->minUDFWriteRev);\n\t\tif (write_rev > UDF_MAX_WRITE_VERSION && !(*flags & MS_RDONLY))\n\t\t\treturn -EACCES;\n\t}\n\n\tuopt.flags = sbi->s_flags;\n\tuopt.uid   = sbi->s_uid;\n\tuopt.gid   = sbi->s_gid;\n\tuopt.umask = sbi->s_umask;\n\tuopt.fmode = sbi->s_fmode;\n\tuopt.dmode = sbi->s_dmode;\n\n\tif (!udf_parse_options(options, &uopt, true))\n\t\treturn -EINVAL;\n\n\twrite_lock(&sbi->s_cred_lock);\n\tsbi->s_flags = uopt.flags;\n\tsbi->s_uid   = uopt.uid;\n\tsbi->s_gid   = uopt.gid;\n\tsbi->s_umask = uopt.umask;\n\tsbi->s_fmode = uopt.fmode;\n\tsbi->s_dmode = uopt.dmode;\n\twrite_unlock(&sbi->s_cred_lock);\n\n\tif ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))\n\t\tgoto out_unlock;\n\n\tif (*flags & MS_RDONLY)\n\t\tudf_close_lvid(sb);\n\telse\n\t\tudf_open_lvid(sb);\n\nout_unlock:\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_open_lvid",
          "args": [
            "sb"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "udf_open_lvid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "1957-1988",
          "snippet": "static void udf_open_lvid(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct buffer_head *bh = sbi->s_lvid_bh;\n\tstruct logicalVolIntegrityDesc *lvid;\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\n\tif (!bh)\n\t\treturn;\n\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (!lvidiu)\n\t\treturn;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tlvidiu->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\tlvidiu->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\tudf_time_to_disk_stamp(&lvid->recordingDateAndTime,\n\t\t\t\tCURRENT_TIME);\n\tlvid->integrityType = cpu_to_le32(LVID_INTEGRITY_TYPE_OPEN);\n\n\tlvid->descTag.descCRC = cpu_to_le16(\n\t\tcrc_itu_t(0, (char *)lvid + sizeof(struct tag),\n\t\t\tle16_to_cpu(lvid->descTag.descCRCLength)));\n\n\tlvid->descTag.tagChecksum = udf_tag_checksum(&lvid->descTag);\n\tmark_buffer_dirty(bh);\n\tsbi->s_lvid_dirty = 0;\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t/* Make opening of filesystem visible on the media immediately */\n\tsync_dirty_buffer(bh);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic void udf_open_lvid(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct buffer_head *bh = sbi->s_lvid_bh;\n\tstruct logicalVolIntegrityDesc *lvid;\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\n\tif (!bh)\n\t\treturn;\n\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (!lvidiu)\n\t\treturn;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tlvidiu->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\tlvidiu->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\tudf_time_to_disk_stamp(&lvid->recordingDateAndTime,\n\t\t\t\tCURRENT_TIME);\n\tlvid->integrityType = cpu_to_le32(LVID_INTEGRITY_TYPE_OPEN);\n\n\tlvid->descTag.descCRC = cpu_to_le16(\n\t\tcrc_itu_t(0, (char *)lvid + sizeof(struct tag),\n\t\t\tle16_to_cpu(lvid->descTag.descCRCLength)));\n\n\tlvid->descTag.tagChecksum = udf_tag_checksum(&lvid->descTag);\n\tmark_buffer_dirty(bh);\n\tsbi->s_lvid_dirty = 0;\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t/* Make opening of filesystem visible on the media immediately */\n\tsync_dirty_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_close_lvid",
          "args": [
            "sb"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "udf_close_lvid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "1990-2032",
          "snippet": "static void udf_close_lvid(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct buffer_head *bh = sbi->s_lvid_bh;\n\tstruct logicalVolIntegrityDesc *lvid;\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\n\tif (!bh)\n\t\treturn;\n\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (!lvidiu)\n\t\treturn;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tlvidiu->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\tlvidiu->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\tudf_time_to_disk_stamp(&lvid->recordingDateAndTime, CURRENT_TIME);\n\tif (UDF_MAX_WRITE_VERSION > le16_to_cpu(lvidiu->maxUDFWriteRev))\n\t\tlvidiu->maxUDFWriteRev = cpu_to_le16(UDF_MAX_WRITE_VERSION);\n\tif (sbi->s_udfrev > le16_to_cpu(lvidiu->minUDFReadRev))\n\t\tlvidiu->minUDFReadRev = cpu_to_le16(sbi->s_udfrev);\n\tif (sbi->s_udfrev > le16_to_cpu(lvidiu->minUDFWriteRev))\n\t\tlvidiu->minUDFWriteRev = cpu_to_le16(sbi->s_udfrev);\n\tlvid->integrityType = cpu_to_le32(LVID_INTEGRITY_TYPE_CLOSE);\n\n\tlvid->descTag.descCRC = cpu_to_le16(\n\t\t\tcrc_itu_t(0, (char *)lvid + sizeof(struct tag),\n\t\t\t\tle16_to_cpu(lvid->descTag.descCRCLength)));\n\n\tlvid->descTag.tagChecksum = udf_tag_checksum(&lvid->descTag);\n\t/*\n\t * We set buffer uptodate unconditionally here to avoid spurious\n\t * warnings from mark_buffer_dirty() when previous EIO has marked\n\t * the buffer as !uptodate\n\t */\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\tsbi->s_lvid_dirty = 0;\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t/* Make closing of filesystem visible on the media immediately */\n\tsync_dirty_buffer(bh);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic void udf_close_lvid(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct buffer_head *bh = sbi->s_lvid_bh;\n\tstruct logicalVolIntegrityDesc *lvid;\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\n\tif (!bh)\n\t\treturn;\n\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (!lvidiu)\n\t\treturn;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tlvidiu->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\tlvidiu->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\tudf_time_to_disk_stamp(&lvid->recordingDateAndTime, CURRENT_TIME);\n\tif (UDF_MAX_WRITE_VERSION > le16_to_cpu(lvidiu->maxUDFWriteRev))\n\t\tlvidiu->maxUDFWriteRev = cpu_to_le16(UDF_MAX_WRITE_VERSION);\n\tif (sbi->s_udfrev > le16_to_cpu(lvidiu->minUDFReadRev))\n\t\tlvidiu->minUDFReadRev = cpu_to_le16(sbi->s_udfrev);\n\tif (sbi->s_udfrev > le16_to_cpu(lvidiu->minUDFWriteRev))\n\t\tlvidiu->minUDFWriteRev = cpu_to_le16(sbi->s_udfrev);\n\tlvid->integrityType = cpu_to_le32(LVID_INTEGRITY_TYPE_CLOSE);\n\n\tlvid->descTag.descCRC = cpu_to_le16(\n\t\t\tcrc_itu_t(0, (char *)lvid + sizeof(struct tag),\n\t\t\t\tle16_to_cpu(lvid->descTag.descCRCLength)));\n\n\tlvid->descTag.tagChecksum = udf_tag_checksum(&lvid->descTag);\n\t/*\n\t * We set buffer uptodate unconditionally here to avoid spurious\n\t * warnings from mark_buffer_dirty() when previous EIO has marked\n\t * the buffer as !uptodate\n\t */\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\tsbi->s_lvid_dirty = 0;\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\t/* Make closing of filesystem visible on the media immediately */\n\tsync_dirty_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&sbi->s_cred_lock"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&sbi->s_cred_lock"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_parse_options",
          "args": [
            "options",
            "&uopt",
            "true"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "udf_parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "486-644",
          "snippet": "static int udf_parse_options(char *options, struct udf_options *uopt,\n\t\t\t     bool remount)\n{\n\tchar *p;\n\tint option;\n\n\tuopt->novrs = 0;\n\tuopt->partition = 0xFFFF;\n\tuopt->session = 0xFFFFFFFF;\n\tuopt->lastblock = 0;\n\tuopt->anchor = 0;\n\tuopt->volume = 0xFFFFFFFF;\n\tuopt->rootdir = 0xFFFFFFFF;\n\tuopt->fileset = 0xFFFFFFFF;\n\tuopt->nls_map = NULL;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tunsigned n;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_novrs:\n\t\t\tuopt->novrs = 1;\n\t\t\tbreak;\n\t\tcase Opt_bs:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tn = option;\n\t\t\tif (n != 512 && n != 1024 && n != 2048 && n != 4096)\n\t\t\t\treturn 0;\n\t\t\tuopt->blocksize = n;\n\t\t\tuopt->flags |= (1 << UDF_FLAG_BLOCKSIZE_SET);\n\t\t\tbreak;\n\t\tcase Opt_unhide:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UNHIDE);\n\t\t\tbreak;\n\t\tcase Opt_undelete:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UNDELETE);\n\t\t\tbreak;\n\t\tcase Opt_noadinicb:\n\t\t\tuopt->flags &= ~(1 << UDF_FLAG_USE_AD_IN_ICB);\n\t\t\tbreak;\n\t\tcase Opt_adinicb:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_USE_AD_IN_ICB);\n\t\t\tbreak;\n\t\tcase Opt_shortad:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_USE_SHORT_AD);\n\t\t\tbreak;\n\t\tcase Opt_longad:\n\t\t\tuopt->flags &= ~(1 << UDF_FLAG_USE_SHORT_AD);\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(uopt->gid))\n\t\t\t\treturn 0;\n\t\t\tuopt->flags |= (1 << UDF_FLAG_GID_SET);\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uopt->uid))\n\t\t\t\treturn 0;\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UID_SET);\n\t\t\tbreak;\n\t\tcase Opt_umask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->umask = option;\n\t\t\tbreak;\n\t\tcase Opt_nostrict:\n\t\t\tuopt->flags &= ~(1 << UDF_FLAG_STRICT);\n\t\t\tbreak;\n\t\tcase Opt_session:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->session = option;\n\t\t\tif (!remount)\n\t\t\t\tuopt->flags |= (1 << UDF_FLAG_SESSION_SET);\n\t\t\tbreak;\n\t\tcase Opt_lastblock:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->lastblock = option;\n\t\t\tif (!remount)\n\t\t\t\tuopt->flags |= (1 << UDF_FLAG_LASTBLOCK_SET);\n\t\t\tbreak;\n\t\tcase Opt_anchor:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->anchor = option;\n\t\t\tbreak;\n\t\tcase Opt_volume:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->volume = option;\n\t\t\tbreak;\n\t\tcase Opt_partition:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->partition = option;\n\t\t\tbreak;\n\t\tcase Opt_fileset:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->fileset = option;\n\t\t\tbreak;\n\t\tcase Opt_rootdir:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->rootdir = option;\n\t\t\tbreak;\n\t\tcase Opt_utf8:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UTF8);\n\t\t\tbreak;\n#ifdef CONFIG_UDF_NLS\n\t\tcase Opt_iocharset:\n\t\t\tuopt->nls_map = load_nls(args[0].from);\n\t\t\tuopt->flags |= (1 << UDF_FLAG_NLS_MAP);\n\t\t\tbreak;\n#endif\n\t\tcase Opt_uignore:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UID_IGNORE);\n\t\t\tbreak;\n\t\tcase Opt_uforget:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UID_FORGET);\n\t\t\tbreak;\n\t\tcase Opt_gignore:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_GID_IGNORE);\n\t\t\tbreak;\n\t\tcase Opt_gforget:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_GID_FORGET);\n\t\t\tbreak;\n\t\tcase Opt_fmode:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->fmode = option & 0777;\n\t\t\tbreak;\n\t\tcase Opt_dmode:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->dmode = option & 0777;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"bad mount option \\\"%s\\\" or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_novrs,\t\"novrs\"},\n\t{Opt_nostrict,\t\"nostrict\"},\n\t{Opt_bs,\t\"bs=%u\"},\n\t{Opt_unhide,\t\"unhide\"},\n\t{Opt_undelete,\t\"undelete\"},\n\t{Opt_noadinicb,\t\"noadinicb\"},\n\t{Opt_adinicb,\t\"adinicb\"},\n\t{Opt_shortad,\t\"shortad\"},\n\t{Opt_longad,\t\"longad\"},\n\t{Opt_uforget,\t\"uid=forget\"},\n\t{Opt_uignore,\t\"uid=ignore\"},\n\t{Opt_gforget,\t\"gid=forget\"},\n\t{Opt_gignore,\t\"gid=ignore\"},\n\t{Opt_gid,\t\"gid=%u\"},\n\t{Opt_uid,\t\"uid=%u\"},\n\t{Opt_umask,\t\"umask=%o\"},\n\t{Opt_session,\t\"session=%u\"},\n\t{Opt_lastblock,\t\"lastblock=%u\"},\n\t{Opt_anchor,\t\"anchor=%u\"},\n\t{Opt_volume,\t\"volume=%u\"},\n\t{Opt_partition,\t\"partition=%u\"},\n\t{Opt_fileset,\t\"fileset=%u\"},\n\t{Opt_rootdir,\t\"rootdir=%u\"},\n\t{Opt_utf8,\t\"utf8\"},\n\t{Opt_iocharset,\t\"iocharset=%s\"},\n\t{Opt_fmode,     \"mode=%o\"},\n\t{Opt_dmode,     \"dmode=%o\"},\n\t{Opt_err,\tNULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic const match_table_t tokens = {\n\t{Opt_novrs,\t\"novrs\"},\n\t{Opt_nostrict,\t\"nostrict\"},\n\t{Opt_bs,\t\"bs=%u\"},\n\t{Opt_unhide,\t\"unhide\"},\n\t{Opt_undelete,\t\"undelete\"},\n\t{Opt_noadinicb,\t\"noadinicb\"},\n\t{Opt_adinicb,\t\"adinicb\"},\n\t{Opt_shortad,\t\"shortad\"},\n\t{Opt_longad,\t\"longad\"},\n\t{Opt_uforget,\t\"uid=forget\"},\n\t{Opt_uignore,\t\"uid=ignore\"},\n\t{Opt_gforget,\t\"gid=forget\"},\n\t{Opt_gignore,\t\"gid=ignore\"},\n\t{Opt_gid,\t\"gid=%u\"},\n\t{Opt_uid,\t\"uid=%u\"},\n\t{Opt_umask,\t\"umask=%o\"},\n\t{Opt_session,\t\"session=%u\"},\n\t{Opt_lastblock,\t\"lastblock=%u\"},\n\t{Opt_anchor,\t\"anchor=%u\"},\n\t{Opt_volume,\t\"volume=%u\"},\n\t{Opt_partition,\t\"partition=%u\"},\n\t{Opt_fileset,\t\"fileset=%u\"},\n\t{Opt_rootdir,\t\"rootdir=%u\"},\n\t{Opt_utf8,\t\"utf8\"},\n\t{Opt_iocharset,\t\"iocharset=%s\"},\n\t{Opt_fmode,     \"mode=%o\"},\n\t{Opt_dmode,     \"dmode=%o\"},\n\t{Opt_err,\tNULL}\n};\n\nstatic int udf_parse_options(char *options, struct udf_options *uopt,\n\t\t\t     bool remount)\n{\n\tchar *p;\n\tint option;\n\n\tuopt->novrs = 0;\n\tuopt->partition = 0xFFFF;\n\tuopt->session = 0xFFFFFFFF;\n\tuopt->lastblock = 0;\n\tuopt->anchor = 0;\n\tuopt->volume = 0xFFFFFFFF;\n\tuopt->rootdir = 0xFFFFFFFF;\n\tuopt->fileset = 0xFFFFFFFF;\n\tuopt->nls_map = NULL;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tunsigned n;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_novrs:\n\t\t\tuopt->novrs = 1;\n\t\t\tbreak;\n\t\tcase Opt_bs:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tn = option;\n\t\t\tif (n != 512 && n != 1024 && n != 2048 && n != 4096)\n\t\t\t\treturn 0;\n\t\t\tuopt->blocksize = n;\n\t\t\tuopt->flags |= (1 << UDF_FLAG_BLOCKSIZE_SET);\n\t\t\tbreak;\n\t\tcase Opt_unhide:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UNHIDE);\n\t\t\tbreak;\n\t\tcase Opt_undelete:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UNDELETE);\n\t\t\tbreak;\n\t\tcase Opt_noadinicb:\n\t\t\tuopt->flags &= ~(1 << UDF_FLAG_USE_AD_IN_ICB);\n\t\t\tbreak;\n\t\tcase Opt_adinicb:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_USE_AD_IN_ICB);\n\t\t\tbreak;\n\t\tcase Opt_shortad:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_USE_SHORT_AD);\n\t\t\tbreak;\n\t\tcase Opt_longad:\n\t\t\tuopt->flags &= ~(1 << UDF_FLAG_USE_SHORT_AD);\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(uopt->gid))\n\t\t\t\treturn 0;\n\t\t\tuopt->flags |= (1 << UDF_FLAG_GID_SET);\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uopt->uid))\n\t\t\t\treturn 0;\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UID_SET);\n\t\t\tbreak;\n\t\tcase Opt_umask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->umask = option;\n\t\t\tbreak;\n\t\tcase Opt_nostrict:\n\t\t\tuopt->flags &= ~(1 << UDF_FLAG_STRICT);\n\t\t\tbreak;\n\t\tcase Opt_session:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->session = option;\n\t\t\tif (!remount)\n\t\t\t\tuopt->flags |= (1 << UDF_FLAG_SESSION_SET);\n\t\t\tbreak;\n\t\tcase Opt_lastblock:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->lastblock = option;\n\t\t\tif (!remount)\n\t\t\t\tuopt->flags |= (1 << UDF_FLAG_LASTBLOCK_SET);\n\t\t\tbreak;\n\t\tcase Opt_anchor:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->anchor = option;\n\t\t\tbreak;\n\t\tcase Opt_volume:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->volume = option;\n\t\t\tbreak;\n\t\tcase Opt_partition:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->partition = option;\n\t\t\tbreak;\n\t\tcase Opt_fileset:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->fileset = option;\n\t\t\tbreak;\n\t\tcase Opt_rootdir:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->rootdir = option;\n\t\t\tbreak;\n\t\tcase Opt_utf8:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UTF8);\n\t\t\tbreak;\n#ifdef CONFIG_UDF_NLS\n\t\tcase Opt_iocharset:\n\t\t\tuopt->nls_map = load_nls(args[0].from);\n\t\t\tuopt->flags |= (1 << UDF_FLAG_NLS_MAP);\n\t\t\tbreak;\n#endif\n\t\tcase Opt_uignore:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UID_IGNORE);\n\t\t\tbreak;\n\t\tcase Opt_uforget:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UID_FORGET);\n\t\t\tbreak;\n\t\tcase Opt_gignore:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_GID_IGNORE);\n\t\t\tbreak;\n\t\tcase Opt_gforget:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_GID_FORGET);\n\t\t\tbreak;\n\t\tcase Opt_fmode:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->fmode = option & 0777;\n\t\t\tbreak;\n\t\tcase Opt_dmode:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->dmode = option & 0777;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"bad mount option \\\"%s\\\" or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "lvidiu->minUDFWriteRev"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_sb_lvidiu",
          "args": [
            "sb"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "udf_sb_lvidiu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "100-120",
          "snippet": "struct logicalVolIntegrityDescImpUse *udf_sb_lvidiu(struct super_block *sb)\n{\n\tstruct logicalVolIntegrityDesc *lvid;\n\tunsigned int partnum;\n\tunsigned int offset;\n\n\tif (!UDF_SB(sb)->s_lvid_bh)\n\t\treturn NULL;\n\tlvid = (struct logicalVolIntegrityDesc *)UDF_SB(sb)->s_lvid_bh->b_data;\n\tpartnum = le32_to_cpu(lvid->numOfPartitions);\n\tif ((sb->s_blocksize - sizeof(struct logicalVolIntegrityDescImpUse) -\n\t     offsetof(struct logicalVolIntegrityDesc, impUse)) /\n\t     (2 * sizeof(uint32_t)) < partnum) {\n\t\tudf_err(sb, \"Logical volume integrity descriptor corrupted \"\n\t\t\t\"(numOfPartitions = %u)!\\n\", partnum);\n\t\treturn NULL;\n\t}\n\t/* The offset is to skip freeSpaceTable and sizeTable arrays */\n\toffset = partnum * 2 * sizeof(uint32_t);\n\treturn (struct logicalVolIntegrityDescImpUse *)&(lvid->impUse[offset]);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstruct logicalVolIntegrityDescImpUse *udf_sb_lvidiu(struct super_block *sb)\n{\n\tstruct logicalVolIntegrityDesc *lvid;\n\tunsigned int partnum;\n\tunsigned int offset;\n\n\tif (!UDF_SB(sb)->s_lvid_bh)\n\t\treturn NULL;\n\tlvid = (struct logicalVolIntegrityDesc *)UDF_SB(sb)->s_lvid_bh->b_data;\n\tpartnum = le32_to_cpu(lvid->numOfPartitions);\n\tif ((sb->s_blocksize - sizeof(struct logicalVolIntegrityDescImpUse) -\n\t     offsetof(struct logicalVolIntegrityDesc, impUse)) /\n\t     (2 * sizeof(uint32_t)) < partnum) {\n\t\tudf_err(sb, \"Logical volume integrity descriptor corrupted \"\n\t\t\t\"(numOfPartitions = %u)!\\n\", partnum);\n\t\treturn NULL;\n\t}\n\t/* The offset is to skip freeSpaceTable and sizeTable arrays */\n\toffset = partnum * 2 * sizeof(uint32_t);\n\treturn (struct logicalVolIntegrityDescImpUse *)&(lvid->impUse[offset]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic int udf_remount_fs(struct super_block *sb, int *flags, char *options)\n{\n\tstruct udf_options uopt;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint error = 0;\n\tstruct logicalVolIntegrityDescImpUse *lvidiu = udf_sb_lvidiu(sb);\n\n\tsync_filesystem(sb);\n\tif (lvidiu) {\n\t\tint write_rev = le16_to_cpu(lvidiu->minUDFWriteRev);\n\t\tif (write_rev > UDF_MAX_WRITE_VERSION && !(*flags & MS_RDONLY))\n\t\t\treturn -EACCES;\n\t}\n\n\tuopt.flags = sbi->s_flags;\n\tuopt.uid   = sbi->s_uid;\n\tuopt.gid   = sbi->s_gid;\n\tuopt.umask = sbi->s_umask;\n\tuopt.fmode = sbi->s_fmode;\n\tuopt.dmode = sbi->s_dmode;\n\n\tif (!udf_parse_options(options, &uopt, true))\n\t\treturn -EINVAL;\n\n\twrite_lock(&sbi->s_cred_lock);\n\tsbi->s_flags = uopt.flags;\n\tsbi->s_uid   = uopt.uid;\n\tsbi->s_gid   = uopt.gid;\n\tsbi->s_umask = uopt.umask;\n\tsbi->s_fmode = uopt.fmode;\n\tsbi->s_dmode = uopt.dmode;\n\twrite_unlock(&sbi->s_cred_lock);\n\n\tif ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))\n\t\tgoto out_unlock;\n\n\tif (*flags & MS_RDONLY)\n\t\tudf_close_lvid(sb);\n\telse\n\t\tudf_open_lvid(sb);\n\nout_unlock:\n\treturn error;\n}"
  },
  {
    "function_name": "udf_parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "486-644",
    "snippet": "static int udf_parse_options(char *options, struct udf_options *uopt,\n\t\t\t     bool remount)\n{\n\tchar *p;\n\tint option;\n\n\tuopt->novrs = 0;\n\tuopt->partition = 0xFFFF;\n\tuopt->session = 0xFFFFFFFF;\n\tuopt->lastblock = 0;\n\tuopt->anchor = 0;\n\tuopt->volume = 0xFFFFFFFF;\n\tuopt->rootdir = 0xFFFFFFFF;\n\tuopt->fileset = 0xFFFFFFFF;\n\tuopt->nls_map = NULL;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tunsigned n;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_novrs:\n\t\t\tuopt->novrs = 1;\n\t\t\tbreak;\n\t\tcase Opt_bs:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tn = option;\n\t\t\tif (n != 512 && n != 1024 && n != 2048 && n != 4096)\n\t\t\t\treturn 0;\n\t\t\tuopt->blocksize = n;\n\t\t\tuopt->flags |= (1 << UDF_FLAG_BLOCKSIZE_SET);\n\t\t\tbreak;\n\t\tcase Opt_unhide:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UNHIDE);\n\t\t\tbreak;\n\t\tcase Opt_undelete:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UNDELETE);\n\t\t\tbreak;\n\t\tcase Opt_noadinicb:\n\t\t\tuopt->flags &= ~(1 << UDF_FLAG_USE_AD_IN_ICB);\n\t\t\tbreak;\n\t\tcase Opt_adinicb:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_USE_AD_IN_ICB);\n\t\t\tbreak;\n\t\tcase Opt_shortad:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_USE_SHORT_AD);\n\t\t\tbreak;\n\t\tcase Opt_longad:\n\t\t\tuopt->flags &= ~(1 << UDF_FLAG_USE_SHORT_AD);\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(uopt->gid))\n\t\t\t\treturn 0;\n\t\t\tuopt->flags |= (1 << UDF_FLAG_GID_SET);\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uopt->uid))\n\t\t\t\treturn 0;\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UID_SET);\n\t\t\tbreak;\n\t\tcase Opt_umask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->umask = option;\n\t\t\tbreak;\n\t\tcase Opt_nostrict:\n\t\t\tuopt->flags &= ~(1 << UDF_FLAG_STRICT);\n\t\t\tbreak;\n\t\tcase Opt_session:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->session = option;\n\t\t\tif (!remount)\n\t\t\t\tuopt->flags |= (1 << UDF_FLAG_SESSION_SET);\n\t\t\tbreak;\n\t\tcase Opt_lastblock:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->lastblock = option;\n\t\t\tif (!remount)\n\t\t\t\tuopt->flags |= (1 << UDF_FLAG_LASTBLOCK_SET);\n\t\t\tbreak;\n\t\tcase Opt_anchor:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->anchor = option;\n\t\t\tbreak;\n\t\tcase Opt_volume:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->volume = option;\n\t\t\tbreak;\n\t\tcase Opt_partition:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->partition = option;\n\t\t\tbreak;\n\t\tcase Opt_fileset:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->fileset = option;\n\t\t\tbreak;\n\t\tcase Opt_rootdir:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->rootdir = option;\n\t\t\tbreak;\n\t\tcase Opt_utf8:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UTF8);\n\t\t\tbreak;\n#ifdef CONFIG_UDF_NLS\n\t\tcase Opt_iocharset:\n\t\t\tuopt->nls_map = load_nls(args[0].from);\n\t\t\tuopt->flags |= (1 << UDF_FLAG_NLS_MAP);\n\t\t\tbreak;\n#endif\n\t\tcase Opt_uignore:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UID_IGNORE);\n\t\t\tbreak;\n\t\tcase Opt_uforget:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UID_FORGET);\n\t\t\tbreak;\n\t\tcase Opt_gignore:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_GID_IGNORE);\n\t\t\tbreak;\n\t\tcase Opt_gforget:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_GID_FORGET);\n\t\t\tbreak;\n\t\tcase Opt_fmode:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->fmode = option & 0777;\n\t\t\tbreak;\n\t\tcase Opt_dmode:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->dmode = option & 0777;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"bad mount option \\\"%s\\\" or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t tokens = {\n\t{Opt_novrs,\t\"novrs\"},\n\t{Opt_nostrict,\t\"nostrict\"},\n\t{Opt_bs,\t\"bs=%u\"},\n\t{Opt_unhide,\t\"unhide\"},\n\t{Opt_undelete,\t\"undelete\"},\n\t{Opt_noadinicb,\t\"noadinicb\"},\n\t{Opt_adinicb,\t\"adinicb\"},\n\t{Opt_shortad,\t\"shortad\"},\n\t{Opt_longad,\t\"longad\"},\n\t{Opt_uforget,\t\"uid=forget\"},\n\t{Opt_uignore,\t\"uid=ignore\"},\n\t{Opt_gforget,\t\"gid=forget\"},\n\t{Opt_gignore,\t\"gid=ignore\"},\n\t{Opt_gid,\t\"gid=%u\"},\n\t{Opt_uid,\t\"uid=%u\"},\n\t{Opt_umask,\t\"umask=%o\"},\n\t{Opt_session,\t\"session=%u\"},\n\t{Opt_lastblock,\t\"lastblock=%u\"},\n\t{Opt_anchor,\t\"anchor=%u\"},\n\t{Opt_volume,\t\"volume=%u\"},\n\t{Opt_partition,\t\"partition=%u\"},\n\t{Opt_fileset,\t\"fileset=%u\"},\n\t{Opt_rootdir,\t\"rootdir=%u\"},\n\t{Opt_utf8,\t\"utf8\"},\n\t{Opt_iocharset,\t\"iocharset=%s\"},\n\t{Opt_fmode,     \"mode=%o\"},\n\t{Opt_dmode,     \"dmode=%o\"},\n\t{Opt_err,\tNULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"bad mount option \\\"%s\\\" or missing value\\n\"",
            "p"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_octal",
          "args": [
            "args",
            "&option"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_octal",
          "args": [
            "args",
            "&option"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_nls",
          "args": [
            "args[0].from"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "unload_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "296-300",
          "snippet": "void unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "args",
            "&option"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "args",
            "&option"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "args",
            "&option"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "args",
            "&option"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "args",
            "&option"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "args",
            "&option"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "args",
            "&option"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_octal",
          "args": [
            "args",
            "&option"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "uopt->uid"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "args",
            "&option"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "uopt->gid"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "args",
            "&option"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic const match_table_t tokens = {\n\t{Opt_novrs,\t\"novrs\"},\n\t{Opt_nostrict,\t\"nostrict\"},\n\t{Opt_bs,\t\"bs=%u\"},\n\t{Opt_unhide,\t\"unhide\"},\n\t{Opt_undelete,\t\"undelete\"},\n\t{Opt_noadinicb,\t\"noadinicb\"},\n\t{Opt_adinicb,\t\"adinicb\"},\n\t{Opt_shortad,\t\"shortad\"},\n\t{Opt_longad,\t\"longad\"},\n\t{Opt_uforget,\t\"uid=forget\"},\n\t{Opt_uignore,\t\"uid=ignore\"},\n\t{Opt_gforget,\t\"gid=forget\"},\n\t{Opt_gignore,\t\"gid=ignore\"},\n\t{Opt_gid,\t\"gid=%u\"},\n\t{Opt_uid,\t\"uid=%u\"},\n\t{Opt_umask,\t\"umask=%o\"},\n\t{Opt_session,\t\"session=%u\"},\n\t{Opt_lastblock,\t\"lastblock=%u\"},\n\t{Opt_anchor,\t\"anchor=%u\"},\n\t{Opt_volume,\t\"volume=%u\"},\n\t{Opt_partition,\t\"partition=%u\"},\n\t{Opt_fileset,\t\"fileset=%u\"},\n\t{Opt_rootdir,\t\"rootdir=%u\"},\n\t{Opt_utf8,\t\"utf8\"},\n\t{Opt_iocharset,\t\"iocharset=%s\"},\n\t{Opt_fmode,     \"mode=%o\"},\n\t{Opt_dmode,     \"dmode=%o\"},\n\t{Opt_err,\tNULL}\n};\n\nstatic int udf_parse_options(char *options, struct udf_options *uopt,\n\t\t\t     bool remount)\n{\n\tchar *p;\n\tint option;\n\n\tuopt->novrs = 0;\n\tuopt->partition = 0xFFFF;\n\tuopt->session = 0xFFFFFFFF;\n\tuopt->lastblock = 0;\n\tuopt->anchor = 0;\n\tuopt->volume = 0xFFFFFFFF;\n\tuopt->rootdir = 0xFFFFFFFF;\n\tuopt->fileset = 0xFFFFFFFF;\n\tuopt->nls_map = NULL;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tunsigned n;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_novrs:\n\t\t\tuopt->novrs = 1;\n\t\t\tbreak;\n\t\tcase Opt_bs:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tn = option;\n\t\t\tif (n != 512 && n != 1024 && n != 2048 && n != 4096)\n\t\t\t\treturn 0;\n\t\t\tuopt->blocksize = n;\n\t\t\tuopt->flags |= (1 << UDF_FLAG_BLOCKSIZE_SET);\n\t\t\tbreak;\n\t\tcase Opt_unhide:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UNHIDE);\n\t\t\tbreak;\n\t\tcase Opt_undelete:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UNDELETE);\n\t\t\tbreak;\n\t\tcase Opt_noadinicb:\n\t\t\tuopt->flags &= ~(1 << UDF_FLAG_USE_AD_IN_ICB);\n\t\t\tbreak;\n\t\tcase Opt_adinicb:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_USE_AD_IN_ICB);\n\t\t\tbreak;\n\t\tcase Opt_shortad:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_USE_SHORT_AD);\n\t\t\tbreak;\n\t\tcase Opt_longad:\n\t\t\tuopt->flags &= ~(1 << UDF_FLAG_USE_SHORT_AD);\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(uopt->gid))\n\t\t\t\treturn 0;\n\t\t\tuopt->flags |= (1 << UDF_FLAG_GID_SET);\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uopt->uid))\n\t\t\t\treturn 0;\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UID_SET);\n\t\t\tbreak;\n\t\tcase Opt_umask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->umask = option;\n\t\t\tbreak;\n\t\tcase Opt_nostrict:\n\t\t\tuopt->flags &= ~(1 << UDF_FLAG_STRICT);\n\t\t\tbreak;\n\t\tcase Opt_session:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->session = option;\n\t\t\tif (!remount)\n\t\t\t\tuopt->flags |= (1 << UDF_FLAG_SESSION_SET);\n\t\t\tbreak;\n\t\tcase Opt_lastblock:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->lastblock = option;\n\t\t\tif (!remount)\n\t\t\t\tuopt->flags |= (1 << UDF_FLAG_LASTBLOCK_SET);\n\t\t\tbreak;\n\t\tcase Opt_anchor:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->anchor = option;\n\t\t\tbreak;\n\t\tcase Opt_volume:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->volume = option;\n\t\t\tbreak;\n\t\tcase Opt_partition:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->partition = option;\n\t\t\tbreak;\n\t\tcase Opt_fileset:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->fileset = option;\n\t\t\tbreak;\n\t\tcase Opt_rootdir:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->rootdir = option;\n\t\t\tbreak;\n\t\tcase Opt_utf8:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UTF8);\n\t\t\tbreak;\n#ifdef CONFIG_UDF_NLS\n\t\tcase Opt_iocharset:\n\t\t\tuopt->nls_map = load_nls(args[0].from);\n\t\t\tuopt->flags |= (1 << UDF_FLAG_NLS_MAP);\n\t\t\tbreak;\n#endif\n\t\tcase Opt_uignore:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UID_IGNORE);\n\t\t\tbreak;\n\t\tcase Opt_uforget:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_UID_FORGET);\n\t\t\tbreak;\n\t\tcase Opt_gignore:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_GID_IGNORE);\n\t\t\tbreak;\n\t\tcase Opt_gforget:\n\t\t\tuopt->flags |= (1 << UDF_FLAG_GID_FORGET);\n\t\t\tbreak;\n\t\tcase Opt_fmode:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->fmode = option & 0777;\n\t\t\tbreak;\n\t\tcase Opt_dmode:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn 0;\n\t\t\tuopt->dmode = option & 0777;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"bad mount option \\\"%s\\\" or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "udf_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "336-387",
    "snippet": "static int udf_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct super_block *sb = root->d_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\n\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_STRICT))\n\t\tseq_puts(seq, \",nostrict\");\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_BLOCKSIZE_SET))\n\t\tseq_printf(seq, \",bs=%lu\", sb->s_blocksize);\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UNHIDE))\n\t\tseq_puts(seq, \",unhide\");\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UNDELETE))\n\t\tseq_puts(seq, \",undelete\");\n\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_USE_AD_IN_ICB))\n\t\tseq_puts(seq, \",noadinicb\");\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_USE_SHORT_AD))\n\t\tseq_puts(seq, \",shortad\");\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UID_FORGET))\n\t\tseq_puts(seq, \",uid=forget\");\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UID_IGNORE))\n\t\tseq_puts(seq, \",uid=ignore\");\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_GID_FORGET))\n\t\tseq_puts(seq, \",gid=forget\");\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_GID_IGNORE))\n\t\tseq_puts(seq, \",gid=ignore\");\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UID_SET))\n\t\tseq_printf(seq, \",uid=%u\", from_kuid(&init_user_ns, sbi->s_uid));\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_GID_SET))\n\t\tseq_printf(seq, \",gid=%u\", from_kgid(&init_user_ns, sbi->s_gid));\n\tif (sbi->s_umask != 0)\n\t\tseq_printf(seq, \",umask=%ho\", sbi->s_umask);\n\tif (sbi->s_fmode != UDF_INVALID_MODE)\n\t\tseq_printf(seq, \",mode=%ho\", sbi->s_fmode);\n\tif (sbi->s_dmode != UDF_INVALID_MODE)\n\t\tseq_printf(seq, \",dmode=%ho\", sbi->s_dmode);\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_SESSION_SET))\n\t\tseq_printf(seq, \",session=%u\", sbi->s_session);\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_LASTBLOCK_SET))\n\t\tseq_printf(seq, \",lastblock=%u\", sbi->s_last_block);\n\tif (sbi->s_anchor != 0)\n\t\tseq_printf(seq, \",anchor=%u\", sbi->s_anchor);\n\t/*\n\t * volume, partition, fileset and rootdir seem to be ignored\n\t * currently\n\t */\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8))\n\t\tseq_puts(seq, \",utf8\");\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP) && sbi->s_nls_map)\n\t\tseq_printf(seq, \",iocharset=%s\", sbi->s_nls_map->charset);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);",
      "static int udf_show_options(struct seq_file *, struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\",iocharset=%s\"",
            "sbi->s_nls_map->charset"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_QUERY_FLAG",
          "args": [
            "sb",
            "UDF_FLAG_NLS_MAP"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_QUERY_FLAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "169-172",
          "snippet": "static inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\",utf8\""
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "sbi->s_gid"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "sbi->s_uid"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\nstatic int udf_show_options(struct seq_file *, struct dentry *);\n\nstatic int udf_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct super_block *sb = root->d_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\n\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_STRICT))\n\t\tseq_puts(seq, \",nostrict\");\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_BLOCKSIZE_SET))\n\t\tseq_printf(seq, \",bs=%lu\", sb->s_blocksize);\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UNHIDE))\n\t\tseq_puts(seq, \",unhide\");\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UNDELETE))\n\t\tseq_puts(seq, \",undelete\");\n\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_USE_AD_IN_ICB))\n\t\tseq_puts(seq, \",noadinicb\");\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_USE_SHORT_AD))\n\t\tseq_puts(seq, \",shortad\");\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UID_FORGET))\n\t\tseq_puts(seq, \",uid=forget\");\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UID_IGNORE))\n\t\tseq_puts(seq, \",uid=ignore\");\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_GID_FORGET))\n\t\tseq_puts(seq, \",gid=forget\");\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_GID_IGNORE))\n\t\tseq_puts(seq, \",gid=ignore\");\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UID_SET))\n\t\tseq_printf(seq, \",uid=%u\", from_kuid(&init_user_ns, sbi->s_uid));\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_GID_SET))\n\t\tseq_printf(seq, \",gid=%u\", from_kgid(&init_user_ns, sbi->s_gid));\n\tif (sbi->s_umask != 0)\n\t\tseq_printf(seq, \",umask=%ho\", sbi->s_umask);\n\tif (sbi->s_fmode != UDF_INVALID_MODE)\n\t\tseq_printf(seq, \",mode=%ho\", sbi->s_fmode);\n\tif (sbi->s_dmode != UDF_INVALID_MODE)\n\t\tseq_printf(seq, \",dmode=%ho\", sbi->s_dmode);\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_SESSION_SET))\n\t\tseq_printf(seq, \",session=%u\", sbi->s_session);\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_LASTBLOCK_SET))\n\t\tseq_printf(seq, \",lastblock=%u\", sbi->s_last_block);\n\tif (sbi->s_anchor != 0)\n\t\tseq_printf(seq, \",anchor=%u\", sbi->s_anchor);\n\t/*\n\t * volume, partition, fileset and rootdir seem to be ignored\n\t * currently\n\t */\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8))\n\t\tseq_puts(seq, \",utf8\");\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP) && sbi->s_nls_map)\n\t\tseq_printf(seq, \",iocharset=%s\", sbi->s_nls_map->charset);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "udf_sb_free_partitions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "324-334",
    "snippet": "static void udf_sb_free_partitions(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint i;\n\tif (sbi->s_partmaps == NULL)\n\t\treturn;\n\tfor (i = 0; i < sbi->s_partitions; i++)\n\t\tudf_free_partition(&sbi->s_partmaps[i]);\n\tkfree(sbi->s_partmaps);\n\tsbi->s_partmaps = NULL;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_partmaps"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_free_partition",
          "args": [
            "&sbi->s_partmaps[i]"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "udf_free_partition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "295-322",
          "snippet": "static void udf_free_partition(struct udf_part_map *map)\n{\n\tint i;\n\tstruct udf_meta_data *mdata;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE)\n\t\tiput(map->s_uspace.s_table);\n\tif (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE)\n\t\tiput(map->s_fspace.s_table);\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP)\n\t\tudf_sb_free_bitmap(map->s_uspace.s_bitmap);\n\tif (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP)\n\t\tudf_sb_free_bitmap(map->s_fspace.s_bitmap);\n\tif (map->s_partition_type == UDF_SPARABLE_MAP15)\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tbrelse(map->s_type_specific.s_sparing.s_spar_map[i]);\n\telse if (map->s_partition_type == UDF_METADATA_MAP25) {\n\t\tmdata = &map->s_type_specific.s_metadata;\n\t\tiput(mdata->s_metadata_fe);\n\t\tmdata->s_metadata_fe = NULL;\n\n\t\tiput(mdata->s_mirror_fe);\n\t\tmdata->s_mirror_fe = NULL;\n\n\t\tiput(mdata->s_bitmap_fe);\n\t\tmdata->s_bitmap_fe = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic void udf_free_partition(struct udf_part_map *map)\n{\n\tint i;\n\tstruct udf_meta_data *mdata;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE)\n\t\tiput(map->s_uspace.s_table);\n\tif (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE)\n\t\tiput(map->s_fspace.s_table);\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP)\n\t\tudf_sb_free_bitmap(map->s_uspace.s_bitmap);\n\tif (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP)\n\t\tudf_sb_free_bitmap(map->s_fspace.s_bitmap);\n\tif (map->s_partition_type == UDF_SPARABLE_MAP15)\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tbrelse(map->s_type_specific.s_sparing.s_spar_map[i]);\n\telse if (map->s_partition_type == UDF_METADATA_MAP25) {\n\t\tmdata = &map->s_type_specific.s_metadata;\n\t\tiput(mdata->s_metadata_fe);\n\t\tmdata->s_metadata_fe = NULL;\n\n\t\tiput(mdata->s_mirror_fe);\n\t\tmdata->s_mirror_fe = NULL;\n\n\t\tiput(mdata->s_bitmap_fe);\n\t\tmdata->s_bitmap_fe = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstatic void udf_sb_free_partitions(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint i;\n\tif (sbi->s_partmaps == NULL)\n\t\treturn;\n\tfor (i = 0; i < sbi->s_partitions; i++)\n\t\tudf_free_partition(&sbi->s_partmaps[i]);\n\tkfree(sbi->s_partmaps);\n\tsbi->s_partmaps = NULL;\n}"
  },
  {
    "function_name": "udf_free_partition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "295-322",
    "snippet": "static void udf_free_partition(struct udf_part_map *map)\n{\n\tint i;\n\tstruct udf_meta_data *mdata;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE)\n\t\tiput(map->s_uspace.s_table);\n\tif (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE)\n\t\tiput(map->s_fspace.s_table);\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP)\n\t\tudf_sb_free_bitmap(map->s_uspace.s_bitmap);\n\tif (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP)\n\t\tudf_sb_free_bitmap(map->s_fspace.s_bitmap);\n\tif (map->s_partition_type == UDF_SPARABLE_MAP15)\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tbrelse(map->s_type_specific.s_sparing.s_spar_map[i]);\n\telse if (map->s_partition_type == UDF_METADATA_MAP25) {\n\t\tmdata = &map->s_type_specific.s_metadata;\n\t\tiput(mdata->s_metadata_fe);\n\t\tmdata->s_metadata_fe = NULL;\n\n\t\tiput(mdata->s_mirror_fe);\n\t\tmdata->s_mirror_fe = NULL;\n\n\t\tiput(mdata->s_bitmap_fe);\n\t\tmdata->s_bitmap_fe = NULL;\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "mdata->s_bitmap_fe"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "map->s_type_specific.s_sparing.s_spar_map[i]"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_sb_free_bitmap",
          "args": [
            "map->s_fspace.s_bitmap"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "udf_sb_free_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "278-293",
          "snippet": "static void udf_sb_free_bitmap(struct udf_bitmap *bitmap)\n{\n\tint i;\n\tint nr_groups = bitmap->s_nr_groups;\n\tint size = sizeof(struct udf_bitmap) + (sizeof(struct buffer_head *) *\n\t\t\t\t\t\tnr_groups);\n\n\tfor (i = 0; i < nr_groups; i++)\n\t\tif (bitmap->s_block_bitmap[i])\n\t\t\tbrelse(bitmap->s_block_bitmap[i]);\n\n\tif (size <= PAGE_SIZE)\n\t\tkfree(bitmap);\n\telse\n\t\tvfree(bitmap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic void udf_sb_free_bitmap(struct udf_bitmap *bitmap)\n{\n\tint i;\n\tint nr_groups = bitmap->s_nr_groups;\n\tint size = sizeof(struct udf_bitmap) + (sizeof(struct buffer_head *) *\n\t\t\t\t\t\tnr_groups);\n\n\tfor (i = 0; i < nr_groups; i++)\n\t\tif (bitmap->s_block_bitmap[i])\n\t\t\tbrelse(bitmap->s_block_bitmap[i]);\n\n\tif (size <= PAGE_SIZE)\n\t\tkfree(bitmap);\n\telse\n\t\tvfree(bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic void udf_free_partition(struct udf_part_map *map)\n{\n\tint i;\n\tstruct udf_meta_data *mdata;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE)\n\t\tiput(map->s_uspace.s_table);\n\tif (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE)\n\t\tiput(map->s_fspace.s_table);\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP)\n\t\tudf_sb_free_bitmap(map->s_uspace.s_bitmap);\n\tif (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP)\n\t\tudf_sb_free_bitmap(map->s_fspace.s_bitmap);\n\tif (map->s_partition_type == UDF_SPARABLE_MAP15)\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tbrelse(map->s_type_specific.s_sparing.s_spar_map[i]);\n\telse if (map->s_partition_type == UDF_METADATA_MAP25) {\n\t\tmdata = &map->s_type_specific.s_metadata;\n\t\tiput(mdata->s_metadata_fe);\n\t\tmdata->s_metadata_fe = NULL;\n\n\t\tiput(mdata->s_mirror_fe);\n\t\tmdata->s_mirror_fe = NULL;\n\n\t\tiput(mdata->s_bitmap_fe);\n\t\tmdata->s_bitmap_fe = NULL;\n\t}\n}"
  },
  {
    "function_name": "udf_sb_free_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "278-293",
    "snippet": "static void udf_sb_free_bitmap(struct udf_bitmap *bitmap)\n{\n\tint i;\n\tint nr_groups = bitmap->s_nr_groups;\n\tint size = sizeof(struct udf_bitmap) + (sizeof(struct buffer_head *) *\n\t\t\t\t\t\tnr_groups);\n\n\tfor (i = 0; i < nr_groups; i++)\n\t\tif (bitmap->s_block_bitmap[i])\n\t\t\tbrelse(bitmap->s_block_bitmap[i]);\n\n\tif (size <= PAGE_SIZE)\n\t\tkfree(bitmap);\n\telse\n\t\tvfree(bitmap);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "bitmap"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bitmap"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bitmap->s_block_bitmap[i]"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic void udf_sb_free_bitmap(struct udf_bitmap *bitmap)\n{\n\tint i;\n\tint nr_groups = bitmap->s_nr_groups;\n\tint size = sizeof(struct udf_bitmap) + (sizeof(struct buffer_head *) *\n\t\t\t\t\t\tnr_groups);\n\n\tfor (i = 0; i < nr_groups; i++)\n\t\tif (bitmap->s_block_bitmap[i])\n\t\t\tbrelse(bitmap->s_block_bitmap[i]);\n\n\tif (size <= PAGE_SIZE)\n\t\tkfree(bitmap);\n\telse\n\t\tvfree(bitmap);\n}"
  },
  {
    "function_name": "module_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "258-272",
    "snippet": "module_init(init_udf_fs)\nmodule_exit(exit_udf_fs)\n\nstatic int udf_sb_alloc_partition_maps(struct super_block *sb, u32 count)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\n\tsbi->s_partmaps = kcalloc(count, sizeof(struct udf_part_map),\n\t\t\t\t  GFP_KERNEL);\n\tif (!sbi->s_partmaps) {\n\t\tudf_err(sb, \"Unable to allocate space for %d partition maps\\n\",\n\t\t\tcount);\n\t\tsbi->s_partitions = 0;\n\t\treturn -ENOMEM;\n\t}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_err",
          "args": [
            "sb",
            "\"Unable to allocate space for %d partition maps\\n\"",
            "count"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "_udf_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "2256-2270",
          "snippet": "void _udf_err(struct super_block *sb, const char *function,\n\t      const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nvoid _udf_err(struct super_block *sb, const char *function,\n\t      const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "count",
            "sizeof(struct udf_part_map)",
            "GFP_KERNEL"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nmodule_init(init_udf_fs)\nmodule_exit(exit_udf_fs)\n\nstatic int udf_sb_alloc_partition_maps(struct super_block *sb, u32 count)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\n\tsbi->s_partmaps = kcalloc(count, sizeof(struct udf_part_map),\n\t\t\t\t  GFP_KERNEL);\n\tif (!sbi->s_partmaps) {\n\t\tudf_err(sb, \"Unable to allocate space for %d partition maps\\n\",\n\t\t\tcount);\n\t\tsbi->s_partitions = 0;\n\t\treturn -ENOMEM;\n\t}"
  },
  {
    "function_name": "exit_udf_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "252-256",
    "snippet": "static void __exit exit_udf_fs(void)\n{\n\tunregister_filesystem(&udf_fstype);\n\tdestroy_inodecache();\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type udf_fstype = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"udf\",\n\t.mount\t\t= udf_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "190-198",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(udf_inode_cachep);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *udf_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic struct kmem_cache *udf_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(udf_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&udf_fstype"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic struct file_system_type udf_fstype = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"udf\",\n\t.mount\t\t= udf_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic void __exit exit_udf_fs(void)\n{\n\tunregister_filesystem(&udf_fstype);\n\tdestroy_inodecache();\n}"
  },
  {
    "function_name": "init_udf_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "232-250",
    "snippet": "static int __init init_udf_fs(void)\n{\n\tint err;\n\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\terr = register_filesystem(&udf_fstype);\n\tif (err)\n\t\tgoto out;\n\n\treturn 0;\n\nout:\n\tdestroy_inodecache();\n\nout1:\n\treturn err;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type udf_fstype = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"udf\",\n\t.mount\t\t= udf_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "190-198",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(udf_inode_cachep);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *udf_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic struct kmem_cache *udf_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(udf_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&udf_fstype"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_inodecache",
          "args": [],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "init_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "178-188",
          "snippet": "static int __init init_inodecache(void)\n{\n\tudf_inode_cachep = kmem_cache_create(\"udf_inode_cache\",\n\t\t\t\t\t     sizeof(struct udf_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT |\n\t\t\t\t\t\t SLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (!udf_inode_cachep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *udf_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic struct kmem_cache *udf_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\tudf_inode_cachep = kmem_cache_create(\"udf_inode_cache\",\n\t\t\t\t\t     sizeof(struct udf_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT |\n\t\t\t\t\t\t SLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (!udf_inode_cachep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic struct file_system_type udf_fstype = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"udf\",\n\t.mount\t\t= udf_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic int __init init_udf_fs(void)\n{\n\tint err;\n\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\terr = register_filesystem(&udf_fstype);\n\tif (err)\n\t\tgoto out;\n\n\treturn 0;\n\nout:\n\tdestroy_inodecache();\n\nout1:\n\treturn err;\n}"
  },
  {
    "function_name": "destroy_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "190-198",
    "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(udf_inode_cachep);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *udf_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "udf_inode_cachep"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic struct kmem_cache *udf_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(udf_inode_cachep);\n}"
  },
  {
    "function_name": "init_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "178-188",
    "snippet": "static int __init init_inodecache(void)\n{\n\tudf_inode_cachep = kmem_cache_create(\"udf_inode_cache\",\n\t\t\t\t\t     sizeof(struct udf_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT |\n\t\t\t\t\t\t SLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (!udf_inode_cachep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *udf_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"udf_inode_cache\"",
            "sizeof(struct udf_inode_info)",
            "0",
            "(SLAB_RECLAIM_ACCOUNT |\n\t\t\t\t\t\t SLAB_MEM_SPREAD)",
            "init_once"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic struct kmem_cache *udf_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\tudf_inode_cachep = kmem_cache_create(\"udf_inode_cache\",\n\t\t\t\t\t     sizeof(struct udf_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT |\n\t\t\t\t\t\t SLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (!udf_inode_cachep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "170-176",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct udf_inode_info *ei = (struct udf_inode_info *)foo;\n\n\tei->i_ext.i_data = NULL;\n\tinode_init_once(&ei->vfs_inode);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&ei->vfs_inode"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1725-1755",
          "snippet": "static void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_remount(struct super_block *sb, int *flags, char *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\n\nstatic void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic void init_once(void *foo)\n{\n\tstruct udf_inode_info *ei = (struct udf_inode_info *)foo;\n\n\tei->i_ext.i_data = NULL;\n\tinode_init_once(&ei->vfs_inode);\n}"
  },
  {
    "function_name": "udf_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "165-168",
    "snippet": "static void udf_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, udf_i_callback);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "udf_i_callback"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic void udf_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, udf_i_callback);\n}"
  },
  {
    "function_name": "udf_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "159-163",
    "snippet": "static void udf_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(udf_inode_cachep, UDF_I(inode));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *udf_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "udf_inode_cachep",
            "UDF_I(inode)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic struct kmem_cache *udf_inode_cachep;\n\nstatic void udf_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(udf_inode_cachep, UDF_I(inode));\n}"
  },
  {
    "function_name": "udf_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "140-157",
    "snippet": "static struct inode *udf_alloc_inode(struct super_block *sb)\n{\n\tstruct udf_inode_info *ei;\n\tei = kmem_cache_alloc(udf_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\n\tei->i_unique = 0;\n\tei->i_lenExtents = 0;\n\tei->i_next_alloc_block = 0;\n\tei->i_next_alloc_goal = 0;\n\tei->i_strat4096 = 0;\n\tinit_rwsem(&ei->i_data_sem);\n\tei->cached_extent.lstart = -1;\n\tspin_lock_init(&ei->i_extent_cache_lock);\n\n\treturn &ei->vfs_inode;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);",
      "static struct kmem_cache *udf_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ei->i_extent_cache_lock"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&ei->i_data_sem"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "udf_inode_cachep",
            "GFP_KERNEL"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\nstatic struct kmem_cache *udf_inode_cachep;\n\nstatic struct inode *udf_alloc_inode(struct super_block *sb)\n{\n\tstruct udf_inode_info *ei;\n\tei = kmem_cache_alloc(udf_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\n\tei->i_unique = 0;\n\tei->i_lenExtents = 0;\n\tei->i_next_alloc_block = 0;\n\tei->i_next_alloc_goal = 0;\n\tei->i_strat4096 = 0;\n\tinit_rwsem(&ei->i_data_sem);\n\tei->cached_extent.lstart = -1;\n\tspin_lock_init(&ei->i_extent_cache_lock);\n\n\treturn &ei->vfs_inode;\n}"
  },
  {
    "function_name": "udf_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "123-127",
    "snippet": "static struct dentry *udf_mount(struct file_system_type *fs_type,\n\t\t      int flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, udf_fill_super);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_show_options(struct seq_file *, struct dentry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "udf_fill_super"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_show_options(struct seq_file *, struct dentry *);\n\nstatic struct dentry *udf_mount(struct file_system_type *fs_type,\n\t\t      int flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, udf_fill_super);\n}"
  },
  {
    "function_name": "udf_sb_lvidiu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
    "lines": "100-120",
    "snippet": "struct logicalVolIntegrityDescImpUse *udf_sb_lvidiu(struct super_block *sb)\n{\n\tstruct logicalVolIntegrityDesc *lvid;\n\tunsigned int partnum;\n\tunsigned int offset;\n\n\tif (!UDF_SB(sb)->s_lvid_bh)\n\t\treturn NULL;\n\tlvid = (struct logicalVolIntegrityDesc *)UDF_SB(sb)->s_lvid_bh->b_data;\n\tpartnum = le32_to_cpu(lvid->numOfPartitions);\n\tif ((sb->s_blocksize - sizeof(struct logicalVolIntegrityDescImpUse) -\n\t     offsetof(struct logicalVolIntegrityDesc, impUse)) /\n\t     (2 * sizeof(uint32_t)) < partnum) {\n\t\tudf_err(sb, \"Logical volume integrity descriptor corrupted \"\n\t\t\t\"(numOfPartitions = %u)!\\n\", partnum);\n\t\treturn NULL;\n\t}\n\t/* The offset is to skip freeSpaceTable and sizeTable arrays */\n\toffset = partnum * 2 * sizeof(uint32_t);\n\treturn (struct logicalVolIntegrityDescImpUse *)&(lvid->impUse[offset]);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/init.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/log2.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/errno.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/nls.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/stat.h>",
      "#include <linux/parser.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_fill_super(struct super_block *, void *, int);",
      "static void udf_put_super(struct super_block *);",
      "static int udf_sync_fs(struct super_block *, int);",
      "static int udf_remount_fs(struct super_block *, int *, char *);",
      "static void udf_open_lvid(struct super_block *);",
      "static void udf_close_lvid(struct super_block *);",
      "static unsigned int udf_count_free(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_err",
          "args": [
            "sb",
            "\"Logical volume integrity descriptor corrupted \"\n\t\t\t\"(numOfPartitions = %u)!\\n\"",
            "partnum"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "_udf_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "2256-2270",
          "snippet": "void _udf_err(struct super_block *sb, const char *function,\n\t      const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nvoid _udf_err(struct super_block *sb, const char *function,\n\t      const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "lvid->numOfPartitions"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstruct logicalVolIntegrityDescImpUse *udf_sb_lvidiu(struct super_block *sb)\n{\n\tstruct logicalVolIntegrityDesc *lvid;\n\tunsigned int partnum;\n\tunsigned int offset;\n\n\tif (!UDF_SB(sb)->s_lvid_bh)\n\t\treturn NULL;\n\tlvid = (struct logicalVolIntegrityDesc *)UDF_SB(sb)->s_lvid_bh->b_data;\n\tpartnum = le32_to_cpu(lvid->numOfPartitions);\n\tif ((sb->s_blocksize - sizeof(struct logicalVolIntegrityDescImpUse) -\n\t     offsetof(struct logicalVolIntegrityDesc, impUse)) /\n\t     (2 * sizeof(uint32_t)) < partnum) {\n\t\tudf_err(sb, \"Logical volume integrity descriptor corrupted \"\n\t\t\t\"(numOfPartitions = %u)!\\n\", partnum);\n\t\treturn NULL;\n\t}\n\t/* The offset is to skip freeSpaceTable and sizeTable arrays */\n\toffset = partnum * 2 * sizeof(uint32_t);\n\treturn (struct logicalVolIntegrityDescImpUse *)&(lvid->impUse[offset]);\n}"
  }
]