[
  {
    "function_name": "hpfs_compare_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dentry.c",
    "lines": "37-56",
    "snippet": "static int hpfs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tunsigned al = len;\n\tunsigned bl = name->len;\n\n\thpfs_adjust_length(str, &al);\n\t/*hpfs_adjust_length(b->name, &bl);*/\n\n\t/*\n\t * 'str' is the nane of an already existing dentry, so the name\n\t * must be valid. 'name' must be validated first.\n\t */\n\n\tif (hpfs_chk_name(name->name, &bl))\n\t\treturn 1;\n\tif (hpfs_compare_names(parent->d_sb, str, al, name->name, bl, 0))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_compare_names",
          "args": [
            "parent->d_sb",
            "str",
            "al",
            "name->name",
            "bl",
            "0"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_compare_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/name.c",
          "lines": "74-90",
          "snippet": "int hpfs_compare_names(struct super_block *s,\n\t\t       const unsigned char *n1, unsigned l1,\n\t\t       const unsigned char *n2, unsigned l2, int last)\n{\n\tunsigned l = l1 < l2 ? l1 : l2;\n\tunsigned i;\n\tif (last) return -1;\n\tfor (i = 0; i < l; i++) {\n\t\tunsigned char c1 = upcase(hpfs_sb(s)->sb_cp_table,n1[i]);\n\t\tunsigned char c2 = upcase(hpfs_sb(s)->sb_cp_table,n2[i]);\n\t\tif (c1 < c2) return -1;\n\t\tif (c1 > c2) return 1;\n\t}\n\tif (l1 < l2) return -1;\n\tif (l1 > l2) return 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_compare_names(struct super_block *s,\n\t\t       const unsigned char *n1, unsigned l1,\n\t\t       const unsigned char *n2, unsigned l2, int last)\n{\n\tunsigned l = l1 < l2 ? l1 : l2;\n\tunsigned i;\n\tif (last) return -1;\n\tfor (i = 0; i < l; i++) {\n\t\tunsigned char c1 = upcase(hpfs_sb(s)->sb_cp_table,n1[i]);\n\t\tunsigned char c2 = upcase(hpfs_sb(s)->sb_cp_table,n2[i]);\n\t\tif (c1 < c2) return -1;\n\t\tif (c1 > c2) return 1;\n\t}\n\tif (l1 < l2) return -1;\n\tif (l1 > l2) return 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_chk_name",
          "args": [
            "name->name",
            "&bl"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_chk_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/name.c",
          "lines": "41-51",
          "snippet": "int hpfs_chk_name(const unsigned char *name, unsigned *len)\n{\n\tint i;\n\tif (*len > 254) return -ENAMETOOLONG;\n\thpfs_adjust_length(name, len);\n\tif (!*len) return -EINVAL;\n\tfor (i = 0; i < *len; i++) if (not_allowed_char(name[i])) return -EINVAL;\n\tif (*len == 1) if (name[0] == '.') return -EINVAL;\n\tif (*len == 2) if (name[0] == '.' && name[1] == '.') return -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_chk_name(const unsigned char *name, unsigned *len)\n{\n\tint i;\n\tif (*len > 254) return -ENAMETOOLONG;\n\thpfs_adjust_length(name, len);\n\tif (!*len) return -EINVAL;\n\tfor (i = 0; i < *len; i++) if (not_allowed_char(name[i])) return -EINVAL;\n\tif (*len == 1) if (name[0] == '.') return -EINVAL;\n\tif (*len == 2) if (name[0] == '.' && name[1] == '.') return -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_adjust_length",
          "args": [
            "str",
            "&al"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_adjust_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/name.c",
          "lines": "106-113",
          "snippet": "void hpfs_adjust_length(const unsigned char *name, unsigned *len)\n{\n\tif (!*len) return;\n\tif (*len == 1 && name[0] == '.') return;\n\tif (*len == 2 && name[0] == '.' && name[1] == '.') return;\n\twhile (*len && (name[*len - 1] == '.' || name[*len - 1] == ' '))\n\t\t(*len)--;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_adjust_length(const unsigned char *name, unsigned *len)\n{\n\tif (!*len) return;\n\tif (*len == 1 && name[0] == '.') return;\n\tif (*len == 2 && name[0] == '.' && name[1] == '.') return;\n\twhile (*len && (name[*len - 1] == '.' || name[*len - 1] == ' '))\n\t\t(*len)--;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic int hpfs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tunsigned al = len;\n\tunsigned bl = name->len;\n\n\thpfs_adjust_length(str, &al);\n\t/*hpfs_adjust_length(b->name, &bl);*/\n\n\t/*\n\t * 'str' is the nane of an already existing dentry, so the name\n\t * must be valid. 'name' must be validated first.\n\t */\n\n\tif (hpfs_chk_name(name->name, &bl))\n\t\treturn 1;\n\tif (hpfs_compare_names(parent->d_sb, str, al, name->name, bl, 0))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "hpfs_hash_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dentry.c",
    "lines": "15-35",
    "snippet": "static int hpfs_hash_dentry(const struct dentry *dentry, struct qstr *qstr)\n{\n\tunsigned long\t hash;\n\tint\t\t i;\n\tunsigned l = qstr->len;\n\n\tif (l == 1) if (qstr->name[0]=='.') goto x;\n\tif (l == 2) if (qstr->name[0]=='.' || qstr->name[1]=='.') goto x;\n\thpfs_adjust_length(qstr->name, &l);\n\t/*if (hpfs_chk_name(qstr->name,&l))*/\n\t\t/*return -ENAMETOOLONG;*/\n\t\t/*return -ENOENT;*/\n\tx:\n\n\thash = init_name_hash();\n\tfor (i = 0; i < l; i++)\n\t\thash = partial_name_hash(hpfs_upcase(hpfs_sb(dentry->d_sb)->sb_cp_table,qstr->name[i]), hash);\n\tqstr->hash = end_name_hash(hash);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_name_hash",
          "args": [
            "hash"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "partial_name_hash",
          "args": [
            "hpfs_upcase(hpfs_sb(dentry->d_sb)->sb_cp_table,qstr->name[i])",
            "hash"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_upcase",
          "args": [
            "hpfs_sb(dentry->d_sb)->sb_cp_table",
            "qstr->name[i]"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_upcase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/name.c",
          "lines": "29-32",
          "snippet": "unsigned char hpfs_upcase(unsigned char *dir, unsigned char a)\n{\n\treturn upcase(dir, a);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nunsigned char hpfs_upcase(unsigned char *dir, unsigned char a)\n{\n\treturn upcase(dir, a);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "dentry->d_sb"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_name_hash",
          "args": [],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_adjust_length",
          "args": [
            "qstr->name",
            "&l"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_adjust_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/name.c",
          "lines": "106-113",
          "snippet": "void hpfs_adjust_length(const unsigned char *name, unsigned *len)\n{\n\tif (!*len) return;\n\tif (*len == 1 && name[0] == '.') return;\n\tif (*len == 2 && name[0] == '.' && name[1] == '.') return;\n\twhile (*len && (name[*len - 1] == '.' || name[*len - 1] == ' '))\n\t\t(*len)--;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_adjust_length(const unsigned char *name, unsigned *len)\n{\n\tif (!*len) return;\n\tif (*len == 1 && name[0] == '.') return;\n\tif (*len == 2 && name[0] == '.' && name[1] == '.') return;\n\twhile (*len && (name[*len - 1] == '.' || name[*len - 1] == ' '))\n\t\t(*len)--;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic int hpfs_hash_dentry(const struct dentry *dentry, struct qstr *qstr)\n{\n\tunsigned long\t hash;\n\tint\t\t i;\n\tunsigned l = qstr->len;\n\n\tif (l == 1) if (qstr->name[0]=='.') goto x;\n\tif (l == 2) if (qstr->name[0]=='.' || qstr->name[1]=='.') goto x;\n\thpfs_adjust_length(qstr->name, &l);\n\t/*if (hpfs_chk_name(qstr->name,&l))*/\n\t\t/*return -ENAMETOOLONG;*/\n\t\t/*return -ENOENT;*/\n\tx:\n\n\thash = init_name_hash();\n\tfor (i = 0; i < l; i++)\n\t\thash = partial_name_hash(hpfs_upcase(hpfs_sb(dentry->d_sb)->sb_cp_table,qstr->name[i]), hash);\n\tqstr->hash = end_name_hash(hash);\n\n\treturn 0;\n}"
  }
]