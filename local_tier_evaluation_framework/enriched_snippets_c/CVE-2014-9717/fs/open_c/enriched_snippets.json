[
  {
    "function_name": "nonseekable_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
    "lines": "1136-1140",
    "snippet": "int nonseekable_open(struct inode *inode, struct file *filp)\n{\n\tfilp->f_mode &= ~(FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint nonseekable_open(struct inode *inode, struct file *filp)\n{\n\tfilp->f_mode &= ~(FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE);\n\treturn 0;\n}"
  },
  {
    "function_name": "generic_file_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
    "lines": "1121-1126",
    "snippet": "int generic_file_open(struct inode * inode, struct file * filp)\n{\n\tif (!(filp->f_flags & O_LARGEFILE) && i_size_read(inode) > MAX_NON_LFS)\n\t\treturn -EOVERFLOW;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint generic_file_open(struct inode * inode, struct file * filp)\n{\n\tif (!(filp->f_flags & O_LARGEFILE) && i_size_read(inode) > MAX_NON_LFS)\n\t\treturn -EOVERFLOW;\n\treturn 0;\n}"
  },
  {
    "function_name": "filp_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
    "lines": "1060-1078",
    "snippet": "int filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "filp"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_remove_posix",
          "args": [
            "filp",
            "id"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "locks_remove_posix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "2359-2386",
          "snippet": "void locks_remove_posix(struct file *filp, fl_owner_t owner)\n{\n\tstruct file_lock lock;\n\tstruct file_lock_context *ctx = file_inode(filp)->i_flctx;\n\n\t/*\n\t * If there are no locks held on this file, we don't need to call\n\t * posix_lock_file().  Another process could be setting a lock on this\n\t * file at the same time, but we wouldn't remove that lock anyway.\n\t */\n\tif (!ctx || list_empty(&ctx->flc_posix))\n\t\treturn;\n\n\tlock.fl_type = F_UNLCK;\n\tlock.fl_flags = FL_POSIX | FL_CLOSE;\n\tlock.fl_start = 0;\n\tlock.fl_end = OFFSET_MAX;\n\tlock.fl_owner = owner;\n\tlock.fl_pid = current->tgid;\n\tlock.fl_file = filp;\n\tlock.fl_ops = NULL;\n\tlock.fl_lmops = NULL;\n\n\tvfs_lock_file(filp, F_SETLK, &lock, NULL);\n\n\tif (lock.fl_ops && lock.fl_ops->fl_release_private)\n\t\tlock.fl_ops->fl_release_private(&lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_remove_posix(struct file *filp, fl_owner_t owner)\n{\n\tstruct file_lock lock;\n\tstruct file_lock_context *ctx = file_inode(filp)->i_flctx;\n\n\t/*\n\t * If there are no locks held on this file, we don't need to call\n\t * posix_lock_file().  Another process could be setting a lock on this\n\t * file at the same time, but we wouldn't remove that lock anyway.\n\t */\n\tif (!ctx || list_empty(&ctx->flc_posix))\n\t\treturn;\n\n\tlock.fl_type = F_UNLCK;\n\tlock.fl_flags = FL_POSIX | FL_CLOSE;\n\tlock.fl_start = 0;\n\tlock.fl_end = OFFSET_MAX;\n\tlock.fl_owner = owner;\n\tlock.fl_pid = current->tgid;\n\tlock.fl_file = filp;\n\tlock.fl_ops = NULL;\n\tlock.fl_lmops = NULL;\n\n\tvfs_lock_file(filp, F_SETLK, &lock, NULL);\n\n\tif (lock.fl_ops && lock.fl_ops->fl_release_private)\n\t\tlock.fl_ops->fl_release_private(&lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnotify_flush",
          "args": [
            "filp",
            "id"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "dnotify_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/dnotify/dnotify.c",
          "lines": "150-191",
          "snippet": "void dnotify_flush(struct file *filp, fl_owner_t id)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\tstruct dnotify_mark *dn_mark;\n\tstruct dnotify_struct *dn;\n\tstruct dnotify_struct **prev;\n\tstruct inode *inode;\n\n\tinode = file_inode(filp);\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tfsn_mark = fsnotify_find_inode_mark(dnotify_group, inode);\n\tif (!fsn_mark)\n\t\treturn;\n\tdn_mark = container_of(fsn_mark, struct dnotify_mark, fsn_mark);\n\n\tmutex_lock(&dnotify_group->mark_mutex);\n\n\tspin_lock(&fsn_mark->lock);\n\tprev = &dn_mark->dn;\n\twhile ((dn = *prev) != NULL) {\n\t\tif ((dn->dn_owner == id) && (dn->dn_filp == filp)) {\n\t\t\t*prev = dn->dn_next;\n\t\t\tkmem_cache_free(dnotify_struct_cache, dn);\n\t\t\tdnotify_recalc_inode_mask(fsn_mark);\n\t\t\tbreak;\n\t\t}\n\t\tprev = &dn->dn_next;\n\t}\n\n\tspin_unlock(&fsn_mark->lock);\n\n\t/* nothing else could have found us thanks to the dnotify_groups\n\t   mark_mutex */\n\tif (dn_mark->dn == NULL)\n\t\tfsnotify_destroy_mark_locked(fsn_mark, dnotify_group);\n\n\tmutex_unlock(&dnotify_group->mark_mutex);\n\n\tfsnotify_put_mark(fsn_mark);\n}",
          "includes": [
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dnotify_struct_cache",
            "static struct fsnotify_group *dnotify_group"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fsnotify_backend.h>\n#include <linux/fdtable.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/dnotify.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *dnotify_struct_cache;\nstatic struct fsnotify_group *dnotify_group;\n\nvoid dnotify_flush(struct file *filp, fl_owner_t id)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\tstruct dnotify_mark *dn_mark;\n\tstruct dnotify_struct *dn;\n\tstruct dnotify_struct **prev;\n\tstruct inode *inode;\n\n\tinode = file_inode(filp);\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tfsn_mark = fsnotify_find_inode_mark(dnotify_group, inode);\n\tif (!fsn_mark)\n\t\treturn;\n\tdn_mark = container_of(fsn_mark, struct dnotify_mark, fsn_mark);\n\n\tmutex_lock(&dnotify_group->mark_mutex);\n\n\tspin_lock(&fsn_mark->lock);\n\tprev = &dn_mark->dn;\n\twhile ((dn = *prev) != NULL) {\n\t\tif ((dn->dn_owner == id) && (dn->dn_filp == filp)) {\n\t\t\t*prev = dn->dn_next;\n\t\t\tkmem_cache_free(dnotify_struct_cache, dn);\n\t\t\tdnotify_recalc_inode_mask(fsn_mark);\n\t\t\tbreak;\n\t\t}\n\t\tprev = &dn->dn_next;\n\t}\n\n\tspin_unlock(&fsn_mark->lock);\n\n\t/* nothing else could have found us thanks to the dnotify_groups\n\t   mark_mutex */\n\tif (dn_mark->dn == NULL)\n\t\tfsnotify_destroy_mark_locked(fsn_mark, dnotify_group);\n\n\tmutex_unlock(&dnotify_group->mark_mutex);\n\n\tfsnotify_put_mark(fsn_mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(filp->f_mode & FMODE_PATH)"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filp->f_op->flush",
          "args": [
            "filp",
            "id"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"VFS: Close: file count is 0\\n\""
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_count",
          "args": [
            "filp"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}"
  },
  {
    "function_name": "do_sys_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
    "lines": "998-1024",
    "snippet": "long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint fd = build_open_flags(flags, mode, &op);\n\tstruct filename *tmp;\n\n\tif (fd)\n\t\treturn fd;\n\n\ttmp = getname(filename);\n\tif (IS_ERR(tmp))\n\t\treturn PTR_ERR(tmp);\n\n\tfd = get_unused_fd_flags(flags);\n\tif (fd >= 0) {\n\t\tstruct file *f = do_filp_open(dfd, tmp, &op);\n\t\tif (IS_ERR(f)) {\n\t\t\tput_unused_fd(fd);\n\t\t\tfd = PTR_ERR(f);\n\t\t} else {\n\t\t\tfsnotify_open(f);\n\t\t\tfd_install(fd, f);\n\t\t}\n\t}\n\tputname(tmp);\n\treturn fd;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "putname",
          "args": [
            "tmp"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "putname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "245-257",
          "snippet": "void putname(struct filename *name)\n{\n\tBUG_ON(name->refcnt <= 0);\n\n\tif (--name->refcnt > 0)\n\t\treturn;\n\n\tif (name->separate) {\n\t\t__putname(name->name);\n\t\tkfree(name);\n\t} else\n\t\t__putname(name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid putname(struct filename *name)\n{\n\tBUG_ON(name->refcnt <= 0);\n\n\tif (--name->refcnt > 0)\n\t\treturn;\n\n\tif (name->separate) {\n\t\t__putname(name->name);\n\t\tkfree(name);\n\t} else\n\t\t__putname(name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fd_install",
          "args": [
            "fd",
            "f"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "fd_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "563-566",
          "snippet": "void fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_open",
          "args": [
            "f"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "f"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_unused_fd",
          "args": [
            "fd"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "put_unused_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "522-528",
          "snippet": "void put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "f"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_filp_open",
          "args": [
            "dfd",
            "tmp",
            "&op"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "do_filp_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3275-3288",
          "snippet": "struct file *do_filp_open(int dfd, struct filename *pathname,\n\t\tconst struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tint flags = op->lookup_flags;\n\tstruct file *filp;\n\n\tfilp = path_openat(dfd, pathname, &nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(filp == ERR_PTR(-ECHILD)))\n\t\tfilp = path_openat(dfd, pathname, &nd, op, flags);\n\tif (unlikely(filp == ERR_PTR(-ESTALE)))\n\t\tfilp = path_openat(dfd, pathname, &nd, op, flags | LOOKUP_REVAL);\n\treturn filp;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nstruct file *do_filp_open(int dfd, struct filename *pathname,\n\t\tconst struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tint flags = op->lookup_flags;\n\tstruct file *filp;\n\n\tfilp = path_openat(dfd, pathname, &nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(filp == ERR_PTR(-ECHILD)))\n\t\tfilp = path_openat(dfd, pathname, &nd, op, flags);\n\tif (unlikely(filp == ERR_PTR(-ESTALE)))\n\t\tfilp = path_openat(dfd, pathname, &nd, op, flags | LOOKUP_REVAL);\n\treturn filp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_unused_fd_flags",
          "args": [
            "flags"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "get_unused_fd_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "508-511",
          "snippet": "int get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tmp"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tmp"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getname",
          "args": [
            "filename"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "getname_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "208-243",
          "snippet": "struct filename *\ngetname_kernel(const char * filename)\n{\n\tstruct filename *result;\n\tint len = strlen(filename) + 1;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (len <= EMBEDDED_NAME_MAX) {\n\t\tresult->name = (char *)(result) + sizeof(*result);\n\t\tresult->separate = false;\n\t} else if (len <= PATH_MAX) {\n\t\tstruct filename *tmp;\n\n\t\ttmp = kmalloc(sizeof(*tmp), GFP_KERNEL);\n\t\tif (unlikely(!tmp)) {\n\t\t\t__putname(result);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\ttmp->name = (char *)result;\n\t\ttmp->separate = true;\n\t\tresult = tmp;\n\t} else {\n\t\t__putname(result);\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\tmemcpy((char *)result->name, filename, len);\n\tresult->uptr = NULL;\n\tresult->aname = NULL;\n\tresult->refcnt = 1;\n\taudit_getname(result);\n\n\treturn result;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define EMBEDDED_NAME_MAX\t(PATH_MAX - sizeof(struct filename))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\n#define EMBEDDED_NAME_MAX\t(PATH_MAX - sizeof(struct filename))\n\nstruct filename *\ngetname_kernel(const char * filename)\n{\n\tstruct filename *result;\n\tint len = strlen(filename) + 1;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (len <= EMBEDDED_NAME_MAX) {\n\t\tresult->name = (char *)(result) + sizeof(*result);\n\t\tresult->separate = false;\n\t} else if (len <= PATH_MAX) {\n\t\tstruct filename *tmp;\n\n\t\ttmp = kmalloc(sizeof(*tmp), GFP_KERNEL);\n\t\tif (unlikely(!tmp)) {\n\t\t\t__putname(result);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\ttmp->name = (char *)result;\n\t\ttmp->separate = true;\n\t\tresult = tmp;\n\t} else {\n\t\t__putname(result);\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\tmemcpy((char *)result->name, filename, len);\n\tresult->uptr = NULL;\n\tresult->aname = NULL;\n\tresult->refcnt = 1;\n\taudit_getname(result);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_open_flags",
          "args": [
            "flags",
            "mode",
            "&op"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "build_open_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "872-938",
          "snippet": "static inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)\n{\n\tint lookup_flags = 0;\n\tint acc_mode;\n\n\tif (flags & (O_CREAT | __O_TMPFILE))\n\t\top->mode = (mode & S_IALLUGO) | S_IFREG;\n\telse\n\t\top->mode = 0;\n\n\t/* Must never be set by userspace */\n\tflags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;\n\n\t/*\n\t * O_SYNC is implemented as __O_SYNC|O_DSYNC.  As many places only\n\t * check for O_DSYNC if the need any syncing at all we enforce it's\n\t * always set instead of having to deal with possibly weird behaviour\n\t * for malicious applications setting only __O_SYNC.\n\t */\n\tif (flags & __O_SYNC)\n\t\tflags |= O_DSYNC;\n\n\tif (flags & __O_TMPFILE) {\n\t\tif ((flags & O_TMPFILE_MASK) != O_TMPFILE)\n\t\t\treturn -EINVAL;\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t\tif (!(acc_mode & MAY_WRITE))\n\t\t\treturn -EINVAL;\n\t} else if (flags & O_PATH) {\n\t\t/*\n\t\t * If we have O_PATH in the open flag. Then we\n\t\t * cannot have anything other than the below set of flags\n\t\t */\n\t\tflags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;\n\t\tacc_mode = 0;\n\t} else {\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t}\n\n\top->open_flag = flags;\n\n\t/* O_TRUNC implies we need access checks for write permissions */\n\tif (flags & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\n\t/* Allow the LSM permission hook to distinguish append\n\t   access from general write access. */\n\tif (flags & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\n\top->acc_mode = acc_mode;\n\n\top->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\n\n\tif (flags & O_CREAT) {\n\t\top->intent |= LOOKUP_CREATE;\n\t\tif (flags & O_EXCL)\n\t\t\top->intent |= LOOKUP_EXCL;\n\t}\n\n\tif (flags & O_DIRECTORY)\n\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\tif (!(flags & O_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\top->lookup_flags = lookup_flags;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)\n{\n\tint lookup_flags = 0;\n\tint acc_mode;\n\n\tif (flags & (O_CREAT | __O_TMPFILE))\n\t\top->mode = (mode & S_IALLUGO) | S_IFREG;\n\telse\n\t\top->mode = 0;\n\n\t/* Must never be set by userspace */\n\tflags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;\n\n\t/*\n\t * O_SYNC is implemented as __O_SYNC|O_DSYNC.  As many places only\n\t * check for O_DSYNC if the need any syncing at all we enforce it's\n\t * always set instead of having to deal with possibly weird behaviour\n\t * for malicious applications setting only __O_SYNC.\n\t */\n\tif (flags & __O_SYNC)\n\t\tflags |= O_DSYNC;\n\n\tif (flags & __O_TMPFILE) {\n\t\tif ((flags & O_TMPFILE_MASK) != O_TMPFILE)\n\t\t\treturn -EINVAL;\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t\tif (!(acc_mode & MAY_WRITE))\n\t\t\treturn -EINVAL;\n\t} else if (flags & O_PATH) {\n\t\t/*\n\t\t * If we have O_PATH in the open flag. Then we\n\t\t * cannot have anything other than the below set of flags\n\t\t */\n\t\tflags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;\n\t\tacc_mode = 0;\n\t} else {\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t}\n\n\top->open_flag = flags;\n\n\t/* O_TRUNC implies we need access checks for write permissions */\n\tif (flags & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\n\t/* Allow the LSM permission hook to distinguish append\n\t   access from general write access. */\n\tif (flags & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\n\top->acc_mode = acc_mode;\n\n\top->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\n\n\tif (flags & O_CREAT) {\n\t\top->intent |= LOOKUP_CREATE;\n\t\tif (flags & O_EXCL)\n\t\t\top->intent |= LOOKUP_EXCL;\n\t}\n\n\tif (flags & O_DIRECTORY)\n\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\tif (!(flags & O_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\top->lookup_flags = lookup_flags;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nlong do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint fd = build_open_flags(flags, mode, &op);\n\tstruct filename *tmp;\n\n\tif (fd)\n\t\treturn fd;\n\n\ttmp = getname(filename);\n\tif (IS_ERR(tmp))\n\t\treturn PTR_ERR(tmp);\n\n\tfd = get_unused_fd_flags(flags);\n\tif (fd >= 0) {\n\t\tstruct file *f = do_filp_open(dfd, tmp, &op);\n\t\tif (IS_ERR(f)) {\n\t\t\tput_unused_fd(fd);\n\t\t\tfd = PTR_ERR(f);\n\t\t} else {\n\t\t\tfsnotify_open(f);\n\t\t\tfd_install(fd, f);\n\t\t}\n\t}\n\tputname(tmp);\n\treturn fd;\n}"
  },
  {
    "function_name": "file_open_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
    "lines": "982-995",
    "snippet": "struct file *file_open_root(struct dentry *dentry, struct vfsmount *mnt,\n\t\t\t    const char *filename, int flags)\n{\n\tstruct open_flags op;\n\tint err = build_open_flags(flags, 0, &op);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tif (flags & O_CREAT)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (!filename && (flags & O_DIRECTORY))\n\t\tif (!dentry->d_inode->i_op->lookup)\n\t\t\treturn ERR_PTR(-ENOTDIR);\n\treturn do_file_open_root(dentry, mnt, filename, &op);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_file_open_root",
          "args": [
            "dentry",
            "mnt",
            "filename",
            "&op"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "do_file_open_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3290-3315",
          "snippet": "struct file *do_file_open_root(struct dentry *dentry, struct vfsmount *mnt,\n\t\tconst char *name, const struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tstruct file *file;\n\tstruct filename *filename;\n\tint flags = op->lookup_flags | LOOKUP_ROOT;\n\n\tnd.root.mnt = mnt;\n\tnd.root.dentry = dentry;\n\n\tif (d_is_symlink(dentry) && op->intent & LOOKUP_OPEN)\n\t\treturn ERR_PTR(-ELOOP);\n\n\tfilename = getname_kernel(name);\n\tif (unlikely(IS_ERR(filename)))\n\t\treturn ERR_CAST(filename);\n\n\tfile = path_openat(-1, filename, &nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(file == ERR_PTR(-ECHILD)))\n\t\tfile = path_openat(-1, filename, &nd, op, flags);\n\tif (unlikely(file == ERR_PTR(-ESTALE)))\n\t\tfile = path_openat(-1, filename, &nd, op, flags | LOOKUP_REVAL);\n\tputname(filename);\n\treturn file;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nstruct file *do_file_open_root(struct dentry *dentry, struct vfsmount *mnt,\n\t\tconst char *name, const struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tstruct file *file;\n\tstruct filename *filename;\n\tint flags = op->lookup_flags | LOOKUP_ROOT;\n\n\tnd.root.mnt = mnt;\n\tnd.root.dentry = dentry;\n\n\tif (d_is_symlink(dentry) && op->intent & LOOKUP_OPEN)\n\t\treturn ERR_PTR(-ELOOP);\n\n\tfilename = getname_kernel(name);\n\tif (unlikely(IS_ERR(filename)))\n\t\treturn ERR_CAST(filename);\n\n\tfile = path_openat(-1, filename, &nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(file == ERR_PTR(-ECHILD)))\n\t\tfile = path_openat(-1, filename, &nd, op, flags);\n\tif (unlikely(file == ERR_PTR(-ESTALE)))\n\t\tfile = path_openat(-1, filename, &nd, op, flags | LOOKUP_REVAL);\n\tputname(filename);\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOTDIR"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_open_flags",
          "args": [
            "flags",
            "0",
            "&op"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "build_open_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "872-938",
          "snippet": "static inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)\n{\n\tint lookup_flags = 0;\n\tint acc_mode;\n\n\tif (flags & (O_CREAT | __O_TMPFILE))\n\t\top->mode = (mode & S_IALLUGO) | S_IFREG;\n\telse\n\t\top->mode = 0;\n\n\t/* Must never be set by userspace */\n\tflags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;\n\n\t/*\n\t * O_SYNC is implemented as __O_SYNC|O_DSYNC.  As many places only\n\t * check for O_DSYNC if the need any syncing at all we enforce it's\n\t * always set instead of having to deal with possibly weird behaviour\n\t * for malicious applications setting only __O_SYNC.\n\t */\n\tif (flags & __O_SYNC)\n\t\tflags |= O_DSYNC;\n\n\tif (flags & __O_TMPFILE) {\n\t\tif ((flags & O_TMPFILE_MASK) != O_TMPFILE)\n\t\t\treturn -EINVAL;\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t\tif (!(acc_mode & MAY_WRITE))\n\t\t\treturn -EINVAL;\n\t} else if (flags & O_PATH) {\n\t\t/*\n\t\t * If we have O_PATH in the open flag. Then we\n\t\t * cannot have anything other than the below set of flags\n\t\t */\n\t\tflags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;\n\t\tacc_mode = 0;\n\t} else {\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t}\n\n\top->open_flag = flags;\n\n\t/* O_TRUNC implies we need access checks for write permissions */\n\tif (flags & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\n\t/* Allow the LSM permission hook to distinguish append\n\t   access from general write access. */\n\tif (flags & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\n\top->acc_mode = acc_mode;\n\n\top->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\n\n\tif (flags & O_CREAT) {\n\t\top->intent |= LOOKUP_CREATE;\n\t\tif (flags & O_EXCL)\n\t\t\top->intent |= LOOKUP_EXCL;\n\t}\n\n\tif (flags & O_DIRECTORY)\n\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\tif (!(flags & O_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\top->lookup_flags = lookup_flags;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)\n{\n\tint lookup_flags = 0;\n\tint acc_mode;\n\n\tif (flags & (O_CREAT | __O_TMPFILE))\n\t\top->mode = (mode & S_IALLUGO) | S_IFREG;\n\telse\n\t\top->mode = 0;\n\n\t/* Must never be set by userspace */\n\tflags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;\n\n\t/*\n\t * O_SYNC is implemented as __O_SYNC|O_DSYNC.  As many places only\n\t * check for O_DSYNC if the need any syncing at all we enforce it's\n\t * always set instead of having to deal with possibly weird behaviour\n\t * for malicious applications setting only __O_SYNC.\n\t */\n\tif (flags & __O_SYNC)\n\t\tflags |= O_DSYNC;\n\n\tif (flags & __O_TMPFILE) {\n\t\tif ((flags & O_TMPFILE_MASK) != O_TMPFILE)\n\t\t\treturn -EINVAL;\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t\tif (!(acc_mode & MAY_WRITE))\n\t\t\treturn -EINVAL;\n\t} else if (flags & O_PATH) {\n\t\t/*\n\t\t * If we have O_PATH in the open flag. Then we\n\t\t * cannot have anything other than the below set of flags\n\t\t */\n\t\tflags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;\n\t\tacc_mode = 0;\n\t} else {\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t}\n\n\top->open_flag = flags;\n\n\t/* O_TRUNC implies we need access checks for write permissions */\n\tif (flags & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\n\t/* Allow the LSM permission hook to distinguish append\n\t   access from general write access. */\n\tif (flags & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\n\top->acc_mode = acc_mode;\n\n\top->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\n\n\tif (flags & O_CREAT) {\n\t\top->intent |= LOOKUP_CREATE;\n\t\tif (flags & O_EXCL)\n\t\t\top->intent |= LOOKUP_EXCL;\n\t}\n\n\tif (flags & O_DIRECTORY)\n\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\tif (!(flags & O_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\top->lookup_flags = lookup_flags;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *file_open_root(struct dentry *dentry, struct vfsmount *mnt,\n\t\t\t    const char *filename, int flags)\n{\n\tstruct open_flags op;\n\tint err = build_open_flags(flags, 0, &op);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tif (flags & O_CREAT)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (!filename && (flags & O_DIRECTORY))\n\t\tif (!dentry->d_inode->i_op->lookup)\n\t\t\treturn ERR_PTR(-ENOTDIR);\n\treturn do_file_open_root(dentry, mnt, filename, &op);\n}"
  },
  {
    "function_name": "filp_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
    "lines": "969-979",
    "snippet": "struct file *filp_open(const char *filename, int flags, umode_t mode)\n{\n\tstruct filename *name = getname_kernel(filename);\n\tstruct file *file = ERR_CAST(name);\n\t\n\tif (!IS_ERR(name)) {\n\t\tfile = file_open_name(name, flags, mode);\n\t\tputname(name);\n\t}\n\treturn file;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "putname",
          "args": [
            "name"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "putname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "245-257",
          "snippet": "void putname(struct filename *name)\n{\n\tBUG_ON(name->refcnt <= 0);\n\n\tif (--name->refcnt > 0)\n\t\treturn;\n\n\tif (name->separate) {\n\t\t__putname(name->name);\n\t\tkfree(name);\n\t} else\n\t\t__putname(name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid putname(struct filename *name)\n{\n\tBUG_ON(name->refcnt <= 0);\n\n\tif (--name->refcnt > 0)\n\t\treturn;\n\n\tif (name->separate) {\n\t\t__putname(name->name);\n\t\tkfree(name);\n\t} else\n\t\t__putname(name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_open_name",
          "args": [
            "name",
            "flags",
            "mode"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "file_open_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "951-956",
          "snippet": "struct file *file_open_name(struct filename *name, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint err = build_open_flags(flags, mode, &op);\n\treturn err ? ERR_PTR(err) : do_filp_open(AT_FDCWD, name, &op);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *file_open_name(struct filename *name, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint err = build_open_flags(flags, mode, &op);\n\treturn err ? ERR_PTR(err) : do_filp_open(AT_FDCWD, name, &op);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "name"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "name"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getname_kernel",
          "args": [
            "filename"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "getname_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "208-243",
          "snippet": "struct filename *\ngetname_kernel(const char * filename)\n{\n\tstruct filename *result;\n\tint len = strlen(filename) + 1;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (len <= EMBEDDED_NAME_MAX) {\n\t\tresult->name = (char *)(result) + sizeof(*result);\n\t\tresult->separate = false;\n\t} else if (len <= PATH_MAX) {\n\t\tstruct filename *tmp;\n\n\t\ttmp = kmalloc(sizeof(*tmp), GFP_KERNEL);\n\t\tif (unlikely(!tmp)) {\n\t\t\t__putname(result);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\ttmp->name = (char *)result;\n\t\ttmp->separate = true;\n\t\tresult = tmp;\n\t} else {\n\t\t__putname(result);\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\tmemcpy((char *)result->name, filename, len);\n\tresult->uptr = NULL;\n\tresult->aname = NULL;\n\tresult->refcnt = 1;\n\taudit_getname(result);\n\n\treturn result;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define EMBEDDED_NAME_MAX\t(PATH_MAX - sizeof(struct filename))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\n#define EMBEDDED_NAME_MAX\t(PATH_MAX - sizeof(struct filename))\n\nstruct filename *\ngetname_kernel(const char * filename)\n{\n\tstruct filename *result;\n\tint len = strlen(filename) + 1;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (len <= EMBEDDED_NAME_MAX) {\n\t\tresult->name = (char *)(result) + sizeof(*result);\n\t\tresult->separate = false;\n\t} else if (len <= PATH_MAX) {\n\t\tstruct filename *tmp;\n\n\t\ttmp = kmalloc(sizeof(*tmp), GFP_KERNEL);\n\t\tif (unlikely(!tmp)) {\n\t\t\t__putname(result);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\ttmp->name = (char *)result;\n\t\ttmp->separate = true;\n\t\tresult = tmp;\n\t} else {\n\t\t__putname(result);\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\tmemcpy((char *)result->name, filename, len);\n\tresult->uptr = NULL;\n\tresult->aname = NULL;\n\tresult->refcnt = 1;\n\taudit_getname(result);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *filp_open(const char *filename, int flags, umode_t mode)\n{\n\tstruct filename *name = getname_kernel(filename);\n\tstruct file *file = ERR_CAST(name);\n\t\n\tif (!IS_ERR(name)) {\n\t\tfile = file_open_name(name, flags, mode);\n\t\tputname(name);\n\t}\n\treturn file;\n}"
  },
  {
    "function_name": "file_open_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
    "lines": "951-956",
    "snippet": "struct file *file_open_name(struct filename *name, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint err = build_open_flags(flags, mode, &op);\n\treturn err ? ERR_PTR(err) : do_filp_open(AT_FDCWD, name, &op);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_filp_open",
          "args": [
            "AT_FDCWD",
            "name",
            "&op"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "do_filp_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3275-3288",
          "snippet": "struct file *do_filp_open(int dfd, struct filename *pathname,\n\t\tconst struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tint flags = op->lookup_flags;\n\tstruct file *filp;\n\n\tfilp = path_openat(dfd, pathname, &nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(filp == ERR_PTR(-ECHILD)))\n\t\tfilp = path_openat(dfd, pathname, &nd, op, flags);\n\tif (unlikely(filp == ERR_PTR(-ESTALE)))\n\t\tfilp = path_openat(dfd, pathname, &nd, op, flags | LOOKUP_REVAL);\n\treturn filp;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nstruct file *do_filp_open(int dfd, struct filename *pathname,\n\t\tconst struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tint flags = op->lookup_flags;\n\tstruct file *filp;\n\n\tfilp = path_openat(dfd, pathname, &nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(filp == ERR_PTR(-ECHILD)))\n\t\tfilp = path_openat(dfd, pathname, &nd, op, flags);\n\tif (unlikely(filp == ERR_PTR(-ESTALE)))\n\t\tfilp = path_openat(dfd, pathname, &nd, op, flags | LOOKUP_REVAL);\n\treturn filp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_open_flags",
          "args": [
            "flags",
            "mode",
            "&op"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "build_open_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "872-938",
          "snippet": "static inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)\n{\n\tint lookup_flags = 0;\n\tint acc_mode;\n\n\tif (flags & (O_CREAT | __O_TMPFILE))\n\t\top->mode = (mode & S_IALLUGO) | S_IFREG;\n\telse\n\t\top->mode = 0;\n\n\t/* Must never be set by userspace */\n\tflags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;\n\n\t/*\n\t * O_SYNC is implemented as __O_SYNC|O_DSYNC.  As many places only\n\t * check for O_DSYNC if the need any syncing at all we enforce it's\n\t * always set instead of having to deal with possibly weird behaviour\n\t * for malicious applications setting only __O_SYNC.\n\t */\n\tif (flags & __O_SYNC)\n\t\tflags |= O_DSYNC;\n\n\tif (flags & __O_TMPFILE) {\n\t\tif ((flags & O_TMPFILE_MASK) != O_TMPFILE)\n\t\t\treturn -EINVAL;\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t\tif (!(acc_mode & MAY_WRITE))\n\t\t\treturn -EINVAL;\n\t} else if (flags & O_PATH) {\n\t\t/*\n\t\t * If we have O_PATH in the open flag. Then we\n\t\t * cannot have anything other than the below set of flags\n\t\t */\n\t\tflags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;\n\t\tacc_mode = 0;\n\t} else {\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t}\n\n\top->open_flag = flags;\n\n\t/* O_TRUNC implies we need access checks for write permissions */\n\tif (flags & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\n\t/* Allow the LSM permission hook to distinguish append\n\t   access from general write access. */\n\tif (flags & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\n\top->acc_mode = acc_mode;\n\n\top->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\n\n\tif (flags & O_CREAT) {\n\t\top->intent |= LOOKUP_CREATE;\n\t\tif (flags & O_EXCL)\n\t\t\top->intent |= LOOKUP_EXCL;\n\t}\n\n\tif (flags & O_DIRECTORY)\n\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\tif (!(flags & O_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\top->lookup_flags = lookup_flags;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)\n{\n\tint lookup_flags = 0;\n\tint acc_mode;\n\n\tif (flags & (O_CREAT | __O_TMPFILE))\n\t\top->mode = (mode & S_IALLUGO) | S_IFREG;\n\telse\n\t\top->mode = 0;\n\n\t/* Must never be set by userspace */\n\tflags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;\n\n\t/*\n\t * O_SYNC is implemented as __O_SYNC|O_DSYNC.  As many places only\n\t * check for O_DSYNC if the need any syncing at all we enforce it's\n\t * always set instead of having to deal with possibly weird behaviour\n\t * for malicious applications setting only __O_SYNC.\n\t */\n\tif (flags & __O_SYNC)\n\t\tflags |= O_DSYNC;\n\n\tif (flags & __O_TMPFILE) {\n\t\tif ((flags & O_TMPFILE_MASK) != O_TMPFILE)\n\t\t\treturn -EINVAL;\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t\tif (!(acc_mode & MAY_WRITE))\n\t\t\treturn -EINVAL;\n\t} else if (flags & O_PATH) {\n\t\t/*\n\t\t * If we have O_PATH in the open flag. Then we\n\t\t * cannot have anything other than the below set of flags\n\t\t */\n\t\tflags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;\n\t\tacc_mode = 0;\n\t} else {\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t}\n\n\top->open_flag = flags;\n\n\t/* O_TRUNC implies we need access checks for write permissions */\n\tif (flags & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\n\t/* Allow the LSM permission hook to distinguish append\n\t   access from general write access. */\n\tif (flags & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\n\top->acc_mode = acc_mode;\n\n\top->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\n\n\tif (flags & O_CREAT) {\n\t\top->intent |= LOOKUP_CREATE;\n\t\tif (flags & O_EXCL)\n\t\t\top->intent |= LOOKUP_EXCL;\n\t}\n\n\tif (flags & O_DIRECTORY)\n\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\tif (!(flags & O_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\top->lookup_flags = lookup_flags;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *file_open_name(struct filename *name, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint err = build_open_flags(flags, mode, &op);\n\treturn err ? ERR_PTR(err) : do_filp_open(AT_FDCWD, name, &op);\n}"
  },
  {
    "function_name": "build_open_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
    "lines": "872-938",
    "snippet": "static inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)\n{\n\tint lookup_flags = 0;\n\tint acc_mode;\n\n\tif (flags & (O_CREAT | __O_TMPFILE))\n\t\top->mode = (mode & S_IALLUGO) | S_IFREG;\n\telse\n\t\top->mode = 0;\n\n\t/* Must never be set by userspace */\n\tflags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;\n\n\t/*\n\t * O_SYNC is implemented as __O_SYNC|O_DSYNC.  As many places only\n\t * check for O_DSYNC if the need any syncing at all we enforce it's\n\t * always set instead of having to deal with possibly weird behaviour\n\t * for malicious applications setting only __O_SYNC.\n\t */\n\tif (flags & __O_SYNC)\n\t\tflags |= O_DSYNC;\n\n\tif (flags & __O_TMPFILE) {\n\t\tif ((flags & O_TMPFILE_MASK) != O_TMPFILE)\n\t\t\treturn -EINVAL;\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t\tif (!(acc_mode & MAY_WRITE))\n\t\t\treturn -EINVAL;\n\t} else if (flags & O_PATH) {\n\t\t/*\n\t\t * If we have O_PATH in the open flag. Then we\n\t\t * cannot have anything other than the below set of flags\n\t\t */\n\t\tflags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;\n\t\tacc_mode = 0;\n\t} else {\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t}\n\n\top->open_flag = flags;\n\n\t/* O_TRUNC implies we need access checks for write permissions */\n\tif (flags & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\n\t/* Allow the LSM permission hook to distinguish append\n\t   access from general write access. */\n\tif (flags & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\n\top->acc_mode = acc_mode;\n\n\top->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\n\n\tif (flags & O_CREAT) {\n\t\top->intent |= LOOKUP_CREATE;\n\t\tif (flags & O_EXCL)\n\t\t\top->intent |= LOOKUP_EXCL;\n\t}\n\n\tif (flags & O_DIRECTORY)\n\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\tif (!(flags & O_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\top->lookup_flags = lookup_flags;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ACC_MODE",
          "args": [
            "flags"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACC_MODE",
          "args": [
            "flags"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)\n{\n\tint lookup_flags = 0;\n\tint acc_mode;\n\n\tif (flags & (O_CREAT | __O_TMPFILE))\n\t\top->mode = (mode & S_IALLUGO) | S_IFREG;\n\telse\n\t\top->mode = 0;\n\n\t/* Must never be set by userspace */\n\tflags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;\n\n\t/*\n\t * O_SYNC is implemented as __O_SYNC|O_DSYNC.  As many places only\n\t * check for O_DSYNC if the need any syncing at all we enforce it's\n\t * always set instead of having to deal with possibly weird behaviour\n\t * for malicious applications setting only __O_SYNC.\n\t */\n\tif (flags & __O_SYNC)\n\t\tflags |= O_DSYNC;\n\n\tif (flags & __O_TMPFILE) {\n\t\tif ((flags & O_TMPFILE_MASK) != O_TMPFILE)\n\t\t\treturn -EINVAL;\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t\tif (!(acc_mode & MAY_WRITE))\n\t\t\treturn -EINVAL;\n\t} else if (flags & O_PATH) {\n\t\t/*\n\t\t * If we have O_PATH in the open flag. Then we\n\t\t * cannot have anything other than the below set of flags\n\t\t */\n\t\tflags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;\n\t\tacc_mode = 0;\n\t} else {\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t}\n\n\top->open_flag = flags;\n\n\t/* O_TRUNC implies we need access checks for write permissions */\n\tif (flags & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\n\t/* Allow the LSM permission hook to distinguish append\n\t   access from general write access. */\n\tif (flags & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\n\top->acc_mode = acc_mode;\n\n\top->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\n\n\tif (flags & O_CREAT) {\n\t\top->intent |= LOOKUP_CREATE;\n\t\tif (flags & O_EXCL)\n\t\t\top->intent |= LOOKUP_EXCL;\n\t}\n\n\tif (flags & O_DIRECTORY)\n\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\tif (!(flags & O_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\top->lookup_flags = lookup_flags;\n\treturn 0;\n}"
  },
  {
    "function_name": "vfs_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
    "lines": "858-869",
    "snippet": "int vfs_open(const struct path *path, struct file *filp,\n\t     const struct cred *cred)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\n\tif (inode->i_op->dentry_open)\n\t\treturn inode->i_op->dentry_open(path->dentry, filp, cred);\n\telse {\n\t\tfilp->f_path = *path;\n\t\treturn do_dentry_open(filp, NULL, cred);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_dentry_open",
          "args": [
            "filp",
            "NULL",
            "cred"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "do_dentry_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "676-761",
          "snippet": "static int do_dentry_open(struct file *f,\n\t\t\t  int (*open)(struct inode *, struct file *),\n\t\t\t  const struct cred *cred)\n{\n\tstatic const struct file_operations empty_fops = {};\n\tstruct inode *inode;\n\tint error;\n\n\tf->f_mode = OPEN_FMODE(f->f_flags) | FMODE_LSEEK |\n\t\t\t\tFMODE_PREAD | FMODE_PWRITE;\n\n\tpath_get(&f->f_path);\n\tinode = f->f_inode = f->f_path.dentry->d_inode;\n\tf->f_mapping = inode->i_mapping;\n\n\tif (unlikely(f->f_flags & O_PATH)) {\n\t\tf->f_mode = FMODE_PATH;\n\t\tf->f_op = &empty_fops;\n\t\treturn 0;\n\t}\n\n\tif (f->f_mode & FMODE_WRITE && !special_file(inode->i_mode)) {\n\t\terror = get_write_access(inode);\n\t\tif (unlikely(error))\n\t\t\tgoto cleanup_file;\n\t\terror = __mnt_want_write(f->f_path.mnt);\n\t\tif (unlikely(error)) {\n\t\t\tput_write_access(inode);\n\t\t\tgoto cleanup_file;\n\t\t}\n\t\tf->f_mode |= FMODE_WRITER;\n\t}\n\n\t/* POSIX.1-2008/SUSv4 Section XSI 2.9.7 */\n\tif (S_ISREG(inode->i_mode))\n\t\tf->f_mode |= FMODE_ATOMIC_POS;\n\n\tf->f_op = fops_get(inode->i_fop);\n\tif (unlikely(WARN_ON(!f->f_op))) {\n\t\terror = -ENODEV;\n\t\tgoto cleanup_all;\n\t}\n\n\terror = security_file_open(f, cred);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\terror = break_lease(inode, f->f_flags);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\tif (!open)\n\t\topen = f->f_op->open;\n\tif (open) {\n\t\terror = open(inode, f);\n\t\tif (error)\n\t\t\tgoto cleanup_all;\n\t}\n\tif ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(inode);\n\tif ((f->f_mode & FMODE_READ) &&\n\t     likely(f->f_op->read || f->f_op->aio_read || f->f_op->read_iter))\n\t\tf->f_mode |= FMODE_CAN_READ;\n\tif ((f->f_mode & FMODE_WRITE) &&\n\t     likely(f->f_op->write || f->f_op->aio_write || f->f_op->write_iter))\n\t\tf->f_mode |= FMODE_CAN_WRITE;\n\n\tf->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);\n\n\tfile_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);\n\n\treturn 0;\n\ncleanup_all:\n\tfops_put(f->f_op);\n\tif (f->f_mode & FMODE_WRITER) {\n\t\tput_write_access(inode);\n\t\t__mnt_drop_write(f->f_path.mnt);\n\t}\ncleanup_file:\n\tpath_put(&f->f_path);\n\tf->f_path.mnt = NULL;\n\tf->f_path.dentry = NULL;\n\tf->f_inode = NULL;\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic int do_dentry_open(struct file *f,\n\t\t\t  int (*open)(struct inode *, struct file *),\n\t\t\t  const struct cred *cred)\n{\n\tstatic const struct file_operations empty_fops = {};\n\tstruct inode *inode;\n\tint error;\n\n\tf->f_mode = OPEN_FMODE(f->f_flags) | FMODE_LSEEK |\n\t\t\t\tFMODE_PREAD | FMODE_PWRITE;\n\n\tpath_get(&f->f_path);\n\tinode = f->f_inode = f->f_path.dentry->d_inode;\n\tf->f_mapping = inode->i_mapping;\n\n\tif (unlikely(f->f_flags & O_PATH)) {\n\t\tf->f_mode = FMODE_PATH;\n\t\tf->f_op = &empty_fops;\n\t\treturn 0;\n\t}\n\n\tif (f->f_mode & FMODE_WRITE && !special_file(inode->i_mode)) {\n\t\terror = get_write_access(inode);\n\t\tif (unlikely(error))\n\t\t\tgoto cleanup_file;\n\t\terror = __mnt_want_write(f->f_path.mnt);\n\t\tif (unlikely(error)) {\n\t\t\tput_write_access(inode);\n\t\t\tgoto cleanup_file;\n\t\t}\n\t\tf->f_mode |= FMODE_WRITER;\n\t}\n\n\t/* POSIX.1-2008/SUSv4 Section XSI 2.9.7 */\n\tif (S_ISREG(inode->i_mode))\n\t\tf->f_mode |= FMODE_ATOMIC_POS;\n\n\tf->f_op = fops_get(inode->i_fop);\n\tif (unlikely(WARN_ON(!f->f_op))) {\n\t\terror = -ENODEV;\n\t\tgoto cleanup_all;\n\t}\n\n\terror = security_file_open(f, cred);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\terror = break_lease(inode, f->f_flags);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\tif (!open)\n\t\topen = f->f_op->open;\n\tif (open) {\n\t\terror = open(inode, f);\n\t\tif (error)\n\t\t\tgoto cleanup_all;\n\t}\n\tif ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(inode);\n\tif ((f->f_mode & FMODE_READ) &&\n\t     likely(f->f_op->read || f->f_op->aio_read || f->f_op->read_iter))\n\t\tf->f_mode |= FMODE_CAN_READ;\n\tif ((f->f_mode & FMODE_WRITE) &&\n\t     likely(f->f_op->write || f->f_op->aio_write || f->f_op->write_iter))\n\t\tf->f_mode |= FMODE_CAN_WRITE;\n\n\tf->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);\n\n\tfile_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);\n\n\treturn 0;\n\ncleanup_all:\n\tfops_put(f->f_op);\n\tif (f->f_mode & FMODE_WRITER) {\n\t\tput_write_access(inode);\n\t\t__mnt_drop_write(f->f_path.mnt);\n\t}\ncleanup_file:\n\tpath_put(&f->f_path);\n\tf->f_path.mnt = NULL;\n\tf->f_path.dentry = NULL;\n\tf->f_inode = NULL;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode->i_op->dentry_open",
          "args": [
            "path->dentry",
            "filp",
            "cred"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "821-849",
          "snippet": "struct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = get_empty_filp();\n\tif (!IS_ERR(f)) {\n\t\tf->f_flags = flags;\n\t\terror = vfs_open(path, f, cred);\n\t\tif (!error) {\n\t\t\t/* from now on we need fput() to dispose of f */\n\t\t\terror = open_check_o_direct(f);\n\t\t\tif (error) {\n\t\t\t\tfput(f);\n\t\t\t\tf = ERR_PTR(error);\n\t\t\t}\n\t\t} else { \n\t\t\tput_filp(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = get_empty_filp();\n\tif (!IS_ERR(f)) {\n\t\tf->f_flags = flags;\n\t\terror = vfs_open(path, f, cred);\n\t\tif (!error) {\n\t\t\t/* from now on we need fput() to dispose of f */\n\t\t\terror = open_check_o_direct(f);\n\t\t\tif (error) {\n\t\t\t\tfput(f);\n\t\t\t\tf = ERR_PTR(error);\n\t\t\t}\n\t\t} else { \n\t\t\tput_filp(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint vfs_open(const struct path *path, struct file *filp,\n\t     const struct cred *cred)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\n\tif (inode->i_op->dentry_open)\n\t\treturn inode->i_op->dentry_open(path->dentry, filp, cred);\n\telse {\n\t\tfilp->f_path = *path;\n\t\treturn do_dentry_open(filp, NULL, cred);\n\t}\n}"
  },
  {
    "function_name": "dentry_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
    "lines": "821-849",
    "snippet": "struct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = get_empty_filp();\n\tif (!IS_ERR(f)) {\n\t\tf->f_flags = flags;\n\t\terror = vfs_open(path, f, cred);\n\t\tif (!error) {\n\t\t\t/* from now on we need fput() to dispose of f */\n\t\t\terror = open_check_o_direct(f);\n\t\t\tif (error) {\n\t\t\t\tfput(f);\n\t\t\t\tf = ERR_PTR(error);\n\t\t\t}\n\t\t} else { \n\t\t\tput_filp(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_filp",
          "args": [
            "f"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "put_filp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "304-310",
          "snippet": "void put_filp(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tsecurity_file_free(file);\n\t\tfile_free(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid put_filp(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tsecurity_file_free(file);\n\t\tfile_free(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "f"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_check_o_direct",
          "args": [
            "f"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "open_check_o_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "666-674",
          "snippet": "int open_check_o_direct(struct file *f)\n{\n\t/* NB: we're sure to have correct a_ops only after f_op->open */\n\tif (f->f_flags & O_DIRECT) {\n\t\tif (!f->f_mapping->a_ops || !f->f_mapping->a_ops->direct_IO)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint open_check_o_direct(struct file *f)\n{\n\t/* NB: we're sure to have correct a_ops only after f_op->open */\n\tif (f->f_flags & O_DIRECT) {\n\t\tif (!f->f_mapping->a_ops || !f->f_mapping->a_ops->direct_IO)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_open",
          "args": [
            "path",
            "f",
            "cred"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "858-869",
          "snippet": "int vfs_open(const struct path *path, struct file *filp,\n\t     const struct cred *cred)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\n\tif (inode->i_op->dentry_open)\n\t\treturn inode->i_op->dentry_open(path->dentry, filp, cred);\n\telse {\n\t\tfilp->f_path = *path;\n\t\treturn do_dentry_open(filp, NULL, cred);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint vfs_open(const struct path *path, struct file *filp,\n\t     const struct cred *cred)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\n\tif (inode->i_op->dentry_open)\n\t\treturn inode->i_op->dentry_open(path->dentry, filp, cred);\n\telse {\n\t\tfilp->f_path = *path;\n\t\treturn do_dentry_open(filp, NULL, cred);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "f"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_empty_filp",
          "args": [],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "get_empty_filp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "103-149",
          "snippet": "struct file *get_empty_filp(void)\n{\n\tconst struct cred *cred = current_cred();\n\tstatic long old_max;\n\tstruct file *f;\n\tint error;\n\n\t/*\n\t * Privileged users can go above max_files\n\t */\n\tif (get_nr_files() >= files_stat.max_files && !capable(CAP_SYS_ADMIN)) {\n\t\t/*\n\t\t * percpu_counters are inaccurate.  Do an expensive check before\n\t\t * we go and fail.\n\t\t */\n\t\tif (percpu_counter_sum_positive(&nr_files) >= files_stat.max_files)\n\t\t\tgoto over;\n\t}\n\n\tf = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);\n\tif (unlikely(!f))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpercpu_counter_inc(&nr_files);\n\tf->f_cred = get_cred(cred);\n\terror = security_file_alloc(f);\n\tif (unlikely(error)) {\n\t\tfile_free(f);\n\t\treturn ERR_PTR(error);\n\t}\n\n\tatomic_long_set(&f->f_count, 1);\n\trwlock_init(&f->f_owner.lock);\n\tspin_lock_init(&f->f_lock);\n\tmutex_init(&f->f_pos_lock);\n\teventpoll_init_file(f);\n\t/* f->f_version: 0 */\n\treturn f;\n\nover:\n\t/* Ran out of filps - report that */\n\tif (get_nr_files() > old_max) {\n\t\tpr_info(\"VFS: file-max limit %lu reached\\n\", get_max_files());\n\t\told_max = get_nr_files();\n\t}\n\treturn ERR_PTR(-ENFILE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct files_stat_struct files_stat = {\n\t.max_files = NR_FILE\n};",
            "static struct kmem_cache *filp_cachep"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct files_stat_struct files_stat = {\n\t.max_files = NR_FILE\n};\nstatic struct kmem_cache *filp_cachep;\n\nstruct file *get_empty_filp(void)\n{\n\tconst struct cred *cred = current_cred();\n\tstatic long old_max;\n\tstruct file *f;\n\tint error;\n\n\t/*\n\t * Privileged users can go above max_files\n\t */\n\tif (get_nr_files() >= files_stat.max_files && !capable(CAP_SYS_ADMIN)) {\n\t\t/*\n\t\t * percpu_counters are inaccurate.  Do an expensive check before\n\t\t * we go and fail.\n\t\t */\n\t\tif (percpu_counter_sum_positive(&nr_files) >= files_stat.max_files)\n\t\t\tgoto over;\n\t}\n\n\tf = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);\n\tif (unlikely(!f))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpercpu_counter_inc(&nr_files);\n\tf->f_cred = get_cred(cred);\n\terror = security_file_alloc(f);\n\tif (unlikely(error)) {\n\t\tfile_free(f);\n\t\treturn ERR_PTR(error);\n\t}\n\n\tatomic_long_set(&f->f_count, 1);\n\trwlock_init(&f->f_owner.lock);\n\tspin_lock_init(&f->f_lock);\n\tmutex_init(&f->f_pos_lock);\n\teventpoll_init_file(f);\n\t/* f->f_version: 0 */\n\treturn f;\n\nover:\n\t/* Ran out of filps - report that */\n\tif (get_nr_files() > old_max) {\n\t\tpr_info(\"VFS: file-max limit %lu reached\\n\", get_max_files());\n\t\told_max = get_nr_files();\n\t}\n\treturn ERR_PTR(-ENFILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!path->mnt"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_creds",
          "args": [
            "cred"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = get_empty_filp();\n\tif (!IS_ERR(f)) {\n\t\tf->f_flags = flags;\n\t\terror = vfs_open(path, f, cred);\n\t\tif (!error) {\n\t\t\t/* from now on we need fput() to dispose of f */\n\t\t\terror = open_check_o_direct(f);\n\t\t\tif (error) {\n\t\t\t\tfput(f);\n\t\t\t\tf = ERR_PTR(error);\n\t\t\t}\n\t\t} else { \n\t\t\tput_filp(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}"
  },
  {
    "function_name": "finish_no_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
    "lines": "814-818",
    "snippet": "int finish_no_open(struct file *file, struct dentry *dentry)\n{\n\tfile->f_path.dentry = dentry;\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint finish_no_open(struct file *file, struct dentry *dentry)\n{\n\tfile->f_path.dentry = dentry;\n\treturn 1;\n}"
  },
  {
    "function_name": "finish_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
    "lines": "784-797",
    "snippet": "int finish_open(struct file *file, struct dentry *dentry,\n\t\tint (*open)(struct inode *, struct file *),\n\t\tint *opened)\n{\n\tint error;\n\tBUG_ON(*opened & FILE_OPENED); /* once it's opened, it's opened */\n\n\tfile->f_path.dentry = dentry;\n\terror = do_dentry_open(file, open, current_cred());\n\tif (!error)\n\t\t*opened |= FILE_OPENED;\n\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_dentry_open",
          "args": [
            "file",
            "open",
            "current_cred()"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "do_dentry_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "676-761",
          "snippet": "static int do_dentry_open(struct file *f,\n\t\t\t  int (*open)(struct inode *, struct file *),\n\t\t\t  const struct cred *cred)\n{\n\tstatic const struct file_operations empty_fops = {};\n\tstruct inode *inode;\n\tint error;\n\n\tf->f_mode = OPEN_FMODE(f->f_flags) | FMODE_LSEEK |\n\t\t\t\tFMODE_PREAD | FMODE_PWRITE;\n\n\tpath_get(&f->f_path);\n\tinode = f->f_inode = f->f_path.dentry->d_inode;\n\tf->f_mapping = inode->i_mapping;\n\n\tif (unlikely(f->f_flags & O_PATH)) {\n\t\tf->f_mode = FMODE_PATH;\n\t\tf->f_op = &empty_fops;\n\t\treturn 0;\n\t}\n\n\tif (f->f_mode & FMODE_WRITE && !special_file(inode->i_mode)) {\n\t\terror = get_write_access(inode);\n\t\tif (unlikely(error))\n\t\t\tgoto cleanup_file;\n\t\terror = __mnt_want_write(f->f_path.mnt);\n\t\tif (unlikely(error)) {\n\t\t\tput_write_access(inode);\n\t\t\tgoto cleanup_file;\n\t\t}\n\t\tf->f_mode |= FMODE_WRITER;\n\t}\n\n\t/* POSIX.1-2008/SUSv4 Section XSI 2.9.7 */\n\tif (S_ISREG(inode->i_mode))\n\t\tf->f_mode |= FMODE_ATOMIC_POS;\n\n\tf->f_op = fops_get(inode->i_fop);\n\tif (unlikely(WARN_ON(!f->f_op))) {\n\t\terror = -ENODEV;\n\t\tgoto cleanup_all;\n\t}\n\n\terror = security_file_open(f, cred);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\terror = break_lease(inode, f->f_flags);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\tif (!open)\n\t\topen = f->f_op->open;\n\tif (open) {\n\t\terror = open(inode, f);\n\t\tif (error)\n\t\t\tgoto cleanup_all;\n\t}\n\tif ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(inode);\n\tif ((f->f_mode & FMODE_READ) &&\n\t     likely(f->f_op->read || f->f_op->aio_read || f->f_op->read_iter))\n\t\tf->f_mode |= FMODE_CAN_READ;\n\tif ((f->f_mode & FMODE_WRITE) &&\n\t     likely(f->f_op->write || f->f_op->aio_write || f->f_op->write_iter))\n\t\tf->f_mode |= FMODE_CAN_WRITE;\n\n\tf->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);\n\n\tfile_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);\n\n\treturn 0;\n\ncleanup_all:\n\tfops_put(f->f_op);\n\tif (f->f_mode & FMODE_WRITER) {\n\t\tput_write_access(inode);\n\t\t__mnt_drop_write(f->f_path.mnt);\n\t}\ncleanup_file:\n\tpath_put(&f->f_path);\n\tf->f_path.mnt = NULL;\n\tf->f_path.dentry = NULL;\n\tf->f_inode = NULL;\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic int do_dentry_open(struct file *f,\n\t\t\t  int (*open)(struct inode *, struct file *),\n\t\t\t  const struct cred *cred)\n{\n\tstatic const struct file_operations empty_fops = {};\n\tstruct inode *inode;\n\tint error;\n\n\tf->f_mode = OPEN_FMODE(f->f_flags) | FMODE_LSEEK |\n\t\t\t\tFMODE_PREAD | FMODE_PWRITE;\n\n\tpath_get(&f->f_path);\n\tinode = f->f_inode = f->f_path.dentry->d_inode;\n\tf->f_mapping = inode->i_mapping;\n\n\tif (unlikely(f->f_flags & O_PATH)) {\n\t\tf->f_mode = FMODE_PATH;\n\t\tf->f_op = &empty_fops;\n\t\treturn 0;\n\t}\n\n\tif (f->f_mode & FMODE_WRITE && !special_file(inode->i_mode)) {\n\t\terror = get_write_access(inode);\n\t\tif (unlikely(error))\n\t\t\tgoto cleanup_file;\n\t\terror = __mnt_want_write(f->f_path.mnt);\n\t\tif (unlikely(error)) {\n\t\t\tput_write_access(inode);\n\t\t\tgoto cleanup_file;\n\t\t}\n\t\tf->f_mode |= FMODE_WRITER;\n\t}\n\n\t/* POSIX.1-2008/SUSv4 Section XSI 2.9.7 */\n\tif (S_ISREG(inode->i_mode))\n\t\tf->f_mode |= FMODE_ATOMIC_POS;\n\n\tf->f_op = fops_get(inode->i_fop);\n\tif (unlikely(WARN_ON(!f->f_op))) {\n\t\terror = -ENODEV;\n\t\tgoto cleanup_all;\n\t}\n\n\terror = security_file_open(f, cred);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\terror = break_lease(inode, f->f_flags);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\tif (!open)\n\t\topen = f->f_op->open;\n\tif (open) {\n\t\terror = open(inode, f);\n\t\tif (error)\n\t\t\tgoto cleanup_all;\n\t}\n\tif ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(inode);\n\tif ((f->f_mode & FMODE_READ) &&\n\t     likely(f->f_op->read || f->f_op->aio_read || f->f_op->read_iter))\n\t\tf->f_mode |= FMODE_CAN_READ;\n\tif ((f->f_mode & FMODE_WRITE) &&\n\t     likely(f->f_op->write || f->f_op->aio_write || f->f_op->write_iter))\n\t\tf->f_mode |= FMODE_CAN_WRITE;\n\n\tf->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);\n\n\tfile_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);\n\n\treturn 0;\n\ncleanup_all:\n\tfops_put(f->f_op);\n\tif (f->f_mode & FMODE_WRITER) {\n\t\tput_write_access(inode);\n\t\t__mnt_drop_write(f->f_path.mnt);\n\t}\ncleanup_file:\n\tpath_put(&f->f_path);\n\tf->f_path.mnt = NULL;\n\tf->f_path.dentry = NULL;\n\tf->f_inode = NULL;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "*opened & FILE_OPENED"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint finish_open(struct file *file, struct dentry *dentry,\n\t\tint (*open)(struct inode *, struct file *),\n\t\tint *opened)\n{\n\tint error;\n\tBUG_ON(*opened & FILE_OPENED); /* once it's opened, it's opened */\n\n\tfile->f_path.dentry = dentry;\n\terror = do_dentry_open(file, open, current_cred());\n\tif (!error)\n\t\t*opened |= FILE_OPENED;\n\n\treturn error;\n}"
  },
  {
    "function_name": "do_dentry_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
    "lines": "676-761",
    "snippet": "static int do_dentry_open(struct file *f,\n\t\t\t  int (*open)(struct inode *, struct file *),\n\t\t\t  const struct cred *cred)\n{\n\tstatic const struct file_operations empty_fops = {};\n\tstruct inode *inode;\n\tint error;\n\n\tf->f_mode = OPEN_FMODE(f->f_flags) | FMODE_LSEEK |\n\t\t\t\tFMODE_PREAD | FMODE_PWRITE;\n\n\tpath_get(&f->f_path);\n\tinode = f->f_inode = f->f_path.dentry->d_inode;\n\tf->f_mapping = inode->i_mapping;\n\n\tif (unlikely(f->f_flags & O_PATH)) {\n\t\tf->f_mode = FMODE_PATH;\n\t\tf->f_op = &empty_fops;\n\t\treturn 0;\n\t}\n\n\tif (f->f_mode & FMODE_WRITE && !special_file(inode->i_mode)) {\n\t\terror = get_write_access(inode);\n\t\tif (unlikely(error))\n\t\t\tgoto cleanup_file;\n\t\terror = __mnt_want_write(f->f_path.mnt);\n\t\tif (unlikely(error)) {\n\t\t\tput_write_access(inode);\n\t\t\tgoto cleanup_file;\n\t\t}\n\t\tf->f_mode |= FMODE_WRITER;\n\t}\n\n\t/* POSIX.1-2008/SUSv4 Section XSI 2.9.7 */\n\tif (S_ISREG(inode->i_mode))\n\t\tf->f_mode |= FMODE_ATOMIC_POS;\n\n\tf->f_op = fops_get(inode->i_fop);\n\tif (unlikely(WARN_ON(!f->f_op))) {\n\t\terror = -ENODEV;\n\t\tgoto cleanup_all;\n\t}\n\n\terror = security_file_open(f, cred);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\terror = break_lease(inode, f->f_flags);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\tif (!open)\n\t\topen = f->f_op->open;\n\tif (open) {\n\t\terror = open(inode, f);\n\t\tif (error)\n\t\t\tgoto cleanup_all;\n\t}\n\tif ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(inode);\n\tif ((f->f_mode & FMODE_READ) &&\n\t     likely(f->f_op->read || f->f_op->aio_read || f->f_op->read_iter))\n\t\tf->f_mode |= FMODE_CAN_READ;\n\tif ((f->f_mode & FMODE_WRITE) &&\n\t     likely(f->f_op->write || f->f_op->aio_write || f->f_op->write_iter))\n\t\tf->f_mode |= FMODE_CAN_WRITE;\n\n\tf->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);\n\n\tfile_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);\n\n\treturn 0;\n\ncleanup_all:\n\tfops_put(f->f_op);\n\tif (f->f_mode & FMODE_WRITER) {\n\t\tput_write_access(inode);\n\t\t__mnt_drop_write(f->f_path.mnt);\n\t}\ncleanup_file:\n\tpath_put(&f->f_path);\n\tf->f_path.mnt = NULL;\n\tf->f_path.dentry = NULL;\n\tf->f_inode = NULL;\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&f->f_path"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mnt_drop_write",
          "args": [
            "f->f_path.mnt"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "__mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "482-485",
          "snippet": "void __mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid __mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_write_access",
          "args": [
            "inode"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fops_put",
          "args": [
            "f->f_op"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_ra_state_init",
          "args": [
            "&f->f_ra",
            "f->f_mapping->host->i_mapping"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "f->f_op->write || f->f_op->aio_write || f->f_op->write_iter"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "f->f_op->read || f->f_op->aio_read || f->f_op->read_iter"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_readcount_inc",
          "args": [
            "inode"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "inode",
            "f"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "nonseekable_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "1136-1140",
          "snippet": "int nonseekable_open(struct inode *inode, struct file *filp)\n{\n\tfilp->f_mode &= ~(FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint nonseekable_open(struct inode *inode, struct file *filp)\n{\n\tfilp->f_mode &= ~(FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "break_lease",
          "args": [
            "inode",
            "f->f_flags"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_open_break_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "661-669",
          "snippet": "static int nfsd_open_break_lease(struct inode *inode, int access)\n{\n\tunsigned int mode;\n\n\tif (access & NFSD_MAY_NOT_BREAK_LEASE)\n\t\treturn 0;\n\tmode = (access & NFSD_MAY_WRITE) ? O_WRONLY : O_RDONLY;\n\treturn break_lease(inode, mode | O_NONBLOCK);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int nfsd_open_break_lease(struct inode *inode, int access)\n{\n\tunsigned int mode;\n\n\tif (access & NFSD_MAY_NOT_BREAK_LEASE)\n\t\treturn 0;\n\tmode = (access & NFSD_MAY_WRITE) ? O_WRONLY : O_RDONLY;\n\treturn break_lease(inode, mode | O_NONBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_file_open",
          "args": [
            "f",
            "cred"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "WARN_ON(!f->f_op)"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!f->f_op"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fops_get",
          "args": [
            "inode->i_fop"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_write_access",
          "args": [
            "inode"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mnt_want_write",
          "args": [
            "f->f_path.mnt"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "__mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "425-431",
          "snippet": "int __mnt_want_write_file(struct file *file)\n{\n\tif (!(file->f_mode & FMODE_WRITER))\n\t\treturn __mnt_want_write(file->f_path.mnt);\n\telse\n\t\treturn mnt_clone_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint __mnt_want_write_file(struct file *file)\n{\n\tif (!(file->f_mode & FMODE_WRITER))\n\t\treturn __mnt_want_write(file->f_path.mnt);\n\telse\n\t\treturn mnt_clone_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_write_access",
          "args": [
            "inode"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "special_file",
          "args": [
            "inode->i_mode"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "f->f_flags & O_PATH"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_get",
          "args": [
            "&f->f_path"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "path_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "476-480",
          "snippet": "void path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OPEN_FMODE",
          "args": [
            "f->f_flags"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic int do_dentry_open(struct file *f,\n\t\t\t  int (*open)(struct inode *, struct file *),\n\t\t\t  const struct cred *cred)\n{\n\tstatic const struct file_operations empty_fops = {};\n\tstruct inode *inode;\n\tint error;\n\n\tf->f_mode = OPEN_FMODE(f->f_flags) | FMODE_LSEEK |\n\t\t\t\tFMODE_PREAD | FMODE_PWRITE;\n\n\tpath_get(&f->f_path);\n\tinode = f->f_inode = f->f_path.dentry->d_inode;\n\tf->f_mapping = inode->i_mapping;\n\n\tif (unlikely(f->f_flags & O_PATH)) {\n\t\tf->f_mode = FMODE_PATH;\n\t\tf->f_op = &empty_fops;\n\t\treturn 0;\n\t}\n\n\tif (f->f_mode & FMODE_WRITE && !special_file(inode->i_mode)) {\n\t\terror = get_write_access(inode);\n\t\tif (unlikely(error))\n\t\t\tgoto cleanup_file;\n\t\terror = __mnt_want_write(f->f_path.mnt);\n\t\tif (unlikely(error)) {\n\t\t\tput_write_access(inode);\n\t\t\tgoto cleanup_file;\n\t\t}\n\t\tf->f_mode |= FMODE_WRITER;\n\t}\n\n\t/* POSIX.1-2008/SUSv4 Section XSI 2.9.7 */\n\tif (S_ISREG(inode->i_mode))\n\t\tf->f_mode |= FMODE_ATOMIC_POS;\n\n\tf->f_op = fops_get(inode->i_fop);\n\tif (unlikely(WARN_ON(!f->f_op))) {\n\t\terror = -ENODEV;\n\t\tgoto cleanup_all;\n\t}\n\n\terror = security_file_open(f, cred);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\terror = break_lease(inode, f->f_flags);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\tif (!open)\n\t\topen = f->f_op->open;\n\tif (open) {\n\t\terror = open(inode, f);\n\t\tif (error)\n\t\t\tgoto cleanup_all;\n\t}\n\tif ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(inode);\n\tif ((f->f_mode & FMODE_READ) &&\n\t     likely(f->f_op->read || f->f_op->aio_read || f->f_op->read_iter))\n\t\tf->f_mode |= FMODE_CAN_READ;\n\tif ((f->f_mode & FMODE_WRITE) &&\n\t     likely(f->f_op->write || f->f_op->aio_write || f->f_op->write_iter))\n\t\tf->f_mode |= FMODE_CAN_WRITE;\n\n\tf->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);\n\n\tfile_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);\n\n\treturn 0;\n\ncleanup_all:\n\tfops_put(f->f_op);\n\tif (f->f_mode & FMODE_WRITER) {\n\t\tput_write_access(inode);\n\t\t__mnt_drop_write(f->f_path.mnt);\n\t}\ncleanup_file:\n\tpath_put(&f->f_path);\n\tf->f_path.mnt = NULL;\n\tf->f_path.dentry = NULL;\n\tf->f_inode = NULL;\n\treturn error;\n}"
  },
  {
    "function_name": "open_check_o_direct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
    "lines": "666-674",
    "snippet": "int open_check_o_direct(struct file *f)\n{\n\t/* NB: we're sure to have correct a_ops only after f_op->open */\n\tif (f->f_flags & O_DIRECT) {\n\t\tif (!f->f_mapping->a_ops || !f->f_mapping->a_ops->direct_IO)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint open_check_o_direct(struct file *f)\n{\n\t/* NB: we're sure to have correct a_ops only after f_op->open */\n\tif (f->f_flags & O_DIRECT) {\n\t\tif (!f->f_mapping->a_ops || !f->f_mapping->a_ops->direct_IO)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "chown_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
    "lines": "561-601",
    "snippet": "static int chown_common(struct path *path, uid_t user, gid_t group)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\tint error;\n\tstruct iattr newattrs;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tuid = make_kuid(current_user_ns(), user);\n\tgid = make_kgid(current_user_ns(), group);\n\n\tnewattrs.ia_valid =  ATTR_CTIME;\n\tif (user != (uid_t) -1) {\n\t\tif (!uid_valid(uid))\n\t\t\treturn -EINVAL;\n\t\tnewattrs.ia_valid |= ATTR_UID;\n\t\tnewattrs.ia_uid = uid;\n\t}\n\tif (group != (gid_t) -1) {\n\t\tif (!gid_valid(gid))\n\t\t\treturn -EINVAL;\n\t\tnewattrs.ia_valid |= ATTR_GID;\n\t\tnewattrs.ia_gid = gid;\n\t}\n\tif (!S_ISDIR(inode->i_mode))\n\t\tnewattrs.ia_valid |=\n\t\t\tATTR_KILL_SUID | ATTR_KILL_SGID | ATTR_KILL_PRIV;\nretry_deleg:\n\tmutex_lock(&inode->i_mutex);\n\terror = security_path_chown(path, uid, gid);\n\tif (!error)\n\t\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\n\tmutex_unlock(&inode->i_mutex);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "break_deleg_wait",
          "args": [
            "&delegated_inode"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_change",
          "args": [
            "path->dentry",
            "&newattrs",
            "&delegated_inode"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "notify_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "190-277",
          "snippet": "int notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_path_chown",
          "args": [
            "path",
            "uid",
            "gid"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "gid"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "uid"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "group"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "user"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic int chown_common(struct path *path, uid_t user, gid_t group)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\tint error;\n\tstruct iattr newattrs;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tuid = make_kuid(current_user_ns(), user);\n\tgid = make_kgid(current_user_ns(), group);\n\n\tnewattrs.ia_valid =  ATTR_CTIME;\n\tif (user != (uid_t) -1) {\n\t\tif (!uid_valid(uid))\n\t\t\treturn -EINVAL;\n\t\tnewattrs.ia_valid |= ATTR_UID;\n\t\tnewattrs.ia_uid = uid;\n\t}\n\tif (group != (gid_t) -1) {\n\t\tif (!gid_valid(gid))\n\t\t\treturn -EINVAL;\n\t\tnewattrs.ia_valid |= ATTR_GID;\n\t\tnewattrs.ia_gid = gid;\n\t}\n\tif (!S_ISDIR(inode->i_mode))\n\t\tnewattrs.ia_valid |=\n\t\t\tATTR_KILL_SUID | ATTR_KILL_SGID | ATTR_KILL_PRIV;\nretry_deleg:\n\tmutex_lock(&inode->i_mutex);\n\terror = security_path_chown(path, uid, gid);\n\tif (!error)\n\t\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\n\tmutex_unlock(&inode->i_mutex);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "chmod_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
    "lines": "496-523",
    "snippet": "static int chmod_common(struct path *path, umode_t mode)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\tstruct iattr newattrs;\n\tint error;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\treturn error;\nretry_deleg:\n\tmutex_lock(&inode->i_mutex);\n\terror = security_path_chmod(path, mode);\n\tif (error)\n\t\tgoto out_unlock;\n\tnewattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);\n\tnewattrs.ia_valid = ATTR_MODE | ATTR_CTIME;\n\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\nout_unlock:\n\tmutex_unlock(&inode->i_mutex);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tmnt_drop_write(path->mnt);\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write",
          "args": [
            "path->mnt"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "break_deleg_wait",
          "args": [
            "&delegated_inode"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_change",
          "args": [
            "path->dentry",
            "&newattrs",
            "&delegated_inode"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "notify_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "190-277",
          "snippet": "int notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_path_chmod",
          "args": [
            "path",
            "mode"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_want_write",
          "args": [
            "path->mnt"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic int chmod_common(struct path *path, umode_t mode)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\tstruct inode *delegated_inode = NULL;\n\tstruct iattr newattrs;\n\tint error;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\treturn error;\nretry_deleg:\n\tmutex_lock(&inode->i_mutex);\n\terror = security_path_chmod(path, mode);\n\tif (error)\n\t\tgoto out_unlock;\n\tnewattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);\n\tnewattrs.ia_valid = ATTR_MODE | ATTR_CTIME;\n\terror = notify_change(path->dentry, &newattrs, &delegated_inode);\nout_unlock:\n\tmutex_unlock(&inode->i_mutex);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tmnt_drop_write(path->mnt);\n\treturn error;\n}"
  },
  {
    "function_name": "vfs_fallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
    "lines": "225-311",
    "snippet": "int vfs_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tlong ret;\n\n\tif (offset < 0 || len <= 0)\n\t\treturn -EINVAL;\n\n\t/* Return error if mode is not supported */\n\tif (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |\n\t\t     FALLOC_FL_COLLAPSE_RANGE | FALLOC_FL_ZERO_RANGE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Punch hole and zero range are mutually exclusive */\n\tif ((mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)) ==\n\t    (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Punch hole must have keep size set */\n\tif ((mode & FALLOC_FL_PUNCH_HOLE) &&\n\t    !(mode & FALLOC_FL_KEEP_SIZE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Collapse range should only be used exclusively. */\n\tif ((mode & FALLOC_FL_COLLAPSE_RANGE) &&\n\t    (mode & ~FALLOC_FL_COLLAPSE_RANGE))\n\t\treturn -EINVAL;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\t/*\n\t * We can only allow pure fallocate on append only files\n\t */\n\tif ((mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode))\n\t\treturn -EPERM;\n\n\tif (IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\t/*\n\t * We cannot allow any fallocate operation on an active swapfile\n\t */\n\tif (IS_SWAPFILE(inode))\n\t\treturn -ETXTBSY;\n\n\t/*\n\t * Revalidate the write permissions, in case security policy has\n\t * changed since the files were opened.\n\t */\n\tret = security_file_permission(file, MAY_WRITE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (S_ISFIFO(inode->i_mode))\n\t\treturn -ESPIPE;\n\n\t/*\n\t * Let individual file system decide if it supports preallocation\n\t * for directories or not.\n\t */\n\tif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\treturn -ENODEV;\n\n\t/* Check for wrap through zero too */\n\tif (((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0))\n\t\treturn -EFBIG;\n\n\tif (!file->f_op->fallocate)\n\t\treturn -EOPNOTSUPP;\n\n\tsb_start_write(inode->i_sb);\n\tret = file->f_op->fallocate(file, mode, offset, len);\n\n\t/*\n\t * Create inotify and fanotify events.\n\t *\n\t * To keep the logic simple always create events if fallocate succeeds.\n\t * This implies that events are even created if the file size remains\n\t * unchanged, e.g. when using flag FALLOC_FL_KEEP_SIZE.\n\t */\n\tif (ret == 0)\n\t\tfsnotify_modify(file);\n\n\tsb_end_write(inode->i_sb);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_end_write",
          "args": [
            "inode->i_sb"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_modify",
          "args": [
            "file"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file->f_op->fallocate",
          "args": [
            "file",
            "mode",
            "offset",
            "len"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_start_write",
          "args": [
            "inode->i_sb"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "inode->i_mode"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_file_permission",
          "args": [
            "file",
            "MAY_WRITE"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SWAPFILE",
          "args": [
            "inode"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "inode"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "inode"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint vfs_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tlong ret;\n\n\tif (offset < 0 || len <= 0)\n\t\treturn -EINVAL;\n\n\t/* Return error if mode is not supported */\n\tif (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |\n\t\t     FALLOC_FL_COLLAPSE_RANGE | FALLOC_FL_ZERO_RANGE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Punch hole and zero range are mutually exclusive */\n\tif ((mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)) ==\n\t    (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Punch hole must have keep size set */\n\tif ((mode & FALLOC_FL_PUNCH_HOLE) &&\n\t    !(mode & FALLOC_FL_KEEP_SIZE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Collapse range should only be used exclusively. */\n\tif ((mode & FALLOC_FL_COLLAPSE_RANGE) &&\n\t    (mode & ~FALLOC_FL_COLLAPSE_RANGE))\n\t\treturn -EINVAL;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\t/*\n\t * We can only allow pure fallocate on append only files\n\t */\n\tif ((mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode))\n\t\treturn -EPERM;\n\n\tif (IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\t/*\n\t * We cannot allow any fallocate operation on an active swapfile\n\t */\n\tif (IS_SWAPFILE(inode))\n\t\treturn -ETXTBSY;\n\n\t/*\n\t * Revalidate the write permissions, in case security policy has\n\t * changed since the files were opened.\n\t */\n\tret = security_file_permission(file, MAY_WRITE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (S_ISFIFO(inode->i_mode))\n\t\treturn -ESPIPE;\n\n\t/*\n\t * Let individual file system decide if it supports preallocation\n\t * for directories or not.\n\t */\n\tif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\treturn -ENODEV;\n\n\t/* Check for wrap through zero too */\n\tif (((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0))\n\t\treturn -EFBIG;\n\n\tif (!file->f_op->fallocate)\n\t\treturn -EOPNOTSUPP;\n\n\tsb_start_write(inode->i_sb);\n\tret = file->f_op->fallocate(file, mode, offset, len);\n\n\t/*\n\t * Create inotify and fanotify events.\n\t *\n\t * To keep the logic simple always create events if fallocate succeeds.\n\t * This implies that events are even created if the file size remains\n\t * unchanged, e.g. when using flag FALLOC_FL_KEEP_SIZE.\n\t */\n\tif (ret == 0)\n\t\tfsnotify_modify(file);\n\n\tsb_end_write(inode->i_sb);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_sys_ftruncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
    "lines": "152-197",
    "snippet": "static long do_sys_ftruncate(unsigned int fd, loff_t length, int small)\n{\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tstruct fd f;\n\tint error;\n\n\terror = -EINVAL;\n\tif (length < 0)\n\t\tgoto out;\n\terror = -EBADF;\n\tf = fdget(fd);\n\tif (!f.file)\n\t\tgoto out;\n\n\t/* explicitly opened as large or we are on 64-bit box */\n\tif (f.file->f_flags & O_LARGEFILE)\n\t\tsmall = 0;\n\n\tdentry = f.file->f_path.dentry;\n\tinode = dentry->d_inode;\n\terror = -EINVAL;\n\tif (!S_ISREG(inode->i_mode) || !(f.file->f_mode & FMODE_WRITE))\n\t\tgoto out_putf;\n\n\terror = -EINVAL;\n\t/* Cannot ftruncate over 2^31 bytes without large file support */\n\tif (small && length > MAX_NON_LFS)\n\t\tgoto out_putf;\n\n\terror = -EPERM;\n\tif (IS_APPEND(inode))\n\t\tgoto out_putf;\n\n\tsb_start_write(inode->i_sb);\n\terror = locks_verify_truncate(inode, f.file, length);\n\tif (!error)\n\t\terror = security_path_truncate(&f.file->f_path);\n\tif (!error)\n\t\terror = do_truncate(dentry, length, ATTR_MTIME|ATTR_CTIME, f.file);\n\tsb_end_write(inode->i_sb);\nout_putf:\n\tfdput(f);\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "fdput_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "273-278",
          "snippet": "static inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_end_write",
          "args": [
            "inode->i_sb"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_truncate",
          "args": [
            "dentry",
            "length",
            "ATTR_MTIME|ATTR_CTIME",
            "f.file"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "do_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "37-64",
          "snippet": "int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint ret;\n\tstruct iattr newattrs;\n\n\t/* Not pretty: \"inode->i_size\" shouldn't really be signed. But it is. */\n\tif (length < 0)\n\t\treturn -EINVAL;\n\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\n\t/* Remove suid/sgid on truncate too */\n\tret = should_remove_suid(dentry);\n\tif (ret)\n\t\tnewattrs.ia_valid |= ret | ATTR_FORCE;\n\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\t/* Note any delegations or leases have already been broken: */\n\tret = notify_change(dentry, &newattrs, NULL);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint ret;\n\tstruct iattr newattrs;\n\n\t/* Not pretty: \"inode->i_size\" shouldn't really be signed. But it is. */\n\tif (length < 0)\n\t\treturn -EINVAL;\n\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\n\t/* Remove suid/sgid on truncate too */\n\tret = should_remove_suid(dentry);\n\tif (ret)\n\t\tnewattrs.ia_valid |= ret | ATTR_FORCE;\n\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\t/* Note any delegations or leases have already been broken: */\n\tret = notify_change(dentry, &newattrs, NULL);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_path_truncate",
          "args": [
            "&f.file->f_path"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_verify_truncate",
          "args": [
            "inode",
            "f.file",
            "length"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_start_write",
          "args": [
            "inode->i_sb"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "inode"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "706-718",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic long do_sys_ftruncate(unsigned int fd, loff_t length, int small)\n{\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tstruct fd f;\n\tint error;\n\n\terror = -EINVAL;\n\tif (length < 0)\n\t\tgoto out;\n\terror = -EBADF;\n\tf = fdget(fd);\n\tif (!f.file)\n\t\tgoto out;\n\n\t/* explicitly opened as large or we are on 64-bit box */\n\tif (f.file->f_flags & O_LARGEFILE)\n\t\tsmall = 0;\n\n\tdentry = f.file->f_path.dentry;\n\tinode = dentry->d_inode;\n\terror = -EINVAL;\n\tif (!S_ISREG(inode->i_mode) || !(f.file->f_mode & FMODE_WRITE))\n\t\tgoto out_putf;\n\n\terror = -EINVAL;\n\t/* Cannot ftruncate over 2^31 bytes without large file support */\n\tif (small && length > MAX_NON_LFS)\n\t\tgoto out_putf;\n\n\terror = -EPERM;\n\tif (IS_APPEND(inode))\n\t\tgoto out_putf;\n\n\tsb_start_write(inode->i_sb);\n\terror = locks_verify_truncate(inode, f.file, length);\n\tif (!error)\n\t\terror = security_path_truncate(&f.file->f_path);\n\tif (!error)\n\t\terror = do_truncate(dentry, length, ATTR_MTIME|ATTR_CTIME, f.file);\n\tsb_end_write(inode->i_sb);\nout_putf:\n\tfdput(f);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "do_sys_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
    "lines": "118-138",
    "snippet": "static long do_sys_truncate(const char __user *pathname, loff_t length)\n{\n\tunsigned int lookup_flags = LOOKUP_FOLLOW;\n\tstruct path path;\n\tint error;\n\n\tif (length < 0)\t/* sorry, but loff_t says... */\n\t\treturn -EINVAL;\n\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (!error) {\n\t\terror = vfs_truncate(&path, length);\n\t\tpath_put(&path);\n\t}\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retry_estale",
          "args": [
            "error",
            "lookup_flags"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_truncate",
          "args": [
            "&path",
            "length"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "66-115",
          "snippet": "long vfs_truncate(struct path *path, loff_t length)\n{\n\tstruct inode *inode;\n\tlong error;\n\n\tinode = path->dentry->d_inode;\n\n\t/* For directories it's -EISDIR, for other non-regulars - -EINVAL */\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\tgoto out;\n\n\terror = inode_permission(inode, MAY_WRITE);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = -EPERM;\n\tif (IS_APPEND(inode))\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = get_write_access(inode);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\t/*\n\t * Make sure that there are no leases.  get_write_access() protects\n\t * against the truncate racing with a lease-granting setlease().\n\t */\n\terror = break_lease(inode, O_WRONLY);\n\tif (error)\n\t\tgoto put_write_and_out;\n\n\terror = locks_verify_truncate(inode, NULL, length);\n\tif (!error)\n\t\terror = security_path_truncate(path);\n\tif (!error)\n\t\terror = do_truncate(path->dentry, length, 0, NULL);\n\nput_write_and_out:\n\tput_write_access(inode);\nmnt_drop_write_and_out:\n\tmnt_drop_write(path->mnt);\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nlong vfs_truncate(struct path *path, loff_t length)\n{\n\tstruct inode *inode;\n\tlong error;\n\n\tinode = path->dentry->d_inode;\n\n\t/* For directories it's -EISDIR, for other non-regulars - -EINVAL */\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\tgoto out;\n\n\terror = inode_permission(inode, MAY_WRITE);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = -EPERM;\n\tif (IS_APPEND(inode))\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = get_write_access(inode);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\t/*\n\t * Make sure that there are no leases.  get_write_access() protects\n\t * against the truncate racing with a lease-granting setlease().\n\t */\n\terror = break_lease(inode, O_WRONLY);\n\tif (error)\n\t\tgoto put_write_and_out;\n\n\terror = locks_verify_truncate(inode, NULL, length);\n\tif (!error)\n\t\terror = security_path_truncate(path);\n\tif (!error)\n\t\terror = do_truncate(path->dentry, length, 0, NULL);\n\nput_write_and_out:\n\tput_write_access(inode);\nmnt_drop_write_and_out:\n\tmnt_drop_write(path->mnt);\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_path_at",
          "args": [
            "AT_FDCWD",
            "pathname",
            "lookup_flags",
            "&path"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "user_path_at",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2205-2209",
          "snippet": "int user_path_at(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path)\n{\n\treturn user_path_at_empty(dfd, name, flags, path, NULL);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint user_path_at(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path)\n{\n\treturn user_path_at_empty(dfd, name, flags, path, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstatic long do_sys_truncate(const char __user *pathname, loff_t length)\n{\n\tunsigned int lookup_flags = LOOKUP_FOLLOW;\n\tstruct path path;\n\tint error;\n\n\tif (length < 0)\t/* sorry, but loff_t says... */\n\t\treturn -EINVAL;\n\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (!error) {\n\t\terror = vfs_truncate(&path, length);\n\t\tpath_put(&path);\n\t}\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "vfs_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
    "lines": "66-115",
    "snippet": "long vfs_truncate(struct path *path, loff_t length)\n{\n\tstruct inode *inode;\n\tlong error;\n\n\tinode = path->dentry->d_inode;\n\n\t/* For directories it's -EISDIR, for other non-regulars - -EINVAL */\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\tgoto out;\n\n\terror = inode_permission(inode, MAY_WRITE);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = -EPERM;\n\tif (IS_APPEND(inode))\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = get_write_access(inode);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\t/*\n\t * Make sure that there are no leases.  get_write_access() protects\n\t * against the truncate racing with a lease-granting setlease().\n\t */\n\terror = break_lease(inode, O_WRONLY);\n\tif (error)\n\t\tgoto put_write_and_out;\n\n\terror = locks_verify_truncate(inode, NULL, length);\n\tif (!error)\n\t\terror = security_path_truncate(path);\n\tif (!error)\n\t\terror = do_truncate(path->dentry, length, 0, NULL);\n\nput_write_and_out:\n\tput_write_access(inode);\nmnt_drop_write_and_out:\n\tmnt_drop_write(path->mnt);\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write",
          "args": [
            "path->mnt"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_write_access",
          "args": [
            "inode"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_truncate",
          "args": [
            "path->dentry",
            "length",
            "0",
            "NULL"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "do_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "37-64",
          "snippet": "int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint ret;\n\tstruct iattr newattrs;\n\n\t/* Not pretty: \"inode->i_size\" shouldn't really be signed. But it is. */\n\tif (length < 0)\n\t\treturn -EINVAL;\n\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\n\t/* Remove suid/sgid on truncate too */\n\tret = should_remove_suid(dentry);\n\tif (ret)\n\t\tnewattrs.ia_valid |= ret | ATTR_FORCE;\n\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\t/* Note any delegations or leases have already been broken: */\n\tret = notify_change(dentry, &newattrs, NULL);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint ret;\n\tstruct iattr newattrs;\n\n\t/* Not pretty: \"inode->i_size\" shouldn't really be signed. But it is. */\n\tif (length < 0)\n\t\treturn -EINVAL;\n\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\n\t/* Remove suid/sgid on truncate too */\n\tret = should_remove_suid(dentry);\n\tif (ret)\n\t\tnewattrs.ia_valid |= ret | ATTR_FORCE;\n\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\t/* Note any delegations or leases have already been broken: */\n\tret = notify_change(dentry, &newattrs, NULL);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_path_truncate",
          "args": [
            "path"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_verify_truncate",
          "args": [
            "inode",
            "NULL",
            "length"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "break_lease",
          "args": [
            "inode",
            "O_WRONLY"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_open_break_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "661-669",
          "snippet": "static int nfsd_open_break_lease(struct inode *inode, int access)\n{\n\tunsigned int mode;\n\n\tif (access & NFSD_MAY_NOT_BREAK_LEASE)\n\t\treturn 0;\n\tmode = (access & NFSD_MAY_WRITE) ? O_WRONLY : O_RDONLY;\n\treturn break_lease(inode, mode | O_NONBLOCK);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int nfsd_open_break_lease(struct inode *inode, int access)\n{\n\tunsigned int mode;\n\n\tif (access & NFSD_MAY_NOT_BREAK_LEASE)\n\t\treturn 0;\n\tmode = (access & NFSD_MAY_WRITE) ? O_WRONLY : O_RDONLY;\n\treturn break_lease(inode, mode | O_NONBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_write_access",
          "args": [
            "inode"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "inode"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "inode",
            "MAY_WRITE"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "inode_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "459-467",
          "snippet": "int inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write",
          "args": [
            "path->mnt"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nlong vfs_truncate(struct path *path, loff_t length)\n{\n\tstruct inode *inode;\n\tlong error;\n\n\tinode = path->dentry->d_inode;\n\n\t/* For directories it's -EISDIR, for other non-regulars - -EINVAL */\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\tgoto out;\n\n\terror = inode_permission(inode, MAY_WRITE);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = -EPERM;\n\tif (IS_APPEND(inode))\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = get_write_access(inode);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\t/*\n\t * Make sure that there are no leases.  get_write_access() protects\n\t * against the truncate racing with a lease-granting setlease().\n\t */\n\terror = break_lease(inode, O_WRONLY);\n\tif (error)\n\t\tgoto put_write_and_out;\n\n\terror = locks_verify_truncate(inode, NULL, length);\n\tif (!error)\n\t\terror = security_path_truncate(path);\n\tif (!error)\n\t\terror = do_truncate(path->dentry, length, 0, NULL);\n\nput_write_and_out:\n\tput_write_access(inode);\nmnt_drop_write_and_out:\n\tmnt_drop_write(path->mnt);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "do_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
    "lines": "37-64",
    "snippet": "int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint ret;\n\tstruct iattr newattrs;\n\n\t/* Not pretty: \"inode->i_size\" shouldn't really be signed. But it is. */\n\tif (length < 0)\n\t\treturn -EINVAL;\n\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\n\t/* Remove suid/sgid on truncate too */\n\tret = should_remove_suid(dentry);\n\tif (ret)\n\t\tnewattrs.ia_valid |= ret | ATTR_FORCE;\n\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\t/* Note any delegations or leases have already been broken: */\n\tret = notify_change(dentry, &newattrs, NULL);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/dnotify.h>",
      "#include <linux/ima.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/falloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/securebits.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/tty.h>",
      "#include <linux/module.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dentry->d_inode->i_mutex"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_change",
          "args": [
            "dentry",
            "&newattrs",
            "NULL"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "notify_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "190-277",
          "snippet": "int notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dentry->d_inode->i_mutex"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_remove_suid",
          "args": [
            "dentry"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "should_remove_suid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1640-1660",
          "snippet": "int should_remove_suid(struct dentry *dentry)\n{\n\tumode_t mode = dentry->d_inode->i_mode;\n\tint kill = 0;\n\n\t/* suid always must be killed */\n\tif (unlikely(mode & S_ISUID))\n\t\tkill = ATTR_KILL_SUID;\n\n\t/*\n\t * sgid without any exec bits is just a mandatory locking mark; leave\n\t * it alone.  If some exec bits are set, it's a real sgid; kill it.\n\t */\n\tif (unlikely((mode & S_ISGID) && (mode & S_IXGRP)))\n\t\tkill |= ATTR_KILL_SGID;\n\n\tif (unlikely(kill && !capable(CAP_FSETID) && S_ISREG(mode)))\n\t\treturn kill;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nint should_remove_suid(struct dentry *dentry)\n{\n\tumode_t mode = dentry->d_inode->i_mode;\n\tint kill = 0;\n\n\t/* suid always must be killed */\n\tif (unlikely(mode & S_ISUID))\n\t\tkill = ATTR_KILL_SUID;\n\n\t/*\n\t * sgid without any exec bits is just a mandatory locking mark; leave\n\t * it alone.  If some exec bits are set, it's a real sgid; kill it.\n\t */\n\tif (unlikely((mode & S_ISGID) && (mode & S_IXGRP)))\n\t\tkill |= ATTR_KILL_SGID;\n\n\tif (unlikely(kill && !capable(CAP_FSETID) && S_ISREG(mode)))\n\t\treturn kill;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint ret;\n\tstruct iattr newattrs;\n\n\t/* Not pretty: \"inode->i_size\" shouldn't really be signed. But it is. */\n\tif (length < 0)\n\t\treturn -EINVAL;\n\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\n\t/* Remove suid/sgid on truncate too */\n\tret = should_remove_suid(dentry);\n\tif (ret)\n\t\tnewattrs.ia_valid |= ret | ATTR_FORCE;\n\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\t/* Note any delegations or leases have already been broken: */\n\tret = notify_change(dentry, &newattrs, NULL);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\treturn ret;\n}"
  }
]