[
  {
    "function_name": "nfs_flock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "898-925",
    "snippet": "int nfs_flock(struct file *filp, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint is_local = 0;\n\n\tdprintk(\"NFS: flock(%pD2, t=%x, fl=%x)\\n\",\n\t\t\tfilp, fl->fl_type, fl->fl_flags);\n\n\tif (!(fl->fl_flags & FL_FLOCK))\n\t\treturn -ENOLCK;\n\n\t/*\n\t * The NFSv4 protocol doesn't support LOCK_MAND, which is not part of\n\t * any standard. In principle we might be able to support LOCK_MAND\n\t * on NFSv2/3 since NLMv3/4 support DOS share modes, but for now the\n\t * NFS code is not set up for it.\n\t */\n\tif (fl->fl_type & LOCK_MAND)\n\t\treturn -EINVAL;\n\n\tif (NFS_SERVER(inode)->flags & NFS_MOUNT_LOCAL_FLOCK)\n\t\tis_local = 1;\n\n\t/* We're simulating flock() locks using posix locks on the server */\n\tif (fl->fl_type == F_UNLCK)\n\t\treturn do_unlk(filp, cmd, fl, is_local);\n\treturn do_setlk(filp, cmd, fl, is_local);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_setlk",
          "args": [
            "filp",
            "cmd",
            "fl",
            "is_local"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "do_setlk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
          "lines": "813-854",
          "snippet": "static int\ndo_setlk(struct file *filp, int cmd, struct file_lock *fl, int is_local)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint status;\n\n\t/*\n\t * Flush all pending writes before doing anything\n\t * with locks..\n\t */\n\tstatus = nfs_sync_mapping(filp->f_mapping);\n\tif (status != 0)\n\t\tgoto out;\n\n\t/*\n\t * Use local locking if mounted with \"-onolock\" or with appropriate\n\t * \"-olocal_lock=\"\n\t */\n\tif (!is_local)\n\t\tstatus = NFS_PROTO(inode)->lock(filp, cmd, fl);\n\telse\n\t\tstatus = do_vfs_lock(filp, fl);\n\tif (status < 0)\n\t\tgoto out;\n\n\t/*\n\t * Revalidate the cache if the server has time stamps granular\n\t * enough to detect subsecond changes.  Otherwise, clear the\n\t * cache to prevent missing any changes.\n\t *\n\t * This makes locking act as a cache coherency point.\n\t */\n\tnfs_sync_mapping(filp->f_mapping);\n\tif (!NFS_PROTO(inode)->have_delegation(inode, FMODE_READ)) {\n\t\tif (is_time_granular(&NFS_SERVER(inode)->time_delta))\n\t\t\t__nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\t\telse\n\t\t\tnfs_zap_caches(inode);\n\t}\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/swap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int\ndo_setlk(struct file *filp, int cmd, struct file_lock *fl, int is_local)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint status;\n\n\t/*\n\t * Flush all pending writes before doing anything\n\t * with locks..\n\t */\n\tstatus = nfs_sync_mapping(filp->f_mapping);\n\tif (status != 0)\n\t\tgoto out;\n\n\t/*\n\t * Use local locking if mounted with \"-onolock\" or with appropriate\n\t * \"-olocal_lock=\"\n\t */\n\tif (!is_local)\n\t\tstatus = NFS_PROTO(inode)->lock(filp, cmd, fl);\n\telse\n\t\tstatus = do_vfs_lock(filp, fl);\n\tif (status < 0)\n\t\tgoto out;\n\n\t/*\n\t * Revalidate the cache if the server has time stamps granular\n\t * enough to detect subsecond changes.  Otherwise, clear the\n\t * cache to prevent missing any changes.\n\t *\n\t * This makes locking act as a cache coherency point.\n\t */\n\tnfs_sync_mapping(filp->f_mapping);\n\tif (!NFS_PROTO(inode)->have_delegation(inode, FMODE_READ)) {\n\t\tif (is_time_granular(&NFS_SERVER(inode)->time_delta))\n\t\t\t__nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\t\telse\n\t\t\tnfs_zap_caches(inode);\n\t}\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_unlk",
          "args": [
            "filp",
            "cmd",
            "fl",
            "is_local"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "do_unlk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
          "lines": "772-806",
          "snippet": "static int\ndo_unlk(struct file *filp, int cmd, struct file_lock *fl, int is_local)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tstruct nfs_lock_context *l_ctx;\n\tint status;\n\n\t/*\n\t * Flush all pending writes before doing anything\n\t * with locks..\n\t */\n\tnfs_sync_mapping(filp->f_mapping);\n\n\tl_ctx = nfs_get_lock_context(nfs_file_open_context(filp));\n\tif (!IS_ERR(l_ctx)) {\n\t\tstatus = nfs_iocounter_wait(&l_ctx->io_count);\n\t\tnfs_put_lock_context(l_ctx);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\t/* NOTE: special case\n\t * \tIf we're signalled while cleaning up locks on process exit, we\n\t * \tstill need to complete the unlock.\n\t */\n\t/*\n\t * Use local locking if mounted with \"-onolock\" or with appropriate\n\t * \"-olocal_lock=\"\n\t */\n\tif (!is_local)\n\t\tstatus = NFS_PROTO(inode)->lock(filp, cmd, fl);\n\telse\n\t\tstatus = do_vfs_lock(filp, fl);\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/swap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int\ndo_unlk(struct file *filp, int cmd, struct file_lock *fl, int is_local)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tstruct nfs_lock_context *l_ctx;\n\tint status;\n\n\t/*\n\t * Flush all pending writes before doing anything\n\t * with locks..\n\t */\n\tnfs_sync_mapping(filp->f_mapping);\n\n\tl_ctx = nfs_get_lock_context(nfs_file_open_context(filp));\n\tif (!IS_ERR(l_ctx)) {\n\t\tstatus = nfs_iocounter_wait(&l_ctx->io_count);\n\t\tnfs_put_lock_context(l_ctx);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\t/* NOTE: special case\n\t * \tIf we're signalled while cleaning up locks on process exit, we\n\t * \tstill need to complete the unlock.\n\t */\n\t/*\n\t * Use local locking if mounted with \"-onolock\" or with appropriate\n\t * \"-olocal_lock=\"\n\t */\n\tif (!is_local)\n\t\tstatus = NFS_PROTO(inode)->lock(filp, cmd, fl);\n\telse\n\t\tstatus = do_vfs_lock(filp, fl);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: flock(%pD2, t=%x, fl=%x)\\n\"",
            "filp",
            "fl->fl_type",
            "fl->fl_flags"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint nfs_flock(struct file *filp, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint is_local = 0;\n\n\tdprintk(\"NFS: flock(%pD2, t=%x, fl=%x)\\n\",\n\t\t\tfilp, fl->fl_type, fl->fl_flags);\n\n\tif (!(fl->fl_flags & FL_FLOCK))\n\t\treturn -ENOLCK;\n\n\t/*\n\t * The NFSv4 protocol doesn't support LOCK_MAND, which is not part of\n\t * any standard. In principle we might be able to support LOCK_MAND\n\t * on NFSv2/3 since NLMv3/4 support DOS share modes, but for now the\n\t * NFS code is not set up for it.\n\t */\n\tif (fl->fl_type & LOCK_MAND)\n\t\treturn -EINVAL;\n\n\tif (NFS_SERVER(inode)->flags & NFS_MOUNT_LOCAL_FLOCK)\n\t\tis_local = 1;\n\n\t/* We're simulating flock() locks using posix locks on the server */\n\tif (fl->fl_type == F_UNLCK)\n\t\treturn do_unlk(filp, cmd, fl, is_local);\n\treturn do_setlk(filp, cmd, fl, is_local);\n}"
  },
  {
    "function_name": "nfs_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "859-892",
    "snippet": "int nfs_lock(struct file *filp, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint ret = -ENOLCK;\n\tint is_local = 0;\n\n\tdprintk(\"NFS: lock(%pD2, t=%x, fl=%x, r=%lld:%lld)\\n\",\n\t\t\tfilp, fl->fl_type, fl->fl_flags,\n\t\t\t(long long)fl->fl_start, (long long)fl->fl_end);\n\n\tnfs_inc_stats(inode, NFSIOS_VFSLOCK);\n\n\t/* No mandatory locks over NFS */\n\tif (__mandatory_lock(inode) && fl->fl_type != F_UNLCK)\n\t\tgoto out_err;\n\n\tif (NFS_SERVER(inode)->flags & NFS_MOUNT_LOCAL_FCNTL)\n\t\tis_local = 1;\n\n\tif (NFS_PROTO(inode)->lock_check_bounds != NULL) {\n\t\tret = NFS_PROTO(inode)->lock_check_bounds(fl);\n\t\tif (ret < 0)\n\t\t\tgoto out_err;\n\t}\n\n\tif (IS_GETLK(cmd))\n\t\tret = do_getlk(filp, cmd, fl, is_local);\n\telse if (fl->fl_type == F_UNLCK)\n\t\tret = do_unlk(filp, cmd, fl, is_local);\n\telse\n\t\tret = do_setlk(filp, cmd, fl, is_local);\nout_err:\n\treturn ret;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_setlk",
          "args": [
            "filp",
            "cmd",
            "fl",
            "is_local"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "do_setlk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
          "lines": "813-854",
          "snippet": "static int\ndo_setlk(struct file *filp, int cmd, struct file_lock *fl, int is_local)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint status;\n\n\t/*\n\t * Flush all pending writes before doing anything\n\t * with locks..\n\t */\n\tstatus = nfs_sync_mapping(filp->f_mapping);\n\tif (status != 0)\n\t\tgoto out;\n\n\t/*\n\t * Use local locking if mounted with \"-onolock\" or with appropriate\n\t * \"-olocal_lock=\"\n\t */\n\tif (!is_local)\n\t\tstatus = NFS_PROTO(inode)->lock(filp, cmd, fl);\n\telse\n\t\tstatus = do_vfs_lock(filp, fl);\n\tif (status < 0)\n\t\tgoto out;\n\n\t/*\n\t * Revalidate the cache if the server has time stamps granular\n\t * enough to detect subsecond changes.  Otherwise, clear the\n\t * cache to prevent missing any changes.\n\t *\n\t * This makes locking act as a cache coherency point.\n\t */\n\tnfs_sync_mapping(filp->f_mapping);\n\tif (!NFS_PROTO(inode)->have_delegation(inode, FMODE_READ)) {\n\t\tif (is_time_granular(&NFS_SERVER(inode)->time_delta))\n\t\t\t__nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\t\telse\n\t\t\tnfs_zap_caches(inode);\n\t}\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/swap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int\ndo_setlk(struct file *filp, int cmd, struct file_lock *fl, int is_local)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint status;\n\n\t/*\n\t * Flush all pending writes before doing anything\n\t * with locks..\n\t */\n\tstatus = nfs_sync_mapping(filp->f_mapping);\n\tif (status != 0)\n\t\tgoto out;\n\n\t/*\n\t * Use local locking if mounted with \"-onolock\" or with appropriate\n\t * \"-olocal_lock=\"\n\t */\n\tif (!is_local)\n\t\tstatus = NFS_PROTO(inode)->lock(filp, cmd, fl);\n\telse\n\t\tstatus = do_vfs_lock(filp, fl);\n\tif (status < 0)\n\t\tgoto out;\n\n\t/*\n\t * Revalidate the cache if the server has time stamps granular\n\t * enough to detect subsecond changes.  Otherwise, clear the\n\t * cache to prevent missing any changes.\n\t *\n\t * This makes locking act as a cache coherency point.\n\t */\n\tnfs_sync_mapping(filp->f_mapping);\n\tif (!NFS_PROTO(inode)->have_delegation(inode, FMODE_READ)) {\n\t\tif (is_time_granular(&NFS_SERVER(inode)->time_delta))\n\t\t\t__nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\t\telse\n\t\t\tnfs_zap_caches(inode);\n\t}\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_unlk",
          "args": [
            "filp",
            "cmd",
            "fl",
            "is_local"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "do_unlk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
          "lines": "772-806",
          "snippet": "static int\ndo_unlk(struct file *filp, int cmd, struct file_lock *fl, int is_local)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tstruct nfs_lock_context *l_ctx;\n\tint status;\n\n\t/*\n\t * Flush all pending writes before doing anything\n\t * with locks..\n\t */\n\tnfs_sync_mapping(filp->f_mapping);\n\n\tl_ctx = nfs_get_lock_context(nfs_file_open_context(filp));\n\tif (!IS_ERR(l_ctx)) {\n\t\tstatus = nfs_iocounter_wait(&l_ctx->io_count);\n\t\tnfs_put_lock_context(l_ctx);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\t/* NOTE: special case\n\t * \tIf we're signalled while cleaning up locks on process exit, we\n\t * \tstill need to complete the unlock.\n\t */\n\t/*\n\t * Use local locking if mounted with \"-onolock\" or with appropriate\n\t * \"-olocal_lock=\"\n\t */\n\tif (!is_local)\n\t\tstatus = NFS_PROTO(inode)->lock(filp, cmd, fl);\n\telse\n\t\tstatus = do_vfs_lock(filp, fl);\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/swap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int\ndo_unlk(struct file *filp, int cmd, struct file_lock *fl, int is_local)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tstruct nfs_lock_context *l_ctx;\n\tint status;\n\n\t/*\n\t * Flush all pending writes before doing anything\n\t * with locks..\n\t */\n\tnfs_sync_mapping(filp->f_mapping);\n\n\tl_ctx = nfs_get_lock_context(nfs_file_open_context(filp));\n\tif (!IS_ERR(l_ctx)) {\n\t\tstatus = nfs_iocounter_wait(&l_ctx->io_count);\n\t\tnfs_put_lock_context(l_ctx);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\t/* NOTE: special case\n\t * \tIf we're signalled while cleaning up locks on process exit, we\n\t * \tstill need to complete the unlock.\n\t */\n\t/*\n\t * Use local locking if mounted with \"-onolock\" or with appropriate\n\t * \"-olocal_lock=\"\n\t */\n\tif (!is_local)\n\t\tstatus = NFS_PROTO(inode)->lock(filp, cmd, fl);\n\telse\n\t\tstatus = do_vfs_lock(filp, fl);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_getlk",
          "args": [
            "filp",
            "cmd",
            "fl",
            "is_local"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "do_getlk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
          "lines": "727-754",
          "snippet": "static int\ndo_getlk(struct file *filp, int cmd, struct file_lock *fl, int is_local)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint status = 0;\n\tunsigned int saved_type = fl->fl_type;\n\n\t/* Try local locking first */\n\tposix_test_lock(filp, fl);\n\tif (fl->fl_type != F_UNLCK) {\n\t\t/* found a conflict */\n\t\tgoto out;\n\t}\n\tfl->fl_type = saved_type;\n\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_READ))\n\t\tgoto out_noconflict;\n\n\tif (is_local)\n\t\tgoto out_noconflict;\n\n\tstatus = NFS_PROTO(inode)->lock(filp, cmd, fl);\nout:\n\treturn status;\nout_noconflict:\n\tfl->fl_type = F_UNLCK;\n\tgoto out;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/swap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int\ndo_getlk(struct file *filp, int cmd, struct file_lock *fl, int is_local)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint status = 0;\n\tunsigned int saved_type = fl->fl_type;\n\n\t/* Try local locking first */\n\tposix_test_lock(filp, fl);\n\tif (fl->fl_type != F_UNLCK) {\n\t\t/* found a conflict */\n\t\tgoto out;\n\t}\n\tfl->fl_type = saved_type;\n\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_READ))\n\t\tgoto out_noconflict;\n\n\tif (is_local)\n\t\tgoto out_noconflict;\n\n\tstatus = NFS_PROTO(inode)->lock(filp, cmd, fl);\nout:\n\treturn status;\nout_noconflict:\n\tfl->fl_type = F_UNLCK;\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_GETLK",
          "args": [
            "cmd"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "fl"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mandatory_lock",
          "args": [
            "inode"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_inc_stats",
          "args": [
            "inode",
            "NFSIOS_VFSLOCK"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "31-35",
          "snippet": "static inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: lock(%pD2, t=%x, fl=%x, r=%lld:%lld)\\n\"",
            "filp",
            "fl->fl_type",
            "fl->fl_flags",
            "(long long)fl->fl_start",
            "(long long)fl->fl_end"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint nfs_lock(struct file *filp, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint ret = -ENOLCK;\n\tint is_local = 0;\n\n\tdprintk(\"NFS: lock(%pD2, t=%x, fl=%x, r=%lld:%lld)\\n\",\n\t\t\tfilp, fl->fl_type, fl->fl_flags,\n\t\t\t(long long)fl->fl_start, (long long)fl->fl_end);\n\n\tnfs_inc_stats(inode, NFSIOS_VFSLOCK);\n\n\t/* No mandatory locks over NFS */\n\tif (__mandatory_lock(inode) && fl->fl_type != F_UNLCK)\n\t\tgoto out_err;\n\n\tif (NFS_SERVER(inode)->flags & NFS_MOUNT_LOCAL_FCNTL)\n\t\tis_local = 1;\n\n\tif (NFS_PROTO(inode)->lock_check_bounds != NULL) {\n\t\tret = NFS_PROTO(inode)->lock_check_bounds(fl);\n\t\tif (ret < 0)\n\t\t\tgoto out_err;\n\t}\n\n\tif (IS_GETLK(cmd))\n\t\tret = do_getlk(filp, cmd, fl, is_local);\n\telse if (fl->fl_type == F_UNLCK)\n\t\tret = do_unlk(filp, cmd, fl, is_local);\n\telse\n\t\tret = do_setlk(filp, cmd, fl, is_local);\nout_err:\n\treturn ret;\n}"
  },
  {
    "function_name": "do_setlk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "813-854",
    "snippet": "static int\ndo_setlk(struct file *filp, int cmd, struct file_lock *fl, int is_local)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint status;\n\n\t/*\n\t * Flush all pending writes before doing anything\n\t * with locks..\n\t */\n\tstatus = nfs_sync_mapping(filp->f_mapping);\n\tif (status != 0)\n\t\tgoto out;\n\n\t/*\n\t * Use local locking if mounted with \"-onolock\" or with appropriate\n\t * \"-olocal_lock=\"\n\t */\n\tif (!is_local)\n\t\tstatus = NFS_PROTO(inode)->lock(filp, cmd, fl);\n\telse\n\t\tstatus = do_vfs_lock(filp, fl);\n\tif (status < 0)\n\t\tgoto out;\n\n\t/*\n\t * Revalidate the cache if the server has time stamps granular\n\t * enough to detect subsecond changes.  Otherwise, clear the\n\t * cache to prevent missing any changes.\n\t *\n\t * This makes locking act as a cache coherency point.\n\t */\n\tnfs_sync_mapping(filp->f_mapping);\n\tif (!NFS_PROTO(inode)->have_delegation(inode, FMODE_READ)) {\n\t\tif (is_time_granular(&NFS_SERVER(inode)->time_delta))\n\t\t\t__nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\t\telse\n\t\t\tnfs_zap_caches(inode);\n\t}\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_zap_caches",
          "args": [
            "inode"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_zap_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "189-194",
          "snippet": "void nfs_zap_caches(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tnfs_zap_caches_locked(inode);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nvoid nfs_zap_caches(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tnfs_zap_caches_locked(inode);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__nfs_revalidate_inode",
          "args": [
            "NFS_SERVER(inode)",
            "inode"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs_revalidate_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "924-991",
          "snippet": "int\n__nfs_revalidate_inode(struct nfs_server *server, struct inode *inode)\n{\n\tint\t\t status = -ESTALE;\n\tstruct nfs4_label *label = NULL;\n\tstruct nfs_fattr *fattr = NULL;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tdfprintk(PAGECACHE, \"NFS: revalidating (%s/%Lu)\\n\",\n\t\tinode->i_sb->s_id, (unsigned long long)NFS_FILEID(inode));\n\n\ttrace_nfs_revalidate_inode_enter(inode);\n\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\tif (NFS_STALE(inode))\n\t\tgoto out;\n\n\tstatus = -ENOMEM;\n\tfattr = nfs_alloc_fattr();\n\tif (fattr == NULL)\n\t\tgoto out;\n\n\tnfs_inc_stats(inode, NFSIOS_INODEREVALIDATE);\n\n\tlabel = nfs4_label_alloc(NFS_SERVER(inode), GFP_KERNEL);\n\tif (IS_ERR(label)) {\n\t\tstatus = PTR_ERR(label);\n\t\tgoto out;\n\t}\n\n\tstatus = NFS_PROTO(inode)->getattr(server, NFS_FH(inode), fattr, label);\n\tif (status != 0) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Lu) getattr failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (unsigned long long)NFS_FILEID(inode), status);\n\t\tif (status == -ESTALE) {\n\t\t\tnfs_zap_caches(inode);\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tset_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n\t\t}\n\t\tgoto err_out;\n\t}\n\n\tstatus = nfs_refresh_inode(inode, fattr);\n\tif (status) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Lu) refresh failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (unsigned long long)NFS_FILEID(inode), status);\n\t\tgoto err_out;\n\t}\n\n\tif (nfsi->cache_validity & NFS_INO_INVALID_ACL)\n\t\tnfs_zap_acl_cache(inode);\n\n\tnfs_setsecurity(inode, fattr, label);\n\n\tdfprintk(PAGECACHE, \"NFS: (%s/%Lu) revalidation complete\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(inode));\n\nerr_out:\n\tnfs4_label_free(label);\nout:\n\tnfs_free_fattr(fattr);\n\ttrace_nfs_revalidate_inode_exit(inode, status);\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);",
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nint\n__nfs_revalidate_inode(struct nfs_server *server, struct inode *inode)\n{\n\tint\t\t status = -ESTALE;\n\tstruct nfs4_label *label = NULL;\n\tstruct nfs_fattr *fattr = NULL;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tdfprintk(PAGECACHE, \"NFS: revalidating (%s/%Lu)\\n\",\n\t\tinode->i_sb->s_id, (unsigned long long)NFS_FILEID(inode));\n\n\ttrace_nfs_revalidate_inode_enter(inode);\n\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\tif (NFS_STALE(inode))\n\t\tgoto out;\n\n\tstatus = -ENOMEM;\n\tfattr = nfs_alloc_fattr();\n\tif (fattr == NULL)\n\t\tgoto out;\n\n\tnfs_inc_stats(inode, NFSIOS_INODEREVALIDATE);\n\n\tlabel = nfs4_label_alloc(NFS_SERVER(inode), GFP_KERNEL);\n\tif (IS_ERR(label)) {\n\t\tstatus = PTR_ERR(label);\n\t\tgoto out;\n\t}\n\n\tstatus = NFS_PROTO(inode)->getattr(server, NFS_FH(inode), fattr, label);\n\tif (status != 0) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Lu) getattr failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (unsigned long long)NFS_FILEID(inode), status);\n\t\tif (status == -ESTALE) {\n\t\t\tnfs_zap_caches(inode);\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tset_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n\t\t}\n\t\tgoto err_out;\n\t}\n\n\tstatus = nfs_refresh_inode(inode, fattr);\n\tif (status) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Lu) refresh failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (unsigned long long)NFS_FILEID(inode), status);\n\t\tgoto err_out;\n\t}\n\n\tif (nfsi->cache_validity & NFS_INO_INVALID_ACL)\n\t\tnfs_zap_acl_cache(inode);\n\n\tnfs_setsecurity(inode, fattr, label);\n\n\tdfprintk(PAGECACHE, \"NFS: (%s/%Lu) revalidation complete\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(inode));\n\nerr_out:\n\tnfs4_label_free(label);\nout:\n\tnfs_free_fattr(fattr);\n\ttrace_nfs_revalidate_inode_exit(inode, status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_time_granular",
          "args": [
            "&NFS_SERVER(inode)->time_delta"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "is_time_granular",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
          "lines": "808-811",
          "snippet": "static int\nis_time_granular(struct timespec *ts) {\n\treturn ((ts->tv_sec == 0) && (ts->tv_nsec <= 1000));\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/swap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int\nis_time_granular(struct timespec *ts) {\n\treturn ((ts->tv_sec == 0) && (ts->tv_nsec <= 1000));\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode",
            "FMODE_READ"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_sync_mapping",
          "args": [
            "filp->f_mapping"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_sync_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "139-148",
          "snippet": "int nfs_sync_mapping(struct address_space *mapping)\n{\n\tint ret = 0;\n\n\tif (mapping->nrpages != 0) {\n\t\tunmap_mapping_range(mapping, 0, 0, 0);\n\t\tret = nfs_wb_all(mapping->host);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint nfs_sync_mapping(struct address_space *mapping)\n{\n\tint ret = 0;\n\n\tif (mapping->nrpages != 0) {\n\t\tunmap_mapping_range(mapping, 0, 0, 0);\n\t\tret = nfs_wb_all(mapping->host);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_vfs_lock",
          "args": [
            "filp",
            "fl"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "do_vfs_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
          "lines": "756-770",
          "snippet": "static int do_vfs_lock(struct file *file, struct file_lock *fl)\n{\n\tint res = 0;\n\tswitch (fl->fl_flags & (FL_POSIX|FL_FLOCK)) {\n\t\tcase FL_POSIX:\n\t\t\tres = posix_lock_file_wait(file, fl);\n\t\t\tbreak;\n\t\tcase FL_FLOCK:\n\t\t\tres = flock_lock_file_wait(file, fl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/swap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int do_vfs_lock(struct file *file, struct file_lock *fl)\n{\n\tint res = 0;\n\tswitch (fl->fl_flags & (FL_POSIX|FL_FLOCK)) {\n\t\tcase FL_POSIX:\n\t\t\tres = posix_lock_file_wait(file, fl);\n\t\t\tbreak;\n\t\tcase FL_FLOCK:\n\t\t\tres = flock_lock_file_wait(file, fl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "filp",
            "cmd",
            "fl"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int\ndo_setlk(struct file *filp, int cmd, struct file_lock *fl, int is_local)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint status;\n\n\t/*\n\t * Flush all pending writes before doing anything\n\t * with locks..\n\t */\n\tstatus = nfs_sync_mapping(filp->f_mapping);\n\tif (status != 0)\n\t\tgoto out;\n\n\t/*\n\t * Use local locking if mounted with \"-onolock\" or with appropriate\n\t * \"-olocal_lock=\"\n\t */\n\tif (!is_local)\n\t\tstatus = NFS_PROTO(inode)->lock(filp, cmd, fl);\n\telse\n\t\tstatus = do_vfs_lock(filp, fl);\n\tif (status < 0)\n\t\tgoto out;\n\n\t/*\n\t * Revalidate the cache if the server has time stamps granular\n\t * enough to detect subsecond changes.  Otherwise, clear the\n\t * cache to prevent missing any changes.\n\t *\n\t * This makes locking act as a cache coherency point.\n\t */\n\tnfs_sync_mapping(filp->f_mapping);\n\tif (!NFS_PROTO(inode)->have_delegation(inode, FMODE_READ)) {\n\t\tif (is_time_granular(&NFS_SERVER(inode)->time_delta))\n\t\t\t__nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\t\telse\n\t\t\tnfs_zap_caches(inode);\n\t}\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "is_time_granular",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "808-811",
    "snippet": "static int\nis_time_granular(struct timespec *ts) {\n\treturn ((ts->tv_sec == 0) && (ts->tv_nsec <= 1000));\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int\nis_time_granular(struct timespec *ts) {\n\treturn ((ts->tv_sec == 0) && (ts->tv_nsec <= 1000));\n}"
  },
  {
    "function_name": "do_unlk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "772-806",
    "snippet": "static int\ndo_unlk(struct file *filp, int cmd, struct file_lock *fl, int is_local)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tstruct nfs_lock_context *l_ctx;\n\tint status;\n\n\t/*\n\t * Flush all pending writes before doing anything\n\t * with locks..\n\t */\n\tnfs_sync_mapping(filp->f_mapping);\n\n\tl_ctx = nfs_get_lock_context(nfs_file_open_context(filp));\n\tif (!IS_ERR(l_ctx)) {\n\t\tstatus = nfs_iocounter_wait(&l_ctx->io_count);\n\t\tnfs_put_lock_context(l_ctx);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\t/* NOTE: special case\n\t * \tIf we're signalled while cleaning up locks on process exit, we\n\t * \tstill need to complete the unlock.\n\t */\n\t/*\n\t * Use local locking if mounted with \"-onolock\" or with appropriate\n\t * \"-olocal_lock=\"\n\t */\n\tif (!is_local)\n\t\tstatus = NFS_PROTO(inode)->lock(filp, cmd, fl);\n\telse\n\t\tstatus = do_vfs_lock(filp, fl);\n\treturn status;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_vfs_lock",
          "args": [
            "filp",
            "fl"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "do_vfs_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
          "lines": "756-770",
          "snippet": "static int do_vfs_lock(struct file *file, struct file_lock *fl)\n{\n\tint res = 0;\n\tswitch (fl->fl_flags & (FL_POSIX|FL_FLOCK)) {\n\t\tcase FL_POSIX:\n\t\t\tres = posix_lock_file_wait(file, fl);\n\t\t\tbreak;\n\t\tcase FL_FLOCK:\n\t\t\tres = flock_lock_file_wait(file, fl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/swap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int do_vfs_lock(struct file *file, struct file_lock *fl)\n{\n\tint res = 0;\n\tswitch (fl->fl_flags & (FL_POSIX|FL_FLOCK)) {\n\t\tcase FL_POSIX:\n\t\t\tres = posix_lock_file_wait(file, fl);\n\t\t\tbreak;\n\t\tcase FL_FLOCK:\n\t\t\tres = flock_lock_file_wait(file, fl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "filp",
            "cmd",
            "fl"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_put_lock_context",
          "args": [
            "l_ctx"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_put_lock_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "736-746",
          "snippet": "void nfs_put_lock_context(struct nfs_lock_context *l_ctx)\n{\n\tstruct nfs_open_context *ctx = l_ctx->open_context;\n\tstruct inode *inode = ctx->dentry->d_inode;\n\n\tif (!atomic_dec_and_lock(&l_ctx->count, &inode->i_lock))\n\t\treturn;\n\tlist_del(&l_ctx->list);\n\tspin_unlock(&inode->i_lock);\n\tkfree(l_ctx);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nvoid nfs_put_lock_context(struct nfs_lock_context *l_ctx)\n{\n\tstruct nfs_open_context *ctx = l_ctx->open_context;\n\tstruct inode *inode = ctx->dentry->d_inode;\n\n\tif (!atomic_dec_and_lock(&l_ctx->count, &inode->i_lock))\n\t\treturn;\n\tlist_del(&l_ctx->list);\n\tspin_unlock(&inode->i_lock);\n\tkfree(l_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_iocounter_wait",
          "args": [
            "&l_ctx->io_count"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_iocounter_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "145-151",
          "snippet": "int\nnfs_iocounter_wait(struct nfs_io_counter *c)\n{\n\tif (atomic_read(&c->io_count) == 0)\n\t\treturn 0;\n\treturn __nfs_iocounter_wait(c);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint\nnfs_iocounter_wait(struct nfs_io_counter *c)\n{\n\tif (atomic_read(&c->io_count) == 0)\n\t\treturn 0;\n\treturn __nfs_iocounter_wait(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "l_ctx"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_get_lock_context",
          "args": [
            "nfs_file_open_context(filp)"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_get_lock_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "708-733",
          "snippet": "struct nfs_lock_context *nfs_get_lock_context(struct nfs_open_context *ctx)\n{\n\tstruct nfs_lock_context *res, *new = NULL;\n\tstruct inode *inode = ctx->dentry->d_inode;\n\n\tspin_lock(&inode->i_lock);\n\tres = __nfs_find_lock_context(ctx);\n\tif (res == NULL) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tnew = kmalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (new == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnfs_init_lock_context(new);\n\t\tspin_lock(&inode->i_lock);\n\t\tres = __nfs_find_lock_context(ctx);\n\t\tif (res == NULL) {\n\t\t\tlist_add_tail(&new->list, &ctx->lock_context.list);\n\t\t\tnew->open_context = ctx;\n\t\t\tres = new;\n\t\t\tnew = NULL;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n\tkfree(new);\n\treturn res;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nstruct nfs_lock_context *nfs_get_lock_context(struct nfs_open_context *ctx)\n{\n\tstruct nfs_lock_context *res, *new = NULL;\n\tstruct inode *inode = ctx->dentry->d_inode;\n\n\tspin_lock(&inode->i_lock);\n\tres = __nfs_find_lock_context(ctx);\n\tif (res == NULL) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tnew = kmalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (new == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnfs_init_lock_context(new);\n\t\tspin_lock(&inode->i_lock);\n\t\tres = __nfs_find_lock_context(ctx);\n\t\tif (res == NULL) {\n\t\t\tlist_add_tail(&new->list, &ctx->lock_context.list);\n\t\t\tnew->open_context = ctx;\n\t\t\tres = new;\n\t\t\tnew = NULL;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n\tkfree(new);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_file_open_context",
          "args": [
            "filp"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_sync_mapping",
          "args": [
            "filp->f_mapping"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_sync_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "139-148",
          "snippet": "int nfs_sync_mapping(struct address_space *mapping)\n{\n\tint ret = 0;\n\n\tif (mapping->nrpages != 0) {\n\t\tunmap_mapping_range(mapping, 0, 0, 0);\n\t\tret = nfs_wb_all(mapping->host);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint nfs_sync_mapping(struct address_space *mapping)\n{\n\tint ret = 0;\n\n\tif (mapping->nrpages != 0) {\n\t\tunmap_mapping_range(mapping, 0, 0, 0);\n\t\tret = nfs_wb_all(mapping->host);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int\ndo_unlk(struct file *filp, int cmd, struct file_lock *fl, int is_local)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tstruct nfs_lock_context *l_ctx;\n\tint status;\n\n\t/*\n\t * Flush all pending writes before doing anything\n\t * with locks..\n\t */\n\tnfs_sync_mapping(filp->f_mapping);\n\n\tl_ctx = nfs_get_lock_context(nfs_file_open_context(filp));\n\tif (!IS_ERR(l_ctx)) {\n\t\tstatus = nfs_iocounter_wait(&l_ctx->io_count);\n\t\tnfs_put_lock_context(l_ctx);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\t/* NOTE: special case\n\t * \tIf we're signalled while cleaning up locks on process exit, we\n\t * \tstill need to complete the unlock.\n\t */\n\t/*\n\t * Use local locking if mounted with \"-onolock\" or with appropriate\n\t * \"-olocal_lock=\"\n\t */\n\tif (!is_local)\n\t\tstatus = NFS_PROTO(inode)->lock(filp, cmd, fl);\n\telse\n\t\tstatus = do_vfs_lock(filp, fl);\n\treturn status;\n}"
  },
  {
    "function_name": "do_vfs_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "756-770",
    "snippet": "static int do_vfs_lock(struct file *file, struct file_lock *fl)\n{\n\tint res = 0;\n\tswitch (fl->fl_flags & (FL_POSIX|FL_FLOCK)) {\n\t\tcase FL_POSIX:\n\t\t\tres = posix_lock_file_wait(file, fl);\n\t\t\tbreak;\n\t\tcase FL_FLOCK:\n\t\t\tres = flock_lock_file_wait(file, fl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\treturn res;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flock_lock_file_wait",
          "args": [
            "file",
            "fl"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "flock_lock_file_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1858-1874",
          "snippet": "int flock_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_file(filp, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint flock_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_file(filp, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_lock_file_wait",
          "args": [
            "file",
            "fl"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "posix_lock_file_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1173-1189",
          "snippet": "int posix_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep ();\n\tfor (;;) {\n\t\terror = posix_lock_file(filp, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint posix_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep ();\n\tfor (;;) {\n\t\terror = posix_lock_file(filp, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int do_vfs_lock(struct file *file, struct file_lock *fl)\n{\n\tint res = 0;\n\tswitch (fl->fl_flags & (FL_POSIX|FL_FLOCK)) {\n\t\tcase FL_POSIX:\n\t\t\tres = posix_lock_file_wait(file, fl);\n\t\t\tbreak;\n\t\tcase FL_FLOCK:\n\t\t\tres = flock_lock_file_wait(file, fl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "do_getlk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "727-754",
    "snippet": "static int\ndo_getlk(struct file *filp, int cmd, struct file_lock *fl, int is_local)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint status = 0;\n\tunsigned int saved_type = fl->fl_type;\n\n\t/* Try local locking first */\n\tposix_test_lock(filp, fl);\n\tif (fl->fl_type != F_UNLCK) {\n\t\t/* found a conflict */\n\t\tgoto out;\n\t}\n\tfl->fl_type = saved_type;\n\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_READ))\n\t\tgoto out_noconflict;\n\n\tif (is_local)\n\t\tgoto out_noconflict;\n\n\tstatus = NFS_PROTO(inode)->lock(filp, cmd, fl);\nout:\n\treturn status;\nout_noconflict:\n\tfl->fl_type = F_UNLCK;\n\tgoto out;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "filp",
            "cmd",
            "fl"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode",
            "FMODE_READ"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_test_lock",
          "args": [
            "filp",
            "fl"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "posix_test_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "759-785",
          "snippet": "void\nposix_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tstruct file_lock *cfl;\n\tstruct file_lock_context *ctx;\n\tstruct inode *inode = file_inode(filp);\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix)) {\n\t\tfl->fl_type = F_UNLCK;\n\t\treturn;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(cfl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_locks_conflict(fl, cfl)) {\n\t\t\tlocks_copy_conflock(fl, cfl);\n\t\t\tif (cfl->fl_nspid)\n\t\t\t\tfl->fl_pid = pid_vnr(cfl->fl_nspid);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfl->fl_type = F_UNLCK;\nout:\n\tspin_unlock(&ctx->flc_lock);\n\treturn;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid\nposix_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tstruct file_lock *cfl;\n\tstruct file_lock_context *ctx;\n\tstruct inode *inode = file_inode(filp);\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix)) {\n\t\tfl->fl_type = F_UNLCK;\n\t\treturn;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(cfl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_locks_conflict(fl, cfl)) {\n\t\t\tlocks_copy_conflock(fl, cfl);\n\t\t\tif (cfl->fl_nspid)\n\t\t\t\tfl->fl_pid = pid_vnr(cfl->fl_nspid);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfl->fl_type = F_UNLCK;\nout:\n\tspin_unlock(&ctx->flc_lock);\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int\ndo_getlk(struct file *filp, int cmd, struct file_lock *fl, int is_local)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint status = 0;\n\tunsigned int saved_type = fl->fl_type;\n\n\t/* Try local locking first */\n\tposix_test_lock(filp, fl);\n\tif (fl->fl_type != F_UNLCK) {\n\t\t/* found a conflict */\n\t\tgoto out;\n\t}\n\tfl->fl_type = saved_type;\n\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_READ))\n\t\tgoto out_noconflict;\n\n\tif (is_local)\n\t\tgoto out_noconflict;\n\n\tstatus = NFS_PROTO(inode)->lock(filp, cmd, fl);\nout:\n\treturn status;\nout_noconflict:\n\tfl->fl_type = F_UNLCK;\n\tgoto out;\n}"
  },
  {
    "function_name": "nfs_file_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "671-724",
    "snippet": "ssize_t nfs_file_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tunsigned long written = 0;\n\tssize_t result;\n\tsize_t count = iov_iter_count(from);\n\tloff_t pos = iocb->ki_pos;\n\n\tresult = nfs_key_timeout_notify(file, inode);\n\tif (result)\n\t\treturn result;\n\n\tif (file->f_flags & O_DIRECT)\n\t\treturn nfs_file_direct_write(iocb, from, pos);\n\n\tdprintk(\"NFS: write(%pD2, %zu@%Ld)\\n\",\n\t\tfile, count, (long long) pos);\n\n\tresult = -EBUSY;\n\tif (IS_SWAPFILE(inode))\n\t\tgoto out_swapfile;\n\t/*\n\t * O_APPEND implies that we must revalidate the file length.\n\t */\n\tif (file->f_flags & O_APPEND) {\n\t\tresult = nfs_revalidate_file_size(inode, file);\n\t\tif (result)\n\t\t\tgoto out;\n\t}\n\n\tresult = count;\n\tif (!count)\n\t\tgoto out;\n\n\tresult = generic_file_write_iter(iocb, from);\n\tif (result > 0)\n\t\twritten = result;\n\n\t/* Return error values for O_DSYNC and IS_SYNC() */\n\tif (result >= 0 && nfs_need_sync_write(file, inode)) {\n\t\tint err = vfs_fsync(file, 0);\n\t\tif (err < 0)\n\t\t\tresult = err;\n\t}\n\tif (result > 0)\n\t\tnfs_add_stats(inode, NFSIOS_NORMALWRITTENBYTES, written);\nout:\n\treturn result;\n\nout_swapfile:\n\tprintk(KERN_INFO \"NFS: attempt to write to active swap file!\\n\");\n\tgoto out;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"NFS: attempt to write to active swap file!\\n\""
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_add_stats",
          "args": [
            "inode",
            "NFSIOS_NORMALWRITTENBYTES",
            "written"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_add_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "44-49",
          "snippet": "static inline void nfs_add_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_bytecounters stat,\n\t\t\t\t long addend)\n{\n\tnfs_add_server_stats(NFS_SERVER(inode), stat, addend);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_add_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_bytecounters stat,\n\t\t\t\t long addend)\n{\n\tnfs_add_server_stats(NFS_SERVER(inode), stat, addend);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_fsync",
          "args": [
            "file",
            "0"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_fsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "202-205",
          "snippet": "int vfs_fsync(struct file *file, int datasync)\n{\n\treturn vfs_fsync_range(file, 0, LLONG_MAX, datasync);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint vfs_fsync(struct file *file, int datasync)\n{\n\treturn vfs_fsync_range(file, 0, LLONG_MAX, datasync);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_need_sync_write",
          "args": [
            "file",
            "inode"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_need_sync_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
          "lines": "658-669",
          "snippet": "static int nfs_need_sync_write(struct file *filp, struct inode *inode)\n{\n\tstruct nfs_open_context *ctx;\n\n\tif (IS_SYNC(inode) || (filp->f_flags & O_DSYNC))\n\t\treturn 1;\n\tctx = nfs_file_open_context(filp);\n\tif (test_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags) ||\n\t    nfs_ctx_key_to_expire(ctx))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/swap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_need_sync_write(struct file *filp, struct inode *inode)\n{\n\tstruct nfs_open_context *ctx;\n\n\tif (IS_SYNC(inode) || (filp->f_flags & O_DSYNC))\n\t\treturn 1;\n\tctx = nfs_file_open_context(filp);\n\tif (test_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags) ||\n\t    nfs_ctx_key_to_expire(ctx))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_file_write_iter",
          "args": [
            "iocb",
            "from"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_revalidate_file_size",
          "args": [
            "inode",
            "file"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_revalidate_file_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
          "lines": "101-119",
          "snippet": "static int nfs_revalidate_file_size(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tif (nfs_have_delegated_attributes(inode))\n\t\tgoto out_noreval;\n\n\tif (filp->f_flags & O_DIRECT)\n\t\tgoto force_reval;\n\tif (nfsi->cache_validity & NFS_INO_REVAL_PAGECACHE)\n\t\tgoto force_reval;\n\tif (nfs_attribute_timeout(inode))\n\t\tgoto force_reval;\nout_noreval:\n\treturn 0;\nforce_reval:\n\treturn __nfs_revalidate_inode(server, inode);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/swap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_revalidate_file_size(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tif (nfs_have_delegated_attributes(inode))\n\t\tgoto out_noreval;\n\n\tif (filp->f_flags & O_DIRECT)\n\t\tgoto force_reval;\n\tif (nfsi->cache_validity & NFS_INO_REVAL_PAGECACHE)\n\t\tgoto force_reval;\n\tif (nfs_attribute_timeout(inode))\n\t\tgoto force_reval;\nout_noreval:\n\treturn 0;\nforce_reval:\n\treturn __nfs_revalidate_inode(server, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SWAPFILE",
          "args": [
            "inode"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: write(%pD2, %zu@%Ld)\\n\"",
            "file",
            "count",
            "(long long) pos"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_file_direct_write",
          "args": [
            "iocb",
            "from",
            "pos"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_file_direct_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "963-1055",
          "snippet": "ssize_t nfs_file_direct_write(struct kiocb *iocb, struct iov_iter *iter,\n\t\t\t\tloff_t pos)\n{\n\tssize_t result = -EINVAL;\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct nfs_direct_req *dreq;\n\tstruct nfs_lock_context *l_ctx;\n\tloff_t end;\n\tsize_t count = iov_iter_count(iter);\n\tend = (pos + count - 1) >> PAGE_CACHE_SHIFT;\n\n\tnfs_add_stats(mapping->host, NFSIOS_DIRECTWRITTENBYTES, count);\n\n\tdfprintk(FILE, \"NFS: direct write(%pD2, %zd@%Ld)\\n\",\n\t\tfile, count, (long long) pos);\n\n\tresult = generic_write_checks(file, &pos, &count, 0);\n\tif (result)\n\t\tgoto out;\n\n\tresult = -EINVAL;\n\tif ((ssize_t) count < 0)\n\t\tgoto out;\n\tresult = 0;\n\tif (!count)\n\t\tgoto out;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tresult = nfs_sync_mapping(mapping);\n\tif (result)\n\t\tgoto out_unlock;\n\n\tif (mapping->nrpages) {\n\t\tresult = invalidate_inode_pages2_range(mapping,\n\t\t\t\t\tpos >> PAGE_CACHE_SHIFT, end);\n\t\tif (result)\n\t\t\tgoto out_unlock;\n\t}\n\n\ttask_io_account_write(count);\n\n\tresult = -ENOMEM;\n\tdreq = nfs_direct_req_alloc();\n\tif (!dreq)\n\t\tgoto out_unlock;\n\n\tdreq->inode = inode;\n\tdreq->bytes_left = count;\n\tdreq->io_start = pos;\n\tdreq->ctx = get_nfs_open_context(nfs_file_open_context(iocb->ki_filp));\n\tl_ctx = nfs_get_lock_context(dreq->ctx);\n\tif (IS_ERR(l_ctx)) {\n\t\tresult = PTR_ERR(l_ctx);\n\t\tgoto out_release;\n\t}\n\tdreq->l_ctx = l_ctx;\n\tif (!is_sync_kiocb(iocb))\n\t\tdreq->iocb = iocb;\n\n\tresult = nfs_direct_write_schedule_iovec(dreq, iter, pos);\n\n\tif (mapping->nrpages) {\n\t\tinvalidate_inode_pages2_range(mapping,\n\t\t\t\t\t      pos >> PAGE_CACHE_SHIFT, end);\n\t}\n\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (!result) {\n\t\tresult = nfs_direct_wait(dreq);\n\t\tif (result > 0) {\n\t\t\tstruct inode *inode = mapping->host;\n\n\t\t\tiocb->ki_pos = pos + result;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tif (i_size_read(inode) < iocb->ki_pos)\n\t\t\t\ti_size_write(inode, iocb->ki_pos);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t}\n\t}\n\tnfs_direct_req_release(dreq);\n\treturn result;\n\nout_release:\n\tnfs_direct_req_release(dreq);\nout_unlock:\n\tmutex_unlock(&inode->i_mutex);\nout:\n\treturn result;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_direct_write_complete(struct nfs_direct_req *dreq, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void nfs_direct_write_complete(struct nfs_direct_req *dreq, struct inode *inode);\n\nssize_t nfs_file_direct_write(struct kiocb *iocb, struct iov_iter *iter,\n\t\t\t\tloff_t pos)\n{\n\tssize_t result = -EINVAL;\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct nfs_direct_req *dreq;\n\tstruct nfs_lock_context *l_ctx;\n\tloff_t end;\n\tsize_t count = iov_iter_count(iter);\n\tend = (pos + count - 1) >> PAGE_CACHE_SHIFT;\n\n\tnfs_add_stats(mapping->host, NFSIOS_DIRECTWRITTENBYTES, count);\n\n\tdfprintk(FILE, \"NFS: direct write(%pD2, %zd@%Ld)\\n\",\n\t\tfile, count, (long long) pos);\n\n\tresult = generic_write_checks(file, &pos, &count, 0);\n\tif (result)\n\t\tgoto out;\n\n\tresult = -EINVAL;\n\tif ((ssize_t) count < 0)\n\t\tgoto out;\n\tresult = 0;\n\tif (!count)\n\t\tgoto out;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tresult = nfs_sync_mapping(mapping);\n\tif (result)\n\t\tgoto out_unlock;\n\n\tif (mapping->nrpages) {\n\t\tresult = invalidate_inode_pages2_range(mapping,\n\t\t\t\t\tpos >> PAGE_CACHE_SHIFT, end);\n\t\tif (result)\n\t\t\tgoto out_unlock;\n\t}\n\n\ttask_io_account_write(count);\n\n\tresult = -ENOMEM;\n\tdreq = nfs_direct_req_alloc();\n\tif (!dreq)\n\t\tgoto out_unlock;\n\n\tdreq->inode = inode;\n\tdreq->bytes_left = count;\n\tdreq->io_start = pos;\n\tdreq->ctx = get_nfs_open_context(nfs_file_open_context(iocb->ki_filp));\n\tl_ctx = nfs_get_lock_context(dreq->ctx);\n\tif (IS_ERR(l_ctx)) {\n\t\tresult = PTR_ERR(l_ctx);\n\t\tgoto out_release;\n\t}\n\tdreq->l_ctx = l_ctx;\n\tif (!is_sync_kiocb(iocb))\n\t\tdreq->iocb = iocb;\n\n\tresult = nfs_direct_write_schedule_iovec(dreq, iter, pos);\n\n\tif (mapping->nrpages) {\n\t\tinvalidate_inode_pages2_range(mapping,\n\t\t\t\t\t      pos >> PAGE_CACHE_SHIFT, end);\n\t}\n\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (!result) {\n\t\tresult = nfs_direct_wait(dreq);\n\t\tif (result > 0) {\n\t\t\tstruct inode *inode = mapping->host;\n\n\t\t\tiocb->ki_pos = pos + result;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tif (i_size_read(inode) < iocb->ki_pos)\n\t\t\t\ti_size_write(inode, iocb->ki_pos);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t}\n\t}\n\tnfs_direct_req_release(dreq);\n\treturn result;\n\nout_release:\n\tnfs_direct_req_release(dreq);\nout_unlock:\n\tmutex_unlock(&inode->i_mutex);\nout:\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_key_timeout_notify",
          "args": [
            "file",
            "inode"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_key_timeout_notify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1138-1145",
          "snippet": "int\nnfs_key_timeout_notify(struct file *filp, struct inode *inode)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(filp);\n\tstruct rpc_auth *auth = NFS_SERVER(inode)->client->cl_auth;\n\n\treturn rpcauth_key_timeout_notify(auth, ctx->cred);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nint\nnfs_key_timeout_notify(struct file *filp, struct inode *inode)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(filp);\n\tstruct rpc_auth *auth = NFS_SERVER(inode)->client->cl_auth;\n\n\treturn rpcauth_key_timeout_notify(auth, ctx->cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nssize_t nfs_file_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tunsigned long written = 0;\n\tssize_t result;\n\tsize_t count = iov_iter_count(from);\n\tloff_t pos = iocb->ki_pos;\n\n\tresult = nfs_key_timeout_notify(file, inode);\n\tif (result)\n\t\treturn result;\n\n\tif (file->f_flags & O_DIRECT)\n\t\treturn nfs_file_direct_write(iocb, from, pos);\n\n\tdprintk(\"NFS: write(%pD2, %zu@%Ld)\\n\",\n\t\tfile, count, (long long) pos);\n\n\tresult = -EBUSY;\n\tif (IS_SWAPFILE(inode))\n\t\tgoto out_swapfile;\n\t/*\n\t * O_APPEND implies that we must revalidate the file length.\n\t */\n\tif (file->f_flags & O_APPEND) {\n\t\tresult = nfs_revalidate_file_size(inode, file);\n\t\tif (result)\n\t\t\tgoto out;\n\t}\n\n\tresult = count;\n\tif (!count)\n\t\tgoto out;\n\n\tresult = generic_file_write_iter(iocb, from);\n\tif (result > 0)\n\t\twritten = result;\n\n\t/* Return error values for O_DSYNC and IS_SYNC() */\n\tif (result >= 0 && nfs_need_sync_write(file, inode)) {\n\t\tint err = vfs_fsync(file, 0);\n\t\tif (err < 0)\n\t\t\tresult = err;\n\t}\n\tif (result > 0)\n\t\tnfs_add_stats(inode, NFSIOS_NORMALWRITTENBYTES, written);\nout:\n\treturn result;\n\nout_swapfile:\n\tprintk(KERN_INFO \"NFS: attempt to write to active swap file!\\n\");\n\tgoto out;\n}"
  },
  {
    "function_name": "nfs_need_sync_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "658-669",
    "snippet": "static int nfs_need_sync_write(struct file *filp, struct inode *inode)\n{\n\tstruct nfs_open_context *ctx;\n\n\tif (IS_SYNC(inode) || (filp->f_flags & O_DSYNC))\n\t\treturn 1;\n\tctx = nfs_file_open_context(filp);\n\tif (test_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags) ||\n\t    nfs_ctx_key_to_expire(ctx))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_ctx_key_to_expire",
          "args": [
            "ctx"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_ctx_key_to_expire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1150-1153",
          "snippet": "bool nfs_ctx_key_to_expire(struct nfs_open_context *ctx)\n{\n\treturn rpcauth_cred_key_to_expire(ctx->cred);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool nfs_ctx_key_to_expire(struct nfs_open_context *ctx)\n{\n\treturn rpcauth_cred_key_to_expire(ctx->cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_CONTEXT_ERROR_WRITE",
            "&ctx->flags"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_file_open_context",
          "args": [
            "filp"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_need_sync_write(struct file *filp, struct inode *inode)\n{\n\tstruct nfs_open_context *ctx;\n\n\tif (IS_SYNC(inode) || (filp->f_flags & O_DSYNC))\n\t\treturn 1;\n\tctx = nfs_file_open_context(filp);\n\tif (test_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags) ||\n\t    nfs_ctx_key_to_expire(ctx))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs_vm_page_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "610-650",
    "snippet": "static int nfs_vm_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tstruct file *filp = vma->vm_file;\n\tstruct inode *inode = file_inode(filp);\n\tunsigned pagelen;\n\tint ret = VM_FAULT_NOPAGE;\n\tstruct address_space *mapping;\n\n\tdfprintk(PAGECACHE, \"NFS: vm_page_mkwrite(%pD2(%lu), offset %lld)\\n\",\n\t\tfilp, filp->f_mapping->host->i_ino,\n\t\t(long long)page_offset(page));\n\n\t/* make sure the cache has finished storing the page */\n\tnfs_fscache_wait_on_page_write(NFS_I(inode), page);\n\n\twait_on_bit_action(&NFS_I(inode)->flags, NFS_INO_INVALIDATING,\n\t\t\tnfs_wait_bit_killable, TASK_KILLABLE);\n\n\tlock_page(page);\n\tmapping = page_file_mapping(page);\n\tif (mapping != inode->i_mapping)\n\t\tgoto out_unlock;\n\n\twait_on_page_writeback(page);\n\n\tpagelen = nfs_page_length(page);\n\tif (pagelen == 0)\n\t\tgoto out_unlock;\n\n\tret = VM_FAULT_LOCKED;\n\tif (nfs_flush_incompatible(filp, page) == 0 &&\n\t    nfs_updatepage(filp, page, 0, pagelen) == 0)\n\t\tgoto out;\n\n\tret = VM_FAULT_SIGBUS;\nout_unlock:\n\tunlock_page(page);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_updatepage",
          "args": [
            "filp",
            "page",
            "0",
            "pagelen"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_updatepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1232-1258",
          "snippet": "int nfs_updatepage(struct file *file, struct page *page,\n\t\tunsigned int offset, unsigned int count)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(file);\n\tstruct inode\t*inode = page_file_mapping(page)->host;\n\tint\t\tstatus = 0;\n\n\tnfs_inc_stats(inode, NFSIOS_VFSUPDATEPAGE);\n\n\tdprintk(\"NFS:       nfs_updatepage(%pD2 %d@%lld)\\n\",\n\t\tfile, count, (long long)(page_file_offset(page) + offset));\n\n\tif (nfs_can_extend_write(file, page, inode)) {\n\t\tcount = max(count + offset, nfs_page_length(page));\n\t\toffset = 0;\n\t}\n\n\tstatus = nfs_writepage_setup(ctx, page, offset, count);\n\tif (status < 0)\n\t\tnfs_set_pageerror(page);\n\telse\n\t\t__set_page_dirty_nobuffers(page);\n\n\tdprintk(\"NFS:       nfs_updatepage returns %d (isize %lld)\\n\",\n\t\t\tstatus, (long long)i_size_read(inode));\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nint nfs_updatepage(struct file *file, struct page *page,\n\t\tunsigned int offset, unsigned int count)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(file);\n\tstruct inode\t*inode = page_file_mapping(page)->host;\n\tint\t\tstatus = 0;\n\n\tnfs_inc_stats(inode, NFSIOS_VFSUPDATEPAGE);\n\n\tdprintk(\"NFS:       nfs_updatepage(%pD2 %d@%lld)\\n\",\n\t\tfile, count, (long long)(page_file_offset(page) + offset));\n\n\tif (nfs_can_extend_write(file, page, inode)) {\n\t\tcount = max(count + offset, nfs_page_length(page));\n\t\toffset = 0;\n\t}\n\n\tstatus = nfs_writepage_setup(ctx, page, offset, count);\n\tif (status < 0)\n\t\tnfs_set_pageerror(page);\n\telse\n\t\t__set_page_dirty_nobuffers(page);\n\n\tdprintk(\"NFS:       nfs_updatepage returns %d (isize %lld)\\n\",\n\t\t\tstatus, (long long)i_size_read(inode));\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_flush_incompatible",
          "args": [
            "filp",
            "page"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_flush_incompatible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1091-1126",
          "snippet": "int nfs_flush_incompatible(struct file *file, struct page *page)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(file);\n\tstruct nfs_lock_context *l_ctx;\n\tstruct file_lock_context *flctx = file_inode(file)->i_flctx;\n\tstruct nfs_page\t*req;\n\tint do_flush, status;\n\t/*\n\t * Look for a request corresponding to this page. If there\n\t * is one, and it belongs to another file, we flush it out\n\t * before we try to copy anything into the page. Do this\n\t * due to the lack of an ACCESS-type call in NFSv2.\n\t * Also do the same if we find a request from an existing\n\t * dropped page.\n\t */\n\tdo {\n\t\treq = nfs_page_find_head_request(page);\n\t\tif (req == NULL)\n\t\t\treturn 0;\n\t\tl_ctx = req->wb_lock_context;\n\t\tdo_flush = req->wb_page != page || req->wb_context != ctx;\n\t\t/* for now, flush if more than 1 request in page_group */\n\t\tdo_flush |= req->wb_this_page != req;\n\t\tif (l_ctx && flctx &&\n\t\t    !(list_empty_careful(&flctx->flc_posix) &&\n\t\t      list_empty_careful(&flctx->flc_flock))) {\n\t\t\tdo_flush |= l_ctx->lockowner.l_owner != current->files\n\t\t\t\t|| l_ctx->lockowner.l_pid != current->tgid;\n\t\t}\n\t\tnfs_release_request(req);\n\t\tif (!do_flush)\n\t\t\treturn 0;\n\t\tstatus = nfs_wb_page(page_file_mapping(page)->host, page);\n\t} while (status == 0);\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nint nfs_flush_incompatible(struct file *file, struct page *page)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(file);\n\tstruct nfs_lock_context *l_ctx;\n\tstruct file_lock_context *flctx = file_inode(file)->i_flctx;\n\tstruct nfs_page\t*req;\n\tint do_flush, status;\n\t/*\n\t * Look for a request corresponding to this page. If there\n\t * is one, and it belongs to another file, we flush it out\n\t * before we try to copy anything into the page. Do this\n\t * due to the lack of an ACCESS-type call in NFSv2.\n\t * Also do the same if we find a request from an existing\n\t * dropped page.\n\t */\n\tdo {\n\t\treq = nfs_page_find_head_request(page);\n\t\tif (req == NULL)\n\t\t\treturn 0;\n\t\tl_ctx = req->wb_lock_context;\n\t\tdo_flush = req->wb_page != page || req->wb_context != ctx;\n\t\t/* for now, flush if more than 1 request in page_group */\n\t\tdo_flush |= req->wb_this_page != req;\n\t\tif (l_ctx && flctx &&\n\t\t    !(list_empty_careful(&flctx->flc_posix) &&\n\t\t      list_empty_careful(&flctx->flc_flock))) {\n\t\t\tdo_flush |= l_ctx->lockowner.l_owner != current->files\n\t\t\t\t|| l_ctx->lockowner.l_pid != current->tgid;\n\t\t}\n\t\tnfs_release_request(req);\n\t\tif (!do_flush)\n\t\t\treturn 0;\n\t\tstatus = nfs_wb_page(page_file_mapping(page)->host, page);\n\t} while (status == 0);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_page_length",
          "args": [
            "page"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "617-631",
          "snippet": "static inline\nunsigned int nfs_page_length(struct page *page)\n{\n\tloff_t i_size = i_size_read(page_file_mapping(page)->host);\n\n\tif (i_size > 0) {\n\t\tpgoff_t page_index = page_file_index(page);\n\t\tpgoff_t end_index = (i_size - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (page_index < end_index)\n\t\t\treturn PAGE_CACHE_SIZE;\n\t\tif (page_index == end_index)\n\t\t\treturn ((i_size - 1) & ~PAGE_CACHE_MASK) + 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int nfs_file_fsync_commit(struct file *, loff_t, loff_t, int);",
            "loff_t nfs_file_llseek(struct file *, loff_t, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nint nfs_file_fsync_commit(struct file *, loff_t, loff_t, int);\nloff_t nfs_file_llseek(struct file *, loff_t, int);\n\nstatic inline\nunsigned int nfs_page_length(struct page *page)\n{\n\tloff_t i_size = i_size_read(page_file_mapping(page)->host);\n\n\tif (i_size > 0) {\n\t\tpgoff_t page_index = page_file_index(page);\n\t\tpgoff_t end_index = (i_size - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (page_index < end_index)\n\t\t\treturn PAGE_CACHE_SIZE;\n\t\tif (page_index == end_index)\n\t\t\treturn ((i_size - 1) & ~PAGE_CACHE_MASK) + 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_file_mapping",
          "args": [
            "page"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_bit_action",
          "args": [
            "&NFS_I(inode)->flags",
            "NFS_INO_INVALIDATING",
            "nfs_wait_bit_killable",
            "TASK_KILLABLE"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_fscache_wait_on_page_write",
          "args": [
            "NFS_I(inode)",
            "page"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_fscache_wait_on_page_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.h",
          "lines": "199-200",
          "snippet": "static inline void nfs_fscache_wait_on_page_write(struct nfs_inode *nfsi,\n\t\t\t\t\t\t  struct page *page) {}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void nfs_fscache_wait_on_page_write(struct nfs_inode *nfsi,\n\t\t\t\t\t\t  struct page *page) {}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "PAGECACHE",
            "\"NFS: vm_page_mkwrite(%pD2(%lu), offset %lld)\\n\"",
            "filp",
            "filp->f_mapping->host->i_ino",
            "(long long)page_offset(page)"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_vm_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tstruct file *filp = vma->vm_file;\n\tstruct inode *inode = file_inode(filp);\n\tunsigned pagelen;\n\tint ret = VM_FAULT_NOPAGE;\n\tstruct address_space *mapping;\n\n\tdfprintk(PAGECACHE, \"NFS: vm_page_mkwrite(%pD2(%lu), offset %lld)\\n\",\n\t\tfilp, filp->f_mapping->host->i_ino,\n\t\t(long long)page_offset(page));\n\n\t/* make sure the cache has finished storing the page */\n\tnfs_fscache_wait_on_page_write(NFS_I(inode), page);\n\n\twait_on_bit_action(&NFS_I(inode)->flags, NFS_INO_INVALIDATING,\n\t\t\tnfs_wait_bit_killable, TASK_KILLABLE);\n\n\tlock_page(page);\n\tmapping = page_file_mapping(page);\n\tif (mapping != inode->i_mapping)\n\t\tgoto out_unlock;\n\n\twait_on_page_writeback(page);\n\n\tpagelen = nfs_page_length(page);\n\tif (pagelen == 0)\n\t\tgoto out_unlock;\n\n\tret = VM_FAULT_LOCKED;\n\tif (nfs_flush_incompatible(filp, page) == 0 &&\n\t    nfs_updatepage(filp, page, 0, pagelen) == 0)\n\t\tgoto out;\n\n\tret = VM_FAULT_SIGBUS;\nout_unlock:\n\tunlock_page(page);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs_swap_deactivate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "574-581",
    "snippet": "static void nfs_swap_deactivate(struct file *file)\n{\n\tstruct rpc_clnt *clnt = NFS_CLIENT(file->f_mapping->host);\n\n\trcu_read_lock();\n\txs_swapper(rcu_dereference(clnt->cl_xprt), 0);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xs_swapper",
          "args": [
            "rcu_dereference(clnt->cl_xprt)",
            "0"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "clnt->cl_xprt"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_CLIENT",
          "args": [
            "file->f_mapping->host"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_swap_deactivate(struct file *file)\n{\n\tstruct rpc_clnt *clnt = NFS_CLIENT(file->f_mapping->host);\n\n\trcu_read_lock();\n\txs_swapper(rcu_dereference(clnt->cl_xprt), 0);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "nfs_swap_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "559-572",
    "snippet": "static int nfs_swap_activate(struct swap_info_struct *sis, struct file *file,\n\t\t\t\t\t\tsector_t *span)\n{\n\tint ret;\n\tstruct rpc_clnt *clnt = NFS_CLIENT(file->f_mapping->host);\n\n\t*span = sis->pages;\n\n\trcu_read_lock();\n\tret = xs_swapper(rcu_dereference(clnt->cl_xprt), 1);\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xs_swapper",
          "args": [
            "rcu_dereference(clnt->cl_xprt)",
            "1"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "clnt->cl_xprt"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_CLIENT",
          "args": [
            "file->f_mapping->host"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_swap_activate(struct swap_info_struct *sis, struct file *file,\n\t\t\t\t\t\tsector_t *span)\n{\n\tint ret;\n\tstruct rpc_clnt *clnt = NFS_CLIENT(file->f_mapping->host);\n\n\t*span = sis->pages;\n\n\trcu_read_lock();\n\tret = xs_swapper(rcu_dereference(clnt->cl_xprt), 1);\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs_launder_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "546-556",
    "snippet": "static int nfs_launder_page(struct page *page)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tdfprintk(PAGECACHE, \"NFS: launder_page(%ld, %llu)\\n\",\n\t\tinode->i_ino, (long long)page_offset(page));\n\n\tnfs_fscache_wait_on_page_write(nfsi, page);\n\treturn nfs_wb_page(inode, page);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_wb_page",
          "args": [
            "inode",
            "page"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_wb_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1893-1925",
          "snippet": "int nfs_wb_page(struct inode *inode, struct page *page)\n{\n\tloff_t range_start = page_file_offset(page);\n\tloff_t range_end = range_start + (loff_t)(PAGE_CACHE_SIZE - 1);\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = 0,\n\t\t.range_start = range_start,\n\t\t.range_end = range_end,\n\t};\n\tint ret;\n\n\ttrace_nfs_writeback_page_enter(inode);\n\n\tfor (;;) {\n\t\twait_on_page_writeback(page);\n\t\tif (clear_page_dirty_for_io(page)) {\n\t\t\tret = nfs_writepage_locked(page, &wbc);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\t\tret = 0;\n\t\tif (!PagePrivate(page))\n\t\t\tbreak;\n\t\tret = nfs_commit_inode(inode, FLUSH_SYNC);\n\t\tif (ret < 0)\n\t\t\tgoto out_error;\n\t}\nout_error:\n\ttrace_nfs_writeback_page_exit(inode, ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nint nfs_wb_page(struct inode *inode, struct page *page)\n{\n\tloff_t range_start = page_file_offset(page);\n\tloff_t range_end = range_start + (loff_t)(PAGE_CACHE_SIZE - 1);\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = 0,\n\t\t.range_start = range_start,\n\t\t.range_end = range_end,\n\t};\n\tint ret;\n\n\ttrace_nfs_writeback_page_enter(inode);\n\n\tfor (;;) {\n\t\twait_on_page_writeback(page);\n\t\tif (clear_page_dirty_for_io(page)) {\n\t\t\tret = nfs_writepage_locked(page, &wbc);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\t\tret = 0;\n\t\tif (!PagePrivate(page))\n\t\t\tbreak;\n\t\tret = nfs_commit_inode(inode, FLUSH_SYNC);\n\t\tif (ret < 0)\n\t\t\tgoto out_error;\n\t}\nout_error:\n\ttrace_nfs_writeback_page_exit(inode, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_fscache_wait_on_page_write",
          "args": [
            "nfsi",
            "page"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_fscache_wait_on_page_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.h",
          "lines": "199-200",
          "snippet": "static inline void nfs_fscache_wait_on_page_write(struct nfs_inode *nfsi,\n\t\t\t\t\t\t  struct page *page) {}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void nfs_fscache_wait_on_page_write(struct nfs_inode *nfsi,\n\t\t\t\t\t\t  struct page *page) {}"
        }
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "PAGECACHE",
            "\"NFS: launder_page(%ld, %llu)\\n\"",
            "inode->i_ino",
            "(long long)page_offset(page)"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_file_mapping",
          "args": [
            "page"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_launder_page(struct page *page)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tdfprintk(PAGECACHE, \"NFS: launder_page(%ld, %llu)\\n\",\n\t\tinode->i_ino, (long long)page_offset(page));\n\n\tnfs_fscache_wait_on_page_write(nfsi, page);\n\treturn nfs_wb_page(inode, page);\n}"
  },
  {
    "function_name": "nfs_check_dirty_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "509-536",
    "snippet": "static void nfs_check_dirty_writeback(struct page *page,\n\t\t\t\tbool *dirty, bool *writeback)\n{\n\tstruct nfs_inode *nfsi;\n\tstruct address_space *mapping = page_file_mapping(page);\n\n\tif (!mapping || PageSwapCache(page))\n\t\treturn;\n\n\t/*\n\t * Check if an unstable page is currently being committed and\n\t * if so, have the VM treat it as if the page is under writeback\n\t * so it will not block due to pages that will shortly be freeable.\n\t */\n\tnfsi = NFS_I(mapping->host);\n\tif (test_bit(NFS_INO_COMMIT, &nfsi->flags)) {\n\t\t*writeback = true;\n\t\treturn;\n\t}\n\n\t/*\n\t * If PagePrivate() is set, then the page is not freeable and as the\n\t * inode is not being committed, it's not going to be cleaned in the\n\t * near future so treat it as dirty\n\t */\n\tif (PagePrivate(page))\n\t\t*dirty = true;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_INO_COMMIT",
            "&nfsi->flags"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "mapping->host"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_file_mapping",
          "args": [
            "page"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_check_dirty_writeback(struct page *page,\n\t\t\t\tbool *dirty, bool *writeback)\n{\n\tstruct nfs_inode *nfsi;\n\tstruct address_space *mapping = page_file_mapping(page);\n\n\tif (!mapping || PageSwapCache(page))\n\t\treturn;\n\n\t/*\n\t * Check if an unstable page is currently being committed and\n\t * if so, have the VM treat it as if the page is under writeback\n\t * so it will not block due to pages that will shortly be freeable.\n\t */\n\tnfsi = NFS_I(mapping->host);\n\tif (test_bit(NFS_INO_COMMIT, &nfsi->flags)) {\n\t\t*writeback = true;\n\t\treturn;\n\t}\n\n\t/*\n\t * If PagePrivate() is set, then the page is not freeable and as the\n\t * inode is not being committed, it's not going to be cleaned in the\n\t * near future so treat it as dirty\n\t */\n\tif (PagePrivate(page))\n\t\t*dirty = true;\n}"
  },
  {
    "function_name": "nfs_release_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "476-507",
    "snippet": "static int nfs_release_page(struct page *page, gfp_t gfp)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\tdfprintk(PAGECACHE, \"NFS: release_page(%p)\\n\", page);\n\n\t/* Always try to initiate a 'commit' if relevant, but only\n\t * wait for it if __GFP_WAIT is set.  Even then, only wait 1\n\t * second and only if the 'bdi' is not congested.\n\t * Waiting indefinitely can cause deadlocks when the NFS\n\t * server is on this machine, when a new TCP connection is\n\t * needed and in other rare cases.  There is no particular\n\t * need to wait extensively here.  A short wait has the\n\t * benefit that someone else can worry about the freezer.\n\t */\n\tif (mapping) {\n\t\tstruct nfs_server *nfss = NFS_SERVER(mapping->host);\n\t\tnfs_commit_inode(mapping->host, 0);\n\t\tif ((gfp & __GFP_WAIT) &&\n\t\t    !bdi_write_congested(&nfss->backing_dev_info)) {\n\t\t\twait_on_page_bit_killable_timeout(page, PG_private,\n\t\t\t\t\t\t\t  HZ);\n\t\t\tif (PagePrivate(page))\n\t\t\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\t\t  BLK_RW_ASYNC);\n\t\t}\n\t}\n\t/* If PagePrivate() is set, then the page is not freeable */\n\tif (PagePrivate(page))\n\t\treturn 0;\n\treturn nfs_fscache_release_page(page, gfp);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_fscache_release_page",
          "args": [
            "page",
            "gfp"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_fscache_release_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.c",
          "lines": "260-277",
          "snippet": "int nfs_fscache_release_page(struct page *page, gfp_t gfp)\n{\n\tif (PageFsCache(page)) {\n\t\tstruct fscache_cookie *cookie = nfs_i_fscache(page->mapping->host);\n\n\t\tBUG_ON(!cookie);\n\t\tdfprintk(FSCACHE, \"NFS: fscache releasepage (0x%p/0x%p/0x%p)\\n\",\n\t\t\t cookie, page, NFS_I(page->mapping->host));\n\n\t\tif (!fscache_maybe_release_page(cookie, page, gfp))\n\t\t\treturn 0;\n\n\t\tnfs_inc_fscache_stats(page->mapping->host,\n\t\t\t\t      NFSIOS_FSCACHE_PAGES_UNCACHED);\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/in6.h>",
            "#include <linux/nfs_fs_sb.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/in6.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/nfs_fs.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nint nfs_fscache_release_page(struct page *page, gfp_t gfp)\n{\n\tif (PageFsCache(page)) {\n\t\tstruct fscache_cookie *cookie = nfs_i_fscache(page->mapping->host);\n\n\t\tBUG_ON(!cookie);\n\t\tdfprintk(FSCACHE, \"NFS: fscache releasepage (0x%p/0x%p/0x%p)\\n\",\n\t\t\t cookie, page, NFS_I(page->mapping->host));\n\n\t\tif (!fscache_maybe_release_page(cookie, page, gfp))\n\t\t\treturn 0;\n\n\t\tnfs_inc_fscache_stats(page->mapping->host,\n\t\t\t\t      NFSIOS_FSCACHE_PAGES_UNCACHED);\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bdi_congested",
          "args": [
            "&nfss->backing_dev_info",
            "BLK_RW_ASYNC"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_bit_killable_timeout",
          "args": [
            "page",
            "PG_private",
            "HZ"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_write_congested",
          "args": [
            "&nfss->backing_dev_info"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_commit_inode",
          "args": [
            "mapping->host",
            "0"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_commit_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1757-1794",
          "snippet": "int nfs_commit_inode(struct inode *inode, int how)\n{\n\tLIST_HEAD(head);\n\tstruct nfs_commit_info cinfo;\n\tint may_wait = how & FLUSH_SYNC;\n\tint res;\n\n\tres = nfs_commit_set_lock(NFS_I(inode), may_wait);\n\tif (res <= 0)\n\t\tgoto out_mark_dirty;\n\tnfs_init_cinfo_from_inode(&cinfo, inode);\n\tres = nfs_scan_commit(inode, &head, &cinfo);\n\tif (res) {\n\t\tint error;\n\n\t\terror = nfs_generic_commit_list(inode, &head, how, &cinfo);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (!may_wait)\n\t\t\tgoto out_mark_dirty;\n\t\terror = wait_on_bit_action(&NFS_I(inode)->flags,\n\t\t\t\tNFS_INO_COMMIT,\n\t\t\t\tnfs_wait_bit_killable,\n\t\t\t\tTASK_KILLABLE);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t} else\n\t\tnfs_commit_clear_lock(NFS_I(inode));\n\treturn res;\n\t/* Note: If we exit without ensuring that the commit is complete,\n\t * we must mark the inode as dirty. Otherwise, future calls to\n\t * sync_inode() with the WB_SYNC_ALL flag set will fail to ensure\n\t * that the data is on the disk.\n\t */\nout_mark_dirty:\n\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\treturn res;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nint nfs_commit_inode(struct inode *inode, int how)\n{\n\tLIST_HEAD(head);\n\tstruct nfs_commit_info cinfo;\n\tint may_wait = how & FLUSH_SYNC;\n\tint res;\n\n\tres = nfs_commit_set_lock(NFS_I(inode), may_wait);\n\tif (res <= 0)\n\t\tgoto out_mark_dirty;\n\tnfs_init_cinfo_from_inode(&cinfo, inode);\n\tres = nfs_scan_commit(inode, &head, &cinfo);\n\tif (res) {\n\t\tint error;\n\n\t\terror = nfs_generic_commit_list(inode, &head, how, &cinfo);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (!may_wait)\n\t\t\tgoto out_mark_dirty;\n\t\terror = wait_on_bit_action(&NFS_I(inode)->flags,\n\t\t\t\tNFS_INO_COMMIT,\n\t\t\t\tnfs_wait_bit_killable,\n\t\t\t\tTASK_KILLABLE);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t} else\n\t\tnfs_commit_clear_lock(NFS_I(inode));\n\treturn res;\n\t/* Note: If we exit without ensuring that the commit is complete,\n\t * we must mark the inode as dirty. Otherwise, future calls to\n\t * sync_inode() with the WB_SYNC_ALL flag set will fail to ensure\n\t * that the data is on the disk.\n\t */\nout_mark_dirty:\n\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "mapping->host"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "PAGECACHE",
            "\"NFS: release_page(%p)\\n\"",
            "page"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_release_page(struct page *page, gfp_t gfp)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\tdfprintk(PAGECACHE, \"NFS: release_page(%p)\\n\", page);\n\n\t/* Always try to initiate a 'commit' if relevant, but only\n\t * wait for it if __GFP_WAIT is set.  Even then, only wait 1\n\t * second and only if the 'bdi' is not congested.\n\t * Waiting indefinitely can cause deadlocks when the NFS\n\t * server is on this machine, when a new TCP connection is\n\t * needed and in other rare cases.  There is no particular\n\t * need to wait extensively here.  A short wait has the\n\t * benefit that someone else can worry about the freezer.\n\t */\n\tif (mapping) {\n\t\tstruct nfs_server *nfss = NFS_SERVER(mapping->host);\n\t\tnfs_commit_inode(mapping->host, 0);\n\t\tif ((gfp & __GFP_WAIT) &&\n\t\t    !bdi_write_congested(&nfss->backing_dev_info)) {\n\t\t\twait_on_page_bit_killable_timeout(page, PG_private,\n\t\t\t\t\t\t\t  HZ);\n\t\t\tif (PagePrivate(page))\n\t\t\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\t\t  BLK_RW_ASYNC);\n\t\t}\n\t}\n\t/* If PagePrivate() is set, then the page is not freeable */\n\tif (PagePrivate(page))\n\t\treturn 0;\n\treturn nfs_fscache_release_page(page, gfp);\n}"
  },
  {
    "function_name": "nfs_invalidate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "456-468",
    "snippet": "static void nfs_invalidate_page(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length)\n{\n\tdfprintk(PAGECACHE, \"NFS: invalidate_page(%p, %u, %u)\\n\",\n\t\t page, offset, length);\n\n\tif (offset != 0 || length < PAGE_CACHE_SIZE)\n\t\treturn;\n\t/* Cancel any unstarted writes on this page */\n\tnfs_wb_page_cancel(page_file_mapping(page)->host, page);\n\n\tnfs_fscache_invalidate_page(page, page->mapping->host);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_fscache_invalidate_page",
          "args": [
            "page",
            "page->mapping->host"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs_fscache_invalidate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.c",
          "lines": "283-298",
          "snippet": "void __nfs_fscache_invalidate_page(struct page *page, struct inode *inode)\n{\n\tstruct fscache_cookie *cookie = nfs_i_fscache(inode);\n\n\tBUG_ON(!cookie);\n\n\tdfprintk(FSCACHE, \"NFS: fscache invalidatepage (0x%p/0x%p/0x%p)\\n\",\n\t\t cookie, page, NFS_I(inode));\n\n\tfscache_wait_on_page_write(cookie, page);\n\n\tBUG_ON(!PageLocked(page));\n\tfscache_uncache_page(cookie, page);\n\tnfs_inc_fscache_stats(page->mapping->host,\n\t\t\t      NFSIOS_FSCACHE_PAGES_UNCACHED);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/in6.h>",
            "#include <linux/nfs_fs_sb.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/in6.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/nfs_fs.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid __nfs_fscache_invalidate_page(struct page *page, struct inode *inode)\n{\n\tstruct fscache_cookie *cookie = nfs_i_fscache(inode);\n\n\tBUG_ON(!cookie);\n\n\tdfprintk(FSCACHE, \"NFS: fscache invalidatepage (0x%p/0x%p/0x%p)\\n\",\n\t\t cookie, page, NFS_I(inode));\n\n\tfscache_wait_on_page_write(cookie, page);\n\n\tBUG_ON(!PageLocked(page));\n\tfscache_uncache_page(cookie, page);\n\tnfs_inc_fscache_stats(page->mapping->host,\n\t\t\t      NFSIOS_FSCACHE_PAGES_UNCACHED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_wb_page_cancel",
          "args": [
            "page_file_mapping(page)->host",
            "page"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_wb_page_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1860-1888",
          "snippet": "int nfs_wb_page_cancel(struct inode *inode, struct page *page)\n{\n\tstruct nfs_page *req;\n\tint ret = 0;\n\n\twait_on_page_writeback(page);\n\n\t/* blocking call to cancel all requests and join to a single (head)\n\t * request */\n\treq = nfs_lock_and_join_requests(page, false);\n\n\tif (IS_ERR(req)) {\n\t\tret = PTR_ERR(req);\n\t} else if (req) {\n\t\t/* all requests from this page have been cancelled by\n\t\t * nfs_lock_and_join_requests, so just remove the head\n\t\t * request from the inode / page_private pointer and\n\t\t * release it */\n\t\tnfs_inode_remove_request(req);\n\t\t/*\n\t\t * In case nfs_inode_remove_request has marked the\n\t\t * page as being dirty\n\t\t */\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\t\tnfs_unlock_and_release_request(req);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nint nfs_wb_page_cancel(struct inode *inode, struct page *page)\n{\n\tstruct nfs_page *req;\n\tint ret = 0;\n\n\twait_on_page_writeback(page);\n\n\t/* blocking call to cancel all requests and join to a single (head)\n\t * request */\n\treq = nfs_lock_and_join_requests(page, false);\n\n\tif (IS_ERR(req)) {\n\t\tret = PTR_ERR(req);\n\t} else if (req) {\n\t\t/* all requests from this page have been cancelled by\n\t\t * nfs_lock_and_join_requests, so just remove the head\n\t\t * request from the inode / page_private pointer and\n\t\t * release it */\n\t\tnfs_inode_remove_request(req);\n\t\t/*\n\t\t * In case nfs_inode_remove_request has marked the\n\t\t * page as being dirty\n\t\t */\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\t\tnfs_unlock_and_release_request(req);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_file_mapping",
          "args": [
            "page"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "PAGECACHE",
            "\"NFS: invalidate_page(%p, %u, %u)\\n\"",
            "page",
            "offset",
            "length"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_page(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length)\n{\n\tdfprintk(PAGECACHE, \"NFS: invalidate_page(%p, %u, %u)\\n\",\n\t\t page, offset, length);\n\n\tif (offset != 0 || length < PAGE_CACHE_SIZE)\n\t\treturn;\n\t/* Cancel any unstarted writes on this page */\n\tnfs_wb_page_cancel(page_file_mapping(page)->host, page);\n\n\tnfs_fscache_invalidate_page(page, page->mapping->host);\n}"
  },
  {
    "function_name": "nfs_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "400-447",
    "snippet": "static int nfs_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tunsigned offset = pos & (PAGE_CACHE_SIZE - 1);\n\tstruct nfs_open_context *ctx = nfs_file_open_context(file);\n\tint status;\n\n\tdfprintk(PAGECACHE, \"NFS: write_end(%pD2(%lu), %u@%lld)\\n\",\n\t\tfile, mapping->host->i_ino, len, (long long) pos);\n\n\t/*\n\t * Zero any uninitialised parts of the page, and then mark the page\n\t * as up to date if it turns out that we're extending the file.\n\t */\n\tif (!PageUptodate(page)) {\n\t\tunsigned pglen = nfs_page_length(page);\n\t\tunsigned end = offset + len;\n\n\t\tif (pglen == 0) {\n\t\t\tzero_user_segments(page, 0, offset,\n\t\t\t\t\tend, PAGE_CACHE_SIZE);\n\t\t\tSetPageUptodate(page);\n\t\t} else if (end >= pglen) {\n\t\t\tzero_user_segment(page, end, PAGE_CACHE_SIZE);\n\t\t\tif (offset == 0)\n\t\t\t\tSetPageUptodate(page);\n\t\t} else\n\t\t\tzero_user_segment(page, pglen, PAGE_CACHE_SIZE);\n\t}\n\n\tstatus = nfs_updatepage(file, page, offset, copied);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (status < 0)\n\t\treturn status;\n\tNFS_I(mapping->host)->write_io += copied;\n\n\tif (nfs_ctx_key_to_expire(ctx)) {\n\t\tstatus = nfs_wb_all(mapping->host);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\treturn copied;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_wb_all",
          "args": [
            "mapping->host"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_wb_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1841-1857",
          "snippet": "int nfs_wb_all(struct inode *inode)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\tint ret;\n\n\ttrace_nfs_writeback_inode_enter(inode);\n\n\tret = sync_inode(inode, &wbc);\n\n\ttrace_nfs_writeback_inode_exit(inode, ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nint nfs_wb_all(struct inode *inode)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\tint ret;\n\n\ttrace_nfs_writeback_inode_enter(inode);\n\n\tret = sync_inode(inode, &wbc);\n\n\ttrace_nfs_writeback_inode_exit(inode, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_ctx_key_to_expire",
          "args": [
            "ctx"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_ctx_key_to_expire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1150-1153",
          "snippet": "bool nfs_ctx_key_to_expire(struct nfs_open_context *ctx)\n{\n\treturn rpcauth_cred_key_to_expire(ctx->cred);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool nfs_ctx_key_to_expire(struct nfs_open_context *ctx)\n{\n\treturn rpcauth_cred_key_to_expire(ctx->cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "mapping->host"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_updatepage",
          "args": [
            "file",
            "page",
            "offset",
            "copied"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_updatepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1232-1258",
          "snippet": "int nfs_updatepage(struct file *file, struct page *page,\n\t\tunsigned int offset, unsigned int count)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(file);\n\tstruct inode\t*inode = page_file_mapping(page)->host;\n\tint\t\tstatus = 0;\n\n\tnfs_inc_stats(inode, NFSIOS_VFSUPDATEPAGE);\n\n\tdprintk(\"NFS:       nfs_updatepage(%pD2 %d@%lld)\\n\",\n\t\tfile, count, (long long)(page_file_offset(page) + offset));\n\n\tif (nfs_can_extend_write(file, page, inode)) {\n\t\tcount = max(count + offset, nfs_page_length(page));\n\t\toffset = 0;\n\t}\n\n\tstatus = nfs_writepage_setup(ctx, page, offset, count);\n\tif (status < 0)\n\t\tnfs_set_pageerror(page);\n\telse\n\t\t__set_page_dirty_nobuffers(page);\n\n\tdprintk(\"NFS:       nfs_updatepage returns %d (isize %lld)\\n\",\n\t\t\tstatus, (long long)i_size_read(inode));\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nint nfs_updatepage(struct file *file, struct page *page,\n\t\tunsigned int offset, unsigned int count)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(file);\n\tstruct inode\t*inode = page_file_mapping(page)->host;\n\tint\t\tstatus = 0;\n\n\tnfs_inc_stats(inode, NFSIOS_VFSUPDATEPAGE);\n\n\tdprintk(\"NFS:       nfs_updatepage(%pD2 %d@%lld)\\n\",\n\t\tfile, count, (long long)(page_file_offset(page) + offset));\n\n\tif (nfs_can_extend_write(file, page, inode)) {\n\t\tcount = max(count + offset, nfs_page_length(page));\n\t\toffset = 0;\n\t}\n\n\tstatus = nfs_writepage_setup(ctx, page, offset, count);\n\tif (status < 0)\n\t\tnfs_set_pageerror(page);\n\telse\n\t\t__set_page_dirty_nobuffers(page);\n\n\tdprintk(\"NFS:       nfs_updatepage returns %d (isize %lld)\\n\",\n\t\t\tstatus, (long long)i_size_read(inode));\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "pglen",
            "PAGE_CACHE_SIZE"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "end",
            "PAGE_CACHE_SIZE"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segments",
          "args": [
            "page",
            "0",
            "offset",
            "end",
            "PAGE_CACHE_SIZE"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_page_length",
          "args": [
            "page"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "617-631",
          "snippet": "static inline\nunsigned int nfs_page_length(struct page *page)\n{\n\tloff_t i_size = i_size_read(page_file_mapping(page)->host);\n\n\tif (i_size > 0) {\n\t\tpgoff_t page_index = page_file_index(page);\n\t\tpgoff_t end_index = (i_size - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (page_index < end_index)\n\t\t\treturn PAGE_CACHE_SIZE;\n\t\tif (page_index == end_index)\n\t\t\treturn ((i_size - 1) & ~PAGE_CACHE_MASK) + 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int nfs_file_fsync_commit(struct file *, loff_t, loff_t, int);",
            "loff_t nfs_file_llseek(struct file *, loff_t, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nint nfs_file_fsync_commit(struct file *, loff_t, loff_t, int);\nloff_t nfs_file_llseek(struct file *, loff_t, int);\n\nstatic inline\nunsigned int nfs_page_length(struct page *page)\n{\n\tloff_t i_size = i_size_read(page_file_mapping(page)->host);\n\n\tif (i_size > 0) {\n\t\tpgoff_t page_index = page_file_index(page);\n\t\tpgoff_t end_index = (i_size - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (page_index < end_index)\n\t\t\treturn PAGE_CACHE_SIZE;\n\t\tif (page_index == end_index)\n\t\t\treturn ((i_size - 1) & ~PAGE_CACHE_MASK) + 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "PAGECACHE",
            "\"NFS: write_end(%pD2(%lu), %u@%lld)\\n\"",
            "file",
            "mapping->host->i_ino",
            "len",
            "(long long) pos"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_file_open_context",
          "args": [
            "file"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tunsigned offset = pos & (PAGE_CACHE_SIZE - 1);\n\tstruct nfs_open_context *ctx = nfs_file_open_context(file);\n\tint status;\n\n\tdfprintk(PAGECACHE, \"NFS: write_end(%pD2(%lu), %u@%lld)\\n\",\n\t\tfile, mapping->host->i_ino, len, (long long) pos);\n\n\t/*\n\t * Zero any uninitialised parts of the page, and then mark the page\n\t * as up to date if it turns out that we're extending the file.\n\t */\n\tif (!PageUptodate(page)) {\n\t\tunsigned pglen = nfs_page_length(page);\n\t\tunsigned end = offset + len;\n\n\t\tif (pglen == 0) {\n\t\t\tzero_user_segments(page, 0, offset,\n\t\t\t\t\tend, PAGE_CACHE_SIZE);\n\t\t\tSetPageUptodate(page);\n\t\t} else if (end >= pglen) {\n\t\t\tzero_user_segment(page, end, PAGE_CACHE_SIZE);\n\t\t\tif (offset == 0)\n\t\t\t\tSetPageUptodate(page);\n\t\t} else\n\t\t\tzero_user_segment(page, pglen, PAGE_CACHE_SIZE);\n\t}\n\n\tstatus = nfs_updatepage(file, page, offset, copied);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (status < 0)\n\t\treturn status;\n\tNFS_I(mapping->host)->write_io += copied;\n\n\tif (nfs_ctx_key_to_expire(ctx)) {\n\t\tstatus = nfs_wb_all(mapping->host);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\treturn copied;\n}"
  },
  {
    "function_name": "nfs_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "354-398",
    "snippet": "static int nfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint once_thru = 0;\n\n\tdfprintk(PAGECACHE, \"NFS: write_begin(%pD2(%lu), %u@%lld)\\n\",\n\t\tfile, mapping->host->i_ino, len, (long long) pos);\n\nstart:\n\t/*\n\t * Prevent starvation issues if someone is doing a consistency\n\t * sync-to-disk\n\t */\n\tret = wait_on_bit_action(&NFS_I(mapping->host)->flags, NFS_INO_FLUSHING,\n\t\t\t\t nfs_wait_bit_killable, TASK_KILLABLE);\n\tif (ret)\n\t\treturn ret;\n\t/*\n\t * Wait for O_DIRECT to complete\n\t */\n\tnfs_inode_dio_wait(mapping->host);\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\t*pagep = page;\n\n\tret = nfs_flush_incompatible(file, page);\n\tif (ret) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t} else if (!once_thru &&\n\t\t   nfs_want_read_modify_write(file, page, pos, len)) {\n\t\tonce_thru = 1;\n\t\tret = nfs_readpage(file, page);\n\t\tpage_cache_release(page);\n\t\tif (!ret)\n\t\t\tgoto start;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_readpage",
          "args": [
            "file",
            "page"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
          "lines": "278-328",
          "snippet": "int nfs_readpage(struct file *file, struct page *page)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tint\t\terror;\n\n\tdprintk(\"NFS: nfs_readpage (%p %ld@%lu)\\n\",\n\t\tpage, PAGE_CACHE_SIZE, page_file_index(page));\n\tnfs_inc_stats(inode, NFSIOS_VFSREADPAGE);\n\tnfs_inc_stats(inode, NFSIOS_READPAGES);\n\n\t/*\n\t * Try to flush any pending writes to the file..\n\t *\n\t * NOTE! Because we own the page lock, there cannot\n\t * be any new pending writes generated at this point\n\t * for this page (other pages can be written to).\n\t */\n\terror = nfs_wb_page(inode, page);\n\tif (error)\n\t\tgoto out_unlock;\n\tif (PageUptodate(page))\n\t\tgoto out_unlock;\n\n\terror = -ESTALE;\n\tif (NFS_STALE(inode))\n\t\tgoto out_unlock;\n\n\tif (file == NULL) {\n\t\terror = -EBADF;\n\t\tctx = nfs_find_open_context(inode, NULL, FMODE_READ);\n\t\tif (ctx == NULL)\n\t\t\tgoto out_unlock;\n\t} else\n\t\tctx = get_nfs_open_context(nfs_file_open_context(file));\n\n\tif (!IS_SYNC(inode)) {\n\t\terror = nfs_readpage_from_fscache(ctx, inode, page);\n\t\tif (error == 0)\n\t\t\tgoto out;\n\t}\n\n\terror = nfs_readpage_async(ctx, inode, page);\n\nout:\n\tput_nfs_open_context(ctx);\n\treturn error;\nout_unlock:\n\tunlock_page(page);\n\treturn error;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nint nfs_readpage(struct file *file, struct page *page)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tint\t\terror;\n\n\tdprintk(\"NFS: nfs_readpage (%p %ld@%lu)\\n\",\n\t\tpage, PAGE_CACHE_SIZE, page_file_index(page));\n\tnfs_inc_stats(inode, NFSIOS_VFSREADPAGE);\n\tnfs_inc_stats(inode, NFSIOS_READPAGES);\n\n\t/*\n\t * Try to flush any pending writes to the file..\n\t *\n\t * NOTE! Because we own the page lock, there cannot\n\t * be any new pending writes generated at this point\n\t * for this page (other pages can be written to).\n\t */\n\terror = nfs_wb_page(inode, page);\n\tif (error)\n\t\tgoto out_unlock;\n\tif (PageUptodate(page))\n\t\tgoto out_unlock;\n\n\terror = -ESTALE;\n\tif (NFS_STALE(inode))\n\t\tgoto out_unlock;\n\n\tif (file == NULL) {\n\t\terror = -EBADF;\n\t\tctx = nfs_find_open_context(inode, NULL, FMODE_READ);\n\t\tif (ctx == NULL)\n\t\t\tgoto out_unlock;\n\t} else\n\t\tctx = get_nfs_open_context(nfs_file_open_context(file));\n\n\tif (!IS_SYNC(inode)) {\n\t\terror = nfs_readpage_from_fscache(ctx, inode, page);\n\t\tif (error == 0)\n\t\t\tgoto out;\n\t}\n\n\terror = nfs_readpage_async(ctx, inode, page);\n\nout:\n\tput_nfs_open_context(ctx);\n\treturn error;\nout_unlock:\n\tunlock_page(page);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_want_read_modify_write",
          "args": [
            "file",
            "page",
            "pos",
            "len"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_want_read_modify_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
          "lines": "324-344",
          "snippet": "static int nfs_want_read_modify_write(struct file *file, struct page *page,\n\t\t\tloff_t pos, unsigned len)\n{\n\tunsigned int pglen = nfs_page_length(page);\n\tunsigned int offset = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned int end = offset + len;\n\n\tif (pnfs_ld_read_whole_page(file->f_mapping->host)) {\n\t\tif (!PageUptodate(page))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tif ((file->f_mode & FMODE_READ) &&\t/* open for read? */\n\t    !PageUptodate(page) &&\t\t/* Uptodate? */\n\t    !PagePrivate(page) &&\t\t/* i/o request already? */\n\t    pglen &&\t\t\t\t/* valid bytes of file? */\n\t    (end < pglen || offset))\t\t/* replace all valid bytes? */\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/swap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_want_read_modify_write(struct file *file, struct page *page,\n\t\t\tloff_t pos, unsigned len)\n{\n\tunsigned int pglen = nfs_page_length(page);\n\tunsigned int offset = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned int end = offset + len;\n\n\tif (pnfs_ld_read_whole_page(file->f_mapping->host)) {\n\t\tif (!PageUptodate(page))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tif ((file->f_mode & FMODE_READ) &&\t/* open for read? */\n\t    !PageUptodate(page) &&\t\t/* Uptodate? */\n\t    !PagePrivate(page) &&\t\t/* i/o request already? */\n\t    pglen &&\t\t\t\t/* valid bytes of file? */\n\t    (end < pglen || offset))\t\t/* replace all valid bytes? */\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_flush_incompatible",
          "args": [
            "file",
            "page"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_flush_incompatible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1091-1126",
          "snippet": "int nfs_flush_incompatible(struct file *file, struct page *page)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(file);\n\tstruct nfs_lock_context *l_ctx;\n\tstruct file_lock_context *flctx = file_inode(file)->i_flctx;\n\tstruct nfs_page\t*req;\n\tint do_flush, status;\n\t/*\n\t * Look for a request corresponding to this page. If there\n\t * is one, and it belongs to another file, we flush it out\n\t * before we try to copy anything into the page. Do this\n\t * due to the lack of an ACCESS-type call in NFSv2.\n\t * Also do the same if we find a request from an existing\n\t * dropped page.\n\t */\n\tdo {\n\t\treq = nfs_page_find_head_request(page);\n\t\tif (req == NULL)\n\t\t\treturn 0;\n\t\tl_ctx = req->wb_lock_context;\n\t\tdo_flush = req->wb_page != page || req->wb_context != ctx;\n\t\t/* for now, flush if more than 1 request in page_group */\n\t\tdo_flush |= req->wb_this_page != req;\n\t\tif (l_ctx && flctx &&\n\t\t    !(list_empty_careful(&flctx->flc_posix) &&\n\t\t      list_empty_careful(&flctx->flc_flock))) {\n\t\t\tdo_flush |= l_ctx->lockowner.l_owner != current->files\n\t\t\t\t|| l_ctx->lockowner.l_pid != current->tgid;\n\t\t}\n\t\tnfs_release_request(req);\n\t\tif (!do_flush)\n\t\t\treturn 0;\n\t\tstatus = nfs_wb_page(page_file_mapping(page)->host, page);\n\t} while (status == 0);\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nint nfs_flush_incompatible(struct file *file, struct page *page)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(file);\n\tstruct nfs_lock_context *l_ctx;\n\tstruct file_lock_context *flctx = file_inode(file)->i_flctx;\n\tstruct nfs_page\t*req;\n\tint do_flush, status;\n\t/*\n\t * Look for a request corresponding to this page. If there\n\t * is one, and it belongs to another file, we flush it out\n\t * before we try to copy anything into the page. Do this\n\t * due to the lack of an ACCESS-type call in NFSv2.\n\t * Also do the same if we find a request from an existing\n\t * dropped page.\n\t */\n\tdo {\n\t\treq = nfs_page_find_head_request(page);\n\t\tif (req == NULL)\n\t\t\treturn 0;\n\t\tl_ctx = req->wb_lock_context;\n\t\tdo_flush = req->wb_page != page || req->wb_context != ctx;\n\t\t/* for now, flush if more than 1 request in page_group */\n\t\tdo_flush |= req->wb_this_page != req;\n\t\tif (l_ctx && flctx &&\n\t\t    !(list_empty_careful(&flctx->flc_posix) &&\n\t\t      list_empty_careful(&flctx->flc_flock))) {\n\t\t\tdo_flush |= l_ctx->lockowner.l_owner != current->files\n\t\t\t\t|| l_ctx->lockowner.l_pid != current->tgid;\n\t\t}\n\t\tnfs_release_request(req);\n\t\tif (!do_flush)\n\t\t\treturn 0;\n\t\tstatus = nfs_wb_page(page_file_mapping(page)->host, page);\n\t} while (status == 0);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "index",
            "flags"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_inode_dio_wait",
          "args": [
            "mapping->host"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "498-501",
          "snippet": "static inline void nfs_inode_dio_wait(struct inode *inode)\n{\n\tinode_dio_wait(inode);\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);",
            "extern void nfs_destroy_inode(struct inode *);",
            "extern int nfs_drop_inode(struct inode *);",
            "extern void nfs_clear_inode(struct inode *);",
            "extern void nfs_evict_inode(struct inode *);",
            "void nfs_zap_acl_cache(struct inode *inode);",
            "int nfs_key_timeout_notify(struct file *filp, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nextern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);\nextern void nfs_destroy_inode(struct inode *);\nextern int nfs_drop_inode(struct inode *);\nextern void nfs_clear_inode(struct inode *);\nextern void nfs_evict_inode(struct inode *);\nvoid nfs_zap_acl_cache(struct inode *inode);\nint nfs_key_timeout_notify(struct file *filp, struct inode *inode);\n\nstatic inline void nfs_inode_dio_wait(struct inode *inode)\n{\n\tinode_dio_wait(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_bit_action",
          "args": [
            "&NFS_I(mapping->host)->flags",
            "NFS_INO_FLUSHING",
            "nfs_wait_bit_killable",
            "TASK_KILLABLE"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "mapping->host"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "PAGECACHE",
            "\"NFS: write_begin(%pD2(%lu), %u@%lld)\\n\"",
            "file",
            "mapping->host->i_ino",
            "len",
            "(long long) pos"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint once_thru = 0;\n\n\tdfprintk(PAGECACHE, \"NFS: write_begin(%pD2(%lu), %u@%lld)\\n\",\n\t\tfile, mapping->host->i_ino, len, (long long) pos);\n\nstart:\n\t/*\n\t * Prevent starvation issues if someone is doing a consistency\n\t * sync-to-disk\n\t */\n\tret = wait_on_bit_action(&NFS_I(mapping->host)->flags, NFS_INO_FLUSHING,\n\t\t\t\t nfs_wait_bit_killable, TASK_KILLABLE);\n\tif (ret)\n\t\treturn ret;\n\t/*\n\t * Wait for O_DIRECT to complete\n\t */\n\tnfs_inode_dio_wait(mapping->host);\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\t*pagep = page;\n\n\tret = nfs_flush_incompatible(file, page);\n\tif (ret) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t} else if (!once_thru &&\n\t\t   nfs_want_read_modify_write(file, page, pos, len)) {\n\t\tonce_thru = 1;\n\t\tret = nfs_readpage(file, page);\n\t\tpage_cache_release(page);\n\t\tif (!ret)\n\t\t\tgoto start;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs_want_read_modify_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "324-344",
    "snippet": "static int nfs_want_read_modify_write(struct file *file, struct page *page,\n\t\t\tloff_t pos, unsigned len)\n{\n\tunsigned int pglen = nfs_page_length(page);\n\tunsigned int offset = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned int end = offset + len;\n\n\tif (pnfs_ld_read_whole_page(file->f_mapping->host)) {\n\t\tif (!PageUptodate(page))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tif ((file->f_mode & FMODE_READ) &&\t/* open for read? */\n\t    !PageUptodate(page) &&\t\t/* Uptodate? */\n\t    !PagePrivate(page) &&\t\t/* i/o request already? */\n\t    pglen &&\t\t\t\t/* valid bytes of file? */\n\t    (end < pglen || offset))\t\t/* replace all valid bytes? */\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_ld_read_whole_page",
          "args": [
            "file->f_mapping->host"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_ld_read_whole_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "565-569",
          "snippet": "static inline bool\npnfs_ld_read_whole_page(struct inode *inode)\n{\n\treturn false;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline bool\npnfs_ld_read_whole_page(struct inode *inode)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_page_length",
          "args": [
            "page"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "617-631",
          "snippet": "static inline\nunsigned int nfs_page_length(struct page *page)\n{\n\tloff_t i_size = i_size_read(page_file_mapping(page)->host);\n\n\tif (i_size > 0) {\n\t\tpgoff_t page_index = page_file_index(page);\n\t\tpgoff_t end_index = (i_size - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (page_index < end_index)\n\t\t\treturn PAGE_CACHE_SIZE;\n\t\tif (page_index == end_index)\n\t\t\treturn ((i_size - 1) & ~PAGE_CACHE_MASK) + 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int nfs_file_fsync_commit(struct file *, loff_t, loff_t, int);",
            "loff_t nfs_file_llseek(struct file *, loff_t, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nint nfs_file_fsync_commit(struct file *, loff_t, loff_t, int);\nloff_t nfs_file_llseek(struct file *, loff_t, int);\n\nstatic inline\nunsigned int nfs_page_length(struct page *page)\n{\n\tloff_t i_size = i_size_read(page_file_mapping(page)->host);\n\n\tif (i_size > 0) {\n\t\tpgoff_t page_index = page_file_index(page);\n\t\tpgoff_t end_index = (i_size - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (page_index < end_index)\n\t\t\treturn PAGE_CACHE_SIZE;\n\t\tif (page_index == end_index)\n\t\t\treturn ((i_size - 1) & ~PAGE_CACHE_MASK) + 1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_want_read_modify_write(struct file *file, struct page *page,\n\t\t\tloff_t pos, unsigned len)\n{\n\tunsigned int pglen = nfs_page_length(page);\n\tunsigned int offset = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned int end = offset + len;\n\n\tif (pnfs_ld_read_whole_page(file->f_mapping->host)) {\n\t\tif (!PageUptodate(page))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tif ((file->f_mode & FMODE_READ) &&\t/* open for read? */\n\t    !PageUptodate(page) &&\t\t/* Uptodate? */\n\t    !PagePrivate(page) &&\t\t/* i/o request already? */\n\t    pglen &&\t\t\t\t/* valid bytes of file? */\n\t    (end < pglen || offset))\t\t/* replace all valid bytes? */\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs_file_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "276-302",
    "snippet": "static int\nnfs_file_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tint ret;\n\tstruct inode *inode = file_inode(file);\n\n\ttrace_nfs_fsync_enter(inode);\n\n\tdo {\n\t\tret = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\tmutex_lock(&inode->i_mutex);\n\t\tret = nfs_file_fsync_commit(file, start, end, datasync);\n\t\tmutex_unlock(&inode->i_mutex);\n\t\t/*\n\t\t * If nfs_file_fsync_commit detected a server reboot, then\n\t\t * resend all dirty pages that might have been covered by\n\t\t * the NFS_CONTEXT_RESEND_WRITES flag\n\t\t */\n\t\tstart = 0;\n\t\tend = LLONG_MAX;\n\t} while (ret == -EAGAIN);\n\n\ttrace_nfs_fsync_exit(inode, ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_nfs_fsync_exit",
          "args": [
            "inode",
            "ret"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_file_fsync_commit",
          "args": [
            "file",
            "start",
            "end",
            "datasync"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_file_fsync_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
          "lines": "244-273",
          "snippet": "int\nnfs_file_fsync_commit(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(file);\n\tstruct inode *inode = file_inode(file);\n\tint have_error, do_resend, status;\n\tint ret = 0;\n\n\tdprintk(\"NFS: fsync file(%pD2) datasync %d\\n\", file, datasync);\n\n\tnfs_inc_stats(inode, NFSIOS_VFSFSYNC);\n\tdo_resend = test_and_clear_bit(NFS_CONTEXT_RESEND_WRITES, &ctx->flags);\n\thave_error = test_and_clear_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags);\n\tstatus = nfs_commit_inode(inode, FLUSH_SYNC);\n\thave_error |= test_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags);\n\tif (have_error) {\n\t\tret = xchg(&ctx->error, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (status < 0) {\n\t\tret = status;\n\t\tgoto out;\n\t}\n\tdo_resend |= test_bit(NFS_CONTEXT_RESEND_WRITES, &ctx->flags);\n\tif (do_resend)\n\t\tret = -EAGAIN;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/swap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint\nnfs_file_fsync_commit(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(file);\n\tstruct inode *inode = file_inode(file);\n\tint have_error, do_resend, status;\n\tint ret = 0;\n\n\tdprintk(\"NFS: fsync file(%pD2) datasync %d\\n\", file, datasync);\n\n\tnfs_inc_stats(inode, NFSIOS_VFSFSYNC);\n\tdo_resend = test_and_clear_bit(NFS_CONTEXT_RESEND_WRITES, &ctx->flags);\n\thave_error = test_and_clear_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags);\n\tstatus = nfs_commit_inode(inode, FLUSH_SYNC);\n\thave_error |= test_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags);\n\tif (have_error) {\n\t\tret = xchg(&ctx->error, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (status < 0) {\n\t\tret = status;\n\t\tgoto out;\n\t}\n\tdo_resend |= test_bit(NFS_CONTEXT_RESEND_WRITES, &ctx->flags);\n\tif (do_resend)\n\t\tret = -EAGAIN;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "inode->i_mapping",
            "start",
            "end"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_nfs_fsync_enter",
          "args": [
            "inode"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int\nnfs_file_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tint ret;\n\tstruct inode *inode = file_inode(file);\n\n\ttrace_nfs_fsync_enter(inode);\n\n\tdo {\n\t\tret = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\tmutex_lock(&inode->i_mutex);\n\t\tret = nfs_file_fsync_commit(file, start, end, datasync);\n\t\tmutex_unlock(&inode->i_mutex);\n\t\t/*\n\t\t * If nfs_file_fsync_commit detected a server reboot, then\n\t\t * resend all dirty pages that might have been covered by\n\t\t * the NFS_CONTEXT_RESEND_WRITES flag\n\t\t */\n\t\tstart = 0;\n\t\tend = LLONG_MAX;\n\t} while (ret == -EAGAIN);\n\n\ttrace_nfs_fsync_exit(inode, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs_file_fsync_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "244-273",
    "snippet": "int\nnfs_file_fsync_commit(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(file);\n\tstruct inode *inode = file_inode(file);\n\tint have_error, do_resend, status;\n\tint ret = 0;\n\n\tdprintk(\"NFS: fsync file(%pD2) datasync %d\\n\", file, datasync);\n\n\tnfs_inc_stats(inode, NFSIOS_VFSFSYNC);\n\tdo_resend = test_and_clear_bit(NFS_CONTEXT_RESEND_WRITES, &ctx->flags);\n\thave_error = test_and_clear_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags);\n\tstatus = nfs_commit_inode(inode, FLUSH_SYNC);\n\thave_error |= test_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags);\n\tif (have_error) {\n\t\tret = xchg(&ctx->error, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (status < 0) {\n\t\tret = status;\n\t\tgoto out;\n\t}\n\tdo_resend |= test_bit(NFS_CONTEXT_RESEND_WRITES, &ctx->flags);\n\tif (do_resend)\n\t\tret = -EAGAIN;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_CONTEXT_RESEND_WRITES",
            "&ctx->flags"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&ctx->error",
            "0"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_commit_inode",
          "args": [
            "inode",
            "FLUSH_SYNC"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_commit_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1757-1794",
          "snippet": "int nfs_commit_inode(struct inode *inode, int how)\n{\n\tLIST_HEAD(head);\n\tstruct nfs_commit_info cinfo;\n\tint may_wait = how & FLUSH_SYNC;\n\tint res;\n\n\tres = nfs_commit_set_lock(NFS_I(inode), may_wait);\n\tif (res <= 0)\n\t\tgoto out_mark_dirty;\n\tnfs_init_cinfo_from_inode(&cinfo, inode);\n\tres = nfs_scan_commit(inode, &head, &cinfo);\n\tif (res) {\n\t\tint error;\n\n\t\terror = nfs_generic_commit_list(inode, &head, how, &cinfo);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (!may_wait)\n\t\t\tgoto out_mark_dirty;\n\t\terror = wait_on_bit_action(&NFS_I(inode)->flags,\n\t\t\t\tNFS_INO_COMMIT,\n\t\t\t\tnfs_wait_bit_killable,\n\t\t\t\tTASK_KILLABLE);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t} else\n\t\tnfs_commit_clear_lock(NFS_I(inode));\n\treturn res;\n\t/* Note: If we exit without ensuring that the commit is complete,\n\t * we must mark the inode as dirty. Otherwise, future calls to\n\t * sync_inode() with the WB_SYNC_ALL flag set will fail to ensure\n\t * that the data is on the disk.\n\t */\nout_mark_dirty:\n\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\treturn res;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nint nfs_commit_inode(struct inode *inode, int how)\n{\n\tLIST_HEAD(head);\n\tstruct nfs_commit_info cinfo;\n\tint may_wait = how & FLUSH_SYNC;\n\tint res;\n\n\tres = nfs_commit_set_lock(NFS_I(inode), may_wait);\n\tif (res <= 0)\n\t\tgoto out_mark_dirty;\n\tnfs_init_cinfo_from_inode(&cinfo, inode);\n\tres = nfs_scan_commit(inode, &head, &cinfo);\n\tif (res) {\n\t\tint error;\n\n\t\terror = nfs_generic_commit_list(inode, &head, how, &cinfo);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (!may_wait)\n\t\t\tgoto out_mark_dirty;\n\t\terror = wait_on_bit_action(&NFS_I(inode)->flags,\n\t\t\t\tNFS_INO_COMMIT,\n\t\t\t\tnfs_wait_bit_killable,\n\t\t\t\tTASK_KILLABLE);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t} else\n\t\tnfs_commit_clear_lock(NFS_I(inode));\n\treturn res;\n\t/* Note: If we exit without ensuring that the commit is complete,\n\t * we must mark the inode as dirty. Otherwise, future calls to\n\t * sync_inode() with the WB_SYNC_ALL flag set will fail to ensure\n\t * that the data is on the disk.\n\t */\nout_mark_dirty:\n\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "NFS_CONTEXT_ERROR_WRITE",
            "&ctx->flags"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_inc_stats",
          "args": [
            "inode",
            "NFSIOS_VFSFSYNC"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "31-35",
          "snippet": "static inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: fsync file(%pD2) datasync %d\\n\"",
            "file",
            "datasync"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_file_open_context",
          "args": [
            "file"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint\nnfs_file_fsync_commit(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(file);\n\tstruct inode *inode = file_inode(file);\n\tint have_error, do_resend, status;\n\tint ret = 0;\n\n\tdprintk(\"NFS: fsync file(%pD2) datasync %d\\n\", file, datasync);\n\n\tnfs_inc_stats(inode, NFSIOS_VFSFSYNC);\n\tdo_resend = test_and_clear_bit(NFS_CONTEXT_RESEND_WRITES, &ctx->flags);\n\thave_error = test_and_clear_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags);\n\tstatus = nfs_commit_inode(inode, FLUSH_SYNC);\n\thave_error |= test_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags);\n\tif (have_error) {\n\t\tret = xchg(&ctx->error, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (status < 0) {\n\t\tret = status;\n\t\tgoto out;\n\t}\n\tdo_resend |= test_bit(NFS_CONTEXT_RESEND_WRITES, &ctx->flags);\n\tif (do_resend)\n\t\tret = -EAGAIN;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs_file_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "212-229",
    "snippet": "int\nnfs_file_mmap(struct file * file, struct vm_area_struct * vma)\n{\n\tstruct inode *inode = file_inode(file);\n\tint\tstatus;\n\n\tdprintk(\"NFS: mmap(%pD2)\\n\", file);\n\n\t/* Note: generic_file_mmap() returns ENOSYS on nommu systems\n\t *       so we call that before revalidating the mapping\n\t */\n\tstatus = generic_file_mmap(file, vma);\n\tif (!status) {\n\t\tvma->vm_ops = &nfs_file_vm_ops;\n\t\tstatus = nfs_revalidate_mapping(inode, file->f_mapping);\n\t}\n\treturn status;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct vm_operations_struct nfs_file_vm_ops;",
      "static const struct vm_operations_struct nfs_file_vm_ops = {\n\t.fault = filemap_fault,\n\t.map_pages = filemap_map_pages,\n\t.page_mkwrite = nfs_vm_page_mkwrite,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_revalidate_mapping",
          "args": [
            "inode",
            "file->f_mapping"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_revalidate_mapping_protected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1160-1163",
          "snippet": "int nfs_revalidate_mapping_protected(struct inode *inode, struct address_space *mapping)\n{\n\treturn __nfs_revalidate_mapping(inode, mapping, true);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nint nfs_revalidate_mapping_protected(struct inode *inode, struct address_space *mapping)\n{\n\treturn __nfs_revalidate_mapping(inode, mapping, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_file_mmap",
          "args": [
            "file",
            "vma"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: mmap(%pD2)\\n\"",
            "file"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic const struct vm_operations_struct nfs_file_vm_ops;\nstatic const struct vm_operations_struct nfs_file_vm_ops = {\n\t.fault = filemap_fault,\n\t.map_pages = filemap_map_pages,\n\t.page_mkwrite = nfs_vm_page_mkwrite,\n};\n\nint\nnfs_file_mmap(struct file * file, struct vm_area_struct * vma)\n{\n\tstruct inode *inode = file_inode(file);\n\tint\tstatus;\n\n\tdprintk(\"NFS: mmap(%pD2)\\n\", file);\n\n\t/* Note: generic_file_mmap() returns ENOSYS on nommu systems\n\t *       so we call that before revalidating the mapping\n\t */\n\tstatus = generic_file_mmap(file, vma);\n\tif (!status) {\n\t\tvma->vm_ops = &nfs_file_vm_ops;\n\t\tstatus = nfs_revalidate_mapping(inode, file->f_mapping);\n\t}\n\treturn status;\n}"
  },
  {
    "function_name": "nfs_file_splice_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "191-209",
    "snippet": "ssize_t\nnfs_file_splice_read(struct file *filp, loff_t *ppos,\n\t\t     struct pipe_inode_info *pipe, size_t count,\n\t\t     unsigned int flags)\n{\n\tstruct inode *inode = file_inode(filp);\n\tssize_t res;\n\n\tdprintk(\"NFS: splice_read(%pD2, %lu@%Lu)\\n\",\n\t\tfilp, (unsigned long) count, (unsigned long long) *ppos);\n\n\tres = nfs_revalidate_mapping_protected(inode, filp->f_mapping);\n\tif (!res) {\n\t\tres = generic_file_splice_read(filp, ppos, pipe, count, flags);\n\t\tif (res > 0)\n\t\t\tnfs_add_stats(inode, NFSIOS_NORMALREADBYTES, res);\n\t}\n\treturn res;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_add_stats",
          "args": [
            "inode",
            "NFSIOS_NORMALREADBYTES",
            "res"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_add_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "44-49",
          "snippet": "static inline void nfs_add_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_bytecounters stat,\n\t\t\t\t long addend)\n{\n\tnfs_add_server_stats(NFS_SERVER(inode), stat, addend);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_add_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_bytecounters stat,\n\t\t\t\t long addend)\n{\n\tnfs_add_server_stats(NFS_SERVER(inode), stat, addend);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_file_splice_read",
          "args": [
            "filp",
            "ppos",
            "pipe",
            "count",
            "flags"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_splice_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "520-542",
          "snippet": "ssize_t generic_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t\t unsigned int flags)\n{\n\tloff_t isize, left;\n\tint ret;\n\n\tisize = i_size_read(in->f_mapping->host);\n\tif (unlikely(*ppos >= isize))\n\t\treturn 0;\n\n\tleft = isize - *ppos;\n\tif (unlikely(left < len))\n\t\tlen = left;\n\n\tret = __generic_file_splice_read(in, ppos, pipe, len, flags);\n\tif (ret > 0) {\n\t\t*ppos += ret;\n\t\tfile_accessed(in);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t generic_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t\t unsigned int flags)\n{\n\tloff_t isize, left;\n\tint ret;\n\n\tisize = i_size_read(in->f_mapping->host);\n\tif (unlikely(*ppos >= isize))\n\t\treturn 0;\n\n\tleft = isize - *ppos;\n\tif (unlikely(left < len))\n\t\tlen = left;\n\n\tret = __generic_file_splice_read(in, ppos, pipe, len, flags);\n\tif (ret > 0) {\n\t\t*ppos += ret;\n\t\tfile_accessed(in);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_revalidate_mapping_protected",
          "args": [
            "inode",
            "filp->f_mapping"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_revalidate_mapping_protected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1160-1163",
          "snippet": "int nfs_revalidate_mapping_protected(struct inode *inode, struct address_space *mapping)\n{\n\treturn __nfs_revalidate_mapping(inode, mapping, true);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nint nfs_revalidate_mapping_protected(struct inode *inode, struct address_space *mapping)\n{\n\treturn __nfs_revalidate_mapping(inode, mapping, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: splice_read(%pD2, %lu@%Lu)\\n\"",
            "filp",
            "(unsigned long) count",
            "(unsigned long long) *ppos"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nssize_t\nnfs_file_splice_read(struct file *filp, loff_t *ppos,\n\t\t     struct pipe_inode_info *pipe, size_t count,\n\t\t     unsigned int flags)\n{\n\tstruct inode *inode = file_inode(filp);\n\tssize_t res;\n\n\tdprintk(\"NFS: splice_read(%pD2, %lu@%Lu)\\n\",\n\t\tfilp, (unsigned long) count, (unsigned long long) *ppos);\n\n\tres = nfs_revalidate_mapping_protected(inode, filp->f_mapping);\n\tif (!res) {\n\t\tres = generic_file_splice_read(filp, ppos, pipe, count, flags);\n\t\tif (res > 0)\n\t\t\tnfs_add_stats(inode, NFSIOS_NORMALREADBYTES, res);\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "nfs_file_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "168-188",
    "snippet": "ssize_t\nnfs_file_read(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tssize_t result;\n\n\tif (iocb->ki_filp->f_flags & O_DIRECT)\n\t\treturn nfs_file_direct_read(iocb, to, iocb->ki_pos);\n\n\tdprintk(\"NFS: read(%pD2, %zu@%lu)\\n\",\n\t\tiocb->ki_filp,\n\t\tiov_iter_count(to), (unsigned long) iocb->ki_pos);\n\n\tresult = nfs_revalidate_mapping_protected(inode, iocb->ki_filp->f_mapping);\n\tif (!result) {\n\t\tresult = generic_file_read_iter(iocb, to);\n\t\tif (result > 0)\n\t\t\tnfs_add_stats(inode, NFSIOS_NORMALREADBYTES, result);\n\t}\n\treturn result;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_add_stats",
          "args": [
            "inode",
            "NFSIOS_NORMALREADBYTES",
            "result"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_add_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "44-49",
          "snippet": "static inline void nfs_add_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_bytecounters stat,\n\t\t\t\t long addend)\n{\n\tnfs_add_server_stats(NFS_SERVER(inode), stat, addend);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_add_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_bytecounters stat,\n\t\t\t\t long addend)\n{\n\tnfs_add_server_stats(NFS_SERVER(inode), stat, addend);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_file_read_iter",
          "args": [
            "iocb",
            "to"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_revalidate_mapping_protected",
          "args": [
            "inode",
            "iocb->ki_filp->f_mapping"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_revalidate_mapping_protected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1160-1163",
          "snippet": "int nfs_revalidate_mapping_protected(struct inode *inode, struct address_space *mapping)\n{\n\treturn __nfs_revalidate_mapping(inode, mapping, true);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nint nfs_revalidate_mapping_protected(struct inode *inode, struct address_space *mapping)\n{\n\treturn __nfs_revalidate_mapping(inode, mapping, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: read(%pD2, %zu@%lu)\\n\"",
            "iocb->ki_filp",
            "iov_iter_count(to)",
            "(unsigned long) iocb->ki_pos"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "to"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_file_direct_read",
          "args": [
            "iocb",
            "to",
            "iocb->ki_pos"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_file_direct_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "572-636",
          "snippet": "ssize_t nfs_file_direct_read(struct kiocb *iocb, struct iov_iter *iter,\n\t\t\t\tloff_t pos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct nfs_direct_req *dreq;\n\tstruct nfs_lock_context *l_ctx;\n\tssize_t result = -EINVAL;\n\tsize_t count = iov_iter_count(iter);\n\tnfs_add_stats(mapping->host, NFSIOS_DIRECTREADBYTES, count);\n\n\tdfprintk(FILE, \"NFS: direct read(%pD2, %zd@%Ld)\\n\",\n\t\tfile, count, (long long) pos);\n\n\tresult = 0;\n\tif (!count)\n\t\tgoto out;\n\n\tmutex_lock(&inode->i_mutex);\n\tresult = nfs_sync_mapping(mapping);\n\tif (result)\n\t\tgoto out_unlock;\n\n\ttask_io_account_read(count);\n\n\tresult = -ENOMEM;\n\tdreq = nfs_direct_req_alloc();\n\tif (dreq == NULL)\n\t\tgoto out_unlock;\n\n\tdreq->inode = inode;\n\tdreq->bytes_left = count;\n\tdreq->io_start = pos;\n\tdreq->ctx = get_nfs_open_context(nfs_file_open_context(iocb->ki_filp));\n\tl_ctx = nfs_get_lock_context(dreq->ctx);\n\tif (IS_ERR(l_ctx)) {\n\t\tresult = PTR_ERR(l_ctx);\n\t\tgoto out_release;\n\t}\n\tdreq->l_ctx = l_ctx;\n\tif (!is_sync_kiocb(iocb))\n\t\tdreq->iocb = iocb;\n\n\tNFS_I(inode)->read_io += count;\n\tresult = nfs_direct_read_schedule_iovec(dreq, iter, pos);\n\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (!result) {\n\t\tresult = nfs_direct_wait(dreq);\n\t\tif (result > 0)\n\t\t\tiocb->ki_pos = pos + result;\n\t}\n\n\tnfs_direct_req_release(dreq);\n\treturn result;\n\nout_release:\n\tnfs_direct_req_release(dreq);\nout_unlock:\n\tmutex_unlock(&inode->i_mutex);\nout:\n\treturn result;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_direct_write_complete(struct nfs_direct_req *dreq, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void nfs_direct_write_complete(struct nfs_direct_req *dreq, struct inode *inode);\n\nssize_t nfs_file_direct_read(struct kiocb *iocb, struct iov_iter *iter,\n\t\t\t\tloff_t pos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct nfs_direct_req *dreq;\n\tstruct nfs_lock_context *l_ctx;\n\tssize_t result = -EINVAL;\n\tsize_t count = iov_iter_count(iter);\n\tnfs_add_stats(mapping->host, NFSIOS_DIRECTREADBYTES, count);\n\n\tdfprintk(FILE, \"NFS: direct read(%pD2, %zd@%Ld)\\n\",\n\t\tfile, count, (long long) pos);\n\n\tresult = 0;\n\tif (!count)\n\t\tgoto out;\n\n\tmutex_lock(&inode->i_mutex);\n\tresult = nfs_sync_mapping(mapping);\n\tif (result)\n\t\tgoto out_unlock;\n\n\ttask_io_account_read(count);\n\n\tresult = -ENOMEM;\n\tdreq = nfs_direct_req_alloc();\n\tif (dreq == NULL)\n\t\tgoto out_unlock;\n\n\tdreq->inode = inode;\n\tdreq->bytes_left = count;\n\tdreq->io_start = pos;\n\tdreq->ctx = get_nfs_open_context(nfs_file_open_context(iocb->ki_filp));\n\tl_ctx = nfs_get_lock_context(dreq->ctx);\n\tif (IS_ERR(l_ctx)) {\n\t\tresult = PTR_ERR(l_ctx);\n\t\tgoto out_release;\n\t}\n\tdreq->l_ctx = l_ctx;\n\tif (!is_sync_kiocb(iocb))\n\t\tdreq->iocb = iocb;\n\n\tNFS_I(inode)->read_io += count;\n\tresult = nfs_direct_read_schedule_iovec(dreq, iter, pos);\n\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (!result) {\n\t\tresult = nfs_direct_wait(dreq);\n\t\tif (result > 0)\n\t\t\tiocb->ki_pos = pos + result;\n\t}\n\n\tnfs_direct_req_release(dreq);\n\treturn result;\n\nout_release:\n\tnfs_direct_req_release(dreq);\nout_unlock:\n\tmutex_unlock(&inode->i_mutex);\nout:\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "iocb->ki_filp"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nssize_t\nnfs_file_read(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tssize_t result;\n\n\tif (iocb->ki_filp->f_flags & O_DIRECT)\n\t\treturn nfs_file_direct_read(iocb, to, iocb->ki_pos);\n\n\tdprintk(\"NFS: read(%pD2, %zu@%lu)\\n\",\n\t\tiocb->ki_filp,\n\t\tiov_iter_count(to), (unsigned long) iocb->ki_pos);\n\n\tresult = nfs_revalidate_mapping_protected(inode, iocb->ki_filp->f_mapping);\n\tif (!result) {\n\t\tresult = generic_file_read_iter(iocb, to);\n\t\tif (result > 0)\n\t\t\tnfs_add_stats(inode, NFSIOS_NORMALREADBYTES, result);\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "nfs_file_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "145-165",
    "snippet": "int\nnfs_file_flush(struct file *file, fl_owner_t id)\n{\n\tstruct inode\t*inode = file_inode(file);\n\n\tdprintk(\"NFS: flush(%pD2)\\n\", file);\n\n\tnfs_inc_stats(inode, NFSIOS_VFSFLUSH);\n\tif ((file->f_mode & FMODE_WRITE) == 0)\n\t\treturn 0;\n\n\t/*\n\t * If we're holding a write delegation, then just start the i/o\n\t * but don't wait for completion (or send a commit).\n\t */\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n\t\treturn filemap_fdatawrite(file->f_mapping);\n\n\t/* Flush writes to the server and return any errors */\n\treturn vfs_fsync(file, 0);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfs_fsync",
          "args": [
            "file",
            "0"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_fsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "202-205",
          "snippet": "int vfs_fsync(struct file *file, int datasync)\n{\n\treturn vfs_fsync_range(file, 0, LLONG_MAX, datasync);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint vfs_fsync(struct file *file, int datasync)\n{\n\treturn vfs_fsync_range(file, 0, LLONG_MAX, datasync);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite",
          "args": [
            "file->f_mapping"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode",
            "FMODE_WRITE"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_inc_stats",
          "args": [
            "inode",
            "NFSIOS_VFSFLUSH"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "31-35",
          "snippet": "static inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: flush(%pD2)\\n\"",
            "file"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint\nnfs_file_flush(struct file *file, fl_owner_t id)\n{\n\tstruct inode\t*inode = file_inode(file);\n\n\tdprintk(\"NFS: flush(%pD2)\\n\", file);\n\n\tnfs_inc_stats(inode, NFSIOS_VFSFLUSH);\n\tif ((file->f_mode & FMODE_WRITE) == 0)\n\t\treturn 0;\n\n\t/*\n\t * If we're holding a write delegation, then just start the i/o\n\t * but don't wait for completion (or send a commit).\n\t */\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n\t\treturn filemap_fdatawrite(file->f_mapping);\n\n\t/* Flush writes to the server and return any errors */\n\treturn vfs_fsync(file, 0);\n}"
  },
  {
    "function_name": "nfs_file_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "121-139",
    "snippet": "loff_t nfs_file_llseek(struct file *filp, loff_t offset, int whence)\n{\n\tdprintk(\"NFS: llseek file(%pD2, %lld, %d)\\n\",\n\t\t\tfilp, offset, whence);\n\n\t/*\n\t * whence == SEEK_END || SEEK_DATA || SEEK_HOLE => we must revalidate\n\t * the cached file length\n\t */\n\tif (whence != SEEK_SET && whence != SEEK_CUR) {\n\t\tstruct inode *inode = filp->f_mapping->host;\n\n\t\tint retval = nfs_revalidate_file_size(inode, filp);\n\t\tif (retval < 0)\n\t\t\treturn (loff_t)retval;\n\t}\n\n\treturn generic_file_llseek(filp, offset, whence);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_file_llseek",
          "args": [
            "filp",
            "offset",
            "whence"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_llseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "147-154",
          "snippet": "loff_t generic_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\tinode->i_sb->s_maxbytes,\n\t\t\t\t\ti_size_read(inode));\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t generic_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\tinode->i_sb->s_maxbytes,\n\t\t\t\t\ti_size_read(inode));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_revalidate_file_size",
          "args": [
            "inode",
            "filp"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_revalidate_file_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
          "lines": "101-119",
          "snippet": "static int nfs_revalidate_file_size(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tif (nfs_have_delegated_attributes(inode))\n\t\tgoto out_noreval;\n\n\tif (filp->f_flags & O_DIRECT)\n\t\tgoto force_reval;\n\tif (nfsi->cache_validity & NFS_INO_REVAL_PAGECACHE)\n\t\tgoto force_reval;\n\tif (nfs_attribute_timeout(inode))\n\t\tgoto force_reval;\nout_noreval:\n\treturn 0;\nforce_reval:\n\treturn __nfs_revalidate_inode(server, inode);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/swap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_revalidate_file_size(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tif (nfs_have_delegated_attributes(inode))\n\t\tgoto out_noreval;\n\n\tif (filp->f_flags & O_DIRECT)\n\t\tgoto force_reval;\n\tif (nfsi->cache_validity & NFS_INO_REVAL_PAGECACHE)\n\t\tgoto force_reval;\n\tif (nfs_attribute_timeout(inode))\n\t\tgoto force_reval;\nout_noreval:\n\treturn 0;\nforce_reval:\n\treturn __nfs_revalidate_inode(server, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: llseek file(%pD2, %lld, %d)\\n\"",
            "filp",
            "offset",
            "whence"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nloff_t nfs_file_llseek(struct file *filp, loff_t offset, int whence)\n{\n\tdprintk(\"NFS: llseek file(%pD2, %lld, %d)\\n\",\n\t\t\tfilp, offset, whence);\n\n\t/*\n\t * whence == SEEK_END || SEEK_DATA || SEEK_HOLE => we must revalidate\n\t * the cached file length\n\t */\n\tif (whence != SEEK_SET && whence != SEEK_CUR) {\n\t\tstruct inode *inode = filp->f_mapping->host;\n\n\t\tint retval = nfs_revalidate_file_size(inode, filp);\n\t\tif (retval < 0)\n\t\t\treturn (loff_t)retval;\n\t}\n\n\treturn generic_file_llseek(filp, offset, whence);\n}"
  },
  {
    "function_name": "nfs_revalidate_file_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "101-119",
    "snippet": "static int nfs_revalidate_file_size(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tif (nfs_have_delegated_attributes(inode))\n\t\tgoto out_noreval;\n\n\tif (filp->f_flags & O_DIRECT)\n\t\tgoto force_reval;\n\tif (nfsi->cache_validity & NFS_INO_REVAL_PAGECACHE)\n\t\tgoto force_reval;\n\tif (nfs_attribute_timeout(inode))\n\t\tgoto force_reval;\nout_noreval:\n\treturn 0;\nforce_reval:\n\treturn __nfs_revalidate_inode(server, inode);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__nfs_revalidate_inode",
          "args": [
            "server",
            "inode"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs_revalidate_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "924-991",
          "snippet": "int\n__nfs_revalidate_inode(struct nfs_server *server, struct inode *inode)\n{\n\tint\t\t status = -ESTALE;\n\tstruct nfs4_label *label = NULL;\n\tstruct nfs_fattr *fattr = NULL;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tdfprintk(PAGECACHE, \"NFS: revalidating (%s/%Lu)\\n\",\n\t\tinode->i_sb->s_id, (unsigned long long)NFS_FILEID(inode));\n\n\ttrace_nfs_revalidate_inode_enter(inode);\n\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\tif (NFS_STALE(inode))\n\t\tgoto out;\n\n\tstatus = -ENOMEM;\n\tfattr = nfs_alloc_fattr();\n\tif (fattr == NULL)\n\t\tgoto out;\n\n\tnfs_inc_stats(inode, NFSIOS_INODEREVALIDATE);\n\n\tlabel = nfs4_label_alloc(NFS_SERVER(inode), GFP_KERNEL);\n\tif (IS_ERR(label)) {\n\t\tstatus = PTR_ERR(label);\n\t\tgoto out;\n\t}\n\n\tstatus = NFS_PROTO(inode)->getattr(server, NFS_FH(inode), fattr, label);\n\tif (status != 0) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Lu) getattr failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (unsigned long long)NFS_FILEID(inode), status);\n\t\tif (status == -ESTALE) {\n\t\t\tnfs_zap_caches(inode);\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tset_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n\t\t}\n\t\tgoto err_out;\n\t}\n\n\tstatus = nfs_refresh_inode(inode, fattr);\n\tif (status) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Lu) refresh failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (unsigned long long)NFS_FILEID(inode), status);\n\t\tgoto err_out;\n\t}\n\n\tif (nfsi->cache_validity & NFS_INO_INVALID_ACL)\n\t\tnfs_zap_acl_cache(inode);\n\n\tnfs_setsecurity(inode, fattr, label);\n\n\tdfprintk(PAGECACHE, \"NFS: (%s/%Lu) revalidation complete\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(inode));\n\nerr_out:\n\tnfs4_label_free(label);\nout:\n\tnfs_free_fattr(fattr);\n\ttrace_nfs_revalidate_inode_exit(inode, status);\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);",
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nint\n__nfs_revalidate_inode(struct nfs_server *server, struct inode *inode)\n{\n\tint\t\t status = -ESTALE;\n\tstruct nfs4_label *label = NULL;\n\tstruct nfs_fattr *fattr = NULL;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tdfprintk(PAGECACHE, \"NFS: revalidating (%s/%Lu)\\n\",\n\t\tinode->i_sb->s_id, (unsigned long long)NFS_FILEID(inode));\n\n\ttrace_nfs_revalidate_inode_enter(inode);\n\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\tif (NFS_STALE(inode))\n\t\tgoto out;\n\n\tstatus = -ENOMEM;\n\tfattr = nfs_alloc_fattr();\n\tif (fattr == NULL)\n\t\tgoto out;\n\n\tnfs_inc_stats(inode, NFSIOS_INODEREVALIDATE);\n\n\tlabel = nfs4_label_alloc(NFS_SERVER(inode), GFP_KERNEL);\n\tif (IS_ERR(label)) {\n\t\tstatus = PTR_ERR(label);\n\t\tgoto out;\n\t}\n\n\tstatus = NFS_PROTO(inode)->getattr(server, NFS_FH(inode), fattr, label);\n\tif (status != 0) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Lu) getattr failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (unsigned long long)NFS_FILEID(inode), status);\n\t\tif (status == -ESTALE) {\n\t\t\tnfs_zap_caches(inode);\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tset_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n\t\t}\n\t\tgoto err_out;\n\t}\n\n\tstatus = nfs_refresh_inode(inode, fattr);\n\tif (status) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Lu) refresh failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (unsigned long long)NFS_FILEID(inode), status);\n\t\tgoto err_out;\n\t}\n\n\tif (nfsi->cache_validity & NFS_INO_INVALID_ACL)\n\t\tnfs_zap_acl_cache(inode);\n\n\tnfs_setsecurity(inode, fattr, label);\n\n\tdfprintk(PAGECACHE, \"NFS: (%s/%Lu) revalidation complete\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(inode));\n\nerr_out:\n\tnfs4_label_free(label);\nout:\n\tnfs_free_fattr(fattr);\n\ttrace_nfs_revalidate_inode_exit(inode, status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_attribute_timeout",
          "args": [
            "inode"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_attribute_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "993-998",
          "snippet": "int nfs_attribute_timeout(struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\treturn !time_in_range_open(jiffies, nfsi->read_cache_jiffies, nfsi->read_cache_jiffies + nfsi->attrtimeo);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nint nfs_attribute_timeout(struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\treturn !time_in_range_open(jiffies, nfsi->read_cache_jiffies, nfsi->read_cache_jiffies + nfsi->attrtimeo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_have_delegated_attributes",
          "args": [
            "inode"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_have_delegated_attributes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/delegation.h",
          "lines": "67-71",
          "snippet": "static inline int nfs_have_delegated_attributes(struct inode *inode)\n{\n\treturn NFS_PROTO(inode)->have_delegation(inode, FMODE_READ) &&\n\t\t!(NFS_I(inode)->cache_validity & NFS_INO_REVAL_FORCED);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int nfs_have_delegated_attributes(struct inode *inode)\n{\n\treturn NFS_PROTO(inode)->have_delegation(inode, FMODE_READ) &&\n\t\t!(NFS_I(inode)->cache_validity & NFS_INO_REVAL_FORCED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_revalidate_file_size(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tif (nfs_have_delegated_attributes(inode))\n\t\tgoto out_noreval;\n\n\tif (filp->f_flags & O_DIRECT)\n\t\tgoto force_reval;\n\tif (nfsi->cache_validity & NFS_INO_REVAL_PAGECACHE)\n\t\tgoto force_reval;\n\tif (nfs_attribute_timeout(inode))\n\t\tgoto force_reval;\nout_noreval:\n\treturn 0;\nforce_reval:\n\treturn __nfs_revalidate_inode(server, inode);\n}"
  },
  {
    "function_name": "nfs_file_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "80-87",
    "snippet": "int\nnfs_file_release(struct inode *inode, struct file *filp)\n{\n\tdprintk(\"NFS: release(%pD2)\\n\", filp);\n\n\tnfs_inc_stats(inode, NFSIOS_VFSRELEASE);\n\treturn nfs_release(inode, filp);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_release",
          "args": [
            "inode",
            "filp"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_release_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
          "lines": "476-507",
          "snippet": "static int nfs_release_page(struct page *page, gfp_t gfp)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\tdfprintk(PAGECACHE, \"NFS: release_page(%p)\\n\", page);\n\n\t/* Always try to initiate a 'commit' if relevant, but only\n\t * wait for it if __GFP_WAIT is set.  Even then, only wait 1\n\t * second and only if the 'bdi' is not congested.\n\t * Waiting indefinitely can cause deadlocks when the NFS\n\t * server is on this machine, when a new TCP connection is\n\t * needed and in other rare cases.  There is no particular\n\t * need to wait extensively here.  A short wait has the\n\t * benefit that someone else can worry about the freezer.\n\t */\n\tif (mapping) {\n\t\tstruct nfs_server *nfss = NFS_SERVER(mapping->host);\n\t\tnfs_commit_inode(mapping->host, 0);\n\t\tif ((gfp & __GFP_WAIT) &&\n\t\t    !bdi_write_congested(&nfss->backing_dev_info)) {\n\t\t\twait_on_page_bit_killable_timeout(page, PG_private,\n\t\t\t\t\t\t\t  HZ);\n\t\t\tif (PagePrivate(page))\n\t\t\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\t\t  BLK_RW_ASYNC);\n\t\t}\n\t}\n\t/* If PagePrivate() is set, then the page is not freeable */\n\tif (PagePrivate(page))\n\t\treturn 0;\n\treturn nfs_fscache_release_page(page, gfp);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/swap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_release_page(struct page *page, gfp_t gfp)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\tdfprintk(PAGECACHE, \"NFS: release_page(%p)\\n\", page);\n\n\t/* Always try to initiate a 'commit' if relevant, but only\n\t * wait for it if __GFP_WAIT is set.  Even then, only wait 1\n\t * second and only if the 'bdi' is not congested.\n\t * Waiting indefinitely can cause deadlocks when the NFS\n\t * server is on this machine, when a new TCP connection is\n\t * needed and in other rare cases.  There is no particular\n\t * need to wait extensively here.  A short wait has the\n\t * benefit that someone else can worry about the freezer.\n\t */\n\tif (mapping) {\n\t\tstruct nfs_server *nfss = NFS_SERVER(mapping->host);\n\t\tnfs_commit_inode(mapping->host, 0);\n\t\tif ((gfp & __GFP_WAIT) &&\n\t\t    !bdi_write_congested(&nfss->backing_dev_info)) {\n\t\t\twait_on_page_bit_killable_timeout(page, PG_private,\n\t\t\t\t\t\t\t  HZ);\n\t\t\tif (PagePrivate(page))\n\t\t\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\t\t  BLK_RW_ASYNC);\n\t\t}\n\t}\n\t/* If PagePrivate() is set, then the page is not freeable */\n\tif (PagePrivate(page))\n\t\treturn 0;\n\treturn nfs_fscache_release_page(page, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_inc_stats",
          "args": [
            "inode",
            "NFSIOS_VFSRELEASE"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "31-35",
          "snippet": "static inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: release(%pD2)\\n\"",
            "filp"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint\nnfs_file_release(struct inode *inode, struct file *filp)\n{\n\tdprintk(\"NFS: release(%pD2)\\n\", filp);\n\n\tnfs_inc_stats(inode, NFSIOS_VFSRELEASE);\n\treturn nfs_release(inode, filp);\n}"
  },
  {
    "function_name": "nfs_file_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "64-78",
    "snippet": "static int\nnfs_file_open(struct inode *inode, struct file *filp)\n{\n\tint res;\n\n\tdprintk(\"NFS: open file(%pD2)\\n\", filp);\n\n\tnfs_inc_stats(inode, NFSIOS_VFSOPEN);\n\tres = nfs_check_flags(filp->f_flags);\n\tif (res)\n\t\treturn res;\n\n\tres = nfs_open(inode, filp);\n\treturn res;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_open",
          "args": [
            "inode",
            "filp"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "901-912",
          "snippet": "int nfs_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\n\tctx = alloc_nfs_open_context(filp->f_path.dentry, filp->f_mode);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\tnfs_file_set_open_context(filp, ctx);\n\tput_nfs_open_context(ctx);\n\tnfs_fscache_open_file(inode, filp);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nint nfs_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\n\tctx = alloc_nfs_open_context(filp->f_path.dentry, filp->f_mode);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\tnfs_file_set_open_context(filp, ctx);\n\tput_nfs_open_context(ctx);\n\tnfs_fscache_open_file(inode, filp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_check_flags",
          "args": [
            "filp->f_flags"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
          "lines": "52-58",
          "snippet": "int nfs_check_flags(int flags)\n{\n\tif ((flags & (O_APPEND | O_DIRECT)) == (O_APPEND | O_DIRECT))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/swap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint nfs_check_flags(int flags)\n{\n\tif ((flags & (O_APPEND | O_DIRECT)) == (O_APPEND | O_DIRECT))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_inc_stats",
          "args": [
            "inode",
            "NFSIOS_VFSOPEN"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "31-35",
          "snippet": "static inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: open file(%pD2)\\n\"",
            "filp"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int\nnfs_file_open(struct inode *inode, struct file *filp)\n{\n\tint res;\n\n\tdprintk(\"NFS: open file(%pD2)\\n\", filp);\n\n\tnfs_inc_stats(inode, NFSIOS_VFSOPEN);\n\tres = nfs_check_flags(filp->f_flags);\n\tif (res)\n\t\treturn res;\n\n\tres = nfs_open(inode, filp);\n\treturn res;\n}"
  },
  {
    "function_name": "nfs_check_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
    "lines": "52-58",
    "snippet": "int nfs_check_flags(int flags)\n{\n\tif ((flags & (O_APPEND | O_DIRECT)) == (O_APPEND | O_DIRECT))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/swap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint nfs_check_flags(int flags)\n{\n\tif ((flags & (O_APPEND | O_DIRECT)) == (O_APPEND | O_DIRECT))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  }
]