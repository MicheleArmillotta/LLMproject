[
  {
    "function_name": "dbg_check_orphans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
    "lines": "913-956",
    "snippet": "static int dbg_check_orphans(struct ubifs_info *c)\n{\n\tstruct check_info ci;\n\tint err;\n\n\tif (!dbg_is_chk_orph(c))\n\t\treturn 0;\n\n\tci.last_ino = 0;\n\tci.tot_inos = 0;\n\tci.missing  = 0;\n\tci.leaf_cnt = 0;\n\tci.root = RB_ROOT;\n\tci.node = kmalloc(UBIFS_MAX_INO_NODE_SZ, GFP_NOFS);\n\tif (!ci.node) {\n\t\tubifs_err(\"out of memory\");\n\t\treturn -ENOMEM;\n\t}\n\n\terr = dbg_scan_orphans(c, &ci);\n\tif (err)\n\t\tgoto out;\n\n\terr = dbg_walk_index(c, &dbg_orphan_check, NULL, &ci);\n\tif (err) {\n\t\tubifs_err(\"cannot scan TNC, error %d\", err);\n\t\tgoto out;\n\t}\n\n\tif (ci.missing) {\n\t\tubifs_err(\"%lu missing orphan(s)\", ci.missing);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdbg_cmt(\"last inode number is %lu\", ci.last_ino);\n\tdbg_cmt(\"total number of inodes is %lu\", ci.tot_inos);\n\tdbg_cmt(\"total number of leaf nodes is %llu\", ci.leaf_cnt);\n\nout:\n\tdbg_free_check_tree(&ci.root);\n\tkfree(ci.node);\n\treturn err;\n}",
    "includes": [
      "#include \"ubifs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbg_check_orphans(struct ubifs_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ci.node"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_free_check_tree",
          "args": [
            "&ci.root"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_free_check_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
          "lines": "815-821",
          "snippet": "static void dbg_free_check_tree(struct rb_root *root)\n{\n\tstruct check_orphan *o, *n;\n\n\trbtree_postorder_for_each_entry_safe(o, n, root, rb)\n\t\tkfree(o);\n}",
          "includes": [
            "#include \"ubifs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ubifs.h\"\n\nstatic void dbg_free_check_tree(struct rb_root *root)\n{\n\tstruct check_orphan *o, *n;\n\n\trbtree_postorder_for_each_entry_safe(o, n, root, rb)\n\t\tkfree(o);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_cmt",
          "args": [
            "\"total number of leaf nodes is %llu\"",
            "ci.leaf_cnt"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_cmt",
          "args": [
            "\"total number of inodes is %lu\"",
            "ci.tot_inos"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_cmt",
          "args": [
            "\"last inode number is %lu\"",
            "ci.last_ino"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_err",
          "args": [
            "\"%lu missing orphan(s)\"",
            "ci.missing"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_err",
          "args": [
            "\"cannot scan TNC, error %d\"",
            "err"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_walk_index",
          "args": [
            "c",
            "&dbg_orphan_check",
            "NULL",
            "&ci"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_scan_orphans",
          "args": [
            "c",
            "&ci"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_scan_orphans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
          "lines": "879-911",
          "snippet": "static int dbg_scan_orphans(struct ubifs_info *c, struct check_info *ci)\n{\n\tint lnum, err = 0;\n\tvoid *buf;\n\n\t/* Check no-orphans flag and skip this if no orphans */\n\tif (c->no_orphs)\n\t\treturn 0;\n\n\tbuf = __vmalloc(c->leb_size, GFP_NOFS, PAGE_KERNEL);\n\tif (!buf) {\n\t\tubifs_err(\"cannot allocate memory to check orphans\");\n\t\treturn 0;\n\t}\n\n\tfor (lnum = c->orph_first; lnum <= c->orph_last; lnum++) {\n\t\tstruct ubifs_scan_leb *sleb;\n\n\t\tsleb = ubifs_scan(c, lnum, 0, buf, 0);\n\t\tif (IS_ERR(sleb)) {\n\t\t\terr = PTR_ERR(sleb);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = dbg_read_orphans(ci, sleb);\n\t\tubifs_scan_destroy(sleb);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tvfree(buf);\n\treturn err;\n}",
          "includes": [
            "#include \"ubifs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbg_check_orphans(struct ubifs_info *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int dbg_scan_orphans(struct ubifs_info *c, struct check_info *ci)\n{\n\tint lnum, err = 0;\n\tvoid *buf;\n\n\t/* Check no-orphans flag and skip this if no orphans */\n\tif (c->no_orphs)\n\t\treturn 0;\n\n\tbuf = __vmalloc(c->leb_size, GFP_NOFS, PAGE_KERNEL);\n\tif (!buf) {\n\t\tubifs_err(\"cannot allocate memory to check orphans\");\n\t\treturn 0;\n\t}\n\n\tfor (lnum = c->orph_first; lnum <= c->orph_last; lnum++) {\n\t\tstruct ubifs_scan_leb *sleb;\n\n\t\tsleb = ubifs_scan(c, lnum, 0, buf, 0);\n\t\tif (IS_ERR(sleb)) {\n\t\t\terr = PTR_ERR(sleb);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = dbg_read_orphans(ci, sleb);\n\t\tubifs_scan_destroy(sleb);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tvfree(buf);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubifs_err",
          "args": [
            "\"out of memory\""
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "UBIFS_MAX_INO_NODE_SZ",
            "GFP_NOFS"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_is_chk_orph",
          "args": [
            "c"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int dbg_check_orphans(struct ubifs_info *c)\n{\n\tstruct check_info ci;\n\tint err;\n\n\tif (!dbg_is_chk_orph(c))\n\t\treturn 0;\n\n\tci.last_ino = 0;\n\tci.tot_inos = 0;\n\tci.missing  = 0;\n\tci.leaf_cnt = 0;\n\tci.root = RB_ROOT;\n\tci.node = kmalloc(UBIFS_MAX_INO_NODE_SZ, GFP_NOFS);\n\tif (!ci.node) {\n\t\tubifs_err(\"out of memory\");\n\t\treturn -ENOMEM;\n\t}\n\n\terr = dbg_scan_orphans(c, &ci);\n\tif (err)\n\t\tgoto out;\n\n\terr = dbg_walk_index(c, &dbg_orphan_check, NULL, &ci);\n\tif (err) {\n\t\tubifs_err(\"cannot scan TNC, error %d\", err);\n\t\tgoto out;\n\t}\n\n\tif (ci.missing) {\n\t\tubifs_err(\"%lu missing orphan(s)\", ci.missing);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdbg_cmt(\"last inode number is %lu\", ci.last_ino);\n\tdbg_cmt(\"total number of inodes is %lu\", ci.tot_inos);\n\tdbg_cmt(\"total number of leaf nodes is %llu\", ci.leaf_cnt);\n\nout:\n\tdbg_free_check_tree(&ci.root);\n\tkfree(ci.node);\n\treturn err;\n}"
  },
  {
    "function_name": "dbg_scan_orphans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
    "lines": "879-911",
    "snippet": "static int dbg_scan_orphans(struct ubifs_info *c, struct check_info *ci)\n{\n\tint lnum, err = 0;\n\tvoid *buf;\n\n\t/* Check no-orphans flag and skip this if no orphans */\n\tif (c->no_orphs)\n\t\treturn 0;\n\n\tbuf = __vmalloc(c->leb_size, GFP_NOFS, PAGE_KERNEL);\n\tif (!buf) {\n\t\tubifs_err(\"cannot allocate memory to check orphans\");\n\t\treturn 0;\n\t}\n\n\tfor (lnum = c->orph_first; lnum <= c->orph_last; lnum++) {\n\t\tstruct ubifs_scan_leb *sleb;\n\n\t\tsleb = ubifs_scan(c, lnum, 0, buf, 0);\n\t\tif (IS_ERR(sleb)) {\n\t\t\terr = PTR_ERR(sleb);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = dbg_read_orphans(ci, sleb);\n\t\tubifs_scan_destroy(sleb);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tvfree(buf);\n\treturn err;\n}",
    "includes": [
      "#include \"ubifs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbg_check_orphans(struct ubifs_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "buf"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_scan_destroy",
          "args": [
            "sleb"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_read_orphans",
          "args": [
            "ci",
            "sleb"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_read_orphans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
          "lines": "856-877",
          "snippet": "static int dbg_read_orphans(struct check_info *ci, struct ubifs_scan_leb *sleb)\n{\n\tstruct ubifs_scan_node *snod;\n\tstruct ubifs_orph_node *orph;\n\tino_t inum;\n\tint i, n, err;\n\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tcond_resched();\n\t\tif (snod->type != UBIFS_ORPH_NODE)\n\t\t\tcontinue;\n\t\torph = snod->node;\n\t\tn = (le32_to_cpu(orph->ch.len) - UBIFS_ORPH_NODE_SZ) >> 3;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tinum = le64_to_cpu(orph->inos[i]);\n\t\t\terr = dbg_ins_check_orphan(&ci->root, inum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ubifs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_read_orphans(struct check_info *ci, struct ubifs_scan_leb *sleb)\n{\n\tstruct ubifs_scan_node *snod;\n\tstruct ubifs_orph_node *orph;\n\tino_t inum;\n\tint i, n, err;\n\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tcond_resched();\n\t\tif (snod->type != UBIFS_ORPH_NODE)\n\t\t\tcontinue;\n\t\torph = snod->node;\n\t\tn = (le32_to_cpu(orph->ch.len) - UBIFS_ORPH_NODE_SZ) >> 3;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tinum = le64_to_cpu(orph->inos[i]);\n\t\t\terr = dbg_ins_check_orphan(&ci->root, inum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sleb"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sleb"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_scan",
          "args": [
            "c",
            "lnum",
            "0",
            "buf",
            "0"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_err",
          "args": [
            "\"cannot allocate memory to check orphans\""
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vmalloc",
          "args": [
            "c->leb_size",
            "GFP_NOFS",
            "PAGE_KERNEL"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int dbg_scan_orphans(struct ubifs_info *c, struct check_info *ci)\n{\n\tint lnum, err = 0;\n\tvoid *buf;\n\n\t/* Check no-orphans flag and skip this if no orphans */\n\tif (c->no_orphs)\n\t\treturn 0;\n\n\tbuf = __vmalloc(c->leb_size, GFP_NOFS, PAGE_KERNEL);\n\tif (!buf) {\n\t\tubifs_err(\"cannot allocate memory to check orphans\");\n\t\treturn 0;\n\t}\n\n\tfor (lnum = c->orph_first; lnum <= c->orph_last; lnum++) {\n\t\tstruct ubifs_scan_leb *sleb;\n\n\t\tsleb = ubifs_scan(c, lnum, 0, buf, 0);\n\t\tif (IS_ERR(sleb)) {\n\t\t\terr = PTR_ERR(sleb);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = dbg_read_orphans(ci, sleb);\n\t\tubifs_scan_destroy(sleb);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tvfree(buf);\n\treturn err;\n}"
  },
  {
    "function_name": "dbg_read_orphans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
    "lines": "856-877",
    "snippet": "static int dbg_read_orphans(struct check_info *ci, struct ubifs_scan_leb *sleb)\n{\n\tstruct ubifs_scan_node *snod;\n\tstruct ubifs_orph_node *orph;\n\tino_t inum;\n\tint i, n, err;\n\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tcond_resched();\n\t\tif (snod->type != UBIFS_ORPH_NODE)\n\t\t\tcontinue;\n\t\torph = snod->node;\n\t\tn = (le32_to_cpu(orph->ch.len) - UBIFS_ORPH_NODE_SZ) >> 3;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tinum = le64_to_cpu(orph->inos[i]);\n\t\t\terr = dbg_ins_check_orphan(&ci->root, inum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ubifs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbg_ins_check_orphan",
          "args": [
            "&ci->root",
            "inum"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_ins_check_orphan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
          "lines": "769-795",
          "snippet": "static int dbg_ins_check_orphan(struct rb_root *root, ino_t inum)\n{\n\tstruct check_orphan *orphan, *o;\n\tstruct rb_node **p, *parent = NULL;\n\n\torphan = kzalloc(sizeof(struct check_orphan), GFP_NOFS);\n\tif (!orphan)\n\t\treturn -ENOMEM;\n\torphan->inum = inum;\n\n\tp = &root->rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\to = rb_entry(parent, struct check_orphan, rb);\n\t\tif (inum < o->inum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (inum > o->inum)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tkfree(orphan);\n\t\t\treturn 0;\n\t\t}\n\t}\n\trb_link_node(&orphan->rb, parent, p);\n\trb_insert_color(&orphan->rb, root);\n\treturn 0;\n}",
          "includes": [
            "#include \"ubifs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_ins_check_orphan(struct rb_root *root, ino_t inum)\n{\n\tstruct check_orphan *orphan, *o;\n\tstruct rb_node **p, *parent = NULL;\n\n\torphan = kzalloc(sizeof(struct check_orphan), GFP_NOFS);\n\tif (!orphan)\n\t\treturn -ENOMEM;\n\torphan->inum = inum;\n\n\tp = &root->rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\to = rb_entry(parent, struct check_orphan, rb);\n\t\tif (inum < o->inum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (inum > o->inum)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tkfree(orphan);\n\t\t\treturn 0;\n\t\t}\n\t}\n\trb_link_node(&orphan->rb, parent, p);\n\trb_insert_color(&orphan->rb, root);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "orph->inos[i]"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "orph->ch.len"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "snod",
            "&sleb->nodes",
            "list"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_read_orphans(struct check_info *ci, struct ubifs_scan_leb *sleb)\n{\n\tstruct ubifs_scan_node *snod;\n\tstruct ubifs_orph_node *orph;\n\tino_t inum;\n\tint i, n, err;\n\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tcond_resched();\n\t\tif (snod->type != UBIFS_ORPH_NODE)\n\t\t\tcontinue;\n\t\torph = snod->node;\n\t\tn = (le32_to_cpu(orph->ch.len) - UBIFS_ORPH_NODE_SZ) >> 3;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tinum = le64_to_cpu(orph->inos[i]);\n\t\t\terr = dbg_ins_check_orphan(&ci->root, inum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "dbg_orphan_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
    "lines": "823-854",
    "snippet": "static int dbg_orphan_check(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\t    void *priv)\n{\n\tstruct check_info *ci = priv;\n\tino_t inum;\n\tint err;\n\n\tinum = key_inum(c, &zbr->key);\n\tif (inum != ci->last_ino) {\n\t\t/* Lowest node type is the inode node, so it comes first */\n\t\tif (key_type(c, &zbr->key) != UBIFS_INO_KEY)\n\t\t\tubifs_err(\"found orphan node ino %lu, type %d\",\n\t\t\t\t  (unsigned long)inum, key_type(c, &zbr->key));\n\t\tci->last_ino = inum;\n\t\tci->tot_inos += 1;\n\t\terr = ubifs_tnc_read_node(c, zbr, ci->node);\n\t\tif (err) {\n\t\t\tubifs_err(\"node read failed, error %d\", err);\n\t\t\treturn err;\n\t\t}\n\t\tif (ci->node->nlink == 0)\n\t\t\t/* Must be recorded as an orphan */\n\t\t\tif (!dbg_find_check_orphan(&ci->root, inum) &&\n\t\t\t    !dbg_find_orphan(c, inum)) {\n\t\t\t\tubifs_err(\"missing orphan, ino %lu\",\n\t\t\t\t\t  (unsigned long)inum);\n\t\t\t\tci->missing += 1;\n\t\t\t}\n\t}\n\tci->leaf_cnt += 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"ubifs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbg_check_orphans(struct ubifs_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ubifs_err",
          "args": [
            "\"missing orphan, ino %lu\"",
            "(unsigned long)inum"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_find_orphan",
          "args": [
            "c",
            "inum"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_find_orphan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
          "lines": "747-767",
          "snippet": "static int dbg_find_orphan(struct ubifs_info *c, ino_t inum)\n{\n\tstruct ubifs_orphan *o;\n\tstruct rb_node *p;\n\n\tspin_lock(&c->orphan_lock);\n\tp = c->orph_tree.rb_node;\n\twhile (p) {\n\t\to = rb_entry(p, struct ubifs_orphan, rb);\n\t\tif (inum < o->inum)\n\t\t\tp = p->rb_left;\n\t\telse if (inum > o->inum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tspin_unlock(&c->orphan_lock);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tspin_unlock(&c->orphan_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"ubifs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbg_check_orphans(struct ubifs_info *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int dbg_find_orphan(struct ubifs_info *c, ino_t inum)\n{\n\tstruct ubifs_orphan *o;\n\tstruct rb_node *p;\n\n\tspin_lock(&c->orphan_lock);\n\tp = c->orph_tree.rb_node;\n\twhile (p) {\n\t\to = rb_entry(p, struct ubifs_orphan, rb);\n\t\tif (inum < o->inum)\n\t\t\tp = p->rb_left;\n\t\telse if (inum > o->inum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tspin_unlock(&c->orphan_lock);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tspin_unlock(&c->orphan_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_find_check_orphan",
          "args": [
            "&ci->root",
            "inum"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_find_check_orphan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
          "lines": "797-813",
          "snippet": "static int dbg_find_check_orphan(struct rb_root *root, ino_t inum)\n{\n\tstruct check_orphan *o;\n\tstruct rb_node *p;\n\n\tp = root->rb_node;\n\twhile (p) {\n\t\to = rb_entry(p, struct check_orphan, rb);\n\t\tif (inum < o->inum)\n\t\t\tp = p->rb_left;\n\t\telse if (inum > o->inum)\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ubifs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_find_check_orphan(struct rb_root *root, ino_t inum)\n{\n\tstruct check_orphan *o;\n\tstruct rb_node *p;\n\n\tp = root->rb_node;\n\twhile (p) {\n\t\to = rb_entry(p, struct check_orphan, rb);\n\t\tif (inum < o->inum)\n\t\t\tp = p->rb_left;\n\t\telse if (inum > o->inum)\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubifs_err",
          "args": [
            "\"node read failed, error %d\"",
            "err"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_tnc_read_node",
          "args": [
            "c",
            "zbr",
            "ci->node"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_err",
          "args": [
            "\"found orphan node ino %lu, type %d\"",
            "(unsigned long)inum",
            "key_type(c, &zbr->key)"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_type",
          "args": [
            "c",
            "&zbr->key"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_key_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2778-2781",
          "snippet": "static inline void btrfs_set_key_type(struct btrfs_key *key, u8 val)\n{\n\tkey->type = val;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_key_type(struct btrfs_key *key, u8 val)\n{\n\tkey->type = val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_inum",
          "args": [
            "c",
            "&zbr->key"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int dbg_orphan_check(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\t    void *priv)\n{\n\tstruct check_info *ci = priv;\n\tino_t inum;\n\tint err;\n\n\tinum = key_inum(c, &zbr->key);\n\tif (inum != ci->last_ino) {\n\t\t/* Lowest node type is the inode node, so it comes first */\n\t\tif (key_type(c, &zbr->key) != UBIFS_INO_KEY)\n\t\t\tubifs_err(\"found orphan node ino %lu, type %d\",\n\t\t\t\t  (unsigned long)inum, key_type(c, &zbr->key));\n\t\tci->last_ino = inum;\n\t\tci->tot_inos += 1;\n\t\terr = ubifs_tnc_read_node(c, zbr, ci->node);\n\t\tif (err) {\n\t\t\tubifs_err(\"node read failed, error %d\", err);\n\t\t\treturn err;\n\t\t}\n\t\tif (ci->node->nlink == 0)\n\t\t\t/* Must be recorded as an orphan */\n\t\t\tif (!dbg_find_check_orphan(&ci->root, inum) &&\n\t\t\t    !dbg_find_orphan(c, inum)) {\n\t\t\t\tubifs_err(\"missing orphan, ino %lu\",\n\t\t\t\t\t  (unsigned long)inum);\n\t\t\t\tci->missing += 1;\n\t\t\t}\n\t}\n\tci->leaf_cnt += 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "dbg_free_check_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
    "lines": "815-821",
    "snippet": "static void dbg_free_check_tree(struct rb_root *root)\n{\n\tstruct check_orphan *o, *n;\n\n\trbtree_postorder_for_each_entry_safe(o, n, root, rb)\n\t\tkfree(o);\n}",
    "includes": [
      "#include \"ubifs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "o"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rbtree_postorder_for_each_entry_safe",
          "args": [
            "o",
            "n",
            "root",
            "rb"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ubifs.h\"\n\nstatic void dbg_free_check_tree(struct rb_root *root)\n{\n\tstruct check_orphan *o, *n;\n\n\trbtree_postorder_for_each_entry_safe(o, n, root, rb)\n\t\tkfree(o);\n}"
  },
  {
    "function_name": "dbg_find_check_orphan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
    "lines": "797-813",
    "snippet": "static int dbg_find_check_orphan(struct rb_root *root, ino_t inum)\n{\n\tstruct check_orphan *o;\n\tstruct rb_node *p;\n\n\tp = root->rb_node;\n\twhile (p) {\n\t\to = rb_entry(p, struct check_orphan, rb);\n\t\tif (inum < o->inum)\n\t\t\tp = p->rb_left;\n\t\telse if (inum > o->inum)\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ubifs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structcheck_orphan",
            "rb"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_find_check_orphan(struct rb_root *root, ino_t inum)\n{\n\tstruct check_orphan *o;\n\tstruct rb_node *p;\n\n\tp = root->rb_node;\n\twhile (p) {\n\t\to = rb_entry(p, struct check_orphan, rb);\n\t\tif (inum < o->inum)\n\t\t\tp = p->rb_left;\n\t\telse if (inum > o->inum)\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "dbg_ins_check_orphan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
    "lines": "769-795",
    "snippet": "static int dbg_ins_check_orphan(struct rb_root *root, ino_t inum)\n{\n\tstruct check_orphan *orphan, *o;\n\tstruct rb_node **p, *parent = NULL;\n\n\torphan = kzalloc(sizeof(struct check_orphan), GFP_NOFS);\n\tif (!orphan)\n\t\treturn -ENOMEM;\n\torphan->inum = inum;\n\n\tp = &root->rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\to = rb_entry(parent, struct check_orphan, rb);\n\t\tif (inum < o->inum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (inum > o->inum)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tkfree(orphan);\n\t\t\treturn 0;\n\t\t}\n\t}\n\trb_link_node(&orphan->rb, parent, p);\n\trb_insert_color(&orphan->rb, root);\n\treturn 0;\n}",
    "includes": [
      "#include \"ubifs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&orphan->rb",
            "root"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&orphan->rb",
            "parent",
            "p"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "orphan"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structcheck_orphan",
            "rb"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct check_orphan)",
            "GFP_NOFS"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_ins_check_orphan(struct rb_root *root, ino_t inum)\n{\n\tstruct check_orphan *orphan, *o;\n\tstruct rb_node **p, *parent = NULL;\n\n\torphan = kzalloc(sizeof(struct check_orphan), GFP_NOFS);\n\tif (!orphan)\n\t\treturn -ENOMEM;\n\torphan->inum = inum;\n\n\tp = &root->rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\to = rb_entry(parent, struct check_orphan, rb);\n\t\tif (inum < o->inum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (inum > o->inum)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tkfree(orphan);\n\t\t\treturn 0;\n\t\t}\n\t}\n\trb_link_node(&orphan->rb, parent, p);\n\trb_insert_color(&orphan->rb, root);\n\treturn 0;\n}"
  },
  {
    "function_name": "dbg_find_orphan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
    "lines": "747-767",
    "snippet": "static int dbg_find_orphan(struct ubifs_info *c, ino_t inum)\n{\n\tstruct ubifs_orphan *o;\n\tstruct rb_node *p;\n\n\tspin_lock(&c->orphan_lock);\n\tp = c->orph_tree.rb_node;\n\twhile (p) {\n\t\to = rb_entry(p, struct ubifs_orphan, rb);\n\t\tif (inum < o->inum)\n\t\t\tp = p->rb_left;\n\t\telse if (inum > o->inum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tspin_unlock(&c->orphan_lock);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tspin_unlock(&c->orphan_lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"ubifs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbg_check_orphans(struct ubifs_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&c->orphan_lock"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structubifs_orphan",
            "rb"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&c->orphan_lock"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int dbg_find_orphan(struct ubifs_info *c, ino_t inum)\n{\n\tstruct ubifs_orphan *o;\n\tstruct rb_node *p;\n\n\tspin_lock(&c->orphan_lock);\n\tp = c->orph_tree.rb_node;\n\twhile (p) {\n\t\to = rb_entry(p, struct ubifs_orphan, rb);\n\t\tif (inum < o->inum)\n\t\t\tp = p->rb_left;\n\t\telse if (inum > o->inum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tspin_unlock(&c->orphan_lock);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tspin_unlock(&c->orphan_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "ubifs_mount_orphans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
    "lines": "709-727",
    "snippet": "int ubifs_mount_orphans(struct ubifs_info *c, int unclean, int read_only)\n{\n\tint err = 0;\n\n\tc->max_orphans = tot_avail_orphs(c);\n\n\tif (!read_only) {\n\t\tc->orph_buf = vmalloc(c->leb_size);\n\t\tif (!c->orph_buf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (unclean)\n\t\terr = kill_orphans(c);\n\telse if (!read_only)\n\t\terr = ubifs_clear_orphans(c);\n\n\treturn err;\n}",
    "includes": [
      "#include \"ubifs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbg_check_orphans(struct ubifs_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ubifs_clear_orphans",
          "args": [
            "c"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "ubifs_clear_orphans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
          "lines": "489-501",
          "snippet": "int ubifs_clear_orphans(struct ubifs_info *c)\n{\n\tint lnum, err;\n\n\tfor (lnum = c->orph_first; lnum <= c->orph_last; lnum++) {\n\t\terr = ubifs_leb_unmap(c, lnum);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tc->ohead_lnum = c->orph_first;\n\tc->ohead_offs = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"ubifs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbg_check_orphans(struct ubifs_info *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nint ubifs_clear_orphans(struct ubifs_info *c)\n{\n\tint lnum, err;\n\n\tfor (lnum = c->orph_first; lnum <= c->orph_last; lnum++) {\n\t\terr = ubifs_leb_unmap(c, lnum);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tc->ohead_lnum = c->orph_first;\n\tc->ohead_offs = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_orphans",
          "args": [
            "c"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "kill_orphans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
          "lines": "647-697",
          "snippet": "static int kill_orphans(struct ubifs_info *c)\n{\n\tunsigned long long last_cmt_no = 0;\n\tint lnum, err = 0, outofdate = 0, last_flagged = 0;\n\n\tc->ohead_lnum = c->orph_first;\n\tc->ohead_offs = 0;\n\t/* Check no-orphans flag and skip this if no orphans */\n\tif (c->no_orphs) {\n\t\tdbg_rcvry(\"no orphans\");\n\t\treturn 0;\n\t}\n\t/*\n\t * Orph nodes always start at c->orph_first and are written to each\n\t * successive LEB in turn. Generally unused LEBs will have been unmapped\n\t * but may contain out of date orphan nodes if the unmap didn't go\n\t * through. In addition, the last orphan node written for each commit is\n\t * marked (top bit of orph->cmt_no is set to 1). It is possible that\n\t * there are orphan nodes from the next commit (i.e. the commit did not\n\t * complete successfully). In that case, no orphans will have been lost\n\t * due to the way that orphans are written, and any orphans added will\n\t * be valid orphans anyway and so can be deleted.\n\t */\n\tfor (lnum = c->orph_first; lnum <= c->orph_last; lnum++) {\n\t\tstruct ubifs_scan_leb *sleb;\n\n\t\tdbg_rcvry(\"LEB %d\", lnum);\n\t\tsleb = ubifs_scan(c, lnum, 0, c->sbuf, 1);\n\t\tif (IS_ERR(sleb)) {\n\t\t\tif (PTR_ERR(sleb) == -EUCLEAN)\n\t\t\t\tsleb = ubifs_recover_leb(c, lnum, 0,\n\t\t\t\t\t\t\t c->sbuf, -1);\n\t\t\tif (IS_ERR(sleb)) {\n\t\t\t\terr = PTR_ERR(sleb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\terr = do_kill_orphans(c, sleb, &last_cmt_no, &outofdate,\n\t\t\t\t      &last_flagged);\n\t\tif (err || outofdate) {\n\t\t\tubifs_scan_destroy(sleb);\n\t\t\tbreak;\n\t\t}\n\t\tif (sleb->endpt) {\n\t\t\tc->ohead_lnum = lnum;\n\t\t\tc->ohead_offs = sleb->endpt;\n\t\t}\n\t\tubifs_scan_destroy(sleb);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"ubifs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbg_check_orphans(struct ubifs_info *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int kill_orphans(struct ubifs_info *c)\n{\n\tunsigned long long last_cmt_no = 0;\n\tint lnum, err = 0, outofdate = 0, last_flagged = 0;\n\n\tc->ohead_lnum = c->orph_first;\n\tc->ohead_offs = 0;\n\t/* Check no-orphans flag and skip this if no orphans */\n\tif (c->no_orphs) {\n\t\tdbg_rcvry(\"no orphans\");\n\t\treturn 0;\n\t}\n\t/*\n\t * Orph nodes always start at c->orph_first and are written to each\n\t * successive LEB in turn. Generally unused LEBs will have been unmapped\n\t * but may contain out of date orphan nodes if the unmap didn't go\n\t * through. In addition, the last orphan node written for each commit is\n\t * marked (top bit of orph->cmt_no is set to 1). It is possible that\n\t * there are orphan nodes from the next commit (i.e. the commit did not\n\t * complete successfully). In that case, no orphans will have been lost\n\t * due to the way that orphans are written, and any orphans added will\n\t * be valid orphans anyway and so can be deleted.\n\t */\n\tfor (lnum = c->orph_first; lnum <= c->orph_last; lnum++) {\n\t\tstruct ubifs_scan_leb *sleb;\n\n\t\tdbg_rcvry(\"LEB %d\", lnum);\n\t\tsleb = ubifs_scan(c, lnum, 0, c->sbuf, 1);\n\t\tif (IS_ERR(sleb)) {\n\t\t\tif (PTR_ERR(sleb) == -EUCLEAN)\n\t\t\t\tsleb = ubifs_recover_leb(c, lnum, 0,\n\t\t\t\t\t\t\t c->sbuf, -1);\n\t\t\tif (IS_ERR(sleb)) {\n\t\t\t\terr = PTR_ERR(sleb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\terr = do_kill_orphans(c, sleb, &last_cmt_no, &outofdate,\n\t\t\t\t      &last_flagged);\n\t\tif (err || outofdate) {\n\t\t\tubifs_scan_destroy(sleb);\n\t\t\tbreak;\n\t\t}\n\t\tif (sleb->endpt) {\n\t\t\tc->ohead_lnum = lnum;\n\t\t\tc->ohead_offs = sleb->endpt;\n\t\t}\n\t\tubifs_scan_destroy(sleb);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "c->leb_size"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tot_avail_orphs",
          "args": [
            "c"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "tot_avail_orphs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
          "lines": "222-230",
          "snippet": "static int tot_avail_orphs(struct ubifs_info *c)\n{\n\tint avail_lebs, avail;\n\n\tavail_lebs = c->orph_lebs;\n\tavail = avail_lebs *\n\t       ((c->leb_size - UBIFS_ORPH_NODE_SZ) / sizeof(__le64));\n\treturn avail / 2;\n}",
          "includes": [
            "#include \"ubifs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbg_check_orphans(struct ubifs_info *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int tot_avail_orphs(struct ubifs_info *c)\n{\n\tint avail_lebs, avail;\n\n\tavail_lebs = c->orph_lebs;\n\tavail = avail_lebs *\n\t       ((c->leb_size - UBIFS_ORPH_NODE_SZ) / sizeof(__le64));\n\treturn avail / 2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nint ubifs_mount_orphans(struct ubifs_info *c, int unclean, int read_only)\n{\n\tint err = 0;\n\n\tc->max_orphans = tot_avail_orphs(c);\n\n\tif (!read_only) {\n\t\tc->orph_buf = vmalloc(c->leb_size);\n\t\tif (!c->orph_buf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (unclean)\n\t\terr = kill_orphans(c);\n\telse if (!read_only)\n\t\terr = ubifs_clear_orphans(c);\n\n\treturn err;\n}"
  },
  {
    "function_name": "kill_orphans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
    "lines": "647-697",
    "snippet": "static int kill_orphans(struct ubifs_info *c)\n{\n\tunsigned long long last_cmt_no = 0;\n\tint lnum, err = 0, outofdate = 0, last_flagged = 0;\n\n\tc->ohead_lnum = c->orph_first;\n\tc->ohead_offs = 0;\n\t/* Check no-orphans flag and skip this if no orphans */\n\tif (c->no_orphs) {\n\t\tdbg_rcvry(\"no orphans\");\n\t\treturn 0;\n\t}\n\t/*\n\t * Orph nodes always start at c->orph_first and are written to each\n\t * successive LEB in turn. Generally unused LEBs will have been unmapped\n\t * but may contain out of date orphan nodes if the unmap didn't go\n\t * through. In addition, the last orphan node written for each commit is\n\t * marked (top bit of orph->cmt_no is set to 1). It is possible that\n\t * there are orphan nodes from the next commit (i.e. the commit did not\n\t * complete successfully). In that case, no orphans will have been lost\n\t * due to the way that orphans are written, and any orphans added will\n\t * be valid orphans anyway and so can be deleted.\n\t */\n\tfor (lnum = c->orph_first; lnum <= c->orph_last; lnum++) {\n\t\tstruct ubifs_scan_leb *sleb;\n\n\t\tdbg_rcvry(\"LEB %d\", lnum);\n\t\tsleb = ubifs_scan(c, lnum, 0, c->sbuf, 1);\n\t\tif (IS_ERR(sleb)) {\n\t\t\tif (PTR_ERR(sleb) == -EUCLEAN)\n\t\t\t\tsleb = ubifs_recover_leb(c, lnum, 0,\n\t\t\t\t\t\t\t c->sbuf, -1);\n\t\t\tif (IS_ERR(sleb)) {\n\t\t\t\terr = PTR_ERR(sleb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\terr = do_kill_orphans(c, sleb, &last_cmt_no, &outofdate,\n\t\t\t\t      &last_flagged);\n\t\tif (err || outofdate) {\n\t\t\tubifs_scan_destroy(sleb);\n\t\t\tbreak;\n\t\t}\n\t\tif (sleb->endpt) {\n\t\t\tc->ohead_lnum = lnum;\n\t\t\tc->ohead_offs = sleb->endpt;\n\t\t}\n\t\tubifs_scan_destroy(sleb);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"ubifs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbg_check_orphans(struct ubifs_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ubifs_scan_destroy",
          "args": [
            "sleb"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_scan_destroy",
          "args": [
            "sleb"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_kill_orphans",
          "args": [
            "c",
            "sleb",
            "&last_cmt_no",
            "&outofdate",
            "&last_flagged"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "do_kill_orphans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
          "lines": "560-635",
          "snippet": "static int do_kill_orphans(struct ubifs_info *c, struct ubifs_scan_leb *sleb,\n\t\t\t   unsigned long long *last_cmt_no, int *outofdate,\n\t\t\t   int *last_flagged)\n{\n\tstruct ubifs_scan_node *snod;\n\tstruct ubifs_orph_node *orph;\n\tunsigned long long cmt_no;\n\tino_t inum;\n\tint i, n, err, first = 1;\n\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tif (snod->type != UBIFS_ORPH_NODE) {\n\t\t\tubifs_err(\"invalid node type %d in orphan area at %d:%d\",\n\t\t\t\t  snod->type, sleb->lnum, snod->offs);\n\t\t\tubifs_dump_node(c, snod->node);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\torph = snod->node;\n\n\t\t/* Check commit number */\n\t\tcmt_no = le64_to_cpu(orph->cmt_no) & LLONG_MAX;\n\t\t/*\n\t\t * The commit number on the master node may be less, because\n\t\t * of a failed commit. If there are several failed commits in a\n\t\t * row, the commit number written on orphan nodes will continue\n\t\t * to increase (because the commit number is adjusted here) even\n\t\t * though the commit number on the master node stays the same\n\t\t * because the master node has not been re-written.\n\t\t */\n\t\tif (cmt_no > c->cmt_no)\n\t\t\tc->cmt_no = cmt_no;\n\t\tif (cmt_no < *last_cmt_no && *last_flagged) {\n\t\t\t/*\n\t\t\t * The last orphan node had a higher commit number and\n\t\t\t * was flagged as the last written for that commit\n\t\t\t * number. That makes this orphan node, out of date.\n\t\t\t */\n\t\t\tif (!first) {\n\t\t\t\tubifs_err(\"out of order commit number %llu in orphan node at %d:%d\",\n\t\t\t\t\t  cmt_no, sleb->lnum, snod->offs);\n\t\t\t\tubifs_dump_node(c, snod->node);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tdbg_rcvry(\"out of date LEB %d\", sleb->lnum);\n\t\t\t*outofdate = 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (first)\n\t\t\tfirst = 0;\n\n\t\tn = (le32_to_cpu(orph->ch.len) - UBIFS_ORPH_NODE_SZ) >> 3;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tinum = le64_to_cpu(orph->inos[i]);\n\t\t\tdbg_rcvry(\"deleting orphaned inode %lu\",\n\t\t\t\t  (unsigned long)inum);\n\t\t\terr = ubifs_tnc_remove_ino(c, inum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\terr = insert_dead_orphan(c, inum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t*last_cmt_no = cmt_no;\n\t\tif (le64_to_cpu(orph->cmt_no) & (1ULL << 63)) {\n\t\t\tdbg_rcvry(\"last orph node for commit %llu at %d:%d\",\n\t\t\t\t  cmt_no, sleb->lnum, snod->offs);\n\t\t\t*last_flagged = 1;\n\t\t} else\n\t\t\t*last_flagged = 0;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ubifs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbg_check_orphans(struct ubifs_info *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int do_kill_orphans(struct ubifs_info *c, struct ubifs_scan_leb *sleb,\n\t\t\t   unsigned long long *last_cmt_no, int *outofdate,\n\t\t\t   int *last_flagged)\n{\n\tstruct ubifs_scan_node *snod;\n\tstruct ubifs_orph_node *orph;\n\tunsigned long long cmt_no;\n\tino_t inum;\n\tint i, n, err, first = 1;\n\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tif (snod->type != UBIFS_ORPH_NODE) {\n\t\t\tubifs_err(\"invalid node type %d in orphan area at %d:%d\",\n\t\t\t\t  snod->type, sleb->lnum, snod->offs);\n\t\t\tubifs_dump_node(c, snod->node);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\torph = snod->node;\n\n\t\t/* Check commit number */\n\t\tcmt_no = le64_to_cpu(orph->cmt_no) & LLONG_MAX;\n\t\t/*\n\t\t * The commit number on the master node may be less, because\n\t\t * of a failed commit. If there are several failed commits in a\n\t\t * row, the commit number written on orphan nodes will continue\n\t\t * to increase (because the commit number is adjusted here) even\n\t\t * though the commit number on the master node stays the same\n\t\t * because the master node has not been re-written.\n\t\t */\n\t\tif (cmt_no > c->cmt_no)\n\t\t\tc->cmt_no = cmt_no;\n\t\tif (cmt_no < *last_cmt_no && *last_flagged) {\n\t\t\t/*\n\t\t\t * The last orphan node had a higher commit number and\n\t\t\t * was flagged as the last written for that commit\n\t\t\t * number. That makes this orphan node, out of date.\n\t\t\t */\n\t\t\tif (!first) {\n\t\t\t\tubifs_err(\"out of order commit number %llu in orphan node at %d:%d\",\n\t\t\t\t\t  cmt_no, sleb->lnum, snod->offs);\n\t\t\t\tubifs_dump_node(c, snod->node);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tdbg_rcvry(\"out of date LEB %d\", sleb->lnum);\n\t\t\t*outofdate = 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (first)\n\t\t\tfirst = 0;\n\n\t\tn = (le32_to_cpu(orph->ch.len) - UBIFS_ORPH_NODE_SZ) >> 3;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tinum = le64_to_cpu(orph->inos[i]);\n\t\t\tdbg_rcvry(\"deleting orphaned inode %lu\",\n\t\t\t\t  (unsigned long)inum);\n\t\t\terr = ubifs_tnc_remove_ino(c, inum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\terr = insert_dead_orphan(c, inum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t*last_cmt_no = cmt_no;\n\t\tif (le64_to_cpu(orph->cmt_no) & (1ULL << 63)) {\n\t\t\tdbg_rcvry(\"last orph node for commit %llu at %d:%d\",\n\t\t\t\t  cmt_no, sleb->lnum, snod->offs);\n\t\t\t*last_flagged = 1;\n\t\t} else\n\t\t\t*last_flagged = 0;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sleb"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sleb"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_recover_leb",
          "args": [
            "c",
            "lnum",
            "0",
            "c->sbuf",
            "-1"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sleb"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sleb"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_scan",
          "args": [
            "c",
            "lnum",
            "0",
            "c->sbuf",
            "1"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_rcvry",
          "args": [
            "\"LEB %d\"",
            "lnum"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_rcvry",
          "args": [
            "\"no orphans\""
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int kill_orphans(struct ubifs_info *c)\n{\n\tunsigned long long last_cmt_no = 0;\n\tint lnum, err = 0, outofdate = 0, last_flagged = 0;\n\n\tc->ohead_lnum = c->orph_first;\n\tc->ohead_offs = 0;\n\t/* Check no-orphans flag and skip this if no orphans */\n\tif (c->no_orphs) {\n\t\tdbg_rcvry(\"no orphans\");\n\t\treturn 0;\n\t}\n\t/*\n\t * Orph nodes always start at c->orph_first and are written to each\n\t * successive LEB in turn. Generally unused LEBs will have been unmapped\n\t * but may contain out of date orphan nodes if the unmap didn't go\n\t * through. In addition, the last orphan node written for each commit is\n\t * marked (top bit of orph->cmt_no is set to 1). It is possible that\n\t * there are orphan nodes from the next commit (i.e. the commit did not\n\t * complete successfully). In that case, no orphans will have been lost\n\t * due to the way that orphans are written, and any orphans added will\n\t * be valid orphans anyway and so can be deleted.\n\t */\n\tfor (lnum = c->orph_first; lnum <= c->orph_last; lnum++) {\n\t\tstruct ubifs_scan_leb *sleb;\n\n\t\tdbg_rcvry(\"LEB %d\", lnum);\n\t\tsleb = ubifs_scan(c, lnum, 0, c->sbuf, 1);\n\t\tif (IS_ERR(sleb)) {\n\t\t\tif (PTR_ERR(sleb) == -EUCLEAN)\n\t\t\t\tsleb = ubifs_recover_leb(c, lnum, 0,\n\t\t\t\t\t\t\t c->sbuf, -1);\n\t\t\tif (IS_ERR(sleb)) {\n\t\t\t\terr = PTR_ERR(sleb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\terr = do_kill_orphans(c, sleb, &last_cmt_no, &outofdate,\n\t\t\t\t      &last_flagged);\n\t\tif (err || outofdate) {\n\t\t\tubifs_scan_destroy(sleb);\n\t\t\tbreak;\n\t\t}\n\t\tif (sleb->endpt) {\n\t\t\tc->ohead_lnum = lnum;\n\t\t\tc->ohead_offs = sleb->endpt;\n\t\t}\n\t\tubifs_scan_destroy(sleb);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "do_kill_orphans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
    "lines": "560-635",
    "snippet": "static int do_kill_orphans(struct ubifs_info *c, struct ubifs_scan_leb *sleb,\n\t\t\t   unsigned long long *last_cmt_no, int *outofdate,\n\t\t\t   int *last_flagged)\n{\n\tstruct ubifs_scan_node *snod;\n\tstruct ubifs_orph_node *orph;\n\tunsigned long long cmt_no;\n\tino_t inum;\n\tint i, n, err, first = 1;\n\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tif (snod->type != UBIFS_ORPH_NODE) {\n\t\t\tubifs_err(\"invalid node type %d in orphan area at %d:%d\",\n\t\t\t\t  snod->type, sleb->lnum, snod->offs);\n\t\t\tubifs_dump_node(c, snod->node);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\torph = snod->node;\n\n\t\t/* Check commit number */\n\t\tcmt_no = le64_to_cpu(orph->cmt_no) & LLONG_MAX;\n\t\t/*\n\t\t * The commit number on the master node may be less, because\n\t\t * of a failed commit. If there are several failed commits in a\n\t\t * row, the commit number written on orphan nodes will continue\n\t\t * to increase (because the commit number is adjusted here) even\n\t\t * though the commit number on the master node stays the same\n\t\t * because the master node has not been re-written.\n\t\t */\n\t\tif (cmt_no > c->cmt_no)\n\t\t\tc->cmt_no = cmt_no;\n\t\tif (cmt_no < *last_cmt_no && *last_flagged) {\n\t\t\t/*\n\t\t\t * The last orphan node had a higher commit number and\n\t\t\t * was flagged as the last written for that commit\n\t\t\t * number. That makes this orphan node, out of date.\n\t\t\t */\n\t\t\tif (!first) {\n\t\t\t\tubifs_err(\"out of order commit number %llu in orphan node at %d:%d\",\n\t\t\t\t\t  cmt_no, sleb->lnum, snod->offs);\n\t\t\t\tubifs_dump_node(c, snod->node);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tdbg_rcvry(\"out of date LEB %d\", sleb->lnum);\n\t\t\t*outofdate = 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (first)\n\t\t\tfirst = 0;\n\n\t\tn = (le32_to_cpu(orph->ch.len) - UBIFS_ORPH_NODE_SZ) >> 3;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tinum = le64_to_cpu(orph->inos[i]);\n\t\t\tdbg_rcvry(\"deleting orphaned inode %lu\",\n\t\t\t\t  (unsigned long)inum);\n\t\t\terr = ubifs_tnc_remove_ino(c, inum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\terr = insert_dead_orphan(c, inum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t*last_cmt_no = cmt_no;\n\t\tif (le64_to_cpu(orph->cmt_no) & (1ULL << 63)) {\n\t\t\tdbg_rcvry(\"last orph node for commit %llu at %d:%d\",\n\t\t\t\t  cmt_no, sleb->lnum, snod->offs);\n\t\t\t*last_flagged = 1;\n\t\t} else\n\t\t\t*last_flagged = 0;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ubifs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbg_check_orphans(struct ubifs_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbg_rcvry",
          "args": [
            "\"last orph node for commit %llu at %d:%d\"",
            "cmt_no",
            "sleb->lnum",
            "snod->offs"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "orph->cmt_no"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_dead_orphan",
          "args": [
            "c",
            "inum"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "insert_dead_orphan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
          "lines": "512-546",
          "snippet": "static int insert_dead_orphan(struct ubifs_info *c, ino_t inum)\n{\n\tstruct ubifs_orphan *orphan, *o;\n\tstruct rb_node **p, *parent = NULL;\n\n\torphan = kzalloc(sizeof(struct ubifs_orphan), GFP_KERNEL);\n\tif (!orphan)\n\t\treturn -ENOMEM;\n\torphan->inum = inum;\n\n\tp = &c->orph_tree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\to = rb_entry(parent, struct ubifs_orphan, rb);\n\t\tif (inum < o->inum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (inum > o->inum)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\t/* Already added - no problem */\n\t\t\tkfree(orphan);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tc->tot_orphans += 1;\n\trb_link_node(&orphan->rb, parent, p);\n\trb_insert_color(&orphan->rb, &c->orph_tree);\n\tlist_add_tail(&orphan->list, &c->orph_list);\n\torphan->del = 1;\n\torphan->dnext = c->orph_dnext;\n\tc->orph_dnext = orphan;\n\tdbg_mnt(\"ino %lu, new %d, tot %d\", (unsigned long)inum,\n\t\tc->new_orphans, c->tot_orphans);\n\treturn 0;\n}",
          "includes": [
            "#include \"ubifs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbg_check_orphans(struct ubifs_info *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int insert_dead_orphan(struct ubifs_info *c, ino_t inum)\n{\n\tstruct ubifs_orphan *orphan, *o;\n\tstruct rb_node **p, *parent = NULL;\n\n\torphan = kzalloc(sizeof(struct ubifs_orphan), GFP_KERNEL);\n\tif (!orphan)\n\t\treturn -ENOMEM;\n\torphan->inum = inum;\n\n\tp = &c->orph_tree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\to = rb_entry(parent, struct ubifs_orphan, rb);\n\t\tif (inum < o->inum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (inum > o->inum)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\t/* Already added - no problem */\n\t\t\tkfree(orphan);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tc->tot_orphans += 1;\n\trb_link_node(&orphan->rb, parent, p);\n\trb_insert_color(&orphan->rb, &c->orph_tree);\n\tlist_add_tail(&orphan->list, &c->orph_list);\n\torphan->del = 1;\n\torphan->dnext = c->orph_dnext;\n\tc->orph_dnext = orphan;\n\tdbg_mnt(\"ino %lu, new %d, tot %d\", (unsigned long)inum,\n\t\tc->new_orphans, c->tot_orphans);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubifs_tnc_remove_ino",
          "args": [
            "c",
            "inum"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_rcvry",
          "args": [
            "\"deleting orphaned inode %lu\"",
            "(unsigned long)inum"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "orph->ch.len"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_rcvry",
          "args": [
            "\"out of date LEB %d\"",
            "sleb->lnum"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_dump_node",
          "args": [
            "c",
            "snod->node"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_err",
          "args": [
            "\"out of order commit number %llu in orphan node at %d:%d\"",
            "cmt_no",
            "sleb->lnum",
            "snod->offs"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_dump_node",
          "args": [
            "c",
            "snod->node"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_err",
          "args": [
            "\"invalid node type %d in orphan area at %d:%d\"",
            "snod->type",
            "sleb->lnum",
            "snod->offs"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "snod",
            "&sleb->nodes",
            "list"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int do_kill_orphans(struct ubifs_info *c, struct ubifs_scan_leb *sleb,\n\t\t\t   unsigned long long *last_cmt_no, int *outofdate,\n\t\t\t   int *last_flagged)\n{\n\tstruct ubifs_scan_node *snod;\n\tstruct ubifs_orph_node *orph;\n\tunsigned long long cmt_no;\n\tino_t inum;\n\tint i, n, err, first = 1;\n\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tif (snod->type != UBIFS_ORPH_NODE) {\n\t\t\tubifs_err(\"invalid node type %d in orphan area at %d:%d\",\n\t\t\t\t  snod->type, sleb->lnum, snod->offs);\n\t\t\tubifs_dump_node(c, snod->node);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\torph = snod->node;\n\n\t\t/* Check commit number */\n\t\tcmt_no = le64_to_cpu(orph->cmt_no) & LLONG_MAX;\n\t\t/*\n\t\t * The commit number on the master node may be less, because\n\t\t * of a failed commit. If there are several failed commits in a\n\t\t * row, the commit number written on orphan nodes will continue\n\t\t * to increase (because the commit number is adjusted here) even\n\t\t * though the commit number on the master node stays the same\n\t\t * because the master node has not been re-written.\n\t\t */\n\t\tif (cmt_no > c->cmt_no)\n\t\t\tc->cmt_no = cmt_no;\n\t\tif (cmt_no < *last_cmt_no && *last_flagged) {\n\t\t\t/*\n\t\t\t * The last orphan node had a higher commit number and\n\t\t\t * was flagged as the last written for that commit\n\t\t\t * number. That makes this orphan node, out of date.\n\t\t\t */\n\t\t\tif (!first) {\n\t\t\t\tubifs_err(\"out of order commit number %llu in orphan node at %d:%d\",\n\t\t\t\t\t  cmt_no, sleb->lnum, snod->offs);\n\t\t\t\tubifs_dump_node(c, snod->node);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tdbg_rcvry(\"out of date LEB %d\", sleb->lnum);\n\t\t\t*outofdate = 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (first)\n\t\t\tfirst = 0;\n\n\t\tn = (le32_to_cpu(orph->ch.len) - UBIFS_ORPH_NODE_SZ) >> 3;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tinum = le64_to_cpu(orph->inos[i]);\n\t\t\tdbg_rcvry(\"deleting orphaned inode %lu\",\n\t\t\t\t  (unsigned long)inum);\n\t\t\terr = ubifs_tnc_remove_ino(c, inum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\terr = insert_dead_orphan(c, inum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t*last_cmt_no = cmt_no;\n\t\tif (le64_to_cpu(orph->cmt_no) & (1ULL << 63)) {\n\t\t\tdbg_rcvry(\"last orph node for commit %llu at %d:%d\",\n\t\t\t\t  cmt_no, sleb->lnum, snod->offs);\n\t\t\t*last_flagged = 1;\n\t\t} else\n\t\t\t*last_flagged = 0;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "insert_dead_orphan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
    "lines": "512-546",
    "snippet": "static int insert_dead_orphan(struct ubifs_info *c, ino_t inum)\n{\n\tstruct ubifs_orphan *orphan, *o;\n\tstruct rb_node **p, *parent = NULL;\n\n\torphan = kzalloc(sizeof(struct ubifs_orphan), GFP_KERNEL);\n\tif (!orphan)\n\t\treturn -ENOMEM;\n\torphan->inum = inum;\n\n\tp = &c->orph_tree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\to = rb_entry(parent, struct ubifs_orphan, rb);\n\t\tif (inum < o->inum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (inum > o->inum)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\t/* Already added - no problem */\n\t\t\tkfree(orphan);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tc->tot_orphans += 1;\n\trb_link_node(&orphan->rb, parent, p);\n\trb_insert_color(&orphan->rb, &c->orph_tree);\n\tlist_add_tail(&orphan->list, &c->orph_list);\n\torphan->del = 1;\n\torphan->dnext = c->orph_dnext;\n\tc->orph_dnext = orphan;\n\tdbg_mnt(\"ino %lu, new %d, tot %d\", (unsigned long)inum,\n\t\tc->new_orphans, c->tot_orphans);\n\treturn 0;\n}",
    "includes": [
      "#include \"ubifs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbg_check_orphans(struct ubifs_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbg_mnt",
          "args": [
            "\"ino %lu, new %d, tot %d\"",
            "(unsigned long)inum",
            "c->new_orphans",
            "c->tot_orphans"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&orphan->list",
            "&c->orph_list"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&orphan->rb",
            "&c->orph_tree"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&orphan->rb",
            "parent",
            "p"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "orphan"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structubifs_orphan",
            "rb"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ubifs_orphan)",
            "GFP_KERNEL"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int insert_dead_orphan(struct ubifs_info *c, ino_t inum)\n{\n\tstruct ubifs_orphan *orphan, *o;\n\tstruct rb_node **p, *parent = NULL;\n\n\torphan = kzalloc(sizeof(struct ubifs_orphan), GFP_KERNEL);\n\tif (!orphan)\n\t\treturn -ENOMEM;\n\torphan->inum = inum;\n\n\tp = &c->orph_tree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\to = rb_entry(parent, struct ubifs_orphan, rb);\n\t\tif (inum < o->inum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (inum > o->inum)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\t/* Already added - no problem */\n\t\t\tkfree(orphan);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tc->tot_orphans += 1;\n\trb_link_node(&orphan->rb, parent, p);\n\trb_insert_color(&orphan->rb, &c->orph_tree);\n\tlist_add_tail(&orphan->list, &c->orph_list);\n\torphan->del = 1;\n\torphan->dnext = c->orph_dnext;\n\tc->orph_dnext = orphan;\n\tdbg_mnt(\"ino %lu, new %d, tot %d\", (unsigned long)inum,\n\t\tc->new_orphans, c->tot_orphans);\n\treturn 0;\n}"
  },
  {
    "function_name": "ubifs_clear_orphans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
    "lines": "489-501",
    "snippet": "int ubifs_clear_orphans(struct ubifs_info *c)\n{\n\tint lnum, err;\n\n\tfor (lnum = c->orph_first; lnum <= c->orph_last; lnum++) {\n\t\terr = ubifs_leb_unmap(c, lnum);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tc->ohead_lnum = c->orph_first;\n\tc->ohead_offs = 0;\n\treturn 0;\n}",
    "includes": [
      "#include \"ubifs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbg_check_orphans(struct ubifs_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ubifs_leb_unmap",
          "args": [
            "c",
            "lnum"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nint ubifs_clear_orphans(struct ubifs_info *c)\n{\n\tint lnum, err;\n\n\tfor (lnum = c->orph_first; lnum <= c->orph_last; lnum++) {\n\t\terr = ubifs_leb_unmap(c, lnum);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tc->ohead_lnum = c->orph_first;\n\tc->ohead_offs = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "ubifs_orphan_end_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
    "lines": "467-479",
    "snippet": "int ubifs_orphan_end_commit(struct ubifs_info *c)\n{\n\tint err;\n\n\tif (c->cmt_orphans != 0) {\n\t\terr = commit_orphans(c);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\terase_deleted(c);\n\terr = dbg_check_orphans(c);\n\treturn err;\n}",
    "includes": [
      "#include \"ubifs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbg_check_orphans(struct ubifs_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbg_check_orphans",
          "args": [
            "c"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_check_orphans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
          "lines": "913-956",
          "snippet": "static int dbg_check_orphans(struct ubifs_info *c)\n{\n\tstruct check_info ci;\n\tint err;\n\n\tif (!dbg_is_chk_orph(c))\n\t\treturn 0;\n\n\tci.last_ino = 0;\n\tci.tot_inos = 0;\n\tci.missing  = 0;\n\tci.leaf_cnt = 0;\n\tci.root = RB_ROOT;\n\tci.node = kmalloc(UBIFS_MAX_INO_NODE_SZ, GFP_NOFS);\n\tif (!ci.node) {\n\t\tubifs_err(\"out of memory\");\n\t\treturn -ENOMEM;\n\t}\n\n\terr = dbg_scan_orphans(c, &ci);\n\tif (err)\n\t\tgoto out;\n\n\terr = dbg_walk_index(c, &dbg_orphan_check, NULL, &ci);\n\tif (err) {\n\t\tubifs_err(\"cannot scan TNC, error %d\", err);\n\t\tgoto out;\n\t}\n\n\tif (ci.missing) {\n\t\tubifs_err(\"%lu missing orphan(s)\", ci.missing);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdbg_cmt(\"last inode number is %lu\", ci.last_ino);\n\tdbg_cmt(\"total number of inodes is %lu\", ci.tot_inos);\n\tdbg_cmt(\"total number of leaf nodes is %llu\", ci.leaf_cnt);\n\nout:\n\tdbg_free_check_tree(&ci.root);\n\tkfree(ci.node);\n\treturn err;\n}",
          "includes": [
            "#include \"ubifs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbg_check_orphans(struct ubifs_info *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int dbg_check_orphans(struct ubifs_info *c)\n{\n\tstruct check_info ci;\n\tint err;\n\n\tif (!dbg_is_chk_orph(c))\n\t\treturn 0;\n\n\tci.last_ino = 0;\n\tci.tot_inos = 0;\n\tci.missing  = 0;\n\tci.leaf_cnt = 0;\n\tci.root = RB_ROOT;\n\tci.node = kmalloc(UBIFS_MAX_INO_NODE_SZ, GFP_NOFS);\n\tif (!ci.node) {\n\t\tubifs_err(\"out of memory\");\n\t\treturn -ENOMEM;\n\t}\n\n\terr = dbg_scan_orphans(c, &ci);\n\tif (err)\n\t\tgoto out;\n\n\terr = dbg_walk_index(c, &dbg_orphan_check, NULL, &ci);\n\tif (err) {\n\t\tubifs_err(\"cannot scan TNC, error %d\", err);\n\t\tgoto out;\n\t}\n\n\tif (ci.missing) {\n\t\tubifs_err(\"%lu missing orphan(s)\", ci.missing);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdbg_cmt(\"last inode number is %lu\", ci.last_ino);\n\tdbg_cmt(\"total number of inodes is %lu\", ci.tot_inos);\n\tdbg_cmt(\"total number of leaf nodes is %llu\", ci.leaf_cnt);\n\nout:\n\tdbg_free_check_tree(&ci.root);\n\tkfree(ci.node);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "erase_deleted",
          "args": [
            "c"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "erase_deleted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
          "lines": "440-459",
          "snippet": "static void erase_deleted(struct ubifs_info *c)\n{\n\tstruct ubifs_orphan *orphan, *dnext;\n\n\tspin_lock(&c->orphan_lock);\n\tdnext = c->orph_dnext;\n\twhile (dnext) {\n\t\torphan = dnext;\n\t\tdnext = orphan->dnext;\n\t\tubifs_assert(!orphan->new);\n\t\tubifs_assert(orphan->del);\n\t\trb_erase(&orphan->rb, &c->orph_tree);\n\t\tlist_del(&orphan->list);\n\t\tc->tot_orphans -= 1;\n\t\tdbg_gen(\"deleting orphan ino %lu\", (unsigned long)orphan->inum);\n\t\tkfree(orphan);\n\t}\n\tc->orph_dnext = NULL;\n\tspin_unlock(&c->orphan_lock);\n}",
          "includes": [
            "#include \"ubifs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbg_check_orphans(struct ubifs_info *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic void erase_deleted(struct ubifs_info *c)\n{\n\tstruct ubifs_orphan *orphan, *dnext;\n\n\tspin_lock(&c->orphan_lock);\n\tdnext = c->orph_dnext;\n\twhile (dnext) {\n\t\torphan = dnext;\n\t\tdnext = orphan->dnext;\n\t\tubifs_assert(!orphan->new);\n\t\tubifs_assert(orphan->del);\n\t\trb_erase(&orphan->rb, &c->orph_tree);\n\t\tlist_del(&orphan->list);\n\t\tc->tot_orphans -= 1;\n\t\tdbg_gen(\"deleting orphan ino %lu\", (unsigned long)orphan->inum);\n\t\tkfree(orphan);\n\t}\n\tc->orph_dnext = NULL;\n\tspin_unlock(&c->orphan_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "commit_orphans",
          "args": [
            "c"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "commit_orphans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
          "lines": "414-429",
          "snippet": "static int commit_orphans(struct ubifs_info *c)\n{\n\tint avail, atomic = 0, err;\n\n\tubifs_assert(c->cmt_orphans > 0);\n\tavail = avail_orphs(c);\n\tif (avail < c->cmt_orphans) {\n\t\t/* Not enough space to write new orphans, so consolidate */\n\t\terr = consolidate(c);\n\t\tif (err)\n\t\t\treturn err;\n\t\tatomic = 1;\n\t}\n\terr = write_orph_nodes(c, atomic);\n\treturn err;\n}",
          "includes": [
            "#include \"ubifs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbg_check_orphans(struct ubifs_info *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int commit_orphans(struct ubifs_info *c)\n{\n\tint avail, atomic = 0, err;\n\n\tubifs_assert(c->cmt_orphans > 0);\n\tavail = avail_orphs(c);\n\tif (avail < c->cmt_orphans) {\n\t\t/* Not enough space to write new orphans, so consolidate */\n\t\terr = consolidate(c);\n\t\tif (err)\n\t\t\treturn err;\n\t\tatomic = 1;\n\t}\n\terr = write_orph_nodes(c, atomic);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nint ubifs_orphan_end_commit(struct ubifs_info *c)\n{\n\tint err;\n\n\tif (c->cmt_orphans != 0) {\n\t\terr = commit_orphans(c);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\terase_deleted(c);\n\terr = dbg_check_orphans(c);\n\treturn err;\n}"
  },
  {
    "function_name": "erase_deleted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
    "lines": "440-459",
    "snippet": "static void erase_deleted(struct ubifs_info *c)\n{\n\tstruct ubifs_orphan *orphan, *dnext;\n\n\tspin_lock(&c->orphan_lock);\n\tdnext = c->orph_dnext;\n\twhile (dnext) {\n\t\torphan = dnext;\n\t\tdnext = orphan->dnext;\n\t\tubifs_assert(!orphan->new);\n\t\tubifs_assert(orphan->del);\n\t\trb_erase(&orphan->rb, &c->orph_tree);\n\t\tlist_del(&orphan->list);\n\t\tc->tot_orphans -= 1;\n\t\tdbg_gen(\"deleting orphan ino %lu\", (unsigned long)orphan->inum);\n\t\tkfree(orphan);\n\t}\n\tc->orph_dnext = NULL;\n\tspin_unlock(&c->orphan_lock);\n}",
    "includes": [
      "#include \"ubifs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbg_check_orphans(struct ubifs_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&c->orphan_lock"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "orphan"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_gen",
          "args": [
            "\"deleting orphan ino %lu\"",
            "(unsigned long)orphan->inum"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&orphan->list"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&orphan->rb",
            "&c->orph_tree"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_assert",
          "args": [
            "orphan->del"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_assert",
          "args": [
            "!orphan->new"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&c->orphan_lock"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic void erase_deleted(struct ubifs_info *c)\n{\n\tstruct ubifs_orphan *orphan, *dnext;\n\n\tspin_lock(&c->orphan_lock);\n\tdnext = c->orph_dnext;\n\twhile (dnext) {\n\t\torphan = dnext;\n\t\tdnext = orphan->dnext;\n\t\tubifs_assert(!orphan->new);\n\t\tubifs_assert(orphan->del);\n\t\trb_erase(&orphan->rb, &c->orph_tree);\n\t\tlist_del(&orphan->list);\n\t\tc->tot_orphans -= 1;\n\t\tdbg_gen(\"deleting orphan ino %lu\", (unsigned long)orphan->inum);\n\t\tkfree(orphan);\n\t}\n\tc->orph_dnext = NULL;\n\tspin_unlock(&c->orphan_lock);\n}"
  },
  {
    "function_name": "commit_orphans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
    "lines": "414-429",
    "snippet": "static int commit_orphans(struct ubifs_info *c)\n{\n\tint avail, atomic = 0, err;\n\n\tubifs_assert(c->cmt_orphans > 0);\n\tavail = avail_orphs(c);\n\tif (avail < c->cmt_orphans) {\n\t\t/* Not enough space to write new orphans, so consolidate */\n\t\terr = consolidate(c);\n\t\tif (err)\n\t\t\treturn err;\n\t\tatomic = 1;\n\t}\n\terr = write_orph_nodes(c, atomic);\n\treturn err;\n}",
    "includes": [
      "#include \"ubifs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbg_check_orphans(struct ubifs_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_orph_nodes",
          "args": [
            "c",
            "atomic"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "write_orph_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
          "lines": "336-356",
          "snippet": "static int write_orph_nodes(struct ubifs_info *c, int atomic)\n{\n\tint err;\n\n\twhile (c->cmt_orphans > 0) {\n\t\terr = write_orph_node(c, atomic);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (atomic) {\n\t\tint lnum;\n\n\t\t/* Unmap any unused LEBs after consolidation */\n\t\tfor (lnum = c->ohead_lnum + 1; lnum <= c->orph_last; lnum++) {\n\t\t\terr = ubifs_leb_unmap(c, lnum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ubifs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbg_check_orphans(struct ubifs_info *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int write_orph_nodes(struct ubifs_info *c, int atomic)\n{\n\tint err;\n\n\twhile (c->cmt_orphans > 0) {\n\t\terr = write_orph_node(c, atomic);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (atomic) {\n\t\tint lnum;\n\n\t\t/* Unmap any unused LEBs after consolidation */\n\t\tfor (lnum = c->ohead_lnum + 1; lnum <= c->orph_last; lnum++) {\n\t\t\terr = ubifs_leb_unmap(c, lnum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "consolidate",
          "args": [
            "c"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "consolidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
          "lines": "369-405",
          "snippet": "static int consolidate(struct ubifs_info *c)\n{\n\tint tot_avail = tot_avail_orphs(c), err = 0;\n\n\tspin_lock(&c->orphan_lock);\n\tdbg_cmt(\"there is space for %d orphans and there are %d\",\n\t\ttot_avail, c->tot_orphans);\n\tif (c->tot_orphans - c->new_orphans <= tot_avail) {\n\t\tstruct ubifs_orphan *orphan, **last;\n\t\tint cnt = 0;\n\n\t\t/* Change the cnext list to include all non-new orphans */\n\t\tlast = &c->orph_cnext;\n\t\tlist_for_each_entry(orphan, &c->orph_list, list) {\n\t\t\tif (orphan->new)\n\t\t\t\tcontinue;\n\t\t\torphan->cmt = 1;\n\t\t\t*last = orphan;\n\t\t\tlast = &orphan->cnext;\n\t\t\tcnt += 1;\n\t\t}\n\t\t*last = NULL;\n\t\tubifs_assert(cnt == c->tot_orphans - c->new_orphans);\n\t\tc->cmt_orphans = cnt;\n\t\tc->ohead_lnum = c->orph_first;\n\t\tc->ohead_offs = 0;\n\t} else {\n\t\t/*\n\t\t * We limit the number of orphans so that this should\n\t\t * never happen.\n\t\t */\n\t\tubifs_err(\"out of space in orphan area\");\n\t\terr = -EINVAL;\n\t}\n\tspin_unlock(&c->orphan_lock);\n\treturn err;\n}",
          "includes": [
            "#include \"ubifs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbg_check_orphans(struct ubifs_info *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int consolidate(struct ubifs_info *c)\n{\n\tint tot_avail = tot_avail_orphs(c), err = 0;\n\n\tspin_lock(&c->orphan_lock);\n\tdbg_cmt(\"there is space for %d orphans and there are %d\",\n\t\ttot_avail, c->tot_orphans);\n\tif (c->tot_orphans - c->new_orphans <= tot_avail) {\n\t\tstruct ubifs_orphan *orphan, **last;\n\t\tint cnt = 0;\n\n\t\t/* Change the cnext list to include all non-new orphans */\n\t\tlast = &c->orph_cnext;\n\t\tlist_for_each_entry(orphan, &c->orph_list, list) {\n\t\t\tif (orphan->new)\n\t\t\t\tcontinue;\n\t\t\torphan->cmt = 1;\n\t\t\t*last = orphan;\n\t\t\tlast = &orphan->cnext;\n\t\t\tcnt += 1;\n\t\t}\n\t\t*last = NULL;\n\t\tubifs_assert(cnt == c->tot_orphans - c->new_orphans);\n\t\tc->cmt_orphans = cnt;\n\t\tc->ohead_lnum = c->orph_first;\n\t\tc->ohead_offs = 0;\n\t} else {\n\t\t/*\n\t\t * We limit the number of orphans so that this should\n\t\t * never happen.\n\t\t */\n\t\tubifs_err(\"out of space in orphan area\");\n\t\terr = -EINVAL;\n\t}\n\tspin_unlock(&c->orphan_lock);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "avail_orphs",
          "args": [
            "c"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "tot_avail_orphs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
          "lines": "222-230",
          "snippet": "static int tot_avail_orphs(struct ubifs_info *c)\n{\n\tint avail_lebs, avail;\n\n\tavail_lebs = c->orph_lebs;\n\tavail = avail_lebs *\n\t       ((c->leb_size - UBIFS_ORPH_NODE_SZ) / sizeof(__le64));\n\treturn avail / 2;\n}",
          "includes": [
            "#include \"ubifs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbg_check_orphans(struct ubifs_info *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int tot_avail_orphs(struct ubifs_info *c)\n{\n\tint avail_lebs, avail;\n\n\tavail_lebs = c->orph_lebs;\n\tavail = avail_lebs *\n\t       ((c->leb_size - UBIFS_ORPH_NODE_SZ) / sizeof(__le64));\n\treturn avail / 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubifs_assert",
          "args": [
            "c->cmt_orphans > 0"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int commit_orphans(struct ubifs_info *c)\n{\n\tint avail, atomic = 0, err;\n\n\tubifs_assert(c->cmt_orphans > 0);\n\tavail = avail_orphs(c);\n\tif (avail < c->cmt_orphans) {\n\t\t/* Not enough space to write new orphans, so consolidate */\n\t\terr = consolidate(c);\n\t\tif (err)\n\t\t\treturn err;\n\t\tatomic = 1;\n\t}\n\terr = write_orph_nodes(c, atomic);\n\treturn err;\n}"
  },
  {
    "function_name": "consolidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
    "lines": "369-405",
    "snippet": "static int consolidate(struct ubifs_info *c)\n{\n\tint tot_avail = tot_avail_orphs(c), err = 0;\n\n\tspin_lock(&c->orphan_lock);\n\tdbg_cmt(\"there is space for %d orphans and there are %d\",\n\t\ttot_avail, c->tot_orphans);\n\tif (c->tot_orphans - c->new_orphans <= tot_avail) {\n\t\tstruct ubifs_orphan *orphan, **last;\n\t\tint cnt = 0;\n\n\t\t/* Change the cnext list to include all non-new orphans */\n\t\tlast = &c->orph_cnext;\n\t\tlist_for_each_entry(orphan, &c->orph_list, list) {\n\t\t\tif (orphan->new)\n\t\t\t\tcontinue;\n\t\t\torphan->cmt = 1;\n\t\t\t*last = orphan;\n\t\t\tlast = &orphan->cnext;\n\t\t\tcnt += 1;\n\t\t}\n\t\t*last = NULL;\n\t\tubifs_assert(cnt == c->tot_orphans - c->new_orphans);\n\t\tc->cmt_orphans = cnt;\n\t\tc->ohead_lnum = c->orph_first;\n\t\tc->ohead_offs = 0;\n\t} else {\n\t\t/*\n\t\t * We limit the number of orphans so that this should\n\t\t * never happen.\n\t\t */\n\t\tubifs_err(\"out of space in orphan area\");\n\t\terr = -EINVAL;\n\t}\n\tspin_unlock(&c->orphan_lock);\n\treturn err;\n}",
    "includes": [
      "#include \"ubifs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbg_check_orphans(struct ubifs_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&c->orphan_lock"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubifs_err",
          "args": [
            "\"out of space in orphan area\""
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_assert",
          "args": [
            "cnt == c->tot_orphans - c->new_orphans"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "orphan",
            "&c->orph_list",
            "list"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_cmt",
          "args": [
            "\"there is space for %d orphans and there are %d\"",
            "tot_avail",
            "c->tot_orphans"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&c->orphan_lock"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tot_avail_orphs",
          "args": [
            "c"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "tot_avail_orphs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
          "lines": "222-230",
          "snippet": "static int tot_avail_orphs(struct ubifs_info *c)\n{\n\tint avail_lebs, avail;\n\n\tavail_lebs = c->orph_lebs;\n\tavail = avail_lebs *\n\t       ((c->leb_size - UBIFS_ORPH_NODE_SZ) / sizeof(__le64));\n\treturn avail / 2;\n}",
          "includes": [
            "#include \"ubifs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbg_check_orphans(struct ubifs_info *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int tot_avail_orphs(struct ubifs_info *c)\n{\n\tint avail_lebs, avail;\n\n\tavail_lebs = c->orph_lebs;\n\tavail = avail_lebs *\n\t       ((c->leb_size - UBIFS_ORPH_NODE_SZ) / sizeof(__le64));\n\treturn avail / 2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int consolidate(struct ubifs_info *c)\n{\n\tint tot_avail = tot_avail_orphs(c), err = 0;\n\n\tspin_lock(&c->orphan_lock);\n\tdbg_cmt(\"there is space for %d orphans and there are %d\",\n\t\ttot_avail, c->tot_orphans);\n\tif (c->tot_orphans - c->new_orphans <= tot_avail) {\n\t\tstruct ubifs_orphan *orphan, **last;\n\t\tint cnt = 0;\n\n\t\t/* Change the cnext list to include all non-new orphans */\n\t\tlast = &c->orph_cnext;\n\t\tlist_for_each_entry(orphan, &c->orph_list, list) {\n\t\t\tif (orphan->new)\n\t\t\t\tcontinue;\n\t\t\torphan->cmt = 1;\n\t\t\t*last = orphan;\n\t\t\tlast = &orphan->cnext;\n\t\t\tcnt += 1;\n\t\t}\n\t\t*last = NULL;\n\t\tubifs_assert(cnt == c->tot_orphans - c->new_orphans);\n\t\tc->cmt_orphans = cnt;\n\t\tc->ohead_lnum = c->orph_first;\n\t\tc->ohead_offs = 0;\n\t} else {\n\t\t/*\n\t\t * We limit the number of orphans so that this should\n\t\t * never happen.\n\t\t */\n\t\tubifs_err(\"out of space in orphan area\");\n\t\terr = -EINVAL;\n\t}\n\tspin_unlock(&c->orphan_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "write_orph_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
    "lines": "336-356",
    "snippet": "static int write_orph_nodes(struct ubifs_info *c, int atomic)\n{\n\tint err;\n\n\twhile (c->cmt_orphans > 0) {\n\t\terr = write_orph_node(c, atomic);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (atomic) {\n\t\tint lnum;\n\n\t\t/* Unmap any unused LEBs after consolidation */\n\t\tfor (lnum = c->ohead_lnum + 1; lnum <= c->orph_last; lnum++) {\n\t\t\terr = ubifs_leb_unmap(c, lnum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ubifs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbg_check_orphans(struct ubifs_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ubifs_leb_unmap",
          "args": [
            "c",
            "lnum"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_orph_node",
          "args": [
            "c",
            "atomic"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "write_orph_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
          "lines": "336-356",
          "snippet": "static int write_orph_nodes(struct ubifs_info *c, int atomic)\n{\n\tint err;\n\n\twhile (c->cmt_orphans > 0) {\n\t\terr = write_orph_node(c, atomic);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (atomic) {\n\t\tint lnum;\n\n\t\t/* Unmap any unused LEBs after consolidation */\n\t\tfor (lnum = c->ohead_lnum + 1; lnum <= c->orph_last; lnum++) {\n\t\t\terr = ubifs_leb_unmap(c, lnum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int write_orph_nodes(struct ubifs_info *c, int atomic)\n{\n\tint err;\n\n\twhile (c->cmt_orphans > 0) {\n\t\terr = write_orph_node(c, atomic);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (atomic) {\n\t\tint lnum;\n\n\t\t/* Unmap any unused LEBs after consolidation */\n\t\tfor (lnum = c->ohead_lnum + 1; lnum <= c->orph_last; lnum++) {\n\t\t\terr = ubifs_leb_unmap(c, lnum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "write_orph_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
    "lines": "273-326",
    "snippet": "static int write_orph_node(struct ubifs_info *c, int atomic)\n{\n\tstruct ubifs_orphan *orphan, *cnext;\n\tstruct ubifs_orph_node *orph;\n\tint gap, err, len, cnt, i;\n\n\tubifs_assert(c->cmt_orphans > 0);\n\tgap = c->leb_size - c->ohead_offs;\n\tif (gap < UBIFS_ORPH_NODE_SZ + sizeof(__le64)) {\n\t\tc->ohead_lnum += 1;\n\t\tc->ohead_offs = 0;\n\t\tgap = c->leb_size;\n\t\tif (c->ohead_lnum > c->orph_last) {\n\t\t\t/*\n\t\t\t * We limit the number of orphans so that this should\n\t\t\t * never happen.\n\t\t\t */\n\t\t\tubifs_err(\"out of space in orphan area\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tcnt = (gap - UBIFS_ORPH_NODE_SZ) / sizeof(__le64);\n\tif (cnt > c->cmt_orphans)\n\t\tcnt = c->cmt_orphans;\n\tlen = UBIFS_ORPH_NODE_SZ + cnt * sizeof(__le64);\n\tubifs_assert(c->orph_buf);\n\torph = c->orph_buf;\n\torph->ch.node_type = UBIFS_ORPH_NODE;\n\tspin_lock(&c->orphan_lock);\n\tcnext = c->orph_cnext;\n\tfor (i = 0; i < cnt; i++) {\n\t\torphan = cnext;\n\t\tubifs_assert(orphan->cmt);\n\t\torph->inos[i] = cpu_to_le64(orphan->inum);\n\t\torphan->cmt = 0;\n\t\tcnext = orphan->cnext;\n\t\torphan->cnext = NULL;\n\t}\n\tc->orph_cnext = cnext;\n\tc->cmt_orphans -= cnt;\n\tspin_unlock(&c->orphan_lock);\n\tif (c->cmt_orphans)\n\t\torph->cmt_no = cpu_to_le64(c->cmt_no);\n\telse\n\t\t/* Mark the last node of the commit */\n\t\torph->cmt_no = cpu_to_le64((c->cmt_no) | (1ULL << 63));\n\tubifs_assert(c->ohead_offs + len <= c->leb_size);\n\tubifs_assert(c->ohead_lnum >= c->orph_first);\n\tubifs_assert(c->ohead_lnum <= c->orph_last);\n\terr = do_write_orph_node(c, len, atomic);\n\tc->ohead_offs += ALIGN(len, c->min_io_size);\n\tc->ohead_offs = ALIGN(c->ohead_offs, 8);\n\treturn err;\n}",
    "includes": [
      "#include \"ubifs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbg_check_orphans(struct ubifs_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "c->ohead_offs",
            "8"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "len",
            "c->min_io_size"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_write_orph_node",
          "args": [
            "c",
            "len",
            "atomic"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "do_write_orph_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
          "lines": "242-262",
          "snippet": "static int do_write_orph_node(struct ubifs_info *c, int len, int atomic)\n{\n\tint err = 0;\n\n\tif (atomic) {\n\t\tubifs_assert(c->ohead_offs == 0);\n\t\tubifs_prepare_node(c, c->orph_buf, len, 1);\n\t\tlen = ALIGN(len, c->min_io_size);\n\t\terr = ubifs_leb_change(c, c->ohead_lnum, c->orph_buf, len);\n\t} else {\n\t\tif (c->ohead_offs == 0) {\n\t\t\t/* Ensure LEB has been unmapped */\n\t\t\terr = ubifs_leb_unmap(c, c->ohead_lnum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = ubifs_write_node(c, c->orph_buf, len, c->ohead_lnum,\n\t\t\t\t       c->ohead_offs);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"ubifs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbg_check_orphans(struct ubifs_info *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int do_write_orph_node(struct ubifs_info *c, int len, int atomic)\n{\n\tint err = 0;\n\n\tif (atomic) {\n\t\tubifs_assert(c->ohead_offs == 0);\n\t\tubifs_prepare_node(c, c->orph_buf, len, 1);\n\t\tlen = ALIGN(len, c->min_io_size);\n\t\terr = ubifs_leb_change(c, c->ohead_lnum, c->orph_buf, len);\n\t} else {\n\t\tif (c->ohead_offs == 0) {\n\t\t\t/* Ensure LEB has been unmapped */\n\t\t\terr = ubifs_leb_unmap(c, c->ohead_lnum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = ubifs_write_node(c, c->orph_buf, len, c->ohead_lnum,\n\t\t\t\t       c->ohead_offs);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubifs_assert",
          "args": [
            "c->ohead_lnum <= c->orph_last"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_assert",
          "args": [
            "c->ohead_lnum >= c->orph_first"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_assert",
          "args": [
            "c->ohead_offs + len <= c->leb_size"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "(c->cmt_no) | (1ULL << 63)"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "c->cmt_no"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&c->orphan_lock"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "orphan->inum"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_assert",
          "args": [
            "orphan->cmt"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&c->orphan_lock"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubifs_assert",
          "args": [
            "c->orph_buf"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_err",
          "args": [
            "\"out of space in orphan area\""
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_assert",
          "args": [
            "c->cmt_orphans > 0"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int write_orph_node(struct ubifs_info *c, int atomic)\n{\n\tstruct ubifs_orphan *orphan, *cnext;\n\tstruct ubifs_orph_node *orph;\n\tint gap, err, len, cnt, i;\n\n\tubifs_assert(c->cmt_orphans > 0);\n\tgap = c->leb_size - c->ohead_offs;\n\tif (gap < UBIFS_ORPH_NODE_SZ + sizeof(__le64)) {\n\t\tc->ohead_lnum += 1;\n\t\tc->ohead_offs = 0;\n\t\tgap = c->leb_size;\n\t\tif (c->ohead_lnum > c->orph_last) {\n\t\t\t/*\n\t\t\t * We limit the number of orphans so that this should\n\t\t\t * never happen.\n\t\t\t */\n\t\t\tubifs_err(\"out of space in orphan area\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tcnt = (gap - UBIFS_ORPH_NODE_SZ) / sizeof(__le64);\n\tif (cnt > c->cmt_orphans)\n\t\tcnt = c->cmt_orphans;\n\tlen = UBIFS_ORPH_NODE_SZ + cnt * sizeof(__le64);\n\tubifs_assert(c->orph_buf);\n\torph = c->orph_buf;\n\torph->ch.node_type = UBIFS_ORPH_NODE;\n\tspin_lock(&c->orphan_lock);\n\tcnext = c->orph_cnext;\n\tfor (i = 0; i < cnt; i++) {\n\t\torphan = cnext;\n\t\tubifs_assert(orphan->cmt);\n\t\torph->inos[i] = cpu_to_le64(orphan->inum);\n\t\torphan->cmt = 0;\n\t\tcnext = orphan->cnext;\n\t\torphan->cnext = NULL;\n\t}\n\tc->orph_cnext = cnext;\n\tc->cmt_orphans -= cnt;\n\tspin_unlock(&c->orphan_lock);\n\tif (c->cmt_orphans)\n\t\torph->cmt_no = cpu_to_le64(c->cmt_no);\n\telse\n\t\t/* Mark the last node of the commit */\n\t\torph->cmt_no = cpu_to_le64((c->cmt_no) | (1ULL << 63));\n\tubifs_assert(c->ohead_offs + len <= c->leb_size);\n\tubifs_assert(c->ohead_lnum >= c->orph_first);\n\tubifs_assert(c->ohead_lnum <= c->orph_last);\n\terr = do_write_orph_node(c, len, atomic);\n\tc->ohead_offs += ALIGN(len, c->min_io_size);\n\tc->ohead_offs = ALIGN(c->ohead_offs, 8);\n\treturn err;\n}"
  },
  {
    "function_name": "do_write_orph_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
    "lines": "242-262",
    "snippet": "static int do_write_orph_node(struct ubifs_info *c, int len, int atomic)\n{\n\tint err = 0;\n\n\tif (atomic) {\n\t\tubifs_assert(c->ohead_offs == 0);\n\t\tubifs_prepare_node(c, c->orph_buf, len, 1);\n\t\tlen = ALIGN(len, c->min_io_size);\n\t\terr = ubifs_leb_change(c, c->ohead_lnum, c->orph_buf, len);\n\t} else {\n\t\tif (c->ohead_offs == 0) {\n\t\t\t/* Ensure LEB has been unmapped */\n\t\t\terr = ubifs_leb_unmap(c, c->ohead_lnum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = ubifs_write_node(c, c->orph_buf, len, c->ohead_lnum,\n\t\t\t\t       c->ohead_offs);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"ubifs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbg_check_orphans(struct ubifs_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ubifs_write_node",
          "args": [
            "c",
            "c->orph_buf",
            "len",
            "c->ohead_lnum",
            "c->ohead_offs"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_leb_unmap",
          "args": [
            "c",
            "c->ohead_lnum"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_leb_change",
          "args": [
            "c",
            "c->ohead_lnum",
            "c->orph_buf",
            "len"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "len",
            "c->min_io_size"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_prepare_node",
          "args": [
            "c",
            "c->orph_buf",
            "len",
            "1"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_assert",
          "args": [
            "c->ohead_offs == 0"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int do_write_orph_node(struct ubifs_info *c, int len, int atomic)\n{\n\tint err = 0;\n\n\tif (atomic) {\n\t\tubifs_assert(c->ohead_offs == 0);\n\t\tubifs_prepare_node(c, c->orph_buf, len, 1);\n\t\tlen = ALIGN(len, c->min_io_size);\n\t\terr = ubifs_leb_change(c, c->ohead_lnum, c->orph_buf, len);\n\t} else {\n\t\tif (c->ohead_offs == 0) {\n\t\t\t/* Ensure LEB has been unmapped */\n\t\t\terr = ubifs_leb_unmap(c, c->ohead_lnum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = ubifs_write_node(c, c->orph_buf, len, c->ohead_lnum,\n\t\t\t\t       c->ohead_offs);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "tot_avail_orphs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
    "lines": "222-230",
    "snippet": "static int tot_avail_orphs(struct ubifs_info *c)\n{\n\tint avail_lebs, avail;\n\n\tavail_lebs = c->orph_lebs;\n\tavail = avail_lebs *\n\t       ((c->leb_size - UBIFS_ORPH_NODE_SZ) / sizeof(__le64));\n\treturn avail / 2;\n}",
    "includes": [
      "#include \"ubifs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbg_check_orphans(struct ubifs_info *c);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int tot_avail_orphs(struct ubifs_info *c)\n{\n\tint avail_lebs, avail;\n\n\tavail_lebs = c->orph_lebs;\n\tavail = avail_lebs *\n\t       ((c->leb_size - UBIFS_ORPH_NODE_SZ) / sizeof(__le64));\n\treturn avail / 2;\n}"
  },
  {
    "function_name": "avail_orphs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
    "lines": "202-213",
    "snippet": "static int avail_orphs(struct ubifs_info *c)\n{\n\tint avail_lebs, avail, gap;\n\n\tavail_lebs = c->orph_lebs - (c->ohead_lnum - c->orph_first) - 1;\n\tavail = avail_lebs *\n\t       ((c->leb_size - UBIFS_ORPH_NODE_SZ) / sizeof(__le64));\n\tgap = c->leb_size - c->ohead_offs;\n\tif (gap >= UBIFS_ORPH_NODE_SZ + sizeof(__le64))\n\t\tavail += (gap - UBIFS_ORPH_NODE_SZ) / sizeof(__le64);\n\treturn avail;\n}",
    "includes": [
      "#include \"ubifs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbg_check_orphans(struct ubifs_info *c);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int avail_orphs(struct ubifs_info *c)\n{\n\tint avail_lebs, avail, gap;\n\n\tavail_lebs = c->orph_lebs - (c->ohead_lnum - c->orph_first) - 1;\n\tavail = avail_lebs *\n\t       ((c->leb_size - UBIFS_ORPH_NODE_SZ) / sizeof(__le64));\n\tgap = c->leb_size - c->ohead_offs;\n\tif (gap >= UBIFS_ORPH_NODE_SZ + sizeof(__le64))\n\t\tavail += (gap - UBIFS_ORPH_NODE_SZ) / sizeof(__le64);\n\treturn avail;\n}"
  },
  {
    "function_name": "ubifs_orphan_start_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
    "lines": "168-193",
    "snippet": "int ubifs_orphan_start_commit(struct ubifs_info *c)\n{\n\tstruct ubifs_orphan *orphan, **last;\n\n\tspin_lock(&c->orphan_lock);\n\tlast = &c->orph_cnext;\n\tlist_for_each_entry(orphan, &c->orph_new, new_list) {\n\t\tubifs_assert(orphan->new);\n\t\tubifs_assert(!orphan->cmt);\n\t\torphan->new = 0;\n\t\torphan->cmt = 1;\n\t\t*last = orphan;\n\t\tlast = &orphan->cnext;\n\t}\n\t*last = NULL;\n\tc->cmt_orphans = c->new_orphans;\n\tc->new_orphans = 0;\n\tdbg_cmt(\"%d orphans to commit\", c->cmt_orphans);\n\tINIT_LIST_HEAD(&c->orph_new);\n\tif (c->tot_orphans == 0)\n\t\tc->no_orphs = 1;\n\telse\n\t\tc->no_orphs = 0;\n\tspin_unlock(&c->orphan_lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"ubifs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbg_check_orphans(struct ubifs_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&c->orphan_lock"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&c->orph_new"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_cmt",
          "args": [
            "\"%d orphans to commit\"",
            "c->cmt_orphans"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_assert",
          "args": [
            "!orphan->cmt"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_assert",
          "args": [
            "orphan->new"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "orphan",
            "&c->orph_new",
            "new_list"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&c->orphan_lock"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nint ubifs_orphan_start_commit(struct ubifs_info *c)\n{\n\tstruct ubifs_orphan *orphan, **last;\n\n\tspin_lock(&c->orphan_lock);\n\tlast = &c->orph_cnext;\n\tlist_for_each_entry(orphan, &c->orph_new, new_list) {\n\t\tubifs_assert(orphan->new);\n\t\tubifs_assert(!orphan->cmt);\n\t\torphan->new = 0;\n\t\torphan->cmt = 1;\n\t\t*last = orphan;\n\t\tlast = &orphan->cnext;\n\t}\n\t*last = NULL;\n\tc->cmt_orphans = c->new_orphans;\n\tc->new_orphans = 0;\n\tdbg_cmt(\"%d orphans to commit\", c->cmt_orphans);\n\tINIT_LIST_HEAD(&c->orph_new);\n\tif (c->tot_orphans == 0)\n\t\tc->no_orphs = 1;\n\telse\n\t\tc->no_orphs = 0;\n\tspin_unlock(&c->orphan_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "ubifs_delete_orphan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
    "lines": "115-160",
    "snippet": "void ubifs_delete_orphan(struct ubifs_info *c, ino_t inum)\n{\n\tstruct ubifs_orphan *o;\n\tstruct rb_node *p;\n\n\tspin_lock(&c->orphan_lock);\n\tp = c->orph_tree.rb_node;\n\twhile (p) {\n\t\to = rb_entry(p, struct ubifs_orphan, rb);\n\t\tif (inum < o->inum)\n\t\t\tp = p->rb_left;\n\t\telse if (inum > o->inum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tif (o->del) {\n\t\t\t\tspin_unlock(&c->orphan_lock);\n\t\t\t\tdbg_gen(\"deleted twice ino %lu\",\n\t\t\t\t\t(unsigned long)inum);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (o->cmt) {\n\t\t\t\to->del = 1;\n\t\t\t\to->dnext = c->orph_dnext;\n\t\t\t\tc->orph_dnext = o;\n\t\t\t\tspin_unlock(&c->orphan_lock);\n\t\t\t\tdbg_gen(\"delete later ino %lu\",\n\t\t\t\t\t(unsigned long)inum);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trb_erase(p, &c->orph_tree);\n\t\t\tlist_del(&o->list);\n\t\t\tc->tot_orphans -= 1;\n\t\t\tif (o->new) {\n\t\t\t\tlist_del(&o->new_list);\n\t\t\t\tc->new_orphans -= 1;\n\t\t\t}\n\t\t\tspin_unlock(&c->orphan_lock);\n\t\t\tkfree(o);\n\t\t\tdbg_gen(\"inum %lu\", (unsigned long)inum);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&c->orphan_lock);\n\tubifs_err(\"missing orphan ino %lu\", (unsigned long)inum);\n\tdump_stack();\n}",
    "includes": [
      "#include \"ubifs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbg_check_orphans(struct ubifs_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_err",
          "args": [
            "\"missing orphan ino %lu\"",
            "(unsigned long)inum"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&c->orphan_lock"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_gen",
          "args": [
            "\"inum %lu\"",
            "(unsigned long)inum"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "o"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&o->new_list"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "p",
            "&c->orph_tree"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_gen",
          "args": [
            "\"delete later ino %lu\"",
            "(unsigned long)inum"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_gen",
          "args": [
            "\"deleted twice ino %lu\"",
            "(unsigned long)inum"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structubifs_orphan",
            "rb"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&c->orphan_lock"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nvoid ubifs_delete_orphan(struct ubifs_info *c, ino_t inum)\n{\n\tstruct ubifs_orphan *o;\n\tstruct rb_node *p;\n\n\tspin_lock(&c->orphan_lock);\n\tp = c->orph_tree.rb_node;\n\twhile (p) {\n\t\to = rb_entry(p, struct ubifs_orphan, rb);\n\t\tif (inum < o->inum)\n\t\t\tp = p->rb_left;\n\t\telse if (inum > o->inum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tif (o->del) {\n\t\t\t\tspin_unlock(&c->orphan_lock);\n\t\t\t\tdbg_gen(\"deleted twice ino %lu\",\n\t\t\t\t\t(unsigned long)inum);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (o->cmt) {\n\t\t\t\to->del = 1;\n\t\t\t\to->dnext = c->orph_dnext;\n\t\t\t\tc->orph_dnext = o;\n\t\t\t\tspin_unlock(&c->orphan_lock);\n\t\t\t\tdbg_gen(\"delete later ino %lu\",\n\t\t\t\t\t(unsigned long)inum);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trb_erase(p, &c->orph_tree);\n\t\t\tlist_del(&o->list);\n\t\t\tc->tot_orphans -= 1;\n\t\t\tif (o->new) {\n\t\t\t\tlist_del(&o->new_list);\n\t\t\t\tc->new_orphans -= 1;\n\t\t\t}\n\t\t\tspin_unlock(&c->orphan_lock);\n\t\t\tkfree(o);\n\t\t\tdbg_gen(\"inum %lu\", (unsigned long)inum);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&c->orphan_lock);\n\tubifs_err(\"missing orphan ino %lu\", (unsigned long)inum);\n\tdump_stack();\n}"
  },
  {
    "function_name": "ubifs_add_orphan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
    "lines": "65-106",
    "snippet": "int ubifs_add_orphan(struct ubifs_info *c, ino_t inum)\n{\n\tstruct ubifs_orphan *orphan, *o;\n\tstruct rb_node **p, *parent = NULL;\n\n\torphan = kzalloc(sizeof(struct ubifs_orphan), GFP_NOFS);\n\tif (!orphan)\n\t\treturn -ENOMEM;\n\torphan->inum = inum;\n\torphan->new = 1;\n\n\tspin_lock(&c->orphan_lock);\n\tif (c->tot_orphans >= c->max_orphans) {\n\t\tspin_unlock(&c->orphan_lock);\n\t\tkfree(orphan);\n\t\treturn -ENFILE;\n\t}\n\tp = &c->orph_tree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\to = rb_entry(parent, struct ubifs_orphan, rb);\n\t\tif (inum < o->inum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (inum > o->inum)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tubifs_err(\"orphaned twice\");\n\t\t\tspin_unlock(&c->orphan_lock);\n\t\t\tkfree(orphan);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tc->tot_orphans += 1;\n\tc->new_orphans += 1;\n\trb_link_node(&orphan->rb, parent, p);\n\trb_insert_color(&orphan->rb, &c->orph_tree);\n\tlist_add_tail(&orphan->list, &c->orph_list);\n\tlist_add_tail(&orphan->new_list, &c->orph_new);\n\tspin_unlock(&c->orphan_lock);\n\tdbg_gen(\"ino %lu\", (unsigned long)inum);\n\treturn 0;\n}",
    "includes": [
      "#include \"ubifs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dbg_check_orphans(struct ubifs_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbg_gen",
          "args": [
            "\"ino %lu\"",
            "(unsigned long)inum"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&c->orphan_lock"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&orphan->new_list",
            "&c->orph_new"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&orphan->list",
            "&c->orph_list"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&orphan->rb",
            "&c->orph_tree"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&orphan->rb",
            "parent",
            "p"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "orphan"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_err",
          "args": [
            "\"orphaned twice\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structubifs_orphan",
            "rb"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "orphan"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&c->orphan_lock"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ubifs_orphan)",
            "GFP_NOFS"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nint ubifs_add_orphan(struct ubifs_info *c, ino_t inum)\n{\n\tstruct ubifs_orphan *orphan, *o;\n\tstruct rb_node **p, *parent = NULL;\n\n\torphan = kzalloc(sizeof(struct ubifs_orphan), GFP_NOFS);\n\tif (!orphan)\n\t\treturn -ENOMEM;\n\torphan->inum = inum;\n\torphan->new = 1;\n\n\tspin_lock(&c->orphan_lock);\n\tif (c->tot_orphans >= c->max_orphans) {\n\t\tspin_unlock(&c->orphan_lock);\n\t\tkfree(orphan);\n\t\treturn -ENFILE;\n\t}\n\tp = &c->orph_tree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\to = rb_entry(parent, struct ubifs_orphan, rb);\n\t\tif (inum < o->inum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (inum > o->inum)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tubifs_err(\"orphaned twice\");\n\t\t\tspin_unlock(&c->orphan_lock);\n\t\t\tkfree(orphan);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tc->tot_orphans += 1;\n\tc->new_orphans += 1;\n\trb_link_node(&orphan->rb, parent, p);\n\trb_insert_color(&orphan->rb, &c->orph_tree);\n\tlist_add_tail(&orphan->list, &c->orph_list);\n\tlist_add_tail(&orphan->new_list, &c->orph_new);\n\tspin_unlock(&c->orphan_lock);\n\tdbg_gen(\"ino %lu\", (unsigned long)inum);\n\treturn 0;\n}"
  }
]