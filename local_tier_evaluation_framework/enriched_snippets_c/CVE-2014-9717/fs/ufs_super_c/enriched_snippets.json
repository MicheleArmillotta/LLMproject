[
  {
    "function_name": "exit_ufs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "1505-1509",
    "snippet": "static void __exit exit_ufs_fs(void)\n{\n\tunregister_filesystem(&ufs_fs_type);\n\tdestroy_inodecache();\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type ufs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ufs\",\n\t.mount\t\t= ufs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "1453-1461",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ufs_inode_cachep);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * ufs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic struct kmem_cache * ufs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ufs_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&ufs_fs_type"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic struct file_system_type ufs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ufs\",\n\t.mount\t\t= ufs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic void __exit exit_ufs_fs(void)\n{\n\tunregister_filesystem(&ufs_fs_type);\n\tdestroy_inodecache();\n}"
  },
  {
    "function_name": "init_ufs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "1490-1503",
    "snippet": "static int __init init_ufs_fs(void)\n{\n\tint err = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\terr = register_filesystem(&ufs_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\treturn err;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type ufs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ufs\",\n\t.mount\t\t= ufs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "1453-1461",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ufs_inode_cachep);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * ufs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic struct kmem_cache * ufs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ufs_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&ufs_fs_type"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_inodecache",
          "args": [],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "init_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "1441-1451",
          "snippet": "static int __init init_inodecache(void)\n{\n\tufs_inode_cachep = kmem_cache_create(\"ufs_inode_cache\",\n\t\t\t\t\t     sizeof(struct ufs_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (ufs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * ufs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic struct kmem_cache * ufs_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\tufs_inode_cachep = kmem_cache_create(\"ufs_inode_cache\",\n\t\t\t\t\t     sizeof(struct ufs_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (ufs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic struct file_system_type ufs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ufs\",\n\t.mount\t\t= ufs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic int __init init_ufs_fs(void)\n{\n\tint err = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\terr = register_filesystem(&ufs_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\treturn err;\n}"
  },
  {
    "function_name": "ufs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "1475-1479",
    "snippet": "static struct dentry *ufs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, ufs_fill_super);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "ufs_fill_super"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic struct dentry *ufs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, ufs_fill_super);\n}"
  },
  {
    "function_name": "destroy_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "1453-1461",
    "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ufs_inode_cachep);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * ufs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ufs_inode_cachep"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic struct kmem_cache * ufs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ufs_inode_cachep);\n}"
  },
  {
    "function_name": "init_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "1441-1451",
    "snippet": "static int __init init_inodecache(void)\n{\n\tufs_inode_cachep = kmem_cache_create(\"ufs_inode_cache\",\n\t\t\t\t\t     sizeof(struct ufs_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (ufs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * ufs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"ufs_inode_cache\"",
            "sizeof(struct ufs_inode_info)",
            "0",
            "(SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD)",
            "init_once"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic struct kmem_cache * ufs_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\tufs_inode_cachep = kmem_cache_create(\"ufs_inode_cache\",\n\t\t\t\t\t     sizeof(struct ufs_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (ufs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "1434-1439",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct ufs_inode_info *ei = (struct ufs_inode_info *) foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&ei->vfs_inode"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1725-1755",
          "snippet": "static void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_remount(struct super_block *sb, int *flags, char *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\n\nstatic void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic void init_once(void *foo)\n{\n\tstruct ufs_inode_info *ei = (struct ufs_inode_info *) foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}"
  },
  {
    "function_name": "ufs_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "1429-1432",
    "snippet": "static void ufs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, ufs_i_callback);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "ufs_i_callback"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic void ufs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, ufs_i_callback);\n}"
  },
  {
    "function_name": "ufs_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "1423-1427",
    "snippet": "static void ufs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(ufs_inode_cachep, UFS_I(inode));\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * ufs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ufs_inode_cachep",
            "UFS_I(inode)"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_I",
          "args": [
            "inode"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic struct kmem_cache * ufs_inode_cachep;\n\nstatic void ufs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(ufs_inode_cachep, UFS_I(inode));\n}"
  },
  {
    "function_name": "ufs_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "1411-1421",
    "snippet": "static struct inode *ufs_alloc_inode(struct super_block *sb)\n{\n\tstruct ufs_inode_info *ei;\n\n\tei = kmem_cache_alloc(ufs_inode_cachep, GFP_NOFS);\n\tif (!ei)\n\t\treturn NULL;\n\n\tei->vfs_inode.i_version = 1;\n\treturn &ei->vfs_inode;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * ufs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ufs_inode_cachep",
            "GFP_NOFS"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic struct kmem_cache * ufs_inode_cachep;\n\nstatic struct inode *ufs_alloc_inode(struct super_block *sb)\n{\n\tstruct ufs_inode_info *ei;\n\n\tei = kmem_cache_alloc(ufs_inode_cachep, GFP_NOFS);\n\tif (!ei)\n\t\treturn NULL;\n\n\tei->vfs_inode.i_version = 1;\n\treturn &ei->vfs_inode;\n}"
  },
  {
    "function_name": "ufs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "1374-1407",
    "snippet": "static int ufs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct ufs_sb_private_info *uspi= UFS_SB(sb)->s_uspi;\n\tunsigned  flags = UFS_SB(sb)->s_flags;\n\tstruct ufs_super_block_third *usb3;\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tlock_ufs(sb);\n\n\tusb3 = ubh_get_usb_third(uspi);\n\t\n\tif ((flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2) {\n\t\tbuf->f_type = UFS2_MAGIC;\n\t\tbuf->f_blocks = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_dsize);\n\t} else {\n\t\tbuf->f_type = UFS_MAGIC;\n\t\tbuf->f_blocks = uspi->s_dsize;\n\t}\n\tbuf->f_bfree = ufs_blkstofrags(uspi->cs_total.cs_nbfree) +\n\t\tuspi->cs_total.cs_nffree;\n\tbuf->f_ffree = uspi->cs_total.cs_nifree;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_bavail = (buf->f_bfree > (((long)buf->f_blocks / 100) * uspi->s_minfree))\n\t\t? (buf->f_bfree - (((long)buf->f_blocks / 100) * uspi->s_minfree)) : 0;\n\tbuf->f_files = uspi->s_ncg * uspi->s_ipg;\n\tbuf->f_namelen = UFS_MAXNAMLEN;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\n\tunlock_ufs(sb);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_ufs",
          "args": [
            "sb"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_ufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "104-110",
          "snippet": "void unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "id >> 32"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_blkstofrags",
          "args": [
            "uspi->cs_total.cs_nbfree"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs64_to_cpu",
          "args": [
            "sb",
            "usb3->fs_un1.fs_u2.fs_dsize"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "fs64_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "25-32",
          "snippet": "static inline u64\nfs64_to_cpu(struct super_block *sbp, __fs64 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64\nfs64_to_cpu(struct super_block *sbp, __fs64 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_get_usb_third",
          "args": [
            "uspi"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_encode_dev",
          "args": [
            "sb->s_bdev->bd_dev"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic int ufs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct ufs_sb_private_info *uspi= UFS_SB(sb)->s_uspi;\n\tunsigned  flags = UFS_SB(sb)->s_flags;\n\tstruct ufs_super_block_third *usb3;\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tlock_ufs(sb);\n\n\tusb3 = ubh_get_usb_third(uspi);\n\t\n\tif ((flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2) {\n\t\tbuf->f_type = UFS2_MAGIC;\n\t\tbuf->f_blocks = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_dsize);\n\t} else {\n\t\tbuf->f_type = UFS_MAGIC;\n\t\tbuf->f_blocks = uspi->s_dsize;\n\t}\n\tbuf->f_bfree = ufs_blkstofrags(uspi->cs_total.cs_nbfree) +\n\t\tuspi->cs_total.cs_nffree;\n\tbuf->f_ffree = uspi->cs_total.cs_nifree;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_bavail = (buf->f_bfree > (((long)buf->f_blocks / 100) * uspi->s_minfree))\n\t\t? (buf->f_bfree - (((long)buf->f_blocks / 100) * uspi->s_minfree)) : 0;\n\tbuf->f_files = uspi->s_ncg * uspi->s_ipg;\n\tbuf->f_namelen = UFS_MAXNAMLEN;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\n\tunlock_ufs(sb);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ufs_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "1354-1372",
    "snippet": "static int ufs_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(root->d_sb);\n\tunsigned mval = sbi->s_mount_opt & UFS_MOUNT_UFSTYPE;\n\tconst struct match_token *tp = tokens;\n\n\twhile (tp->token != Opt_onerror_panic && tp->token != mval)\n\t\t++tp;\n\tBUG_ON(tp->token == Opt_onerror_panic);\n\tseq_printf(seq, \",%s\", tp->pattern);\n\n\tmval = sbi->s_mount_opt & UFS_MOUNT_ONERROR;\n\twhile (tp->token != Opt_err && tp->token != mval)\n\t\t++tp;\n\tBUG_ON(tp->token == Opt_err);\n\tseq_printf(seq, \",%s\", tp->pattern);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t tokens = {\n\t{Opt_type_old, \"ufstype=old\"},\n\t{Opt_type_sunx86, \"ufstype=sunx86\"},\n\t{Opt_type_sun, \"ufstype=sun\"},\n\t{Opt_type_sunos, \"ufstype=sunos\"},\n\t{Opt_type_44bsd, \"ufstype=44bsd\"},\n\t{Opt_type_ufs2, \"ufstype=ufs2\"},\n\t{Opt_type_ufs2, \"ufstype=5xbsd\"},\n\t{Opt_type_hp, \"ufstype=hp\"},\n\t{Opt_type_nextstepcd, \"ufstype=nextstep-cd\"},\n\t{Opt_type_nextstep, \"ufstype=nextstep\"},\n\t{Opt_type_openstep, \"ufstype=openstep\"},\n/*end of possible ufs types */\n\t{Opt_onerror_panic, \"onerror=panic\"},\n\t{Opt_onerror_lock, \"onerror=lock\"},\n\t{Opt_onerror_umount, \"onerror=umount\"},\n\t{Opt_onerror_repair, \"onerror=repair\"},\n\t{Opt_err, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\",%s\"",
            "tp->pattern"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tp->token == Opt_err"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tp->token == Opt_onerror_panic"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "root->d_sb"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_type_old, \"ufstype=old\"},\n\t{Opt_type_sunx86, \"ufstype=sunx86\"},\n\t{Opt_type_sun, \"ufstype=sun\"},\n\t{Opt_type_sunos, \"ufstype=sunos\"},\n\t{Opt_type_44bsd, \"ufstype=44bsd\"},\n\t{Opt_type_ufs2, \"ufstype=ufs2\"},\n\t{Opt_type_ufs2, \"ufstype=5xbsd\"},\n\t{Opt_type_hp, \"ufstype=hp\"},\n\t{Opt_type_nextstepcd, \"ufstype=nextstep-cd\"},\n\t{Opt_type_nextstep, \"ufstype=nextstep\"},\n\t{Opt_type_openstep, \"ufstype=openstep\"},\n/*end of possible ufs types */\n\t{Opt_onerror_panic, \"onerror=panic\"},\n\t{Opt_onerror_lock, \"onerror=lock\"},\n\t{Opt_onerror_umount, \"onerror=umount\"},\n\t{Opt_onerror_repair, \"onerror=repair\"},\n\t{Opt_err, NULL}\n};\n\nstatic int ufs_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(root->d_sb);\n\tunsigned mval = sbi->s_mount_opt & UFS_MOUNT_UFSTYPE;\n\tconst struct match_token *tp = tokens;\n\n\twhile (tp->token != Opt_onerror_panic && tp->token != mval)\n\t\t++tp;\n\tBUG_ON(tp->token == Opt_onerror_panic);\n\tseq_printf(seq, \",%s\", tp->pattern);\n\n\tmval = sbi->s_mount_opt & UFS_MOUNT_ONERROR;\n\twhile (tp->token != Opt_err && tp->token != mval)\n\t\t++tp;\n\tBUG_ON(tp->token == Opt_err);\n\tseq_printf(seq, \",%s\", tp->pattern);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ufs_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "1270-1352",
    "snippet": "static int ufs_remount (struct super_block *sb, int *mount_flags, char *data)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct ufs_super_block_third * usb3;\n\tunsigned new_mount_opt, ufstype;\n\tunsigned flags;\n\n\tsync_filesystem(sb);\n\tlock_ufs(sb);\n\tuspi = UFS_SB(sb)->s_uspi;\n\tflags = UFS_SB(sb)->s_flags;\n\tusb1 = ubh_get_usb_first(uspi);\n\tusb3 = ubh_get_usb_third(uspi);\n\t\n\t/*\n\t * Allow the \"check\" option to be passed as a remount option.\n\t * It is not possible to change ufstype option during remount\n\t */\n\tufstype = UFS_SB(sb)->s_mount_opt & UFS_MOUNT_UFSTYPE;\n\tnew_mount_opt = 0;\n\tufs_set_opt (new_mount_opt, ONERROR_LOCK);\n\tif (!ufs_parse_options (data, &new_mount_opt)) {\n\t\tunlock_ufs(sb);\n\t\treturn -EINVAL;\n\t}\n\tif (!(new_mount_opt & UFS_MOUNT_UFSTYPE)) {\n\t\tnew_mount_opt |= ufstype;\n\t} else if ((new_mount_opt & UFS_MOUNT_UFSTYPE) != ufstype) {\n\t\tpr_err(\"ufstype can't be changed during remount\\n\");\n\t\tunlock_ufs(sb);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((*mount_flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY)) {\n\t\tUFS_SB(sb)->s_mount_opt = new_mount_opt;\n\t\tunlock_ufs(sb);\n\t\treturn 0;\n\t}\n\t\n\t/*\n\t * fs was mouted as rw, remounting ro\n\t */\n\tif (*mount_flags & MS_RDONLY) {\n\t\tufs_put_super_internal(sb);\n\t\tusb1->fs_time = cpu_to_fs32(sb, get_seconds());\n\t\tif ((flags & UFS_ST_MASK) == UFS_ST_SUN\n\t\t  || (flags & UFS_ST_MASK) == UFS_ST_SUNOS\n\t\t  || (flags & UFS_ST_MASK) == UFS_ST_SUNx86) \n\t\t\tufs_set_fs_state(sb, usb1, usb3,\n\t\t\t\tUFS_FSOK - fs32_to_cpu(sb, usb1->fs_time));\n\t\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\t\tsb->s_flags |= MS_RDONLY;\n\t} else {\n\t/*\n\t * fs was mounted as ro, remounting rw\n\t */\n#ifndef CONFIG_UFS_FS_WRITE\n\t\tpr_err(\"ufs was compiled with read-only support, can't be mounted as read-write\\n\");\n\t\tunlock_ufs(sb);\n\t\treturn -EINVAL;\n#else\n\t\tif (ufstype != UFS_MOUNT_UFSTYPE_SUN && \n\t\t    ufstype != UFS_MOUNT_UFSTYPE_SUNOS &&\n\t\t    ufstype != UFS_MOUNT_UFSTYPE_44BSD &&\n\t\t    ufstype != UFS_MOUNT_UFSTYPE_SUNx86 &&\n\t\t    ufstype != UFS_MOUNT_UFSTYPE_UFS2) {\n\t\t\tpr_err(\"this ufstype is read-only supported\\n\");\n\t\t\tunlock_ufs(sb);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!ufs_read_cylinder_structures(sb)) {\n\t\t\tpr_err(\"failed during remounting\\n\");\n\t\t\tunlock_ufs(sb);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tsb->s_flags &= ~MS_RDONLY;\n#endif\n\t}\n\tUFS_SB(sb)->s_mount_opt = new_mount_opt;\n\tunlock_ufs(sb);\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_ufs",
          "args": [
            "sb"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_ufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "104-110",
          "snippet": "void unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed during remounting\\n\""
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_read_cylinder_structures",
          "args": [
            "sb"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_read_cylinder_structures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "517-596",
          "snippet": "static int ufs_read_cylinder_structures(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info *uspi = sbi->s_uspi;\n\tstruct ufs_buffer_head * ubh;\n\tunsigned char * base, * space;\n\tunsigned size, blks, i;\n\n\tUFSD(\"ENTER\\n\");\n\n\t/*\n\t * Read cs structures from (usually) first data block\n\t * on the device. \n\t */\n\tsize = uspi->s_cssize;\n\tblks = (size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\tbase = space = kmalloc(size, GFP_NOFS);\n\tif (!base)\n\t\tgoto failed; \n\tsbi->s_csp = (struct ufs_csum *)space;\n\tfor (i = 0; i < blks; i += uspi->s_fpb) {\n\t\tsize = uspi->s_bsize;\n\t\tif (i + uspi->s_fpb > blks)\n\t\t\tsize = (blks - i) * uspi->s_fsize;\n\n\t\tubh = ubh_bread(sb, uspi->s_csaddr + i, size);\n\t\t\n\t\tif (!ubh)\n\t\t\tgoto failed;\n\n\t\tubh_ubhcpymem (space, ubh, size);\n\n\t\tspace += size;\n\t\tubh_brelse (ubh);\n\t\tubh = NULL;\n\t}\n\n\t/*\n\t * Read cylinder group (we read only first fragment from block\n\t * at this time) and prepare internal data structures for cg caching.\n\t */\n\tif (!(sbi->s_ucg = kmalloc (sizeof(struct buffer_head *) * uspi->s_ncg, GFP_NOFS)))\n\t\tgoto failed;\n\tfor (i = 0; i < uspi->s_ncg; i++) \n\t\tsbi->s_ucg[i] = NULL;\n\tfor (i = 0; i < UFS_MAX_GROUP_LOADED; i++) {\n\t\tsbi->s_ucpi[i] = NULL;\n\t\tsbi->s_cgno[i] = UFS_CGNO_EMPTY;\n\t}\n\tfor (i = 0; i < uspi->s_ncg; i++) {\n\t\tUFSD(\"read cg %u\\n\", i);\n\t\tif (!(sbi->s_ucg[i] = sb_bread(sb, ufs_cgcmin(i))))\n\t\t\tgoto failed;\n\t\tif (!ufs_cg_chkmagic (sb, (struct ufs_cylinder_group *) sbi->s_ucg[i]->b_data))\n\t\t\tgoto failed;\n\n\t\tufs_print_cylinder_stuff(sb, (struct ufs_cylinder_group *) sbi->s_ucg[i]->b_data);\n\t}\n\tfor (i = 0; i < UFS_MAX_GROUP_LOADED; i++) {\n\t\tif (!(sbi->s_ucpi[i] = kmalloc (sizeof(struct ufs_cg_private_info), GFP_NOFS)))\n\t\t\tgoto failed;\n\t\tsbi->s_cgno[i] = UFS_CGNO_EMPTY;\n\t}\n\tsbi->s_cg_loaded = 0;\n\tUFSD(\"EXIT\\n\");\n\treturn 1;\n\nfailed:\n\tkfree (base);\n\tif (sbi->s_ucg) {\n\t\tfor (i = 0; i < uspi->s_ncg; i++)\n\t\t\tif (sbi->s_ucg[i])\n\t\t\t\tbrelse (sbi->s_ucg[i]);\n\t\tkfree (sbi->s_ucg);\n\t\tfor (i = 0; i < UFS_MAX_GROUP_LOADED; i++)\n\t\t\tkfree (sbi->s_ucpi[i]);\n\t}\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic int ufs_read_cylinder_structures(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info *uspi = sbi->s_uspi;\n\tstruct ufs_buffer_head * ubh;\n\tunsigned char * base, * space;\n\tunsigned size, blks, i;\n\n\tUFSD(\"ENTER\\n\");\n\n\t/*\n\t * Read cs structures from (usually) first data block\n\t * on the device. \n\t */\n\tsize = uspi->s_cssize;\n\tblks = (size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\tbase = space = kmalloc(size, GFP_NOFS);\n\tif (!base)\n\t\tgoto failed; \n\tsbi->s_csp = (struct ufs_csum *)space;\n\tfor (i = 0; i < blks; i += uspi->s_fpb) {\n\t\tsize = uspi->s_bsize;\n\t\tif (i + uspi->s_fpb > blks)\n\t\t\tsize = (blks - i) * uspi->s_fsize;\n\n\t\tubh = ubh_bread(sb, uspi->s_csaddr + i, size);\n\t\t\n\t\tif (!ubh)\n\t\t\tgoto failed;\n\n\t\tubh_ubhcpymem (space, ubh, size);\n\n\t\tspace += size;\n\t\tubh_brelse (ubh);\n\t\tubh = NULL;\n\t}\n\n\t/*\n\t * Read cylinder group (we read only first fragment from block\n\t * at this time) and prepare internal data structures for cg caching.\n\t */\n\tif (!(sbi->s_ucg = kmalloc (sizeof(struct buffer_head *) * uspi->s_ncg, GFP_NOFS)))\n\t\tgoto failed;\n\tfor (i = 0; i < uspi->s_ncg; i++) \n\t\tsbi->s_ucg[i] = NULL;\n\tfor (i = 0; i < UFS_MAX_GROUP_LOADED; i++) {\n\t\tsbi->s_ucpi[i] = NULL;\n\t\tsbi->s_cgno[i] = UFS_CGNO_EMPTY;\n\t}\n\tfor (i = 0; i < uspi->s_ncg; i++) {\n\t\tUFSD(\"read cg %u\\n\", i);\n\t\tif (!(sbi->s_ucg[i] = sb_bread(sb, ufs_cgcmin(i))))\n\t\t\tgoto failed;\n\t\tif (!ufs_cg_chkmagic (sb, (struct ufs_cylinder_group *) sbi->s_ucg[i]->b_data))\n\t\t\tgoto failed;\n\n\t\tufs_print_cylinder_stuff(sb, (struct ufs_cylinder_group *) sbi->s_ucg[i]->b_data);\n\t}\n\tfor (i = 0; i < UFS_MAX_GROUP_LOADED; i++) {\n\t\tif (!(sbi->s_ucpi[i] = kmalloc (sizeof(struct ufs_cg_private_info), GFP_NOFS)))\n\t\t\tgoto failed;\n\t\tsbi->s_cgno[i] = UFS_CGNO_EMPTY;\n\t}\n\tsbi->s_cg_loaded = 0;\n\tUFSD(\"EXIT\\n\");\n\treturn 1;\n\nfailed:\n\tkfree (base);\n\tif (sbi->s_ucg) {\n\t\tfor (i = 0; i < uspi->s_ncg; i++)\n\t\t\tif (sbi->s_ucg[i])\n\t\t\t\tbrelse (sbi->s_ucg[i]);\n\t\tkfree (sbi->s_ucg);\n\t\tfor (i = 0; i < UFS_MAX_GROUP_LOADED; i++)\n\t\t\tkfree (sbi->s_ucpi[i]);\n\t}\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"this ufstype is read-only supported\\n\""
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"ufs was compiled with read-only support, can't be mounted as read-write\\n\""
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_mark_buffer_dirty",
          "args": [
            "USPI_UBH(uspi)"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "92-99",
          "snippet": "void ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USPI_UBH",
          "args": [
            "uspi"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "USPI_UBH",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "26-29",
          "snippet": "static inline struct ufs_buffer_head *USPI_UBH(struct ufs_sb_private_info *spi)\n{\n\treturn &spi->s_ubh;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse (struct ufs_buffer_head *);",
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);",
            "extern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);",
            "extern void ubh_sync_block(struct ufs_buffer_head *);",
            "extern void ubh_bforget (struct ufs_buffer_head *);",
            "extern int  ubh_buffer_dirty (struct ufs_buffer_head *);",
            "extern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);",
            "extern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\nstatic inline struct ufs_buffer_head *USPI_UBH(struct ufs_sb_private_info *spi)\n{\n\treturn &spi->s_ubh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_set_fs_state",
          "args": [
            "sb",
            "usb1",
            "usb3",
            "UFS_FSOK - fs32_to_cpu(sb, usb1->fs_time)"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_set_fs_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "55-76",
          "snippet": "static inline void\nufs_set_fs_state(struct super_block *sb, struct ufs_super_block_first *usb1,\n\t\t struct ufs_super_block_third *usb3, s32 value)\n{\n\tswitch (UFS_SB(sb)->s_flags & UFS_ST_MASK) {\n\tcase UFS_ST_SUNOS:\n\t\tif (fs32_to_cpu(sb, usb3->fs_postblformat) == UFS_42POSTBLFMT) {\n\t\t\tusb1->fs_u0.fs_sun.fs_state = cpu_to_fs32(sb, value);\n\t\t\tbreak;\n\t\t}\n\t\t/* Fall Through to UFS_ST_SUN */\n\tcase UFS_ST_SUN:\n\t\tusb3->fs_un2.fs_sun.fs_state = cpu_to_fs32(sb, value);\n\t\tbreak;\n\tcase UFS_ST_SUNx86:\n\t\tusb1->fs_u1.fs_sunx86.fs_state = cpu_to_fs32(sb, value);\n\t\tbreak;\n\tcase UFS_ST_44BSD:\n\t\tusb3->fs_un2.fs_44.fs_state = cpu_to_fs32(sb, value);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline void\nufs_set_fs_state(struct super_block *sb, struct ufs_super_block_first *usb1,\n\t\t struct ufs_super_block_third *usb3, s32 value)\n{\n\tswitch (UFS_SB(sb)->s_flags & UFS_ST_MASK) {\n\tcase UFS_ST_SUNOS:\n\t\tif (fs32_to_cpu(sb, usb3->fs_postblformat) == UFS_42POSTBLFMT) {\n\t\t\tusb1->fs_u0.fs_sun.fs_state = cpu_to_fs32(sb, value);\n\t\t\tbreak;\n\t\t}\n\t\t/* Fall Through to UFS_ST_SUN */\n\tcase UFS_ST_SUN:\n\t\tusb3->fs_un2.fs_sun.fs_state = cpu_to_fs32(sb, value);\n\t\tbreak;\n\tcase UFS_ST_SUNx86:\n\t\tusb1->fs_u1.fs_sunx86.fs_state = cpu_to_fs32(sb, value);\n\t\tbreak;\n\tcase UFS_ST_44BSD:\n\t\tusb3->fs_un2.fs_44.fs_state = cpu_to_fs32(sb, value);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sb",
            "usb1->fs_time"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "43-50",
          "snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_fs32",
          "args": [
            "sb",
            "get_seconds()"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_fs32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "52-59",
          "snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_put_super_internal",
          "args": [
            "sb"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_put_super_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "647-687",
          "snippet": "static void ufs_put_super_internal(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info *uspi = sbi->s_uspi;\n\tstruct ufs_buffer_head * ubh;\n\tunsigned char * base, * space;\n\tunsigned blks, size, i;\n\n\t\n\tUFSD(\"ENTER\\n\");\n\n\tufs_put_cstotal(sb);\n\tsize = uspi->s_cssize;\n\tblks = (size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\tbase = space = (char*) sbi->s_csp;\n\tfor (i = 0; i < blks; i += uspi->s_fpb) {\n\t\tsize = uspi->s_bsize;\n\t\tif (i + uspi->s_fpb > blks)\n\t\t\tsize = (blks - i) * uspi->s_fsize;\n\n\t\tubh = ubh_bread(sb, uspi->s_csaddr + i, size);\n\n\t\tubh_memcpyubh (ubh, space, size);\n\t\tspace += size;\n\t\tubh_mark_buffer_uptodate (ubh, 1);\n\t\tubh_mark_buffer_dirty (ubh);\n\t\tubh_brelse (ubh);\n\t}\n\tfor (i = 0; i < sbi->s_cg_loaded; i++) {\n\t\tufs_put_cylinder (sb, i);\n\t\tkfree (sbi->s_ucpi[i]);\n\t}\n\tfor (; i < UFS_MAX_GROUP_LOADED; i++) \n\t\tkfree (sbi->s_ucpi[i]);\n\tfor (i = 0; i < uspi->s_ncg; i++) \n\t\tbrelse (sbi->s_ucg[i]);\n\tkfree (sbi->s_ucg);\n\tkfree (base);\n\n\tUFSD(\"EXIT\\n\");\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic void ufs_put_super_internal(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info *uspi = sbi->s_uspi;\n\tstruct ufs_buffer_head * ubh;\n\tunsigned char * base, * space;\n\tunsigned blks, size, i;\n\n\t\n\tUFSD(\"ENTER\\n\");\n\n\tufs_put_cstotal(sb);\n\tsize = uspi->s_cssize;\n\tblks = (size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\tbase = space = (char*) sbi->s_csp;\n\tfor (i = 0; i < blks; i += uspi->s_fpb) {\n\t\tsize = uspi->s_bsize;\n\t\tif (i + uspi->s_fpb > blks)\n\t\t\tsize = (blks - i) * uspi->s_fsize;\n\n\t\tubh = ubh_bread(sb, uspi->s_csaddr + i, size);\n\n\t\tubh_memcpyubh (ubh, space, size);\n\t\tspace += size;\n\t\tubh_mark_buffer_uptodate (ubh, 1);\n\t\tubh_mark_buffer_dirty (ubh);\n\t\tubh_brelse (ubh);\n\t}\n\tfor (i = 0; i < sbi->s_cg_loaded; i++) {\n\t\tufs_put_cylinder (sb, i);\n\t\tkfree (sbi->s_ucpi[i]);\n\t}\n\tfor (; i < UFS_MAX_GROUP_LOADED; i++) \n\t\tkfree (sbi->s_ucpi[i]);\n\tfor (i = 0; i < uspi->s_ncg; i++) \n\t\tbrelse (sbi->s_ucg[i]);\n\tkfree (sbi->s_ucg);\n\tkfree (base);\n\n\tUFSD(\"EXIT\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"ufstype can't be changed during remount\\n\""
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_parse_options",
          "args": [
            "data",
            "&new_mount_opt"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "396-476",
          "snippet": "static int ufs_parse_options (char * options, unsigned * mount_options)\n{\n\tchar * p;\n\t\n\tUFSD(\"ENTER\\n\");\n\t\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_type_old:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_OLD);\n\t\t\tbreak;\n\t\tcase Opt_type_sunx86:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_SUNx86);\n\t\t\tbreak;\n\t\tcase Opt_type_sun:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_SUN);\n\t\t\tbreak;\n\t\tcase Opt_type_sunos:\n\t\t\tufs_clear_opt(*mount_options, UFSTYPE);\n\t\t\tufs_set_opt(*mount_options, UFSTYPE_SUNOS);\n\t\t\tbreak;\n\t\tcase Opt_type_44bsd:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_44BSD);\n\t\t\tbreak;\n\t\tcase Opt_type_ufs2:\n\t\t\tufs_clear_opt(*mount_options, UFSTYPE);\n\t\t\tufs_set_opt(*mount_options, UFSTYPE_UFS2);\n\t\t\tbreak;\n\t\tcase Opt_type_hp:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_HP);\n\t\t\tbreak;\n\t\tcase Opt_type_nextstepcd:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_NEXTSTEP_CD);\n\t\t\tbreak;\n\t\tcase Opt_type_nextstep:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_NEXTSTEP);\n\t\t\tbreak;\n\t\tcase Opt_type_openstep:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_OPENSTEP);\n\t\t\tbreak;\n\t\tcase Opt_onerror_panic:\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_onerror_lock:\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_LOCK);\n\t\t\tbreak;\n\t\tcase Opt_onerror_umount:\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_UMOUNT);\n\t\t\tbreak;\n\t\tcase Opt_onerror_repair:\n\t\t\tpr_err(\"Unable to do repair on error, will lock lock instead\\n\");\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_REPAIR);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Invalid option: \\\"%s\\\" or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_type_old, \"ufstype=old\"},\n\t{Opt_type_sunx86, \"ufstype=sunx86\"},\n\t{Opt_type_sun, \"ufstype=sun\"},\n\t{Opt_type_sunos, \"ufstype=sunos\"},\n\t{Opt_type_44bsd, \"ufstype=44bsd\"},\n\t{Opt_type_ufs2, \"ufstype=ufs2\"},\n\t{Opt_type_ufs2, \"ufstype=5xbsd\"},\n\t{Opt_type_hp, \"ufstype=hp\"},\n\t{Opt_type_nextstepcd, \"ufstype=nextstep-cd\"},\n\t{Opt_type_nextstep, \"ufstype=nextstep\"},\n\t{Opt_type_openstep, \"ufstype=openstep\"},\n/*end of possible ufs types */\n\t{Opt_onerror_panic, \"onerror=panic\"},\n\t{Opt_onerror_lock, \"onerror=lock\"},\n\t{Opt_onerror_umount, \"onerror=umount\"},\n\t{Opt_onerror_repair, \"onerror=repair\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_type_old, \"ufstype=old\"},\n\t{Opt_type_sunx86, \"ufstype=sunx86\"},\n\t{Opt_type_sun, \"ufstype=sun\"},\n\t{Opt_type_sunos, \"ufstype=sunos\"},\n\t{Opt_type_44bsd, \"ufstype=44bsd\"},\n\t{Opt_type_ufs2, \"ufstype=ufs2\"},\n\t{Opt_type_ufs2, \"ufstype=5xbsd\"},\n\t{Opt_type_hp, \"ufstype=hp\"},\n\t{Opt_type_nextstepcd, \"ufstype=nextstep-cd\"},\n\t{Opt_type_nextstep, \"ufstype=nextstep\"},\n\t{Opt_type_openstep, \"ufstype=openstep\"},\n/*end of possible ufs types */\n\t{Opt_onerror_panic, \"onerror=panic\"},\n\t{Opt_onerror_lock, \"onerror=lock\"},\n\t{Opt_onerror_umount, \"onerror=umount\"},\n\t{Opt_onerror_repair, \"onerror=repair\"},\n\t{Opt_err, NULL}\n};\n\nstatic int ufs_parse_options (char * options, unsigned * mount_options)\n{\n\tchar * p;\n\t\n\tUFSD(\"ENTER\\n\");\n\t\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_type_old:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_OLD);\n\t\t\tbreak;\n\t\tcase Opt_type_sunx86:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_SUNx86);\n\t\t\tbreak;\n\t\tcase Opt_type_sun:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_SUN);\n\t\t\tbreak;\n\t\tcase Opt_type_sunos:\n\t\t\tufs_clear_opt(*mount_options, UFSTYPE);\n\t\t\tufs_set_opt(*mount_options, UFSTYPE_SUNOS);\n\t\t\tbreak;\n\t\tcase Opt_type_44bsd:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_44BSD);\n\t\t\tbreak;\n\t\tcase Opt_type_ufs2:\n\t\t\tufs_clear_opt(*mount_options, UFSTYPE);\n\t\t\tufs_set_opt(*mount_options, UFSTYPE_UFS2);\n\t\t\tbreak;\n\t\tcase Opt_type_hp:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_HP);\n\t\t\tbreak;\n\t\tcase Opt_type_nextstepcd:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_NEXTSTEP_CD);\n\t\t\tbreak;\n\t\tcase Opt_type_nextstep:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_NEXTSTEP);\n\t\t\tbreak;\n\t\tcase Opt_type_openstep:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_OPENSTEP);\n\t\t\tbreak;\n\t\tcase Opt_onerror_panic:\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_onerror_lock:\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_LOCK);\n\t\t\tbreak;\n\t\tcase Opt_onerror_umount:\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_UMOUNT);\n\t\t\tbreak;\n\t\tcase Opt_onerror_repair:\n\t\t\tpr_err(\"Unable to do repair on error, will lock lock instead\\n\");\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_REPAIR);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Invalid option: \\\"%s\\\" or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_set_opt",
          "args": [
            "new_mount_opt",
            "ONERROR_LOCK"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_get_usb_third",
          "args": [
            "uspi"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_get_usb_first",
          "args": [
            "uspi"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic int ufs_remount (struct super_block *sb, int *mount_flags, char *data)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct ufs_super_block_third * usb3;\n\tunsigned new_mount_opt, ufstype;\n\tunsigned flags;\n\n\tsync_filesystem(sb);\n\tlock_ufs(sb);\n\tuspi = UFS_SB(sb)->s_uspi;\n\tflags = UFS_SB(sb)->s_flags;\n\tusb1 = ubh_get_usb_first(uspi);\n\tusb3 = ubh_get_usb_third(uspi);\n\t\n\t/*\n\t * Allow the \"check\" option to be passed as a remount option.\n\t * It is not possible to change ufstype option during remount\n\t */\n\tufstype = UFS_SB(sb)->s_mount_opt & UFS_MOUNT_UFSTYPE;\n\tnew_mount_opt = 0;\n\tufs_set_opt (new_mount_opt, ONERROR_LOCK);\n\tif (!ufs_parse_options (data, &new_mount_opt)) {\n\t\tunlock_ufs(sb);\n\t\treturn -EINVAL;\n\t}\n\tif (!(new_mount_opt & UFS_MOUNT_UFSTYPE)) {\n\t\tnew_mount_opt |= ufstype;\n\t} else if ((new_mount_opt & UFS_MOUNT_UFSTYPE) != ufstype) {\n\t\tpr_err(\"ufstype can't be changed during remount\\n\");\n\t\tunlock_ufs(sb);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((*mount_flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY)) {\n\t\tUFS_SB(sb)->s_mount_opt = new_mount_opt;\n\t\tunlock_ufs(sb);\n\t\treturn 0;\n\t}\n\t\n\t/*\n\t * fs was mouted as rw, remounting ro\n\t */\n\tif (*mount_flags & MS_RDONLY) {\n\t\tufs_put_super_internal(sb);\n\t\tusb1->fs_time = cpu_to_fs32(sb, get_seconds());\n\t\tif ((flags & UFS_ST_MASK) == UFS_ST_SUN\n\t\t  || (flags & UFS_ST_MASK) == UFS_ST_SUNOS\n\t\t  || (flags & UFS_ST_MASK) == UFS_ST_SUNx86) \n\t\t\tufs_set_fs_state(sb, usb1, usb3,\n\t\t\t\tUFS_FSOK - fs32_to_cpu(sb, usb1->fs_time));\n\t\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\t\tsb->s_flags |= MS_RDONLY;\n\t} else {\n\t/*\n\t * fs was mounted as ro, remounting rw\n\t */\n#ifndef CONFIG_UFS_FS_WRITE\n\t\tpr_err(\"ufs was compiled with read-only support, can't be mounted as read-write\\n\");\n\t\tunlock_ufs(sb);\n\t\treturn -EINVAL;\n#else\n\t\tif (ufstype != UFS_MOUNT_UFSTYPE_SUN && \n\t\t    ufstype != UFS_MOUNT_UFSTYPE_SUNOS &&\n\t\t    ufstype != UFS_MOUNT_UFSTYPE_44BSD &&\n\t\t    ufstype != UFS_MOUNT_UFSTYPE_SUNx86 &&\n\t\t    ufstype != UFS_MOUNT_UFSTYPE_UFS2) {\n\t\t\tpr_err(\"this ufstype is read-only supported\\n\");\n\t\t\tunlock_ufs(sb);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!ufs_read_cylinder_structures(sb)) {\n\t\t\tpr_err(\"failed during remounting\\n\");\n\t\t\tunlock_ufs(sb);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tsb->s_flags &= ~MS_RDONLY;\n#endif\n\t}\n\tUFS_SB(sb)->s_mount_opt = new_mount_opt;\n\tunlock_ufs(sb);\n\treturn 0;\n}"
  },
  {
    "function_name": "ufs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "765-1268",
    "snippet": "static int ufs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct ufs_sb_info * sbi;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct ufs_super_block_second * usb2;\n\tstruct ufs_super_block_third * usb3;\n\tstruct ufs_buffer_head * ubh;\t\n\tstruct inode *inode;\n\tunsigned block_size, super_block_size;\n\tunsigned flags;\n\tunsigned super_block_offset;\n\tunsigned maxsymlen;\n\tint ret = -EINVAL;\n\n\tuspi = NULL;\n\tubh = NULL;\n\tflags = 0;\n\t\n\tUFSD(\"ENTER\\n\");\n\n#ifndef CONFIG_UFS_FS_WRITE\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tpr_err(\"ufs was compiled with read-only support, can't be mounted as read-write\\n\");\n\t\treturn -EROFS;\n\t}\n#endif\n\t\t\n\tsbi = kzalloc(sizeof(struct ufs_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\tgoto failed_nomem;\n\tsb->s_fs_info = sbi;\n\tsbi->sb = sb;\n\n\tUFSD(\"flag %u\\n\", (int)(sb->s_flags & MS_RDONLY));\n\t\n\tmutex_init(&sbi->mutex);\n\tspin_lock_init(&sbi->work_lock);\n\tINIT_DELAYED_WORK(&sbi->sync_work, delayed_sync_fs);\n\t/*\n\t * Set default mount options\n\t * Parse mount options\n\t */\n\tsbi->s_mount_opt = 0;\n\tufs_set_opt (sbi->s_mount_opt, ONERROR_LOCK);\n\tif (!ufs_parse_options ((char *) data, &sbi->s_mount_opt)) {\n\t\tpr_err(\"wrong mount options\\n\");\n\t\tgoto failed;\n\t}\n\tif (!(sbi->s_mount_opt & UFS_MOUNT_UFSTYPE)) {\n\t\tif (!silent)\n\t\t\tpr_err(\"You didn't specify the type of your ufs filesystem\\n\\n\"\n\t\t\t\"mount -t ufs -o ufstype=\"\n\t\t\t\"sun|sunx86|44bsd|ufs2|5xbsd|old|hp|nextstep|nextstep-cd|openstep ...\\n\\n\"\n\t\t\t\">>>WARNING<<< Wrong ufstype may corrupt your filesystem, \"\n\t\t\t\"default is ufstype=old\\n\");\n\t\tufs_set_opt (sbi->s_mount_opt, UFSTYPE_OLD);\n\t}\n\n\tuspi = kzalloc(sizeof(struct ufs_sb_private_info), GFP_KERNEL);\n\tsbi->s_uspi = uspi;\n\tif (!uspi)\n\t\tgoto failed;\n\tuspi->s_dirblksize = UFS_SECTOR_SIZE;\n\tsuper_block_offset=UFS_SBLOCK;\n\n\t/* Keep 2Gig file limit. Some UFS variants need to override \n\t   this but as I don't know which I'll let those in the know loosen\n\t   the rules */\n\tswitch (sbi->s_mount_opt & UFS_MOUNT_UFSTYPE) {\n\tcase UFS_MOUNT_UFSTYPE_44BSD:\n\t\tUFSD(\"ufstype=44bsd\\n\");\n\t\tuspi->s_fsize = block_size = 512;\n\t\tuspi->s_fmask = ~(512 - 1);\n\t\tuspi->s_fshift = 9;\n\t\tuspi->s_sbsize = super_block_size = 1536;\n\t\tuspi->s_sbbase = 0;\n\t\tflags |= UFS_DE_44BSD | UFS_UID_44BSD | UFS_ST_44BSD | UFS_CG_44BSD;\n\t\tbreak;\n\tcase UFS_MOUNT_UFSTYPE_UFS2:\n\t\tUFSD(\"ufstype=ufs2\\n\");\n\t\tsuper_block_offset=SBLOCK_UFS2;\n\t\tuspi->s_fsize = block_size = 512;\n\t\tuspi->s_fmask = ~(512 - 1);\n\t\tuspi->s_fshift = 9;\n\t\tuspi->s_sbsize = super_block_size = 1536;\n\t\tuspi->s_sbbase =  0;\n\t\tflags |= UFS_TYPE_UFS2 | UFS_DE_44BSD | UFS_UID_44BSD | UFS_ST_44BSD | UFS_CG_44BSD;\n\t\tbreak;\n\t\t\n\tcase UFS_MOUNT_UFSTYPE_SUN:\n\t\tUFSD(\"ufstype=sun\\n\");\n\t\tuspi->s_fsize = block_size = 1024;\n\t\tuspi->s_fmask = ~(1024 - 1);\n\t\tuspi->s_fshift = 10;\n\t\tuspi->s_sbsize = super_block_size = 2048;\n\t\tuspi->s_sbbase = 0;\n\t\tuspi->s_maxsymlinklen = 0; /* Not supported on disk */\n\t\tflags |= UFS_DE_OLD | UFS_UID_EFT | UFS_ST_SUN | UFS_CG_SUN;\n\t\tbreak;\n\n\tcase UFS_MOUNT_UFSTYPE_SUNOS:\n\t\tUFSD(\"ufstype=sunos\\n\");\n\t\tuspi->s_fsize = block_size = 1024;\n\t\tuspi->s_fmask = ~(1024 - 1);\n\t\tuspi->s_fshift = 10;\n\t\tuspi->s_sbsize = 2048;\n\t\tsuper_block_size = 2048;\n\t\tuspi->s_sbbase = 0;\n\t\tuspi->s_maxsymlinklen = 0; /* Not supported on disk */\n\t\tflags |= UFS_DE_OLD | UFS_UID_OLD | UFS_ST_SUNOS | UFS_CG_SUN;\n\t\tbreak;\n\n\tcase UFS_MOUNT_UFSTYPE_SUNx86:\n\t\tUFSD(\"ufstype=sunx86\\n\");\n\t\tuspi->s_fsize = block_size = 1024;\n\t\tuspi->s_fmask = ~(1024 - 1);\n\t\tuspi->s_fshift = 10;\n\t\tuspi->s_sbsize = super_block_size = 2048;\n\t\tuspi->s_sbbase = 0;\n\t\tuspi->s_maxsymlinklen = 0; /* Not supported on disk */\n\t\tflags |= UFS_DE_OLD | UFS_UID_EFT | UFS_ST_SUNx86 | UFS_CG_SUN;\n\t\tbreak;\n\n\tcase UFS_MOUNT_UFSTYPE_OLD:\n\t\tUFSD(\"ufstype=old\\n\");\n\t\tuspi->s_fsize = block_size = 1024;\n\t\tuspi->s_fmask = ~(1024 - 1);\n\t\tuspi->s_fshift = 10;\n\t\tuspi->s_sbsize = super_block_size = 2048;\n\t\tuspi->s_sbbase = 0;\n\t\tflags |= UFS_DE_OLD | UFS_UID_OLD | UFS_ST_OLD | UFS_CG_OLD;\n\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\tif (!silent)\n\t\t\t\tpr_info(\"ufstype=old is supported read-only\\n\");\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t}\n\t\tbreak;\n\t\n\tcase UFS_MOUNT_UFSTYPE_NEXTSTEP:\n\t\tUFSD(\"ufstype=nextstep\\n\");\n\t\tuspi->s_fsize = block_size = 1024;\n\t\tuspi->s_fmask = ~(1024 - 1);\n\t\tuspi->s_fshift = 10;\n\t\tuspi->s_sbsize = super_block_size = 2048;\n\t\tuspi->s_sbbase = 0;\n\t\tuspi->s_dirblksize = 1024;\n\t\tflags |= UFS_DE_OLD | UFS_UID_OLD | UFS_ST_OLD | UFS_CG_OLD;\n\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\tif (!silent)\n\t\t\t\tpr_info(\"ufstype=nextstep is supported read-only\\n\");\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t}\n\t\tbreak;\n\t\n\tcase UFS_MOUNT_UFSTYPE_NEXTSTEP_CD:\n\t\tUFSD(\"ufstype=nextstep-cd\\n\");\n\t\tuspi->s_fsize = block_size = 2048;\n\t\tuspi->s_fmask = ~(2048 - 1);\n\t\tuspi->s_fshift = 11;\n\t\tuspi->s_sbsize = super_block_size = 2048;\n\t\tuspi->s_sbbase = 0;\n\t\tuspi->s_dirblksize = 1024;\n\t\tflags |= UFS_DE_OLD | UFS_UID_OLD | UFS_ST_OLD | UFS_CG_OLD;\n\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\tif (!silent)\n\t\t\t\tpr_info(\"ufstype=nextstep-cd is supported read-only\\n\");\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t}\n\t\tbreak;\n\t\n\tcase UFS_MOUNT_UFSTYPE_OPENSTEP:\n\t\tUFSD(\"ufstype=openstep\\n\");\n\t\tuspi->s_fsize = block_size = 1024;\n\t\tuspi->s_fmask = ~(1024 - 1);\n\t\tuspi->s_fshift = 10;\n\t\tuspi->s_sbsize = super_block_size = 2048;\n\t\tuspi->s_sbbase = 0;\n\t\tuspi->s_dirblksize = 1024;\n\t\tflags |= UFS_DE_44BSD | UFS_UID_44BSD | UFS_ST_44BSD | UFS_CG_44BSD;\n\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\tif (!silent)\n\t\t\t\tpr_info(\"ufstype=openstep is supported read-only\\n\");\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t}\n\t\tbreak;\n\t\n\tcase UFS_MOUNT_UFSTYPE_HP:\n\t\tUFSD(\"ufstype=hp\\n\");\n\t\tuspi->s_fsize = block_size = 1024;\n\t\tuspi->s_fmask = ~(1024 - 1);\n\t\tuspi->s_fshift = 10;\n\t\tuspi->s_sbsize = super_block_size = 2048;\n\t\tuspi->s_sbbase = 0;\n\t\tflags |= UFS_DE_OLD | UFS_UID_OLD | UFS_ST_OLD | UFS_CG_OLD;\n\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\tif (!silent)\n\t\t\t\tpr_info(\"ufstype=hp is supported read-only\\n\");\n\t\t\tsb->s_flags |= MS_RDONLY;\n \t\t}\n \t\tbreak;\n\tdefault:\n\t\tif (!silent)\n\t\t\tpr_err(\"unknown ufstype\\n\");\n\t\tgoto failed;\n\t}\n\t\nagain:\t\n\tif (!sb_set_blocksize(sb, block_size)) {\n\t\tpr_err(\"failed to set blocksize\\n\");\n\t\tgoto failed;\n\t}\n\n\t/*\n\t * read ufs super block from device\n\t */\n\n\tubh = ubh_bread_uspi(uspi, sb, uspi->s_sbbase + super_block_offset/block_size, super_block_size);\n\t\n\tif (!ubh) \n            goto failed;\n\n\tusb1 = ubh_get_usb_first(uspi);\n\tusb2 = ubh_get_usb_second(uspi);\n\tusb3 = ubh_get_usb_third(uspi);\n\n\t/* Sort out mod used on SunOS 4.1.3 for fs_state */\n\tuspi->s_postblformat = fs32_to_cpu(sb, usb3->fs_postblformat);\n\tif (((flags & UFS_ST_MASK) == UFS_ST_SUNOS) &&\n\t    (uspi->s_postblformat != UFS_42POSTBLFMT)) {\n\t\tflags &= ~UFS_ST_MASK;\n\t\tflags |=  UFS_ST_SUN;\n\t}\n\n\t/*\n\t * Check ufs magic number\n\t */\n\tsbi->s_bytesex = BYTESEX_LE;\n\tswitch ((uspi->fs_magic = fs32_to_cpu(sb, usb3->fs_magic))) {\n\t\tcase UFS_MAGIC:\n\t\tcase UFS_MAGIC_BW:\n\t\tcase UFS2_MAGIC:\n\t\tcase UFS_MAGIC_LFN:\n\t        case UFS_MAGIC_FEA:\n\t        case UFS_MAGIC_4GB:\n\t\t\tgoto magic_found;\n\t}\n\tsbi->s_bytesex = BYTESEX_BE;\n\tswitch ((uspi->fs_magic = fs32_to_cpu(sb, usb3->fs_magic))) {\n\t\tcase UFS_MAGIC:\n\t\tcase UFS_MAGIC_BW:\n\t\tcase UFS2_MAGIC:\n\t\tcase UFS_MAGIC_LFN:\n\t        case UFS_MAGIC_FEA:\n\t        case UFS_MAGIC_4GB:\n\t\t\tgoto magic_found;\n\t}\n\n\tif ((((sbi->s_mount_opt & UFS_MOUNT_UFSTYPE) == UFS_MOUNT_UFSTYPE_NEXTSTEP) \n\t  || ((sbi->s_mount_opt & UFS_MOUNT_UFSTYPE) == UFS_MOUNT_UFSTYPE_NEXTSTEP_CD) \n\t  || ((sbi->s_mount_opt & UFS_MOUNT_UFSTYPE) == UFS_MOUNT_UFSTYPE_OPENSTEP)) \n\t  && uspi->s_sbbase < 256) {\n\t\tubh_brelse_uspi(uspi);\n\t\tubh = NULL;\n\t\tuspi->s_sbbase += 8;\n\t\tgoto again;\n\t}\n\tif (!silent)\n\t\tpr_err(\"%s(): bad magic number\\n\", __func__);\n\tgoto failed;\n\nmagic_found:\n\t/*\n\t * Check block and fragment sizes\n\t */\n\tuspi->s_bsize = fs32_to_cpu(sb, usb1->fs_bsize);\n\tuspi->s_fsize = fs32_to_cpu(sb, usb1->fs_fsize);\n\tuspi->s_sbsize = fs32_to_cpu(sb, usb1->fs_sbsize);\n\tuspi->s_fmask = fs32_to_cpu(sb, usb1->fs_fmask);\n\tuspi->s_fshift = fs32_to_cpu(sb, usb1->fs_fshift);\n\n\tif (!is_power_of_2(uspi->s_fsize)) {\n\t\tpr_err(\"%s(): fragment size %u is not a power of 2\\n\",\n\t\t       __func__, uspi->s_fsize);\n\t\tgoto failed;\n\t}\n\tif (uspi->s_fsize < 512) {\n\t\tpr_err(\"%s(): fragment size %u is too small\\n\",\n\t\t       __func__, uspi->s_fsize);\n\t\tgoto failed;\n\t}\n\tif (uspi->s_fsize > 4096) {\n\t\tpr_err(\"%s(): fragment size %u is too large\\n\",\n\t\t       __func__, uspi->s_fsize);\n\t\tgoto failed;\n\t}\n\tif (!is_power_of_2(uspi->s_bsize)) {\n\t\tpr_err(\"%s(): block size %u is not a power of 2\\n\",\n\t\t       __func__, uspi->s_bsize);\n\t\tgoto failed;\n\t}\n\tif (uspi->s_bsize < 4096) {\n\t\tpr_err(\"%s(): block size %u is too small\\n\",\n\t\t       __func__, uspi->s_bsize);\n\t\tgoto failed;\n\t}\n\tif (uspi->s_bsize / uspi->s_fsize > 8) {\n\t\tpr_err(\"%s(): too many fragments per block (%u)\\n\",\n\t\t       __func__, uspi->s_bsize / uspi->s_fsize);\n\t\tgoto failed;\n\t}\n\tif (uspi->s_fsize != block_size || uspi->s_sbsize != super_block_size) {\n\t\tubh_brelse_uspi(uspi);\n\t\tubh = NULL;\n\t\tblock_size = uspi->s_fsize;\n\t\tsuper_block_size = uspi->s_sbsize;\n\t\tUFSD(\"another value of block_size or super_block_size %u, %u\\n\", block_size, super_block_size);\n\t\tgoto again;\n\t}\n\n\tsbi->s_flags = flags;/*after that line some functions use s_flags*/\n\tufs_print_super_stuff(sb, usb1, usb2, usb3);\n\n\t/*\n\t * Check, if file system was correctly unmounted.\n\t * If not, make it read only.\n\t */\n\tif (((flags & UFS_ST_MASK) == UFS_ST_44BSD) ||\n\t  ((flags & UFS_ST_MASK) == UFS_ST_OLD) ||\n\t  (((flags & UFS_ST_MASK) == UFS_ST_SUN ||\n\t    (flags & UFS_ST_MASK) == UFS_ST_SUNOS ||\n\t  (flags & UFS_ST_MASK) == UFS_ST_SUNx86) &&\n\t  (ufs_get_fs_state(sb, usb1, usb3) == (UFS_FSOK - fs32_to_cpu(sb, usb1->fs_time))))) {\n\t\tswitch(usb1->fs_clean) {\n\t\tcase UFS_FSCLEAN:\n\t\t\tUFSD(\"fs is clean\\n\");\n\t\t\tbreak;\n\t\tcase UFS_FSSTABLE:\n\t\t\tUFSD(\"fs is stable\\n\");\n\t\t\tbreak;\n\t\tcase UFS_FSLOG:\n\t\t\tUFSD(\"fs is logging fs\\n\");\n\t\t\tbreak;\n\t\tcase UFS_FSOSF1:\n\t\t\tUFSD(\"fs is DEC OSF/1\\n\");\n\t\t\tbreak;\n\t\tcase UFS_FSACTIVE:\n\t\t\tpr_err(\"%s(): fs is active\\n\", __func__);\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t\tbreak;\n\t\tcase UFS_FSBAD:\n\t\t\tpr_err(\"%s(): fs is bad\\n\", __func__);\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"%s(): can't grok fs_clean 0x%x\\n\",\n\t\t\t       __func__, usb1->fs_clean);\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tpr_err(\"%s(): fs needs fsck\\n\", __func__);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\n\t/*\n\t * Read ufs_super_block into internal data structures\n\t */\n\tsb->s_op = &ufs_super_ops;\n\tsb->s_export_op = &ufs_export_ops;\n\n\tsb->s_magic = fs32_to_cpu(sb, usb3->fs_magic);\n\n\tuspi->s_sblkno = fs32_to_cpu(sb, usb1->fs_sblkno);\n\tuspi->s_cblkno = fs32_to_cpu(sb, usb1->fs_cblkno);\n\tuspi->s_iblkno = fs32_to_cpu(sb, usb1->fs_iblkno);\n\tuspi->s_dblkno = fs32_to_cpu(sb, usb1->fs_dblkno);\n\tuspi->s_cgoffset = fs32_to_cpu(sb, usb1->fs_cgoffset);\n\tuspi->s_cgmask = fs32_to_cpu(sb, usb1->fs_cgmask);\n\n\tif ((flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2) {\n\t\tuspi->s_u2_size  = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_size);\n\t\tuspi->s_u2_dsize = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_dsize);\n\t} else {\n\t\tuspi->s_size  =  fs32_to_cpu(sb, usb1->fs_size);\n\t\tuspi->s_dsize =  fs32_to_cpu(sb, usb1->fs_dsize);\n\t}\n\n\tuspi->s_ncg = fs32_to_cpu(sb, usb1->fs_ncg);\n\t/* s_bsize already set */\n\t/* s_fsize already set */\n\tuspi->s_fpb = fs32_to_cpu(sb, usb1->fs_frag);\n\tuspi->s_minfree = fs32_to_cpu(sb, usb1->fs_minfree);\n\tuspi->s_bmask = fs32_to_cpu(sb, usb1->fs_bmask);\n\tuspi->s_fmask = fs32_to_cpu(sb, usb1->fs_fmask);\n\tuspi->s_bshift = fs32_to_cpu(sb, usb1->fs_bshift);\n\tuspi->s_fshift = fs32_to_cpu(sb, usb1->fs_fshift);\n\tUFSD(\"uspi->s_bshift = %d,uspi->s_fshift = %d\", uspi->s_bshift,\n\t\tuspi->s_fshift);\n\tuspi->s_fpbshift = fs32_to_cpu(sb, usb1->fs_fragshift);\n\tuspi->s_fsbtodb = fs32_to_cpu(sb, usb1->fs_fsbtodb);\n\t/* s_sbsize already set */\n\tuspi->s_csmask = fs32_to_cpu(sb, usb1->fs_csmask);\n\tuspi->s_csshift = fs32_to_cpu(sb, usb1->fs_csshift);\n\tuspi->s_nindir = fs32_to_cpu(sb, usb1->fs_nindir);\n\tuspi->s_inopb = fs32_to_cpu(sb, usb1->fs_inopb);\n\tuspi->s_nspf = fs32_to_cpu(sb, usb1->fs_nspf);\n\tuspi->s_npsect = ufs_get_fs_npsect(sb, usb1, usb3);\n\tuspi->s_interleave = fs32_to_cpu(sb, usb1->fs_interleave);\n\tuspi->s_trackskew = fs32_to_cpu(sb, usb1->fs_trackskew);\n\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\tuspi->s_csaddr = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_csaddr);\n\telse\n\t\tuspi->s_csaddr = fs32_to_cpu(sb, usb1->fs_csaddr);\n\n\tuspi->s_cssize = fs32_to_cpu(sb, usb1->fs_cssize);\n\tuspi->s_cgsize = fs32_to_cpu(sb, usb1->fs_cgsize);\n\tuspi->s_ntrak = fs32_to_cpu(sb, usb1->fs_ntrak);\n\tuspi->s_nsect = fs32_to_cpu(sb, usb1->fs_nsect);\n\tuspi->s_spc = fs32_to_cpu(sb, usb1->fs_spc);\n\tuspi->s_ipg = fs32_to_cpu(sb, usb1->fs_ipg);\n\tuspi->s_fpg = fs32_to_cpu(sb, usb1->fs_fpg);\n\tuspi->s_cpc = fs32_to_cpu(sb, usb2->fs_un.fs_u1.fs_cpc);\n\tuspi->s_contigsumsize = fs32_to_cpu(sb, usb3->fs_un2.fs_44.fs_contigsumsize);\n\tuspi->s_qbmask = ufs_get_fs_qbmask(sb, usb3);\n\tuspi->s_qfmask = ufs_get_fs_qfmask(sb, usb3);\n\tuspi->s_nrpos = fs32_to_cpu(sb, usb3->fs_nrpos);\n\tuspi->s_postbloff = fs32_to_cpu(sb, usb3->fs_postbloff);\n\tuspi->s_rotbloff = fs32_to_cpu(sb, usb3->fs_rotbloff);\n\n\t/*\n\t * Compute another frequently used values\n\t */\n\tuspi->s_fpbmask = uspi->s_fpb - 1;\n\tif ((flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2)\n\t\tuspi->s_apbshift = uspi->s_bshift - 3;\n\telse\n\t\tuspi->s_apbshift = uspi->s_bshift - 2;\n\n\tuspi->s_2apbshift = uspi->s_apbshift * 2;\n\tuspi->s_3apbshift = uspi->s_apbshift * 3;\n\tuspi->s_apb = 1 << uspi->s_apbshift;\n\tuspi->s_2apb = 1 << uspi->s_2apbshift;\n\tuspi->s_3apb = 1 << uspi->s_3apbshift;\n\tuspi->s_apbmask = uspi->s_apb - 1;\n\tuspi->s_nspfshift = uspi->s_fshift - UFS_SECTOR_BITS;\n\tuspi->s_nspb = uspi->s_nspf << uspi->s_fpbshift;\n\tuspi->s_inopf = uspi->s_inopb >> uspi->s_fpbshift;\n\tuspi->s_bpf = uspi->s_fsize << 3;\n\tuspi->s_bpfshift = uspi->s_fshift + 3;\n\tuspi->s_bpfmask = uspi->s_bpf - 1;\n\tif ((sbi->s_mount_opt & UFS_MOUNT_UFSTYPE) == UFS_MOUNT_UFSTYPE_44BSD ||\n\t    (sbi->s_mount_opt & UFS_MOUNT_UFSTYPE) == UFS_MOUNT_UFSTYPE_UFS2)\n\t\tuspi->s_maxsymlinklen =\n\t\t    fs32_to_cpu(sb, usb3->fs_un2.fs_44.fs_maxsymlinklen);\n\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\tmaxsymlen = 2 * 4 * (UFS_NDADDR + UFS_NINDIR);\n\telse\n\t\tmaxsymlen = 4 * (UFS_NDADDR + UFS_NINDIR);\n\tif (uspi->s_maxsymlinklen > maxsymlen) {\n\t\tufs_warning(sb, __func__, \"ufs_read_super: excessive maximum \"\n\t\t\t    \"fast symlink size (%u)\\n\", uspi->s_maxsymlinklen);\n\t\tuspi->s_maxsymlinklen = maxsymlen;\n\t}\n\tsb->s_max_links = UFS_LINK_MAX;\n\n\tinode = ufs_iget(sb, UFS_ROOTINO);\n\tif (IS_ERR(inode)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto failed;\n\t}\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root) {\n\t\tret = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tufs_setup_cstotal(sb);\n\t/*\n\t * Read cylinder group structures\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tif (!ufs_read_cylinder_structures(sb))\n\t\t\tgoto failed;\n\n\tUFSD(\"EXIT\\n\");\n\treturn 0;\n\nfailed:\n\tmutex_destroy(&sbi->mutex);\n\tif (ubh)\n\t\tubh_brelse_uspi (uspi);\n\tkfree (uspi);\n\tkfree(sbi);\n\tsb->s_fs_info = NULL;\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn ret;\n\nfailed_nomem:\n\tUFSD(\"EXIT (NOMEM)\\n\");\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct export_operations ufs_export_ops = {\n\t.fh_to_dentry\t= ufs_fh_to_dentry,\n\t.fh_to_parent\t= ufs_fh_to_parent,\n\t.get_parent\t= ufs_get_parent,\n};",
      "static const struct super_operations ufs_super_ops;",
      "static const struct super_operations ufs_super_ops = {\n\t.alloc_inode\t= ufs_alloc_inode,\n\t.destroy_inode\t= ufs_destroy_inode,\n\t.write_inode\t= ufs_write_inode,\n\t.evict_inode\t= ufs_evict_inode,\n\t.put_super\t= ufs_put_super,\n\t.sync_fs\t= ufs_sync_fs,\n\t.statfs\t\t= ufs_statfs,\n\t.remount_fs\t= ufs_remount,\n\t.show_options   = ufs_show_options,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT (NOMEM)\\n\""
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT (FAILED)\\n\""
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "uspi"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_brelse_uspi",
          "args": [
            "uspi"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_brelse_uspi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "81-90",
          "snippet": "void ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&sbi->mutex"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT\\n\""
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_read_cylinder_structures",
          "args": [
            "sb"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_read_cylinder_structures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "517-596",
          "snippet": "static int ufs_read_cylinder_structures(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info *uspi = sbi->s_uspi;\n\tstruct ufs_buffer_head * ubh;\n\tunsigned char * base, * space;\n\tunsigned size, blks, i;\n\n\tUFSD(\"ENTER\\n\");\n\n\t/*\n\t * Read cs structures from (usually) first data block\n\t * on the device. \n\t */\n\tsize = uspi->s_cssize;\n\tblks = (size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\tbase = space = kmalloc(size, GFP_NOFS);\n\tif (!base)\n\t\tgoto failed; \n\tsbi->s_csp = (struct ufs_csum *)space;\n\tfor (i = 0; i < blks; i += uspi->s_fpb) {\n\t\tsize = uspi->s_bsize;\n\t\tif (i + uspi->s_fpb > blks)\n\t\t\tsize = (blks - i) * uspi->s_fsize;\n\n\t\tubh = ubh_bread(sb, uspi->s_csaddr + i, size);\n\t\t\n\t\tif (!ubh)\n\t\t\tgoto failed;\n\n\t\tubh_ubhcpymem (space, ubh, size);\n\n\t\tspace += size;\n\t\tubh_brelse (ubh);\n\t\tubh = NULL;\n\t}\n\n\t/*\n\t * Read cylinder group (we read only first fragment from block\n\t * at this time) and prepare internal data structures for cg caching.\n\t */\n\tif (!(sbi->s_ucg = kmalloc (sizeof(struct buffer_head *) * uspi->s_ncg, GFP_NOFS)))\n\t\tgoto failed;\n\tfor (i = 0; i < uspi->s_ncg; i++) \n\t\tsbi->s_ucg[i] = NULL;\n\tfor (i = 0; i < UFS_MAX_GROUP_LOADED; i++) {\n\t\tsbi->s_ucpi[i] = NULL;\n\t\tsbi->s_cgno[i] = UFS_CGNO_EMPTY;\n\t}\n\tfor (i = 0; i < uspi->s_ncg; i++) {\n\t\tUFSD(\"read cg %u\\n\", i);\n\t\tif (!(sbi->s_ucg[i] = sb_bread(sb, ufs_cgcmin(i))))\n\t\t\tgoto failed;\n\t\tif (!ufs_cg_chkmagic (sb, (struct ufs_cylinder_group *) sbi->s_ucg[i]->b_data))\n\t\t\tgoto failed;\n\n\t\tufs_print_cylinder_stuff(sb, (struct ufs_cylinder_group *) sbi->s_ucg[i]->b_data);\n\t}\n\tfor (i = 0; i < UFS_MAX_GROUP_LOADED; i++) {\n\t\tif (!(sbi->s_ucpi[i] = kmalloc (sizeof(struct ufs_cg_private_info), GFP_NOFS)))\n\t\t\tgoto failed;\n\t\tsbi->s_cgno[i] = UFS_CGNO_EMPTY;\n\t}\n\tsbi->s_cg_loaded = 0;\n\tUFSD(\"EXIT\\n\");\n\treturn 1;\n\nfailed:\n\tkfree (base);\n\tif (sbi->s_ucg) {\n\t\tfor (i = 0; i < uspi->s_ncg; i++)\n\t\t\tif (sbi->s_ucg[i])\n\t\t\t\tbrelse (sbi->s_ucg[i]);\n\t\tkfree (sbi->s_ucg);\n\t\tfor (i = 0; i < UFS_MAX_GROUP_LOADED; i++)\n\t\t\tkfree (sbi->s_ucpi[i]);\n\t}\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic int ufs_read_cylinder_structures(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info *uspi = sbi->s_uspi;\n\tstruct ufs_buffer_head * ubh;\n\tunsigned char * base, * space;\n\tunsigned size, blks, i;\n\n\tUFSD(\"ENTER\\n\");\n\n\t/*\n\t * Read cs structures from (usually) first data block\n\t * on the device. \n\t */\n\tsize = uspi->s_cssize;\n\tblks = (size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\tbase = space = kmalloc(size, GFP_NOFS);\n\tif (!base)\n\t\tgoto failed; \n\tsbi->s_csp = (struct ufs_csum *)space;\n\tfor (i = 0; i < blks; i += uspi->s_fpb) {\n\t\tsize = uspi->s_bsize;\n\t\tif (i + uspi->s_fpb > blks)\n\t\t\tsize = (blks - i) * uspi->s_fsize;\n\n\t\tubh = ubh_bread(sb, uspi->s_csaddr + i, size);\n\t\t\n\t\tif (!ubh)\n\t\t\tgoto failed;\n\n\t\tubh_ubhcpymem (space, ubh, size);\n\n\t\tspace += size;\n\t\tubh_brelse (ubh);\n\t\tubh = NULL;\n\t}\n\n\t/*\n\t * Read cylinder group (we read only first fragment from block\n\t * at this time) and prepare internal data structures for cg caching.\n\t */\n\tif (!(sbi->s_ucg = kmalloc (sizeof(struct buffer_head *) * uspi->s_ncg, GFP_NOFS)))\n\t\tgoto failed;\n\tfor (i = 0; i < uspi->s_ncg; i++) \n\t\tsbi->s_ucg[i] = NULL;\n\tfor (i = 0; i < UFS_MAX_GROUP_LOADED; i++) {\n\t\tsbi->s_ucpi[i] = NULL;\n\t\tsbi->s_cgno[i] = UFS_CGNO_EMPTY;\n\t}\n\tfor (i = 0; i < uspi->s_ncg; i++) {\n\t\tUFSD(\"read cg %u\\n\", i);\n\t\tif (!(sbi->s_ucg[i] = sb_bread(sb, ufs_cgcmin(i))))\n\t\t\tgoto failed;\n\t\tif (!ufs_cg_chkmagic (sb, (struct ufs_cylinder_group *) sbi->s_ucg[i]->b_data))\n\t\t\tgoto failed;\n\n\t\tufs_print_cylinder_stuff(sb, (struct ufs_cylinder_group *) sbi->s_ucg[i]->b_data);\n\t}\n\tfor (i = 0; i < UFS_MAX_GROUP_LOADED; i++) {\n\t\tif (!(sbi->s_ucpi[i] = kmalloc (sizeof(struct ufs_cg_private_info), GFP_NOFS)))\n\t\t\tgoto failed;\n\t\tsbi->s_cgno[i] = UFS_CGNO_EMPTY;\n\t}\n\tsbi->s_cg_loaded = 0;\n\tUFSD(\"EXIT\\n\");\n\treturn 1;\n\nfailed:\n\tkfree (base);\n\tif (sbi->s_ucg) {\n\t\tfor (i = 0; i < uspi->s_ncg; i++)\n\t\t\tif (sbi->s_ucg[i])\n\t\t\t\tbrelse (sbi->s_ucg[i]);\n\t\tkfree (sbi->s_ucg);\n\t\tfor (i = 0; i < UFS_MAX_GROUP_LOADED; i++)\n\t\t\tkfree (sbi->s_ucpi[i]);\n\t}\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_setup_cstotal",
          "args": [
            "sb"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_setup_cstotal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "483-512",
          "snippet": "static void ufs_setup_cstotal(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info *uspi = sbi->s_uspi;\n\tstruct ufs_super_block_first *usb1;\n\tstruct ufs_super_block_second *usb2;\n\tstruct ufs_super_block_third *usb3;\n\tunsigned mtype = sbi->s_mount_opt & UFS_MOUNT_UFSTYPE;\n\n\tUFSD(\"ENTER, mtype=%u\\n\", mtype);\n\tusb1 = ubh_get_usb_first(uspi);\n\tusb2 = ubh_get_usb_second(uspi);\n\tusb3 = ubh_get_usb_third(uspi);\n\n\tif ((mtype == UFS_MOUNT_UFSTYPE_44BSD &&\n\t     (usb1->fs_flags & UFS_FLAGS_UPDATED)) ||\n\t    mtype == UFS_MOUNT_UFSTYPE_UFS2) {\n\t\t/*we have statistic in different place, then usual*/\n\t\tuspi->cs_total.cs_ndir = fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_ndir);\n\t\tuspi->cs_total.cs_nbfree = fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_nbfree);\n\t\tuspi->cs_total.cs_nifree = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nifree);\n\t\tuspi->cs_total.cs_nffree = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nffree);\n\t} else {\n\t\tuspi->cs_total.cs_ndir = fs32_to_cpu(sb, usb1->fs_cstotal.cs_ndir);\n\t\tuspi->cs_total.cs_nbfree = fs32_to_cpu(sb, usb1->fs_cstotal.cs_nbfree);\n\t\tuspi->cs_total.cs_nifree = fs32_to_cpu(sb, usb1->fs_cstotal.cs_nifree);\n\t\tuspi->cs_total.cs_nffree = fs32_to_cpu(sb, usb1->fs_cstotal.cs_nffree);\n\t}\n\tUFSD(\"EXIT\\n\");\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic void ufs_setup_cstotal(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info *uspi = sbi->s_uspi;\n\tstruct ufs_super_block_first *usb1;\n\tstruct ufs_super_block_second *usb2;\n\tstruct ufs_super_block_third *usb3;\n\tunsigned mtype = sbi->s_mount_opt & UFS_MOUNT_UFSTYPE;\n\n\tUFSD(\"ENTER, mtype=%u\\n\", mtype);\n\tusb1 = ubh_get_usb_first(uspi);\n\tusb2 = ubh_get_usb_second(uspi);\n\tusb3 = ubh_get_usb_third(uspi);\n\n\tif ((mtype == UFS_MOUNT_UFSTYPE_44BSD &&\n\t     (usb1->fs_flags & UFS_FLAGS_UPDATED)) ||\n\t    mtype == UFS_MOUNT_UFSTYPE_UFS2) {\n\t\t/*we have statistic in different place, then usual*/\n\t\tuspi->cs_total.cs_ndir = fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_ndir);\n\t\tuspi->cs_total.cs_nbfree = fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_nbfree);\n\t\tuspi->cs_total.cs_nifree = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nifree);\n\t\tuspi->cs_total.cs_nffree = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nffree);\n\t} else {\n\t\tuspi->cs_total.cs_ndir = fs32_to_cpu(sb, usb1->fs_cstotal.cs_ndir);\n\t\tuspi->cs_total.cs_nbfree = fs32_to_cpu(sb, usb1->fs_cstotal.cs_nbfree);\n\t\tuspi->cs_total.cs_nifree = fs32_to_cpu(sb, usb1->fs_cstotal.cs_nifree);\n\t\tuspi->cs_total.cs_nffree = fs32_to_cpu(sb, usb1->fs_cstotal.cs_nffree);\n\t}\n\tUFSD(\"EXIT\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "inode"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_iget",
          "args": [
            "sb",
            "UFS_ROOTINO"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
          "lines": "682-743",
          "snippet": "struct inode *ufs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ufs_inode_info *ufsi;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct buffer_head * bh;\n\tstruct inode *inode;\n\tint err;\n\n\tUFSD(\"ENTER, ino %lu\\n\", ino);\n\n\tif (ino < UFS_ROOTINO || ino > (uspi->s_ncg * uspi->s_ipg)) {\n\t\tufs_warning(sb, \"ufs_read_inode\", \"bad inode number (%lu)\\n\",\n\t\t\t    ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tufsi = UFS_I(inode);\n\n\tbh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));\n\tif (!bh) {\n\t\tufs_warning(sb, \"ufs_read_inode\", \"unable to read inode %lu\\n\",\n\t\t\t    inode->i_ino);\n\t\tgoto bad_inode;\n\t}\n\tif ((UFS_SB(sb)->s_flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2) {\n\t\tstruct ufs2_inode *ufs2_inode = (struct ufs2_inode *)bh->b_data;\n\n\t\terr = ufs2_read_inode(inode,\n\t\t\t\t      ufs2_inode + ufs_inotofsbo(inode->i_ino));\n\t} else {\n\t\tstruct ufs_inode *ufs_inode = (struct ufs_inode *)bh->b_data;\n\n\t\terr = ufs1_read_inode(inode,\n\t\t\t\t      ufs_inode + ufs_inotofsbo(inode->i_ino));\n\t}\n\n\tif (err)\n\t\tgoto bad_inode;\n\tinode->i_version++;\n\tufsi->i_lastfrag =\n\t\t(inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\tufsi->i_dir_start_lookup = 0;\n\tufsi->i_osync = 0;\n\n\tufs_set_inode_ops(inode);\n\n\tbrelse(bh);\n\n\tUFSD(\"EXIT\\n\");\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstruct inode *ufs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ufs_inode_info *ufsi;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct buffer_head * bh;\n\tstruct inode *inode;\n\tint err;\n\n\tUFSD(\"ENTER, ino %lu\\n\", ino);\n\n\tif (ino < UFS_ROOTINO || ino > (uspi->s_ncg * uspi->s_ipg)) {\n\t\tufs_warning(sb, \"ufs_read_inode\", \"bad inode number (%lu)\\n\",\n\t\t\t    ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tufsi = UFS_I(inode);\n\n\tbh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));\n\tif (!bh) {\n\t\tufs_warning(sb, \"ufs_read_inode\", \"unable to read inode %lu\\n\",\n\t\t\t    inode->i_ino);\n\t\tgoto bad_inode;\n\t}\n\tif ((UFS_SB(sb)->s_flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2) {\n\t\tstruct ufs2_inode *ufs2_inode = (struct ufs2_inode *)bh->b_data;\n\n\t\terr = ufs2_read_inode(inode,\n\t\t\t\t      ufs2_inode + ufs_inotofsbo(inode->i_ino));\n\t} else {\n\t\tstruct ufs_inode *ufs_inode = (struct ufs_inode *)bh->b_data;\n\n\t\terr = ufs1_read_inode(inode,\n\t\t\t\t      ufs_inode + ufs_inotofsbo(inode->i_ino));\n\t}\n\n\tif (err)\n\t\tgoto bad_inode;\n\tinode->i_version++;\n\tufsi->i_lastfrag =\n\t\t(inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\tufsi->i_dir_start_lookup = 0;\n\tufsi->i_osync = 0;\n\n\tufs_set_inode_ops(inode);\n\n\tbrelse(bh);\n\n\tUFSD(\"EXIT\\n\");\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_warning",
          "args": [
            "sb",
            "__func__",
            "\"ufs_read_super: excessive maximum \"\n\t\t\t    \"fast symlink size (%u)\\n\"",
            "uspi->s_maxsymlinklen"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "344-356",
          "snippet": "void ufs_warning (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_warning (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sb",
            "usb3->fs_un2.fs_44.fs_maxsymlinklen"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "43-50",
          "snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_get_fs_qfmask",
          "args": [
            "sb",
            "usb3"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_get_fs_qfmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "112-134",
          "snippet": "static inline u64\nufs_get_fs_qfmask(struct super_block *sb, struct ufs_super_block_third *usb3)\n{\n\t__fs64 tmp;\n\n\tswitch (UFS_SB(sb)->s_flags & UFS_ST_MASK) {\n\tcase UFS_ST_SUNOS:\n\tcase UFS_ST_SUN:\n\t\t((__fs32 *)&tmp)[0] = usb3->fs_un2.fs_sun.fs_qfmask[0];\n\t\t((__fs32 *)&tmp)[1] = usb3->fs_un2.fs_sun.fs_qfmask[1];\n\t\tbreak;\n\tcase UFS_ST_SUNx86:\n\t\t((__fs32 *)&tmp)[0] = usb3->fs_un2.fs_sunx86.fs_qfmask[0];\n\t\t((__fs32 *)&tmp)[1] = usb3->fs_un2.fs_sunx86.fs_qfmask[1];\n\t\tbreak;\n\tcase UFS_ST_44BSD:\n\t\t((__fs32 *)&tmp)[0] = usb3->fs_un2.fs_44.fs_qfmask[0];\n\t\t((__fs32 *)&tmp)[1] = usb3->fs_un2.fs_44.fs_qfmask[1];\n\t\tbreak;\n\t}\n\n\treturn fs64_to_cpu(sb, tmp);\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);",
            "extern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);\nextern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);\n\nstatic inline u64\nufs_get_fs_qfmask(struct super_block *sb, struct ufs_super_block_third *usb3)\n{\n\t__fs64 tmp;\n\n\tswitch (UFS_SB(sb)->s_flags & UFS_ST_MASK) {\n\tcase UFS_ST_SUNOS:\n\tcase UFS_ST_SUN:\n\t\t((__fs32 *)&tmp)[0] = usb3->fs_un2.fs_sun.fs_qfmask[0];\n\t\t((__fs32 *)&tmp)[1] = usb3->fs_un2.fs_sun.fs_qfmask[1];\n\t\tbreak;\n\tcase UFS_ST_SUNx86:\n\t\t((__fs32 *)&tmp)[0] = usb3->fs_un2.fs_sunx86.fs_qfmask[0];\n\t\t((__fs32 *)&tmp)[1] = usb3->fs_un2.fs_sunx86.fs_qfmask[1];\n\t\tbreak;\n\tcase UFS_ST_44BSD:\n\t\t((__fs32 *)&tmp)[0] = usb3->fs_un2.fs_44.fs_qfmask[0];\n\t\t((__fs32 *)&tmp)[1] = usb3->fs_un2.fs_44.fs_qfmask[1];\n\t\tbreak;\n\t}\n\n\treturn fs64_to_cpu(sb, tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_get_fs_qbmask",
          "args": [
            "sb",
            "usb3"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_get_fs_qbmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "88-110",
          "snippet": "static inline u64\nufs_get_fs_qbmask(struct super_block *sb, struct ufs_super_block_third *usb3)\n{\n\t__fs64 tmp;\n\n\tswitch (UFS_SB(sb)->s_flags & UFS_ST_MASK) {\n\tcase UFS_ST_SUNOS:\n\tcase UFS_ST_SUN:\n\t\t((__fs32 *)&tmp)[0] = usb3->fs_un2.fs_sun.fs_qbmask[0];\n\t\t((__fs32 *)&tmp)[1] = usb3->fs_un2.fs_sun.fs_qbmask[1];\n\t\tbreak;\n\tcase UFS_ST_SUNx86:\n\t\t((__fs32 *)&tmp)[0] = usb3->fs_un2.fs_sunx86.fs_qbmask[0];\n\t\t((__fs32 *)&tmp)[1] = usb3->fs_un2.fs_sunx86.fs_qbmask[1];\n\t\tbreak;\n\tcase UFS_ST_44BSD:\n\t\t((__fs32 *)&tmp)[0] = usb3->fs_un2.fs_44.fs_qbmask[0];\n\t\t((__fs32 *)&tmp)[1] = usb3->fs_un2.fs_44.fs_qbmask[1];\n\t\tbreak;\n\t}\n\n\treturn fs64_to_cpu(sb, tmp);\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);",
            "extern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);\nextern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);\n\nstatic inline u64\nufs_get_fs_qbmask(struct super_block *sb, struct ufs_super_block_third *usb3)\n{\n\t__fs64 tmp;\n\n\tswitch (UFS_SB(sb)->s_flags & UFS_ST_MASK) {\n\tcase UFS_ST_SUNOS:\n\tcase UFS_ST_SUN:\n\t\t((__fs32 *)&tmp)[0] = usb3->fs_un2.fs_sun.fs_qbmask[0];\n\t\t((__fs32 *)&tmp)[1] = usb3->fs_un2.fs_sun.fs_qbmask[1];\n\t\tbreak;\n\tcase UFS_ST_SUNx86:\n\t\t((__fs32 *)&tmp)[0] = usb3->fs_un2.fs_sunx86.fs_qbmask[0];\n\t\t((__fs32 *)&tmp)[1] = usb3->fs_un2.fs_sunx86.fs_qbmask[1];\n\t\tbreak;\n\tcase UFS_ST_44BSD:\n\t\t((__fs32 *)&tmp)[0] = usb3->fs_un2.fs_44.fs_qbmask[0];\n\t\t((__fs32 *)&tmp)[1] = usb3->fs_un2.fs_44.fs_qbmask[1];\n\t\tbreak;\n\t}\n\n\treturn fs64_to_cpu(sb, tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs64_to_cpu",
          "args": [
            "sb",
            "usb3->fs_un1.fs_u2.fs_csaddr"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "fs64_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "25-32",
          "snippet": "static inline u64\nfs64_to_cpu(struct super_block *sbp, __fs64 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64\nfs64_to_cpu(struct super_block *sbp, __fs64 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_get_fs_npsect",
          "args": [
            "sb",
            "usb1",
            "usb3"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_get_fs_npsect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "78-86",
          "snippet": "static inline u32\nufs_get_fs_npsect(struct super_block *sb, struct ufs_super_block_first *usb1,\n\t\t  struct ufs_super_block_third *usb3)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_ST_MASK) == UFS_ST_SUNx86)\n\t\treturn fs32_to_cpu(sb, usb3->fs_un2.fs_sunx86.fs_npsect);\n\telse\n\t\treturn fs32_to_cpu(sb, usb1->fs_u1.fs_sun.fs_npsect);\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline u32\nufs_get_fs_npsect(struct super_block *sb, struct ufs_super_block_first *usb1,\n\t\t  struct ufs_super_block_third *usb3)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_ST_MASK) == UFS_ST_SUNx86)\n\t\treturn fs32_to_cpu(sb, usb3->fs_un2.fs_sunx86.fs_npsect);\n\telse\n\t\treturn fs32_to_cpu(sb, usb1->fs_u1.fs_sun.fs_npsect);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"uspi->s_bshift = %d,uspi->s_fshift = %d\"",
            "uspi->s_bshift",
            "uspi->s_fshift"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(): fs needs fsck\\n\"",
            "__func__"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(): can't grok fs_clean 0x%x\\n\"",
            "__func__",
            "usb1->fs_clean"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(): fs is bad\\n\"",
            "__func__"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(): fs is active\\n\"",
            "__func__"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"fs is DEC OSF/1\\n\""
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"fs is logging fs\\n\""
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"fs is stable\\n\""
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"fs is clean\\n\""
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_get_fs_state",
          "args": [
            "sb",
            "usb1",
            "usb3"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_get_fs_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "36-53",
          "snippet": "static inline s32\nufs_get_fs_state(struct super_block *sb, struct ufs_super_block_first *usb1,\n\t\t struct ufs_super_block_third *usb3)\n{\n\tswitch (UFS_SB(sb)->s_flags & UFS_ST_MASK) {\n\tcase UFS_ST_SUNOS:\n\t\tif (fs32_to_cpu(sb, usb3->fs_postblformat) == UFS_42POSTBLFMT)\n\t\t\treturn fs32_to_cpu(sb, usb1->fs_u0.fs_sun.fs_state);\n\t\t/* Fall Through to UFS_ST_SUN */\n\tcase UFS_ST_SUN:\n\t\treturn fs32_to_cpu(sb, usb3->fs_un2.fs_sun.fs_state);\n\tcase UFS_ST_SUNx86:\n\t\treturn fs32_to_cpu(sb, usb1->fs_u1.fs_sunx86.fs_state);\n\tcase UFS_ST_44BSD:\n\tdefault:\n\t\treturn fs32_to_cpu(sb, usb3->fs_un2.fs_44.fs_state);\n\t}\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline s32\nufs_get_fs_state(struct super_block *sb, struct ufs_super_block_first *usb1,\n\t\t struct ufs_super_block_third *usb3)\n{\n\tswitch (UFS_SB(sb)->s_flags & UFS_ST_MASK) {\n\tcase UFS_ST_SUNOS:\n\t\tif (fs32_to_cpu(sb, usb3->fs_postblformat) == UFS_42POSTBLFMT)\n\t\t\treturn fs32_to_cpu(sb, usb1->fs_u0.fs_sun.fs_state);\n\t\t/* Fall Through to UFS_ST_SUN */\n\tcase UFS_ST_SUN:\n\t\treturn fs32_to_cpu(sb, usb3->fs_un2.fs_sun.fs_state);\n\tcase UFS_ST_SUNx86:\n\t\treturn fs32_to_cpu(sb, usb1->fs_u1.fs_sunx86.fs_state);\n\tcase UFS_ST_44BSD:\n\tdefault:\n\t\treturn fs32_to_cpu(sb, usb3->fs_un2.fs_44.fs_state);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_print_super_stuff",
          "args": [
            "sb",
            "usb1",
            "usb2",
            "usb3"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_print_super_stuff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "163-237",
          "snippet": "static void ufs_print_super_stuff(struct super_block *sb,\n\t\t\t\t  struct ufs_super_block_first *usb1,\n\t\t\t\t  struct ufs_super_block_second *usb2,\n\t\t\t\t  struct ufs_super_block_third *usb3)\n{\n\tu32 magic = fs32_to_cpu(sb, usb3->fs_magic);\n\n\tpr_debug(\"ufs_print_super_stuff\\n\");\n\tpr_debug(\"  magic:     0x%x\\n\", magic);\n\tif (fs32_to_cpu(sb, usb3->fs_magic) == UFS2_MAGIC) {\n\t\tpr_debug(\"  fs_size:   %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_size));\n\t\tpr_debug(\"  fs_dsize:  %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_dsize));\n\t\tpr_debug(\"  bsize:         %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_bsize));\n\t\tpr_debug(\"  fsize:         %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_fsize));\n\t\tpr_debug(\"  fs_volname:  %s\\n\", usb2->fs_un.fs_u2.fs_volname);\n\t\tpr_debug(\"  fs_sblockloc: %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb2->fs_un.fs_u2.fs_sblockloc));\n\t\tpr_debug(\"  cs_ndir(No of dirs):  %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_ndir));\n\t\tpr_debug(\"  cs_nbfree(No of free blocks):  %llu\\n\",\n\t\t\t (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_nbfree));\n\t\tpr_info(\"  cs_nifree(Num of free inodes): %llu\\n\",\n\t\t\t(unsigned long long)\n\t\t\tfs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nifree));\n\t\tpr_info(\"  cs_nffree(Num of free frags): %llu\\n\",\n\t\t\t(unsigned long long)\n\t\t\tfs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nffree));\n\t\tpr_info(\"  fs_maxsymlinklen: %u\\n\",\n\t\t\tfs32_to_cpu(sb, usb3->fs_un2.fs_44.fs_maxsymlinklen));\n\t} else {\n\t\tpr_debug(\" sblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_sblkno));\n\t\tpr_debug(\" cblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_cblkno));\n\t\tpr_debug(\" iblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_iblkno));\n\t\tpr_debug(\" dblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_dblkno));\n\t\tpr_debug(\" cgoffset:    %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cgoffset));\n\t\tpr_debug(\" ~cgmask:     0x%x\\n\",\n\t\t\t ~fs32_to_cpu(sb, usb1->fs_cgmask));\n\t\tpr_debug(\" size:        %u\\n\", fs32_to_cpu(sb, usb1->fs_size));\n\t\tpr_debug(\" dsize:       %u\\n\", fs32_to_cpu(sb, usb1->fs_dsize));\n\t\tpr_debug(\" ncg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_ncg));\n\t\tpr_debug(\" bsize:       %u\\n\", fs32_to_cpu(sb, usb1->fs_bsize));\n\t\tpr_debug(\" fsize:       %u\\n\", fs32_to_cpu(sb, usb1->fs_fsize));\n\t\tpr_debug(\" frag:        %u\\n\", fs32_to_cpu(sb, usb1->fs_frag));\n\t\tpr_debug(\" fragshift:   %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_fragshift));\n\t\tpr_debug(\" ~fmask:      %u\\n\", ~fs32_to_cpu(sb, usb1->fs_fmask));\n\t\tpr_debug(\" fshift:      %u\\n\", fs32_to_cpu(sb, usb1->fs_fshift));\n\t\tpr_debug(\" sbsize:      %u\\n\", fs32_to_cpu(sb, usb1->fs_sbsize));\n\t\tpr_debug(\" spc:         %u\\n\", fs32_to_cpu(sb, usb1->fs_spc));\n\t\tpr_debug(\" cpg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_cpg));\n\t\tpr_debug(\" ipg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_ipg));\n\t\tpr_debug(\" fpg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_fpg));\n\t\tpr_debug(\" csaddr:      %u\\n\", fs32_to_cpu(sb, usb1->fs_csaddr));\n\t\tpr_debug(\" cssize:      %u\\n\", fs32_to_cpu(sb, usb1->fs_cssize));\n\t\tpr_debug(\" cgsize:      %u\\n\", fs32_to_cpu(sb, usb1->fs_cgsize));\n\t\tpr_debug(\" fstodb:      %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_fsbtodb));\n\t\tpr_debug(\" nrpos:       %u\\n\", fs32_to_cpu(sb, usb3->fs_nrpos));\n\t\tpr_debug(\" ndir         %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_ndir));\n\t\tpr_debug(\" nifree       %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_nifree));\n\t\tpr_debug(\" nbfree       %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_nbfree));\n\t\tpr_debug(\" nffree       %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_nffree));\n\t}\n\tpr_debug(\"\\n\");\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic void ufs_print_super_stuff(struct super_block *sb,\n\t\t\t\t  struct ufs_super_block_first *usb1,\n\t\t\t\t  struct ufs_super_block_second *usb2,\n\t\t\t\t  struct ufs_super_block_third *usb3)\n{\n\tu32 magic = fs32_to_cpu(sb, usb3->fs_magic);\n\n\tpr_debug(\"ufs_print_super_stuff\\n\");\n\tpr_debug(\"  magic:     0x%x\\n\", magic);\n\tif (fs32_to_cpu(sb, usb3->fs_magic) == UFS2_MAGIC) {\n\t\tpr_debug(\"  fs_size:   %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_size));\n\t\tpr_debug(\"  fs_dsize:  %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_dsize));\n\t\tpr_debug(\"  bsize:         %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_bsize));\n\t\tpr_debug(\"  fsize:         %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_fsize));\n\t\tpr_debug(\"  fs_volname:  %s\\n\", usb2->fs_un.fs_u2.fs_volname);\n\t\tpr_debug(\"  fs_sblockloc: %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb2->fs_un.fs_u2.fs_sblockloc));\n\t\tpr_debug(\"  cs_ndir(No of dirs):  %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_ndir));\n\t\tpr_debug(\"  cs_nbfree(No of free blocks):  %llu\\n\",\n\t\t\t (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_nbfree));\n\t\tpr_info(\"  cs_nifree(Num of free inodes): %llu\\n\",\n\t\t\t(unsigned long long)\n\t\t\tfs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nifree));\n\t\tpr_info(\"  cs_nffree(Num of free frags): %llu\\n\",\n\t\t\t(unsigned long long)\n\t\t\tfs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nffree));\n\t\tpr_info(\"  fs_maxsymlinklen: %u\\n\",\n\t\t\tfs32_to_cpu(sb, usb3->fs_un2.fs_44.fs_maxsymlinklen));\n\t} else {\n\t\tpr_debug(\" sblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_sblkno));\n\t\tpr_debug(\" cblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_cblkno));\n\t\tpr_debug(\" iblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_iblkno));\n\t\tpr_debug(\" dblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_dblkno));\n\t\tpr_debug(\" cgoffset:    %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cgoffset));\n\t\tpr_debug(\" ~cgmask:     0x%x\\n\",\n\t\t\t ~fs32_to_cpu(sb, usb1->fs_cgmask));\n\t\tpr_debug(\" size:        %u\\n\", fs32_to_cpu(sb, usb1->fs_size));\n\t\tpr_debug(\" dsize:       %u\\n\", fs32_to_cpu(sb, usb1->fs_dsize));\n\t\tpr_debug(\" ncg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_ncg));\n\t\tpr_debug(\" bsize:       %u\\n\", fs32_to_cpu(sb, usb1->fs_bsize));\n\t\tpr_debug(\" fsize:       %u\\n\", fs32_to_cpu(sb, usb1->fs_fsize));\n\t\tpr_debug(\" frag:        %u\\n\", fs32_to_cpu(sb, usb1->fs_frag));\n\t\tpr_debug(\" fragshift:   %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_fragshift));\n\t\tpr_debug(\" ~fmask:      %u\\n\", ~fs32_to_cpu(sb, usb1->fs_fmask));\n\t\tpr_debug(\" fshift:      %u\\n\", fs32_to_cpu(sb, usb1->fs_fshift));\n\t\tpr_debug(\" sbsize:      %u\\n\", fs32_to_cpu(sb, usb1->fs_sbsize));\n\t\tpr_debug(\" spc:         %u\\n\", fs32_to_cpu(sb, usb1->fs_spc));\n\t\tpr_debug(\" cpg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_cpg));\n\t\tpr_debug(\" ipg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_ipg));\n\t\tpr_debug(\" fpg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_fpg));\n\t\tpr_debug(\" csaddr:      %u\\n\", fs32_to_cpu(sb, usb1->fs_csaddr));\n\t\tpr_debug(\" cssize:      %u\\n\", fs32_to_cpu(sb, usb1->fs_cssize));\n\t\tpr_debug(\" cgsize:      %u\\n\", fs32_to_cpu(sb, usb1->fs_cgsize));\n\t\tpr_debug(\" fstodb:      %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_fsbtodb));\n\t\tpr_debug(\" nrpos:       %u\\n\", fs32_to_cpu(sb, usb3->fs_nrpos));\n\t\tpr_debug(\" ndir         %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_ndir));\n\t\tpr_debug(\" nifree       %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_nifree));\n\t\tpr_debug(\" nbfree       %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_nbfree));\n\t\tpr_debug(\" nffree       %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_nffree));\n\t}\n\tpr_debug(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"another value of block_size or super_block_size %u, %u\\n\"",
            "block_size",
            "super_block_size"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(): too many fragments per block (%u)\\n\"",
            "__func__",
            "uspi->s_bsize / uspi->s_fsize"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(): block size %u is too small\\n\"",
            "__func__",
            "uspi->s_bsize"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(): block size %u is not a power of 2\\n\"",
            "__func__",
            "uspi->s_bsize"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "uspi->s_bsize"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(): fragment size %u is too large\\n\"",
            "__func__",
            "uspi->s_fsize"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(): fragment size %u is too small\\n\"",
            "__func__",
            "uspi->s_fsize"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(): fragment size %u is not a power of 2\\n\"",
            "__func__",
            "uspi->s_fsize"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "uspi->s_fsize"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(): bad magic number\\n\"",
            "__func__"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_get_usb_third",
          "args": [
            "uspi"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_get_usb_second",
          "args": [
            "uspi"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_get_usb_first",
          "args": [
            "uspi"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_bread_uspi",
          "args": [
            "uspi",
            "sb",
            "uspi->s_sbbase + super_block_offset/block_size",
            "super_block_size"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_bread_uspi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "47-69",
          "snippet": "struct ufs_buffer_head * ubh_bread_uspi (struct ufs_sb_private_info * uspi,\n\tstruct super_block *sb, u64 fragment, u64 size)\n{\n\tunsigned i, j;\n\tu64 count = 0;\n\tif (size & ~uspi->s_fmask)\n\t\treturn NULL;\n\tcount = size >> uspi->s_fshift;\n\tif (count <= 0 || count > UFS_MAXFRAG)\n\t\treturn NULL;\n\tUSPI_UBH(uspi)->fragment = fragment;\n\tUSPI_UBH(uspi)->count = count;\n\tfor (i = 0; i < count; i++)\n\t\tif (!(USPI_UBH(uspi)->bh[i] = sb_bread(sb, fragment + i)))\n\t\t\tgoto failed;\n\tfor (; i < UFS_MAXFRAG; i++)\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\treturn USPI_UBH(uspi);\nfailed:\n\tfor (j = 0; j < i; j++)\n\t\tbrelse (USPI_UBH(uspi)->bh[j]);\n\treturn NULL;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct ufs_buffer_head * ubh_bread_uspi (struct ufs_sb_private_info * uspi,\n\tstruct super_block *sb, u64 fragment, u64 size)\n{\n\tunsigned i, j;\n\tu64 count = 0;\n\tif (size & ~uspi->s_fmask)\n\t\treturn NULL;\n\tcount = size >> uspi->s_fshift;\n\tif (count <= 0 || count > UFS_MAXFRAG)\n\t\treturn NULL;\n\tUSPI_UBH(uspi)->fragment = fragment;\n\tUSPI_UBH(uspi)->count = count;\n\tfor (i = 0; i < count; i++)\n\t\tif (!(USPI_UBH(uspi)->bh[i] = sb_bread(sb, fragment + i)))\n\t\t\tgoto failed;\n\tfor (; i < UFS_MAXFRAG; i++)\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\treturn USPI_UBH(uspi);\nfailed:\n\tfor (j = 0; j < i; j++)\n\t\tbrelse (USPI_UBH(uspi)->bh[j]);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to set blocksize\\n\""
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "sb",
            "block_size"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unknown ufstype\\n\""
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ufstype=hp is supported read-only\\n\""
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ufstype=hp\\n\""
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ufstype=openstep is supported read-only\\n\""
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ufstype=openstep\\n\""
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ufstype=nextstep-cd is supported read-only\\n\""
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ufstype=nextstep-cd\\n\""
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ufstype=nextstep is supported read-only\\n\""
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ufstype=nextstep\\n\""
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ufstype=old is supported read-only\\n\""
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ufstype=old\\n\""
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ufstype=sunx86\\n\""
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ufstype=sunos\\n\""
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ufstype=sun\\n\""
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ufstype=ufs2\\n\""
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ufstype=44bsd\\n\""
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ufs_sb_private_info)",
            "GFP_KERNEL"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_set_opt",
          "args": [
            "sbi->s_mount_opt",
            "UFSTYPE_OLD"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"You didn't specify the type of your ufs filesystem\\n\\n\"\n\t\t\t\"mount -t ufs -o ufstype=\"\n\t\t\t\"sun|sunx86|44bsd|ufs2|5xbsd|old|hp|nextstep|nextstep-cd|openstep ...\\n\\n\"\n\t\t\t\">>>WARNING<<< Wrong ufstype may corrupt your filesystem, \"\n\t\t\t\"default is ufstype=old\\n\""
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"wrong mount options\\n\""
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_parse_options",
          "args": [
            "(char *) data",
            "&sbi->s_mount_opt"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "396-476",
          "snippet": "static int ufs_parse_options (char * options, unsigned * mount_options)\n{\n\tchar * p;\n\t\n\tUFSD(\"ENTER\\n\");\n\t\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_type_old:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_OLD);\n\t\t\tbreak;\n\t\tcase Opt_type_sunx86:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_SUNx86);\n\t\t\tbreak;\n\t\tcase Opt_type_sun:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_SUN);\n\t\t\tbreak;\n\t\tcase Opt_type_sunos:\n\t\t\tufs_clear_opt(*mount_options, UFSTYPE);\n\t\t\tufs_set_opt(*mount_options, UFSTYPE_SUNOS);\n\t\t\tbreak;\n\t\tcase Opt_type_44bsd:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_44BSD);\n\t\t\tbreak;\n\t\tcase Opt_type_ufs2:\n\t\t\tufs_clear_opt(*mount_options, UFSTYPE);\n\t\t\tufs_set_opt(*mount_options, UFSTYPE_UFS2);\n\t\t\tbreak;\n\t\tcase Opt_type_hp:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_HP);\n\t\t\tbreak;\n\t\tcase Opt_type_nextstepcd:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_NEXTSTEP_CD);\n\t\t\tbreak;\n\t\tcase Opt_type_nextstep:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_NEXTSTEP);\n\t\t\tbreak;\n\t\tcase Opt_type_openstep:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_OPENSTEP);\n\t\t\tbreak;\n\t\tcase Opt_onerror_panic:\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_onerror_lock:\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_LOCK);\n\t\t\tbreak;\n\t\tcase Opt_onerror_umount:\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_UMOUNT);\n\t\t\tbreak;\n\t\tcase Opt_onerror_repair:\n\t\t\tpr_err(\"Unable to do repair on error, will lock lock instead\\n\");\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_REPAIR);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Invalid option: \\\"%s\\\" or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_type_old, \"ufstype=old\"},\n\t{Opt_type_sunx86, \"ufstype=sunx86\"},\n\t{Opt_type_sun, \"ufstype=sun\"},\n\t{Opt_type_sunos, \"ufstype=sunos\"},\n\t{Opt_type_44bsd, \"ufstype=44bsd\"},\n\t{Opt_type_ufs2, \"ufstype=ufs2\"},\n\t{Opt_type_ufs2, \"ufstype=5xbsd\"},\n\t{Opt_type_hp, \"ufstype=hp\"},\n\t{Opt_type_nextstepcd, \"ufstype=nextstep-cd\"},\n\t{Opt_type_nextstep, \"ufstype=nextstep\"},\n\t{Opt_type_openstep, \"ufstype=openstep\"},\n/*end of possible ufs types */\n\t{Opt_onerror_panic, \"onerror=panic\"},\n\t{Opt_onerror_lock, \"onerror=lock\"},\n\t{Opt_onerror_umount, \"onerror=umount\"},\n\t{Opt_onerror_repair, \"onerror=repair\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_type_old, \"ufstype=old\"},\n\t{Opt_type_sunx86, \"ufstype=sunx86\"},\n\t{Opt_type_sun, \"ufstype=sun\"},\n\t{Opt_type_sunos, \"ufstype=sunos\"},\n\t{Opt_type_44bsd, \"ufstype=44bsd\"},\n\t{Opt_type_ufs2, \"ufstype=ufs2\"},\n\t{Opt_type_ufs2, \"ufstype=5xbsd\"},\n\t{Opt_type_hp, \"ufstype=hp\"},\n\t{Opt_type_nextstepcd, \"ufstype=nextstep-cd\"},\n\t{Opt_type_nextstep, \"ufstype=nextstep\"},\n\t{Opt_type_openstep, \"ufstype=openstep\"},\n/*end of possible ufs types */\n\t{Opt_onerror_panic, \"onerror=panic\"},\n\t{Opt_onerror_lock, \"onerror=lock\"},\n\t{Opt_onerror_umount, \"onerror=umount\"},\n\t{Opt_onerror_repair, \"onerror=repair\"},\n\t{Opt_err, NULL}\n};\n\nstatic int ufs_parse_options (char * options, unsigned * mount_options)\n{\n\tchar * p;\n\t\n\tUFSD(\"ENTER\\n\");\n\t\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_type_old:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_OLD);\n\t\t\tbreak;\n\t\tcase Opt_type_sunx86:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_SUNx86);\n\t\t\tbreak;\n\t\tcase Opt_type_sun:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_SUN);\n\t\t\tbreak;\n\t\tcase Opt_type_sunos:\n\t\t\tufs_clear_opt(*mount_options, UFSTYPE);\n\t\t\tufs_set_opt(*mount_options, UFSTYPE_SUNOS);\n\t\t\tbreak;\n\t\tcase Opt_type_44bsd:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_44BSD);\n\t\t\tbreak;\n\t\tcase Opt_type_ufs2:\n\t\t\tufs_clear_opt(*mount_options, UFSTYPE);\n\t\t\tufs_set_opt(*mount_options, UFSTYPE_UFS2);\n\t\t\tbreak;\n\t\tcase Opt_type_hp:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_HP);\n\t\t\tbreak;\n\t\tcase Opt_type_nextstepcd:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_NEXTSTEP_CD);\n\t\t\tbreak;\n\t\tcase Opt_type_nextstep:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_NEXTSTEP);\n\t\t\tbreak;\n\t\tcase Opt_type_openstep:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_OPENSTEP);\n\t\t\tbreak;\n\t\tcase Opt_onerror_panic:\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_onerror_lock:\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_LOCK);\n\t\t\tbreak;\n\t\tcase Opt_onerror_umount:\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_UMOUNT);\n\t\t\tbreak;\n\t\tcase Opt_onerror_repair:\n\t\t\tpr_err(\"Unable to do repair on error, will lock lock instead\\n\");\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_REPAIR);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Invalid option: \\\"%s\\\" or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_set_opt",
          "args": [
            "sbi->s_mount_opt",
            "ONERROR_LOCK"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&sbi->sync_work",
            "delayed_sync_fs"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sbi->work_lock"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sbi->mutex"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"flag %u\\n\"",
            "(int)(sb->s_flags & MS_RDONLY)"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ufs_sb_info)",
            "GFP_KERNEL"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"ufs was compiled with read-only support, can't be mounted as read-write\\n\""
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER\\n\""
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic const struct export_operations ufs_export_ops = {\n\t.fh_to_dentry\t= ufs_fh_to_dentry,\n\t.fh_to_parent\t= ufs_fh_to_parent,\n\t.get_parent\t= ufs_get_parent,\n};\nstatic const struct super_operations ufs_super_ops;\nstatic const struct super_operations ufs_super_ops = {\n\t.alloc_inode\t= ufs_alloc_inode,\n\t.destroy_inode\t= ufs_destroy_inode,\n\t.write_inode\t= ufs_write_inode,\n\t.evict_inode\t= ufs_evict_inode,\n\t.put_super\t= ufs_put_super,\n\t.sync_fs\t= ufs_sync_fs,\n\t.statfs\t\t= ufs_statfs,\n\t.remount_fs\t= ufs_remount,\n\t.show_options   = ufs_show_options,\n};\n\nstatic int ufs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct ufs_sb_info * sbi;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct ufs_super_block_second * usb2;\n\tstruct ufs_super_block_third * usb3;\n\tstruct ufs_buffer_head * ubh;\t\n\tstruct inode *inode;\n\tunsigned block_size, super_block_size;\n\tunsigned flags;\n\tunsigned super_block_offset;\n\tunsigned maxsymlen;\n\tint ret = -EINVAL;\n\n\tuspi = NULL;\n\tubh = NULL;\n\tflags = 0;\n\t\n\tUFSD(\"ENTER\\n\");\n\n#ifndef CONFIG_UFS_FS_WRITE\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tpr_err(\"ufs was compiled with read-only support, can't be mounted as read-write\\n\");\n\t\treturn -EROFS;\n\t}\n#endif\n\t\t\n\tsbi = kzalloc(sizeof(struct ufs_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\tgoto failed_nomem;\n\tsb->s_fs_info = sbi;\n\tsbi->sb = sb;\n\n\tUFSD(\"flag %u\\n\", (int)(sb->s_flags & MS_RDONLY));\n\t\n\tmutex_init(&sbi->mutex);\n\tspin_lock_init(&sbi->work_lock);\n\tINIT_DELAYED_WORK(&sbi->sync_work, delayed_sync_fs);\n\t/*\n\t * Set default mount options\n\t * Parse mount options\n\t */\n\tsbi->s_mount_opt = 0;\n\tufs_set_opt (sbi->s_mount_opt, ONERROR_LOCK);\n\tif (!ufs_parse_options ((char *) data, &sbi->s_mount_opt)) {\n\t\tpr_err(\"wrong mount options\\n\");\n\t\tgoto failed;\n\t}\n\tif (!(sbi->s_mount_opt & UFS_MOUNT_UFSTYPE)) {\n\t\tif (!silent)\n\t\t\tpr_err(\"You didn't specify the type of your ufs filesystem\\n\\n\"\n\t\t\t\"mount -t ufs -o ufstype=\"\n\t\t\t\"sun|sunx86|44bsd|ufs2|5xbsd|old|hp|nextstep|nextstep-cd|openstep ...\\n\\n\"\n\t\t\t\">>>WARNING<<< Wrong ufstype may corrupt your filesystem, \"\n\t\t\t\"default is ufstype=old\\n\");\n\t\tufs_set_opt (sbi->s_mount_opt, UFSTYPE_OLD);\n\t}\n\n\tuspi = kzalloc(sizeof(struct ufs_sb_private_info), GFP_KERNEL);\n\tsbi->s_uspi = uspi;\n\tif (!uspi)\n\t\tgoto failed;\n\tuspi->s_dirblksize = UFS_SECTOR_SIZE;\n\tsuper_block_offset=UFS_SBLOCK;\n\n\t/* Keep 2Gig file limit. Some UFS variants need to override \n\t   this but as I don't know which I'll let those in the know loosen\n\t   the rules */\n\tswitch (sbi->s_mount_opt & UFS_MOUNT_UFSTYPE) {\n\tcase UFS_MOUNT_UFSTYPE_44BSD:\n\t\tUFSD(\"ufstype=44bsd\\n\");\n\t\tuspi->s_fsize = block_size = 512;\n\t\tuspi->s_fmask = ~(512 - 1);\n\t\tuspi->s_fshift = 9;\n\t\tuspi->s_sbsize = super_block_size = 1536;\n\t\tuspi->s_sbbase = 0;\n\t\tflags |= UFS_DE_44BSD | UFS_UID_44BSD | UFS_ST_44BSD | UFS_CG_44BSD;\n\t\tbreak;\n\tcase UFS_MOUNT_UFSTYPE_UFS2:\n\t\tUFSD(\"ufstype=ufs2\\n\");\n\t\tsuper_block_offset=SBLOCK_UFS2;\n\t\tuspi->s_fsize = block_size = 512;\n\t\tuspi->s_fmask = ~(512 - 1);\n\t\tuspi->s_fshift = 9;\n\t\tuspi->s_sbsize = super_block_size = 1536;\n\t\tuspi->s_sbbase =  0;\n\t\tflags |= UFS_TYPE_UFS2 | UFS_DE_44BSD | UFS_UID_44BSD | UFS_ST_44BSD | UFS_CG_44BSD;\n\t\tbreak;\n\t\t\n\tcase UFS_MOUNT_UFSTYPE_SUN:\n\t\tUFSD(\"ufstype=sun\\n\");\n\t\tuspi->s_fsize = block_size = 1024;\n\t\tuspi->s_fmask = ~(1024 - 1);\n\t\tuspi->s_fshift = 10;\n\t\tuspi->s_sbsize = super_block_size = 2048;\n\t\tuspi->s_sbbase = 0;\n\t\tuspi->s_maxsymlinklen = 0; /* Not supported on disk */\n\t\tflags |= UFS_DE_OLD | UFS_UID_EFT | UFS_ST_SUN | UFS_CG_SUN;\n\t\tbreak;\n\n\tcase UFS_MOUNT_UFSTYPE_SUNOS:\n\t\tUFSD(\"ufstype=sunos\\n\");\n\t\tuspi->s_fsize = block_size = 1024;\n\t\tuspi->s_fmask = ~(1024 - 1);\n\t\tuspi->s_fshift = 10;\n\t\tuspi->s_sbsize = 2048;\n\t\tsuper_block_size = 2048;\n\t\tuspi->s_sbbase = 0;\n\t\tuspi->s_maxsymlinklen = 0; /* Not supported on disk */\n\t\tflags |= UFS_DE_OLD | UFS_UID_OLD | UFS_ST_SUNOS | UFS_CG_SUN;\n\t\tbreak;\n\n\tcase UFS_MOUNT_UFSTYPE_SUNx86:\n\t\tUFSD(\"ufstype=sunx86\\n\");\n\t\tuspi->s_fsize = block_size = 1024;\n\t\tuspi->s_fmask = ~(1024 - 1);\n\t\tuspi->s_fshift = 10;\n\t\tuspi->s_sbsize = super_block_size = 2048;\n\t\tuspi->s_sbbase = 0;\n\t\tuspi->s_maxsymlinklen = 0; /* Not supported on disk */\n\t\tflags |= UFS_DE_OLD | UFS_UID_EFT | UFS_ST_SUNx86 | UFS_CG_SUN;\n\t\tbreak;\n\n\tcase UFS_MOUNT_UFSTYPE_OLD:\n\t\tUFSD(\"ufstype=old\\n\");\n\t\tuspi->s_fsize = block_size = 1024;\n\t\tuspi->s_fmask = ~(1024 - 1);\n\t\tuspi->s_fshift = 10;\n\t\tuspi->s_sbsize = super_block_size = 2048;\n\t\tuspi->s_sbbase = 0;\n\t\tflags |= UFS_DE_OLD | UFS_UID_OLD | UFS_ST_OLD | UFS_CG_OLD;\n\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\tif (!silent)\n\t\t\t\tpr_info(\"ufstype=old is supported read-only\\n\");\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t}\n\t\tbreak;\n\t\n\tcase UFS_MOUNT_UFSTYPE_NEXTSTEP:\n\t\tUFSD(\"ufstype=nextstep\\n\");\n\t\tuspi->s_fsize = block_size = 1024;\n\t\tuspi->s_fmask = ~(1024 - 1);\n\t\tuspi->s_fshift = 10;\n\t\tuspi->s_sbsize = super_block_size = 2048;\n\t\tuspi->s_sbbase = 0;\n\t\tuspi->s_dirblksize = 1024;\n\t\tflags |= UFS_DE_OLD | UFS_UID_OLD | UFS_ST_OLD | UFS_CG_OLD;\n\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\tif (!silent)\n\t\t\t\tpr_info(\"ufstype=nextstep is supported read-only\\n\");\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t}\n\t\tbreak;\n\t\n\tcase UFS_MOUNT_UFSTYPE_NEXTSTEP_CD:\n\t\tUFSD(\"ufstype=nextstep-cd\\n\");\n\t\tuspi->s_fsize = block_size = 2048;\n\t\tuspi->s_fmask = ~(2048 - 1);\n\t\tuspi->s_fshift = 11;\n\t\tuspi->s_sbsize = super_block_size = 2048;\n\t\tuspi->s_sbbase = 0;\n\t\tuspi->s_dirblksize = 1024;\n\t\tflags |= UFS_DE_OLD | UFS_UID_OLD | UFS_ST_OLD | UFS_CG_OLD;\n\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\tif (!silent)\n\t\t\t\tpr_info(\"ufstype=nextstep-cd is supported read-only\\n\");\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t}\n\t\tbreak;\n\t\n\tcase UFS_MOUNT_UFSTYPE_OPENSTEP:\n\t\tUFSD(\"ufstype=openstep\\n\");\n\t\tuspi->s_fsize = block_size = 1024;\n\t\tuspi->s_fmask = ~(1024 - 1);\n\t\tuspi->s_fshift = 10;\n\t\tuspi->s_sbsize = super_block_size = 2048;\n\t\tuspi->s_sbbase = 0;\n\t\tuspi->s_dirblksize = 1024;\n\t\tflags |= UFS_DE_44BSD | UFS_UID_44BSD | UFS_ST_44BSD | UFS_CG_44BSD;\n\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\tif (!silent)\n\t\t\t\tpr_info(\"ufstype=openstep is supported read-only\\n\");\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t}\n\t\tbreak;\n\t\n\tcase UFS_MOUNT_UFSTYPE_HP:\n\t\tUFSD(\"ufstype=hp\\n\");\n\t\tuspi->s_fsize = block_size = 1024;\n\t\tuspi->s_fmask = ~(1024 - 1);\n\t\tuspi->s_fshift = 10;\n\t\tuspi->s_sbsize = super_block_size = 2048;\n\t\tuspi->s_sbbase = 0;\n\t\tflags |= UFS_DE_OLD | UFS_UID_OLD | UFS_ST_OLD | UFS_CG_OLD;\n\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\tif (!silent)\n\t\t\t\tpr_info(\"ufstype=hp is supported read-only\\n\");\n\t\t\tsb->s_flags |= MS_RDONLY;\n \t\t}\n \t\tbreak;\n\tdefault:\n\t\tif (!silent)\n\t\t\tpr_err(\"unknown ufstype\\n\");\n\t\tgoto failed;\n\t}\n\t\nagain:\t\n\tif (!sb_set_blocksize(sb, block_size)) {\n\t\tpr_err(\"failed to set blocksize\\n\");\n\t\tgoto failed;\n\t}\n\n\t/*\n\t * read ufs super block from device\n\t */\n\n\tubh = ubh_bread_uspi(uspi, sb, uspi->s_sbbase + super_block_offset/block_size, super_block_size);\n\t\n\tif (!ubh) \n            goto failed;\n\n\tusb1 = ubh_get_usb_first(uspi);\n\tusb2 = ubh_get_usb_second(uspi);\n\tusb3 = ubh_get_usb_third(uspi);\n\n\t/* Sort out mod used on SunOS 4.1.3 for fs_state */\n\tuspi->s_postblformat = fs32_to_cpu(sb, usb3->fs_postblformat);\n\tif (((flags & UFS_ST_MASK) == UFS_ST_SUNOS) &&\n\t    (uspi->s_postblformat != UFS_42POSTBLFMT)) {\n\t\tflags &= ~UFS_ST_MASK;\n\t\tflags |=  UFS_ST_SUN;\n\t}\n\n\t/*\n\t * Check ufs magic number\n\t */\n\tsbi->s_bytesex = BYTESEX_LE;\n\tswitch ((uspi->fs_magic = fs32_to_cpu(sb, usb3->fs_magic))) {\n\t\tcase UFS_MAGIC:\n\t\tcase UFS_MAGIC_BW:\n\t\tcase UFS2_MAGIC:\n\t\tcase UFS_MAGIC_LFN:\n\t        case UFS_MAGIC_FEA:\n\t        case UFS_MAGIC_4GB:\n\t\t\tgoto magic_found;\n\t}\n\tsbi->s_bytesex = BYTESEX_BE;\n\tswitch ((uspi->fs_magic = fs32_to_cpu(sb, usb3->fs_magic))) {\n\t\tcase UFS_MAGIC:\n\t\tcase UFS_MAGIC_BW:\n\t\tcase UFS2_MAGIC:\n\t\tcase UFS_MAGIC_LFN:\n\t        case UFS_MAGIC_FEA:\n\t        case UFS_MAGIC_4GB:\n\t\t\tgoto magic_found;\n\t}\n\n\tif ((((sbi->s_mount_opt & UFS_MOUNT_UFSTYPE) == UFS_MOUNT_UFSTYPE_NEXTSTEP) \n\t  || ((sbi->s_mount_opt & UFS_MOUNT_UFSTYPE) == UFS_MOUNT_UFSTYPE_NEXTSTEP_CD) \n\t  || ((sbi->s_mount_opt & UFS_MOUNT_UFSTYPE) == UFS_MOUNT_UFSTYPE_OPENSTEP)) \n\t  && uspi->s_sbbase < 256) {\n\t\tubh_brelse_uspi(uspi);\n\t\tubh = NULL;\n\t\tuspi->s_sbbase += 8;\n\t\tgoto again;\n\t}\n\tif (!silent)\n\t\tpr_err(\"%s(): bad magic number\\n\", __func__);\n\tgoto failed;\n\nmagic_found:\n\t/*\n\t * Check block and fragment sizes\n\t */\n\tuspi->s_bsize = fs32_to_cpu(sb, usb1->fs_bsize);\n\tuspi->s_fsize = fs32_to_cpu(sb, usb1->fs_fsize);\n\tuspi->s_sbsize = fs32_to_cpu(sb, usb1->fs_sbsize);\n\tuspi->s_fmask = fs32_to_cpu(sb, usb1->fs_fmask);\n\tuspi->s_fshift = fs32_to_cpu(sb, usb1->fs_fshift);\n\n\tif (!is_power_of_2(uspi->s_fsize)) {\n\t\tpr_err(\"%s(): fragment size %u is not a power of 2\\n\",\n\t\t       __func__, uspi->s_fsize);\n\t\tgoto failed;\n\t}\n\tif (uspi->s_fsize < 512) {\n\t\tpr_err(\"%s(): fragment size %u is too small\\n\",\n\t\t       __func__, uspi->s_fsize);\n\t\tgoto failed;\n\t}\n\tif (uspi->s_fsize > 4096) {\n\t\tpr_err(\"%s(): fragment size %u is too large\\n\",\n\t\t       __func__, uspi->s_fsize);\n\t\tgoto failed;\n\t}\n\tif (!is_power_of_2(uspi->s_bsize)) {\n\t\tpr_err(\"%s(): block size %u is not a power of 2\\n\",\n\t\t       __func__, uspi->s_bsize);\n\t\tgoto failed;\n\t}\n\tif (uspi->s_bsize < 4096) {\n\t\tpr_err(\"%s(): block size %u is too small\\n\",\n\t\t       __func__, uspi->s_bsize);\n\t\tgoto failed;\n\t}\n\tif (uspi->s_bsize / uspi->s_fsize > 8) {\n\t\tpr_err(\"%s(): too many fragments per block (%u)\\n\",\n\t\t       __func__, uspi->s_bsize / uspi->s_fsize);\n\t\tgoto failed;\n\t}\n\tif (uspi->s_fsize != block_size || uspi->s_sbsize != super_block_size) {\n\t\tubh_brelse_uspi(uspi);\n\t\tubh = NULL;\n\t\tblock_size = uspi->s_fsize;\n\t\tsuper_block_size = uspi->s_sbsize;\n\t\tUFSD(\"another value of block_size or super_block_size %u, %u\\n\", block_size, super_block_size);\n\t\tgoto again;\n\t}\n\n\tsbi->s_flags = flags;/*after that line some functions use s_flags*/\n\tufs_print_super_stuff(sb, usb1, usb2, usb3);\n\n\t/*\n\t * Check, if file system was correctly unmounted.\n\t * If not, make it read only.\n\t */\n\tif (((flags & UFS_ST_MASK) == UFS_ST_44BSD) ||\n\t  ((flags & UFS_ST_MASK) == UFS_ST_OLD) ||\n\t  (((flags & UFS_ST_MASK) == UFS_ST_SUN ||\n\t    (flags & UFS_ST_MASK) == UFS_ST_SUNOS ||\n\t  (flags & UFS_ST_MASK) == UFS_ST_SUNx86) &&\n\t  (ufs_get_fs_state(sb, usb1, usb3) == (UFS_FSOK - fs32_to_cpu(sb, usb1->fs_time))))) {\n\t\tswitch(usb1->fs_clean) {\n\t\tcase UFS_FSCLEAN:\n\t\t\tUFSD(\"fs is clean\\n\");\n\t\t\tbreak;\n\t\tcase UFS_FSSTABLE:\n\t\t\tUFSD(\"fs is stable\\n\");\n\t\t\tbreak;\n\t\tcase UFS_FSLOG:\n\t\t\tUFSD(\"fs is logging fs\\n\");\n\t\t\tbreak;\n\t\tcase UFS_FSOSF1:\n\t\t\tUFSD(\"fs is DEC OSF/1\\n\");\n\t\t\tbreak;\n\t\tcase UFS_FSACTIVE:\n\t\t\tpr_err(\"%s(): fs is active\\n\", __func__);\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t\tbreak;\n\t\tcase UFS_FSBAD:\n\t\t\tpr_err(\"%s(): fs is bad\\n\", __func__);\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"%s(): can't grok fs_clean 0x%x\\n\",\n\t\t\t       __func__, usb1->fs_clean);\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tpr_err(\"%s(): fs needs fsck\\n\", __func__);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\n\t/*\n\t * Read ufs_super_block into internal data structures\n\t */\n\tsb->s_op = &ufs_super_ops;\n\tsb->s_export_op = &ufs_export_ops;\n\n\tsb->s_magic = fs32_to_cpu(sb, usb3->fs_magic);\n\n\tuspi->s_sblkno = fs32_to_cpu(sb, usb1->fs_sblkno);\n\tuspi->s_cblkno = fs32_to_cpu(sb, usb1->fs_cblkno);\n\tuspi->s_iblkno = fs32_to_cpu(sb, usb1->fs_iblkno);\n\tuspi->s_dblkno = fs32_to_cpu(sb, usb1->fs_dblkno);\n\tuspi->s_cgoffset = fs32_to_cpu(sb, usb1->fs_cgoffset);\n\tuspi->s_cgmask = fs32_to_cpu(sb, usb1->fs_cgmask);\n\n\tif ((flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2) {\n\t\tuspi->s_u2_size  = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_size);\n\t\tuspi->s_u2_dsize = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_dsize);\n\t} else {\n\t\tuspi->s_size  =  fs32_to_cpu(sb, usb1->fs_size);\n\t\tuspi->s_dsize =  fs32_to_cpu(sb, usb1->fs_dsize);\n\t}\n\n\tuspi->s_ncg = fs32_to_cpu(sb, usb1->fs_ncg);\n\t/* s_bsize already set */\n\t/* s_fsize already set */\n\tuspi->s_fpb = fs32_to_cpu(sb, usb1->fs_frag);\n\tuspi->s_minfree = fs32_to_cpu(sb, usb1->fs_minfree);\n\tuspi->s_bmask = fs32_to_cpu(sb, usb1->fs_bmask);\n\tuspi->s_fmask = fs32_to_cpu(sb, usb1->fs_fmask);\n\tuspi->s_bshift = fs32_to_cpu(sb, usb1->fs_bshift);\n\tuspi->s_fshift = fs32_to_cpu(sb, usb1->fs_fshift);\n\tUFSD(\"uspi->s_bshift = %d,uspi->s_fshift = %d\", uspi->s_bshift,\n\t\tuspi->s_fshift);\n\tuspi->s_fpbshift = fs32_to_cpu(sb, usb1->fs_fragshift);\n\tuspi->s_fsbtodb = fs32_to_cpu(sb, usb1->fs_fsbtodb);\n\t/* s_sbsize already set */\n\tuspi->s_csmask = fs32_to_cpu(sb, usb1->fs_csmask);\n\tuspi->s_csshift = fs32_to_cpu(sb, usb1->fs_csshift);\n\tuspi->s_nindir = fs32_to_cpu(sb, usb1->fs_nindir);\n\tuspi->s_inopb = fs32_to_cpu(sb, usb1->fs_inopb);\n\tuspi->s_nspf = fs32_to_cpu(sb, usb1->fs_nspf);\n\tuspi->s_npsect = ufs_get_fs_npsect(sb, usb1, usb3);\n\tuspi->s_interleave = fs32_to_cpu(sb, usb1->fs_interleave);\n\tuspi->s_trackskew = fs32_to_cpu(sb, usb1->fs_trackskew);\n\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\tuspi->s_csaddr = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_csaddr);\n\telse\n\t\tuspi->s_csaddr = fs32_to_cpu(sb, usb1->fs_csaddr);\n\n\tuspi->s_cssize = fs32_to_cpu(sb, usb1->fs_cssize);\n\tuspi->s_cgsize = fs32_to_cpu(sb, usb1->fs_cgsize);\n\tuspi->s_ntrak = fs32_to_cpu(sb, usb1->fs_ntrak);\n\tuspi->s_nsect = fs32_to_cpu(sb, usb1->fs_nsect);\n\tuspi->s_spc = fs32_to_cpu(sb, usb1->fs_spc);\n\tuspi->s_ipg = fs32_to_cpu(sb, usb1->fs_ipg);\n\tuspi->s_fpg = fs32_to_cpu(sb, usb1->fs_fpg);\n\tuspi->s_cpc = fs32_to_cpu(sb, usb2->fs_un.fs_u1.fs_cpc);\n\tuspi->s_contigsumsize = fs32_to_cpu(sb, usb3->fs_un2.fs_44.fs_contigsumsize);\n\tuspi->s_qbmask = ufs_get_fs_qbmask(sb, usb3);\n\tuspi->s_qfmask = ufs_get_fs_qfmask(sb, usb3);\n\tuspi->s_nrpos = fs32_to_cpu(sb, usb3->fs_nrpos);\n\tuspi->s_postbloff = fs32_to_cpu(sb, usb3->fs_postbloff);\n\tuspi->s_rotbloff = fs32_to_cpu(sb, usb3->fs_rotbloff);\n\n\t/*\n\t * Compute another frequently used values\n\t */\n\tuspi->s_fpbmask = uspi->s_fpb - 1;\n\tif ((flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2)\n\t\tuspi->s_apbshift = uspi->s_bshift - 3;\n\telse\n\t\tuspi->s_apbshift = uspi->s_bshift - 2;\n\n\tuspi->s_2apbshift = uspi->s_apbshift * 2;\n\tuspi->s_3apbshift = uspi->s_apbshift * 3;\n\tuspi->s_apb = 1 << uspi->s_apbshift;\n\tuspi->s_2apb = 1 << uspi->s_2apbshift;\n\tuspi->s_3apb = 1 << uspi->s_3apbshift;\n\tuspi->s_apbmask = uspi->s_apb - 1;\n\tuspi->s_nspfshift = uspi->s_fshift - UFS_SECTOR_BITS;\n\tuspi->s_nspb = uspi->s_nspf << uspi->s_fpbshift;\n\tuspi->s_inopf = uspi->s_inopb >> uspi->s_fpbshift;\n\tuspi->s_bpf = uspi->s_fsize << 3;\n\tuspi->s_bpfshift = uspi->s_fshift + 3;\n\tuspi->s_bpfmask = uspi->s_bpf - 1;\n\tif ((sbi->s_mount_opt & UFS_MOUNT_UFSTYPE) == UFS_MOUNT_UFSTYPE_44BSD ||\n\t    (sbi->s_mount_opt & UFS_MOUNT_UFSTYPE) == UFS_MOUNT_UFSTYPE_UFS2)\n\t\tuspi->s_maxsymlinklen =\n\t\t    fs32_to_cpu(sb, usb3->fs_un2.fs_44.fs_maxsymlinklen);\n\n\tif (uspi->fs_magic == UFS2_MAGIC)\n\t\tmaxsymlen = 2 * 4 * (UFS_NDADDR + UFS_NINDIR);\n\telse\n\t\tmaxsymlen = 4 * (UFS_NDADDR + UFS_NINDIR);\n\tif (uspi->s_maxsymlinklen > maxsymlen) {\n\t\tufs_warning(sb, __func__, \"ufs_read_super: excessive maximum \"\n\t\t\t    \"fast symlink size (%u)\\n\", uspi->s_maxsymlinklen);\n\t\tuspi->s_maxsymlinklen = maxsymlen;\n\t}\n\tsb->s_max_links = UFS_LINK_MAX;\n\n\tinode = ufs_iget(sb, UFS_ROOTINO);\n\tif (IS_ERR(inode)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto failed;\n\t}\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root) {\n\t\tret = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tufs_setup_cstotal(sb);\n\t/*\n\t * Read cylinder group structures\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tif (!ufs_read_cylinder_structures(sb))\n\t\t\tgoto failed;\n\n\tUFSD(\"EXIT\\n\");\n\treturn 0;\n\nfailed:\n\tmutex_destroy(&sbi->mutex);\n\tif (ubh)\n\t\tubh_brelse_uspi (uspi);\n\tkfree (uspi);\n\tkfree(sbi);\n\tsb->s_fs_info = NULL;\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn ret;\n\nfailed_nomem:\n\tUFSD(\"EXIT (NOMEM)\\n\");\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "ufs_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "746-763",
    "snippet": "static void ufs_put_super(struct super_block *sb)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\n\tUFSD(\"ENTER\\n\");\n\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tufs_put_super_internal(sb);\n\tcancel_delayed_work_sync(&sbi->sync_work);\n\n\tubh_brelse_uspi (sbi->s_uspi);\n\tkfree (sbi->s_uspi);\n\tmutex_destroy(&sbi->mutex);\n\tkfree (sbi);\n\tsb->s_fs_info = NULL;\n\tUFSD(\"EXIT\\n\");\n\treturn;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT\\n\""
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&sbi->mutex"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_uspi"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_brelse_uspi",
          "args": [
            "sbi->s_uspi"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_brelse_uspi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "81-90",
          "snippet": "void ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&sbi->sync_work"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_put_super_internal",
          "args": [
            "sb"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_put_super_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "647-687",
          "snippet": "static void ufs_put_super_internal(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info *uspi = sbi->s_uspi;\n\tstruct ufs_buffer_head * ubh;\n\tunsigned char * base, * space;\n\tunsigned blks, size, i;\n\n\t\n\tUFSD(\"ENTER\\n\");\n\n\tufs_put_cstotal(sb);\n\tsize = uspi->s_cssize;\n\tblks = (size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\tbase = space = (char*) sbi->s_csp;\n\tfor (i = 0; i < blks; i += uspi->s_fpb) {\n\t\tsize = uspi->s_bsize;\n\t\tif (i + uspi->s_fpb > blks)\n\t\t\tsize = (blks - i) * uspi->s_fsize;\n\n\t\tubh = ubh_bread(sb, uspi->s_csaddr + i, size);\n\n\t\tubh_memcpyubh (ubh, space, size);\n\t\tspace += size;\n\t\tubh_mark_buffer_uptodate (ubh, 1);\n\t\tubh_mark_buffer_dirty (ubh);\n\t\tubh_brelse (ubh);\n\t}\n\tfor (i = 0; i < sbi->s_cg_loaded; i++) {\n\t\tufs_put_cylinder (sb, i);\n\t\tkfree (sbi->s_ucpi[i]);\n\t}\n\tfor (; i < UFS_MAX_GROUP_LOADED; i++) \n\t\tkfree (sbi->s_ucpi[i]);\n\tfor (i = 0; i < uspi->s_ncg; i++) \n\t\tbrelse (sbi->s_ucg[i]);\n\tkfree (sbi->s_ucg);\n\tkfree (base);\n\n\tUFSD(\"EXIT\\n\");\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic void ufs_put_super_internal(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info *uspi = sbi->s_uspi;\n\tstruct ufs_buffer_head * ubh;\n\tunsigned char * base, * space;\n\tunsigned blks, size, i;\n\n\t\n\tUFSD(\"ENTER\\n\");\n\n\tufs_put_cstotal(sb);\n\tsize = uspi->s_cssize;\n\tblks = (size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\tbase = space = (char*) sbi->s_csp;\n\tfor (i = 0; i < blks; i += uspi->s_fpb) {\n\t\tsize = uspi->s_bsize;\n\t\tif (i + uspi->s_fpb > blks)\n\t\t\tsize = (blks - i) * uspi->s_fsize;\n\n\t\tubh = ubh_bread(sb, uspi->s_csaddr + i, size);\n\n\t\tubh_memcpyubh (ubh, space, size);\n\t\tspace += size;\n\t\tubh_mark_buffer_uptodate (ubh, 1);\n\t\tubh_mark_buffer_dirty (ubh);\n\t\tubh_brelse (ubh);\n\t}\n\tfor (i = 0; i < sbi->s_cg_loaded; i++) {\n\t\tufs_put_cylinder (sb, i);\n\t\tkfree (sbi->s_ucpi[i]);\n\t}\n\tfor (; i < UFS_MAX_GROUP_LOADED; i++) \n\t\tkfree (sbi->s_ucpi[i]);\n\tfor (i = 0; i < uspi->s_ncg; i++) \n\t\tbrelse (sbi->s_ucg[i]);\n\tkfree (sbi->s_ucg);\n\tkfree (base);\n\n\tUFSD(\"EXIT\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER\\n\""
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic void ufs_put_super(struct super_block *sb)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\n\tUFSD(\"ENTER\\n\");\n\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tufs_put_super_internal(sb);\n\tcancel_delayed_work_sync(&sbi->sync_work);\n\n\tubh_brelse_uspi (sbi->s_uspi);\n\tkfree (sbi->s_uspi);\n\tmutex_destroy(&sbi->mutex);\n\tkfree (sbi);\n\tsb->s_fs_info = NULL;\n\tUFSD(\"EXIT\\n\");\n\treturn;\n}"
  },
  {
    "function_name": "ufs_mark_sb_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "732-744",
    "snippet": "void ufs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tunsigned long delay;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->work_lock"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "system_long_wq",
            "&sbi->sync_work",
            "delay"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "dirty_writeback_interval * 10"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->work_lock"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tunsigned long delay;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}"
  },
  {
    "function_name": "delayed_sync_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "719-730",
    "snippet": "static void delayed_sync_fs(struct work_struct *work)\n{\n\tstruct ufs_sb_info *sbi;\n\n\tsbi = container_of(work, struct ufs_sb_info, sync_work.work);\n\n\tspin_lock(&sbi->work_lock);\n\tsbi->work_queued = 0;\n\tspin_unlock(&sbi->work_lock);\n\n\tufs_sync_fs(sbi->sb, 1);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ufs_sync_fs",
          "args": [
            "sbi->sb",
            "1"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_sync_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "689-717",
          "snippet": "static int ufs_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct ufs_super_block_third * usb3;\n\tunsigned flags;\n\n\tlock_ufs(sb);\n\n\tUFSD(\"ENTER\\n\");\n\n\tflags = UFS_SB(sb)->s_flags;\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\tusb3 = ubh_get_usb_third(uspi);\n\n\tusb1->fs_time = cpu_to_fs32(sb, get_seconds());\n\tif ((flags & UFS_ST_MASK) == UFS_ST_SUN  ||\n\t    (flags & UFS_ST_MASK) == UFS_ST_SUNOS ||\n\t    (flags & UFS_ST_MASK) == UFS_ST_SUNx86)\n\t\tufs_set_fs_state(sb, usb1, usb3,\n\t\t\t\tUFS_FSOK - fs32_to_cpu(sb, usb1->fs_time));\n\tufs_put_cstotal(sb);\n\n\tUFSD(\"EXIT\\n\");\n\tunlock_ufs(sb);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic int ufs_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct ufs_super_block_third * usb3;\n\tunsigned flags;\n\n\tlock_ufs(sb);\n\n\tUFSD(\"ENTER\\n\");\n\n\tflags = UFS_SB(sb)->s_flags;\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\tusb3 = ubh_get_usb_third(uspi);\n\n\tusb1->fs_time = cpu_to_fs32(sb, get_seconds());\n\tif ((flags & UFS_ST_MASK) == UFS_ST_SUN  ||\n\t    (flags & UFS_ST_MASK) == UFS_ST_SUNOS ||\n\t    (flags & UFS_ST_MASK) == UFS_ST_SUNx86)\n\t\tufs_set_fs_state(sb, usb1, usb3,\n\t\t\t\tUFS_FSOK - fs32_to_cpu(sb, usb1->fs_time));\n\tufs_put_cstotal(sb);\n\n\tUFSD(\"EXIT\\n\");\n\tunlock_ufs(sb);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->work_lock"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->work_lock"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structufs_sb_info",
            "sync_work.work"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic void delayed_sync_fs(struct work_struct *work)\n{\n\tstruct ufs_sb_info *sbi;\n\n\tsbi = container_of(work, struct ufs_sb_info, sync_work.work);\n\n\tspin_lock(&sbi->work_lock);\n\tsbi->work_queued = 0;\n\tspin_unlock(&sbi->work_lock);\n\n\tufs_sync_fs(sbi->sb, 1);\n}"
  },
  {
    "function_name": "ufs_sync_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "689-717",
    "snippet": "static int ufs_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct ufs_super_block_third * usb3;\n\tunsigned flags;\n\n\tlock_ufs(sb);\n\n\tUFSD(\"ENTER\\n\");\n\n\tflags = UFS_SB(sb)->s_flags;\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\tusb3 = ubh_get_usb_third(uspi);\n\n\tusb1->fs_time = cpu_to_fs32(sb, get_seconds());\n\tif ((flags & UFS_ST_MASK) == UFS_ST_SUN  ||\n\t    (flags & UFS_ST_MASK) == UFS_ST_SUNOS ||\n\t    (flags & UFS_ST_MASK) == UFS_ST_SUNx86)\n\t\tufs_set_fs_state(sb, usb1, usb3,\n\t\t\t\tUFS_FSOK - fs32_to_cpu(sb, usb1->fs_time));\n\tufs_put_cstotal(sb);\n\n\tUFSD(\"EXIT\\n\");\n\tunlock_ufs(sb);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_ufs",
          "args": [
            "sb"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_ufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "104-110",
          "snippet": "void unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT\\n\""
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_put_cstotal",
          "args": [
            "sb"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_put_cstotal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "601-639",
          "snippet": "static void ufs_put_cstotal(struct super_block *sb)\n{\n\tunsigned mtype = UFS_SB(sb)->s_mount_opt & UFS_MOUNT_UFSTYPE;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct ufs_super_block_first *usb1;\n\tstruct ufs_super_block_second *usb2;\n\tstruct ufs_super_block_third *usb3;\n\n\tUFSD(\"ENTER\\n\");\n\tusb1 = ubh_get_usb_first(uspi);\n\tusb2 = ubh_get_usb_second(uspi);\n\tusb3 = ubh_get_usb_third(uspi);\n\n\tif ((mtype == UFS_MOUNT_UFSTYPE_44BSD &&\n\t     (usb1->fs_flags & UFS_FLAGS_UPDATED)) ||\n\t    mtype == UFS_MOUNT_UFSTYPE_UFS2) {\n\t\t/*we have statistic in different place, then usual*/\n\t\tusb2->fs_un.fs_u2.cs_ndir =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_ndir);\n\t\tusb2->fs_un.fs_u2.cs_nbfree =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_nbfree);\n\t\tusb3->fs_un1.fs_u2.cs_nifree =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_nifree);\n\t\tusb3->fs_un1.fs_u2.cs_nffree =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_nffree);\n\t} else {\n\t\tusb1->fs_cstotal.cs_ndir =\n\t\t\tcpu_to_fs32(sb, uspi->cs_total.cs_ndir);\n\t\tusb1->fs_cstotal.cs_nbfree =\n\t\t\tcpu_to_fs32(sb, uspi->cs_total.cs_nbfree);\n\t\tusb1->fs_cstotal.cs_nifree =\n\t\t\tcpu_to_fs32(sb, uspi->cs_total.cs_nifree);\n\t\tusb1->fs_cstotal.cs_nffree =\n\t\t\tcpu_to_fs32(sb, uspi->cs_total.cs_nffree);\n\t}\n\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\tufs_print_super_stuff(sb, usb1, usb2, usb3);\n\tUFSD(\"EXIT\\n\");\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic void ufs_put_cstotal(struct super_block *sb)\n{\n\tunsigned mtype = UFS_SB(sb)->s_mount_opt & UFS_MOUNT_UFSTYPE;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct ufs_super_block_first *usb1;\n\tstruct ufs_super_block_second *usb2;\n\tstruct ufs_super_block_third *usb3;\n\n\tUFSD(\"ENTER\\n\");\n\tusb1 = ubh_get_usb_first(uspi);\n\tusb2 = ubh_get_usb_second(uspi);\n\tusb3 = ubh_get_usb_third(uspi);\n\n\tif ((mtype == UFS_MOUNT_UFSTYPE_44BSD &&\n\t     (usb1->fs_flags & UFS_FLAGS_UPDATED)) ||\n\t    mtype == UFS_MOUNT_UFSTYPE_UFS2) {\n\t\t/*we have statistic in different place, then usual*/\n\t\tusb2->fs_un.fs_u2.cs_ndir =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_ndir);\n\t\tusb2->fs_un.fs_u2.cs_nbfree =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_nbfree);\n\t\tusb3->fs_un1.fs_u2.cs_nifree =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_nifree);\n\t\tusb3->fs_un1.fs_u2.cs_nffree =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_nffree);\n\t} else {\n\t\tusb1->fs_cstotal.cs_ndir =\n\t\t\tcpu_to_fs32(sb, uspi->cs_total.cs_ndir);\n\t\tusb1->fs_cstotal.cs_nbfree =\n\t\t\tcpu_to_fs32(sb, uspi->cs_total.cs_nbfree);\n\t\tusb1->fs_cstotal.cs_nifree =\n\t\t\tcpu_to_fs32(sb, uspi->cs_total.cs_nifree);\n\t\tusb1->fs_cstotal.cs_nffree =\n\t\t\tcpu_to_fs32(sb, uspi->cs_total.cs_nffree);\n\t}\n\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\tufs_print_super_stuff(sb, usb1, usb2, usb3);\n\tUFSD(\"EXIT\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_set_fs_state",
          "args": [
            "sb",
            "usb1",
            "usb3",
            "UFS_FSOK - fs32_to_cpu(sb, usb1->fs_time)"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_set_fs_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "55-76",
          "snippet": "static inline void\nufs_set_fs_state(struct super_block *sb, struct ufs_super_block_first *usb1,\n\t\t struct ufs_super_block_third *usb3, s32 value)\n{\n\tswitch (UFS_SB(sb)->s_flags & UFS_ST_MASK) {\n\tcase UFS_ST_SUNOS:\n\t\tif (fs32_to_cpu(sb, usb3->fs_postblformat) == UFS_42POSTBLFMT) {\n\t\t\tusb1->fs_u0.fs_sun.fs_state = cpu_to_fs32(sb, value);\n\t\t\tbreak;\n\t\t}\n\t\t/* Fall Through to UFS_ST_SUN */\n\tcase UFS_ST_SUN:\n\t\tusb3->fs_un2.fs_sun.fs_state = cpu_to_fs32(sb, value);\n\t\tbreak;\n\tcase UFS_ST_SUNx86:\n\t\tusb1->fs_u1.fs_sunx86.fs_state = cpu_to_fs32(sb, value);\n\t\tbreak;\n\tcase UFS_ST_44BSD:\n\t\tusb3->fs_un2.fs_44.fs_state = cpu_to_fs32(sb, value);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline void\nufs_set_fs_state(struct super_block *sb, struct ufs_super_block_first *usb1,\n\t\t struct ufs_super_block_third *usb3, s32 value)\n{\n\tswitch (UFS_SB(sb)->s_flags & UFS_ST_MASK) {\n\tcase UFS_ST_SUNOS:\n\t\tif (fs32_to_cpu(sb, usb3->fs_postblformat) == UFS_42POSTBLFMT) {\n\t\t\tusb1->fs_u0.fs_sun.fs_state = cpu_to_fs32(sb, value);\n\t\t\tbreak;\n\t\t}\n\t\t/* Fall Through to UFS_ST_SUN */\n\tcase UFS_ST_SUN:\n\t\tusb3->fs_un2.fs_sun.fs_state = cpu_to_fs32(sb, value);\n\t\tbreak;\n\tcase UFS_ST_SUNx86:\n\t\tusb1->fs_u1.fs_sunx86.fs_state = cpu_to_fs32(sb, value);\n\t\tbreak;\n\tcase UFS_ST_44BSD:\n\t\tusb3->fs_un2.fs_44.fs_state = cpu_to_fs32(sb, value);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sb",
            "usb1->fs_time"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "43-50",
          "snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_fs32",
          "args": [
            "sb",
            "get_seconds()"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_fs32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "52-59",
          "snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_get_usb_third",
          "args": [
            "uspi"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_get_usb_first",
          "args": [
            "uspi"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER\\n\""
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic int ufs_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct ufs_super_block_third * usb3;\n\tunsigned flags;\n\n\tlock_ufs(sb);\n\n\tUFSD(\"ENTER\\n\");\n\n\tflags = UFS_SB(sb)->s_flags;\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\tusb3 = ubh_get_usb_third(uspi);\n\n\tusb1->fs_time = cpu_to_fs32(sb, get_seconds());\n\tif ((flags & UFS_ST_MASK) == UFS_ST_SUN  ||\n\t    (flags & UFS_ST_MASK) == UFS_ST_SUNOS ||\n\t    (flags & UFS_ST_MASK) == UFS_ST_SUNx86)\n\t\tufs_set_fs_state(sb, usb1, usb3,\n\t\t\t\tUFS_FSOK - fs32_to_cpu(sb, usb1->fs_time));\n\tufs_put_cstotal(sb);\n\n\tUFSD(\"EXIT\\n\");\n\tunlock_ufs(sb);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ufs_put_super_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "647-687",
    "snippet": "static void ufs_put_super_internal(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info *uspi = sbi->s_uspi;\n\tstruct ufs_buffer_head * ubh;\n\tunsigned char * base, * space;\n\tunsigned blks, size, i;\n\n\t\n\tUFSD(\"ENTER\\n\");\n\n\tufs_put_cstotal(sb);\n\tsize = uspi->s_cssize;\n\tblks = (size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\tbase = space = (char*) sbi->s_csp;\n\tfor (i = 0; i < blks; i += uspi->s_fpb) {\n\t\tsize = uspi->s_bsize;\n\t\tif (i + uspi->s_fpb > blks)\n\t\t\tsize = (blks - i) * uspi->s_fsize;\n\n\t\tubh = ubh_bread(sb, uspi->s_csaddr + i, size);\n\n\t\tubh_memcpyubh (ubh, space, size);\n\t\tspace += size;\n\t\tubh_mark_buffer_uptodate (ubh, 1);\n\t\tubh_mark_buffer_dirty (ubh);\n\t\tubh_brelse (ubh);\n\t}\n\tfor (i = 0; i < sbi->s_cg_loaded; i++) {\n\t\tufs_put_cylinder (sb, i);\n\t\tkfree (sbi->s_ucpi[i]);\n\t}\n\tfor (; i < UFS_MAX_GROUP_LOADED; i++) \n\t\tkfree (sbi->s_ucpi[i]);\n\tfor (i = 0; i < uspi->s_ncg; i++) \n\t\tbrelse (sbi->s_ucg[i]);\n\tkfree (sbi->s_ucg);\n\tkfree (base);\n\n\tUFSD(\"EXIT\\n\");\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT\\n\""
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "base"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_ucg"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "sbi->s_ucg[i]"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_brelse_uspi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "81-90",
          "snippet": "void ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_ucpi[i]"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_ucpi[i]"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_put_cylinder",
          "args": [
            "sb",
            "i"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_put_cylinder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/cylinder.c",
          "lines": "82-118",
          "snippet": "void ufs_put_cylinder (struct super_block * sb, unsigned bitmap_nr)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi; \n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned i;\n\n\tUFSD(\"ENTER, bitmap_nr %u\\n\", bitmap_nr);\n\n\tuspi = sbi->s_uspi;\n\tif (sbi->s_cgno[bitmap_nr] == UFS_CGNO_EMPTY) {\n\t\tUFSD(\"EXIT\\n\");\n\t\treturn;\n\t}\n\tucpi = sbi->s_ucpi[bitmap_nr];\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\n\tif (uspi->s_ncg > UFS_MAX_GROUP_LOADED && bitmap_nr >= sbi->s_cg_loaded) {\n\t\tufs_panic (sb, \"ufs_put_cylinder\", \"internal error\");\n\t\treturn;\n\t}\n\t/*\n\t * rotor is not so important data, so we put it to disk \n\t * at the end of working with cylinder\n\t */\n\tucg->cg_rotor = cpu_to_fs32(sb, ucpi->c_rotor);\n\tucg->cg_frotor = cpu_to_fs32(sb, ucpi->c_frotor);\n\tucg->cg_irotor = cpu_to_fs32(sb, ucpi->c_irotor);\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tfor (i = 1; i < UCPI_UBH(ucpi)->count; i++) {\n\t\tbrelse (UCPI_UBH(ucpi)->bh[i]);\n\t}\n\n\tsbi->s_cgno[bitmap_nr] = UFS_CGNO_EMPTY;\n\tUFSD(\"EXIT\\n\");\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ufs_put_cylinder (struct super_block * sb, unsigned bitmap_nr)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi; \n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned i;\n\n\tUFSD(\"ENTER, bitmap_nr %u\\n\", bitmap_nr);\n\n\tuspi = sbi->s_uspi;\n\tif (sbi->s_cgno[bitmap_nr] == UFS_CGNO_EMPTY) {\n\t\tUFSD(\"EXIT\\n\");\n\t\treturn;\n\t}\n\tucpi = sbi->s_ucpi[bitmap_nr];\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\n\tif (uspi->s_ncg > UFS_MAX_GROUP_LOADED && bitmap_nr >= sbi->s_cg_loaded) {\n\t\tufs_panic (sb, \"ufs_put_cylinder\", \"internal error\");\n\t\treturn;\n\t}\n\t/*\n\t * rotor is not so important data, so we put it to disk \n\t * at the end of working with cylinder\n\t */\n\tucg->cg_rotor = cpu_to_fs32(sb, ucpi->c_rotor);\n\tucg->cg_frotor = cpu_to_fs32(sb, ucpi->c_frotor);\n\tucg->cg_irotor = cpu_to_fs32(sb, ucpi->c_irotor);\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tfor (i = 1; i < UCPI_UBH(ucpi)->count; i++) {\n\t\tbrelse (UCPI_UBH(ucpi)->bh[i]);\n\t}\n\n\tsbi->s_cgno[bitmap_nr] = UFS_CGNO_EMPTY;\n\tUFSD(\"EXIT\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_mark_buffer_dirty",
          "args": [
            "ubh"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "92-99",
          "snippet": "void ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_mark_buffer_uptodate",
          "args": [
            "ubh",
            "1"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_mark_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "101-113",
          "snippet": "void ubh_mark_buffer_uptodate (struct ufs_buffer_head * ubh, int flag)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tif (flag) {\n\t\tfor ( i = 0; i < ubh->count; i++ )\n\t\t\tset_buffer_uptodate (ubh->bh[i]);\n\t} else {\n\t\tfor ( i = 0; i < ubh->count; i++ )\n\t\t\tclear_buffer_uptodate (ubh->bh[i]);\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_mark_buffer_uptodate (struct ufs_buffer_head * ubh, int flag)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tif (flag) {\n\t\tfor ( i = 0; i < ubh->count; i++ )\n\t\t\tset_buffer_uptodate (ubh->bh[i]);\n\t} else {\n\t\tfor ( i = 0; i < ubh->count; i++ )\n\t\t\tclear_buffer_uptodate (ubh->bh[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_memcpyubh",
          "args": [
            "ubh",
            "space",
            "size"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_bread",
          "args": [
            "sb",
            "uspi->s_csaddr + i",
            "size"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_put_cstotal",
          "args": [
            "sb"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_put_cstotal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "601-639",
          "snippet": "static void ufs_put_cstotal(struct super_block *sb)\n{\n\tunsigned mtype = UFS_SB(sb)->s_mount_opt & UFS_MOUNT_UFSTYPE;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct ufs_super_block_first *usb1;\n\tstruct ufs_super_block_second *usb2;\n\tstruct ufs_super_block_third *usb3;\n\n\tUFSD(\"ENTER\\n\");\n\tusb1 = ubh_get_usb_first(uspi);\n\tusb2 = ubh_get_usb_second(uspi);\n\tusb3 = ubh_get_usb_third(uspi);\n\n\tif ((mtype == UFS_MOUNT_UFSTYPE_44BSD &&\n\t     (usb1->fs_flags & UFS_FLAGS_UPDATED)) ||\n\t    mtype == UFS_MOUNT_UFSTYPE_UFS2) {\n\t\t/*we have statistic in different place, then usual*/\n\t\tusb2->fs_un.fs_u2.cs_ndir =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_ndir);\n\t\tusb2->fs_un.fs_u2.cs_nbfree =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_nbfree);\n\t\tusb3->fs_un1.fs_u2.cs_nifree =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_nifree);\n\t\tusb3->fs_un1.fs_u2.cs_nffree =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_nffree);\n\t} else {\n\t\tusb1->fs_cstotal.cs_ndir =\n\t\t\tcpu_to_fs32(sb, uspi->cs_total.cs_ndir);\n\t\tusb1->fs_cstotal.cs_nbfree =\n\t\t\tcpu_to_fs32(sb, uspi->cs_total.cs_nbfree);\n\t\tusb1->fs_cstotal.cs_nifree =\n\t\t\tcpu_to_fs32(sb, uspi->cs_total.cs_nifree);\n\t\tusb1->fs_cstotal.cs_nffree =\n\t\t\tcpu_to_fs32(sb, uspi->cs_total.cs_nffree);\n\t}\n\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\tufs_print_super_stuff(sb, usb1, usb2, usb3);\n\tUFSD(\"EXIT\\n\");\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic void ufs_put_cstotal(struct super_block *sb)\n{\n\tunsigned mtype = UFS_SB(sb)->s_mount_opt & UFS_MOUNT_UFSTYPE;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct ufs_super_block_first *usb1;\n\tstruct ufs_super_block_second *usb2;\n\tstruct ufs_super_block_third *usb3;\n\n\tUFSD(\"ENTER\\n\");\n\tusb1 = ubh_get_usb_first(uspi);\n\tusb2 = ubh_get_usb_second(uspi);\n\tusb3 = ubh_get_usb_third(uspi);\n\n\tif ((mtype == UFS_MOUNT_UFSTYPE_44BSD &&\n\t     (usb1->fs_flags & UFS_FLAGS_UPDATED)) ||\n\t    mtype == UFS_MOUNT_UFSTYPE_UFS2) {\n\t\t/*we have statistic in different place, then usual*/\n\t\tusb2->fs_un.fs_u2.cs_ndir =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_ndir);\n\t\tusb2->fs_un.fs_u2.cs_nbfree =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_nbfree);\n\t\tusb3->fs_un1.fs_u2.cs_nifree =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_nifree);\n\t\tusb3->fs_un1.fs_u2.cs_nffree =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_nffree);\n\t} else {\n\t\tusb1->fs_cstotal.cs_ndir =\n\t\t\tcpu_to_fs32(sb, uspi->cs_total.cs_ndir);\n\t\tusb1->fs_cstotal.cs_nbfree =\n\t\t\tcpu_to_fs32(sb, uspi->cs_total.cs_nbfree);\n\t\tusb1->fs_cstotal.cs_nifree =\n\t\t\tcpu_to_fs32(sb, uspi->cs_total.cs_nifree);\n\t\tusb1->fs_cstotal.cs_nffree =\n\t\t\tcpu_to_fs32(sb, uspi->cs_total.cs_nffree);\n\t}\n\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\tufs_print_super_stuff(sb, usb1, usb2, usb3);\n\tUFSD(\"EXIT\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER\\n\""
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic void ufs_put_super_internal(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info *uspi = sbi->s_uspi;\n\tstruct ufs_buffer_head * ubh;\n\tunsigned char * base, * space;\n\tunsigned blks, size, i;\n\n\t\n\tUFSD(\"ENTER\\n\");\n\n\tufs_put_cstotal(sb);\n\tsize = uspi->s_cssize;\n\tblks = (size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\tbase = space = (char*) sbi->s_csp;\n\tfor (i = 0; i < blks; i += uspi->s_fpb) {\n\t\tsize = uspi->s_bsize;\n\t\tif (i + uspi->s_fpb > blks)\n\t\t\tsize = (blks - i) * uspi->s_fsize;\n\n\t\tubh = ubh_bread(sb, uspi->s_csaddr + i, size);\n\n\t\tubh_memcpyubh (ubh, space, size);\n\t\tspace += size;\n\t\tubh_mark_buffer_uptodate (ubh, 1);\n\t\tubh_mark_buffer_dirty (ubh);\n\t\tubh_brelse (ubh);\n\t}\n\tfor (i = 0; i < sbi->s_cg_loaded; i++) {\n\t\tufs_put_cylinder (sb, i);\n\t\tkfree (sbi->s_ucpi[i]);\n\t}\n\tfor (; i < UFS_MAX_GROUP_LOADED; i++) \n\t\tkfree (sbi->s_ucpi[i]);\n\tfor (i = 0; i < uspi->s_ncg; i++) \n\t\tbrelse (sbi->s_ucg[i]);\n\tkfree (sbi->s_ucg);\n\tkfree (base);\n\n\tUFSD(\"EXIT\\n\");\n}"
  },
  {
    "function_name": "ufs_put_cstotal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "601-639",
    "snippet": "static void ufs_put_cstotal(struct super_block *sb)\n{\n\tunsigned mtype = UFS_SB(sb)->s_mount_opt & UFS_MOUNT_UFSTYPE;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct ufs_super_block_first *usb1;\n\tstruct ufs_super_block_second *usb2;\n\tstruct ufs_super_block_third *usb3;\n\n\tUFSD(\"ENTER\\n\");\n\tusb1 = ubh_get_usb_first(uspi);\n\tusb2 = ubh_get_usb_second(uspi);\n\tusb3 = ubh_get_usb_third(uspi);\n\n\tif ((mtype == UFS_MOUNT_UFSTYPE_44BSD &&\n\t     (usb1->fs_flags & UFS_FLAGS_UPDATED)) ||\n\t    mtype == UFS_MOUNT_UFSTYPE_UFS2) {\n\t\t/*we have statistic in different place, then usual*/\n\t\tusb2->fs_un.fs_u2.cs_ndir =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_ndir);\n\t\tusb2->fs_un.fs_u2.cs_nbfree =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_nbfree);\n\t\tusb3->fs_un1.fs_u2.cs_nifree =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_nifree);\n\t\tusb3->fs_un1.fs_u2.cs_nffree =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_nffree);\n\t} else {\n\t\tusb1->fs_cstotal.cs_ndir =\n\t\t\tcpu_to_fs32(sb, uspi->cs_total.cs_ndir);\n\t\tusb1->fs_cstotal.cs_nbfree =\n\t\t\tcpu_to_fs32(sb, uspi->cs_total.cs_nbfree);\n\t\tusb1->fs_cstotal.cs_nifree =\n\t\t\tcpu_to_fs32(sb, uspi->cs_total.cs_nifree);\n\t\tusb1->fs_cstotal.cs_nffree =\n\t\t\tcpu_to_fs32(sb, uspi->cs_total.cs_nffree);\n\t}\n\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\tufs_print_super_stuff(sb, usb1, usb2, usb3);\n\tUFSD(\"EXIT\\n\");\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT\\n\""
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_print_super_stuff",
          "args": [
            "sb",
            "usb1",
            "usb2",
            "usb3"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_print_super_stuff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "163-237",
          "snippet": "static void ufs_print_super_stuff(struct super_block *sb,\n\t\t\t\t  struct ufs_super_block_first *usb1,\n\t\t\t\t  struct ufs_super_block_second *usb2,\n\t\t\t\t  struct ufs_super_block_third *usb3)\n{\n\tu32 magic = fs32_to_cpu(sb, usb3->fs_magic);\n\n\tpr_debug(\"ufs_print_super_stuff\\n\");\n\tpr_debug(\"  magic:     0x%x\\n\", magic);\n\tif (fs32_to_cpu(sb, usb3->fs_magic) == UFS2_MAGIC) {\n\t\tpr_debug(\"  fs_size:   %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_size));\n\t\tpr_debug(\"  fs_dsize:  %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_dsize));\n\t\tpr_debug(\"  bsize:         %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_bsize));\n\t\tpr_debug(\"  fsize:         %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_fsize));\n\t\tpr_debug(\"  fs_volname:  %s\\n\", usb2->fs_un.fs_u2.fs_volname);\n\t\tpr_debug(\"  fs_sblockloc: %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb2->fs_un.fs_u2.fs_sblockloc));\n\t\tpr_debug(\"  cs_ndir(No of dirs):  %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_ndir));\n\t\tpr_debug(\"  cs_nbfree(No of free blocks):  %llu\\n\",\n\t\t\t (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_nbfree));\n\t\tpr_info(\"  cs_nifree(Num of free inodes): %llu\\n\",\n\t\t\t(unsigned long long)\n\t\t\tfs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nifree));\n\t\tpr_info(\"  cs_nffree(Num of free frags): %llu\\n\",\n\t\t\t(unsigned long long)\n\t\t\tfs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nffree));\n\t\tpr_info(\"  fs_maxsymlinklen: %u\\n\",\n\t\t\tfs32_to_cpu(sb, usb3->fs_un2.fs_44.fs_maxsymlinklen));\n\t} else {\n\t\tpr_debug(\" sblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_sblkno));\n\t\tpr_debug(\" cblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_cblkno));\n\t\tpr_debug(\" iblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_iblkno));\n\t\tpr_debug(\" dblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_dblkno));\n\t\tpr_debug(\" cgoffset:    %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cgoffset));\n\t\tpr_debug(\" ~cgmask:     0x%x\\n\",\n\t\t\t ~fs32_to_cpu(sb, usb1->fs_cgmask));\n\t\tpr_debug(\" size:        %u\\n\", fs32_to_cpu(sb, usb1->fs_size));\n\t\tpr_debug(\" dsize:       %u\\n\", fs32_to_cpu(sb, usb1->fs_dsize));\n\t\tpr_debug(\" ncg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_ncg));\n\t\tpr_debug(\" bsize:       %u\\n\", fs32_to_cpu(sb, usb1->fs_bsize));\n\t\tpr_debug(\" fsize:       %u\\n\", fs32_to_cpu(sb, usb1->fs_fsize));\n\t\tpr_debug(\" frag:        %u\\n\", fs32_to_cpu(sb, usb1->fs_frag));\n\t\tpr_debug(\" fragshift:   %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_fragshift));\n\t\tpr_debug(\" ~fmask:      %u\\n\", ~fs32_to_cpu(sb, usb1->fs_fmask));\n\t\tpr_debug(\" fshift:      %u\\n\", fs32_to_cpu(sb, usb1->fs_fshift));\n\t\tpr_debug(\" sbsize:      %u\\n\", fs32_to_cpu(sb, usb1->fs_sbsize));\n\t\tpr_debug(\" spc:         %u\\n\", fs32_to_cpu(sb, usb1->fs_spc));\n\t\tpr_debug(\" cpg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_cpg));\n\t\tpr_debug(\" ipg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_ipg));\n\t\tpr_debug(\" fpg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_fpg));\n\t\tpr_debug(\" csaddr:      %u\\n\", fs32_to_cpu(sb, usb1->fs_csaddr));\n\t\tpr_debug(\" cssize:      %u\\n\", fs32_to_cpu(sb, usb1->fs_cssize));\n\t\tpr_debug(\" cgsize:      %u\\n\", fs32_to_cpu(sb, usb1->fs_cgsize));\n\t\tpr_debug(\" fstodb:      %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_fsbtodb));\n\t\tpr_debug(\" nrpos:       %u\\n\", fs32_to_cpu(sb, usb3->fs_nrpos));\n\t\tpr_debug(\" ndir         %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_ndir));\n\t\tpr_debug(\" nifree       %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_nifree));\n\t\tpr_debug(\" nbfree       %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_nbfree));\n\t\tpr_debug(\" nffree       %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_nffree));\n\t}\n\tpr_debug(\"\\n\");\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic void ufs_print_super_stuff(struct super_block *sb,\n\t\t\t\t  struct ufs_super_block_first *usb1,\n\t\t\t\t  struct ufs_super_block_second *usb2,\n\t\t\t\t  struct ufs_super_block_third *usb3)\n{\n\tu32 magic = fs32_to_cpu(sb, usb3->fs_magic);\n\n\tpr_debug(\"ufs_print_super_stuff\\n\");\n\tpr_debug(\"  magic:     0x%x\\n\", magic);\n\tif (fs32_to_cpu(sb, usb3->fs_magic) == UFS2_MAGIC) {\n\t\tpr_debug(\"  fs_size:   %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_size));\n\t\tpr_debug(\"  fs_dsize:  %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_dsize));\n\t\tpr_debug(\"  bsize:         %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_bsize));\n\t\tpr_debug(\"  fsize:         %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_fsize));\n\t\tpr_debug(\"  fs_volname:  %s\\n\", usb2->fs_un.fs_u2.fs_volname);\n\t\tpr_debug(\"  fs_sblockloc: %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb2->fs_un.fs_u2.fs_sblockloc));\n\t\tpr_debug(\"  cs_ndir(No of dirs):  %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_ndir));\n\t\tpr_debug(\"  cs_nbfree(No of free blocks):  %llu\\n\",\n\t\t\t (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_nbfree));\n\t\tpr_info(\"  cs_nifree(Num of free inodes): %llu\\n\",\n\t\t\t(unsigned long long)\n\t\t\tfs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nifree));\n\t\tpr_info(\"  cs_nffree(Num of free frags): %llu\\n\",\n\t\t\t(unsigned long long)\n\t\t\tfs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nffree));\n\t\tpr_info(\"  fs_maxsymlinklen: %u\\n\",\n\t\t\tfs32_to_cpu(sb, usb3->fs_un2.fs_44.fs_maxsymlinklen));\n\t} else {\n\t\tpr_debug(\" sblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_sblkno));\n\t\tpr_debug(\" cblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_cblkno));\n\t\tpr_debug(\" iblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_iblkno));\n\t\tpr_debug(\" dblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_dblkno));\n\t\tpr_debug(\" cgoffset:    %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cgoffset));\n\t\tpr_debug(\" ~cgmask:     0x%x\\n\",\n\t\t\t ~fs32_to_cpu(sb, usb1->fs_cgmask));\n\t\tpr_debug(\" size:        %u\\n\", fs32_to_cpu(sb, usb1->fs_size));\n\t\tpr_debug(\" dsize:       %u\\n\", fs32_to_cpu(sb, usb1->fs_dsize));\n\t\tpr_debug(\" ncg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_ncg));\n\t\tpr_debug(\" bsize:       %u\\n\", fs32_to_cpu(sb, usb1->fs_bsize));\n\t\tpr_debug(\" fsize:       %u\\n\", fs32_to_cpu(sb, usb1->fs_fsize));\n\t\tpr_debug(\" frag:        %u\\n\", fs32_to_cpu(sb, usb1->fs_frag));\n\t\tpr_debug(\" fragshift:   %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_fragshift));\n\t\tpr_debug(\" ~fmask:      %u\\n\", ~fs32_to_cpu(sb, usb1->fs_fmask));\n\t\tpr_debug(\" fshift:      %u\\n\", fs32_to_cpu(sb, usb1->fs_fshift));\n\t\tpr_debug(\" sbsize:      %u\\n\", fs32_to_cpu(sb, usb1->fs_sbsize));\n\t\tpr_debug(\" spc:         %u\\n\", fs32_to_cpu(sb, usb1->fs_spc));\n\t\tpr_debug(\" cpg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_cpg));\n\t\tpr_debug(\" ipg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_ipg));\n\t\tpr_debug(\" fpg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_fpg));\n\t\tpr_debug(\" csaddr:      %u\\n\", fs32_to_cpu(sb, usb1->fs_csaddr));\n\t\tpr_debug(\" cssize:      %u\\n\", fs32_to_cpu(sb, usb1->fs_cssize));\n\t\tpr_debug(\" cgsize:      %u\\n\", fs32_to_cpu(sb, usb1->fs_cgsize));\n\t\tpr_debug(\" fstodb:      %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_fsbtodb));\n\t\tpr_debug(\" nrpos:       %u\\n\", fs32_to_cpu(sb, usb3->fs_nrpos));\n\t\tpr_debug(\" ndir         %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_ndir));\n\t\tpr_debug(\" nifree       %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_nifree));\n\t\tpr_debug(\" nbfree       %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_nbfree));\n\t\tpr_debug(\" nffree       %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_nffree));\n\t}\n\tpr_debug(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_mark_buffer_dirty",
          "args": [
            "USPI_UBH(uspi)"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "92-99",
          "snippet": "void ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USPI_UBH",
          "args": [
            "uspi"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "USPI_UBH",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "26-29",
          "snippet": "static inline struct ufs_buffer_head *USPI_UBH(struct ufs_sb_private_info *spi)\n{\n\treturn &spi->s_ubh;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse (struct ufs_buffer_head *);",
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);",
            "extern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);",
            "extern void ubh_sync_block(struct ufs_buffer_head *);",
            "extern void ubh_bforget (struct ufs_buffer_head *);",
            "extern int  ubh_buffer_dirty (struct ufs_buffer_head *);",
            "extern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);",
            "extern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\nstatic inline struct ufs_buffer_head *USPI_UBH(struct ufs_sb_private_info *spi)\n{\n\treturn &spi->s_ubh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_fs32",
          "args": [
            "sb",
            "uspi->cs_total.cs_nffree"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_fs32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "52-59",
          "snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_fs64",
          "args": [
            "sb",
            "uspi->cs_total.cs_nffree"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_fs64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "34-41",
          "snippet": "static inline __fs64\ncpu_to_fs64(struct super_block *sbp, u64 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs64)cpu_to_le64(n);\n\telse\n\t\treturn (__force __fs64)cpu_to_be64(n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __fs64\ncpu_to_fs64(struct super_block *sbp, u64 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs64)cpu_to_le64(n);\n\telse\n\t\treturn (__force __fs64)cpu_to_be64(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_get_usb_third",
          "args": [
            "uspi"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_get_usb_second",
          "args": [
            "uspi"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_get_usb_first",
          "args": [
            "uspi"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER\\n\""
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic void ufs_put_cstotal(struct super_block *sb)\n{\n\tunsigned mtype = UFS_SB(sb)->s_mount_opt & UFS_MOUNT_UFSTYPE;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct ufs_super_block_first *usb1;\n\tstruct ufs_super_block_second *usb2;\n\tstruct ufs_super_block_third *usb3;\n\n\tUFSD(\"ENTER\\n\");\n\tusb1 = ubh_get_usb_first(uspi);\n\tusb2 = ubh_get_usb_second(uspi);\n\tusb3 = ubh_get_usb_third(uspi);\n\n\tif ((mtype == UFS_MOUNT_UFSTYPE_44BSD &&\n\t     (usb1->fs_flags & UFS_FLAGS_UPDATED)) ||\n\t    mtype == UFS_MOUNT_UFSTYPE_UFS2) {\n\t\t/*we have statistic in different place, then usual*/\n\t\tusb2->fs_un.fs_u2.cs_ndir =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_ndir);\n\t\tusb2->fs_un.fs_u2.cs_nbfree =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_nbfree);\n\t\tusb3->fs_un1.fs_u2.cs_nifree =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_nifree);\n\t\tusb3->fs_un1.fs_u2.cs_nffree =\n\t\t\tcpu_to_fs64(sb, uspi->cs_total.cs_nffree);\n\t} else {\n\t\tusb1->fs_cstotal.cs_ndir =\n\t\t\tcpu_to_fs32(sb, uspi->cs_total.cs_ndir);\n\t\tusb1->fs_cstotal.cs_nbfree =\n\t\t\tcpu_to_fs32(sb, uspi->cs_total.cs_nbfree);\n\t\tusb1->fs_cstotal.cs_nifree =\n\t\t\tcpu_to_fs32(sb, uspi->cs_total.cs_nifree);\n\t\tusb1->fs_cstotal.cs_nffree =\n\t\t\tcpu_to_fs32(sb, uspi->cs_total.cs_nffree);\n\t}\n\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\tufs_print_super_stuff(sb, usb1, usb2, usb3);\n\tUFSD(\"EXIT\\n\");\n}"
  },
  {
    "function_name": "ufs_read_cylinder_structures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "517-596",
    "snippet": "static int ufs_read_cylinder_structures(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info *uspi = sbi->s_uspi;\n\tstruct ufs_buffer_head * ubh;\n\tunsigned char * base, * space;\n\tunsigned size, blks, i;\n\n\tUFSD(\"ENTER\\n\");\n\n\t/*\n\t * Read cs structures from (usually) first data block\n\t * on the device. \n\t */\n\tsize = uspi->s_cssize;\n\tblks = (size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\tbase = space = kmalloc(size, GFP_NOFS);\n\tif (!base)\n\t\tgoto failed; \n\tsbi->s_csp = (struct ufs_csum *)space;\n\tfor (i = 0; i < blks; i += uspi->s_fpb) {\n\t\tsize = uspi->s_bsize;\n\t\tif (i + uspi->s_fpb > blks)\n\t\t\tsize = (blks - i) * uspi->s_fsize;\n\n\t\tubh = ubh_bread(sb, uspi->s_csaddr + i, size);\n\t\t\n\t\tif (!ubh)\n\t\t\tgoto failed;\n\n\t\tubh_ubhcpymem (space, ubh, size);\n\n\t\tspace += size;\n\t\tubh_brelse (ubh);\n\t\tubh = NULL;\n\t}\n\n\t/*\n\t * Read cylinder group (we read only first fragment from block\n\t * at this time) and prepare internal data structures for cg caching.\n\t */\n\tif (!(sbi->s_ucg = kmalloc (sizeof(struct buffer_head *) * uspi->s_ncg, GFP_NOFS)))\n\t\tgoto failed;\n\tfor (i = 0; i < uspi->s_ncg; i++) \n\t\tsbi->s_ucg[i] = NULL;\n\tfor (i = 0; i < UFS_MAX_GROUP_LOADED; i++) {\n\t\tsbi->s_ucpi[i] = NULL;\n\t\tsbi->s_cgno[i] = UFS_CGNO_EMPTY;\n\t}\n\tfor (i = 0; i < uspi->s_ncg; i++) {\n\t\tUFSD(\"read cg %u\\n\", i);\n\t\tif (!(sbi->s_ucg[i] = sb_bread(sb, ufs_cgcmin(i))))\n\t\t\tgoto failed;\n\t\tif (!ufs_cg_chkmagic (sb, (struct ufs_cylinder_group *) sbi->s_ucg[i]->b_data))\n\t\t\tgoto failed;\n\n\t\tufs_print_cylinder_stuff(sb, (struct ufs_cylinder_group *) sbi->s_ucg[i]->b_data);\n\t}\n\tfor (i = 0; i < UFS_MAX_GROUP_LOADED; i++) {\n\t\tif (!(sbi->s_ucpi[i] = kmalloc (sizeof(struct ufs_cg_private_info), GFP_NOFS)))\n\t\t\tgoto failed;\n\t\tsbi->s_cgno[i] = UFS_CGNO_EMPTY;\n\t}\n\tsbi->s_cg_loaded = 0;\n\tUFSD(\"EXIT\\n\");\n\treturn 1;\n\nfailed:\n\tkfree (base);\n\tif (sbi->s_ucg) {\n\t\tfor (i = 0; i < uspi->s_ncg; i++)\n\t\t\tif (sbi->s_ucg[i])\n\t\t\t\tbrelse (sbi->s_ucg[i]);\n\t\tkfree (sbi->s_ucg);\n\t\tfor (i = 0; i < UFS_MAX_GROUP_LOADED; i++)\n\t\t\tkfree (sbi->s_ucpi[i]);\n\t}\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT (FAILED)\\n\""
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_ucpi[i]"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_ucg"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "sbi->s_ucg[i]"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_brelse_uspi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "81-90",
          "snippet": "void ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "base"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT\\n\""
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct ufs_cg_private_info)",
            "GFP_NOFS"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_print_cylinder_stuff",
          "args": [
            "sb",
            "(struct ufs_cylinder_group *) sbi->s_ucg[i]->b_data"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_print_cylinder_stuff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "242-277",
          "snippet": "static void ufs_print_cylinder_stuff(struct super_block *sb,\n\t\t\t\t     struct ufs_cylinder_group *cg)\n{\n\tpr_debug(\"\\nufs_print_cylinder_stuff\\n\");\n\tpr_debug(\"size of ucg: %zu\\n\", sizeof(struct ufs_cylinder_group));\n\tpr_debug(\"  magic:        %x\\n\", fs32_to_cpu(sb, cg->cg_magic));\n\tpr_debug(\"  time:         %u\\n\", fs32_to_cpu(sb, cg->cg_time));\n\tpr_debug(\"  cgx:          %u\\n\", fs32_to_cpu(sb, cg->cg_cgx));\n\tpr_debug(\"  ncyl:         %u\\n\", fs16_to_cpu(sb, cg->cg_ncyl));\n\tpr_debug(\"  niblk:        %u\\n\", fs16_to_cpu(sb, cg->cg_niblk));\n\tpr_debug(\"  ndblk:        %u\\n\", fs32_to_cpu(sb, cg->cg_ndblk));\n\tpr_debug(\"  cs_ndir:      %u\\n\", fs32_to_cpu(sb, cg->cg_cs.cs_ndir));\n\tpr_debug(\"  cs_nbfree:    %u\\n\", fs32_to_cpu(sb, cg->cg_cs.cs_nbfree));\n\tpr_debug(\"  cs_nifree:    %u\\n\", fs32_to_cpu(sb, cg->cg_cs.cs_nifree));\n\tpr_debug(\"  cs_nffree:    %u\\n\", fs32_to_cpu(sb, cg->cg_cs.cs_nffree));\n\tpr_debug(\"  rotor:        %u\\n\", fs32_to_cpu(sb, cg->cg_rotor));\n\tpr_debug(\"  frotor:       %u\\n\", fs32_to_cpu(sb, cg->cg_frotor));\n\tpr_debug(\"  irotor:       %u\\n\", fs32_to_cpu(sb, cg->cg_irotor));\n\tpr_debug(\"  frsum:        %u, %u, %u, %u, %u, %u, %u, %u\\n\",\n\t    fs32_to_cpu(sb, cg->cg_frsum[0]), fs32_to_cpu(sb, cg->cg_frsum[1]),\n\t    fs32_to_cpu(sb, cg->cg_frsum[2]), fs32_to_cpu(sb, cg->cg_frsum[3]),\n\t    fs32_to_cpu(sb, cg->cg_frsum[4]), fs32_to_cpu(sb, cg->cg_frsum[5]),\n\t    fs32_to_cpu(sb, cg->cg_frsum[6]), fs32_to_cpu(sb, cg->cg_frsum[7]));\n\tpr_debug(\"  btotoff:      %u\\n\", fs32_to_cpu(sb, cg->cg_btotoff));\n\tpr_debug(\"  boff:         %u\\n\", fs32_to_cpu(sb, cg->cg_boff));\n\tpr_debug(\"  iuseoff:      %u\\n\", fs32_to_cpu(sb, cg->cg_iusedoff));\n\tpr_debug(\"  freeoff:      %u\\n\", fs32_to_cpu(sb, cg->cg_freeoff));\n\tpr_debug(\"  nextfreeoff:  %u\\n\", fs32_to_cpu(sb, cg->cg_nextfreeoff));\n\tpr_debug(\"  clustersumoff %u\\n\",\n\t\t fs32_to_cpu(sb, cg->cg_u.cg_44.cg_clustersumoff));\n\tpr_debug(\"  clusteroff    %u\\n\",\n\t\t fs32_to_cpu(sb, cg->cg_u.cg_44.cg_clusteroff));\n\tpr_debug(\"  nclusterblks  %u\\n\",\n\t\t fs32_to_cpu(sb, cg->cg_u.cg_44.cg_nclusterblks));\n\tpr_debug(\"\\n\");\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic void ufs_print_cylinder_stuff(struct super_block *sb,\n\t\t\t\t     struct ufs_cylinder_group *cg)\n{\n\tpr_debug(\"\\nufs_print_cylinder_stuff\\n\");\n\tpr_debug(\"size of ucg: %zu\\n\", sizeof(struct ufs_cylinder_group));\n\tpr_debug(\"  magic:        %x\\n\", fs32_to_cpu(sb, cg->cg_magic));\n\tpr_debug(\"  time:         %u\\n\", fs32_to_cpu(sb, cg->cg_time));\n\tpr_debug(\"  cgx:          %u\\n\", fs32_to_cpu(sb, cg->cg_cgx));\n\tpr_debug(\"  ncyl:         %u\\n\", fs16_to_cpu(sb, cg->cg_ncyl));\n\tpr_debug(\"  niblk:        %u\\n\", fs16_to_cpu(sb, cg->cg_niblk));\n\tpr_debug(\"  ndblk:        %u\\n\", fs32_to_cpu(sb, cg->cg_ndblk));\n\tpr_debug(\"  cs_ndir:      %u\\n\", fs32_to_cpu(sb, cg->cg_cs.cs_ndir));\n\tpr_debug(\"  cs_nbfree:    %u\\n\", fs32_to_cpu(sb, cg->cg_cs.cs_nbfree));\n\tpr_debug(\"  cs_nifree:    %u\\n\", fs32_to_cpu(sb, cg->cg_cs.cs_nifree));\n\tpr_debug(\"  cs_nffree:    %u\\n\", fs32_to_cpu(sb, cg->cg_cs.cs_nffree));\n\tpr_debug(\"  rotor:        %u\\n\", fs32_to_cpu(sb, cg->cg_rotor));\n\tpr_debug(\"  frotor:       %u\\n\", fs32_to_cpu(sb, cg->cg_frotor));\n\tpr_debug(\"  irotor:       %u\\n\", fs32_to_cpu(sb, cg->cg_irotor));\n\tpr_debug(\"  frsum:        %u, %u, %u, %u, %u, %u, %u, %u\\n\",\n\t    fs32_to_cpu(sb, cg->cg_frsum[0]), fs32_to_cpu(sb, cg->cg_frsum[1]),\n\t    fs32_to_cpu(sb, cg->cg_frsum[2]), fs32_to_cpu(sb, cg->cg_frsum[3]),\n\t    fs32_to_cpu(sb, cg->cg_frsum[4]), fs32_to_cpu(sb, cg->cg_frsum[5]),\n\t    fs32_to_cpu(sb, cg->cg_frsum[6]), fs32_to_cpu(sb, cg->cg_frsum[7]));\n\tpr_debug(\"  btotoff:      %u\\n\", fs32_to_cpu(sb, cg->cg_btotoff));\n\tpr_debug(\"  boff:         %u\\n\", fs32_to_cpu(sb, cg->cg_boff));\n\tpr_debug(\"  iuseoff:      %u\\n\", fs32_to_cpu(sb, cg->cg_iusedoff));\n\tpr_debug(\"  freeoff:      %u\\n\", fs32_to_cpu(sb, cg->cg_freeoff));\n\tpr_debug(\"  nextfreeoff:  %u\\n\", fs32_to_cpu(sb, cg->cg_nextfreeoff));\n\tpr_debug(\"  clustersumoff %u\\n\",\n\t\t fs32_to_cpu(sb, cg->cg_u.cg_44.cg_clustersumoff));\n\tpr_debug(\"  clusteroff    %u\\n\",\n\t\t fs32_to_cpu(sb, cg->cg_u.cg_44.cg_clusteroff));\n\tpr_debug(\"  nclusterblks  %u\\n\",\n\t\t fs32_to_cpu(sb, cg->cg_u.cg_44.cg_nclusterblks));\n\tpr_debug(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_cg_chkmagic",
          "args": [
            "sb",
            "(struct ufs_cylinder_group *) sbi->s_ucg[i]->b_data"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "ufs_cgcmin(i)"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_cgcmin",
          "args": [
            "i"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"read cg %u\\n\"",
            "i"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_ubhcpymem",
          "args": [
            "space",
            "ubh",
            "size"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_bread",
          "args": [
            "sb",
            "uspi->s_csaddr + i",
            "size"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER\\n\""
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic int ufs_read_cylinder_structures(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info *uspi = sbi->s_uspi;\n\tstruct ufs_buffer_head * ubh;\n\tunsigned char * base, * space;\n\tunsigned size, blks, i;\n\n\tUFSD(\"ENTER\\n\");\n\n\t/*\n\t * Read cs structures from (usually) first data block\n\t * on the device. \n\t */\n\tsize = uspi->s_cssize;\n\tblks = (size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\tbase = space = kmalloc(size, GFP_NOFS);\n\tif (!base)\n\t\tgoto failed; \n\tsbi->s_csp = (struct ufs_csum *)space;\n\tfor (i = 0; i < blks; i += uspi->s_fpb) {\n\t\tsize = uspi->s_bsize;\n\t\tif (i + uspi->s_fpb > blks)\n\t\t\tsize = (blks - i) * uspi->s_fsize;\n\n\t\tubh = ubh_bread(sb, uspi->s_csaddr + i, size);\n\t\t\n\t\tif (!ubh)\n\t\t\tgoto failed;\n\n\t\tubh_ubhcpymem (space, ubh, size);\n\n\t\tspace += size;\n\t\tubh_brelse (ubh);\n\t\tubh = NULL;\n\t}\n\n\t/*\n\t * Read cylinder group (we read only first fragment from block\n\t * at this time) and prepare internal data structures for cg caching.\n\t */\n\tif (!(sbi->s_ucg = kmalloc (sizeof(struct buffer_head *) * uspi->s_ncg, GFP_NOFS)))\n\t\tgoto failed;\n\tfor (i = 0; i < uspi->s_ncg; i++) \n\t\tsbi->s_ucg[i] = NULL;\n\tfor (i = 0; i < UFS_MAX_GROUP_LOADED; i++) {\n\t\tsbi->s_ucpi[i] = NULL;\n\t\tsbi->s_cgno[i] = UFS_CGNO_EMPTY;\n\t}\n\tfor (i = 0; i < uspi->s_ncg; i++) {\n\t\tUFSD(\"read cg %u\\n\", i);\n\t\tif (!(sbi->s_ucg[i] = sb_bread(sb, ufs_cgcmin(i))))\n\t\t\tgoto failed;\n\t\tif (!ufs_cg_chkmagic (sb, (struct ufs_cylinder_group *) sbi->s_ucg[i]->b_data))\n\t\t\tgoto failed;\n\n\t\tufs_print_cylinder_stuff(sb, (struct ufs_cylinder_group *) sbi->s_ucg[i]->b_data);\n\t}\n\tfor (i = 0; i < UFS_MAX_GROUP_LOADED; i++) {\n\t\tif (!(sbi->s_ucpi[i] = kmalloc (sizeof(struct ufs_cg_private_info), GFP_NOFS)))\n\t\t\tgoto failed;\n\t\tsbi->s_cgno[i] = UFS_CGNO_EMPTY;\n\t}\n\tsbi->s_cg_loaded = 0;\n\tUFSD(\"EXIT\\n\");\n\treturn 1;\n\nfailed:\n\tkfree (base);\n\tif (sbi->s_ucg) {\n\t\tfor (i = 0; i < uspi->s_ncg; i++)\n\t\t\tif (sbi->s_ucg[i])\n\t\t\t\tbrelse (sbi->s_ucg[i]);\n\t\tkfree (sbi->s_ucg);\n\t\tfor (i = 0; i < UFS_MAX_GROUP_LOADED; i++)\n\t\t\tkfree (sbi->s_ucpi[i]);\n\t}\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "ufs_setup_cstotal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "483-512",
    "snippet": "static void ufs_setup_cstotal(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info *uspi = sbi->s_uspi;\n\tstruct ufs_super_block_first *usb1;\n\tstruct ufs_super_block_second *usb2;\n\tstruct ufs_super_block_third *usb3;\n\tunsigned mtype = sbi->s_mount_opt & UFS_MOUNT_UFSTYPE;\n\n\tUFSD(\"ENTER, mtype=%u\\n\", mtype);\n\tusb1 = ubh_get_usb_first(uspi);\n\tusb2 = ubh_get_usb_second(uspi);\n\tusb3 = ubh_get_usb_third(uspi);\n\n\tif ((mtype == UFS_MOUNT_UFSTYPE_44BSD &&\n\t     (usb1->fs_flags & UFS_FLAGS_UPDATED)) ||\n\t    mtype == UFS_MOUNT_UFSTYPE_UFS2) {\n\t\t/*we have statistic in different place, then usual*/\n\t\tuspi->cs_total.cs_ndir = fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_ndir);\n\t\tuspi->cs_total.cs_nbfree = fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_nbfree);\n\t\tuspi->cs_total.cs_nifree = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nifree);\n\t\tuspi->cs_total.cs_nffree = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nffree);\n\t} else {\n\t\tuspi->cs_total.cs_ndir = fs32_to_cpu(sb, usb1->fs_cstotal.cs_ndir);\n\t\tuspi->cs_total.cs_nbfree = fs32_to_cpu(sb, usb1->fs_cstotal.cs_nbfree);\n\t\tuspi->cs_total.cs_nifree = fs32_to_cpu(sb, usb1->fs_cstotal.cs_nifree);\n\t\tuspi->cs_total.cs_nffree = fs32_to_cpu(sb, usb1->fs_cstotal.cs_nffree);\n\t}\n\tUFSD(\"EXIT\\n\");\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT\\n\""
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sb",
            "usb1->fs_cstotal.cs_nffree"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "43-50",
          "snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs64_to_cpu",
          "args": [
            "sb",
            "usb3->fs_un1.fs_u2.cs_nffree"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "fs64_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "25-32",
          "snippet": "static inline u64\nfs64_to_cpu(struct super_block *sbp, __fs64 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64\nfs64_to_cpu(struct super_block *sbp, __fs64 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_get_usb_third",
          "args": [
            "uspi"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_get_usb_second",
          "args": [
            "uspi"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_get_usb_first",
          "args": [
            "uspi"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER, mtype=%u\\n\"",
            "mtype"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic void ufs_setup_cstotal(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info *uspi = sbi->s_uspi;\n\tstruct ufs_super_block_first *usb1;\n\tstruct ufs_super_block_second *usb2;\n\tstruct ufs_super_block_third *usb3;\n\tunsigned mtype = sbi->s_mount_opt & UFS_MOUNT_UFSTYPE;\n\n\tUFSD(\"ENTER, mtype=%u\\n\", mtype);\n\tusb1 = ubh_get_usb_first(uspi);\n\tusb2 = ubh_get_usb_second(uspi);\n\tusb3 = ubh_get_usb_third(uspi);\n\n\tif ((mtype == UFS_MOUNT_UFSTYPE_44BSD &&\n\t     (usb1->fs_flags & UFS_FLAGS_UPDATED)) ||\n\t    mtype == UFS_MOUNT_UFSTYPE_UFS2) {\n\t\t/*we have statistic in different place, then usual*/\n\t\tuspi->cs_total.cs_ndir = fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_ndir);\n\t\tuspi->cs_total.cs_nbfree = fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_nbfree);\n\t\tuspi->cs_total.cs_nifree = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nifree);\n\t\tuspi->cs_total.cs_nffree = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nffree);\n\t} else {\n\t\tuspi->cs_total.cs_ndir = fs32_to_cpu(sb, usb1->fs_cstotal.cs_ndir);\n\t\tuspi->cs_total.cs_nbfree = fs32_to_cpu(sb, usb1->fs_cstotal.cs_nbfree);\n\t\tuspi->cs_total.cs_nifree = fs32_to_cpu(sb, usb1->fs_cstotal.cs_nifree);\n\t\tuspi->cs_total.cs_nffree = fs32_to_cpu(sb, usb1->fs_cstotal.cs_nffree);\n\t}\n\tUFSD(\"EXIT\\n\");\n}"
  },
  {
    "function_name": "ufs_parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "396-476",
    "snippet": "static int ufs_parse_options (char * options, unsigned * mount_options)\n{\n\tchar * p;\n\t\n\tUFSD(\"ENTER\\n\");\n\t\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_type_old:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_OLD);\n\t\t\tbreak;\n\t\tcase Opt_type_sunx86:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_SUNx86);\n\t\t\tbreak;\n\t\tcase Opt_type_sun:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_SUN);\n\t\t\tbreak;\n\t\tcase Opt_type_sunos:\n\t\t\tufs_clear_opt(*mount_options, UFSTYPE);\n\t\t\tufs_set_opt(*mount_options, UFSTYPE_SUNOS);\n\t\t\tbreak;\n\t\tcase Opt_type_44bsd:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_44BSD);\n\t\t\tbreak;\n\t\tcase Opt_type_ufs2:\n\t\t\tufs_clear_opt(*mount_options, UFSTYPE);\n\t\t\tufs_set_opt(*mount_options, UFSTYPE_UFS2);\n\t\t\tbreak;\n\t\tcase Opt_type_hp:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_HP);\n\t\t\tbreak;\n\t\tcase Opt_type_nextstepcd:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_NEXTSTEP_CD);\n\t\t\tbreak;\n\t\tcase Opt_type_nextstep:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_NEXTSTEP);\n\t\t\tbreak;\n\t\tcase Opt_type_openstep:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_OPENSTEP);\n\t\t\tbreak;\n\t\tcase Opt_onerror_panic:\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_onerror_lock:\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_LOCK);\n\t\t\tbreak;\n\t\tcase Opt_onerror_umount:\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_UMOUNT);\n\t\t\tbreak;\n\t\tcase Opt_onerror_repair:\n\t\t\tpr_err(\"Unable to do repair on error, will lock lock instead\\n\");\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_REPAIR);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Invalid option: \\\"%s\\\" or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t tokens = {\n\t{Opt_type_old, \"ufstype=old\"},\n\t{Opt_type_sunx86, \"ufstype=sunx86\"},\n\t{Opt_type_sun, \"ufstype=sun\"},\n\t{Opt_type_sunos, \"ufstype=sunos\"},\n\t{Opt_type_44bsd, \"ufstype=44bsd\"},\n\t{Opt_type_ufs2, \"ufstype=ufs2\"},\n\t{Opt_type_ufs2, \"ufstype=5xbsd\"},\n\t{Opt_type_hp, \"ufstype=hp\"},\n\t{Opt_type_nextstepcd, \"ufstype=nextstep-cd\"},\n\t{Opt_type_nextstep, \"ufstype=nextstep\"},\n\t{Opt_type_openstep, \"ufstype=openstep\"},\n/*end of possible ufs types */\n\t{Opt_onerror_panic, \"onerror=panic\"},\n\t{Opt_onerror_lock, \"onerror=lock\"},\n\t{Opt_onerror_umount, \"onerror=umount\"},\n\t{Opt_onerror_repair, \"onerror=repair\"},\n\t{Opt_err, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Invalid option: \\\"%s\\\" or missing value\\n\"",
            "p"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_set_opt",
          "args": [
            "*mount_options",
            "ONERROR_REPAIR"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_clear_opt",
          "args": [
            "*mount_options",
            "ONERROR"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unable to do repair on error, will lock lock instead\\n\""
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_set_opt",
          "args": [
            "*mount_options",
            "ONERROR_UMOUNT"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_clear_opt",
          "args": [
            "*mount_options",
            "ONERROR"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_set_opt",
          "args": [
            "*mount_options",
            "ONERROR_LOCK"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_clear_opt",
          "args": [
            "*mount_options",
            "ONERROR"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_set_opt",
          "args": [
            "*mount_options",
            "ONERROR_PANIC"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_clear_opt",
          "args": [
            "*mount_options",
            "ONERROR"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_set_opt",
          "args": [
            "*mount_options",
            "UFSTYPE_OPENSTEP"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_clear_opt",
          "args": [
            "*mount_options",
            "UFSTYPE"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_set_opt",
          "args": [
            "*mount_options",
            "UFSTYPE_NEXTSTEP"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_clear_opt",
          "args": [
            "*mount_options",
            "UFSTYPE"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_set_opt",
          "args": [
            "*mount_options",
            "UFSTYPE_NEXTSTEP_CD"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_clear_opt",
          "args": [
            "*mount_options",
            "UFSTYPE"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_set_opt",
          "args": [
            "*mount_options",
            "UFSTYPE_HP"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_clear_opt",
          "args": [
            "*mount_options",
            "UFSTYPE"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_set_opt",
          "args": [
            "*mount_options",
            "UFSTYPE_UFS2"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_clear_opt",
          "args": [
            "*mount_options",
            "UFSTYPE"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_set_opt",
          "args": [
            "*mount_options",
            "UFSTYPE_44BSD"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_clear_opt",
          "args": [
            "*mount_options",
            "UFSTYPE"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_set_opt",
          "args": [
            "*mount_options",
            "UFSTYPE_SUNOS"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_clear_opt",
          "args": [
            "*mount_options",
            "UFSTYPE"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_set_opt",
          "args": [
            "*mount_options",
            "UFSTYPE_SUN"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_clear_opt",
          "args": [
            "*mount_options",
            "UFSTYPE"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_set_opt",
          "args": [
            "*mount_options",
            "UFSTYPE_SUNx86"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_clear_opt",
          "args": [
            "*mount_options",
            "UFSTYPE"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_set_opt",
          "args": [
            "*mount_options",
            "UFSTYPE_OLD"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_clear_opt",
          "args": [
            "*mount_options",
            "UFSTYPE"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER\\n\""
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_type_old, \"ufstype=old\"},\n\t{Opt_type_sunx86, \"ufstype=sunx86\"},\n\t{Opt_type_sun, \"ufstype=sun\"},\n\t{Opt_type_sunos, \"ufstype=sunos\"},\n\t{Opt_type_44bsd, \"ufstype=44bsd\"},\n\t{Opt_type_ufs2, \"ufstype=ufs2\"},\n\t{Opt_type_ufs2, \"ufstype=5xbsd\"},\n\t{Opt_type_hp, \"ufstype=hp\"},\n\t{Opt_type_nextstepcd, \"ufstype=nextstep-cd\"},\n\t{Opt_type_nextstep, \"ufstype=nextstep\"},\n\t{Opt_type_openstep, \"ufstype=openstep\"},\n/*end of possible ufs types */\n\t{Opt_onerror_panic, \"onerror=panic\"},\n\t{Opt_onerror_lock, \"onerror=lock\"},\n\t{Opt_onerror_umount, \"onerror=umount\"},\n\t{Opt_onerror_repair, \"onerror=repair\"},\n\t{Opt_err, NULL}\n};\n\nstatic int ufs_parse_options (char * options, unsigned * mount_options)\n{\n\tchar * p;\n\t\n\tUFSD(\"ENTER\\n\");\n\t\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_type_old:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_OLD);\n\t\t\tbreak;\n\t\tcase Opt_type_sunx86:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_SUNx86);\n\t\t\tbreak;\n\t\tcase Opt_type_sun:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_SUN);\n\t\t\tbreak;\n\t\tcase Opt_type_sunos:\n\t\t\tufs_clear_opt(*mount_options, UFSTYPE);\n\t\t\tufs_set_opt(*mount_options, UFSTYPE_SUNOS);\n\t\t\tbreak;\n\t\tcase Opt_type_44bsd:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_44BSD);\n\t\t\tbreak;\n\t\tcase Opt_type_ufs2:\n\t\t\tufs_clear_opt(*mount_options, UFSTYPE);\n\t\t\tufs_set_opt(*mount_options, UFSTYPE_UFS2);\n\t\t\tbreak;\n\t\tcase Opt_type_hp:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_HP);\n\t\t\tbreak;\n\t\tcase Opt_type_nextstepcd:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_NEXTSTEP_CD);\n\t\t\tbreak;\n\t\tcase Opt_type_nextstep:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_NEXTSTEP);\n\t\t\tbreak;\n\t\tcase Opt_type_openstep:\n\t\t\tufs_clear_opt (*mount_options, UFSTYPE);\n\t\t\tufs_set_opt (*mount_options, UFSTYPE_OPENSTEP);\n\t\t\tbreak;\n\t\tcase Opt_onerror_panic:\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_onerror_lock:\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_LOCK);\n\t\t\tbreak;\n\t\tcase Opt_onerror_umount:\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_UMOUNT);\n\t\t\tbreak;\n\t\tcase Opt_onerror_repair:\n\t\t\tpr_err(\"Unable to do repair on error, will lock lock instead\\n\");\n\t\t\tufs_clear_opt (*mount_options, ONERROR);\n\t\t\tufs_set_opt (*mount_options, ONERROR_REPAIR);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Invalid option: \\\"%s\\\" or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "ufs_warning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "344-356",
    "snippet": "void ufs_warning (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"(device %s): %s: %pV\\n\"",
            "sb->s_id",
            "function",
            "&vaf"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_warning (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}"
  },
  {
    "function_name": "ufs_panic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "319-342",
    "snippet": "void ufs_panic (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tsb->s_flags |= MS_RDONLY;\n\tpr_crit(\"panic (device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"panic (device %s): %s: %pV\\n\"",
            "sb->s_id",
            "function",
            "&vaf"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_mark_sb_dirty",
          "args": [
            "sb"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_mark_sb_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "732-744",
          "snippet": "void ufs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tunsigned long delay;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tunsigned long delay;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_mark_buffer_dirty",
          "args": [
            "USPI_UBH(uspi)"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "92-99",
          "snippet": "void ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USPI_UBH",
          "args": [
            "uspi"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "USPI_UBH",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "26-29",
          "snippet": "static inline struct ufs_buffer_head *USPI_UBH(struct ufs_sb_private_info *spi)\n{\n\treturn &spi->s_ubh;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse (struct ufs_buffer_head *);",
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);",
            "extern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);",
            "extern void ubh_sync_block(struct ufs_buffer_head *);",
            "extern void ubh_bforget (struct ufs_buffer_head *);",
            "extern int  ubh_buffer_dirty (struct ufs_buffer_head *);",
            "extern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);",
            "extern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\nstatic inline struct ufs_buffer_head *USPI_UBH(struct ufs_sb_private_info *spi)\n{\n\treturn &spi->s_ubh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_get_usb_first",
          "args": [
            "uspi"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_panic (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tsb->s_flags |= MS_RDONLY;\n\tpr_crit(\"panic (device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}"
  },
  {
    "function_name": "ufs_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "285-317",
    "snippet": "void ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"error (device %s): %s: %pV\\n\"",
            "sb->s_id",
            "function",
            "&vaf"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"panic (device %s): %s: %pV\\n\"",
            "sb->s_id",
            "function",
            "&vaf"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "319-342",
          "snippet": "void ufs_panic (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tsb->s_flags |= MS_RDONLY;\n\tpr_crit(\"panic (device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_panic (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tsb->s_flags |= MS_RDONLY;\n\tpr_crit(\"panic (device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_mark_sb_dirty",
          "args": [
            "sb"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_mark_sb_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "732-744",
          "snippet": "void ufs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tunsigned long delay;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tunsigned long delay;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_mark_buffer_dirty",
          "args": [
            "USPI_UBH(uspi)"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "92-99",
          "snippet": "void ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USPI_UBH",
          "args": [
            "uspi"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "USPI_UBH",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "26-29",
          "snippet": "static inline struct ufs_buffer_head *USPI_UBH(struct ufs_sb_private_info *spi)\n{\n\treturn &spi->s_ubh;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse (struct ufs_buffer_head *);",
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);",
            "extern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);",
            "extern void ubh_sync_block(struct ufs_buffer_head *);",
            "extern void ubh_bforget (struct ufs_buffer_head *);",
            "extern int  ubh_buffer_dirty (struct ufs_buffer_head *);",
            "extern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);",
            "extern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\nstatic inline struct ufs_buffer_head *USPI_UBH(struct ufs_sb_private_info *spi)\n{\n\treturn &spi->s_ubh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_get_usb_first",
          "args": [
            "uspi"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}"
  },
  {
    "function_name": "ufs_print_cylinder_stuff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "242-277",
    "snippet": "static void ufs_print_cylinder_stuff(struct super_block *sb,\n\t\t\t\t     struct ufs_cylinder_group *cg)\n{\n\tpr_debug(\"\\nufs_print_cylinder_stuff\\n\");\n\tpr_debug(\"size of ucg: %zu\\n\", sizeof(struct ufs_cylinder_group));\n\tpr_debug(\"  magic:        %x\\n\", fs32_to_cpu(sb, cg->cg_magic));\n\tpr_debug(\"  time:         %u\\n\", fs32_to_cpu(sb, cg->cg_time));\n\tpr_debug(\"  cgx:          %u\\n\", fs32_to_cpu(sb, cg->cg_cgx));\n\tpr_debug(\"  ncyl:         %u\\n\", fs16_to_cpu(sb, cg->cg_ncyl));\n\tpr_debug(\"  niblk:        %u\\n\", fs16_to_cpu(sb, cg->cg_niblk));\n\tpr_debug(\"  ndblk:        %u\\n\", fs32_to_cpu(sb, cg->cg_ndblk));\n\tpr_debug(\"  cs_ndir:      %u\\n\", fs32_to_cpu(sb, cg->cg_cs.cs_ndir));\n\tpr_debug(\"  cs_nbfree:    %u\\n\", fs32_to_cpu(sb, cg->cg_cs.cs_nbfree));\n\tpr_debug(\"  cs_nifree:    %u\\n\", fs32_to_cpu(sb, cg->cg_cs.cs_nifree));\n\tpr_debug(\"  cs_nffree:    %u\\n\", fs32_to_cpu(sb, cg->cg_cs.cs_nffree));\n\tpr_debug(\"  rotor:        %u\\n\", fs32_to_cpu(sb, cg->cg_rotor));\n\tpr_debug(\"  frotor:       %u\\n\", fs32_to_cpu(sb, cg->cg_frotor));\n\tpr_debug(\"  irotor:       %u\\n\", fs32_to_cpu(sb, cg->cg_irotor));\n\tpr_debug(\"  frsum:        %u, %u, %u, %u, %u, %u, %u, %u\\n\",\n\t    fs32_to_cpu(sb, cg->cg_frsum[0]), fs32_to_cpu(sb, cg->cg_frsum[1]),\n\t    fs32_to_cpu(sb, cg->cg_frsum[2]), fs32_to_cpu(sb, cg->cg_frsum[3]),\n\t    fs32_to_cpu(sb, cg->cg_frsum[4]), fs32_to_cpu(sb, cg->cg_frsum[5]),\n\t    fs32_to_cpu(sb, cg->cg_frsum[6]), fs32_to_cpu(sb, cg->cg_frsum[7]));\n\tpr_debug(\"  btotoff:      %u\\n\", fs32_to_cpu(sb, cg->cg_btotoff));\n\tpr_debug(\"  boff:         %u\\n\", fs32_to_cpu(sb, cg->cg_boff));\n\tpr_debug(\"  iuseoff:      %u\\n\", fs32_to_cpu(sb, cg->cg_iusedoff));\n\tpr_debug(\"  freeoff:      %u\\n\", fs32_to_cpu(sb, cg->cg_freeoff));\n\tpr_debug(\"  nextfreeoff:  %u\\n\", fs32_to_cpu(sb, cg->cg_nextfreeoff));\n\tpr_debug(\"  clustersumoff %u\\n\",\n\t\t fs32_to_cpu(sb, cg->cg_u.cg_44.cg_clustersumoff));\n\tpr_debug(\"  clusteroff    %u\\n\",\n\t\t fs32_to_cpu(sb, cg->cg_u.cg_44.cg_clusteroff));\n\tpr_debug(\"  nclusterblks  %u\\n\",\n\t\t fs32_to_cpu(sb, cg->cg_u.cg_44.cg_nclusterblks));\n\tpr_debug(\"\\n\");\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"\\n\""
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  nclusterblks  %u\\n\"",
            "fs32_to_cpu(sb, cg->cg_u.cg_44.cg_nclusterblks)"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sb",
            "cg->cg_u.cg_44.cg_nclusterblks"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "43-50",
          "snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  clusteroff    %u\\n\"",
            "fs32_to_cpu(sb, cg->cg_u.cg_44.cg_clusteroff)"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  clustersumoff %u\\n\"",
            "fs32_to_cpu(sb, cg->cg_u.cg_44.cg_clustersumoff)"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  nextfreeoff:  %u\\n\"",
            "fs32_to_cpu(sb, cg->cg_nextfreeoff)"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  freeoff:      %u\\n\"",
            "fs32_to_cpu(sb, cg->cg_freeoff)"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  iuseoff:      %u\\n\"",
            "fs32_to_cpu(sb, cg->cg_iusedoff)"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  boff:         %u\\n\"",
            "fs32_to_cpu(sb, cg->cg_boff)"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  btotoff:      %u\\n\"",
            "fs32_to_cpu(sb, cg->cg_btotoff)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  frsum:        %u, %u, %u, %u, %u, %u, %u, %u\\n\"",
            "fs32_to_cpu(sb, cg->cg_frsum[0])",
            "fs32_to_cpu(sb, cg->cg_frsum[1])",
            "fs32_to_cpu(sb, cg->cg_frsum[2])",
            "fs32_to_cpu(sb, cg->cg_frsum[3])",
            "fs32_to_cpu(sb, cg->cg_frsum[4])",
            "fs32_to_cpu(sb, cg->cg_frsum[5])",
            "fs32_to_cpu(sb, cg->cg_frsum[6])",
            "fs32_to_cpu(sb, cg->cg_frsum[7])"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  irotor:       %u\\n\"",
            "fs32_to_cpu(sb, cg->cg_irotor)"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  frotor:       %u\\n\"",
            "fs32_to_cpu(sb, cg->cg_frotor)"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  rotor:        %u\\n\"",
            "fs32_to_cpu(sb, cg->cg_rotor)"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  cs_nffree:    %u\\n\"",
            "fs32_to_cpu(sb, cg->cg_cs.cs_nffree)"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  cs_nifree:    %u\\n\"",
            "fs32_to_cpu(sb, cg->cg_cs.cs_nifree)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  cs_nbfree:    %u\\n\"",
            "fs32_to_cpu(sb, cg->cg_cs.cs_nbfree)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  cs_ndir:      %u\\n\"",
            "fs32_to_cpu(sb, cg->cg_cs.cs_ndir)"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  ndblk:        %u\\n\"",
            "fs32_to_cpu(sb, cg->cg_ndblk)"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  niblk:        %u\\n\"",
            "fs16_to_cpu(sb, cg->cg_niblk)"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs16_to_cpu",
          "args": [
            "sb",
            "cg->cg_niblk"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "fs16_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "79-86",
          "snippet": "static inline u16\nfs16_to_cpu(struct super_block *sbp, __fs16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u16\nfs16_to_cpu(struct super_block *sbp, __fs16 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  ncyl:         %u\\n\"",
            "fs16_to_cpu(sb, cg->cg_ncyl)"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  cgx:          %u\\n\"",
            "fs32_to_cpu(sb, cg->cg_cgx)"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  time:         %u\\n\"",
            "fs32_to_cpu(sb, cg->cg_time)"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  magic:        %x\\n\"",
            "fs32_to_cpu(sb, cg->cg_magic)"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"size of ucg: %zu\\n\"",
            "sizeof(struct ufs_cylinder_group)"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"\\nufs_print_cylinder_stuff\\n\""
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic void ufs_print_cylinder_stuff(struct super_block *sb,\n\t\t\t\t     struct ufs_cylinder_group *cg)\n{\n\tpr_debug(\"\\nufs_print_cylinder_stuff\\n\");\n\tpr_debug(\"size of ucg: %zu\\n\", sizeof(struct ufs_cylinder_group));\n\tpr_debug(\"  magic:        %x\\n\", fs32_to_cpu(sb, cg->cg_magic));\n\tpr_debug(\"  time:         %u\\n\", fs32_to_cpu(sb, cg->cg_time));\n\tpr_debug(\"  cgx:          %u\\n\", fs32_to_cpu(sb, cg->cg_cgx));\n\tpr_debug(\"  ncyl:         %u\\n\", fs16_to_cpu(sb, cg->cg_ncyl));\n\tpr_debug(\"  niblk:        %u\\n\", fs16_to_cpu(sb, cg->cg_niblk));\n\tpr_debug(\"  ndblk:        %u\\n\", fs32_to_cpu(sb, cg->cg_ndblk));\n\tpr_debug(\"  cs_ndir:      %u\\n\", fs32_to_cpu(sb, cg->cg_cs.cs_ndir));\n\tpr_debug(\"  cs_nbfree:    %u\\n\", fs32_to_cpu(sb, cg->cg_cs.cs_nbfree));\n\tpr_debug(\"  cs_nifree:    %u\\n\", fs32_to_cpu(sb, cg->cg_cs.cs_nifree));\n\tpr_debug(\"  cs_nffree:    %u\\n\", fs32_to_cpu(sb, cg->cg_cs.cs_nffree));\n\tpr_debug(\"  rotor:        %u\\n\", fs32_to_cpu(sb, cg->cg_rotor));\n\tpr_debug(\"  frotor:       %u\\n\", fs32_to_cpu(sb, cg->cg_frotor));\n\tpr_debug(\"  irotor:       %u\\n\", fs32_to_cpu(sb, cg->cg_irotor));\n\tpr_debug(\"  frsum:        %u, %u, %u, %u, %u, %u, %u, %u\\n\",\n\t    fs32_to_cpu(sb, cg->cg_frsum[0]), fs32_to_cpu(sb, cg->cg_frsum[1]),\n\t    fs32_to_cpu(sb, cg->cg_frsum[2]), fs32_to_cpu(sb, cg->cg_frsum[3]),\n\t    fs32_to_cpu(sb, cg->cg_frsum[4]), fs32_to_cpu(sb, cg->cg_frsum[5]),\n\t    fs32_to_cpu(sb, cg->cg_frsum[6]), fs32_to_cpu(sb, cg->cg_frsum[7]));\n\tpr_debug(\"  btotoff:      %u\\n\", fs32_to_cpu(sb, cg->cg_btotoff));\n\tpr_debug(\"  boff:         %u\\n\", fs32_to_cpu(sb, cg->cg_boff));\n\tpr_debug(\"  iuseoff:      %u\\n\", fs32_to_cpu(sb, cg->cg_iusedoff));\n\tpr_debug(\"  freeoff:      %u\\n\", fs32_to_cpu(sb, cg->cg_freeoff));\n\tpr_debug(\"  nextfreeoff:  %u\\n\", fs32_to_cpu(sb, cg->cg_nextfreeoff));\n\tpr_debug(\"  clustersumoff %u\\n\",\n\t\t fs32_to_cpu(sb, cg->cg_u.cg_44.cg_clustersumoff));\n\tpr_debug(\"  clusteroff    %u\\n\",\n\t\t fs32_to_cpu(sb, cg->cg_u.cg_44.cg_clusteroff));\n\tpr_debug(\"  nclusterblks  %u\\n\",\n\t\t fs32_to_cpu(sb, cg->cg_u.cg_44.cg_nclusterblks));\n\tpr_debug(\"\\n\");\n}"
  },
  {
    "function_name": "ufs_print_super_stuff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "163-237",
    "snippet": "static void ufs_print_super_stuff(struct super_block *sb,\n\t\t\t\t  struct ufs_super_block_first *usb1,\n\t\t\t\t  struct ufs_super_block_second *usb2,\n\t\t\t\t  struct ufs_super_block_third *usb3)\n{\n\tu32 magic = fs32_to_cpu(sb, usb3->fs_magic);\n\n\tpr_debug(\"ufs_print_super_stuff\\n\");\n\tpr_debug(\"  magic:     0x%x\\n\", magic);\n\tif (fs32_to_cpu(sb, usb3->fs_magic) == UFS2_MAGIC) {\n\t\tpr_debug(\"  fs_size:   %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_size));\n\t\tpr_debug(\"  fs_dsize:  %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_dsize));\n\t\tpr_debug(\"  bsize:         %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_bsize));\n\t\tpr_debug(\"  fsize:         %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_fsize));\n\t\tpr_debug(\"  fs_volname:  %s\\n\", usb2->fs_un.fs_u2.fs_volname);\n\t\tpr_debug(\"  fs_sblockloc: %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb2->fs_un.fs_u2.fs_sblockloc));\n\t\tpr_debug(\"  cs_ndir(No of dirs):  %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_ndir));\n\t\tpr_debug(\"  cs_nbfree(No of free blocks):  %llu\\n\",\n\t\t\t (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_nbfree));\n\t\tpr_info(\"  cs_nifree(Num of free inodes): %llu\\n\",\n\t\t\t(unsigned long long)\n\t\t\tfs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nifree));\n\t\tpr_info(\"  cs_nffree(Num of free frags): %llu\\n\",\n\t\t\t(unsigned long long)\n\t\t\tfs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nffree));\n\t\tpr_info(\"  fs_maxsymlinklen: %u\\n\",\n\t\t\tfs32_to_cpu(sb, usb3->fs_un2.fs_44.fs_maxsymlinklen));\n\t} else {\n\t\tpr_debug(\" sblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_sblkno));\n\t\tpr_debug(\" cblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_cblkno));\n\t\tpr_debug(\" iblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_iblkno));\n\t\tpr_debug(\" dblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_dblkno));\n\t\tpr_debug(\" cgoffset:    %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cgoffset));\n\t\tpr_debug(\" ~cgmask:     0x%x\\n\",\n\t\t\t ~fs32_to_cpu(sb, usb1->fs_cgmask));\n\t\tpr_debug(\" size:        %u\\n\", fs32_to_cpu(sb, usb1->fs_size));\n\t\tpr_debug(\" dsize:       %u\\n\", fs32_to_cpu(sb, usb1->fs_dsize));\n\t\tpr_debug(\" ncg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_ncg));\n\t\tpr_debug(\" bsize:       %u\\n\", fs32_to_cpu(sb, usb1->fs_bsize));\n\t\tpr_debug(\" fsize:       %u\\n\", fs32_to_cpu(sb, usb1->fs_fsize));\n\t\tpr_debug(\" frag:        %u\\n\", fs32_to_cpu(sb, usb1->fs_frag));\n\t\tpr_debug(\" fragshift:   %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_fragshift));\n\t\tpr_debug(\" ~fmask:      %u\\n\", ~fs32_to_cpu(sb, usb1->fs_fmask));\n\t\tpr_debug(\" fshift:      %u\\n\", fs32_to_cpu(sb, usb1->fs_fshift));\n\t\tpr_debug(\" sbsize:      %u\\n\", fs32_to_cpu(sb, usb1->fs_sbsize));\n\t\tpr_debug(\" spc:         %u\\n\", fs32_to_cpu(sb, usb1->fs_spc));\n\t\tpr_debug(\" cpg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_cpg));\n\t\tpr_debug(\" ipg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_ipg));\n\t\tpr_debug(\" fpg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_fpg));\n\t\tpr_debug(\" csaddr:      %u\\n\", fs32_to_cpu(sb, usb1->fs_csaddr));\n\t\tpr_debug(\" cssize:      %u\\n\", fs32_to_cpu(sb, usb1->fs_cssize));\n\t\tpr_debug(\" cgsize:      %u\\n\", fs32_to_cpu(sb, usb1->fs_cgsize));\n\t\tpr_debug(\" fstodb:      %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_fsbtodb));\n\t\tpr_debug(\" nrpos:       %u\\n\", fs32_to_cpu(sb, usb3->fs_nrpos));\n\t\tpr_debug(\" ndir         %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_ndir));\n\t\tpr_debug(\" nifree       %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_nifree));\n\t\tpr_debug(\" nbfree       %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_nbfree));\n\t\tpr_debug(\" nffree       %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_nffree));\n\t}\n\tpr_debug(\"\\n\");\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"\\n\""
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" nffree       %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_cstotal.cs_nffree)"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sb",
            "usb1->fs_cstotal.cs_nffree"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "43-50",
          "snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" nbfree       %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_cstotal.cs_nbfree)"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" nifree       %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_cstotal.cs_nifree)"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" ndir         %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_cstotal.cs_ndir)"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" nrpos:       %u\\n\"",
            "fs32_to_cpu(sb, usb3->fs_nrpos)"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" fstodb:      %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_fsbtodb)"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" cgsize:      %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_cgsize)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" cssize:      %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_cssize)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" csaddr:      %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_csaddr)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" fpg:         %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_fpg)"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" ipg:         %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_ipg)"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" cpg:         %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_cpg)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" spc:         %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_spc)"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" sbsize:      %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_sbsize)"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" fshift:      %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_fshift)"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" ~fmask:      %u\\n\"",
            "~fs32_to_cpu(sb, usb1->fs_fmask)"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" fragshift:   %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_fragshift)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" frag:        %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_frag)"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" fsize:       %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_fsize)"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" bsize:       %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_bsize)"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" ncg:         %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_ncg)"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" dsize:       %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_dsize)"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" size:        %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_size)"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" ~cgmask:     0x%x\\n\"",
            "~fs32_to_cpu(sb, usb1->fs_cgmask)"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" cgoffset:    %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_cgoffset)"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" dblkno:      %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_dblkno)"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" iblkno:      %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_iblkno)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" cblkno:      %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_cblkno)"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" sblkno:      %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_sblkno)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"  fs_maxsymlinklen: %u\\n\"",
            "fs32_to_cpu(sb, usb3->fs_un2.fs_44.fs_maxsymlinklen)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"  cs_nffree(Num of free frags): %llu\\n\"",
            "(unsigned long long)\n\t\t\tfs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nffree)"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs64_to_cpu",
          "args": [
            "sb",
            "usb3->fs_un1.fs_u2.cs_nffree"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "fs64_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "25-32",
          "snippet": "static inline u64\nfs64_to_cpu(struct super_block *sbp, __fs64 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64\nfs64_to_cpu(struct super_block *sbp, __fs64 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"  cs_nifree(Num of free inodes): %llu\\n\"",
            "(unsigned long long)\n\t\t\tfs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nifree)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  cs_nbfree(No of free blocks):  %llu\\n\"",
            "(unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_nbfree)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  cs_ndir(No of dirs):  %llu\\n\"",
            "(unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_ndir)"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  fs_sblockloc: %llu\\n\"",
            "(unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb2->fs_un.fs_u2.fs_sblockloc)"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  fs_volname:  %s\\n\"",
            "usb2->fs_un.fs_u2.fs_volname"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  fsize:         %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_fsize)"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  bsize:         %u\\n\"",
            "fs32_to_cpu(sb, usb1->fs_bsize)"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  fs_dsize:  %llu\\n\"",
            "(unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_dsize)"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  fs_size:   %llu\\n\"",
            "(unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_size)"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  magic:     0x%x\\n\"",
            "magic"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"ufs_print_super_stuff\\n\""
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic void ufs_print_super_stuff(struct super_block *sb,\n\t\t\t\t  struct ufs_super_block_first *usb1,\n\t\t\t\t  struct ufs_super_block_second *usb2,\n\t\t\t\t  struct ufs_super_block_third *usb3)\n{\n\tu32 magic = fs32_to_cpu(sb, usb3->fs_magic);\n\n\tpr_debug(\"ufs_print_super_stuff\\n\");\n\tpr_debug(\"  magic:     0x%x\\n\", magic);\n\tif (fs32_to_cpu(sb, usb3->fs_magic) == UFS2_MAGIC) {\n\t\tpr_debug(\"  fs_size:   %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_size));\n\t\tpr_debug(\"  fs_dsize:  %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_dsize));\n\t\tpr_debug(\"  bsize:         %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_bsize));\n\t\tpr_debug(\"  fsize:         %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_fsize));\n\t\tpr_debug(\"  fs_volname:  %s\\n\", usb2->fs_un.fs_u2.fs_volname);\n\t\tpr_debug(\"  fs_sblockloc: %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb2->fs_un.fs_u2.fs_sblockloc));\n\t\tpr_debug(\"  cs_ndir(No of dirs):  %llu\\n\", (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_ndir));\n\t\tpr_debug(\"  cs_nbfree(No of free blocks):  %llu\\n\",\n\t\t\t (unsigned long long)\n\t\t\t fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_nbfree));\n\t\tpr_info(\"  cs_nifree(Num of free inodes): %llu\\n\",\n\t\t\t(unsigned long long)\n\t\t\tfs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nifree));\n\t\tpr_info(\"  cs_nffree(Num of free frags): %llu\\n\",\n\t\t\t(unsigned long long)\n\t\t\tfs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nffree));\n\t\tpr_info(\"  fs_maxsymlinklen: %u\\n\",\n\t\t\tfs32_to_cpu(sb, usb3->fs_un2.fs_44.fs_maxsymlinklen));\n\t} else {\n\t\tpr_debug(\" sblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_sblkno));\n\t\tpr_debug(\" cblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_cblkno));\n\t\tpr_debug(\" iblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_iblkno));\n\t\tpr_debug(\" dblkno:      %u\\n\", fs32_to_cpu(sb, usb1->fs_dblkno));\n\t\tpr_debug(\" cgoffset:    %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cgoffset));\n\t\tpr_debug(\" ~cgmask:     0x%x\\n\",\n\t\t\t ~fs32_to_cpu(sb, usb1->fs_cgmask));\n\t\tpr_debug(\" size:        %u\\n\", fs32_to_cpu(sb, usb1->fs_size));\n\t\tpr_debug(\" dsize:       %u\\n\", fs32_to_cpu(sb, usb1->fs_dsize));\n\t\tpr_debug(\" ncg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_ncg));\n\t\tpr_debug(\" bsize:       %u\\n\", fs32_to_cpu(sb, usb1->fs_bsize));\n\t\tpr_debug(\" fsize:       %u\\n\", fs32_to_cpu(sb, usb1->fs_fsize));\n\t\tpr_debug(\" frag:        %u\\n\", fs32_to_cpu(sb, usb1->fs_frag));\n\t\tpr_debug(\" fragshift:   %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_fragshift));\n\t\tpr_debug(\" ~fmask:      %u\\n\", ~fs32_to_cpu(sb, usb1->fs_fmask));\n\t\tpr_debug(\" fshift:      %u\\n\", fs32_to_cpu(sb, usb1->fs_fshift));\n\t\tpr_debug(\" sbsize:      %u\\n\", fs32_to_cpu(sb, usb1->fs_sbsize));\n\t\tpr_debug(\" spc:         %u\\n\", fs32_to_cpu(sb, usb1->fs_spc));\n\t\tpr_debug(\" cpg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_cpg));\n\t\tpr_debug(\" ipg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_ipg));\n\t\tpr_debug(\" fpg:         %u\\n\", fs32_to_cpu(sb, usb1->fs_fpg));\n\t\tpr_debug(\" csaddr:      %u\\n\", fs32_to_cpu(sb, usb1->fs_csaddr));\n\t\tpr_debug(\" cssize:      %u\\n\", fs32_to_cpu(sb, usb1->fs_cssize));\n\t\tpr_debug(\" cgsize:      %u\\n\", fs32_to_cpu(sb, usb1->fs_cgsize));\n\t\tpr_debug(\" fstodb:      %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_fsbtodb));\n\t\tpr_debug(\" nrpos:       %u\\n\", fs32_to_cpu(sb, usb3->fs_nrpos));\n\t\tpr_debug(\" ndir         %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_ndir));\n\t\tpr_debug(\" nifree       %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_nifree));\n\t\tpr_debug(\" nbfree       %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_nbfree));\n\t\tpr_debug(\" nffree       %u\\n\",\n\t\t\t fs32_to_cpu(sb, usb1->fs_cstotal.cs_nffree));\n\t}\n\tpr_debug(\"\\n\");\n}"
  },
  {
    "function_name": "ufs_get_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "142-151",
    "snippet": "static struct dentry *ufs_get_parent(struct dentry *child)\n{\n\tstruct qstr dot_dot = QSTR_INIT(\"..\", 2);\n\tino_t ino;\n\n\tino = ufs_inode_by_name(child->d_inode, &dot_dot);\n\tif (!ino)\n\t\treturn ERR_PTR(-ENOENT);\n\treturn d_obtain_alias(ufs_iget(child->d_inode->i_sb, ino));\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "ufs_iget(child->d_inode->i_sb, ino)"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1977-1980",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_iget",
          "args": [
            "child->d_inode->i_sb",
            "ino"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
          "lines": "682-743",
          "snippet": "struct inode *ufs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ufs_inode_info *ufsi;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct buffer_head * bh;\n\tstruct inode *inode;\n\tint err;\n\n\tUFSD(\"ENTER, ino %lu\\n\", ino);\n\n\tif (ino < UFS_ROOTINO || ino > (uspi->s_ncg * uspi->s_ipg)) {\n\t\tufs_warning(sb, \"ufs_read_inode\", \"bad inode number (%lu)\\n\",\n\t\t\t    ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tufsi = UFS_I(inode);\n\n\tbh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));\n\tif (!bh) {\n\t\tufs_warning(sb, \"ufs_read_inode\", \"unable to read inode %lu\\n\",\n\t\t\t    inode->i_ino);\n\t\tgoto bad_inode;\n\t}\n\tif ((UFS_SB(sb)->s_flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2) {\n\t\tstruct ufs2_inode *ufs2_inode = (struct ufs2_inode *)bh->b_data;\n\n\t\terr = ufs2_read_inode(inode,\n\t\t\t\t      ufs2_inode + ufs_inotofsbo(inode->i_ino));\n\t} else {\n\t\tstruct ufs_inode *ufs_inode = (struct ufs_inode *)bh->b_data;\n\n\t\terr = ufs1_read_inode(inode,\n\t\t\t\t      ufs_inode + ufs_inotofsbo(inode->i_ino));\n\t}\n\n\tif (err)\n\t\tgoto bad_inode;\n\tinode->i_version++;\n\tufsi->i_lastfrag =\n\t\t(inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\tufsi->i_dir_start_lookup = 0;\n\tufsi->i_osync = 0;\n\n\tufs_set_inode_ops(inode);\n\n\tbrelse(bh);\n\n\tUFSD(\"EXIT\\n\");\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstruct inode *ufs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ufs_inode_info *ufsi;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct buffer_head * bh;\n\tstruct inode *inode;\n\tint err;\n\n\tUFSD(\"ENTER, ino %lu\\n\", ino);\n\n\tif (ino < UFS_ROOTINO || ino > (uspi->s_ncg * uspi->s_ipg)) {\n\t\tufs_warning(sb, \"ufs_read_inode\", \"bad inode number (%lu)\\n\",\n\t\t\t    ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tufsi = UFS_I(inode);\n\n\tbh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));\n\tif (!bh) {\n\t\tufs_warning(sb, \"ufs_read_inode\", \"unable to read inode %lu\\n\",\n\t\t\t    inode->i_ino);\n\t\tgoto bad_inode;\n\t}\n\tif ((UFS_SB(sb)->s_flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2) {\n\t\tstruct ufs2_inode *ufs2_inode = (struct ufs2_inode *)bh->b_data;\n\n\t\terr = ufs2_read_inode(inode,\n\t\t\t\t      ufs2_inode + ufs_inotofsbo(inode->i_ino));\n\t} else {\n\t\tstruct ufs_inode *ufs_inode = (struct ufs_inode *)bh->b_data;\n\n\t\terr = ufs1_read_inode(inode,\n\t\t\t\t      ufs_inode + ufs_inotofsbo(inode->i_ino));\n\t}\n\n\tif (err)\n\t\tgoto bad_inode;\n\tinode->i_version++;\n\tufsi->i_lastfrag =\n\t\t(inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\tufsi->i_dir_start_lookup = 0;\n\tufsi->i_osync = 0;\n\n\tufs_set_inode_ops(inode);\n\n\tbrelse(bh);\n\n\tUFSD(\"EXIT\\n\");\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_inode_by_name",
          "args": [
            "child->d_inode",
            "&dot_dot"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_inode_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/dir.c",
          "lines": "73-85",
          "snippet": "ino_t ufs_inode_by_name(struct inode *dir, const struct qstr *qstr)\n{\n\tino_t res = 0;\n\tstruct ufs_dir_entry *de;\n\tstruct page *page;\n\t\n\tde = ufs_find_entry(dir, qstr, &page);\n\tif (de) {\n\t\tres = fs32_to_cpu(dir->i_sb, de->d_ino);\n\t\tufs_put_page(page);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nino_t ufs_inode_by_name(struct inode *dir, const struct qstr *qstr)\n{\n\tino_t res = 0;\n\tstruct ufs_dir_entry *de;\n\tstruct page *page;\n\t\n\tde = ufs_find_entry(dir, qstr, &page);\n\tif (de) {\n\t\tres = fs32_to_cpu(dir->i_sb, de->d_ino);\n\t\tufs_put_page(page);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QSTR_INIT",
          "args": [
            "\"..\"",
            "2"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic struct dentry *ufs_get_parent(struct dentry *child)\n{\n\tstruct qstr dot_dot = QSTR_INIT(\"..\", 2);\n\tino_t ino;\n\n\tino = ufs_inode_by_name(child->d_inode, &dot_dot);\n\tif (!ino)\n\t\treturn ERR_PTR(-ENOENT);\n\treturn d_obtain_alias(ufs_iget(child->d_inode->i_sb, ino));\n}"
  },
  {
    "function_name": "ufs_fh_to_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "136-140",
    "snippet": "static struct dentry *ufs_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\t\t\t       int fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type, ufs_nfs_get_inode);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fh_to_parent",
          "args": [
            "sb",
            "fid",
            "fh_len",
            "fh_type",
            "ufs_nfs_get_inode"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fh_to_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "906-923",
          "snippet": "struct dentry *generic_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len <= 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t  (fh_len > 3 ? fid->i32.parent_gen : 0));\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct dentry *generic_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len <= 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t  (fh_len > 3 ? fid->i32.parent_gen : 0));\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic struct dentry *ufs_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\t\t\t       int fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type, ufs_nfs_get_inode);\n}"
  },
  {
    "function_name": "ufs_fh_to_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "130-134",
    "snippet": "static struct dentry *ufs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\t\t\t       int fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type, ufs_nfs_get_inode);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fh_to_dentry",
          "args": [
            "sb",
            "fid",
            "fh_len",
            "fh_type",
            "ufs_nfs_get_inode"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fh_to_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "873-890",
          "snippet": "struct dentry *generic_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct dentry *generic_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic struct dentry *ufs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\t\t\t       int fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type, ufs_nfs_get_inode);\n}"
  },
  {
    "function_name": "ufs_nfs_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "112-128",
    "snippet": "static struct inode *ufs_nfs_get_inode(struct super_block *sb, u64 ino, u32 generation)\n{\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct inode *inode;\n\n\tif (ino < UFS_ROOTINO || ino > uspi->s_ncg * uspi->s_ipg)\n\t\treturn ERR_PTR(-ESTALE);\n\n\tinode = ufs_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (generation && inode->i_generation != generation) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_iget",
          "args": [
            "sb",
            "ino"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/inode.c",
          "lines": "682-743",
          "snippet": "struct inode *ufs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ufs_inode_info *ufsi;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct buffer_head * bh;\n\tstruct inode *inode;\n\tint err;\n\n\tUFSD(\"ENTER, ino %lu\\n\", ino);\n\n\tif (ino < UFS_ROOTINO || ino > (uspi->s_ncg * uspi->s_ipg)) {\n\t\tufs_warning(sb, \"ufs_read_inode\", \"bad inode number (%lu)\\n\",\n\t\t\t    ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tufsi = UFS_I(inode);\n\n\tbh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));\n\tif (!bh) {\n\t\tufs_warning(sb, \"ufs_read_inode\", \"unable to read inode %lu\\n\",\n\t\t\t    inode->i_ino);\n\t\tgoto bad_inode;\n\t}\n\tif ((UFS_SB(sb)->s_flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2) {\n\t\tstruct ufs2_inode *ufs2_inode = (struct ufs2_inode *)bh->b_data;\n\n\t\terr = ufs2_read_inode(inode,\n\t\t\t\t      ufs2_inode + ufs_inotofsbo(inode->i_ino));\n\t} else {\n\t\tstruct ufs_inode *ufs_inode = (struct ufs_inode *)bh->b_data;\n\n\t\terr = ufs1_read_inode(inode,\n\t\t\t\t      ufs_inode + ufs_inotofsbo(inode->i_ino));\n\t}\n\n\tif (err)\n\t\tgoto bad_inode;\n\tinode->i_version++;\n\tufsi->i_lastfrag =\n\t\t(inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\tufsi->i_dir_start_lookup = 0;\n\tufsi->i_osync = 0;\n\n\tufs_set_inode_ops(inode);\n\n\tbrelse(bh);\n\n\tUFSD(\"EXIT\\n\");\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstruct inode *ufs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ufs_inode_info *ufsi;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct buffer_head * bh;\n\tstruct inode *inode;\n\tint err;\n\n\tUFSD(\"ENTER, ino %lu\\n\", ino);\n\n\tif (ino < UFS_ROOTINO || ino > (uspi->s_ncg * uspi->s_ipg)) {\n\t\tufs_warning(sb, \"ufs_read_inode\", \"bad inode number (%lu)\\n\",\n\t\t\t    ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tufsi = UFS_I(inode);\n\n\tbh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));\n\tif (!bh) {\n\t\tufs_warning(sb, \"ufs_read_inode\", \"unable to read inode %lu\\n\",\n\t\t\t    inode->i_ino);\n\t\tgoto bad_inode;\n\t}\n\tif ((UFS_SB(sb)->s_flags & UFS_TYPE_MASK) == UFS_TYPE_UFS2) {\n\t\tstruct ufs2_inode *ufs2_inode = (struct ufs2_inode *)bh->b_data;\n\n\t\terr = ufs2_read_inode(inode,\n\t\t\t\t      ufs2_inode + ufs_inotofsbo(inode->i_ino));\n\t} else {\n\t\tstruct ufs_inode *ufs_inode = (struct ufs_inode *)bh->b_data;\n\n\t\terr = ufs1_read_inode(inode,\n\t\t\t\t      ufs_inode + ufs_inotofsbo(inode->i_ino));\n\t}\n\n\tif (err)\n\t\tgoto bad_inode;\n\tinode->i_version++;\n\tufsi->i_lastfrag =\n\t\t(inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift;\n\tufsi->i_dir_start_lookup = 0;\n\tufsi->i_osync = 0;\n\n\tufs_set_inode_ops(inode);\n\n\tbrelse(bh);\n\n\tUFSD(\"EXIT\\n\");\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nstatic struct inode *ufs_nfs_get_inode(struct super_block *sb, u64 ino, u32 generation)\n{\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tstruct inode *inode;\n\n\tif (ino < UFS_ROOTINO || ino > uspi->s_ncg * uspi->s_ipg)\n\t\treturn ERR_PTR(-ESTALE);\n\n\tinode = ufs_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (generation && inode->i_generation != generation) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\treturn inode;\n}"
  },
  {
    "function_name": "unlock_ufs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "104-110",
    "snippet": "void unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->mutex"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}"
  },
  {
    "function_name": "lock_ufs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
    "lines": "96-102",
    "snippet": "void lock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tmutex_lock(&sbi->mutex);\n\tsbi->mutex_owner = current;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>",
      "#include <stdarg.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->mutex"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid lock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tmutex_lock(&sbi->mutex);\n\tsbi->mutex_owner = current;\n}"
  }
]