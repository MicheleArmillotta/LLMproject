[
  {
    "function_name": "ng_exit(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "3101-3104",
    "snippet": "bugging_exit(struct ubifs_info *c)\n{\n\tkfree(c->dbg);\n}",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ";\n}",
          "args": [],
          "line": 3103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nbugging_exit(struct ubifs_info *c)\n{\n\tkfree(c->dbg);\n}"
  },
  {
    "function_name": "ng_init(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "3088-3095",
    "snippet": "ugging_init(struct ubifs_info *c)\n{\n\tc->dbg = kzalloc(sizeof(struct ubifs_debug_info), GFP_KERNEL);\n\tif (!c->dbg)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f(struc",
          "args": [
            "ubifs_debug_info), GFP_KERNEL)",
            "if (!c->d"
          ],
          "line": 3090
        },
        "resolved": true,
        "details": {
          "function_name": "f(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
          "lines": "71-96",
          "snippet": "wbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt",
          "includes": [
            "fs.h\"\n\nstatic int d"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic int d\n\nwbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt"
        }
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nugging_init(struct ubifs_info *c)\n{\n\tc->dbg = kzalloc(sizeof(struct ubifs_debug_info), GFP_KERNEL);\n\tif (!c->dbg)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "xit(void)\n{\n\tif",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "3074-3078",
    "snippet": "gfs_exit(void)\n{\n\tif (IS_ENABLED(CONFIG_DEBUG_FS))\n\t\tdebugfs_remove_recursive(dfs_rootdir);\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [
      "dentry *dfs_rootdir;\n\nstatic int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "e_recursive(dfs_rootdir)",
          "args": [
            "}\n\n/**\n *"
          ],
          "line": 3077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFIG_DEBUG",
          "args": [
            "FS))\n\t\tdebugfs_"
          ],
          "line": 3076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\ndentry *dfs_rootdir;\n\nstatic int;\n\ngfs_exit(void)\n{\n\tif (IS_ENABLED(CONFIG_DEBUG_FS))\n\t\tdebugfs_remove_recursive(dfs_rootdir);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "nit(void)\n{\n\tint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "3003-3069",
    "snippet": "fs_init(void)\n{\n\tint err;\n\tconst char *fname;\n\tstruct dentry *dent;\n\n\tif (!IS_ENABLED(CONFIG_DEBUG_FS))\n\t\treturn 0;\n\n\tfname = \"ubifs\";\n\tdent = debugfs_create_dir(fname, NULL);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out;\n\tdfs_rootdir = dent;\n\n\tfname = \"chk_general\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, dfs_rootdir, NULL,\n\t\t\t\t   &dfs_global_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\tdfs_chk_gen = dent;\n\n\tfname = \"chk_index\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, dfs_rootdir, NULL,\n\t\t\t\t   &dfs_global_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\tdfs_chk_index = dent;\n\n\tfname = \"chk_orphans\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, dfs_rootdir, NULL,\n\t\t\t\t   &dfs_global_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\tdfs_chk_orph = dent;\n\n\tfname = \"chk_lprops\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, dfs_rootdir, NULL,\n\t\t\t\t   &dfs_global_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\tdfs_chk_lprops = dent;\n\n\tfname = \"chk_fs\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, dfs_rootdir, NULL,\n\t\t\t\t   &dfs_global_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\tdfs_chk_fs = dent;\n\n\tfname = \"tst_recovery\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, dfs_rootdir, NULL,\n\t\t\t\t   &dfs_global_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\tdfs_tst_rcvry = dent;\n\n\treturn 0;\n\nout_remove:\n\tdebugfs_remove_recursive(dfs_rootdir);\nout:\n\terr = dent ? PTR_ERR(dent) : -ENODEV;\n\tubifs_err(\"cannot create \\\"%s\\\" debugfs file or directory, error %d\\n\",\n\t\t  fname, err);\n\treturn err;\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [
      "dentry *dfs_rootdir;\n\nstatic int",
      "struct file_operations dfs_global_fops = {\n\t.read = dfs_global_file_read,\n\t.write = dfs_global_file_write,\n\t.owner = THIS_MODULE,\n\t.llseek = no_llseek,\n};\n\n/**\n * dbg_"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nnot crea",
          "args": [
            "e \\\"%s\\\" debugfs file or directory, error %d\\n\",\n\t\t  fname,",
            "retu",
            "er"
          ],
          "line": 3066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ": -ENO",
          "args": [
            "EV;"
          ],
          "line": 3065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_recursive(dfs_rootdir)",
          "args": [
            "out:\n\terr"
          ],
          "line": 3063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L(dent))\n\t\tgot",
          "args": [
            "out"
          ],
          "line": 3056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_file(fname, S_IRU",
          "args": [
            "R | S",
            "WUSR, dfs_rootdir",
            "NULL,",
            "&dfs",
            "ops);\n\tif (IS_ER"
          ],
          "line": 3054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L(dent))\n\t\tgot",
          "args": [
            "out"
          ],
          "line": 3049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_file(fname, S_IRU",
          "args": [
            "R | S",
            "WUSR, dfs_rootdir",
            "NULL,",
            "&dfs",
            "ops);\n\tif (IS_ER"
          ],
          "line": 3047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L(dent))\n\t\tgot",
          "args": [
            "out"
          ],
          "line": 3042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_file(fname, S_IRU",
          "args": [
            "R | S",
            "WUSR, dfs_rootdir",
            "NULL,",
            "&dfs",
            "ops);\n\tif (IS_ER"
          ],
          "line": 3040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L(dent))\n\t\tgot",
          "args": [
            "out"
          ],
          "line": 3035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_file(fname, S_IRU",
          "args": [
            "R | S",
            "WUSR, dfs_rootdir",
            "NULL,",
            "&dfs",
            "ops);\n\tif (IS_ER"
          ],
          "line": 3033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L(dent))\n\t\tgot",
          "args": [
            "out"
          ],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_file(fname, S_IRU",
          "args": [
            "R | S",
            "WUSR, dfs_rootdir",
            "NULL,",
            "&dfs",
            "ops);\n\tif (IS_ER"
          ],
          "line": 3026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L(dent))\n\t\tgot",
          "args": [
            "out"
          ],
          "line": 3021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_file(fname, S_IRU",
          "args": [
            "R | S",
            "WUSR, dfs_rootdir",
            "NULL,",
            "&dfs",
            "ops);\n\tif (IS_ER"
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L(dent))\n\t\tgot",
          "args": [
            "out"
          ],
          "line": 3014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_dir(fname, NULL)",
          "args": [
            "if",
            "S_ER"
          ],
          "line": 3013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFIG_DEBUG",
          "args": [
            "FS))\n\t\treturn 0"
          ],
          "line": 3009
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\ndentry *dfs_rootdir;\n\nstatic int;\nstruct file_operations dfs_global_fops = {\n\t.read = dfs_global_file_read,\n\t.write = dfs_global_file_write,\n\t.owner = THIS_MODULE,\n\t.llseek = no_llseek,\n};\n\n/**\n * dbg_;\n\nfs_init(void)\n{\n\tint err;\n\tconst char *fname;\n\tstruct dentry *dent;\n\n\tif (!IS_ENABLED(CONFIG_DEBUG_FS))\n\t\treturn 0;\n\n\tfname = \"ubifs\";\n\tdent = debugfs_create_dir(fname, NULL);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out;\n\tdfs_rootdir = dent;\n\n\tfname = \"chk_general\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, dfs_rootdir, NULL,\n\t\t\t\t   &dfs_global_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\tdfs_chk_gen = dent;\n\n\tfname = \"chk_index\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, dfs_rootdir, NULL,\n\t\t\t\t   &dfs_global_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\tdfs_chk_index = dent;\n\n\tfname = \"chk_orphans\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, dfs_rootdir, NULL,\n\t\t\t\t   &dfs_global_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\tdfs_chk_orph = dent;\n\n\tfname = \"chk_lprops\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, dfs_rootdir, NULL,\n\t\t\t\t   &dfs_global_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\tdfs_chk_lprops = dent;\n\n\tfname = \"chk_fs\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, dfs_rootdir, NULL,\n\t\t\t\t   &dfs_global_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\tdfs_chk_fs = dent;\n\n\tfname = \"tst_recovery\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, dfs_rootdir, NULL,\n\t\t\t\t   &dfs_global_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\tdfs_tst_rcvry = dent;\n\n\treturn 0;\n\nout_remove:\n\tdebugfs_remove_recursive(dfs_rootdir);\nout:\n\terr = dent ? PTR_ERR(dent) : -ENODEV;\n\tubifs_err(\"cannot create \\\"%s\\\" debugfs file or directory, error %d\\n\",\n\t\t  fname, err);\n\treturn err;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "le_write(struct file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "2960-2986",
    "snippet": "t dfs_global_file_write(struct file *file, const char __user *u,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct dentry *dent = file->f_path.dentry;\n\tint val;\n\n\tval = interpret_user_input(u, count);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (dent == dfs_chk_gen)\n\t\tubifs_dbg.chk_gen = val;\n\telse if (dent == dfs_chk_index)\n\t\tubifs_dbg.chk_index = val;\n\telse if (dent == dfs_chk_orph)\n\t\tubifs_dbg.chk_orph = val;\n\telse if (dent == dfs_chk_lprops)\n\t\tubifs_dbg.chk_lprops = val;\n\telse if (dent == dfs_chk_fs)\n\t\tubifs_dbg.chk_fs = val;\n\telse if (dent == dfs_tst_rcvry)\n\t\tubifs_dbg.tst_rcvry = val;\n\telse\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\nstatic cons",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [
      "_SPINLOCK(dbg_lock);\n\nstatic cons"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "r_input(u, count);",
          "args": [
            "f",
            "val <"
          ],
          "line": 2966
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\n_SPINLOCK(dbg_lock);\n\nstatic cons;\n\nt dfs_global_file_write(struct file *file, const char __user *u,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct dentry *dent = file->f_path.dentry;\n\tint val;\n\n\tval = interpret_user_input(u, count);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (dent == dfs_chk_gen)\n\t\tubifs_dbg.chk_gen = val;\n\telse if (dent == dfs_chk_index)\n\t\tubifs_dbg.chk_index = val;\n\telse if (dent == dfs_chk_orph)\n\t\tubifs_dbg.chk_orph = val;\n\telse if (dent == dfs_chk_lprops)\n\t\tubifs_dbg.chk_lprops = val;\n\telse if (dent == dfs_chk_fs)\n\t\tubifs_dbg.chk_fs = val;\n\telse if (dent == dfs_tst_rcvry)\n\t\tubifs_dbg.tst_rcvry = val;\n\telse\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\nstatic cons"
  },
  {
    "function_name": "le_read(struct file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "2936-2958",
    "snippet": "t dfs_global_file_read(struct file *file, char __user *u,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct dentry *dent = file->f_path.dentry;\n\tint val;\n\n\tif (dent == dfs_chk_gen)\n\t\tval = ubifs_dbg.chk_gen;\n\telse if (dent == dfs_chk_index)\n\t\tval = ubifs_dbg.chk_index;\n\telse if (dent == dfs_chk_orph)\n\t\tval = ubifs_dbg.chk_orph;\n\telse if (dent == dfs_chk_lprops)\n\t\tval = ubifs_dbg.chk_lprops;\n\telse if (dent == dfs_chk_fs)\n\t\tval = ubifs_dbg.chk_fs;\n\telse if (dent == dfs_tst_rcvry)\n\t\tval = ubifs_dbg.tst_rcvry;\n\telse\n\t\treturn -EINVAL;\n\n\treturn provide_user_output(val, u, count, ppos);\n}\n\nstatic ssiz",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [
      "dentry *dfs_tst_rcvry;\n\nstatic ssiz"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "output(val, u, coun",
          "args": [
            ", p",
            "s",
            "}\n\ns",
            "tic"
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\ndentry *dfs_tst_rcvry;\n\nstatic ssiz;\n\nt dfs_global_file_read(struct file *file, char __user *u,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct dentry *dent = file->f_path.dentry;\n\tint val;\n\n\tif (dent == dfs_chk_gen)\n\t\tval = ubifs_dbg.chk_gen;\n\telse if (dent == dfs_chk_index)\n\t\tval = ubifs_dbg.chk_index;\n\telse if (dent == dfs_chk_orph)\n\t\tval = ubifs_dbg.chk_orph;\n\telse if (dent == dfs_chk_lprops)\n\t\tval = ubifs_dbg.chk_lprops;\n\telse if (dent == dfs_chk_fs)\n\t\tval = ubifs_dbg.chk_fs;\n\telse if (dent == dfs_tst_rcvry)\n\t\tval = ubifs_dbg.tst_rcvry;\n\telse\n\t\treturn -EINVAL;\n\n\treturn provide_user_output(val, u, count, ppos);\n}\n\nstatic ssiz"
  },
  {
    "function_name": "xit_fs(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "2921-2925",
    "snippet": "gfs_exit_fs(struct ubifs_info *c)\n{\n\tif (IS_ENABLED(CONFIG_DEBUG_FS))\n\t\tdebugfs_remove_recursive(c->dbg->dfs_dir);\n}\n\nstruct ubif",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "e_recursive(c->dbg->dfs_",
          "args": [
            "ir);\n}\n\nstruct"
          ],
          "line": 2924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFIG_DEBUG",
          "args": [
            "FS))\n\t\tdebugfs_"
          ],
          "line": 2923
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\ngfs_exit_fs(struct ubifs_info *c)\n{\n\tif (IS_ENABLED(CONFIG_DEBUG_FS))\n\t\tdebugfs_remove_recursive(c->dbg->dfs_dir);\n}\n\nstruct ubif"
  },
  {
    "function_name": "nit_fs(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "2814-2915",
    "snippet": "fs_init_fs(struct ubifs_info *c)\n{\n\tint err, n;\n\tconst char *fname;\n\tstruct dentry *dent;\n\tstruct ubifs_debug_info *d = c->dbg;\n\n\tif (!IS_ENABLED(CONFIG_DEBUG_FS))\n\t\treturn 0;\n\n\tn = snprintf(d->dfs_dir_name, UBIFS_DFS_DIR_LEN + 1, UBIFS_DFS_DIR_NAME,\n\t\t     c->vi.ubi_num, c->vi.vol_id);\n\tif (n == UBIFS_DFS_DIR_LEN) {\n\t\t/* The array size is too small */\n\t\tfname = UBIFS_DFS_DIR_NAME;\n\t\tdent = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tfname = d->dfs_dir_name;\n\tdent = debugfs_create_dir(fname, dfs_rootdir);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out;\n\td->dfs_dir = dent;\n\n\tfname = \"dump_lprops\";\n\tdent = debugfs_create_file(fname, S_IWUSR, d->dfs_dir, c, &dfs_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\td->dfs_dump_lprops = dent;\n\n\tfname = \"dump_budg\";\n\tdent = debugfs_create_file(fname, S_IWUSR, d->dfs_dir, c, &dfs_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\td->dfs_dump_budg = dent;\n\n\tfname = \"dump_tnc\";\n\tdent = debugfs_create_file(fname, S_IWUSR, d->dfs_dir, c, &dfs_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\td->dfs_dump_tnc = dent;\n\n\tfname = \"chk_general\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, d->dfs_dir, c,\n\t\t\t\t   &dfs_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\td->dfs_chk_gen = dent;\n\n\tfname = \"chk_index\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, d->dfs_dir, c,\n\t\t\t\t   &dfs_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\td->dfs_chk_index = dent;\n\n\tfname = \"chk_orphans\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, d->dfs_dir, c,\n\t\t\t\t   &dfs_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\td->dfs_chk_orph = dent;\n\n\tfname = \"chk_lprops\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, d->dfs_dir, c,\n\t\t\t\t   &dfs_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\td->dfs_chk_lprops = dent;\n\n\tfname = \"chk_fs\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, d->dfs_dir, c,\n\t\t\t\t   &dfs_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\td->dfs_chk_fs = dent;\n\n\tfname = \"tst_recovery\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, d->dfs_dir, c,\n\t\t\t\t   &dfs_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\td->dfs_tst_rcvry = dent;\n\n\tfname = \"ro_error\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, d->dfs_dir, c,\n\t\t\t\t   &dfs_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\td->dfs_ro_error = dent;\n\n\treturn 0;\n\nout_remove:\n\tdebugfs_remove_recursive(d->dfs_dir);\nout:\n\terr = dent ? PTR_ERR(dent) : -ENODEV;\n\tubifs_err(\"cannot create \\\"%s\\\" debugfs file or directory, error %d\\n\",\n\t\t  fname, err);\n\treturn err;\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [
      "dentry *dfs_rootdir;\n\nstatic int",
      "struct file_operations dfs_fops = {\n\t.open = dfs_file_open,\n\t.read = dfs_file_read,\n\t.write = dfs_file_write,\n\t.owner = THIS_MODULE,\n\t.llseek = no_llseek,\n};\n\n/**\n * dbg_"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nnot crea",
          "args": [
            "e \\\"%s\\\" debugfs file or directory, error %d\\n\",\n\t\t  fname,",
            "retu",
            "er"
          ],
          "line": 2912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ": -ENO",
          "args": [
            "EV;"
          ],
          "line": 2911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_recursive(d->dfs_dir);",
          "args": [
            "out:\n\terr"
          ],
          "line": 2909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L(dent))\n\t\tgot",
          "args": [
            "out"
          ],
          "line": 2902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_file(fname, S_IRU",
          "args": [
            "R | S",
            "WUSR, d->dfs_dir,",
            ",\n\t\t\t\t   &",
            "s",
            "if (IS_ER"
          ],
          "line": 2900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L(dent))\n\t\tgot",
          "args": [
            "out"
          ],
          "line": 2895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_file(fname, S_IRU",
          "args": [
            "R | S",
            "WUSR, d->dfs_dir,",
            ",\n\t\t\t\t   &",
            "s",
            "if (IS_ER"
          ],
          "line": 2893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L(dent))\n\t\tgot",
          "args": [
            "out"
          ],
          "line": 2888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_file(fname, S_IRU",
          "args": [
            "R | S",
            "WUSR, d->dfs_dir,",
            ",\n\t\t\t\t   &",
            "s",
            "if (IS_ER"
          ],
          "line": 2886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L(dent))\n\t\tgot",
          "args": [
            "out"
          ],
          "line": 2881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_file(fname, S_IRU",
          "args": [
            "R | S",
            "WUSR, d->dfs_dir,",
            ",\n\t\t\t\t   &",
            "s",
            "if (IS_ER"
          ],
          "line": 2879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L(dent))\n\t\tgot",
          "args": [
            "out"
          ],
          "line": 2874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_file(fname, S_IRU",
          "args": [
            "R | S",
            "WUSR, d->dfs_dir,",
            ",\n\t\t\t\t   &",
            "s",
            "if (IS_ER"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L(dent))\n\t\tgot",
          "args": [
            "out"
          ],
          "line": 2867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_file(fname, S_IRU",
          "args": [
            "R | S",
            "WUSR, d->dfs_dir,",
            ",\n\t\t\t\t   &",
            "s",
            "if (IS_ER"
          ],
          "line": 2865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L(dent))\n\t\tgot",
          "args": [
            "out"
          ],
          "line": 2860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_file(fname, S_IRU",
          "args": [
            "R | S",
            "WUSR, d->dfs_dir,",
            ",\n\t\t\t\t   &",
            "s",
            "if (IS_ER"
          ],
          "line": 2858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L(dent))\n\t\tgot",
          "args": [
            "out"
          ],
          "line": 2853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_file(fname, S_IWU",
          "args": [
            "R, d-",
            "fs_dir,",
            ", &dfs_fop",
            ";",
            "if (IS_ER"
          ],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L(dent))\n\t\tgot",
          "args": [
            "out"
          ],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_file(fname, S_IWU",
          "args": [
            "R, d-",
            "fs_dir,",
            ", &dfs_fop",
            ";",
            "if (IS_ER"
          ],
          "line": 2846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L(dent))\n\t\tgot",
          "args": [
            "out"
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_file(fname, S_IWU",
          "args": [
            "R, d-",
            "fs_dir,",
            ", &dfs_fop",
            ";",
            "if (IS_ER"
          ],
          "line": 2840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "L(dent))\n\t\tgot",
          "args": [
            "out"
          ],
          "line": 2835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_dir(fname, dfs_r",
          "args": [
            "otdir",
            "if (IS_ER"
          ],
          "line": 2834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AL);",
          "args": [
            "oto out"
          ],
          "line": 2829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_dir_n",
          "args": [
            "me, UBIFS_DFS_D",
            "_LEN + 1, UBIFS_DFS_D",
            "_NAME,\n\t\t     c->v",
            ", c->vi.vol_i",
            ";\n\tif (n =="
          ],
          "line": 2824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFIG_DEBUG",
          "args": [
            "FS))\n\t\treturn 0"
          ],
          "line": 2821
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\ndentry *dfs_rootdir;\n\nstatic int;\nstruct file_operations dfs_fops = {\n\t.open = dfs_file_open,\n\t.read = dfs_file_read,\n\t.write = dfs_file_write,\n\t.owner = THIS_MODULE,\n\t.llseek = no_llseek,\n};\n\n/**\n * dbg_;\n\nfs_init_fs(struct ubifs_info *c)\n{\n\tint err, n;\n\tconst char *fname;\n\tstruct dentry *dent;\n\tstruct ubifs_debug_info *d = c->dbg;\n\n\tif (!IS_ENABLED(CONFIG_DEBUG_FS))\n\t\treturn 0;\n\n\tn = snprintf(d->dfs_dir_name, UBIFS_DFS_DIR_LEN + 1, UBIFS_DFS_DIR_NAME,\n\t\t     c->vi.ubi_num, c->vi.vol_id);\n\tif (n == UBIFS_DFS_DIR_LEN) {\n\t\t/* The array size is too small */\n\t\tfname = UBIFS_DFS_DIR_NAME;\n\t\tdent = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tfname = d->dfs_dir_name;\n\tdent = debugfs_create_dir(fname, dfs_rootdir);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out;\n\td->dfs_dir = dent;\n\n\tfname = \"dump_lprops\";\n\tdent = debugfs_create_file(fname, S_IWUSR, d->dfs_dir, c, &dfs_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\td->dfs_dump_lprops = dent;\n\n\tfname = \"dump_budg\";\n\tdent = debugfs_create_file(fname, S_IWUSR, d->dfs_dir, c, &dfs_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\td->dfs_dump_budg = dent;\n\n\tfname = \"dump_tnc\";\n\tdent = debugfs_create_file(fname, S_IWUSR, d->dfs_dir, c, &dfs_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\td->dfs_dump_tnc = dent;\n\n\tfname = \"chk_general\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, d->dfs_dir, c,\n\t\t\t\t   &dfs_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\td->dfs_chk_gen = dent;\n\n\tfname = \"chk_index\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, d->dfs_dir, c,\n\t\t\t\t   &dfs_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\td->dfs_chk_index = dent;\n\n\tfname = \"chk_orphans\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, d->dfs_dir, c,\n\t\t\t\t   &dfs_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\td->dfs_chk_orph = dent;\n\n\tfname = \"chk_lprops\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, d->dfs_dir, c,\n\t\t\t\t   &dfs_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\td->dfs_chk_lprops = dent;\n\n\tfname = \"chk_fs\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, d->dfs_dir, c,\n\t\t\t\t   &dfs_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\td->dfs_chk_fs = dent;\n\n\tfname = \"tst_recovery\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, d->dfs_dir, c,\n\t\t\t\t   &dfs_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\td->dfs_tst_rcvry = dent;\n\n\tfname = \"ro_error\";\n\tdent = debugfs_create_file(fname, S_IRUSR | S_IWUSR, d->dfs_dir, c,\n\t\t\t\t   &dfs_fops);\n\tif (IS_ERR_OR_NULL(dent))\n\t\tgoto out_remove;\n\td->dfs_ro_error = dent;\n\n\treturn 0;\n\nout_remove:\n\tdebugfs_remove_recursive(d->dfs_dir);\nout:\n\terr = dent ? PTR_ERR(dent) : -ENODEV;\n\tubifs_err(\"cannot create \\\"%s\\\" debugfs file or directory, error %d\\n\",\n\t\t  fname, err);\n\treturn err;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "e(struct file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "2735-2792",
    "snippet": "t dfs_file_write(struct file *file, const char __user *u,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ubifs_info *c = file->private_data;\n\tstruct ubifs_debug_info *d = c->dbg;\n\tstruct dentry *dent = file->f_path.dentry;\n\tint val;\n\n\t/*\n\t * TODO: this is racy - the file-system might have already been\n\t * unmounted and we'd oops in this case. The plan is to fix it with\n\t * help of 'iterate_supers_type()' which we should have in v3.0: when\n\t * a debugfs opened, we rember FS's UUID in file->private_data. Then\n\t * whenever we access the FS via a debugfs file, we iterate all UBIFS\n\t * superblocks and fine the one with the same UUID, and take the\n\t * locking right.\n\t *\n\t * The other way to go suggested by Al Viro is to create a separate\n\t * 'ubifs-debug' file-system instead.\n\t */\n\tif (file->f_path.dentry == d->dfs_dump_lprops) {\n\t\tubifs_dump_lprops(c);\n\t\treturn count;\n\t}\n\tif (file->f_path.dentry == d->dfs_dump_budg) {\n\t\tubifs_dump_budg(c, &c->bi);\n\t\treturn count;\n\t}\n\tif (file->f_path.dentry == d->dfs_dump_tnc) {\n\t\tmutex_lock(&c->tnc_mutex);\n\t\tubifs_dump_tnc(c);\n\t\tmutex_unlock(&c->tnc_mutex);\n\t\treturn count;\n\t}\n\n\tval = interpret_user_input(u, count);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (dent == d->dfs_chk_gen)\n\t\td->chk_gen = val;\n\telse if (dent == d->dfs_chk_index)\n\t\td->chk_index = val;\n\telse if (dent == d->dfs_chk_orph)\n\t\td->chk_orph = val;\n\telse if (dent == d->dfs_chk_lprops)\n\t\td->chk_lprops = val;\n\telse if (dent == d->dfs_chk_fs)\n\t\td->chk_fs = val;\n\telse if (dent == d->dfs_tst_rcvry)\n\t\td->tst_rcvry = val;\n\telse if (dent == d->dfs_ro_error)\n\t\tc->ro_error = !!val;\n\telse\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\nstatic cons",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [
      "_SPINLOCK(dbg_lock);\n\nstatic cons"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "r_input(u, count);",
          "args": [
            "f",
            "val <"
          ],
          "line": 2770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->tnc_mute",
          "args": [
            ");\n\t\treturn c"
          ],
          "line": 2766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c(c);\n\t\tmutex_",
          "args": [
            "n"
          ],
          "line": 2765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->tnc_mute",
          "args": [
            ");\n\t\tubifs_du"
          ],
          "line": 2764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dg(c, &c->bi);",
          "args": [
            "turn c"
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rops(c);\n\t\treturn",
          "args": [
            "c"
          ],
          "line": 2756
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\n_SPINLOCK(dbg_lock);\n\nstatic cons;\n\nt dfs_file_write(struct file *file, const char __user *u,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ubifs_info *c = file->private_data;\n\tstruct ubifs_debug_info *d = c->dbg;\n\tstruct dentry *dent = file->f_path.dentry;\n\tint val;\n\n\t/*\n\t * TODO: this is racy - the file-system might have already been\n\t * unmounted and we'd oops in this case. The plan is to fix it with\n\t * help of 'iterate_supers_type()' which we should have in v3.0: when\n\t * a debugfs opened, we rember FS's UUID in file->private_data. Then\n\t * whenever we access the FS via a debugfs file, we iterate all UBIFS\n\t * superblocks and fine the one with the same UUID, and take the\n\t * locking right.\n\t *\n\t * The other way to go suggested by Al Viro is to create a separate\n\t * 'ubifs-debug' file-system instead.\n\t */\n\tif (file->f_path.dentry == d->dfs_dump_lprops) {\n\t\tubifs_dump_lprops(c);\n\t\treturn count;\n\t}\n\tif (file->f_path.dentry == d->dfs_dump_budg) {\n\t\tubifs_dump_budg(c, &c->bi);\n\t\treturn count;\n\t}\n\tif (file->f_path.dentry == d->dfs_dump_tnc) {\n\t\tmutex_lock(&c->tnc_mutex);\n\t\tubifs_dump_tnc(c);\n\t\tmutex_unlock(&c->tnc_mutex);\n\t\treturn count;\n\t}\n\n\tval = interpret_user_input(u, count);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (dent == d->dfs_chk_gen)\n\t\td->chk_gen = val;\n\telse if (dent == d->dfs_chk_index)\n\t\td->chk_index = val;\n\telse if (dent == d->dfs_chk_orph)\n\t\td->chk_orph = val;\n\telse if (dent == d->dfs_chk_lprops)\n\t\td->chk_lprops = val;\n\telse if (dent == d->dfs_chk_fs)\n\t\td->chk_fs = val;\n\telse if (dent == d->dfs_tst_rcvry)\n\t\td->tst_rcvry = val;\n\telse if (dent == d->dfs_ro_error)\n\t\tc->ro_error = !!val;\n\telse\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\nstatic cons"
  },
  {
    "function_name": "r_input(const char _",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "2718-2733",
    "snippet": "terpret_user_input(const char __user *u, size_t count)\n{\n\tsize_t buf_size;\n\tchar buf[8];\n\n\tbuf_size = min_t(size_t, count, (sizeof(buf) - 1));\n\tif (copy_from_user(buf, u, buf_size))\n\t\treturn -EFAULT;\n\n\tif (buf[0] == '1')\n\t\treturn 1;\n\telse if (buf[0] == '0')\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic ssiz",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [
      "dentry *dfs_tst_rcvry;\n\nstatic ssiz"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "r(buf, u, buf_",
          "args": [
            "ize",
            "return -"
          ],
          "line": 2724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coun",
          "args": [
            ", (siz",
            "f(buf",
            "- 1));\n\tif (copy_"
          ],
          "line": 2723
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_refcount_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "490-496",
          "snippet": "void ocfs2_init_refcount_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_rb,\n\t\t\t\t NULL, &ocfs2_refcount_tree_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_refcount_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_refcount_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_refcount_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_refcount_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_refcount_tree_fill_root_el,\n\t.eo_extent_contig\t= ocfs2_refcount_tree_extent_contig,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_refcount_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_refcount_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_refcount_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_refcount_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_refcount_tree_fill_root_el,\n\t.eo_extent_contig\t= ocfs2_refcount_tree_extent_contig,\n};\n\nvoid ocfs2_init_refcount_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_rb,\n\t\t\t\t NULL, &ocfs2_refcount_tree_et_ops);\n}"
        }
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\ndentry *dfs_tst_rcvry;\n\nstatic ssiz;\n\nterpret_user_input(const char __user *u, size_t count)\n{\n\tsize_t buf_size;\n\tchar buf[8];\n\n\tbuf_size = min_t(size_t, count, (sizeof(buf) - 1));\n\tif (copy_from_user(buf, u, buf_size))\n\t\treturn -EFAULT;\n\n\tif (buf[0] == '1')\n\t\treturn 1;\n\telse if (buf[0] == '0')\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic ssiz"
  },
  {
    "function_name": "(struct file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "2681-2707",
    "snippet": "t dfs_file_read(struct file *file, char __user *u, size_t count,\n\t\t\t     loff_t *ppos)\n{\n\tstruct dentry *dent = file->f_path.dentry;\n\tstruct ubifs_info *c = file->private_data;\n\tstruct ubifs_debug_info *d = c->dbg;\n\tint val;\n\n\tif (dent == d->dfs_chk_gen)\n\t\tval = d->chk_gen;\n\telse if (dent == d->dfs_chk_index)\n\t\tval = d->chk_index;\n\telse if (dent == d->dfs_chk_orph)\n\t\tval = d->chk_orph;\n\telse if (dent == d->dfs_chk_lprops)\n\t\tval = d->chk_lprops;\n\telse if (dent == d->dfs_chk_fs)\n\t\tval = d->chk_fs;\n\telse if (dent == d->dfs_tst_rcvry)\n\t\tval = d->tst_rcvry;\n\telse if (dent == d->dfs_ro_error)\n\t\tval = c->ro_error;\n\telse\n\t\treturn -EINVAL;\n\n\treturn provide_user_output(val, u, count, ppos);\n}\n\n/**\n * inte",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "output(val, u, coun",
          "args": [
            ", p",
            "s",
            "}\n\n/",
            "*"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nt dfs_file_read(struct file *file, char __user *u, size_t count,\n\t\t\t     loff_t *ppos)\n{\n\tstruct dentry *dent = file->f_path.dentry;\n\tstruct ubifs_info *c = file->private_data;\n\tstruct ubifs_debug_info *d = c->dbg;\n\tint val;\n\n\tif (dent == d->dfs_chk_gen)\n\t\tval = d->chk_gen;\n\telse if (dent == d->dfs_chk_index)\n\t\tval = d->chk_index;\n\telse if (dent == d->dfs_chk_orph)\n\t\tval = d->chk_orph;\n\telse if (dent == d->dfs_chk_lprops)\n\t\tval = d->chk_lprops;\n\telse if (dent == d->dfs_chk_fs)\n\t\tval = d->chk_fs;\n\telse if (dent == d->dfs_tst_rcvry)\n\t\tval = d->tst_rcvry;\n\telse if (dent == d->dfs_ro_error)\n\t\tval = c->ro_error;\n\telse\n\t\treturn -EINVAL;\n\n\treturn provide_user_output(val, u, count, ppos);\n}\n\n/**\n * inte"
  },
  {
    "function_name": "output(int val, cha",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "2666-2679",
    "snippet": "ovide_user_output(int val, char __user *u, size_t count,\n\t\t\t       loff_t *ppos)\n{\n\tchar buf[3];\n\n\tif (val)\n\t\tbuf[0] = '1';\n\telse\n\t\tbuf[0] = '0';\n\tbuf[1] = '\\n';\n\tbuf[2] = 0x00;\n\n\treturn simple_read_from_buffer(u, count, ppos, buf, 2);\n}\n\nstatic ssiz",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [
      "dentry *dfs_tst_rcvry;\n\nstatic ssiz"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rom_buffer(u, count, pp",
          "args": [
            "s",
            "buf,",
            ";\n}",
            "tat"
          ],
          "line": 2678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\ndentry *dfs_tst_rcvry;\n\nstatic ssiz;\n\novide_user_output(int val, char __user *u, size_t count,\n\t\t\t       loff_t *ppos)\n{\n\tchar buf[3];\n\n\tif (val)\n\t\tbuf[0] = '1';\n\telse\n\t\tbuf[0] = '0';\n\tbuf[1] = '\\n';\n\tbuf[2] = 0x00;\n\n\treturn simple_read_from_buffer(u, count, ppos, buf, 2);\n}\n\nstatic ssiz"
  },
  {
    "function_name": "(struct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "2648-2652",
    "snippet": "s_file_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = inode->i_private;\n\treturn nonseekable_open(inode, file);\n}\n\n/**\n * prov",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pen(inode, file)",
          "args": [
            "}\n\n/",
            "*"
          ],
          "line": 2651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\ns_file_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = inode->i_private;\n\treturn nonseekable_open(inode, file);\n}\n\n/**\n * prov"
  },
  {
    "function_name": "truct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "2626-2640",
    "snippet": "ap(struct ubifs_info *c, int lnum)\n{\n\tint err;\n\n\tif (c->dbg->pc_happened)\n\t\treturn -EROFS;\n\tif (power_cut_emulated(c, lnum, 0))\n\t\treturn -EROFS;\n\terr = ubi_leb_map(c->ubi, lnum);\n\tif (err)\n\t\treturn err;\n\tif (power_cut_emulated(c, lnum, 0))\n\t\treturn -EROFS;\n\treturn 0;\n}\n\n/*\n * Root",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lated(c, lnum, 0))",
          "args": [
            "etur",
            "-"
          ],
          "line": 2637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->ubi, lnum",
          "args": [
            ";\n\tif",
            "rr)"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lated(c, lnum, 0))",
          "args": [
            "etur",
            "-"
          ],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nap(struct ubifs_info *c, int lnum)\n{\n\tint err;\n\n\tif (c->dbg->pc_happened)\n\t\treturn -EROFS;\n\tif (power_cut_emulated(c, lnum, 0))\n\t\treturn -EROFS;\n\terr = ubi_leb_map(c->ubi, lnum);\n\tif (err)\n\t\treturn err;\n\tif (power_cut_emulated(c, lnum, 0))\n\t\treturn -EROFS;\n\treturn 0;\n}\n\n/*\n * Root"
  },
  {
    "function_name": "(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "2610-2624",
    "snippet": "nmap(struct ubifs_info *c, int lnum)\n{\n\tint err;\n\n\tif (c->dbg->pc_happened)\n\t\treturn -EROFS;\n\tif (power_cut_emulated(c, lnum, 0))\n\t\treturn -EROFS;\n\terr = ubi_leb_unmap(c->ubi, lnum);\n\tif (err)\n\t\treturn err;\n\tif (power_cut_emulated(c, lnum, 0))\n\t\treturn -EROFS;\n\treturn 0;\n}\n\nint dbg_leb",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lated(c, lnum, 0))",
          "args": [
            "etur",
            "-"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c->ubi, lnum",
          "args": [
            ";\n\tif",
            "rr)"
          ],
          "line": 2618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lated(c, lnum, 0))",
          "args": [
            "etur",
            "-"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nnmap(struct ubifs_info *c, int lnum)\n{\n\tint err;\n\n\tif (c->dbg->pc_happened)\n\t\treturn -EROFS;\n\tif (power_cut_emulated(c, lnum, 0))\n\t\treturn -EROFS;\n\terr = ubi_leb_unmap(c->ubi, lnum);\n\tif (err)\n\t\treturn err;\n\tif (power_cut_emulated(c, lnum, 0))\n\t\treturn -EROFS;\n\treturn 0;\n}\n\nint dbg_leb"
  },
  {
    "function_name": "e(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "2593-2608",
    "snippet": "hange(struct ubifs_info *c, int lnum, const void *buf,\n\t\t   int len)\n{\n\tint err;\n\n\tif (c->dbg->pc_happened)\n\t\treturn -EROFS;\n\tif (power_cut_emulated(c, lnum, 1))\n\t\treturn -EROFS;\n\terr = ubi_leb_change(c->ubi, lnum, buf, len);\n\tif (err)\n\t\treturn err;\n\tif (power_cut_emulated(c, lnum, 1))\n\t\treturn -EROFS;\n\treturn 0;\n}\n\nint dbg_leb",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lated(c, lnum, 1))",
          "args": [
            "etur",
            "-"
          ],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(c->ubi, lnum",
          "args": [
            "buf,",
            "n);",
            "f (",
            "r)"
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lated(c, lnum, 1))",
          "args": [
            "etur",
            "-"
          ],
          "line": 2600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nhange(struct ubifs_info *c, int lnum, const void *buf,\n\t\t   int len)\n{\n\tint err;\n\n\tif (c->dbg->pc_happened)\n\t\treturn -EROFS;\n\tif (power_cut_emulated(c, lnum, 1))\n\t\treturn -EROFS;\n\terr = ubi_leb_change(c->ubi, lnum, buf, len);\n\tif (err)\n\t\treturn err;\n\tif (power_cut_emulated(c, lnum, 1))\n\t\treturn -EROFS;\n\treturn 0;\n}\n\nint dbg_leb"
  },
  {
    "function_name": "(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "2571-2591",
    "snippet": "rite(struct ubifs_info *c, int lnum, const void *buf,\n\t\t  int offs, int len)\n{\n\tint err, failing;\n\n\tif (c->dbg->pc_happened)\n\t\treturn -EROFS;\n\n\tfailing = power_cut_emulated(c, lnum, 1);\n\tif (failing) {\n\t\tlen = corrupt_data(c, buf, len);\n\t\tubifs_warn(\"actually write %d bytes to LEB %d:%d (the buffer was corrupted)\",\n\t\t\t   len, lnum, offs);\n\t}\n\terr = ubi_leb_write(c->ubi, lnum, buf, offs, len);\n\tif (err)\n\t\treturn err;\n\tif (failing)\n\t\treturn -EROFS;\n\treturn 0;\n}\n\nint dbg_leb",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "(c->ubi, lnum",
          "args": [
            "buf,",
            "fs,",
            "n);",
            "if (",
            "r)"
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctually wr",
          "args": [
            "te %d bytes to LEB %d:%d (the buffer was corrupted)\",\n\t\t\t   len,",
            "fs)",
            "}",
            "r ="
          ],
          "line": 2582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, buf, len)",
          "args": [
            "ubi",
            "_wa"
          ],
          "line": 2581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lated(c, lnum, 1);",
          "args": [
            "(fa",
            "i"
          ],
          "line": 2579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nrite(struct ubifs_info *c, int lnum, const void *buf,\n\t\t  int offs, int len)\n{\n\tint err, failing;\n\n\tif (c->dbg->pc_happened)\n\t\treturn -EROFS;\n\n\tfailing = power_cut_emulated(c, lnum, 1);\n\tif (failing) {\n\t\tlen = corrupt_data(c, buf, len);\n\t\tubifs_warn(\"actually write %d bytes to LEB %d:%d (the buffer was corrupted)\",\n\t\t\t   len, lnum, offs);\n\t}\n\terr = ubi_leb_write(c->ubi, lnum, buf, offs, len);\n\tif (err)\n\t\treturn err;\n\tif (failing)\n\t\treturn -EROFS;\n\treturn 0;\n}\n\nint dbg_leb"
  },
  {
    "function_name": "const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "2550-2569",
    "snippet": "rrupt_data(const struct ubifs_info *c, const void *buf,\n\t\t\tunsigned int len)\n{\n\tunsigned int from, to, ffs = chance(1, 2);\n\tunsigned char *p = (void *)buf;\n\n\tfrom = prandom_u32() % len;\n\t/* Corruption span max to end of write unit */\n\tto = min(len, ALIGN(from + 1, c->max_write_size));\n\n\tubifs_warn(\"filled bytes %u-%u with %s\", from, to - 1,\n\t\t   ffs ? \"0xFFs\" : \"random data\");\n\n\tif (ffs)\n\t\tmemset(p + from, 0xFF, to - from);\n\telse\n\t\tprandom_bytes(p + from, to - from);\n\n\treturn to;\n}\n\nint dbg_leb",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "(p + from, to",
          "args": [
            "- from);",
            "return t"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "om, 0x",
          "args": [
            "F, to -",
            "om);",
            "else\n\t\tpr"
          ],
          "line": 2564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "illed byte",
          "args": [
            "%u-%u with %s\", from, to -",
            "ffs ?",
            ": \"random data\");\n\n\tif (ffs)"
          ],
          "line": 2560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N(f",
          "args": [
            "om",
            "1, c->max_write_size));\n\n\tubifs_wa"
          ],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "1, c-",
          "args": [
            "max_writ",
            "size));\n\n\tubifs_w"
          ],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "% len;\n\t/*",
          "args": [],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unsi",
          "args": [
            "n"
          ],
          "line": 2553
        },
        "resolved": true,
        "details": {
          "function_name": "unsigned_offsets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "40-43",
          "snippet": "static inline int unsigned_offsets(struct file *file)\n{\n\treturn file->f_mode & FMODE_UNSIGNED_OFFSET;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline int unsigned_offsets(struct file *file)\n{\n\treturn file->f_mode & FMODE_UNSIGNED_OFFSET;\n}"
        }
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nrrupt_data(const struct ubifs_info *c, const void *buf,\n\t\t\tunsigned int len)\n{\n\tunsigned int from, to, ffs = chance(1, 2);\n\tunsigned char *p = (void *)buf;\n\n\tfrom = prandom_u32() % len;\n\t/* Corruption span max to end of write unit */\n\tto = min(len, ALIGN(from + 1, c->max_write_size));\n\n\tubifs_warn(\"filled bytes %u-%u with %s\", from, to - 1,\n\t\t   ffs ? \"0xFFs\" : \"random data\");\n\n\tif (ffs)\n\t\tmemset(p + from, 0xFF, to - from);\n\telse\n\t\tprandom_bytes(p + from, to - from);\n\n\treturn to;\n}\n\nint dbg_leb"
  },
  {
    "function_name": "lated(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "2456-2548",
    "snippet": "wer_cut_emulated(struct ubifs_info *c, int lnum, int write)\n{\n\tstruct ubifs_debug_info *d = c->dbg;\n\n\tubifs_assert(dbg_is_tst_rcvry(c));\n\n\tif (!d->pc_cnt) {\n\t\t/* First call - decide delay to the power cut */\n\t\tif (chance(1, 2)) {\n\t\t\tunsigned long delay;\n\n\t\t\tif (chance(1, 2)) {\n\t\t\t\td->pc_delay = 1;\n\t\t\t\t/* Fail within 1 minute */\n\t\t\t\tdelay = prandom_u32() % 60000;\n\t\t\t\td->pc_timeout = jiffies;\n\t\t\t\td->pc_timeout += msecs_to_jiffies(delay);\n\t\t\t\tubifs_warn(\"failing after %lums\", delay);\n\t\t\t} else {\n\t\t\t\td->pc_delay = 2;\n\t\t\t\tdelay = prandom_u32() % 10000;\n\t\t\t\t/* Fail within 10000 operations */\n\t\t\t\td->pc_cnt_max = delay;\n\t\t\t\tubifs_warn(\"failing after %lu calls\", delay);\n\t\t\t}\n\t\t}\n\n\t\td->pc_cnt += 1;\n\t}\n\n\t/* Determine if failure delay has expired */\n\tif (d->pc_delay == 1 && time_before(jiffies, d->pc_timeout))\n\t\t\treturn 0;\n\tif (d->pc_delay == 2 && d->pc_cnt++ < d->pc_cnt_max)\n\t\t\treturn 0;\n\n\tif (lnum == UBIFS_SB_LNUM) {\n\t\tif (write && chance(1, 2))\n\t\t\treturn 0;\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in super block LEB %d\", lnum);\n\t} else if (lnum == UBIFS_MST_LNUM || lnum == UBIFS_MST_LNUM + 1) {\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in master LEB %d\", lnum);\n\t} else if (lnum >= UBIFS_LOG_LNUM && lnum <= c->log_last) {\n\t\tif (write && chance(99, 100))\n\t\t\treturn 0;\n\t\tif (chance(399, 400))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in log LEB %d\", lnum);\n\t} else if (lnum >= c->lpt_first && lnum <= c->lpt_last) {\n\t\tif (write && chance(7, 8))\n\t\t\treturn 0;\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in LPT LEB %d\", lnum);\n\t} else if (lnum >= c->orph_first && lnum <= c->orph_last) {\n\t\tif (write && chance(1, 2))\n\t\t\treturn 0;\n\t\tif (chance(9, 10))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in orphan LEB %d\", lnum);\n\t} else if (lnum == c->ihead_lnum) {\n\t\tif (chance(99, 100))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in index head LEB %d\", lnum);\n\t} else if (c->jheads && lnum == c->jheads[GCHD].wbuf.lnum) {\n\t\tif (chance(9, 10))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in GC head LEB %d\", lnum);\n\t} else if (write && !RB_EMPTY_ROOT(&c->buds) &&\n\t\t   !ubifs_search_bud(c, lnum)) {\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in non-bud LEB %d\", lnum);\n\t} else if (c->cmt_state == COMMIT_RUNNING_BACKGROUND ||\n\t\t   c->cmt_state == COMMIT_RUNNING_REQUIRED) {\n\t\tif (chance(999, 1000))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in bud LEB %d commit running\", lnum);\n\t} else {\n\t\tif (chance(9999, 10000))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in bud LEB %d commit not running\", lnum);\n\t}\n\n\td->pc_happened = 1;\n\tubifs_warn(\"========== Power cut emulated ==========\");\n\tdump_stack();\n\treturn 1;\n}\n\nstatic int",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "return 1",
          "args": [],
          "line": 2546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "=========",
          "args": [
            "ower cut emulated ==========\");\n\tdump_stac"
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailing in",
          "args": [
            "ud LEB %d commit not running\", lnum);\n\t}",
            "->pc"
          ],
          "line": 2541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "10000)",
          "args": [
            "turn"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailing in",
          "args": [
            "ud LEB %d commit running\", lnum);\n\t} e",
            "e {"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "000))",
          "args": [
            "r",
            "urn"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailing in",
          "args": [
            "on-bud LEB %d\", lnum);\n\t} e",
            "e if"
          ],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "))",
          "args": [
            "et",
            "n"
          ],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bud(c, lnum)) {",
          "args": [
            "(ch"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(&c->buds) &&",
          "args": [
            "!ub"
          ],
          "line": 2528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailing in",
          "args": [
            "C head LEB %d\", lnum);\n\t} e",
            "e if"
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\t\tr",
          "args": [
            "t",
            "n"
          ],
          "line": 2525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailing in",
          "args": [
            "ndex head LEB %d\", lnum);\n\t} e",
            "e if"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "0))",
          "args": [
            "re",
            "rn"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailing in",
          "args": [
            "rphan LEB %d\", lnum);\n\t} e",
            "e if"
          ],
          "line": 2519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\t\tr",
          "args": [
            "t",
            "n"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "re",
          "args": [
            "u"
          ],
          "line": 2515
        },
        "resolved": true,
        "details": {
          "function_name": "dget_req(const struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
          "lines": "548-563",
          "snippet": "mp_budget_req(const struct ubifs_budget_req *req)\n{\n\tspin_lock(&dbg_lock);\n\tpr_err(\"Budgeting request: new_ino %d, dirtied_ino %d\\n\",\n\t       req->new_ino, req->dirtied_ino);\n\tpr_err(\"\\tnew_ino_d   %d, dirtied_ino_d %d\\n\",\n\t       req->new_ino_d, req->dirtied_ino_d);\n\tpr_err(\"\\tnew_page    %d, dirtied_page %d\\n\",\n\t       req->new_page, req->dirtied_page);\n\tpr_err(\"\\tnew_dent    %d, mod_dent     %d\\n\",\n\t       req->new_dent, req->mod_dent);\n\tpr_err(\"\\tidx_growth  %d\\n\", req->idx_growth);\n\tpr_err(\"\\tdata_growth %d dd_growth     %d\\n\",\n\t       req->data_growth, req->dd_growth);\n\tspin_unlock(&dbg_lock);\n}\n\nvoid ubifs_",
          "includes": [
            "fs.h\"\n\nstatic DEFIN",
            "ux/random.h>\n#include \"ubi",
            "ux/uaccess.h>\n#include <lin",
            "ux/math64.h>\n#include <lin",
            "ux/debugfs.h>\n#include <lin",
            "ux/module.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nmp_budget_req(const struct ubifs_budget_req *req)\n{\n\tspin_lock(&dbg_lock);\n\tpr_err(\"Budgeting request: new_ino %d, dirtied_ino %d\\n\",\n\t       req->new_ino, req->dirtied_ino);\n\tpr_err(\"\\tnew_ino_d   %d, dirtied_ino_d %d\\n\",\n\t       req->new_ino_d, req->dirtied_ino_d);\n\tpr_err(\"\\tnew_page    %d, dirtied_page %d\\n\",\n\t       req->new_page, req->dirtied_page);\n\tpr_err(\"\\tnew_dent    %d, mod_dent     %d\\n\",\n\t       req->new_dent, req->mod_dent);\n\tpr_err(\"\\tidx_growth  %d\\n\", req->idx_growth);\n\tpr_err(\"\\tdata_growth %d dd_growth     %d\\n\",\n\t       req->data_growth, req->dd_growth);\n\tspin_unlock(&dbg_lock);\n}\n\nvoid ubifs_"
        }
      },
      {
        "call_info": {
          "callee": "ailing in",
          "args": [
            "PT LEB %d\", lnum);\n\t} e",
            "e if"
          ],
          "line": 2513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "))",
          "args": [
            "et",
            "n"
          ],
          "line": 2511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailing in",
          "args": [
            "og LEB %d\", lnum);\n\t} e",
            "e if"
          ],
          "line": 2507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "00))",
          "args": [
            "re",
            "rn"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "0))",
          "args": [
            "re",
            "rn"
          ],
          "line": 2503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailing in",
          "args": [
            "aster LEB %d\", lnum);\n\t} e",
            "e if"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "))",
          "args": [
            "et",
            "n"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailing in",
          "args": [
            "uper block LEB %d\", lnum);\n\t} e",
            "e if"
          ],
          "line": 2497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "))",
          "args": [
            "et",
            "n"
          ],
          "line": 2495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iffies, d->",
          "args": [
            "c_timeo",
            "))\n\t\t\treturn"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailing aft",
          "args": [
            "r %lu calls\", delay);",
            "}"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "% 10000;",
          "args": [],
          "line": 2476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailing aft",
          "args": [
            "r %lums\", delay);",
            "else"
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ies(delay);",
          "args": [
            "bifs_"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "% 60000;",
          "args": [],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{",
          "args": [
            "d",
            "p"
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{",
          "args": [
            "n",
            "g"
          ],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_is_tst_r",
          "args": [
            "vry(c));\n\n\tif (!d->"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vry(c));\n\n\tif (!",
          "args": [
            "-"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nwer_cut_emulated(struct ubifs_info *c, int lnum, int write)\n{\n\tstruct ubifs_debug_info *d = c->dbg;\n\n\tubifs_assert(dbg_is_tst_rcvry(c));\n\n\tif (!d->pc_cnt) {\n\t\t/* First call - decide delay to the power cut */\n\t\tif (chance(1, 2)) {\n\t\t\tunsigned long delay;\n\n\t\t\tif (chance(1, 2)) {\n\t\t\t\td->pc_delay = 1;\n\t\t\t\t/* Fail within 1 minute */\n\t\t\t\tdelay = prandom_u32() % 60000;\n\t\t\t\td->pc_timeout = jiffies;\n\t\t\t\td->pc_timeout += msecs_to_jiffies(delay);\n\t\t\t\tubifs_warn(\"failing after %lums\", delay);\n\t\t\t} else {\n\t\t\t\td->pc_delay = 2;\n\t\t\t\tdelay = prandom_u32() % 10000;\n\t\t\t\t/* Fail within 10000 operations */\n\t\t\t\td->pc_cnt_max = delay;\n\t\t\t\tubifs_warn(\"failing after %lu calls\", delay);\n\t\t\t}\n\t\t}\n\n\t\td->pc_cnt += 1;\n\t}\n\n\t/* Determine if failure delay has expired */\n\tif (d->pc_delay == 1 && time_before(jiffies, d->pc_timeout))\n\t\t\treturn 0;\n\tif (d->pc_delay == 2 && d->pc_cnt++ < d->pc_cnt_max)\n\t\t\treturn 0;\n\n\tif (lnum == UBIFS_SB_LNUM) {\n\t\tif (write && chance(1, 2))\n\t\t\treturn 0;\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in super block LEB %d\", lnum);\n\t} else if (lnum == UBIFS_MST_LNUM || lnum == UBIFS_MST_LNUM + 1) {\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in master LEB %d\", lnum);\n\t} else if (lnum >= UBIFS_LOG_LNUM && lnum <= c->log_last) {\n\t\tif (write && chance(99, 100))\n\t\t\treturn 0;\n\t\tif (chance(399, 400))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in log LEB %d\", lnum);\n\t} else if (lnum >= c->lpt_first && lnum <= c->lpt_last) {\n\t\tif (write && chance(7, 8))\n\t\t\treturn 0;\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in LPT LEB %d\", lnum);\n\t} else if (lnum >= c->orph_first && lnum <= c->orph_last) {\n\t\tif (write && chance(1, 2))\n\t\t\treturn 0;\n\t\tif (chance(9, 10))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in orphan LEB %d\", lnum);\n\t} else if (lnum == c->ihead_lnum) {\n\t\tif (chance(99, 100))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in index head LEB %d\", lnum);\n\t} else if (c->jheads && lnum == c->jheads[GCHD].wbuf.lnum) {\n\t\tif (chance(9, 10))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in GC head LEB %d\", lnum);\n\t} else if (write && !RB_EMPTY_ROOT(&c->buds) &&\n\t\t   !ubifs_search_bud(c, lnum)) {\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in non-bud LEB %d\", lnum);\n\t} else if (c->cmt_state == COMMIT_RUNNING_BACKGROUND ||\n\t\t   c->cmt_state == COMMIT_RUNNING_REQUIRED) {\n\t\tif (chance(999, 1000))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in bud LEB %d commit running\", lnum);\n\t} else {\n\t\tif (chance(9999, 10000))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in bud LEB %d commit not running\", lnum);\n\t}\n\n\td->pc_happened = 1;\n\tubifs_warn(\"========== Power cut emulated ==========\");\n\tdump_stack();\n\treturn 1;\n}\n\nstatic int"
  },
  {
    "function_name": "ed int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "2450-2454",
    "snippet": "int chance(unsigned int n, unsigned int out_of)\n{\n\treturn !!((prandom_u32() % out_of) + 1 <= n);\n\n}\n\nstatic int",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "% out_of)",
          "args": [],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nint chance(unsigned int n, unsigned int out_of)\n{\n\treturn !!((prandom_u32() % out_of) + 1 <= n);\n\n}\n\nstatic int"
  },
  {
    "function_name": "data_nodes_order(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "2368-2448",
    "snippet": "_nondata_nodes_order(struct ubifs_info *c, struct list_head *head)\n{\n\tstruct list_head *cur;\n\tstruct ubifs_scan_node *sa, *sb;\n\n\tif (!dbg_is_chk_gen(c))\n\t\treturn 0;\n\n\tfor (cur = head->next; cur->next != head; cur = cur->next) {\n\t\tino_t inuma, inumb;\n\t\tuint32_t hasha, hashb;\n\n\t\tcond_resched();\n\t\tsa = container_of(cur, struct ubifs_scan_node, list);\n\t\tsb = container_of(cur->next, struct ubifs_scan_node, list);\n\n\t\tif (sa->type != UBIFS_INO_NODE && sa->type != UBIFS_DENT_NODE &&\n\t\t    sa->type != UBIFS_XENT_NODE) {\n\t\t\tubifs_err(\"bad node type %d\", sa->type);\n\t\t\tubifs_dump_node(c, sa->node);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (sa->type != UBIFS_INO_NODE && sa->type != UBIFS_DENT_NODE &&\n\t\t    sa->type != UBIFS_XENT_NODE) {\n\t\t\tubifs_err(\"bad node type %d\", sb->type);\n\t\t\tubifs_dump_node(c, sb->node);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sa->type != UBIFS_INO_NODE && sb->type == UBIFS_INO_NODE) {\n\t\t\tubifs_err(\"non-inode node goes before inode node\");\n\t\t\tgoto error_dump;\n\t\t}\n\n\t\tif (sa->type == UBIFS_INO_NODE && sb->type != UBIFS_INO_NODE)\n\t\t\tcontinue;\n\n\t\tif (sa->type == UBIFS_INO_NODE && sb->type == UBIFS_INO_NODE) {\n\t\t\t/* Inode nodes are sorted in descending size order */\n\t\t\tif (sa->len < sb->len) {\n\t\t\t\tubifs_err(\"smaller inode node goes first\");\n\t\t\t\tgoto error_dump;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * This is either a dentry or xentry, which should be sorted in\n\t\t * ascending (parent ino, hash) order.\n\t\t */\n\t\tinuma = key_inum(c, &sa->key);\n\t\tinumb = key_inum(c, &sb->key);\n\n\t\tif (inuma < inumb)\n\t\t\tcontinue;\n\t\tif (inuma > inumb) {\n\t\t\tubifs_err(\"larger inum %lu goes before inum %lu\",\n\t\t\t\t  (unsigned long)inuma, (unsigned long)inumb);\n\t\t\tgoto error_dump;\n\t\t}\n\n\t\thasha = key_block(c, &sa->key);\n\t\thashb = key_block(c, &sb->key);\n\n\t\tif (hasha > hashb) {\n\t\t\tubifs_err(\"larger hash %u goes before %u\",\n\t\t\t\t  hasha, hashb);\n\t\t\tgoto error_dump;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror_dump:\n\tubifs_msg(\"dumping first node\");\n\tubifs_dump_node(c, sa->node);\n\tubifs_msg(\"dumping second node\");\n\tubifs_dump_node(c, sb->node);\n\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic inli",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "de(c, sb->node)",
          "args": [
            "eturn -E"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mping sec",
          "args": [
            "nd node\");\n\tubifs_dum"
          ],
          "line": 2444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, sa->node)",
          "args": [
            "bifs_msg"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mping fir",
          "args": [
            "t node\");\n\tubifs_dum"
          ],
          "line": 2442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rger hash",
          "args": [
            "%u goes before %u\",\n\t\t\t\t  hasha",
            ";",
            "to er"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&sb->key)",
          "args": [
            "if (has"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&sa->key)",
          "args": [
            "hashb ="
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rger inum",
          "args": [
            "%lu goes before inum %lu\",\n\t\t\t\t  (unsi",
            "g)inuma, (unsigned l",
            "g)inumb);\n\t\t\tgoto er"
          ],
          "line": 2424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb->key)",
          "args": [
            "if (inu"
          ],
          "line": 2419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sa->key)",
          "args": [
            "inumb ="
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aller ino",
          "args": [
            "e node goes first\");\n\t\t\t\tgoto e"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n-inode n",
          "args": [
            "de goes before inode node\");\n\t\t\tgoto er"
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, sb->node)",
          "args": [
            "return"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d node ty",
          "args": [
            "e %d\", sb->type);",
            "ubifs_d"
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, sa->node)",
          "args": [
            "return"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d node ty",
          "args": [
            "e %d\", sa->type);",
            "ubifs_d"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->next, s",
          "args": [
            "ruct ubif",
            "scan_nde, list);\n\n\t\ti",
            "(sa-"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur, struct",
          "args": [
            "bif",
            "scan_nde, list);\n\t\tsb",
            "con"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\tsa = co",
          "args": [],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n(c))\n\t\treturn",
          "args": [
            "0"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\n_nondata_nodes_order(struct ubifs_info *c, struct list_head *head)\n{\n\tstruct list_head *cur;\n\tstruct ubifs_scan_node *sa, *sb;\n\n\tif (!dbg_is_chk_gen(c))\n\t\treturn 0;\n\n\tfor (cur = head->next; cur->next != head; cur = cur->next) {\n\t\tino_t inuma, inumb;\n\t\tuint32_t hasha, hashb;\n\n\t\tcond_resched();\n\t\tsa = container_of(cur, struct ubifs_scan_node, list);\n\t\tsb = container_of(cur->next, struct ubifs_scan_node, list);\n\n\t\tif (sa->type != UBIFS_INO_NODE && sa->type != UBIFS_DENT_NODE &&\n\t\t    sa->type != UBIFS_XENT_NODE) {\n\t\t\tubifs_err(\"bad node type %d\", sa->type);\n\t\t\tubifs_dump_node(c, sa->node);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (sa->type != UBIFS_INO_NODE && sa->type != UBIFS_DENT_NODE &&\n\t\t    sa->type != UBIFS_XENT_NODE) {\n\t\t\tubifs_err(\"bad node type %d\", sb->type);\n\t\t\tubifs_dump_node(c, sb->node);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sa->type != UBIFS_INO_NODE && sb->type == UBIFS_INO_NODE) {\n\t\t\tubifs_err(\"non-inode node goes before inode node\");\n\t\t\tgoto error_dump;\n\t\t}\n\n\t\tif (sa->type == UBIFS_INO_NODE && sb->type != UBIFS_INO_NODE)\n\t\t\tcontinue;\n\n\t\tif (sa->type == UBIFS_INO_NODE && sb->type == UBIFS_INO_NODE) {\n\t\t\t/* Inode nodes are sorted in descending size order */\n\t\t\tif (sa->len < sb->len) {\n\t\t\t\tubifs_err(\"smaller inode node goes first\");\n\t\t\t\tgoto error_dump;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * This is either a dentry or xentry, which should be sorted in\n\t\t * ascending (parent ino, hash) order.\n\t\t */\n\t\tinuma = key_inum(c, &sa->key);\n\t\tinumb = key_inum(c, &sb->key);\n\n\t\tif (inuma < inumb)\n\t\t\tcontinue;\n\t\tif (inuma > inumb) {\n\t\t\tubifs_err(\"larger inum %lu goes before inum %lu\",\n\t\t\t\t  (unsigned long)inuma, (unsigned long)inumb);\n\t\t\tgoto error_dump;\n\t\t}\n\n\t\thasha = key_block(c, &sa->key);\n\t\thashb = key_block(c, &sb->key);\n\n\t\tif (hasha > hashb) {\n\t\t\tubifs_err(\"larger hash %u goes before %u\",\n\t\t\t\t  hasha, hashb);\n\t\t\tgoto error_dump;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror_dump:\n\tubifs_msg(\"dumping first node\");\n\tubifs_dump_node(c, sa->node);\n\tubifs_msg(\"dumping second node\");\n\tubifs_dump_node(c, sb->node);\n\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic inli"
  },
  {
    "function_name": "a_nodes_order(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "2301-2358",
    "snippet": "_data_nodes_order(struct ubifs_info *c, struct list_head *head)\n{\n\tstruct list_head *cur;\n\tstruct ubifs_scan_node *sa, *sb;\n\n\tif (!dbg_is_chk_gen(c))\n\t\treturn 0;\n\n\tfor (cur = head->next; cur->next != head; cur = cur->next) {\n\t\tino_t inuma, inumb;\n\t\tuint32_t blka, blkb;\n\n\t\tcond_resched();\n\t\tsa = container_of(cur, struct ubifs_scan_node, list);\n\t\tsb = container_of(cur->next, struct ubifs_scan_node, list);\n\n\t\tif (sa->type != UBIFS_DATA_NODE) {\n\t\t\tubifs_err(\"bad node type %d\", sa->type);\n\t\t\tubifs_dump_node(c, sa->node);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (sb->type != UBIFS_DATA_NODE) {\n\t\t\tubifs_err(\"bad node type %d\", sb->type);\n\t\t\tubifs_dump_node(c, sb->node);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinuma = key_inum(c, &sa->key);\n\t\tinumb = key_inum(c, &sb->key);\n\n\t\tif (inuma < inumb)\n\t\t\tcontinue;\n\t\tif (inuma > inumb) {\n\t\t\tubifs_err(\"larger inum %lu goes before inum %lu\",\n\t\t\t\t  (unsigned long)inuma, (unsigned long)inumb);\n\t\t\tgoto error_dump;\n\t\t}\n\n\t\tblka = key_block(c, &sa->key);\n\t\tblkb = key_block(c, &sb->key);\n\n\t\tif (blka > blkb) {\n\t\t\tubifs_err(\"larger block %u goes before %u\", blka, blkb);\n\t\t\tgoto error_dump;\n\t\t}\n\t\tif (blka == blkb) {\n\t\t\tubifs_err(\"two data nodes for the same block\");\n\t\t\tgoto error_dump;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror_dump:\n\tubifs_dump_node(c, sa->node);\n\tubifs_dump_node(c, sb->node);\n\treturn -EINVAL;\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "de(c, sb->node)",
          "args": [
            "eturn -E"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, sa->node)",
          "args": [
            "bifs_dum"
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o data no",
          "args": [
            "es for the same block\");\n\t\t\tgoto er"
          ],
          "line": 2347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rger bloc",
          "args": [
            "%u goes before %u\", blka, blkb)",
            "g",
            "o er"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&sb->key)",
          "args": [
            "if (blk"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&sa->key)",
          "args": [
            "blkb = k"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rger inum",
          "args": [
            "%lu goes before inum %lu\",\n\t\t\t\t  (unsi",
            "g)inuma, (unsigned l",
            "g)inumb);\n\t\t\tgoto er"
          ],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb->key)",
          "args": [
            "if (inu"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sa->key)",
          "args": [
            "inumb ="
          ],
          "line": 2328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, sb->node)",
          "args": [
            "return"
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d node ty",
          "args": [
            "e %d\", sb->type);",
            "ubifs_d"
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, sa->node)",
          "args": [
            "return"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d node ty",
          "args": [
            "e %d\", sa->type);",
            "ubifs_d"
          ],
          "line": 2318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->next, s",
          "args": [
            "ruct ubif",
            "scan_nde, list);\n\n\t\ti",
            "(sa-"
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur, struct",
          "args": [
            "bif",
            "scan_nde, list);\n\t\tsb",
            "con"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\tsa = co",
          "args": [],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n(c))\n\t\treturn",
          "args": [
            "0"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\n_data_nodes_order(struct ubifs_info *c, struct list_head *head)\n{\n\tstruct list_head *cur;\n\tstruct ubifs_scan_node *sa, *sb;\n\n\tif (!dbg_is_chk_gen(c))\n\t\treturn 0;\n\n\tfor (cur = head->next; cur->next != head; cur = cur->next) {\n\t\tino_t inuma, inumb;\n\t\tuint32_t blka, blkb;\n\n\t\tcond_resched();\n\t\tsa = container_of(cur, struct ubifs_scan_node, list);\n\t\tsb = container_of(cur->next, struct ubifs_scan_node, list);\n\n\t\tif (sa->type != UBIFS_DATA_NODE) {\n\t\t\tubifs_err(\"bad node type %d\", sa->type);\n\t\t\tubifs_dump_node(c, sa->node);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (sb->type != UBIFS_DATA_NODE) {\n\t\t\tubifs_err(\"bad node type %d\", sb->type);\n\t\t\tubifs_dump_node(c, sb->node);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinuma = key_inum(c, &sa->key);\n\t\tinumb = key_inum(c, &sb->key);\n\n\t\tif (inuma < inumb)\n\t\t\tcontinue;\n\t\tif (inuma > inumb) {\n\t\t\tubifs_err(\"larger inum %lu goes before inum %lu\",\n\t\t\t\t  (unsigned long)inuma, (unsigned long)inumb);\n\t\t\tgoto error_dump;\n\t\t}\n\n\t\tblka = key_block(c, &sa->key);\n\t\tblkb = key_block(c, &sb->key);\n\n\t\tif (blka > blkb) {\n\t\t\tubifs_err(\"larger block %u goes before %u\", blka, blkb);\n\t\t\tgoto error_dump;\n\t\t}\n\t\tif (blka == blkb) {\n\t\t\tubifs_err(\"two data nodes for the same block\");\n\t\t\tgoto error_dump;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror_dump:\n\tubifs_dump_node(c, sa->node);\n\tubifs_dump_node(c, sb->node);\n\treturn -EINVAL;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "esystem(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "2266-2291",
    "snippet": "_filesystem(struct ubifs_info *c)\n{\n\tint err;\n\tstruct fsck_data fsckd;\n\n\tif (!dbg_is_chk_fs(c))\n\t\treturn 0;\n\n\tfsckd.inodes = RB_ROOT;\n\terr = dbg_walk_index(c, check_leaf, NULL, &fsckd);\n\tif (err)\n\t\tgoto out_free;\n\n\terr = check_inodes(c, &fsckd);\n\tif (err)\n\t\tgoto out_free;\n\n\tfree_inodes(&fsckd);\n\treturn 0;\n\nout_free:\n\tubifs_err(\"file-system check failed with error %d\", err);\n\tdump_stack();\n\tfree_inodes(&fsckd);\n\treturn err;\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsckd);\n\tre",
          "args": [
            "urn er"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_ino",
          "args": [],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le-system",
          "args": [
            "check failed with error %d\", err);\n\tdump",
            "tac"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsckd);\n\tre",
          "args": [
            "urn 0;"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, &fsckd);",
          "args": [
            "i",
            "(err)"
          ],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x(c, check_lea",
          "args": [
            ",",
            "ULL, &fsck",
            ";\n\ti",
            "(err)"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c))\n\t\treturn",
          "args": [
            "0"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\n_filesystem(struct ubifs_info *c)\n{\n\tint err;\n\tstruct fsck_data fsckd;\n\n\tif (!dbg_is_chk_fs(c))\n\t\treturn 0;\n\n\tfsckd.inodes = RB_ROOT;\n\terr = dbg_walk_index(c, check_leaf, NULL, &fsckd);\n\tif (err)\n\t\tgoto out_free;\n\n\terr = check_inodes(c, &fsckd);\n\tif (err)\n\t\tgoto out_free;\n\n\tfree_inodes(&fsckd);\n\treturn 0;\n\nout_free:\n\tubifs_err(\"file-system check failed with error %d\", err);\n\tdump_stack();\n\tfree_inodes(&fsckd);\n\treturn err;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "2143-2251",
    "snippet": "eck_inodes(struct ubifs_info *c, struct fsck_data *fsckd)\n{\n\tint n, err;\n\tunion ubifs_key key;\n\tstruct ubifs_znode *znode;\n\tstruct ubifs_zbranch *zbr;\n\tstruct ubifs_ino_node *ino;\n\tstruct fsck_inode *fscki;\n\tstruct rb_node *this = rb_first(&fsckd->inodes);\n\n\twhile (this) {\n\t\tfscki = rb_entry(this, struct fsck_inode, rb);\n\t\tthis = rb_next(this);\n\n\t\tif (S_ISDIR(fscki->mode)) {\n\t\t\t/*\n\t\t\t * Directories have to have exactly one reference (they\n\t\t\t * cannot have hardlinks), although root inode is an\n\t\t\t * exception.\n\t\t\t */\n\t\t\tif (fscki->inum != UBIFS_ROOT_INO &&\n\t\t\t    fscki->references != 1) {\n\t\t\t\tubifs_err(\"directory inode %lu has %d direntries which refer it, but should be 1\",\n\t\t\t\t\t  (unsigned long)fscki->inum,\n\t\t\t\t\t  fscki->references);\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t\tif (fscki->inum == UBIFS_ROOT_INO &&\n\t\t\t    fscki->references != 0) {\n\t\t\t\tubifs_err(\"root inode %lu has non-zero (%d) direntries which refer it\",\n\t\t\t\t\t  (unsigned long)fscki->inum,\n\t\t\t\t\t  fscki->references);\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t\tif (fscki->calc_sz != fscki->size) {\n\t\t\t\tubifs_err(\"directory inode %lu size is %lld, but calculated size is %lld\",\n\t\t\t\t\t  (unsigned long)fscki->inum,\n\t\t\t\t\t  fscki->size, fscki->calc_sz);\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t\tif (fscki->calc_cnt != fscki->nlink) {\n\t\t\t\tubifs_err(\"directory inode %lu nlink is %d, but calculated nlink is %d\",\n\t\t\t\t\t  (unsigned long)fscki->inum,\n\t\t\t\t\t  fscki->nlink, fscki->calc_cnt);\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t} else {\n\t\t\tif (fscki->references != fscki->nlink) {\n\t\t\t\tubifs_err(\"inode %lu nlink is %d, but calculated nlink is %d\",\n\t\t\t\t\t  (unsigned long)fscki->inum,\n\t\t\t\t\t  fscki->nlink, fscki->references);\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t}\n\t\tif (fscki->xattr_sz != fscki->calc_xsz) {\n\t\t\tubifs_err(\"inode %lu has xattr size %u, but calculated size is %lld\",\n\t\t\t\t  (unsigned long)fscki->inum, fscki->xattr_sz,\n\t\t\t\t  fscki->calc_xsz);\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (fscki->xattr_cnt != fscki->calc_xcnt) {\n\t\t\tubifs_err(\"inode %lu has %u xattrs, but calculated count is %lld\",\n\t\t\t\t  (unsigned long)fscki->inum,\n\t\t\t\t  fscki->xattr_cnt, fscki->calc_xcnt);\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (fscki->xattr_nms != fscki->calc_xnms) {\n\t\t\tubifs_err(\"inode %lu has xattr names' size %u, but calculated names' size is %lld\",\n\t\t\t\t  (unsigned long)fscki->inum, fscki->xattr_nms,\n\t\t\t\t  fscki->calc_xnms);\n\t\t\tgoto out_dump;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_dump:\n\t/* Read the bad inode and dump it */\n\tino_key_init(c, &key, fscki->inum);\n\terr = ubifs_lookup_level0(c, &key, &znode, &n);\n\tif (!err) {\n\t\tubifs_err(\"inode %lu not found in index\",\n\t\t\t  (unsigned long)fscki->inum);\n\t\treturn -ENOENT;\n\t} else if (err < 0) {\n\t\tubifs_err(\"error %d while looking up inode %lu\",\n\t\t\t  err, (unsigned long)fscki->inum);\n\t\treturn err;\n\t}\n\n\tzbr = &znode->zbranch[n];\n\tino = kmalloc(zbr->len, GFP_NOFS);\n\tif (!ino)\n\t\treturn -ENOMEM;\n\n\terr = ubifs_tnc_read_node(c, zbr, ino);\n\tif (err) {\n\t\tubifs_err(\"cannot read inode node at LEB %d:%d, error %d\",\n\t\t\t  zbr->lnum, zbr->offs, err);\n\t\tkfree(ino);\n\t\treturn err;\n\t}\n\n\tubifs_msg(\"dump of the inode %lu sitting in LEB %d:%d\",\n\t\t  (unsigned long)fscki->inum, zbr->lnum, zbr->offs);\n\tubifs_dump_node(c, ino);\n\tkfree(ino);\n\treturn -EINVAL;\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retur",
          "args": [
            "-E"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "de(c, ino);\n\tkf",
          "args": [
            "e",
            "ino"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp of the",
          "args": [
            "inode %lu sitting in LEB %d:%d\",\n\t\t  (unsign",
            "g)fscki->inum, zbr->lnum,",
            "r->offs);",
            "ubifs_dum"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnot read",
          "args": [
            "inode node at LEB %d:%d, error %d\",\n\t\t\t  zbr->l",
            "r->offs,",
            "r);\n\t\tkfr",
            "(in"
          ],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_node(c, zbr, ino)",
          "args": [
            "f (",
            "r)"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "len, GF",
          "args": [
            "_NOFS);",
            "f (!ino)"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ror %d wh",
          "args": [
            "le looking up inode %lu\",\n\t\t\t  err, (",
            "d l",
            "g)fscki->inum);\n\t\treturn e"
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode %lu n",
          "args": [
            "t found in index\",\n\t\t\t  (unsig",
            "g)fscki->inum);\n\t\treturn -"
          ],
          "line": 2224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "level0(c, &key, &zn",
          "args": [
            "d",
            "&n)",
            "if (!",
            "r)"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, &key, fsc",
          "args": [
            "i",
            "inum",
            "err = ubi"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode %lu h",
          "args": [
            "s xattr names' size %u, but calculated names' size is %lld\",\n\t\t\t\t  (unsi",
            "g)fscki->inum, fscki->xatt",
            "nms,\n\t\t\t\t  fscki",
            "nms);\n\t\t\tgoto ou"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode %lu h",
          "args": [
            "s %u xattrs, but calculated count is %lld\",\n\t\t\t\t  (unsi",
            "g)fscki->inum,\n\t\t\t\t  fscki",
            "cnt, fscki->calc",
            "cnt);\n\t\t\tgoto ou"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode %lu h",
          "args": [
            "s xattr size %u, but calculated size is %lld\",\n\t\t\t\t  (unsi",
            "g)fscki->inum, fscki->xatt",
            "sz,\n\t\t\t\t  fscki",
            "sz);\n\t\t\tgoto ou"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode %lu n",
          "args": [
            "ink is %d, but calculated nlink is %d\",\n\t\t\t\t\t  (uns",
            "g)fscki->inum,\n\t\t\t\t\t  fsck",
            "fscki->refe",
            "nces);\n\t\t\t\tgoto o"
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rectory i",
          "args": [
            "ode %lu nlink is %d, but calculated nlink is %d\",\n\t\t\t\t\t  (uns",
            "g)fscki->inum,\n\t\t\t\t\t  fsck",
            "fscki->calc",
            "nt);\n\t\t\t\tgoto o"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rectory i",
          "args": [
            "ode %lu size is %lld, but calculated size is %lld\",\n\t\t\t\t\t  (uns",
            "g)fscki->inum,\n\t\t\t\t\t  fsck",
            "fscki->calc",
            "z);\n\t\t\t\tgoto o"
          ],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ot inode",
          "args": [
            "lu has non-zero (%d) direntries which refer it\",\n\t\t\t\t\t  (uns",
            "g)fscki->inum,\n\t\t\t\t\t  fsck",
            "nces);\n\t\t\t\tgoto o"
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rectory i",
          "args": [
            "ode %lu has %d direntries which refer it, but should be 1\",\n\t\t\t\t\t  (uns",
            "g)fscki->inum,\n\t\t\t\t\t  fsck",
            "nces);\n\t\t\t\tgoto o"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->mode)",
          "args": [
            "{\n\t\t\t/*"
          ],
          "line": 2157
        },
        "resolved": true,
        "details": {
          "function_name": "(int mode)\n{",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/journal.c",
          "lines": "427-448",
          "snippet": "t_dent_type(int mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\t\treturn UBIFS_ITYPE_REG;\n\tcase S_IFDIR:\n\t\treturn UBIFS_ITYPE_DIR;\n\tcase S_IFLNK:\n\t\treturn UBIFS_ITYPE_LNK;\n\tcase S_IFBLK:\n\t\treturn UBIFS_ITYPE_BLK;\n\tcase S_IFCHR:\n\t\treturn UBIFS_ITYPE_CHR;\n\tcase S_IFIFO:\n\t\treturn UBIFS_ITYPE_FIFO;\n\tcase S_IFSOCK:\n\t\treturn UBIFS_ITYPE_SOCK;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}\n\n/**\n * pack",
          "includes": [
            "fs.h\"\n\n/**\n * zero_"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * zero_\n\nt_dent_type(int mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\t\treturn UBIFS_ITYPE_REG;\n\tcase S_IFDIR:\n\t\treturn UBIFS_ITYPE_DIR;\n\tcase S_IFLNK:\n\t\treturn UBIFS_ITYPE_LNK;\n\tcase S_IFBLK:\n\t\treturn UBIFS_ITYPE_BLK;\n\tcase S_IFCHR:\n\t\treturn UBIFS_ITYPE_CHR;\n\tcase S_IFIFO:\n\t\treturn UBIFS_ITYPE_FIFO;\n\tcase S_IFSOCK:\n\t\treturn UBIFS_ITYPE_SOCK;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}\n\n/**\n * pack"
        }
      },
      {
        "call_info": {
          "callee": ";\n\n\t\tif",
          "args": [
            "(S_I"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", struct",
          "args": [
            "fsck",
            "node, b);\n\t\tthis",
            "r"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kd->inod",
          "args": [
            "s);\n\n\twhile (t"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\neck_inodes(struct ubifs_info *c, struct fsck_data *fsckd)\n{\n\tint n, err;\n\tunion ubifs_key key;\n\tstruct ubifs_znode *znode;\n\tstruct ubifs_zbranch *zbr;\n\tstruct ubifs_ino_node *ino;\n\tstruct fsck_inode *fscki;\n\tstruct rb_node *this = rb_first(&fsckd->inodes);\n\n\twhile (this) {\n\t\tfscki = rb_entry(this, struct fsck_inode, rb);\n\t\tthis = rb_next(this);\n\n\t\tif (S_ISDIR(fscki->mode)) {\n\t\t\t/*\n\t\t\t * Directories have to have exactly one reference (they\n\t\t\t * cannot have hardlinks), although root inode is an\n\t\t\t * exception.\n\t\t\t */\n\t\t\tif (fscki->inum != UBIFS_ROOT_INO &&\n\t\t\t    fscki->references != 1) {\n\t\t\t\tubifs_err(\"directory inode %lu has %d direntries which refer it, but should be 1\",\n\t\t\t\t\t  (unsigned long)fscki->inum,\n\t\t\t\t\t  fscki->references);\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t\tif (fscki->inum == UBIFS_ROOT_INO &&\n\t\t\t    fscki->references != 0) {\n\t\t\t\tubifs_err(\"root inode %lu has non-zero (%d) direntries which refer it\",\n\t\t\t\t\t  (unsigned long)fscki->inum,\n\t\t\t\t\t  fscki->references);\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t\tif (fscki->calc_sz != fscki->size) {\n\t\t\t\tubifs_err(\"directory inode %lu size is %lld, but calculated size is %lld\",\n\t\t\t\t\t  (unsigned long)fscki->inum,\n\t\t\t\t\t  fscki->size, fscki->calc_sz);\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t\tif (fscki->calc_cnt != fscki->nlink) {\n\t\t\t\tubifs_err(\"directory inode %lu nlink is %d, but calculated nlink is %d\",\n\t\t\t\t\t  (unsigned long)fscki->inum,\n\t\t\t\t\t  fscki->nlink, fscki->calc_cnt);\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t} else {\n\t\t\tif (fscki->references != fscki->nlink) {\n\t\t\t\tubifs_err(\"inode %lu nlink is %d, but calculated nlink is %d\",\n\t\t\t\t\t  (unsigned long)fscki->inum,\n\t\t\t\t\t  fscki->nlink, fscki->references);\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t}\n\t\tif (fscki->xattr_sz != fscki->calc_xsz) {\n\t\t\tubifs_err(\"inode %lu has xattr size %u, but calculated size is %lld\",\n\t\t\t\t  (unsigned long)fscki->inum, fscki->xattr_sz,\n\t\t\t\t  fscki->calc_xsz);\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (fscki->xattr_cnt != fscki->calc_xcnt) {\n\t\t\tubifs_err(\"inode %lu has %u xattrs, but calculated count is %lld\",\n\t\t\t\t  (unsigned long)fscki->inum,\n\t\t\t\t  fscki->xattr_cnt, fscki->calc_xcnt);\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (fscki->xattr_nms != fscki->calc_xnms) {\n\t\t\tubifs_err(\"inode %lu has xattr names' size %u, but calculated names' size is %lld\",\n\t\t\t\t  (unsigned long)fscki->inum, fscki->xattr_nms,\n\t\t\t\t  fscki->calc_xnms);\n\t\t\tgoto out_dump;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_dump:\n\t/* Read the bad inode and dump it */\n\tino_key_init(c, &key, fscki->inum);\n\terr = ubifs_lookup_level0(c, &key, &znode, &n);\n\tif (!err) {\n\t\tubifs_err(\"inode %lu not found in index\",\n\t\t\t  (unsigned long)fscki->inum);\n\t\treturn -ENOENT;\n\t} else if (err < 0) {\n\t\tubifs_err(\"error %d while looking up inode %lu\",\n\t\t\t  err, (unsigned long)fscki->inum);\n\t\treturn err;\n\t}\n\n\tzbr = &znode->zbranch[n];\n\tino = kmalloc(zbr->len, GFP_NOFS);\n\tif (!ino)\n\t\treturn -ENOMEM;\n\n\terr = ubifs_tnc_read_node(c, zbr, ino);\n\tif (err) {\n\t\tubifs_err(\"cannot read inode node at LEB %d:%d, error %d\",\n\t\t\t  zbr->lnum, zbr->offs, err);\n\t\tkfree(ino);\n\t\treturn err;\n\t}\n\n\tubifs_msg(\"dump of the inode %lu sitting in LEB %d:%d\",\n\t\t  (unsigned long)fscki->inum, zbr->lnum, zbr->offs);\n\tubifs_dump_node(c, ino);\n\tkfree(ino);\n\treturn -EINVAL;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "truct fsck_",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "2125-2131",
    "snippet": "ree_inodes(struct fsck_data *fsckd)\n{\n\tstruct fsck_inode *fscki, *n;\n\n\trbtree_postorder_for_each_entry_safe(fscki, n, &fsckd->inodes, rb)\n\t\tkfree(fscki);\n}\n\n/**\n * chec",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\n/",
          "args": [
            "*\n *"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "der_for_each_entry_safe(fscki, n, &f",
          "args": [
            "ckd->",
            "o",
            "s, rb)\n\t\tkfree",
            "sc"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nree_inodes(struct fsck_data *fsckd)\n{\n\tstruct fsck_inode *fscki, *n;\n\n\trbtree_postorder_for_each_entry_safe(fscki, n, &fsckd->inodes, rb)\n\t\tkfree(fscki);\n}\n\n/**\n * chec"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "1978-2119",
    "snippet": "eck_leaf(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t      void *priv)\n{\n\tino_t inum;\n\tvoid *node;\n\tstruct ubifs_ch *ch;\n\tint err, type = key_type(c, &zbr->key);\n\tstruct fsck_inode *fscki;\n\n\tif (zbr->len < UBIFS_CH_SZ) {\n\t\tubifs_err(\"bad leaf length %d (LEB %d:%d)\",\n\t\t\t  zbr->len, zbr->lnum, zbr->offs);\n\t\treturn -EINVAL;\n\t}\n\n\tnode = kmalloc(zbr->len, GFP_NOFS);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\terr = ubifs_tnc_read_node(c, zbr, node);\n\tif (err) {\n\t\tubifs_err(\"cannot read leaf node at LEB %d:%d, error %d\",\n\t\t\t  zbr->lnum, zbr->offs, err);\n\t\tgoto out_free;\n\t}\n\n\t/* If this is an inode node, add it to RB-tree of inodes */\n\tif (type == UBIFS_INO_KEY) {\n\t\tfscki = add_inode(c, priv, node);\n\t\tif (IS_ERR(fscki)) {\n\t\t\terr = PTR_ERR(fscki);\n\t\t\tubifs_err(\"error %d while adding inode node\", err);\n\t\t\tgoto out_dump;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (type != UBIFS_DENT_KEY && type != UBIFS_XENT_KEY &&\n\t    type != UBIFS_DATA_KEY) {\n\t\tubifs_err(\"unexpected node type %d at LEB %d:%d\",\n\t\t\t  type, zbr->lnum, zbr->offs);\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tch = node;\n\tif (le64_to_cpu(ch->sqnum) > c->max_sqnum) {\n\t\tubifs_err(\"too high sequence number, max. is %llu\",\n\t\t\t  c->max_sqnum);\n\t\terr = -EINVAL;\n\t\tgoto out_dump;\n\t}\n\n\tif (type == UBIFS_DATA_KEY) {\n\t\tlong long blk_offs;\n\t\tstruct ubifs_data_node *dn = node;\n\n\t\tubifs_assert(zbr->len >= UBIFS_DATA_NODE_SZ);\n\n\t\t/*\n\t\t * Search the inode node this data node belongs to and insert\n\t\t * it to the RB-tree of inodes.\n\t\t */\n\t\tinum = key_inum_flash(c, &dn->key);\n\t\tfscki = read_add_inode(c, priv, inum);\n\t\tif (IS_ERR(fscki)) {\n\t\t\terr = PTR_ERR(fscki);\n\t\t\tubifs_err(\"error %d while processing data node and trying to find inode node %lu\",\n\t\t\t\t  err, (unsigned long)inum);\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\t/* Make sure the data node is within inode size */\n\t\tblk_offs = key_block_flash(c, &dn->key);\n\t\tblk_offs <<= UBIFS_BLOCK_SHIFT;\n\t\tblk_offs += le32_to_cpu(dn->size);\n\t\tif (blk_offs > fscki->size) {\n\t\t\tubifs_err(\"data node at LEB %d:%d is not within inode size %lld\",\n\t\t\t\t  zbr->lnum, zbr->offs, fscki->size);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_dump;\n\t\t}\n\t} else {\n\t\tint nlen;\n\t\tstruct ubifs_dent_node *dent = node;\n\t\tstruct fsck_inode *fscki1;\n\n\t\tubifs_assert(zbr->len >= UBIFS_DENT_NODE_SZ);\n\n\t\terr = ubifs_validate_entry(c, dent);\n\t\tif (err)\n\t\t\tgoto out_dump;\n\n\t\t/*\n\t\t * Search the inode node this entry refers to and the parent\n\t\t * inode node and insert them to the RB-tree of inodes.\n\t\t */\n\t\tinum = le64_to_cpu(dent->inum);\n\t\tfscki = read_add_inode(c, priv, inum);\n\t\tif (IS_ERR(fscki)) {\n\t\t\terr = PTR_ERR(fscki);\n\t\t\tubifs_err(\"error %d while processing entry node and trying to find inode node %lu\",\n\t\t\t\t  err, (unsigned long)inum);\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\t/* Count how many direntries or xentries refers this inode */\n\t\tfscki->references += 1;\n\n\t\tinum = key_inum_flash(c, &dent->key);\n\t\tfscki1 = read_add_inode(c, priv, inum);\n\t\tif (IS_ERR(fscki1)) {\n\t\t\terr = PTR_ERR(fscki1);\n\t\t\tubifs_err(\"error %d while processing entry node and trying to find parent inode node %lu\",\n\t\t\t\t  err, (unsigned long)inum);\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\tnlen = le16_to_cpu(dent->nlen);\n\t\tif (type == UBIFS_XENT_KEY) {\n\t\t\tfscki1->calc_xcnt += 1;\n\t\t\tfscki1->calc_xsz += CALC_DENT_SIZE(nlen);\n\t\t\tfscki1->calc_xsz += CALC_XATTR_BYTES(fscki->size);\n\t\t\tfscki1->calc_xnms += nlen;\n\t\t} else {\n\t\t\tfscki1->calc_sz += CALC_DENT_SIZE(nlen);\n\t\t\tif (dent->type == UBIFS_ITYPE_DIR)\n\t\t\t\tfscki1->calc_cnt += 1;\n\t\t}\n\t}\n\nout:\n\tkfree(node);\n\treturn 0;\n\nout_dump:\n\tubifs_msg(\"dump of node at LEB %d:%d\", zbr->lnum, zbr->offs);\n\tubifs_dump_node(c, node);\nout_free:\n\tkfree(node);\n\treturn err;\n}\n\n/**\n * free",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retu",
          "args": [
            "n er"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "de(c, node);\nou",
          "args": [
            "_",
            "ee:"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp of nod",
          "args": [
            "at LEB %d:%d\", zbr->lnum,",
            "r->offs);",
            "ubifs_dum"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E(nlen);\n\t\t\tif",
          "args": [
            "(den"
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TES(fscki->size)",
          "args": [
            "fscki1-"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E(nlen);\n\t\t\tfs",
          "args": [
            "ki1-"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent->nlen);",
          "args": [
            "if (type"
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ror %d wh",
          "args": [
            "le processing entry node and trying to find parent inode node %lu\",\n\t\t\t\t  err,",
            "d l",
            "g)inum);\n\t\t\tgoto ou"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "1);",
          "args": [
            "bifs_e"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")) {",
          "args": [
            "err ="
          ],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(c, priv, inu",
          "args": [
            ")",
            "if",
            "IS_E"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h(c, &dent->ke",
          "args": [
            ")",
            "fscki1 ="
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ror %d wh",
          "args": [
            "le processing entry node and trying to find inode node %lu\",\n\t\t\t\t  err,",
            "d l",
            "g)inum);\n\t\t\tgoto ou"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\t\tu",
          "args": [
            "ifs_e"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "err ="
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(c, priv, inu",
          "args": [
            ")",
            "if",
            "IS_E"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent->inum);",
          "args": [
            "fscki ="
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_entry(c, dent);",
          "args": [
            "f",
            "err)"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zbr->len >=",
          "args": [
            "BIFS_DENT_NODE_SZ);\n\n\t\terr = u"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ta node a",
          "args": [
            "LEB %d:%d is not within inode size %lld\",\n\t\t\t\t  zbr->",
            "r->offs,",
            "cki->size",
            "err = -"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n->size);",
          "args": [
            "if (blk_"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sh(c, &dn->key)",
          "args": [
            "blk_offs"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ror %d wh",
          "args": [
            "le processing data node and trying to find inode node %lu\",\n\t\t\t\t  err,",
            "d l",
            "g)inum);\n\t\t\tgoto ou"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\t\tu",
          "args": [
            "ifs_e"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "err ="
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(c, priv, inu",
          "args": [
            ")",
            "if",
            "IS_E"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h(c, &dn->key)",
          "args": [
            "fscki ="
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zbr->len >=",
          "args": [
            "BIFS_DATA_NODE_SZ);\n\n\t\t/*\n\t\t *"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o high se",
          "args": [
            "uence number, max. is %llu\",\n\t\t\t  c->max",
            ";\n\t\terr = -E"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->sqnum) >",
          "args": [
            "c->max_sq"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expected",
          "args": [
            "ode type %d at LEB %d:%d\",\n\t\t\t  type,",
            "um,",
            "r->offs);",
            "err = -E"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ror %d wh",
          "args": [
            "le adding inode node\", err);\n\t\t\tgo",
            "ou"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\t\tu",
          "args": [
            "ifs_e"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "err ="
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv, nod",
          "args": [
            ")",
            "if",
            "IS_E"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnot read",
          "args": [
            "leaf node at LEB %d:%d, error %d\",\n\t\t\t  zbr->l",
            "r->offs,",
            "r);\n\t\tgot",
            "out"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_node(c, zbr, node",
          "args": [
            ";",
            "if",
            "rr)"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "len, GF",
          "args": [
            "_NOFS);",
            "f (!node"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d leaf le",
          "args": [
            "gth %d (LEB %d:%d)\",\n\t\t\t  zbr->l",
            "->lnum,",
            "r->offs);",
            "return -"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zbr->key",
          "args": [
            ";",
            "struct fs"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\neck_leaf(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t      void *priv)\n{\n\tino_t inum;\n\tvoid *node;\n\tstruct ubifs_ch *ch;\n\tint err, type = key_type(c, &zbr->key);\n\tstruct fsck_inode *fscki;\n\n\tif (zbr->len < UBIFS_CH_SZ) {\n\t\tubifs_err(\"bad leaf length %d (LEB %d:%d)\",\n\t\t\t  zbr->len, zbr->lnum, zbr->offs);\n\t\treturn -EINVAL;\n\t}\n\n\tnode = kmalloc(zbr->len, GFP_NOFS);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\terr = ubifs_tnc_read_node(c, zbr, node);\n\tif (err) {\n\t\tubifs_err(\"cannot read leaf node at LEB %d:%d, error %d\",\n\t\t\t  zbr->lnum, zbr->offs, err);\n\t\tgoto out_free;\n\t}\n\n\t/* If this is an inode node, add it to RB-tree of inodes */\n\tif (type == UBIFS_INO_KEY) {\n\t\tfscki = add_inode(c, priv, node);\n\t\tif (IS_ERR(fscki)) {\n\t\t\terr = PTR_ERR(fscki);\n\t\t\tubifs_err(\"error %d while adding inode node\", err);\n\t\t\tgoto out_dump;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (type != UBIFS_DENT_KEY && type != UBIFS_XENT_KEY &&\n\t    type != UBIFS_DATA_KEY) {\n\t\tubifs_err(\"unexpected node type %d at LEB %d:%d\",\n\t\t\t  type, zbr->lnum, zbr->offs);\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tch = node;\n\tif (le64_to_cpu(ch->sqnum) > c->max_sqnum) {\n\t\tubifs_err(\"too high sequence number, max. is %llu\",\n\t\t\t  c->max_sqnum);\n\t\terr = -EINVAL;\n\t\tgoto out_dump;\n\t}\n\n\tif (type == UBIFS_DATA_KEY) {\n\t\tlong long blk_offs;\n\t\tstruct ubifs_data_node *dn = node;\n\n\t\tubifs_assert(zbr->len >= UBIFS_DATA_NODE_SZ);\n\n\t\t/*\n\t\t * Search the inode node this data node belongs to and insert\n\t\t * it to the RB-tree of inodes.\n\t\t */\n\t\tinum = key_inum_flash(c, &dn->key);\n\t\tfscki = read_add_inode(c, priv, inum);\n\t\tif (IS_ERR(fscki)) {\n\t\t\terr = PTR_ERR(fscki);\n\t\t\tubifs_err(\"error %d while processing data node and trying to find inode node %lu\",\n\t\t\t\t  err, (unsigned long)inum);\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\t/* Make sure the data node is within inode size */\n\t\tblk_offs = key_block_flash(c, &dn->key);\n\t\tblk_offs <<= UBIFS_BLOCK_SHIFT;\n\t\tblk_offs += le32_to_cpu(dn->size);\n\t\tif (blk_offs > fscki->size) {\n\t\t\tubifs_err(\"data node at LEB %d:%d is not within inode size %lld\",\n\t\t\t\t  zbr->lnum, zbr->offs, fscki->size);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_dump;\n\t\t}\n\t} else {\n\t\tint nlen;\n\t\tstruct ubifs_dent_node *dent = node;\n\t\tstruct fsck_inode *fscki1;\n\n\t\tubifs_assert(zbr->len >= UBIFS_DENT_NODE_SZ);\n\n\t\terr = ubifs_validate_entry(c, dent);\n\t\tif (err)\n\t\t\tgoto out_dump;\n\n\t\t/*\n\t\t * Search the inode node this entry refers to and the parent\n\t\t * inode node and insert them to the RB-tree of inodes.\n\t\t */\n\t\tinum = le64_to_cpu(dent->inum);\n\t\tfscki = read_add_inode(c, priv, inum);\n\t\tif (IS_ERR(fscki)) {\n\t\t\terr = PTR_ERR(fscki);\n\t\t\tubifs_err(\"error %d while processing entry node and trying to find inode node %lu\",\n\t\t\t\t  err, (unsigned long)inum);\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\t/* Count how many direntries or xentries refers this inode */\n\t\tfscki->references += 1;\n\n\t\tinum = key_inum_flash(c, &dent->key);\n\t\tfscki1 = read_add_inode(c, priv, inum);\n\t\tif (IS_ERR(fscki1)) {\n\t\t\terr = PTR_ERR(fscki1);\n\t\t\tubifs_err(\"error %d while processing entry node and trying to find parent inode node %lu\",\n\t\t\t\t  err, (unsigned long)inum);\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\tnlen = le16_to_cpu(dent->nlen);\n\t\tif (type == UBIFS_XENT_KEY) {\n\t\t\tfscki1->calc_xcnt += 1;\n\t\t\tfscki1->calc_xsz += CALC_DENT_SIZE(nlen);\n\t\t\tfscki1->calc_xsz += CALC_XATTR_BYTES(fscki->size);\n\t\t\tfscki1->calc_xnms += nlen;\n\t\t} else {\n\t\t\tfscki1->calc_sz += CALC_DENT_SIZE(nlen);\n\t\t\tif (dent->type == UBIFS_ITYPE_DIR)\n\t\t\t\tfscki1->calc_cnt += 1;\n\t\t}\n\t}\n\nout:\n\tkfree(node);\n\treturn 0;\n\nout_dump:\n\tubifs_msg(\"dump of node at LEB %d:%d\", zbr->lnum, zbr->offs);\n\tubifs_dump_node(c, node);\nout_free:\n\tkfree(node);\n\treturn err;\n}\n\n/**\n * free"
  },
  {
    "function_name": "e(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "1907-1960",
    "snippet": "fsck_inode *read_add_inode(struct ubifs_info *c,\n\t\t\t\t\t struct fsck_data *fsckd, ino_t inum)\n{\n\tint n, err;\n\tunion ubifs_key key;\n\tstruct ubifs_znode *znode;\n\tstruct ubifs_zbranch *zbr;\n\tstruct ubifs_ino_node *ino;\n\tstruct fsck_inode *fscki;\n\n\tfscki = search_inode(fsckd, inum);\n\tif (fscki)\n\t\treturn fscki;\n\n\tino_key_init(c, &key, inum);\n\terr = ubifs_lookup_level0(c, &key, &znode, &n);\n\tif (!err) {\n\t\tubifs_err(\"inode %lu not found in index\", (unsigned long)inum);\n\t\treturn ERR_PTR(-ENOENT);\n\t} else if (err < 0) {\n\t\tubifs_err(\"error %d while looking up inode %lu\",\n\t\t\t  err, (unsigned long)inum);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tzbr = &znode->zbranch[n];\n\tif (zbr->len < UBIFS_INO_NODE_SZ) {\n\t\tubifs_err(\"bad node %lu node length %d\",\n\t\t\t  (unsigned long)inum, zbr->len);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tino = kmalloc(zbr->len, GFP_NOFS);\n\tif (!ino)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = ubifs_tnc_read_node(c, zbr, ino);\n\tif (err) {\n\t\tubifs_err(\"cannot read inode node at LEB %d:%d, error %d\",\n\t\t\t  zbr->lnum, zbr->offs, err);\n\t\tkfree(ino);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tfscki = add_inode(c, fsckd, ino);\n\tkfree(ino);\n\tif (IS_ERR(fscki)) {\n\t\tubifs_err(\"error %ld while adding inode %lu node\",\n\t\t\t  PTR_ERR(fscki), (unsigned long)inum);\n\t\treturn fscki;\n\t}\n\n\treturn fscki;\n}\n\n/**\n * chec",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ror %ld w",
          "args": [
            "ile adding inode %lu node\",\n\t\t\t  PTR_ER",
            "), (unsigned l",
            "g)inum);\n\t\treturn f"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "), (uns",
          "args": [
            "gned"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "bifs_"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if (I",
          "args": [
            "_ER"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsckd, in",
          "args": [
            ")",
            "kfre",
            "ino"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "}\n\n\tf",
          "args": [
            "cki"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retu",
          "args": [
            "n E"
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nnot read",
          "args": [
            "inode node at LEB %d:%d, error %d\",\n\t\t\t  zbr->l",
            "r->offs,",
            "r);\n\t\tkfr",
            "(in"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_node(c, zbr, ino)",
          "args": [
            "f (",
            "r)"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EM);",
          "args": [
            "rr = ub"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "len, GF",
          "args": [
            "_NOFS);",
            "f (!ino)"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AL);\n\t}",
          "args": [
            "ino ="
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d node %l",
          "args": [
            "node length %d\",\n\t\t\t  (unsig",
            "g)inum, zbr->len);",
            "return E"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "}\n\n\tz",
          "args": [
            "r ="
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ror %d wh",
          "args": [
            "le looking up inode %lu\",\n\t\t\t  err, (",
            "d l",
            "g)inum);\n\t\treturn E"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NT);\n\t}",
          "args": [
            "else if"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode %lu n",
          "args": [
            "t found in index\", (unsigned l",
            "g)inum);\n\t\treturn E"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "level0(c, &key, &zn",
          "args": [
            "d",
            "&n)",
            "if (!",
            "r)"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, &key, inu",
          "args": [
            ")",
            "err",
            "ubi"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsckd, inum)",
          "args": [
            "if",
            "scki"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nfsck_inode *read_add_inode(struct ubifs_info *c,\n\t\t\t\t\t struct fsck_data *fsckd, ino_t inum)\n{\n\tint n, err;\n\tunion ubifs_key key;\n\tstruct ubifs_znode *znode;\n\tstruct ubifs_zbranch *zbr;\n\tstruct ubifs_ino_node *ino;\n\tstruct fsck_inode *fscki;\n\n\tfscki = search_inode(fsckd, inum);\n\tif (fscki)\n\t\treturn fscki;\n\n\tino_key_init(c, &key, inum);\n\terr = ubifs_lookup_level0(c, &key, &znode, &n);\n\tif (!err) {\n\t\tubifs_err(\"inode %lu not found in index\", (unsigned long)inum);\n\t\treturn ERR_PTR(-ENOENT);\n\t} else if (err < 0) {\n\t\tubifs_err(\"error %d while looking up inode %lu\",\n\t\t\t  err, (unsigned long)inum);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tzbr = &znode->zbranch[n];\n\tif (zbr->len < UBIFS_INO_NODE_SZ) {\n\t\tubifs_err(\"bad node %lu node length %d\",\n\t\t\t  (unsigned long)inum, zbr->len);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tino = kmalloc(zbr->len, GFP_NOFS);\n\tif (!ino)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = ubifs_tnc_read_node(c, zbr, ino);\n\tif (err) {\n\t\tubifs_err(\"cannot read inode node at LEB %d:%d, error %d\",\n\t\t\t  zbr->lnum, zbr->offs, err);\n\t\tkfree(ino);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tfscki = add_inode(c, fsckd, ino);\n\tkfree(ino);\n\tif (IS_ERR(fscki)) {\n\t\tubifs_err(\"error %ld while adding inode %lu node\",\n\t\t\t  PTR_ERR(fscki), (unsigned long)inum);\n\t\treturn fscki;\n\t}\n\n\treturn fscki;\n}\n\n/**\n * chec"
  },
  {
    "function_name": "struct fsck_",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "1878-1894",
    "snippet": "fsck_inode *search_inode(struct fsck_data *fsckd, ino_t inum)\n{\n\tstruct rb_node *p;\n\tstruct fsck_inode *fscki;\n\n\tp = fsckd->inodes.rb_node;\n\twhile (p) {\n\t\tfscki = rb_entry(p, struct fsck_inode, rb);\n\t\tif (inum < fscki->inum)\n\t\t\tp = p->rb_left;\n\t\telse if (inum > fscki->inum)\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\treturn fscki;\n\t}\n\treturn NULL;\n}\n\n/**\n * read",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truct fs",
          "args": [
            "k",
            "node, b);\n\t\tif (",
            "um"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nfsck_inode *search_inode(struct fsck_data *fsckd, ino_t inum)\n{\n\tstruct rb_node *p;\n\tstruct fsck_inode *fscki;\n\n\tp = fsckd->inodes.rb_node;\n\twhile (p) {\n\t\tfscki = rb_entry(p, struct fsck_inode, rb);\n\t\tif (inum < fscki->inum)\n\t\t\tp = p->rb_left;\n\t\telse if (inum > fscki->inum)\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\treturn fscki;\n\t}\n\treturn NULL;\n}\n\n/**\n * read"
  },
  {
    "function_name": "uct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "1794-1867",
    "snippet": "fsck_inode *add_inode(struct ubifs_info *c,\n\t\t\t\t    struct fsck_data *fsckd,\n\t\t\t\t    struct ubifs_ino_node *ino)\n{\n\tstruct rb_node **p, *parent = NULL;\n\tstruct fsck_inode *fscki;\n\tino_t inum = key_inum_flash(c, &ino->key);\n\tstruct inode *inode;\n\tstruct ubifs_inode *ui;\n\n\tp = &fsckd->inodes.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tfscki = rb_entry(parent, struct fsck_inode, rb);\n\t\tif (inum < fscki->inum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (inum > fscki->inum)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn fscki;\n\t}\n\n\tif (inum > c->highest_inum) {\n\t\tubifs_err(\"too high inode number, max. is %lu\",\n\t\t\t  (unsigned long)c->highest_inum);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfscki = kzalloc(sizeof(struct fsck_inode), GFP_NOFS);\n\tif (!fscki)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode = ilookup(c->vfs_sb, inum);\n\n\tfscki->inum = inum;\n\t/*\n\t * If the inode is present in the VFS inode cache, use it instead of\n\t * the on-flash inode which might be out-of-date. E.g., the size might\n\t * be out-of-date. If we do not do this, the following may happen, for\n\t * example:\n\t *   1. A power cut happens\n\t *   2. We mount the file-system R/O, the replay process fixes up the\n\t *      inode size in the VFS cache, but on on-flash.\n\t *   3. 'check_leaf()' fails because it hits a data node beyond inode\n\t *      size.\n\t */\n\tif (!inode) {\n\t\tfscki->nlink = le32_to_cpu(ino->nlink);\n\t\tfscki->size = le64_to_cpu(ino->size);\n\t\tfscki->xattr_cnt = le32_to_cpu(ino->xattr_cnt);\n\t\tfscki->xattr_sz = le32_to_cpu(ino->xattr_size);\n\t\tfscki->xattr_nms = le32_to_cpu(ino->xattr_names);\n\t\tfscki->mode = le32_to_cpu(ino->mode);\n\t} else {\n\t\tui = ubifs_inode(inode);\n\t\tfscki->nlink = inode->i_nlink;\n\t\tfscki->size = inode->i_size;\n\t\tfscki->xattr_cnt = ui->xattr_cnt;\n\t\tfscki->xattr_sz = ui->xattr_size;\n\t\tfscki->xattr_nms = ui->xattr_names;\n\t\tfscki->mode = inode->i_mode;\n\t\tiput(inode);\n\t}\n\n\tif (S_ISDIR(fscki->mode)) {\n\t\tfscki->calc_sz = UBIFS_INO_NODE_SZ;\n\t\tfscki->calc_cnt = 2;\n\t}\n\n\trb_link_node(&fscki->rb, parent, p);\n\trb_insert_color(&fscki->rb, &fsckd->inodes);\n\n\treturn fscki;\n}\n\n/**\n * sear",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "or(&fscki->rb,",
          "args": [
            "fsckd->ino",
            "s);\n\n\treturn f"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&fscki->rb,",
          "args": [
            "arent, p);",
            "rb_ins",
            "t"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->mode)",
          "args": [
            "{\n\t\tfscki-"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "(int mode)\n{",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/journal.c",
          "lines": "427-448",
          "snippet": "t_dent_type(int mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\t\treturn UBIFS_ITYPE_REG;\n\tcase S_IFDIR:\n\t\treturn UBIFS_ITYPE_DIR;\n\tcase S_IFLNK:\n\t\treturn UBIFS_ITYPE_LNK;\n\tcase S_IFBLK:\n\t\treturn UBIFS_ITYPE_BLK;\n\tcase S_IFCHR:\n\t\treturn UBIFS_ITYPE_CHR;\n\tcase S_IFIFO:\n\t\treturn UBIFS_ITYPE_FIFO;\n\tcase S_IFSOCK:\n\t\treturn UBIFS_ITYPE_SOCK;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}\n\n/**\n * pack",
          "includes": [
            "fs.h\"\n\n/**\n * zero_"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * zero_\n\nt_dent_type(int mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\t\treturn UBIFS_ITYPE_REG;\n\tcase S_IFDIR:\n\t\treturn UBIFS_ITYPE_DIR;\n\tcase S_IFLNK:\n\t\treturn UBIFS_ITYPE_LNK;\n\tcase S_IFBLK:\n\t\treturn UBIFS_ITYPE_BLK;\n\tcase S_IFCHR:\n\t\treturn UBIFS_ITYPE_CHR;\n\tcase S_IFIFO:\n\t\treturn UBIFS_ITYPE_FIFO;\n\tcase S_IFSOCK:\n\t\treturn UBIFS_ITYPE_SOCK;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}\n\n/**\n * pack"
        }
      },
      {
        "call_info": {
          "callee": "}",
          "args": [
            "if (S"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\t\tfs",
          "args": [
            "ki->n"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->mode);",
          "args": [
            "} else {"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->xattr_n",
          "args": [
            "mes);\n\t\tfscki->m"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->xattr_s",
          "args": [
            "ze);\n\t\tfscki->x"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->xattr_c",
          "args": [
            "t);\n\t\tfscki->x"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->size);",
          "args": [
            "fscki->x"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->nlink);",
          "args": [
            "fscki->s"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s_sb, i",
          "args": [
            "um);\n\n\tfs",
            "i->i"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EM);",
          "args": [
            "node ="
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(struc",
          "args": [
            "fsck_inode), GFP_NOFS);",
            "f (!fsck"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "f(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
          "lines": "71-96",
          "snippet": "wbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt",
          "includes": [
            "fs.h\"\n\nstatic int d"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic int d\n\nwbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt"
        }
      },
      {
        "call_info": {
          "callee": "AL);\n\t}",
          "args": [
            "fscki"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o high in",
          "args": [
            "de number, max. is %lu\",\n\t\t\t  (unsig",
            "g)c->highest_inum);\n\t\treturn E"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nt, stru",
          "args": [
            "t fsck",
            "node, b);\n\t\tif (",
            "um"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h(c, &ino->key",
          "args": [
            ";",
            "struct in"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nfsck_inode *add_inode(struct ubifs_info *c,\n\t\t\t\t    struct fsck_data *fsckd,\n\t\t\t\t    struct ubifs_ino_node *ino)\n{\n\tstruct rb_node **p, *parent = NULL;\n\tstruct fsck_inode *fscki;\n\tino_t inum = key_inum_flash(c, &ino->key);\n\tstruct inode *inode;\n\tstruct ubifs_inode *ui;\n\n\tp = &fsckd->inodes.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tfscki = rb_entry(parent, struct fsck_inode, rb);\n\t\tif (inum < fscki->inum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (inum > fscki->inum)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn fscki;\n\t}\n\n\tif (inum > c->highest_inum) {\n\t\tubifs_err(\"too high inode number, max. is %lu\",\n\t\t\t  (unsigned long)c->highest_inum);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfscki = kzalloc(sizeof(struct fsck_inode), GFP_NOFS);\n\tif (!fscki)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode = ilookup(c->vfs_sb, inum);\n\n\tfscki->inum = inum;\n\t/*\n\t * If the inode is present in the VFS inode cache, use it instead of\n\t * the on-flash inode which might be out-of-date. E.g., the size might\n\t * be out-of-date. If we do not do this, the following may happen, for\n\t * example:\n\t *   1. A power cut happens\n\t *   2. We mount the file-system R/O, the replay process fixes up the\n\t *      inode size in the VFS cache, but on on-flash.\n\t *   3. 'check_leaf()' fails because it hits a data node beyond inode\n\t *      size.\n\t */\n\tif (!inode) {\n\t\tfscki->nlink = le32_to_cpu(ino->nlink);\n\t\tfscki->size = le64_to_cpu(ino->size);\n\t\tfscki->xattr_cnt = le32_to_cpu(ino->xattr_cnt);\n\t\tfscki->xattr_sz = le32_to_cpu(ino->xattr_size);\n\t\tfscki->xattr_nms = le32_to_cpu(ino->xattr_names);\n\t\tfscki->mode = le32_to_cpu(ino->mode);\n\t} else {\n\t\tui = ubifs_inode(inode);\n\t\tfscki->nlink = inode->i_nlink;\n\t\tfscki->size = inode->i_size;\n\t\tfscki->xattr_cnt = ui->xattr_cnt;\n\t\tfscki->xattr_sz = ui->xattr_size;\n\t\tfscki->xattr_nms = ui->xattr_names;\n\t\tfscki->mode = inode->i_mode;\n\t\tiput(inode);\n\t}\n\n\tif (S_ISDIR(fscki->mode)) {\n\t\tfscki->calc_sz = UBIFS_INO_NODE_SZ;\n\t\tfscki->calc_cnt = 2;\n\t}\n\n\trb_link_node(&fscki->rb, parent, p);\n\trb_insert_color(&fscki->rb, &fsckd->inodes);\n\n\treturn fscki;\n}\n\n/**\n * sear"
  },
  {
    "function_name": "_size(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "1715-1737",
    "snippet": "_idx_size(struct ubifs_info *c, long long idx_size)\n{\n\tint err;\n\tlong long calc = 0;\n\n\tif (!dbg_is_chk_index(c))\n\t\treturn 0;\n\n\terr = dbg_walk_index(c, NULL, add_size, &calc);\n\tif (err) {\n\t\tubifs_err(\"error %d while walking the index\", err);\n\t\treturn err;\n\t}\n\n\tif (calc != idx_size) {\n\t\tubifs_err(\"index size check failed: calculated size is %lld, should be %lld\",\n\t\t\t  calc, idx_size);\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/**\n * stru",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [
      "global_debug_info ubifs_dbg;\n\nstatic stru"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "return",
          "args": [],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "coda_return_EIO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "32-35",
          "snippet": "static int coda_return_EIO(void)\n{\n\treturn -EIO;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int coda_return_EIO(void)\n{\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dex size",
          "args": [
            "heck failed: calculated size is %lld, should be %lld\",\n\t\t\t  calc,",
            "e);",
            "dump_sta"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ror %d wh",
          "args": [
            "le walking the index\", err);\n\t\tret",
            "n e"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x(c, NULL, add",
          "args": [
            "s",
            "e, &",
            "lc);\n\tif",
            "err)"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dex(c))\n\t\treturn",
          "args": [
            "0"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nglobal_debug_info ubifs_dbg;\n\nstatic stru;\n\n_idx_size(struct ubifs_info *c, long long idx_size)\n{\n\tint err;\n\tlong long calc = 0;\n\n\tif (!dbg_is_chk_index(c))\n\t\treturn 0;\n\n\terr = dbg_walk_index(c, NULL, add_size, &calc);\n\tif (err) {\n\t\tubifs_err(\"error %d while walking the index\", err);\n\t\treturn err;\n\t}\n\n\tif (calc != idx_size) {\n\t\tubifs_err(\"index size check failed: calculated size is %lld, should be %lld\",\n\t\t\t  calc, idx_size);\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/**\n * stru"
  },
  {
    "function_name": "ct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "1695-1704",
    "snippet": "d_size(struct ubifs_info *c, struct ubifs_znode *znode, void *priv)\n{\n\tlong long *idx_size = priv;\n\tint add;\n\n\tadd = ubifs_idx_node_sz(c, znode->child_cnt);\n\tadd = ALIGN(add, 8);\n\t*idx_size += add;\n\treturn 0;\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ";\n\t*i",
          "args": [
            "x_s",
            "e"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_sz(c, znode->ch",
          "args": [
            "l",
            "cnt);\n\tadd = ALI"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nd_size(struct ubifs_info *c, struct ubifs_znode *znode, void *priv)\n{\n\tlong long *idx_size = priv;\n\tint add;\n\n\tadd = ubifs_idx_node_sz(c, znode->child_cnt);\n\tadd = ALIGN(add, 8);\n\t*idx_size += add;\n\treturn 0;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "x(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "1563-1683",
    "snippet": "index(struct ubifs_info *c, dbg_leaf_callback leaf_cb,\n\t\t   dbg_znode_callback znode_cb, void *priv)\n{\n\tint err;\n\tstruct ubifs_zbranch *zbr;\n\tstruct ubifs_znode *znode, *child;\n\n\tmutex_lock(&c->tnc_mutex);\n\t/* If the root indexing node is not in TNC - pull it */\n\tif (!c->zroot.znode) {\n\t\tc->zroot.znode = ubifs_load_znode(c, &c->zroot, NULL, 0);\n\t\tif (IS_ERR(c->zroot.znode)) {\n\t\t\terr = PTR_ERR(c->zroot.znode);\n\t\t\tc->zroot.znode = NULL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/*\n\t * We are going to traverse the indexing tree in the postorder manner.\n\t * Go down and find the leftmost indexing node where we are going to\n\t * start from.\n\t */\n\tznode = c->zroot.znode;\n\twhile (znode->level > 0) {\n\t\tzbr = &znode->zbranch[0];\n\t\tchild = zbr->znode;\n\t\tif (!child) {\n\t\t\tchild = ubifs_load_znode(c, zbr, znode, 0);\n\t\t\tif (IS_ERR(child)) {\n\t\t\t\terr = PTR_ERR(child);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tzbr->znode = child;\n\t\t}\n\n\t\tznode = child;\n\t}\n\n\t/* Iterate over all indexing nodes */\n\twhile (1) {\n\t\tint idx;\n\n\t\tcond_resched();\n\n\t\tif (znode_cb) {\n\t\t\terr = znode_cb(c, znode, priv);\n\t\t\tif (err) {\n\t\t\t\tubifs_err(\"znode checking function returned error %d\",\n\t\t\t\t\t  err);\n\t\t\t\tubifs_dump_znode(c, znode);\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t}\n\t\tif (leaf_cb && znode->level == 0) {\n\t\t\tfor (idx = 0; idx < znode->child_cnt; idx++) {\n\t\t\t\tzbr = &znode->zbranch[idx];\n\t\t\t\terr = leaf_cb(c, zbr, priv);\n\t\t\t\tif (err) {\n\t\t\t\t\tubifs_err(\"leaf checking function returned error %d, for leaf at LEB %d:%d\",\n\t\t\t\t\t\t  err, zbr->lnum, zbr->offs);\n\t\t\t\t\tgoto out_dump;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!znode->parent)\n\t\t\tbreak;\n\n\t\tidx = znode->iip + 1;\n\t\tznode = znode->parent;\n\t\tif (idx < znode->child_cnt) {\n\t\t\t/* Switch to the next index in the parent */\n\t\t\tzbr = &znode->zbranch[idx];\n\t\t\tchild = zbr->znode;\n\t\t\tif (!child) {\n\t\t\t\tchild = ubifs_load_znode(c, zbr, znode, idx);\n\t\t\t\tif (IS_ERR(child)) {\n\t\t\t\t\terr = PTR_ERR(child);\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t\tzbr->znode = child;\n\t\t\t}\n\t\t\tznode = child;\n\t\t} else\n\t\t\t/*\n\t\t\t * This is the last child, switch to the parent and\n\t\t\t * continue.\n\t\t\t */\n\t\t\tcontinue;\n\n\t\t/* Go to the lowest leftmost znode in the new sub-tree */\n\t\twhile (znode->level > 0) {\n\t\t\tzbr = &znode->zbranch[0];\n\t\t\tchild = zbr->znode;\n\t\t\tif (!child) {\n\t\t\t\tchild = ubifs_load_znode(c, zbr, znode, 0);\n\t\t\t\tif (IS_ERR(child)) {\n\t\t\t\t\terr = PTR_ERR(child);\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t\tzbr->znode = child;\n\t\t\t}\n\t\t\tznode = child;\n\t\t}\n\t}\n\n\tmutex_unlock(&c->tnc_mutex);\n\treturn 0;\n\nout_dump:\n\tif (znode->parent)\n\t\tzbr = &znode->parent->zbranch[znode->iip];\n\telse\n\t\tzbr = &c->zroot;\n\tubifs_msg(\"dump of znode at LEB %d:%d\", zbr->lnum, zbr->offs);\n\tubifs_dump_znode(c, znode);\nout_unlock:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n/**\n * add_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&c->tnc_mute",
          "args": [
            ");\n\treturn er"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, znode);\no",
          "args": [
            "t",
            "nlock"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp of zno",
          "args": [
            "e at LEB %d:%d\", zbr->lnum,",
            "r->offs);",
            "ubifs_dum"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->tnc_mute",
          "args": [
            ");\n\treturn 0;"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");",
          "args": [
            "goto"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "err"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, zbr, znod",
          "args": [
            ",",
            ");",
            "if",
            "S"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");",
          "args": [
            "goto"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "err"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, zbr, znod",
          "args": [
            ",",
            "dx)",
            "i",
            "(IS"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "af checki",
          "args": [
            "g function returned error %d, for leaf at LEB %d:%d\",\n\t\t\t\t\t\t  err",
            "m,",
            "r->offs);",
            "goto"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r, priv",
          "args": [
            ";",
            "(er"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, znode);",
          "args": [
            "oto o"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode check",
          "args": [
            "ng function returned error %d\",\n\t\t\t\t\t  err)",
            "fs_"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node, pr",
          "args": [
            "v",
            "i",
            "(err"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\n\t\tif (zn",
          "args": [],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");",
          "args": [
            "oto o"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {",
          "args": [
            "err"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, zbr, znod",
          "args": [
            ",",
            ");",
            "if (",
            "_"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oot.zno",
          "args": [
            "e);\n\t\t\tc->zroo"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ot.zno",
          "args": [
            "e)) {\n\t\t\terr ="
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, &c->zroot",
          "args": [
            "LL, 0);",
            "f (I",
            "E"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->tnc_mute",
          "args": [
            ");\n\t/* If the"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nindex(struct ubifs_info *c, dbg_leaf_callback leaf_cb,\n\t\t   dbg_znode_callback znode_cb, void *priv)\n{\n\tint err;\n\tstruct ubifs_zbranch *zbr;\n\tstruct ubifs_znode *znode, *child;\n\n\tmutex_lock(&c->tnc_mutex);\n\t/* If the root indexing node is not in TNC - pull it */\n\tif (!c->zroot.znode) {\n\t\tc->zroot.znode = ubifs_load_znode(c, &c->zroot, NULL, 0);\n\t\tif (IS_ERR(c->zroot.znode)) {\n\t\t\terr = PTR_ERR(c->zroot.znode);\n\t\t\tc->zroot.znode = NULL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/*\n\t * We are going to traverse the indexing tree in the postorder manner.\n\t * Go down and find the leftmost indexing node where we are going to\n\t * start from.\n\t */\n\tznode = c->zroot.znode;\n\twhile (znode->level > 0) {\n\t\tzbr = &znode->zbranch[0];\n\t\tchild = zbr->znode;\n\t\tif (!child) {\n\t\t\tchild = ubifs_load_znode(c, zbr, znode, 0);\n\t\t\tif (IS_ERR(child)) {\n\t\t\t\terr = PTR_ERR(child);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tzbr->znode = child;\n\t\t}\n\n\t\tznode = child;\n\t}\n\n\t/* Iterate over all indexing nodes */\n\twhile (1) {\n\t\tint idx;\n\n\t\tcond_resched();\n\n\t\tif (znode_cb) {\n\t\t\terr = znode_cb(c, znode, priv);\n\t\t\tif (err) {\n\t\t\t\tubifs_err(\"znode checking function returned error %d\",\n\t\t\t\t\t  err);\n\t\t\t\tubifs_dump_znode(c, znode);\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t}\n\t\tif (leaf_cb && znode->level == 0) {\n\t\t\tfor (idx = 0; idx < znode->child_cnt; idx++) {\n\t\t\t\tzbr = &znode->zbranch[idx];\n\t\t\t\terr = leaf_cb(c, zbr, priv);\n\t\t\t\tif (err) {\n\t\t\t\t\tubifs_err(\"leaf checking function returned error %d, for leaf at LEB %d:%d\",\n\t\t\t\t\t\t  err, zbr->lnum, zbr->offs);\n\t\t\t\t\tgoto out_dump;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!znode->parent)\n\t\t\tbreak;\n\n\t\tidx = znode->iip + 1;\n\t\tznode = znode->parent;\n\t\tif (idx < znode->child_cnt) {\n\t\t\t/* Switch to the next index in the parent */\n\t\t\tzbr = &znode->zbranch[idx];\n\t\t\tchild = zbr->znode;\n\t\t\tif (!child) {\n\t\t\t\tchild = ubifs_load_znode(c, zbr, znode, idx);\n\t\t\t\tif (IS_ERR(child)) {\n\t\t\t\t\terr = PTR_ERR(child);\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t\tzbr->znode = child;\n\t\t\t}\n\t\t\tznode = child;\n\t\t} else\n\t\t\t/*\n\t\t\t * This is the last child, switch to the parent and\n\t\t\t * continue.\n\t\t\t */\n\t\t\tcontinue;\n\n\t\t/* Go to the lowest leftmost znode in the new sub-tree */\n\t\twhile (znode->level > 0) {\n\t\t\tzbr = &znode->zbranch[0];\n\t\t\tchild = zbr->znode;\n\t\t\tif (!child) {\n\t\t\t\tchild = ubifs_load_znode(c, zbr, znode, 0);\n\t\t\t\tif (IS_ERR(child)) {\n\t\t\t\t\terr = PTR_ERR(child);\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t\tzbr->znode = child;\n\t\t\t}\n\t\t\tznode = child;\n\t\t}\n\t}\n\n\tmutex_unlock(&c->tnc_mutex);\n\treturn 0;\n\nout_dump:\n\tif (znode->parent)\n\t\tzbr = &znode->parent->zbranch[znode->iip];\n\telse\n\t\tzbr = &c->zroot;\n\tubifs_msg(\"dump of znode at LEB %d:%d\", zbr->lnum, zbr->offs);\n\tubifs_dump_znode(c, znode);\nout_unlock:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n/**\n * add_"
  },
  {
    "function_name": "(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "1469-1546",
    "snippet": "_tnc(struct ubifs_info *c, int extra)\n{\n\tstruct ubifs_znode *znode;\n\tlong clean_cnt = 0, dirty_cnt = 0;\n\tint err, last;\n\n\tif (!dbg_is_chk_index(c))\n\t\treturn 0;\n\n\tubifs_assert(mutex_is_locked(&c->tnc_mutex));\n\tif (!c->zroot.znode)\n\t\treturn 0;\n\n\tznode = ubifs_tnc_postorder_first(c->zroot.znode);\n\twhile (1) {\n\t\tstruct ubifs_znode *prev;\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\tif (!znode->parent)\n\t\t\tzbr = &c->zroot;\n\t\telse\n\t\t\tzbr = &znode->parent->zbranch[znode->iip];\n\n\t\terr = dbg_check_znode(c, zbr);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (extra) {\n\t\t\tif (ubifs_zn_dirty(znode))\n\t\t\t\tdirty_cnt += 1;\n\t\t\telse\n\t\t\t\tclean_cnt += 1;\n\t\t}\n\n\t\tprev = znode;\n\t\tznode = ubifs_tnc_postorder_next(znode);\n\t\tif (!znode)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If the last key of this znode is equivalent to the first key\n\t\t * of the next znode (collision), then check order of the keys.\n\t\t */\n\t\tlast = prev->child_cnt - 1;\n\t\tif (prev->level == 0 && znode->level == 0 && !c->replaying &&\n\t\t    !keys_cmp(c, &prev->zbranch[last].key,\n\t\t\t      &znode->zbranch[0].key)) {\n\t\t\terr = dbg_check_key_order(c, &prev->zbranch[last],\n\t\t\t\t\t\t  &znode->zbranch[0]);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (err) {\n\t\t\t\tubifs_msg(\"first znode\");\n\t\t\t\tubifs_dump_znode(c, prev);\n\t\t\t\tubifs_msg(\"second znode\");\n\t\t\t\tubifs_dump_znode(c, znode);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (extra) {\n\t\tif (clean_cnt != atomic_long_read(&c->clean_zn_cnt)) {\n\t\t\tubifs_err(\"incorrect clean_zn_cnt %ld, calculated %ld\",\n\t\t\t\t  atomic_long_read(&c->clean_zn_cnt),\n\t\t\t\t  clean_cnt);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (dirty_cnt != atomic_long_read(&c->dirty_zn_cnt)) {\n\t\t\tubifs_err(\"incorrect dirty_zn_cnt %ld, calculated %ld\",\n\t\t\t\t  atomic_long_read(&c->dirty_zn_cnt),\n\t\t\t\t  dirty_cnt);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "correct d",
          "args": [
            "rty_zn_cnt %ld, calculated %ld\",\n\t\t\t\t  atomi",
            "ead(&c->dirty_zn_cnt),\n\t\t\t\t  dirty",
            "return"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ead(&c->dirty_zn",
          "args": [
            "cnt),\n\t\t\t\t  dirt"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ead(&c->dirty_zn",
          "args": [
            "cnt)) {\n\t\t\tubifs"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "correct c",
          "args": [
            "ean_zn_cnt %ld, calculated %ld\",\n\t\t\t\t  atomi",
            "ead(&c->clean_zn_cnt),\n\t\t\t\t  clean",
            "return"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ead(&c->clean_zn",
          "args": [
            "cnt),\n\t\t\t\t  clea"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ead(&c->clean_zn",
          "args": [
            "cnt)) {\n\t\t\tubifs"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, znode);",
          "args": [
            "eturn"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond znod",
          "args": [
            "\");\n\t\t\t\tubifs_"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, prev);",
          "args": [
            "ifs_"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rst znode",
          "args": [
            ");\n\t\t\t\tubifs_"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_order(c, &prev->zb",
          "args": [
            "a",
            "h[last],\n\t\t\t\t\t\t  &zn",
            "ch[0]);\n\t\t\tif (err"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prev->zb",
          "args": [
            "a",
            "h[last].key,\n\t\t\t      &z",
            "ch[0].key)) {\n\t\t\terr ="
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torder_next(znode);\n\t\tif",
          "args": [
            "(!zno"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y(znode))",
          "args": [
            "irty_"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, zbr);\n\t\ti",
          "args": [
            "rr)"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torder_first(c->zroot.zno",
          "args": [
            "e);\n\twhile (1)"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&c->tnc_mutex));\n\tif (!c->z"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&c->tnc_mute",
          "args": [
            "));\n\tif (!c->"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dex(c))\n\t\treturn",
          "args": [
            "0"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\n_tnc(struct ubifs_info *c, int extra)\n{\n\tstruct ubifs_znode *znode;\n\tlong clean_cnt = 0, dirty_cnt = 0;\n\tint err, last;\n\n\tif (!dbg_is_chk_index(c))\n\t\treturn 0;\n\n\tubifs_assert(mutex_is_locked(&c->tnc_mutex));\n\tif (!c->zroot.znode)\n\t\treturn 0;\n\n\tznode = ubifs_tnc_postorder_first(c->zroot.znode);\n\twhile (1) {\n\t\tstruct ubifs_znode *prev;\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\tif (!znode->parent)\n\t\t\tzbr = &c->zroot;\n\t\telse\n\t\t\tzbr = &znode->parent->zbranch[znode->iip];\n\n\t\terr = dbg_check_znode(c, zbr);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (extra) {\n\t\t\tif (ubifs_zn_dirty(znode))\n\t\t\t\tdirty_cnt += 1;\n\t\t\telse\n\t\t\t\tclean_cnt += 1;\n\t\t}\n\n\t\tprev = znode;\n\t\tznode = ubifs_tnc_postorder_next(znode);\n\t\tif (!znode)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If the last key of this znode is equivalent to the first key\n\t\t * of the next znode (collision), then check order of the keys.\n\t\t */\n\t\tlast = prev->child_cnt - 1;\n\t\tif (prev->level == 0 && znode->level == 0 && !c->replaying &&\n\t\t    !keys_cmp(c, &prev->zbranch[last].key,\n\t\t\t      &znode->zbranch[0].key)) {\n\t\t\terr = dbg_check_key_order(c, &prev->zbranch[last],\n\t\t\t\t\t\t  &znode->zbranch[0]);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (err) {\n\t\t\t\tubifs_msg(\"first znode\");\n\t\t\t\tubifs_dump_znode(c, prev);\n\t\t\t\tubifs_msg(\"second znode\");\n\t\t\t\tubifs_dump_znode(c, znode);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (extra) {\n\t\tif (clean_cnt != atomic_long_read(&c->clean_zn_cnt)) {\n\t\t\tubifs_err(\"incorrect clean_zn_cnt %ld, calculated %ld\",\n\t\t\t\t  atomic_long_read(&c->clean_zn_cnt),\n\t\t\t\t  clean_cnt);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (dirty_cnt != atomic_long_read(&c->dirty_zn_cnt)) {\n\t\t\tubifs_err(\"incorrect dirty_zn_cnt %ld, calculated %ld\",\n\t\t\t\t  atomic_long_read(&c->dirty_zn_cnt),\n\t\t\t\t  dirty_cnt);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "de(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "1265-1459",
    "snippet": "g_check_znode(struct ubifs_info *c, struct ubifs_zbranch *zbr)\n{\n\tstruct ubifs_znode *znode = zbr->znode;\n\tstruct ubifs_znode *zp = znode->parent;\n\tint n, err, cmp;\n\n\tif (znode->child_cnt <= 0 || znode->child_cnt > c->fanout) {\n\t\terr = 1;\n\t\tgoto out;\n\t}\n\tif (znode->level < 0) {\n\t\terr = 2;\n\t\tgoto out;\n\t}\n\tif (znode->iip < 0 || znode->iip >= c->fanout) {\n\t\terr = 3;\n\t\tgoto out;\n\t}\n\n\tif (zbr->len == 0)\n\t\t/* Only dirty zbranch may have no on-flash nodes */\n\t\tif (!ubifs_zn_dirty(znode)) {\n\t\t\terr = 4;\n\t\t\tgoto out;\n\t\t}\n\n\tif (ubifs_zn_dirty(znode)) {\n\t\t/*\n\t\t * If znode is dirty, its parent has to be dirty as well. The\n\t\t * order of the operation is important, so we have to have\n\t\t * memory barriers.\n\t\t */\n\t\tsmp_mb();\n\t\tif (zp && !ubifs_zn_dirty(zp)) {\n\t\t\t/*\n\t\t\t * The dirty flag is atomic and is cleared outside the\n\t\t\t * TNC mutex, so znode's dirty flag may now have\n\t\t\t * been cleared. The child is always cleared before the\n\t\t\t * parent, so we just need to check again.\n\t\t\t */\n\t\t\tsmp_mb();\n\t\t\tif (ubifs_zn_dirty(znode)) {\n\t\t\t\terr = 5;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zp) {\n\t\tconst union ubifs_key *min, *max;\n\n\t\tif (znode->level != zp->level - 1) {\n\t\t\terr = 6;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Make sure the 'parent' pointer in our znode is correct */\n\t\terr = ubifs_search_zbranch(c, zp, &zbr->key, &n);\n\t\tif (!err) {\n\t\t\t/* This zbranch does not exist in the parent */\n\t\t\terr = 7;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (znode->iip >= zp->child_cnt) {\n\t\t\terr = 8;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (znode->iip != n) {\n\t\t\t/* This may happen only in case of collisions */\n\t\t\tif (keys_cmp(c, &zp->zbranch[n].key,\n\t\t\t\t     &zp->zbranch[znode->iip].key)) {\n\t\t\t\terr = 9;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tn = znode->iip;\n\t\t}\n\n\t\t/*\n\t\t * Make sure that the first key in our znode is greater than or\n\t\t * equal to the key in the pointing zbranch.\n\t\t */\n\t\tmin = &zbr->key;\n\t\tcmp = keys_cmp(c, min, &znode->zbranch[0].key);\n\t\tif (cmp == 1) {\n\t\t\terr = 10;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (n + 1 < zp->child_cnt) {\n\t\t\tmax = &zp->zbranch[n + 1].key;\n\n\t\t\t/*\n\t\t\t * Make sure the last key in our znode is less or\n\t\t\t * equivalent than the key in the zbranch which goes\n\t\t\t * after our pointing zbranch.\n\t\t\t */\n\t\t\tcmp = keys_cmp(c, max,\n\t\t\t\t&znode->zbranch[znode->child_cnt - 1].key);\n\t\t\tif (cmp == -1) {\n\t\t\t\terr = 11;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* This may only be root znode */\n\t\tif (zbr != &c->zroot) {\n\t\t\terr = 12;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that next key is greater or equivalent then the previous\n\t * one.\n\t */\n\tfor (n = 1; n < znode->child_cnt; n++) {\n\t\tcmp = keys_cmp(c, &znode->zbranch[n - 1].key,\n\t\t\t       &znode->zbranch[n].key);\n\t\tif (cmp > 0) {\n\t\t\terr = 13;\n\t\t\tgoto out;\n\t\t}\n\t\tif (cmp == 0) {\n\t\t\t/* This can only be keys with colliding hash */\n\t\t\tif (!is_hash_key(c, &znode->zbranch[n].key)) {\n\t\t\t\terr = 14;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (znode->level != 0 || c->replaying)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Colliding keys should follow binary order of\n\t\t\t * corresponding xentry/dentry names.\n\t\t\t */\n\t\t\terr = dbg_check_key_order(c, &znode->zbranch[n - 1],\n\t\t\t\t\t\t  &znode->zbranch[n]);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (err) {\n\t\t\t\terr = 15;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (n = 0; n < znode->child_cnt; n++) {\n\t\tif (!znode->zbranch[n].znode &&\n\t\t    (znode->zbranch[n].lnum == 0 ||\n\t\t     znode->zbranch[n].len == 0)) {\n\t\t\terr = 16;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (znode->zbranch[n].lnum != 0 &&\n\t\t    znode->zbranch[n].len == 0) {\n\t\t\terr = 17;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (znode->zbranch[n].lnum == 0 &&\n\t\t    znode->zbranch[n].len != 0) {\n\t\t\terr = 18;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (znode->zbranch[n].lnum == 0 &&\n\t\t    znode->zbranch[n].offs != 0) {\n\t\t\terr = 19;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (znode->level != 0 && znode->zbranch[n].znode)\n\t\t\tif (znode->zbranch[n].znode->parent != znode) {\n\t\t\t\terr = 20;\n\t\t\t\tgoto out;\n\t\t\t}\n\t}\n\n\treturn 0;\n\nout:\n\tubifs_err(\"failed, error %d\", err);\n\tubifs_msg(\"dump of the znode\");\n\tubifs_dump_znode(c, znode);\n\tif (zp) {\n\t\tubifs_msg(\"dump of the parent znode\");\n\t\tubifs_dump_znode(c, zp);\n\t}\n\tdump_stack();\n\treturn -EINVAL;\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "return -",
          "args": [],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, zp);\n\t}",
          "args": [
            "u",
            "_s"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp of the",
          "args": [
            "parent znode\");\n\t\tubifs_du"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, znode);",
          "args": [
            "f",
            "zp) {"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp of the",
          "args": [
            "znode\");\n\tubifs_dum"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iled, err",
          "args": [
            "r %d\", err);\n\tubif",
            "msg"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_order(c, &znode->z",
          "args": [
            "r",
            "ch[n - 1],\n\t\t\t\t\t\t  &zn",
            "ch[n]);\n\t\t\tif (err"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", &znode->z",
          "args": [
            "r",
            "ch[n].key)) {\n\t\t\t\terr"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode->z",
          "args": [
            "r",
            "ch[n - 1].key,\n\t\t\t       &",
            "ch[n].key);\n\t\tif (cmp"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ax,",
          "args": [
            "z",
            "de-",
            "ch[znode->child_cnt - 1].key);\n\t\t\tif (cmp"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in, &zno",
          "args": [
            "e",
            "zbr",
            "ch[0].key);\n\t\tif (cmp"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zp->zbra",
          "args": [
            "c",
            "n].key,\n\t\t\t\t     &z",
            "znode->iip].key)) {\n\t\t\t\terr"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zbranch(c, zp, &zbr-",
          "args": [
            "k",
            ",",
            ");\n\t\tif (",
            "rr"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y(znode)) {",
          "args": [
            "err"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if (ub",
          "args": [],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y(zp)) {\n\t\t\t/*",
          "args": [],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f (zp",
          "args": [],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y(znode)) {",
          "args": [
            "*"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y(znode)) {",
          "args": [
            "err ="
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\ng_check_znode(struct ubifs_info *c, struct ubifs_zbranch *zbr)\n{\n\tstruct ubifs_znode *znode = zbr->znode;\n\tstruct ubifs_znode *zp = znode->parent;\n\tint n, err, cmp;\n\n\tif (znode->child_cnt <= 0 || znode->child_cnt > c->fanout) {\n\t\terr = 1;\n\t\tgoto out;\n\t}\n\tif (znode->level < 0) {\n\t\terr = 2;\n\t\tgoto out;\n\t}\n\tif (znode->iip < 0 || znode->iip >= c->fanout) {\n\t\terr = 3;\n\t\tgoto out;\n\t}\n\n\tif (zbr->len == 0)\n\t\t/* Only dirty zbranch may have no on-flash nodes */\n\t\tif (!ubifs_zn_dirty(znode)) {\n\t\t\terr = 4;\n\t\t\tgoto out;\n\t\t}\n\n\tif (ubifs_zn_dirty(znode)) {\n\t\t/*\n\t\t * If znode is dirty, its parent has to be dirty as well. The\n\t\t * order of the operation is important, so we have to have\n\t\t * memory barriers.\n\t\t */\n\t\tsmp_mb();\n\t\tif (zp && !ubifs_zn_dirty(zp)) {\n\t\t\t/*\n\t\t\t * The dirty flag is atomic and is cleared outside the\n\t\t\t * TNC mutex, so znode's dirty flag may now have\n\t\t\t * been cleared. The child is always cleared before the\n\t\t\t * parent, so we just need to check again.\n\t\t\t */\n\t\t\tsmp_mb();\n\t\t\tif (ubifs_zn_dirty(znode)) {\n\t\t\t\terr = 5;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zp) {\n\t\tconst union ubifs_key *min, *max;\n\n\t\tif (znode->level != zp->level - 1) {\n\t\t\terr = 6;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Make sure the 'parent' pointer in our znode is correct */\n\t\terr = ubifs_search_zbranch(c, zp, &zbr->key, &n);\n\t\tif (!err) {\n\t\t\t/* This zbranch does not exist in the parent */\n\t\t\terr = 7;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (znode->iip >= zp->child_cnt) {\n\t\t\terr = 8;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (znode->iip != n) {\n\t\t\t/* This may happen only in case of collisions */\n\t\t\tif (keys_cmp(c, &zp->zbranch[n].key,\n\t\t\t\t     &zp->zbranch[znode->iip].key)) {\n\t\t\t\terr = 9;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tn = znode->iip;\n\t\t}\n\n\t\t/*\n\t\t * Make sure that the first key in our znode is greater than or\n\t\t * equal to the key in the pointing zbranch.\n\t\t */\n\t\tmin = &zbr->key;\n\t\tcmp = keys_cmp(c, min, &znode->zbranch[0].key);\n\t\tif (cmp == 1) {\n\t\t\terr = 10;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (n + 1 < zp->child_cnt) {\n\t\t\tmax = &zp->zbranch[n + 1].key;\n\n\t\t\t/*\n\t\t\t * Make sure the last key in our znode is less or\n\t\t\t * equivalent than the key in the zbranch which goes\n\t\t\t * after our pointing zbranch.\n\t\t\t */\n\t\t\tcmp = keys_cmp(c, max,\n\t\t\t\t&znode->zbranch[znode->child_cnt - 1].key);\n\t\t\tif (cmp == -1) {\n\t\t\t\terr = 11;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* This may only be root znode */\n\t\tif (zbr != &c->zroot) {\n\t\t\terr = 12;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure that next key is greater or equivalent then the previous\n\t * one.\n\t */\n\tfor (n = 1; n < znode->child_cnt; n++) {\n\t\tcmp = keys_cmp(c, &znode->zbranch[n - 1].key,\n\t\t\t       &znode->zbranch[n].key);\n\t\tif (cmp > 0) {\n\t\t\terr = 13;\n\t\t\tgoto out;\n\t\t}\n\t\tif (cmp == 0) {\n\t\t\t/* This can only be keys with colliding hash */\n\t\t\tif (!is_hash_key(c, &znode->zbranch[n].key)) {\n\t\t\t\terr = 14;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (znode->level != 0 || c->replaying)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Colliding keys should follow binary order of\n\t\t\t * corresponding xentry/dentry names.\n\t\t\t */\n\t\t\terr = dbg_check_key_order(c, &znode->zbranch[n - 1],\n\t\t\t\t\t\t  &znode->zbranch[n]);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (err) {\n\t\t\t\terr = 15;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (n = 0; n < znode->child_cnt; n++) {\n\t\tif (!znode->zbranch[n].znode &&\n\t\t    (znode->zbranch[n].lnum == 0 ||\n\t\t     znode->zbranch[n].len == 0)) {\n\t\t\terr = 16;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (znode->zbranch[n].lnum != 0 &&\n\t\t    znode->zbranch[n].len == 0) {\n\t\t\terr = 17;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (znode->zbranch[n].lnum == 0 &&\n\t\t    znode->zbranch[n].len != 0) {\n\t\t\terr = 18;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (znode->zbranch[n].lnum == 0 &&\n\t\t    znode->zbranch[n].offs != 0) {\n\t\t\terr = 19;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (znode->level != 0 && znode->zbranch[n].znode)\n\t\t\tif (znode->zbranch[n].znode->parent != znode) {\n\t\t\t\terr = 20;\n\t\t\t\tgoto out;\n\t\t\t}\n\t}\n\n\treturn 0;\n\nout:\n\tubifs_err(\"failed, error %d\", err);\n\tubifs_msg(\"dump of the znode\");\n\tubifs_dump_znode(c, znode);\n\tif (zp) {\n\t\tubifs_msg(\"dump of the parent znode\");\n\t\tubifs_dump_znode(c, zp);\n\t}\n\tdump_stack();\n\treturn -EINVAL;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "_order(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "1174-1255",
    "snippet": "g_check_key_order(struct ubifs_info *c, struct ubifs_zbranch *zbr1,\n\t\t\t       struct ubifs_zbranch *zbr2)\n{\n\tint err, nlen1, nlen2, cmp;\n\tstruct ubifs_dent_node *dent1, *dent2;\n\tunion ubifs_key key;\n\tchar key_buf[DBG_KEY_BUF_LEN];\n\n\tubifs_assert(!keys_cmp(c, &zbr1->key, &zbr2->key));\n\tdent1 = kmalloc(UBIFS_MAX_DENT_NODE_SZ, GFP_NOFS);\n\tif (!dent1)\n\t\treturn -ENOMEM;\n\tdent2 = kmalloc(UBIFS_MAX_DENT_NODE_SZ, GFP_NOFS);\n\tif (!dent2) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\terr = ubifs_tnc_read_node(c, zbr1, dent1);\n\tif (err)\n\t\tgoto out_free;\n\terr = ubifs_validate_entry(c, dent1);\n\tif (err)\n\t\tgoto out_free;\n\n\terr = ubifs_tnc_read_node(c, zbr2, dent2);\n\tif (err)\n\t\tgoto out_free;\n\terr = ubifs_validate_entry(c, dent2);\n\tif (err)\n\t\tgoto out_free;\n\n\t/* Make sure node keys are the same as in zbranch */\n\terr = 1;\n\tkey_read(c, &dent1->key, &key);\n\tif (keys_cmp(c, &zbr1->key, &key)) {\n\t\tubifs_err(\"1st entry at %d:%d has key %s\", zbr1->lnum,\n\t\t\t  zbr1->offs, dbg_snprintf_key(c, &key, key_buf,\n\t\t\t\t\t\t       DBG_KEY_BUF_LEN));\n\t\tubifs_err(\"but it should have key %s according to tnc\",\n\t\t\t  dbg_snprintf_key(c, &zbr1->key, key_buf,\n\t\t\t\t\t   DBG_KEY_BUF_LEN));\n\t\tubifs_dump_node(c, dent1);\n\t\tgoto out_free;\n\t}\n\n\tkey_read(c, &dent2->key, &key);\n\tif (keys_cmp(c, &zbr2->key, &key)) {\n\t\tubifs_err(\"2nd entry at %d:%d has key %s\", zbr1->lnum,\n\t\t\t  zbr1->offs, dbg_snprintf_key(c, &key, key_buf,\n\t\t\t\t\t\t       DBG_KEY_BUF_LEN));\n\t\tubifs_err(\"but it should have key %s according to tnc\",\n\t\t\t  dbg_snprintf_key(c, &zbr2->key, key_buf,\n\t\t\t\t\t   DBG_KEY_BUF_LEN));\n\t\tubifs_dump_node(c, dent2);\n\t\tgoto out_free;\n\t}\n\n\tnlen1 = le16_to_cpu(dent1->nlen);\n\tnlen2 = le16_to_cpu(dent2->nlen);\n\n\tcmp = memcmp(dent1->name, dent2->name, min_t(int, nlen1, nlen2));\n\tif (cmp < 0 || (cmp == 0 && nlen1 < nlen2)) {\n\t\terr = 0;\n\t\tgoto out_free;\n\t}\n\tif (cmp == 0 && nlen1 == nlen2)\n\t\tubifs_err(\"2 xent/dent nodes with the same name\");\n\telse\n\t\tubifs_err(\"bad order of colliding key %s\",\n\t\t\t  dbg_snprintf_key(c, &key, key_buf, DBG_KEY_BUF_LEN));\n\n\tubifs_msg(\"first node at %d:%d\\n\", zbr1->lnum, zbr1->offs);\n\tubifs_dump_node(c, dent1);\n\tubifs_msg(\"second node at %d:%d\\n\", zbr2->lnum, zbr2->offs);\n\tubifs_dump_node(c, dent2);\n\nout_free:\n\tkfree(dent2);\n\tkfree(dent1);\n\treturn err;\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ret",
          "args": [
            "rn er"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "retire_sysctl_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1567-1570",
          "snippet": "void retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nvoid retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfr",
          "args": [
            "e(den"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, dent2);",
          "args": [
            "u",
            "free:"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond node",
          "args": [
            "at %d:%d\\n\", zbr2->lnum,",
            "br2->offs)",
            "ubifs_dum"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, dent1);",
          "args": [
            "b",
            "s_msg"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rst node",
          "args": [
            "t %d:%d\\n\", zbr1->lnum,",
            "br1->offs)",
            "ubifs_dum"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d order o",
          "args": [
            "colliding key %s\",\n\t\t\t  dbg_sn",
            "key(c, &key, key_buf, DBG_KEY_BUF_LEN));\n\n\tubifs_ms"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key(c, &key, key",
          "args": [
            "b",
            ", DB",
            "KEY_BUF",
            "EN));\n\n\tubifs_m"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xent/dent",
          "args": [
            "nodes with the same name\");\n\telse\n\t\tub"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">name,",
          "args": [
            "dent2->name",
            "min_t(int,",
            "en1, nlen2));\n\tif (cmp <"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en1,",
          "args": [
            "len",
            ");\n\ti",
            "(cmp"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent2->nlen)",
          "args": [
            "cmp = me"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent1->nlen)",
          "args": [
            "nlen2 = l"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, dent2);",
          "args": [
            "g",
            "o out"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t it shou",
          "args": [
            "d have key %s according to tnc\",\n\t\t\t  dbg_sn",
            "key(c, &zbr2->key, key_buf,\n\t\t\t\t\t   DBG_KEY_BUF_LEN));\n\t\tubifs_du"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key(c, &zbr2->ke",
          "args": [
            ",",
            "ey_buf,",
            "DBG",
            "EN));\n\t\tubifs_d"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d entry a",
          "args": [
            "%d:%d has key %s\", zbr1->lnum,",
            "zbr1->",
            "bg_snprint",
            "key(c, &key, key_buf,\n\t\t\t\t\t\t       DBG_KEY_BUF_LEN));\n\t\tubifs_er"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key(c, &key, key",
          "args": [
            "b",
            ",",
            "EN));\n\t\tubifs_e"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zbr2->ke",
          "args": [
            ",",
            "key)) {",
            "ifs_"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dent2->k",
          "args": [
            "y",
            "&key);\n\tif",
            "eys_"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, dent1);",
          "args": [
            "g",
            "o out"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t it shou",
          "args": [
            "d have key %s according to tnc\",\n\t\t\t  dbg_sn",
            "key(c, &zbr1->key, key_buf,\n\t\t\t\t\t   DBG_KEY_BUF_LEN));\n\t\tubifs_du"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key(c, &zbr1->ke",
          "args": [
            ",",
            "ey_buf,",
            "DBG",
            "EN));\n\t\tubifs_d"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t entry a",
          "args": [
            "%d:%d has key %s\", zbr1->lnum,",
            "zbr1->",
            "bg_snprint",
            "key(c, &key, key_buf,\n\t\t\t\t\t\t       DBG_KEY_BUF_LEN));\n\t\tubifs_er"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key(c, &key, key",
          "args": [
            "b",
            ",",
            "EN));\n\t\tubifs_e"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zbr1->ke",
          "args": [
            ",",
            "key)) {",
            "ifs_"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dent1->k",
          "args": [
            "y",
            "&key);\n\tif",
            "eys_"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_entry(c, dent2);",
          "args": [
            "f",
            "err)"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_node(c, zbr2, den",
          "args": [
            "2",
            "if",
            "err)"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_entry(c, dent1);",
          "args": [
            "f",
            "err)"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_node(c, zbr1, den",
          "args": [
            "1",
            "if",
            "err)"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_MAX_DE",
          "args": [
            "T_NODE_SZ, GFP_NOFS);",
            "f (!dent"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_MAX_DE",
          "args": [
            "T_NODE_SZ, GFP_NOFS);",
            "f (!dent"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!keys_cmp(c,",
          "args": [
            "&zbr1->key, &zbr2->key));\n\tdent1 = k"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zbr1->ke",
          "args": [
            ",",
            "zbr2->key)",
            "dent1 ="
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\ng_check_key_order(struct ubifs_info *c, struct ubifs_zbranch *zbr1,\n\t\t\t       struct ubifs_zbranch *zbr2)\n{\n\tint err, nlen1, nlen2, cmp;\n\tstruct ubifs_dent_node *dent1, *dent2;\n\tunion ubifs_key key;\n\tchar key_buf[DBG_KEY_BUF_LEN];\n\n\tubifs_assert(!keys_cmp(c, &zbr1->key, &zbr2->key));\n\tdent1 = kmalloc(UBIFS_MAX_DENT_NODE_SZ, GFP_NOFS);\n\tif (!dent1)\n\t\treturn -ENOMEM;\n\tdent2 = kmalloc(UBIFS_MAX_DENT_NODE_SZ, GFP_NOFS);\n\tif (!dent2) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\terr = ubifs_tnc_read_node(c, zbr1, dent1);\n\tif (err)\n\t\tgoto out_free;\n\terr = ubifs_validate_entry(c, dent1);\n\tif (err)\n\t\tgoto out_free;\n\n\terr = ubifs_tnc_read_node(c, zbr2, dent2);\n\tif (err)\n\t\tgoto out_free;\n\terr = ubifs_validate_entry(c, dent2);\n\tif (err)\n\t\tgoto out_free;\n\n\t/* Make sure node keys are the same as in zbranch */\n\terr = 1;\n\tkey_read(c, &dent1->key, &key);\n\tif (keys_cmp(c, &zbr1->key, &key)) {\n\t\tubifs_err(\"1st entry at %d:%d has key %s\", zbr1->lnum,\n\t\t\t  zbr1->offs, dbg_snprintf_key(c, &key, key_buf,\n\t\t\t\t\t\t       DBG_KEY_BUF_LEN));\n\t\tubifs_err(\"but it should have key %s according to tnc\",\n\t\t\t  dbg_snprintf_key(c, &zbr1->key, key_buf,\n\t\t\t\t\t   DBG_KEY_BUF_LEN));\n\t\tubifs_dump_node(c, dent1);\n\t\tgoto out_free;\n\t}\n\n\tkey_read(c, &dent2->key, &key);\n\tif (keys_cmp(c, &zbr2->key, &key)) {\n\t\tubifs_err(\"2nd entry at %d:%d has key %s\", zbr1->lnum,\n\t\t\t  zbr1->offs, dbg_snprintf_key(c, &key, key_buf,\n\t\t\t\t\t\t       DBG_KEY_BUF_LEN));\n\t\tubifs_err(\"but it should have key %s according to tnc\",\n\t\t\t  dbg_snprintf_key(c, &zbr2->key, key_buf,\n\t\t\t\t\t   DBG_KEY_BUF_LEN));\n\t\tubifs_dump_node(c, dent2);\n\t\tgoto out_free;\n\t}\n\n\tnlen1 = le16_to_cpu(dent1->nlen);\n\tnlen2 = le16_to_cpu(dent2->nlen);\n\n\tcmp = memcmp(dent1->name, dent2->name, min_t(int, nlen1, nlen2));\n\tif (cmp < 0 || (cmp == 0 && nlen1 < nlen2)) {\n\t\terr = 0;\n\t\tgoto out_free;\n\t}\n\tif (cmp == 0 && nlen1 == nlen2)\n\t\tubifs_err(\"2 xent/dent nodes with the same name\");\n\telse\n\t\tubifs_err(\"bad order of colliding key %s\",\n\t\t\t  dbg_snprintf_key(c, &key, key_buf, DBG_KEY_BUF_LEN));\n\n\tubifs_msg(\"first node at %d:%d\\n\", zbr1->lnum, zbr1->offs);\n\tubifs_dump_node(c, dent1);\n\tubifs_msg(\"second node at %d:%d\\n\", zbr2->lnum, zbr2->offs);\n\tubifs_dump_node(c, dent2);\n\nout_free:\n\tkfree(dent2);\n\tkfree(dent1);\n\treturn err;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "1105-1159",
    "snippet": "_dir(struct ubifs_info *c, const struct inode *dir)\n{\n\tunsigned int nlink = 2;\n\tunion ubifs_key key;\n\tstruct ubifs_dent_node *dent, *pdent = NULL;\n\tstruct qstr nm = { .name = NULL };\n\tloff_t size = UBIFS_INO_NODE_SZ;\n\n\tif (!dbg_is_chk_gen(c))\n\t\treturn 0;\n\n\tif (!S_ISDIR(dir->i_mode))\n\t\treturn 0;\n\n\tlowest_dent_key(c, &key, dir->i_ino);\n\twhile (1) {\n\t\tint err;\n\n\t\tdent = ubifs_tnc_next_ent(c, &key, &nm);\n\t\tif (IS_ERR(dent)) {\n\t\t\terr = PTR_ERR(dent);\n\t\t\tif (err == -ENOENT)\n\t\t\t\tbreak;\n\t\t\treturn err;\n\t\t}\n\n\t\tnm.name = dent->name;\n\t\tnm.len = le16_to_cpu(dent->nlen);\n\t\tsize += CALC_DENT_SIZE(nm.len);\n\t\tif (dent->type == UBIFS_ITYPE_DIR)\n\t\t\tnlink += 1;\n\t\tkfree(pdent);\n\t\tpdent = dent;\n\t\tkey_read(c, &dent->key, &key);\n\t}\n\tkfree(pdent);\n\n\tif (i_size_read(dir) != size) {\n\t\tubifs_err(\"directory inode %lu has size %llu, but calculated size is %llu\",\n\t\t\t  dir->i_ino, (unsigned long long)i_size_read(dir),\n\t\t\t  (unsigned long long)size);\n\t\tubifs_dump_inode(c, dir);\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\tif (dir->i_nlink != nlink) {\n\t\tubifs_err(\"directory inode %lu has nlink %u, but calculated nlink is %u\",\n\t\t\t  dir->i_ino, dir->i_nlink, nlink);\n\t\tubifs_dump_inode(c, dir);\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "return",
          "args": [],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "coda_return_EIO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "32-35",
          "snippet": "static int coda_return_EIO(void)\n{\n\treturn -EIO;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int coda_return_EIO(void)\n{\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ode(c, dir);\n\t\td",
          "args": [
            "m",
            "sta"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rectory i",
          "args": [
            "ode %lu has nlink %u, but calculated nlink is %u\",\n\t\t\t  dir->i",
            "ir->i_nlin",
            "nlink);\n\t\tu",
            "fs_du"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, dir);\n\t\td",
          "args": [
            "m",
            "sta"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rectory i",
          "args": [
            "ode %lu has size %llu, but calculated size is %llu\",\n\t\t\t  dir->i",
            "unsigned l",
            "g long)i_size_read(dir),\n\t\t\t  (unsig",
            "g long)size);\n\t\tubifs_du"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir),\n\t\t\t  (",
          "args": [
            "nsi"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir) != size",
          "args": [
            "{"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if",
          "args": [
            "(i_si"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "ng_exit(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
          "lines": "3101-3104",
          "snippet": "bugging_exit(struct ubifs_info *c)\n{\n\tkfree(c->dbg);\n}",
          "includes": [
            "fs.h\"\n\nstatic DEFIN",
            "ux/random.h>\n#include \"ubi",
            "ux/uaccess.h>\n#include <lin",
            "ux/math64.h>\n#include <lin",
            "ux/debugfs.h>\n#include <lin",
            "ux/module.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nbugging_exit(struct ubifs_info *c)\n{\n\tkfree(c->dbg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dent->ke",
          "args": [
            ",",
            "key);\n\t}",
            "ree("
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pd",
          "args": [
            "nt ="
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "update_mem_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/debug.c",
          "lines": "124-194",
          "snippet": "static void update_mem_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\n\tunsigned npages;\n\tint i;\n\n\tif (si->base_mem)\n\t\tgoto get_cache;\n\n\tsi->base_mem = sizeof(struct f2fs_sb_info) + sbi->sb->s_blocksize;\n\tsi->base_mem += 2 * sizeof(struct f2fs_inode_info);\n\tsi->base_mem += sizeof(*sbi->ckpt);\n\n\t/* build sm */\n\tsi->base_mem += sizeof(struct f2fs_sm_info);\n\n\t/* build sit */\n\tsi->base_mem += sizeof(struct sit_info);\n\tsi->base_mem += MAIN_SEGS(sbi) * sizeof(struct seg_entry);\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += 2 * SIT_VBLOCK_MAP_SIZE * MAIN_SEGS(sbi);\n\tsi->base_mem += SIT_VBLOCK_MAP_SIZE;\n\tif (sbi->segs_per_sec > 1)\n\t\tsi->base_mem += MAIN_SECS(sbi) * sizeof(struct sec_entry);\n\tsi->base_mem += __bitmap_size(sbi, SIT_BITMAP);\n\n\t/* build free segmap */\n\tsi->base_mem += sizeof(struct free_segmap_info);\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SECS(sbi));\n\n\t/* build curseg */\n\tsi->base_mem += sizeof(struct curseg_info) * NR_CURSEG_TYPE;\n\tsi->base_mem += PAGE_CACHE_SIZE * NR_CURSEG_TYPE;\n\n\t/* build dirty segmap */\n\tsi->base_mem += sizeof(struct dirty_seglist_info);\n\tsi->base_mem += NR_DIRTY_TYPE * f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SECS(sbi));\n\n\t/* build nm */\n\tsi->base_mem += sizeof(struct f2fs_nm_info);\n\tsi->base_mem += __bitmap_size(sbi, NAT_BITMAP);\n\nget_cache:\n\tsi->cache_mem = 0;\n\n\t/* build gc */\n\tif (sbi->gc_thread)\n\t\tsi->cache_mem += sizeof(struct f2fs_gc_kthread);\n\n\t/* build merge flush thread */\n\tif (SM_I(sbi)->cmd_control_info)\n\t\tsi->cache_mem += sizeof(struct flush_cmd_control);\n\n\t/* free nids */\n\tsi->cache_mem += NM_I(sbi)->fcnt * sizeof(struct free_nid);\n\tsi->cache_mem += NM_I(sbi)->nat_cnt * sizeof(struct nat_entry);\n\tsi->cache_mem += NM_I(sbi)->dirty_nat_cnt *\n\t\t\t\t\tsizeof(struct nat_entry_set);\n\tsi->cache_mem += si->inmem_pages * sizeof(struct inmem_pages);\n\tsi->cache_mem += sbi->n_dirty_dirs * sizeof(struct inode_entry);\n\tfor (i = 0; i <= UPDATE_INO; i++)\n\t\tsi->cache_mem += sbi->im[i].ino_num * sizeof(struct ino_entry);\n\n\tsi->page_mem = 0;\n\tnpages = NODE_MAPPING(sbi)->nrpages;\n\tsi->page_mem += npages << PAGE_CACHE_SHIFT;\n\tnpages = META_MAPPING(sbi)->nrpages;\n\tsi->page_mem += npages << PAGE_CACHE_SHIFT;\n}",
          "includes": [
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/blkdev.h>\n#include <linux/f2fs_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic void update_mem_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\n\tunsigned npages;\n\tint i;\n\n\tif (si->base_mem)\n\t\tgoto get_cache;\n\n\tsi->base_mem = sizeof(struct f2fs_sb_info) + sbi->sb->s_blocksize;\n\tsi->base_mem += 2 * sizeof(struct f2fs_inode_info);\n\tsi->base_mem += sizeof(*sbi->ckpt);\n\n\t/* build sm */\n\tsi->base_mem += sizeof(struct f2fs_sm_info);\n\n\t/* build sit */\n\tsi->base_mem += sizeof(struct sit_info);\n\tsi->base_mem += MAIN_SEGS(sbi) * sizeof(struct seg_entry);\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += 2 * SIT_VBLOCK_MAP_SIZE * MAIN_SEGS(sbi);\n\tsi->base_mem += SIT_VBLOCK_MAP_SIZE;\n\tif (sbi->segs_per_sec > 1)\n\t\tsi->base_mem += MAIN_SECS(sbi) * sizeof(struct sec_entry);\n\tsi->base_mem += __bitmap_size(sbi, SIT_BITMAP);\n\n\t/* build free segmap */\n\tsi->base_mem += sizeof(struct free_segmap_info);\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SECS(sbi));\n\n\t/* build curseg */\n\tsi->base_mem += sizeof(struct curseg_info) * NR_CURSEG_TYPE;\n\tsi->base_mem += PAGE_CACHE_SIZE * NR_CURSEG_TYPE;\n\n\t/* build dirty segmap */\n\tsi->base_mem += sizeof(struct dirty_seglist_info);\n\tsi->base_mem += NR_DIRTY_TYPE * f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SECS(sbi));\n\n\t/* build nm */\n\tsi->base_mem += sizeof(struct f2fs_nm_info);\n\tsi->base_mem += __bitmap_size(sbi, NAT_BITMAP);\n\nget_cache:\n\tsi->cache_mem = 0;\n\n\t/* build gc */\n\tif (sbi->gc_thread)\n\t\tsi->cache_mem += sizeof(struct f2fs_gc_kthread);\n\n\t/* build merge flush thread */\n\tif (SM_I(sbi)->cmd_control_info)\n\t\tsi->cache_mem += sizeof(struct flush_cmd_control);\n\n\t/* free nids */\n\tsi->cache_mem += NM_I(sbi)->fcnt * sizeof(struct free_nid);\n\tsi->cache_mem += NM_I(sbi)->nat_cnt * sizeof(struct nat_entry);\n\tsi->cache_mem += NM_I(sbi)->dirty_nat_cnt *\n\t\t\t\t\tsizeof(struct nat_entry_set);\n\tsi->cache_mem += si->inmem_pages * sizeof(struct inmem_pages);\n\tsi->cache_mem += sbi->n_dirty_dirs * sizeof(struct inode_entry);\n\tfor (i = 0; i <= UPDATE_INO; i++)\n\t\tsi->cache_mem += sbi->im[i].ino_num * sizeof(struct ino_entry);\n\n\tsi->page_mem = 0;\n\tnpages = NODE_MAPPING(sbi)->nrpages;\n\tsi->page_mem += npages << PAGE_CACHE_SHIFT;\n\tnpages = META_MAPPING(sbi)->nrpages;\n\tsi->page_mem += npages << PAGE_CACHE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "E(nm.len);\n\t\ti",
          "args": [
            "(dent"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent->nlen);",
          "args": [
            "size +="
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tif",
          "args": [
            "(err"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{",
          "args": [
            "rr ="
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "xit(void)\n{\n\tif",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
          "lines": "3074-3078",
          "snippet": "gfs_exit(void)\n{\n\tif (IS_ENABLED(CONFIG_DEBUG_FS))\n\t\tdebugfs_remove_recursive(dfs_rootdir);\n}\n\n/**\n * ubif",
          "includes": [
            "fs.h\"\n\nstatic DEFIN",
            "ux/random.h>\n#include \"ubi",
            "ux/uaccess.h>\n#include <lin",
            "ux/math64.h>\n#include <lin",
            "ux/debugfs.h>\n#include <lin",
            "ux/module.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [
            "dentry *dfs_rootdir;\n\nstatic int"
          ],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\ndentry *dfs_rootdir;\n\nstatic int;\n\ngfs_exit(void)\n{\n\tif (IS_ENABLED(CONFIG_DEBUG_FS))\n\t\tdebugfs_remove_recursive(dfs_rootdir);\n}\n\n/**\n * ubif"
        }
      },
      {
        "call_info": {
          "callee": "t_ent(c, &key, &nm",
          "args": [
            ";",
            "if",
            "S_E"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey(c, &key, dir",
          "args": [
            ">",
            "ino)",
            "while (1)"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_mode)",
          "args": [
            "return 0"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n(c))\n\t\treturn",
          "args": [
            "0"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\n_dir(struct ubifs_info *c, const struct inode *dir)\n{\n\tunsigned int nlink = 2;\n\tunion ubifs_key key;\n\tstruct ubifs_dent_node *dent, *pdent = NULL;\n\tstruct qstr nm = { .name = NULL };\n\tloff_t size = UBIFS_INO_NODE_SZ;\n\n\tif (!dbg_is_chk_gen(c))\n\t\treturn 0;\n\n\tif (!S_ISDIR(dir->i_mode))\n\t\treturn 0;\n\n\tlowest_dent_key(c, &key, dir->i_ino);\n\twhile (1) {\n\t\tint err;\n\n\t\tdent = ubifs_tnc_next_ent(c, &key, &nm);\n\t\tif (IS_ERR(dent)) {\n\t\t\terr = PTR_ERR(dent);\n\t\t\tif (err == -ENOENT)\n\t\t\t\tbreak;\n\t\t\treturn err;\n\t\t}\n\n\t\tnm.name = dent->name;\n\t\tnm.len = le16_to_cpu(dent->nlen);\n\t\tsize += CALC_DENT_SIZE(nm.len);\n\t\tif (dent->type == UBIFS_ITYPE_DIR)\n\t\t\tnlink += 1;\n\t\tkfree(pdent);\n\t\tpdent = dent;\n\t\tkey_read(c, &dent->key, &key);\n\t}\n\tkfree(pdent);\n\n\tif (i_size_read(dir) != size) {\n\t\tubifs_err(\"directory inode %lu has size %llu, but calculated size is %llu\",\n\t\t\t  dir->i_ino, (unsigned long long)i_size_read(dir),\n\t\t\t  (unsigned long long)size);\n\t\tubifs_dump_inode(c, dir);\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\tif (dir->i_nlink != nlink) {\n\t\tubifs_err(\"directory inode %lu has nlink %u, but calculated nlink is %u\",\n\t\t\t  dir->i_ino, dir->i_nlink, nlink);\n\t\tubifs_dump_inode(c, dir);\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "ced_i_size(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "1067-1090",
    "snippet": "_synced_i_size(const struct ubifs_info *c, struct inode *inode)\n{\n\tint err = 0;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tif (!dbg_is_chk_gen(c))\n\t\treturn 0;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\n\tmutex_lock(&ui->ui_mutex);\n\tspin_lock(&ui->ui_lock);\n\tif (ui->ui_size != ui->synced_i_size && !ui->dirty) {\n\t\tubifs_err(\"ui_size is %lld, synced_i_size is %lld, but inode is clean\",\n\t\t\t  ui->ui_size, ui->synced_i_size);\n\t\tubifs_err(\"i_ino %lu, i_mode %#x, i_size %lld\", inode->i_ino,\n\t\t\t  inode->i_mode, i_size_read(inode));\n\t\tdump_stack();\n\t\terr = -EINVAL;\n\t}\n\tspin_unlock(&ui->ui_lock);\n\tmutex_unlock(&ui->ui_mutex);\n\treturn err;\n}\n\n/*\n * dbg_c",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&ui->ui_mute",
          "args": [
            ");\n\treturn er"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui->ui_lock",
          "args": [
            ";\n\tmutex_unl"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err = -",
          "args": [],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ino %lu,",
          "args": [
            "_mode %#x, i_size %lld\", inode->i_in",
            "inode-",
            ", i_size_read",
            "node));\n\t\tdump_sta"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node));\n\t\td",
          "args": [
            "mp_st"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_size is",
          "args": [
            "lld, synced_i_size is %lld, but inode is clean\",\n\t\t\t  ui->ui",
            "ui->synced_",
            "size);\n\t\tubifs_er"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->ui_lock",
          "args": [
            ";\n\tif (ui->u"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->ui_mute",
          "args": [
            ");\n\tspin_lock"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->i_mod",
          "args": [
            "))\n\t\treturn 0"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n(c))\n\t\treturn",
          "args": [
            "0"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\n\tif",
          "args": [
            "(!dbg"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\n_synced_i_size(const struct ubifs_info *c, struct inode *inode)\n{\n\tint err = 0;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tif (!dbg_is_chk_gen(c))\n\t\treturn 0;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\n\tmutex_lock(&ui->ui_mutex);\n\tspin_lock(&ui->ui_lock);\n\tif (ui->ui_size != ui->synced_i_size && !ui->dirty) {\n\t\tubifs_err(\"ui_size is %lld, synced_i_size is %lld, but inode is clean\",\n\t\t\t  ui->ui_size, ui->synced_i_size);\n\t\tubifs_err(\"i_ino %lu, i_mode %#x, i_size %lld\", inode->i_ino,\n\t\t\t  inode->i_mode, i_size_read(inode));\n\t\tdump_stack();\n\t\terr = -EINVAL;\n\t}\n\tspin_unlock(&ui->ui_lock);\n\tmutex_unlock(&ui->ui_mutex);\n\treturn err;\n}\n\n/*\n * dbg_c"
  },
  {
    "function_name": "ce_info(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "1020-1055",
    "snippet": "_space_info(struct ubifs_info *c)\n{\n\tstruct ubifs_debug_info *d = c->dbg;\n\tstruct ubifs_lp_stats lst;\n\tlong long free;\n\tint freeable_cnt;\n\n\tspin_lock(&c->space_lock);\n\tfreeable_cnt = c->freeable_cnt;\n\tc->freeable_cnt = 0;\n\tfree = ubifs_get_free_space_nolock(c);\n\tc->freeable_cnt = freeable_cnt;\n\tspin_unlock(&c->space_lock);\n\n\tif (free != d->saved_free) {\n\t\tubifs_err(\"free space changed from %lld to %lld\",\n\t\t\t  d->saved_free, free);\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tubifs_msg(\"saved lprops statistics dump\");\n\tubifs_dump_lstats(&d->saved_lst);\n\tubifs_msg(\"saved budgeting info dump\");\n\tubifs_dump_budg(c, &d->saved_bi);\n\tubifs_msg(\"saved idx_gc_cnt %d\", d->saved_idx_gc_cnt);\n\tubifs_msg(\"current lprops statistics dump\");\n\tubifs_get_lp_stats(c, &lst);\n\tubifs_dump_lstats(&lst);\n\tubifs_msg(\"current budgeting info dump\");\n\tubifs_dump_budg(c, &c->bi);\n\tdump_stack();\n\treturn -EINVAL;\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "return -",
          "args": [],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dg(c, &c->bi);",
          "args": [
            "d",
            "p_stac"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rrent bud",
          "args": [
            "eting info dump\");\n\tubifs_dum"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tats(&lst);\n\tubif",
          "args": [
            "_msg"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stats(c, &lst);\n\tu",
          "args": [
            "i",
            "_dum"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rrent lpr",
          "args": [
            "ps statistics dump\");\n\tubifs_get"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ved idx_g",
          "args": [
            "_cnt %d\", d->saved_id",
            "gc_cnt);\n\tubifs_msg"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dg(c, &d->saved",
          "args": [
            "b",
            ";\n\tubifs_msg"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ved budge",
          "args": [
            "ing info dump\");\n\tubifs_dum"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tats(&d->saved_ls",
          "args": [
            ");\n\tubifs_msg"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ved lprop",
          "args": [
            "statistics dump\");\n\tubifs_dum"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ee space",
          "args": [
            "hanged from %lld to %lld\",\n\t\t\t  d->sav",
            ", free);\n\t\tgo",
            "out"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->space_lo",
          "args": [
            "k);\n\n\tif (free"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_space_nolock(c);\n\tc->free",
          "args": [
            "b"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">space_lo",
          "args": [
            "k);\n\tfreeable_"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\n_space_info(struct ubifs_info *c)\n{\n\tstruct ubifs_debug_info *d = c->dbg;\n\tstruct ubifs_lp_stats lst;\n\tlong long free;\n\tint freeable_cnt;\n\n\tspin_lock(&c->space_lock);\n\tfreeable_cnt = c->freeable_cnt;\n\tc->freeable_cnt = 0;\n\tfree = ubifs_get_free_space_nolock(c);\n\tc->freeable_cnt = freeable_cnt;\n\tspin_unlock(&c->space_lock);\n\n\tif (free != d->saved_free) {\n\t\tubifs_err(\"free space changed from %lld to %lld\",\n\t\t\t  d->saved_free, free);\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tubifs_msg(\"saved lprops statistics dump\");\n\tubifs_dump_lstats(&d->saved_lst);\n\tubifs_msg(\"saved budgeting info dump\");\n\tubifs_dump_budg(c, &d->saved_bi);\n\tubifs_msg(\"saved idx_gc_cnt %d\", d->saved_idx_gc_cnt);\n\tubifs_msg(\"current lprops statistics dump\");\n\tubifs_get_lp_stats(c, &lst);\n\tubifs_dump_lstats(&lst);\n\tubifs_msg(\"current budgeting info dump\");\n\tubifs_dump_budg(c, &c->bi);\n\tdump_stack();\n\treturn -EINVAL;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "e_info(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "970-1009",
    "snippet": "_space_info(struct ubifs_info *c)\n{\n\tstruct ubifs_debug_info *d = c->dbg;\n\tint freeable_cnt;\n\n\tspin_lock(&c->space_lock);\n\tmemcpy(&d->saved_lst, &c->lst, sizeof(struct ubifs_lp_stats));\n\tmemcpy(&d->saved_bi, &c->bi, sizeof(struct ubifs_budg_info));\n\td->saved_idx_gc_cnt = c->idx_gc_cnt;\n\n\t/*\n\t * We use a dirty hack here and zero out @c->freeable_cnt, because it\n\t * affects the free space calculations, and UBIFS might not know about\n\t * all freeable eraseblocks. Indeed, we know about freeable eraseblocks\n\t * only when we read their lprops, and we do this only lazily, upon the\n\t * need. So at any given point of time @c->freeable_cnt might be not\n\t * exactly accurate.\n\t *\n\t * Just one example about the issue we hit when we did not zero\n\t * @c->freeable_cnt.\n\t * 1. The file-system is mounted R/O, c->freeable_cnt is %0. We save the\n\t *    amount of free space in @d->saved_free\n\t * 2. We re-mount R/W, which makes UBIFS to read the \"lsave\"\n\t *    information from flash, where we cache LEBs from various\n\t *    categories ('ubifs_remount_fs()' -> 'ubifs_lpt_init()'\n\t *    -> 'lpt_init_wr()' -> 'read_lsave()' -> 'ubifs_lpt_lookup()'\n\t *    -> 'ubifs_get_pnode()' -> 'update_cats()'\n\t *    -> 'ubifs_add_to_cat()').\n\t * 3. Lsave contains a freeable eraseblock, and @c->freeable_cnt\n\t *    becomes %1.\n\t * 4. We calculate the amount of free space when the re-mount is\n\t *    finished in 'dbg_check_space_info()' and it does not match\n\t *    @d->saved_free.\n\t */\n\tfreeable_cnt = c->freeable_cnt;\n\tc->freeable_cnt = 0;\n\td->saved_free = ubifs_get_free_space_nolock(c);\n\tc->freeable_cnt = freeable_cnt;\n\tspin_unlock(&c->space_lock);\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->space_lo",
          "args": [
            "k);\n}\n\n/**\n *"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_space_nolock(c);\n\tc->free",
          "args": [
            "b"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ved_bi",
          "args": [
            "&c->bi, siz",
            "f(stru",
            "ubifs_budg_info));\n\td->saved_"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ved_ls",
          "args": [
            ", &c->lst, si",
            "of(stru",
            "ubifs_lp_stats));\n\tmemcpy(&d"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">space_lo",
          "args": [
            "k);\n\tmemcpy(&d"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\n_space_info(struct ubifs_info *c)\n{\n\tstruct ubifs_debug_info *d = c->dbg;\n\tint freeable_cnt;\n\n\tspin_lock(&c->space_lock);\n\tmemcpy(&d->saved_lst, &c->lst, sizeof(struct ubifs_lp_stats));\n\tmemcpy(&d->saved_bi, &c->bi, sizeof(struct ubifs_budg_info));\n\td->saved_idx_gc_cnt = c->idx_gc_cnt;\n\n\t/*\n\t * We use a dirty hack here and zero out @c->freeable_cnt, because it\n\t * affects the free space calculations, and UBIFS might not know about\n\t * all freeable eraseblocks. Indeed, we know about freeable eraseblocks\n\t * only when we read their lprops, and we do this only lazily, upon the\n\t * need. So at any given point of time @c->freeable_cnt might be not\n\t * exactly accurate.\n\t *\n\t * Just one example about the issue we hit when we did not zero\n\t * @c->freeable_cnt.\n\t * 1. The file-system is mounted R/O, c->freeable_cnt is %0. We save the\n\t *    amount of free space in @d->saved_free\n\t * 2. We re-mount R/W, which makes UBIFS to read the \"lsave\"\n\t *    information from flash, where we cache LEBs from various\n\t *    categories ('ubifs_remount_fs()' -> 'ubifs_lpt_init()'\n\t *    -> 'lpt_init_wr()' -> 'read_lsave()' -> 'ubifs_lpt_lookup()'\n\t *    -> 'ubifs_get_pnode()' -> 'update_cats()'\n\t *    -> 'ubifs_add_to_cat()').\n\t * 3. Lsave contains a freeable eraseblock, and @c->freeable_cnt\n\t *    becomes %1.\n\t * 4. We calculate the amount of free space when the re-mount is\n\t *    finished in 'dbg_check_space_info()' and it does not match\n\t *    @d->saved_free.\n\t */\n\tfreeable_cnt = c->freeable_cnt;\n\tc->freeable_cnt = 0;\n\td->saved_free = ubifs_get_free_space_nolock(c);\n\tc->freeable_cnt = freeable_cnt;\n\tspin_unlock(&c->space_lock);\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "dex(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "958-961",
    "snippet": "mp_index(struct ubifs_info *c)\n{\n\tdbg_walk_index(c, NULL, dump_znode, NULL);\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x(c, NULL, dum",
          "args": [
            "_",
            "ode,",
            "ULL);\n}\n\n/",
            "*"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nmp_index(struct ubifs_info *c)\n{\n\tdbg_walk_index(c, NULL, dump_znode, NULL);\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "944-949",
    "snippet": "mp_znode(struct ubifs_info *c, struct ubifs_znode *znode,\n\t\t      void *priv)\n{\n\tubifs_dump_znode(c, znode);\n\treturn 0;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ode(c, znode);",
          "args": [
            "e",
            "rn 0;"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nmp_znode(struct ubifs_info *c, struct ubifs_znode *znode,\n\t\t      void *priv)\n{\n\tubifs_dump_znode(c, znode);\n\treturn 0;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "c(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "923-942",
    "snippet": "mp_tnc(struct ubifs_info *c)\n{\n\tstruct ubifs_znode *znode;\n\tint level;\n\n\tpr_err(\"\\n\");\n\tpr_err(\"(pid %d) start dumping TNC tree\\n\", current->pid);\n\tznode = ubifs_tnc_levelorder_next(c->zroot.znode, NULL);\n\tlevel = znode->level;\n\tpr_err(\"== Level %d ==\\n\", level);\n\twhile (znode) {\n\t\tif (level != znode->level) {\n\t\t\tlevel = znode->level;\n\t\t\tpr_err(\"== Level %d ==\\n\", level);\n\t\t}\n\t\tubifs_dump_znode(c, znode);\n\t\tznode = ubifs_tnc_levelorder_next(c->zroot.znode, znode);\n\t}\n\tpr_err(\"(pid %d) finish dumping TNC tree\\n\", current->pid);\n}\n\nstatic int",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "%d) fi",
          "args": [
            "ish dumping TNC tree\\n\", current->pi",
            ";\n}\n\nstatic"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elorder_next(c->zroot.zno",
          "args": [
            "e, znode);\n\t}",
            "r_err"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, znode);",
          "args": [
            "z",
            "de ="
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vel %d",
          "args": [
            "==\\n\", level);\n\t\t}",
            "ubif"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vel %d",
          "args": [
            "==\\n\", level);\n\twh",
            "e (zn"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elorder_next(c->zroot.zno",
          "args": [
            "e, NULL);\n\tlev",
            "= z"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%d) st",
          "args": [
            "rt dumping TNC tree\\n\", current->pi",
            ";\n\tznode = u"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_e",
          "args": [
            "r(\"("
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nmp_tnc(struct ubifs_info *c)\n{\n\tstruct ubifs_znode *znode;\n\tint level;\n\n\tpr_err(\"\\n\");\n\tpr_err(\"(pid %d) start dumping TNC tree\\n\", current->pid);\n\tznode = ubifs_tnc_levelorder_next(c->zroot.znode, NULL);\n\tlevel = znode->level;\n\tpr_err(\"== Level %d ==\\n\", level);\n\twhile (znode) {\n\t\tif (level != znode->level) {\n\t\t\tlevel = znode->level;\n\t\t\tpr_err(\"== Level %d ==\\n\", level);\n\t\t}\n\t\tubifs_dump_znode(c, znode);\n\t\tznode = ubifs_tnc_levelorder_next(c->zroot.znode, znode);\n\t}\n\tpr_err(\"(pid %d) finish dumping TNC tree\\n\", current->pid);\n}\n\nstatic int"
  },
  {
    "function_name": "ode(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "905-921",
    "snippet": "mp_pnode(struct ubifs_info *c, struct ubifs_pnode *pnode,\n\t\t      struct ubifs_nnode *parent, int iip)\n{\n\tint i;\n\n\tpr_err(\"(pid %d) dumping pnode:\\n\", current->pid);\n\tpr_err(\"\\taddress %zx parent %zx cnext %zx\\n\",\n\t       (size_t)pnode, (size_t)parent, (size_t)pnode->cnext);\n\tpr_err(\"\\tflags %lu iip %d level %d num %d\\n\",\n\t       pnode->flags, iip, pnode->level, pnode->num);\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tstruct ubifs_lprops *lp = &pnode->lprops[i];\n\n\t\tpr_err(\"\\t%d: free %d dirty %d flags %d lnum %d\\n\",\n\t\t       i, lp->free, lp->dirty, lp->flags, lp->lnum);\n\t}\n}\n\nvoid ubifs_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "d dirty %d flags %d lnum %d\\n\",\n\t\t       i,",
            "l",
            ">dirty,",
            "->flags,",
            "->lnum);",
            "}\n\nvoid"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_info_freefrag_scan_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ioctl.c",
          "lines": "434-535",
          "snippet": "static int ocfs2_info_freefrag_scan_chain(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *gb_inode,\n\t\t\t\t\t  struct ocfs2_dinode *gb_dinode,\n\t\t\t\t\t  struct ocfs2_chain_rec *rec,\n\t\t\t\t\t  struct ocfs2_info_freefrag *ffg,\n\t\t\t\t\t  u32 chunks_in_group)\n{\n\tint status = 0, used;\n\tu64 blkno;\n\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_group_desc *bg = NULL;\n\n\tunsigned int max_bits, num_clusters;\n\tunsigned int offset = 0, cluster, chunk;\n\tunsigned int chunk_free, last_chunksize = 0;\n\n\tif (!le32_to_cpu(rec->c_free))\n\t\tgoto bail;\n\n\tdo {\n\t\tif (!bg)\n\t\t\tblkno = le64_to_cpu(rec->c_blkno);\n\t\telse\n\t\t\tblkno = le64_to_cpu(bg->bg_next_group);\n\n\t\tif (bh) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t}\n\n\t\tif (o2info_coherent(&ffg->iff_req))\n\t\t\tstatus = ocfs2_read_group_descriptor(gb_inode,\n\t\t\t\t\t\t\t     gb_dinode,\n\t\t\t\t\t\t\t     blkno, &bh);\n\t\telse\n\t\t\tstatus = ocfs2_read_blocks_sync(osb, blkno, 1, &bh);\n\n\t\tif (status < 0) {\n\t\t\tmlog(ML_ERROR, \"Can't read the group descriptor # \"\n\t\t\t     \"%llu from device.\", (unsigned long long)blkno);\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tbg = (struct ocfs2_group_desc *)bh->b_data;\n\n\t\tif (!le16_to_cpu(bg->bg_free_bits_count))\n\t\t\tcontinue;\n\n\t\tmax_bits = le16_to_cpu(bg->bg_bits);\n\t\toffset = 0;\n\n\t\tfor (chunk = 0; chunk < chunks_in_group; chunk++) {\n\t\t\t/*\n\t\t\t * last chunk may be not an entire one.\n\t\t\t */\n\t\t\tif ((offset + ffg->iff_chunksize) > max_bits)\n\t\t\t\tnum_clusters = max_bits - offset;\n\t\t\telse\n\t\t\t\tnum_clusters = ffg->iff_chunksize;\n\n\t\t\tchunk_free = 0;\n\t\t\tfor (cluster = 0; cluster < num_clusters; cluster++) {\n\t\t\t\tused = ocfs2_test_bit(offset,\n\t\t\t\t\t\t(unsigned long *)bg->bg_bitmap);\n\t\t\t\t/*\n\t\t\t\t * - chunk_free counts free clusters in #N chunk.\n\t\t\t\t * - last_chunksize records the size(in) clusters\n\t\t\t\t *   for the last real free chunk being counted.\n\t\t\t\t */\n\t\t\t\tif (!used) {\n\t\t\t\t\tlast_chunksize++;\n\t\t\t\t\tchunk_free++;\n\t\t\t\t}\n\n\t\t\t\tif (used && last_chunksize) {\n\t\t\t\t\tocfs2_info_update_ffg(ffg,\n\t\t\t\t\t\t\t      last_chunksize);\n\t\t\t\t\tlast_chunksize = 0;\n\t\t\t\t}\n\n\t\t\t\toffset++;\n\t\t\t}\n\n\t\t\tif (chunk_free == ffg->iff_chunksize)\n\t\t\t\tffg->iff_ffs.ffs_free_chunks++;\n\t\t}\n\n\t\t/*\n\t\t * need to update the info for last free chunk.\n\t\t */\n\t\tif (last_chunksize)\n\t\t\tocfs2_info_update_ffg(ffg, last_chunksize);\n\n\t} while (le64_to_cpu(bg->bg_next_group));\n\nbail:\n\tbrelse(bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_freefrag_scan_chain(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *gb_inode,\n\t\t\t\t\t  struct ocfs2_dinode *gb_dinode,\n\t\t\t\t\t  struct ocfs2_chain_rec *rec,\n\t\t\t\t\t  struct ocfs2_info_freefrag *ffg,\n\t\t\t\t\t  u32 chunks_in_group)\n{\n\tint status = 0, used;\n\tu64 blkno;\n\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_group_desc *bg = NULL;\n\n\tunsigned int max_bits, num_clusters;\n\tunsigned int offset = 0, cluster, chunk;\n\tunsigned int chunk_free, last_chunksize = 0;\n\n\tif (!le32_to_cpu(rec->c_free))\n\t\tgoto bail;\n\n\tdo {\n\t\tif (!bg)\n\t\t\tblkno = le64_to_cpu(rec->c_blkno);\n\t\telse\n\t\t\tblkno = le64_to_cpu(bg->bg_next_group);\n\n\t\tif (bh) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t}\n\n\t\tif (o2info_coherent(&ffg->iff_req))\n\t\t\tstatus = ocfs2_read_group_descriptor(gb_inode,\n\t\t\t\t\t\t\t     gb_dinode,\n\t\t\t\t\t\t\t     blkno, &bh);\n\t\telse\n\t\t\tstatus = ocfs2_read_blocks_sync(osb, blkno, 1, &bh);\n\n\t\tif (status < 0) {\n\t\t\tmlog(ML_ERROR, \"Can't read the group descriptor # \"\n\t\t\t     \"%llu from device.\", (unsigned long long)blkno);\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tbg = (struct ocfs2_group_desc *)bh->b_data;\n\n\t\tif (!le16_to_cpu(bg->bg_free_bits_count))\n\t\t\tcontinue;\n\n\t\tmax_bits = le16_to_cpu(bg->bg_bits);\n\t\toffset = 0;\n\n\t\tfor (chunk = 0; chunk < chunks_in_group; chunk++) {\n\t\t\t/*\n\t\t\t * last chunk may be not an entire one.\n\t\t\t */\n\t\t\tif ((offset + ffg->iff_chunksize) > max_bits)\n\t\t\t\tnum_clusters = max_bits - offset;\n\t\t\telse\n\t\t\t\tnum_clusters = ffg->iff_chunksize;\n\n\t\t\tchunk_free = 0;\n\t\t\tfor (cluster = 0; cluster < num_clusters; cluster++) {\n\t\t\t\tused = ocfs2_test_bit(offset,\n\t\t\t\t\t\t(unsigned long *)bg->bg_bitmap);\n\t\t\t\t/*\n\t\t\t\t * - chunk_free counts free clusters in #N chunk.\n\t\t\t\t * - last_chunksize records the size(in) clusters\n\t\t\t\t *   for the last real free chunk being counted.\n\t\t\t\t */\n\t\t\t\tif (!used) {\n\t\t\t\t\tlast_chunksize++;\n\t\t\t\t\tchunk_free++;\n\t\t\t\t}\n\n\t\t\t\tif (used && last_chunksize) {\n\t\t\t\t\tocfs2_info_update_ffg(ffg,\n\t\t\t\t\t\t\t      last_chunksize);\n\t\t\t\t\tlast_chunksize = 0;\n\t\t\t\t}\n\n\t\t\t\toffset++;\n\t\t\t}\n\n\t\t\tif (chunk_free == ffg->iff_chunksize)\n\t\t\t\tffg->iff_ffs.ffs_free_chunks++;\n\t\t}\n\n\t\t/*\n\t\t * need to update the info for last free chunk.\n\t\t */\n\t\tif (last_chunksize)\n\t\t\tocfs2_info_update_ffg(ffg, last_chunksize);\n\n\t} while (le64_to_cpu(bg->bg_next_group));\n\nbail:\n\tbrelse(bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gs %lu",
          "args": [
            "iip %d level %d num %d\\n\",\n\t       pno",
            "iip, pnode-",
            "eve",
            "pnode->num)",
            "for (i ="
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ress %",
          "args": [
            "x parent %zx cnext %zx\\n\",\n\t       (si",
            ", (size_t)par",
            "t, (size_t)pno",
            "->cnext);\n\tpr_err(\"\\"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%d) du",
          "args": [
            "ping pnode:\\n\", current->pi",
            ";\n\tpr_err(\"\\"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nmp_pnode(struct ubifs_info *c, struct ubifs_pnode *pnode,\n\t\t      struct ubifs_nnode *parent, int iip)\n{\n\tint i;\n\n\tpr_err(\"(pid %d) dumping pnode:\\n\", current->pid);\n\tpr_err(\"\\taddress %zx parent %zx cnext %zx\\n\",\n\t       (size_t)pnode, (size_t)parent, (size_t)pnode->cnext);\n\tpr_err(\"\\tflags %lu iip %d level %d num %d\\n\",\n\t       pnode->flags, iip, pnode->level, pnode->num);\n\tfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\n\t\tstruct ubifs_lprops *lp = &pnode->lprops[i];\n\n\t\tpr_err(\"\\t%d: free %d dirty %d flags %d lnum %d\\n\",\n\t\t       i, lp->free, lp->dirty, lp->flags, lp->lnum);\n\t}\n}\n\nvoid ubifs_"
  },
  {
    "function_name": "ap(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "889-903",
    "snippet": "mp_heap(struct ubifs_info *c, struct ubifs_lpt_heap *heap, int cat)\n{\n\tint i;\n\n\tpr_err(\"(pid %d) start dumping heap cat %d (%d elements)\\n\",\n\t       current->pid, cat, heap->cnt);\n\tfor (i = 0; i < heap->cnt; i++) {\n\t\tstruct ubifs_lprops *lprops = heap->arr[i];\n\n\t\tpr_err(\"\\t%d. LEB %d hpos %d free %d dirty %d flags %d\\n\",\n\t\t       i, lprops->lnum, lprops->hpos, lprops->free,\n\t\t       lprops->dirty, lprops->flags);\n\t}\n\tpr_err(\"(pid %d) finish dumping heap\\n\", current->pid);\n}\n\nvoid ubifs_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "%d) fi",
          "args": [
            "ish dumping heap\\n\", current->pi",
            ";\n}\n\nvoid ub"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEB %",
          "args": [
            "hpos %d free %d dirty %d flags %d\\n\",\n\t\t       i,",
            "u",
            "lprops->hpo",
            "lprops->fre",
            "lp",
            ", lprops->fla",
            ");\n\t}\n\tpr_err"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%d) st",
          "args": [
            "rt dumping heap cat %d (%d elements)\\n\",\n\t       cur",
            "cat, heap->",
            "t);",
            "for (i ="
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nmp_heap(struct ubifs_info *c, struct ubifs_lpt_heap *heap, int cat)\n{\n\tint i;\n\n\tpr_err(\"(pid %d) start dumping heap cat %d (%d elements)\\n\",\n\t       current->pid, cat, heap->cnt);\n\tfor (i = 0; i < heap->cnt; i++) {\n\t\tstruct ubifs_lprops *lprops = heap->arr[i];\n\n\t\tpr_err(\"\\t%d. LEB %d hpos %d free %d dirty %d flags %d\\n\",\n\t\t       i, lprops->lnum, lprops->hpos, lprops->free,\n\t\t       lprops->dirty, lprops->flags);\n\t}\n\tpr_err(\"(pid %d) finish dumping heap\\n\", current->pid);\n}\n\nvoid ubifs_"
  },
  {
    "function_name": "ode(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "850-887",
    "snippet": "mp_znode(const struct ubifs_info *c,\n\t\t      const struct ubifs_znode *znode)\n{\n\tint n;\n\tconst struct ubifs_zbranch *zbr;\n\tchar key_buf[DBG_KEY_BUF_LEN];\n\n\tspin_lock(&dbg_lock);\n\tif (znode->parent)\n\t\tzbr = &znode->parent->zbranch[znode->iip];\n\telse\n\t\tzbr = &c->zroot;\n\n\tpr_err(\"znode %p, LEB %d:%d len %d parent %p iip %d level %d child_cnt %d flags %lx\\n\",\n\t       znode, zbr->lnum, zbr->offs, zbr->len, znode->parent, znode->iip,\n\t       znode->level, znode->child_cnt, znode->flags);\n\n\tif (znode->child_cnt <= 0 || znode->child_cnt > c->fanout) {\n\t\tspin_unlock(&dbg_lock);\n\t\treturn;\n\t}\n\n\tpr_err(\"zbranches:\\n\");\n\tfor (n = 0; n < znode->child_cnt; n++) {\n\t\tzbr = &znode->zbranch[n];\n\t\tif (znode->level > 0)\n\t\t\tpr_err(\"\\t%d: znode %p LEB %d:%d len %d key %s\\n\",\n\t\t\t       n, zbr->znode, zbr->lnum, zbr->offs, zbr->len,\n\t\t\t       dbg_snprintf_key(c, &zbr->key, key_buf,\n\t\t\t\t\t\tDBG_KEY_BUF_LEN));\n\t\telse\n\t\t\tpr_err(\"\\t%d: LNC %p LEB %d:%d len %d key %s\\n\",\n\t\t\t       n, zbr->znode, zbr->lnum, zbr->offs, zbr->len,\n\t\t\t       dbg_snprintf_key(c, &zbr->key, key_buf,\n\t\t\t\t\t\tDBG_KEY_BUF_LEN));\n\t}\n\tspin_unlock(&dbg_lock);\n}\n\nvoid ubifs_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbg_lock);",
          "args": [
            "void ub"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LNC %",
          "args": [
            "LEB %d:%d len %d key %s\\n\",\n\t\t\t       n",
            ",",
            "br->lnum,",
            "r->offs,",
            "r->len,",
            "d",
            "key(c, &zbr->key, key_buf,\n\t\t\t\t\t\tDBG_KEY_BUF_LEN));\n\t}\n\tspin_u"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key(c, &zbr->key",
          "args": [
            "y_buf,",
            "DBG_K",
            "EN));\n\t}\n\tspin_"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode",
          "args": [
            "%p LEB %d:%d len %d key %s\\n\",\n\t\t\t       n",
            ",",
            "br->lnum,",
            "r->offs,",
            "r->len,",
            "d",
            "key(c, &zbr->key, key_buf,\n\t\t\t\t\t\tDBG_KEY_BUF_LEN));\n\t\telse"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key(c, &zbr->key",
          "args": [
            "y_buf,",
            "DBG_K",
            "EN));\n\t\telse"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ches:\\",
          "args": [
            "\");\n\tfor (n ="
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_lock);",
          "args": [
            "return;"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%p, L",
          "args": [
            "B %d:%d len %d parent %p iip %d level %d child_cnt %d flags %lx\\n\",\n\t       zno",
            "num,",
            "r->offs,",
            "r->len, z",
            "de->pare",
            ", znode->iip,",
            "zno",
            "znode->chil",
            "cnt, znode->flag",
            ";\n\n\tif (znod"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_lock);",
          "args": [
            "if (znode"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nmp_znode(const struct ubifs_info *c,\n\t\t      const struct ubifs_znode *znode)\n{\n\tint n;\n\tconst struct ubifs_zbranch *zbr;\n\tchar key_buf[DBG_KEY_BUF_LEN];\n\n\tspin_lock(&dbg_lock);\n\tif (znode->parent)\n\t\tzbr = &znode->parent->zbranch[znode->iip];\n\telse\n\t\tzbr = &c->zroot;\n\n\tpr_err(\"znode %p, LEB %d:%d len %d parent %p iip %d level %d child_cnt %d flags %lx\\n\",\n\t       znode, zbr->lnum, zbr->offs, zbr->len, znode->parent, znode->iip,\n\t       znode->level, znode->child_cnt, znode->flags);\n\n\tif (znode->child_cnt <= 0 || znode->child_cnt > c->fanout) {\n\t\tspin_unlock(&dbg_lock);\n\t\treturn;\n\t}\n\n\tpr_err(\"zbranches:\\n\");\n\tfor (n = 0; n < znode->child_cnt; n++) {\n\t\tzbr = &znode->zbranch[n];\n\t\tif (znode->level > 0)\n\t\t\tpr_err(\"\\t%d: znode %p LEB %d:%d len %d key %s\\n\",\n\t\t\t       n, zbr->znode, zbr->lnum, zbr->offs, zbr->len,\n\t\t\t       dbg_snprintf_key(c, &zbr->key, key_buf,\n\t\t\t\t\t\tDBG_KEY_BUF_LEN));\n\t\telse\n\t\t\tpr_err(\"\\t%d: LNC %p LEB %d:%d len %d key %s\\n\",\n\t\t\t       n, zbr->znode, zbr->lnum, zbr->offs, zbr->len,\n\t\t\t       dbg_snprintf_key(c, &zbr->key, key_buf,\n\t\t\t\t\t\tDBG_KEY_BUF_LEN));\n\t}\n\tspin_unlock(&dbg_lock);\n}\n\nvoid ubifs_"
  },
  {
    "function_name": "b(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "812-848",
    "snippet": "mp_leb(const struct ubifs_info *c, int lnum)\n{\n\tstruct ubifs_scan_leb *sleb;\n\tstruct ubifs_scan_node *snod;\n\tvoid *buf;\n\n\tpr_err(\"(pid %d) start dumping LEB %d\\n\", current->pid, lnum);\n\n\tbuf = __vmalloc(c->leb_size, GFP_NOFS, PAGE_KERNEL);\n\tif (!buf) {\n\t\tubifs_err(\"cannot allocate memory for dumping LEB %d\", lnum);\n\t\treturn;\n\t}\n\n\tsleb = ubifs_scan(c, lnum, 0, buf, 0);\n\tif (IS_ERR(sleb)) {\n\t\tubifs_err(\"scan error %d\", (int)PTR_ERR(sleb));\n\t\tgoto out;\n\t}\n\n\tpr_err(\"LEB %d has %d nodes ending at %d\\n\", lnum,\n\t       sleb->nodes_cnt, sleb->endpt);\n\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tcond_resched();\n\t\tpr_err(\"Dumping node at LEB %d:%d len %d\\n\", lnum,\n\t\t       snod->offs, snod->len);\n\t\tubifs_dump_node(c, snod->node);\n\t}\n\n\tpr_err(\"(pid %d) finish dumping LEB %d\\n\", current->pid, lnum);\n\tubifs_scan_destroy(sleb);\n\nout:\n\tvfree(buf);\n\treturn;\n}\n\nvoid ubifs_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retur",
          "args": [
            ";\n}"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stroy(sleb);\n\nout:",
          "args": [
            "vfr"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%d) fi",
          "args": [
            "ish dumping LEB %d\\n\", current->pi",
            "lnum);\n\tubi",
            "_sca"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, snod->nod",
          "args": [
            ")",
            "}\n\n\tpr_er"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ng nod",
          "args": [
            "at LEB %d:%d len %d\\n\", lnum,",
            "sn",
            "nod->len);",
            "ubifs_du"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\tpr_err(",
          "args": [],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(snod, &sleb-",
          "args": [
            "node",
            "list) {\n\t\tc",
            "d_re"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d has",
          "args": [
            "d nodes ending at %d\\n\", lnum,",
            "sle",
            "nt, sleb->endpt",
            "list_for"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "an error",
          "args": [
            "d\", (int)PTR_ER",
            "sleb));\n\t\tgoto out"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\tgo",
          "args": [
            "o ou"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{\n\t\tu",
          "args": [
            "ifs_"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lnum, 0,",
          "args": [
            "u",
            "0);",
            "i",
            "(IS",
            "R"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnot allo",
          "args": [
            "ate memory for dumping LEB %d\", lnum);\n\t\tre",
            "rn;"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leb_size,",
          "args": [
            "GFP_NOFS, P",
            "E_KERNEL",
            "if (!buf)"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%d) st",
          "args": [
            "rt dumping LEB %d\\n\", current->pi",
            "lnum);\n\n\tbu",
            "= __"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nmp_leb(const struct ubifs_info *c, int lnum)\n{\n\tstruct ubifs_scan_leb *sleb;\n\tstruct ubifs_scan_node *snod;\n\tvoid *buf;\n\n\tpr_err(\"(pid %d) start dumping LEB %d\\n\", current->pid, lnum);\n\n\tbuf = __vmalloc(c->leb_size, GFP_NOFS, PAGE_KERNEL);\n\tif (!buf) {\n\t\tubifs_err(\"cannot allocate memory for dumping LEB %d\", lnum);\n\t\treturn;\n\t}\n\n\tsleb = ubifs_scan(c, lnum, 0, buf, 0);\n\tif (IS_ERR(sleb)) {\n\t\tubifs_err(\"scan error %d\", (int)PTR_ERR(sleb));\n\t\tgoto out;\n\t}\n\n\tpr_err(\"LEB %d has %d nodes ending at %d\\n\", lnum,\n\t       sleb->nodes_cnt, sleb->endpt);\n\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tcond_resched();\n\t\tpr_err(\"Dumping node at LEB %d:%d len %d\\n\", lnum,\n\t\t       snod->offs, snod->len);\n\t\tubifs_dump_node(c, snod->node);\n\t}\n\n\tpr_err(\"(pid %d) finish dumping LEB %d\\n\", current->pid, lnum);\n\tubifs_scan_destroy(sleb);\n\nout:\n\tvfree(buf);\n\treturn;\n}\n\nvoid ubifs_"
  },
  {
    "function_name": "eb(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "796-810",
    "snippet": "mp_sleb(const struct ubifs_info *c,\n\t\t     const struct ubifs_scan_leb *sleb, int offs)\n{\n\tstruct ubifs_scan_node *snod;\n\n\tpr_err(\"(pid %d) start dumping scanned data from LEB %d:%d\\n\",\n\t       current->pid, sleb->lnum, offs);\n\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tcond_resched();\n\t\tpr_err(\"Dumping node at LEB %d:%d len %d\\n\",\n\t\t       sleb->lnum, snod->offs, snod->len);\n\t\tubifs_dump_node(c, snod->node);\n\t}\n}\n\nvoid ubifs_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "de(c, snod->nod",
          "args": [
            ")",
            "}\n}\n\nvoid"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ng nod",
          "args": [
            "at LEB %d:%d len %d\\n\",\n\t\t       sl",
            "nod->offs,",
            "nod->len);",
            "ubifs_du"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\tpr_err(",
          "args": [],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(snod, &sleb-",
          "args": [
            "node",
            "list) {\n\t\tc",
            "d_re"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%d) st",
          "args": [
            "rt dumping scanned data from LEB %d:%d\\n\",\n\t       cur",
            "sleb->lnum,",
            "ffs);\n\n\tli",
            "_for"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nmp_sleb(const struct ubifs_info *c,\n\t\t     const struct ubifs_scan_leb *sleb, int offs)\n{\n\tstruct ubifs_scan_node *snod;\n\n\tpr_err(\"(pid %d) start dumping scanned data from LEB %d:%d\\n\",\n\t       current->pid, sleb->lnum, offs);\n\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tcond_resched();\n\t\tpr_err(\"Dumping node at LEB %d:%d len %d\\n\",\n\t\t       sleb->lnum, snod->offs, snod->len);\n\t\tubifs_dump_node(c, snod->node);\n\t}\n}\n\nvoid ubifs_"
  },
  {
    "function_name": "t_info(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "758-794",
    "snippet": "mp_lpt_info(struct ubifs_info *c)\n{\n\tint i;\n\n\tspin_lock(&dbg_lock);\n\tpr_err(\"(pid %d) dumping LPT information\\n\", current->pid);\n\tpr_err(\"\\tlpt_sz:        %lld\\n\", c->lpt_sz);\n\tpr_err(\"\\tpnode_sz:      %d\\n\", c->pnode_sz);\n\tpr_err(\"\\tnnode_sz:      %d\\n\", c->nnode_sz);\n\tpr_err(\"\\tltab_sz:       %d\\n\", c->ltab_sz);\n\tpr_err(\"\\tlsave_sz:      %d\\n\", c->lsave_sz);\n\tpr_err(\"\\tbig_lpt:       %d\\n\", c->big_lpt);\n\tpr_err(\"\\tlpt_hght:      %d\\n\", c->lpt_hght);\n\tpr_err(\"\\tpnode_cnt:     %d\\n\", c->pnode_cnt);\n\tpr_err(\"\\tnnode_cnt:     %d\\n\", c->nnode_cnt);\n\tpr_err(\"\\tdirty_pn_cnt:  %d\\n\", c->dirty_pn_cnt);\n\tpr_err(\"\\tdirty_nn_cnt:  %d\\n\", c->dirty_nn_cnt);\n\tpr_err(\"\\tlsave_cnt:     %d\\n\", c->lsave_cnt);\n\tpr_err(\"\\tspace_bits:    %d\\n\", c->space_bits);\n\tpr_err(\"\\tlpt_lnum_bits: %d\\n\", c->lpt_lnum_bits);\n\tpr_err(\"\\tlpt_offs_bits: %d\\n\", c->lpt_offs_bits);\n\tpr_err(\"\\tlpt_spc_bits:  %d\\n\", c->lpt_spc_bits);\n\tpr_err(\"\\tpcnt_bits:     %d\\n\", c->pcnt_bits);\n\tpr_err(\"\\tlnum_bits:     %d\\n\", c->lnum_bits);\n\tpr_err(\"\\tLPT root is at %d:%d\\n\", c->lpt_lnum, c->lpt_offs);\n\tpr_err(\"\\tLPT head is at %d:%d\\n\",\n\t       c->nhead_lnum, c->nhead_offs);\n\tpr_err(\"\\tLPT ltab is at %d:%d\\n\", c->ltab_lnum, c->ltab_offs);\n\tif (c->big_lpt)\n\t\tpr_err(\"\\tLPT lsave is at %d:%d\\n\",\n\t\t       c->lsave_lnum, c->lsave_offs);\n\tfor (i = 0; i < c->lpt_lebs; i++)\n\t\tpr_err(\"\\tLPT LEB %d free %d dirty %d tgc %d cmt %d\\n\",\n\t\t       i + c->lpt_first, c->ltab[i].free, c->ltab[i].dirty,\n\t\t       c->ltab[i].tgc, c->ltab[i].cmt);\n\tspin_unlock(&dbg_lock);\n}\n\nvoid ubifs_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbg_lock);",
          "args": [
            "void ub"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEB %",
          "args": [
            "free %d dirty %d tgc %d cmt %d\\n\",\n\t\t       i",
            "rst, c->ltab[i].",
            "ee, c->ltab[i].",
            "rty,\n\t\t       c-",
            "c, c->ltab[i].",
            "t);\n\tspin_unlo"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lsave",
          "args": [
            "is at %d:%d\\n\",\n\t\t       c-",
            ", c->lsave_of",
            ");\n\tfor (i ="
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltab",
          "args": [
            "s at %d:%d\\n\", c->ltab_lnu",
            "c->ltab_off",
            ";\n\tif (c->bi"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "head",
          "args": [
            "s at %d:%d\\n\",\n\t       c->",
            ", c->nhead_of",
            ");\n\tpr_err(\"\\"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "__breadahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1381-1388",
          "snippet": "void __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "root",
          "args": [
            "s at %d:%d\\n\", c->lpt_lnum",
            "c->lpt_offs",
            "pr_err(\"\\"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "get_peer_under_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "32-47",
          "snippet": "static struct mount *get_peer_under_root(struct mount *mnt,\n\t\t\t\t\t struct mnt_namespace *ns,\n\t\t\t\t\t const struct path *root)\n{\n\tstruct mount *m = mnt;\n\n\tdo {\n\t\t/* Check the namespace first for optimization */\n\t\tif (m->mnt_ns == ns && is_path_reachable(m, m->mnt.mnt_root, root))\n\t\t\treturn m;\n\n\t\tm = next_peer(m);\n\t} while (m != mnt);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic struct mount *get_peer_under_root(struct mount *mnt,\n\t\t\t\t\t struct mnt_namespace *ns,\n\t\t\t\t\t const struct path *root)\n{\n\tstruct mount *m = mnt;\n\n\tdo {\n\t\t/* Check the namespace first for optimization */\n\t\tif (m->mnt_ns == ns && is_path_reachable(m, m->mnt.mnt_root, root))\n\t\t\treturn m;\n\n\t\tm = next_peer(m);\n\t} while (m != mnt);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_bits",
          "args": [
            "%d\\n\", c->lnum_bit",
            ";\n\tpr_err(\"\\"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_bits",
          "args": [
            "%d\\n\", c->pcnt_bit",
            ";\n\tpr_err(\"\\"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "get_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "375-378",
          "snippet": "static unsigned long get_bits(u64 val, level_t skip)\n{\n\treturn __get_bits(val, (__force int)skip, LOGFS_BLOCK_BITS);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic unsigned long get_bits(u64 val, level_t skip)\n{\n\treturn __get_bits(val, (__force int)skip, LOGFS_BLOCK_BITS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_spc_b",
          "args": [
            "ts:  %d\\n\", c->lpt_spc_",
            "ts);\n\tpr_err(\"\\"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_offs_",
          "args": [
            "its: %d\\n\", c->lpt_offs",
            "its);\n\tpr_err(\"\\"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_grp_offs_to_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.h",
          "lines": "209-214",
          "snippet": "static inline ext4_fsblk_t ext4_grp_offs_to_block(struct super_block *sb,\n\t\t\t\t\tstruct ext4_free_extent *fex)\n{\n\treturn ext4_group_first_block_no(sb, fex->fe_group) +\n\t\t(fex->fe_start << EXT4_SB(sb)->s_cluster_bits);\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n#include <linux/proc_fs.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline ext4_fsblk_t ext4_grp_offs_to_block(struct super_block *sb,\n\t\t\t\t\tstruct ext4_free_extent *fex)\n{\n\treturn ext4_group_first_block_no(sb, fex->fe_group) +\n\t\t(fex->fe_start << EXT4_SB(sb)->s_cluster_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_lnum_",
          "args": [
            "its: %d\\n\", c->lpt_lnum",
            "its);\n\tpr_err(\"\\"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ce_bit",
          "args": [
            ":    %d\\n\", c->space_bi",
            ");\n\tpr_err(\"\\"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ve_cnt",
          "args": [
            "%d\\n\", c->lsave_cn",
            ";\n\tpr_err(\"\\"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ty_nn_",
          "args": [
            "nt:  %d\\n\", c->dirty_nn",
            "nt);\n\tpr_err(\"\\"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ty_pn_",
          "args": [
            "nt:  %d\\n\", c->dirty_pn",
            "nt);\n\tpr_err(\"\\"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de_cnt",
          "args": [
            "%d\\n\", c->nnode_cn",
            ";\n\tpr_err(\"\\"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de_cnt",
          "args": [
            "%d\\n\", c->pnode_cn",
            ";\n\tpr_err(\"\\"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_hght:",
          "args": [
            "%d\\n\", c->lpt_hght",
            "pr_err(\"\\"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_lpt:",
          "args": [
            "%d\\n\", c->big_lpt)",
            "pr_err(\"\\"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ve_sz:",
          "args": [
            "%d\\n\", c->lsave_sz",
            "pr_err(\"\\"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_sz:",
          "args": [
            "%d\\n\", c->ltab_sz)",
            "pr_err(\"\\"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de_sz:",
          "args": [
            "%d\\n\", c->nnode_sz",
            "pr_err(\"\\"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de_sz:",
          "args": [
            "%d\\n\", c->pnode_sz",
            "pr_err(\"\\"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_sz:",
          "args": [
            "%lld\\n\", c->lpt_sz);",
            "pr_err(\"\\"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "e_sz(const struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/misc.h",
          "lines": "201-204",
          "snippet": "int ubifs_idx_node_sz(const struct ubifs_info *c, int child_cnt)\n{\n\treturn UBIFS_IDX_NODE_SZ + (UBIFS_BRANCH_SZ + c->key_len) * child_cnt;\n}\n\n/**\n * ubif",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "int ubifs_idx_node_sz(const struct ubifs_info *c, int child_cnt)\n{\n\treturn UBIFS_IDX_NODE_SZ + (UBIFS_BRANCH_SZ + c->key_len) * child_cnt;\n}\n\n/**\n * ubif"
        }
      },
      {
        "call_info": {
          "callee": "%d) du",
          "args": [
            "ping LPT information\\n\", current->pi",
            ";\n\tpr_err(\"\\"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_lock);",
          "args": [
            "pr_err(\"("
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nmp_lpt_info(struct ubifs_info *c)\n{\n\tint i;\n\n\tspin_lock(&dbg_lock);\n\tpr_err(\"(pid %d) dumping LPT information\\n\", current->pid);\n\tpr_err(\"\\tlpt_sz:        %lld\\n\", c->lpt_sz);\n\tpr_err(\"\\tpnode_sz:      %d\\n\", c->pnode_sz);\n\tpr_err(\"\\tnnode_sz:      %d\\n\", c->nnode_sz);\n\tpr_err(\"\\tltab_sz:       %d\\n\", c->ltab_sz);\n\tpr_err(\"\\tlsave_sz:      %d\\n\", c->lsave_sz);\n\tpr_err(\"\\tbig_lpt:       %d\\n\", c->big_lpt);\n\tpr_err(\"\\tlpt_hght:      %d\\n\", c->lpt_hght);\n\tpr_err(\"\\tpnode_cnt:     %d\\n\", c->pnode_cnt);\n\tpr_err(\"\\tnnode_cnt:     %d\\n\", c->nnode_cnt);\n\tpr_err(\"\\tdirty_pn_cnt:  %d\\n\", c->dirty_pn_cnt);\n\tpr_err(\"\\tdirty_nn_cnt:  %d\\n\", c->dirty_nn_cnt);\n\tpr_err(\"\\tlsave_cnt:     %d\\n\", c->lsave_cnt);\n\tpr_err(\"\\tspace_bits:    %d\\n\", c->space_bits);\n\tpr_err(\"\\tlpt_lnum_bits: %d\\n\", c->lpt_lnum_bits);\n\tpr_err(\"\\tlpt_offs_bits: %d\\n\", c->lpt_offs_bits);\n\tpr_err(\"\\tlpt_spc_bits:  %d\\n\", c->lpt_spc_bits);\n\tpr_err(\"\\tpcnt_bits:     %d\\n\", c->pcnt_bits);\n\tpr_err(\"\\tlnum_bits:     %d\\n\", c->lnum_bits);\n\tpr_err(\"\\tLPT root is at %d:%d\\n\", c->lpt_lnum, c->lpt_offs);\n\tpr_err(\"\\tLPT head is at %d:%d\\n\",\n\t       c->nhead_lnum, c->nhead_offs);\n\tpr_err(\"\\tLPT ltab is at %d:%d\\n\", c->ltab_lnum, c->ltab_offs);\n\tif (c->big_lpt)\n\t\tpr_err(\"\\tLPT lsave is at %d:%d\\n\",\n\t\t       c->lsave_lnum, c->lsave_offs);\n\tfor (i = 0; i < c->lpt_lebs; i++)\n\t\tpr_err(\"\\tLPT LEB %d free %d dirty %d tgc %d cmt %d\\n\",\n\t\t       i + c->lpt_first, c->ltab[i].free, c->ltab[i].dirty,\n\t\t       c->ltab[i].tgc, c->ltab[i].cmt);\n\tspin_unlock(&dbg_lock);\n}\n\nvoid ubifs_"
  },
  {
    "function_name": "rops(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "736-756",
    "snippet": "mp_lprops(struct ubifs_info *c)\n{\n\tint lnum, err;\n\tstruct ubifs_lprops lp;\n\tstruct ubifs_lp_stats lst;\n\n\tpr_err(\"(pid %d) start dumping LEB properties\\n\", current->pid);\n\tubifs_get_lp_stats(c, &lst);\n\tubifs_dump_lstats(&lst);\n\n\tfor (lnum = c->main_first; lnum < c->leb_cnt; lnum++) {\n\t\terr = ubifs_read_one_lp(c, lnum, &lp);\n\t\tif (err) {\n\t\t\tubifs_err(\"cannot read lprops for LEB %d\", lnum);\n\t\t\tcontinue;\n\t\t}\n\n\t\tubifs_dump_lprop(c, &lp);\n\t}\n\tpr_err(\"(pid %d) finish dumping LEB properties\\n\", current->pid);\n}\n\nvoid ubifs_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "%d) fi",
          "args": [
            "ish dumping LEB properties\\n\", current->pi",
            ";\n}\n\nvoid ub"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rop(c, &lp);\n\t}",
          "args": [
            "p",
            "err"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnot read",
          "args": [
            "lprops for LEB %d\", lnum);\n\t\t\tc",
            "tinu"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_lp(c, lnum, &lp",
          "args": [
            ";",
            "if",
            "rr)"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tats(&lst);\n\n\tfor",
          "args": [
            "(lnu"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stats(c, &lst);\n\tu",
          "args": [
            "i",
            "_dum"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%d) st",
          "args": [
            "rt dumping LEB properties\\n\", current->pi",
            ";\n\tubifs_get"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nmp_lprops(struct ubifs_info *c)\n{\n\tint lnum, err;\n\tstruct ubifs_lprops lp;\n\tstruct ubifs_lp_stats lst;\n\n\tpr_err(\"(pid %d) start dumping LEB properties\\n\", current->pid);\n\tubifs_get_lp_stats(c, &lst);\n\tubifs_dump_lstats(&lst);\n\n\tfor (lnum = c->main_first; lnum < c->leb_cnt; lnum++) {\n\t\terr = ubifs_read_one_lp(c, lnum, &lp);\n\t\tif (err) {\n\t\t\tubifs_err(\"cannot read lprops for LEB %d\", lnum);\n\t\t\tcontinue;\n\t\t}\n\n\t\tubifs_dump_lprop(c, &lp);\n\t}\n\tpr_err(\"(pid %d) finish dumping LEB properties\\n\", current->pid);\n}\n\nvoid ubifs_"
  },
  {
    "function_name": "rop(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "645-734",
    "snippet": "mp_lprop(const struct ubifs_info *c, const struct ubifs_lprops *lp)\n{\n\tint i, spc, dark = 0, dead = 0;\n\tstruct rb_node *rb;\n\tstruct ubifs_bud *bud;\n\n\tspc = lp->free + lp->dirty;\n\tif (spc < c->dead_wm)\n\t\tdead = spc;\n\telse\n\t\tdark = ubifs_calc_dark(c, spc);\n\n\tif (lp->flags & LPROPS_INDEX)\n\t\tpr_err(\"LEB %-7d free %-8d dirty %-8d used %-8d free + dirty %-8d flags %#x (\",\n\t\t       lp->lnum, lp->free, lp->dirty, c->leb_size - spc, spc,\n\t\t       lp->flags);\n\telse\n\t\tpr_err(\"LEB %-7d free %-8d dirty %-8d used %-8d free + dirty %-8d dark %-4d dead %-4d nodes fit %-3d flags %#-4x (\",\n\t\t       lp->lnum, lp->free, lp->dirty, c->leb_size - spc, spc,\n\t\t       dark, dead, (int)(spc / UBIFS_MAX_NODE_SZ), lp->flags);\n\n\tif (lp->flags & LPROPS_TAKEN) {\n\t\tif (lp->flags & LPROPS_INDEX)\n\t\t\tpr_cont(\"index, taken\");\n\t\telse\n\t\t\tpr_cont(\"taken\");\n\t} else {\n\t\tconst char *s;\n\n\t\tif (lp->flags & LPROPS_INDEX) {\n\t\t\tswitch (lp->flags & LPROPS_CAT_MASK) {\n\t\t\tcase LPROPS_DIRTY_IDX:\n\t\t\t\ts = \"dirty index\";\n\t\t\t\tbreak;\n\t\t\tcase LPROPS_FRDI_IDX:\n\t\t\t\ts = \"freeable index\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ts = \"index\";\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (lp->flags & LPROPS_CAT_MASK) {\n\t\t\tcase LPROPS_UNCAT:\n\t\t\t\ts = \"not categorized\";\n\t\t\t\tbreak;\n\t\t\tcase LPROPS_DIRTY:\n\t\t\t\ts = \"dirty\";\n\t\t\t\tbreak;\n\t\t\tcase LPROPS_FREE:\n\t\t\t\ts = \"free\";\n\t\t\t\tbreak;\n\t\t\tcase LPROPS_EMPTY:\n\t\t\t\ts = \"empty\";\n\t\t\t\tbreak;\n\t\t\tcase LPROPS_FREEABLE:\n\t\t\t\ts = \"freeable\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ts = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpr_cont(\"%s\", s);\n\t}\n\n\tfor (rb = rb_first((struct rb_root *)&c->buds); rb; rb = rb_next(rb)) {\n\t\tbud = rb_entry(rb, struct ubifs_bud, rb);\n\t\tif (bud->lnum == lp->lnum) {\n\t\t\tint head = 0;\n\t\t\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\t\t\t/*\n\t\t\t\t * Note, if we are in R/O mode or in the middle\n\t\t\t\t * of mounting/re-mounting, the write-buffers do\n\t\t\t\t * not exist.\n\t\t\t\t */\n\t\t\t\tif (c->jheads &&\n\t\t\t\t    lp->lnum == c->jheads[i].wbuf.lnum) {\n\t\t\t\t\tpr_cont(\", jhead %s\", dbg_jhead(i));\n\t\t\t\t\thead = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!head)\n\t\t\t\tpr_cont(\", bud of jhead %s\",\n\t\t\t\t       dbg_jhead(bud->jhead));\n\t\t}\n\t}\n\tif (lp->lnum == c->gc_lnum)\n\t\tpr_cont(\", GC LEB\");\n\tpr_cont(\")\\n\");\n}\n\nvoid ubifs_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ");\n}\n\nv",
          "args": [
            "id ub"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEB\");",
          "args": [
            "pr_cont(\""
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d of jh",
          "args": [
            "ad %s\",",
            "->jhead));\n\t\t}\n\t}\n\tif"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->jhead))",
          "args": [
            "}\n\t}\n\ti"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ead %s\"",
          "args": [
            "dbg_jhead(i",
            ";\n\t\t\t\t\thead"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\t\t\the",
          "args": [
            "d"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct u",
          "args": [
            "if",
            "bud, r);\n\t\tif (",
            "d-"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "lated(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
          "lines": "2456-2548",
          "snippet": "wer_cut_emulated(struct ubifs_info *c, int lnum, int write)\n{\n\tstruct ubifs_debug_info *d = c->dbg;\n\n\tubifs_assert(dbg_is_tst_rcvry(c));\n\n\tif (!d->pc_cnt) {\n\t\t/* First call - decide delay to the power cut */\n\t\tif (chance(1, 2)) {\n\t\t\tunsigned long delay;\n\n\t\t\tif (chance(1, 2)) {\n\t\t\t\td->pc_delay = 1;\n\t\t\t\t/* Fail within 1 minute */\n\t\t\t\tdelay = prandom_u32() % 60000;\n\t\t\t\td->pc_timeout = jiffies;\n\t\t\t\td->pc_timeout += msecs_to_jiffies(delay);\n\t\t\t\tubifs_warn(\"failing after %lums\", delay);\n\t\t\t} else {\n\t\t\t\td->pc_delay = 2;\n\t\t\t\tdelay = prandom_u32() % 10000;\n\t\t\t\t/* Fail within 10000 operations */\n\t\t\t\td->pc_cnt_max = delay;\n\t\t\t\tubifs_warn(\"failing after %lu calls\", delay);\n\t\t\t}\n\t\t}\n\n\t\td->pc_cnt += 1;\n\t}\n\n\t/* Determine if failure delay has expired */\n\tif (d->pc_delay == 1 && time_before(jiffies, d->pc_timeout))\n\t\t\treturn 0;\n\tif (d->pc_delay == 2 && d->pc_cnt++ < d->pc_cnt_max)\n\t\t\treturn 0;\n\n\tif (lnum == UBIFS_SB_LNUM) {\n\t\tif (write && chance(1, 2))\n\t\t\treturn 0;\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in super block LEB %d\", lnum);\n\t} else if (lnum == UBIFS_MST_LNUM || lnum == UBIFS_MST_LNUM + 1) {\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in master LEB %d\", lnum);\n\t} else if (lnum >= UBIFS_LOG_LNUM && lnum <= c->log_last) {\n\t\tif (write && chance(99, 100))\n\t\t\treturn 0;\n\t\tif (chance(399, 400))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in log LEB %d\", lnum);\n\t} else if (lnum >= c->lpt_first && lnum <= c->lpt_last) {\n\t\tif (write && chance(7, 8))\n\t\t\treturn 0;\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in LPT LEB %d\", lnum);\n\t} else if (lnum >= c->orph_first && lnum <= c->orph_last) {\n\t\tif (write && chance(1, 2))\n\t\t\treturn 0;\n\t\tif (chance(9, 10))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in orphan LEB %d\", lnum);\n\t} else if (lnum == c->ihead_lnum) {\n\t\tif (chance(99, 100))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in index head LEB %d\", lnum);\n\t} else if (c->jheads && lnum == c->jheads[GCHD].wbuf.lnum) {\n\t\tif (chance(9, 10))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in GC head LEB %d\", lnum);\n\t} else if (write && !RB_EMPTY_ROOT(&c->buds) &&\n\t\t   !ubifs_search_bud(c, lnum)) {\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in non-bud LEB %d\", lnum);\n\t} else if (c->cmt_state == COMMIT_RUNNING_BACKGROUND ||\n\t\t   c->cmt_state == COMMIT_RUNNING_REQUIRED) {\n\t\tif (chance(999, 1000))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in bud LEB %d commit running\", lnum);\n\t} else {\n\t\tif (chance(9999, 10000))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in bud LEB %d commit not running\", lnum);\n\t}\n\n\td->pc_happened = 1;\n\tubifs_warn(\"========== Power cut emulated ==========\");\n\tdump_stack();\n\treturn 1;\n}\n\nstatic int",
          "includes": [
            "fs.h\"\n\nstatic DEFIN",
            "ux/random.h>\n#include \"ubi",
            "ux/uaccess.h>\n#include <lin",
            "ux/math64.h>\n#include <lin",
            "ux/debugfs.h>\n#include <lin",
            "ux/module.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nwer_cut_emulated(struct ubifs_info *c, int lnum, int write)\n{\n\tstruct ubifs_debug_info *d = c->dbg;\n\n\tubifs_assert(dbg_is_tst_rcvry(c));\n\n\tif (!d->pc_cnt) {\n\t\t/* First call - decide delay to the power cut */\n\t\tif (chance(1, 2)) {\n\t\t\tunsigned long delay;\n\n\t\t\tif (chance(1, 2)) {\n\t\t\t\td->pc_delay = 1;\n\t\t\t\t/* Fail within 1 minute */\n\t\t\t\tdelay = prandom_u32() % 60000;\n\t\t\t\td->pc_timeout = jiffies;\n\t\t\t\td->pc_timeout += msecs_to_jiffies(delay);\n\t\t\t\tubifs_warn(\"failing after %lums\", delay);\n\t\t\t} else {\n\t\t\t\td->pc_delay = 2;\n\t\t\t\tdelay = prandom_u32() % 10000;\n\t\t\t\t/* Fail within 10000 operations */\n\t\t\t\td->pc_cnt_max = delay;\n\t\t\t\tubifs_warn(\"failing after %lu calls\", delay);\n\t\t\t}\n\t\t}\n\n\t\td->pc_cnt += 1;\n\t}\n\n\t/* Determine if failure delay has expired */\n\tif (d->pc_delay == 1 && time_before(jiffies, d->pc_timeout))\n\t\t\treturn 0;\n\tif (d->pc_delay == 2 && d->pc_cnt++ < d->pc_cnt_max)\n\t\t\treturn 0;\n\n\tif (lnum == UBIFS_SB_LNUM) {\n\t\tif (write && chance(1, 2))\n\t\t\treturn 0;\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in super block LEB %d\", lnum);\n\t} else if (lnum == UBIFS_MST_LNUM || lnum == UBIFS_MST_LNUM + 1) {\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in master LEB %d\", lnum);\n\t} else if (lnum >= UBIFS_LOG_LNUM && lnum <= c->log_last) {\n\t\tif (write && chance(99, 100))\n\t\t\treturn 0;\n\t\tif (chance(399, 400))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in log LEB %d\", lnum);\n\t} else if (lnum >= c->lpt_first && lnum <= c->lpt_last) {\n\t\tif (write && chance(7, 8))\n\t\t\treturn 0;\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in LPT LEB %d\", lnum);\n\t} else if (lnum >= c->orph_first && lnum <= c->orph_last) {\n\t\tif (write && chance(1, 2))\n\t\t\treturn 0;\n\t\tif (chance(9, 10))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in orphan LEB %d\", lnum);\n\t} else if (lnum == c->ihead_lnum) {\n\t\tif (chance(99, 100))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in index head LEB %d\", lnum);\n\t} else if (c->jheads && lnum == c->jheads[GCHD].wbuf.lnum) {\n\t\tif (chance(9, 10))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in GC head LEB %d\", lnum);\n\t} else if (write && !RB_EMPTY_ROOT(&c->buds) &&\n\t\t   !ubifs_search_bud(c, lnum)) {\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in non-bud LEB %d\", lnum);\n\t} else if (c->cmt_state == COMMIT_RUNNING_BACKGROUND ||\n\t\t   c->cmt_state == COMMIT_RUNNING_REQUIRED) {\n\t\tif (chance(999, 1000))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in bud LEB %d commit running\", lnum);\n\t} else {\n\t\tif (chance(9999, 10000))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in bud LEB %d commit not running\", lnum);\n\t}\n\n\td->pc_happened = 1;\n\tubifs_warn(\"========== Power cut emulated ==========\");\n\tdump_stack();\n\treturn 1;\n}\n\nstatic int"
        }
      },
      {
        "call_info": {
          "callee": "{\n\t\tbud",
          "args": [
            "="
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uct rb_r",
          "args": [
            "ot *)&c->buds); rb; rb = r"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "tree(struct rb_ro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
          "lines": "584-590",
          "snippet": "estroy_done_tree(struct rb_root *done_tree)\n{\n\tstruct done_ref *dr, *n;\n\n\trbtree_postorder_for_each_entry_safe(dr, n, done_tree, rb)\n\t\tkfree(dr);\n}\n\n/**\n * add_",
          "includes": [
            "fs.h\"\n\nstatic int d"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic int d\n\nestroy_done_tree(struct rb_root *done_tree)\n{\n\tstruct done_ref *dr, *n;\n\n\trbtree_postorder_for_each_entry_safe(dr, n, done_tree, rb)\n\t\tkfree(dr);\n}\n\n/**\n * add_"
        }
      },
      {
        "call_info": {
          "callee": "s);\n\t}",
          "args": [
            "fo",
            "("
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n\");\n\t}",
          "args": [
            "else {"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x, take",
          "args": [
            "\");\n\t\telse"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "-7d fr",
          "args": [
            "e %-8d dirty %-8d used %-8d free + dirty %-8d dark %-4d dead %-4d nodes fit %-3d flags %#-4x (\",\n\t\t       lp",
            ">free, l",
            ">dirty,",
            ">leb_size",
            "spc, spc,",
            "da",
            "int)",
            "pc /",
            "BIFS_MAX_NODE_SZ), lp->flags);",
            "if (lp->"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "-7d fr",
          "args": [
            "e %-8d dirty %-8d used %-8d free + dirty %-8d flags %#x (\",\n\t\t       lp",
            ">free, l",
            ">dirty,",
            ">leb_size",
            "spc, spc,",
            "lp",
            "else\n\t\tpr"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rk(c, spc);\n\n\ti",
          "args": [
            "p->"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nmp_lprop(const struct ubifs_info *c, const struct ubifs_lprops *lp)\n{\n\tint i, spc, dark = 0, dead = 0;\n\tstruct rb_node *rb;\n\tstruct ubifs_bud *bud;\n\n\tspc = lp->free + lp->dirty;\n\tif (spc < c->dead_wm)\n\t\tdead = spc;\n\telse\n\t\tdark = ubifs_calc_dark(c, spc);\n\n\tif (lp->flags & LPROPS_INDEX)\n\t\tpr_err(\"LEB %-7d free %-8d dirty %-8d used %-8d free + dirty %-8d flags %#x (\",\n\t\t       lp->lnum, lp->free, lp->dirty, c->leb_size - spc, spc,\n\t\t       lp->flags);\n\telse\n\t\tpr_err(\"LEB %-7d free %-8d dirty %-8d used %-8d free + dirty %-8d dark %-4d dead %-4d nodes fit %-3d flags %#-4x (\",\n\t\t       lp->lnum, lp->free, lp->dirty, c->leb_size - spc, spc,\n\t\t       dark, dead, (int)(spc / UBIFS_MAX_NODE_SZ), lp->flags);\n\n\tif (lp->flags & LPROPS_TAKEN) {\n\t\tif (lp->flags & LPROPS_INDEX)\n\t\t\tpr_cont(\"index, taken\");\n\t\telse\n\t\t\tpr_cont(\"taken\");\n\t} else {\n\t\tconst char *s;\n\n\t\tif (lp->flags & LPROPS_INDEX) {\n\t\t\tswitch (lp->flags & LPROPS_CAT_MASK) {\n\t\t\tcase LPROPS_DIRTY_IDX:\n\t\t\t\ts = \"dirty index\";\n\t\t\t\tbreak;\n\t\t\tcase LPROPS_FRDI_IDX:\n\t\t\t\ts = \"freeable index\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ts = \"index\";\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (lp->flags & LPROPS_CAT_MASK) {\n\t\t\tcase LPROPS_UNCAT:\n\t\t\t\ts = \"not categorized\";\n\t\t\t\tbreak;\n\t\t\tcase LPROPS_DIRTY:\n\t\t\t\ts = \"dirty\";\n\t\t\t\tbreak;\n\t\t\tcase LPROPS_FREE:\n\t\t\t\ts = \"free\";\n\t\t\t\tbreak;\n\t\t\tcase LPROPS_EMPTY:\n\t\t\t\ts = \"empty\";\n\t\t\t\tbreak;\n\t\t\tcase LPROPS_FREEABLE:\n\t\t\t\ts = \"freeable\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ts = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpr_cont(\"%s\", s);\n\t}\n\n\tfor (rb = rb_first((struct rb_root *)&c->buds); rb; rb = rb_next(rb)) {\n\t\tbud = rb_entry(rb, struct ubifs_bud, rb);\n\t\tif (bud->lnum == lp->lnum) {\n\t\t\tint head = 0;\n\t\t\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\t\t\t/*\n\t\t\t\t * Note, if we are in R/O mode or in the middle\n\t\t\t\t * of mounting/re-mounting, the write-buffers do\n\t\t\t\t * not exist.\n\t\t\t\t */\n\t\t\t\tif (c->jheads &&\n\t\t\t\t    lp->lnum == c->jheads[i].wbuf.lnum) {\n\t\t\t\t\tpr_cont(\", jhead %s\", dbg_jhead(i));\n\t\t\t\t\thead = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!head)\n\t\t\t\tpr_cont(\", bud of jhead %s\",\n\t\t\t\t       dbg_jhead(bud->jhead));\n\t\t}\n\t}\n\tif (lp->lnum == c->gc_lnum)\n\t\tpr_cont(\", GC LEB\");\n\tpr_cont(\")\\n\");\n}\n\nvoid ubifs_"
  },
  {
    "function_name": "dg(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "577-643",
    "snippet": "mp_budg(struct ubifs_info *c, const struct ubifs_budg_info *bi)\n{\n\tint i;\n\tstruct rb_node *rb;\n\tstruct ubifs_bud *bud;\n\tstruct ubifs_gced_idx_leb *idx_gc;\n\tlong long available, outstanding, free;\n\n\tspin_lock(&c->space_lock);\n\tspin_lock(&dbg_lock);\n\tpr_err(\"(pid %d) Budgeting info: data budget sum %lld, total budget sum %lld\\n\",\n\t       current->pid, bi->data_growth + bi->dd_growth,\n\t       bi->data_growth + bi->dd_growth + bi->idx_growth);\n\tpr_err(\"\\tbudg_data_growth %lld, budg_dd_growth %lld, budg_idx_growth %lld\\n\",\n\t       bi->data_growth, bi->dd_growth, bi->idx_growth);\n\tpr_err(\"\\tmin_idx_lebs %d, old_idx_sz %llu, uncommitted_idx %lld\\n\",\n\t       bi->min_idx_lebs, bi->old_idx_sz, bi->uncommitted_idx);\n\tpr_err(\"\\tpage_budget %d, inode_budget %d, dent_budget %d\\n\",\n\t       bi->page_budget, bi->inode_budget, bi->dent_budget);\n\tpr_err(\"\\tnospace %u, nospace_rp %u\\n\", bi->nospace, bi->nospace_rp);\n\tpr_err(\"\\tdark_wm %d, dead_wm %d, max_idx_node_sz %d\\n\",\n\t       c->dark_wm, c->dead_wm, c->max_idx_node_sz);\n\n\tif (bi != &c->bi)\n\t\t/*\n\t\t * If we are dumping saved budgeting data, do not print\n\t\t * additional information which is about the current state, not\n\t\t * the old one which corresponded to the saved budgeting data.\n\t\t */\n\t\tgoto out_unlock;\n\n\tpr_err(\"\\tfreeable_cnt %d, calc_idx_sz %lld, idx_gc_cnt %d\\n\",\n\t       c->freeable_cnt, c->calc_idx_sz, c->idx_gc_cnt);\n\tpr_err(\"\\tdirty_pg_cnt %ld, dirty_zn_cnt %ld, clean_zn_cnt %ld\\n\",\n\t       atomic_long_read(&c->dirty_pg_cnt),\n\t       atomic_long_read(&c->dirty_zn_cnt),\n\t       atomic_long_read(&c->clean_zn_cnt));\n\tpr_err(\"\\tgc_lnum %d, ihead_lnum %d\\n\", c->gc_lnum, c->ihead_lnum);\n\n\t/* If we are in R/O mode, journal heads do not exist */\n\tif (c->jheads)\n\t\tfor (i = 0; i < c->jhead_cnt; i++)\n\t\t\tpr_err(\"\\tjhead %s\\t LEB %d\\n\",\n\t\t\t       dbg_jhead(c->jheads[i].wbuf.jhead),\n\t\t\t       c->jheads[i].wbuf.lnum);\n\tfor (rb = rb_first(&c->buds); rb; rb = rb_next(rb)) {\n\t\tbud = rb_entry(rb, struct ubifs_bud, rb);\n\t\tpr_err(\"\\tbud LEB %d\\n\", bud->lnum);\n\t}\n\tlist_for_each_entry(bud, &c->old_buds, list)\n\t\tpr_err(\"\\told bud LEB %d\\n\", bud->lnum);\n\tlist_for_each_entry(idx_gc, &c->idx_gc, list)\n\t\tpr_err(\"\\tGC'ed idx LEB %d unmap %d\\n\",\n\t\t       idx_gc->lnum, idx_gc->unmap);\n\tpr_err(\"\\tcommit state %d\\n\", c->cmt_state);\n\n\t/* Print budgeting predictions */\n\tavailable = ubifs_calc_available(c, c->bi.min_idx_lebs);\n\toutstanding = c->bi.data_growth + c->bi.dd_growth;\n\tfree = ubifs_get_free_space_nolock(c);\n\tpr_err(\"Budgeting predictions:\\n\");\n\tpr_err(\"\\tavailable: %lld, outstanding %lld, free %lld\\n\",\n\t       available, outstanding, free);\nout_unlock:\n\tspin_unlock(&dbg_lock);\n\tspin_unlock(&c->space_lock);\n}\n\nvoid ubifs_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->space_lo",
          "args": [
            "k);\n}\n\nvoid ub"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_lock);",
          "args": [
            "spin_unlo"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilable",
          "args": [
            "%lld, outstanding %lld, free %lld\\n\",\n\t       ava",
            "tstanding",
            "free);\nout_",
            "lock"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "journal_check_available_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1428-1447",
          "snippet": "int journal_check_available_features (journal_t *journal, unsigned long compat,\n\t\t\t\t      unsigned long ro, unsigned long incompat)\n{\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\n\t/* We can support any known requested features iff the\n\t * superblock is in version 2.  Otherwise we fail to support any\n\t * extended sb features. */\n\n\tif (journal->j_format_version != 2)\n\t\treturn 0;\n\n\tif ((compat   & JFS_KNOWN_COMPAT_FEATURES) == compat &&\n\t    (ro       & JFS_KNOWN_ROCOMPAT_FEATURES) == ro &&\n\t    (incompat & JFS_KNOWN_INCOMPAT_FEATURES) == incompat)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_check_available_features (journal_t *journal, unsigned long compat,\n\t\t\t\t      unsigned long ro, unsigned long incompat)\n{\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\n\t/* We can support any known requested features iff the\n\t * superblock is in version 2.  Otherwise we fail to support any\n\t * extended sb features. */\n\n\tif (journal->j_format_version != 2)\n\t\treturn 0;\n\n\tif ((compat   & JFS_KNOWN_COMPAT_FEATURES) == compat &&\n\t    (ro       & JFS_KNOWN_ROCOMPAT_FEATURES) == ro &&\n\t    (incompat & JFS_KNOWN_INCOMPAT_FEATURES) == incompat)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ting p",
          "args": [
            "edictions:\\n\");\n\tpr_err(\"\\"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_space_nolock(c);\n\tpr_err(",
          "args": [
            "B"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailable(c, c->bi.min",
          "args": [
            "i",
            "_lebs);\n\toutstandi"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mit st",
          "args": [
            "te %d\\n\", c->cmt_stat",
            ";\n\n\t/* Print"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed idx",
          "args": [
            "LEB %d unmap %d\\n\",\n\t\t       id",
            "idx_gc->unm",
            ");\n\tpr_err(\"\\"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(idx_gc, &c->",
          "args": [
            "dx_gc,",
            "ist)\n\t\tpr_",
            "r(\"\\"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bud L",
          "args": [
            "B %d\\n\", bud->lnum);",
            "list_for_"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(bud, &c->old",
          "args": [
            "bud",
            "list)\n\t\tpr_",
            "r(\"\\"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEB %",
          "args": [
            "\\n\", bud->lnum);",
            "}\n\tlist_f"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct u",
          "args": [
            "if",
            "bud, r);\n\t\tpr_e",
            "(\""
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "lated(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
          "lines": "2456-2548",
          "snippet": "wer_cut_emulated(struct ubifs_info *c, int lnum, int write)\n{\n\tstruct ubifs_debug_info *d = c->dbg;\n\n\tubifs_assert(dbg_is_tst_rcvry(c));\n\n\tif (!d->pc_cnt) {\n\t\t/* First call - decide delay to the power cut */\n\t\tif (chance(1, 2)) {\n\t\t\tunsigned long delay;\n\n\t\t\tif (chance(1, 2)) {\n\t\t\t\td->pc_delay = 1;\n\t\t\t\t/* Fail within 1 minute */\n\t\t\t\tdelay = prandom_u32() % 60000;\n\t\t\t\td->pc_timeout = jiffies;\n\t\t\t\td->pc_timeout += msecs_to_jiffies(delay);\n\t\t\t\tubifs_warn(\"failing after %lums\", delay);\n\t\t\t} else {\n\t\t\t\td->pc_delay = 2;\n\t\t\t\tdelay = prandom_u32() % 10000;\n\t\t\t\t/* Fail within 10000 operations */\n\t\t\t\td->pc_cnt_max = delay;\n\t\t\t\tubifs_warn(\"failing after %lu calls\", delay);\n\t\t\t}\n\t\t}\n\n\t\td->pc_cnt += 1;\n\t}\n\n\t/* Determine if failure delay has expired */\n\tif (d->pc_delay == 1 && time_before(jiffies, d->pc_timeout))\n\t\t\treturn 0;\n\tif (d->pc_delay == 2 && d->pc_cnt++ < d->pc_cnt_max)\n\t\t\treturn 0;\n\n\tif (lnum == UBIFS_SB_LNUM) {\n\t\tif (write && chance(1, 2))\n\t\t\treturn 0;\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in super block LEB %d\", lnum);\n\t} else if (lnum == UBIFS_MST_LNUM || lnum == UBIFS_MST_LNUM + 1) {\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in master LEB %d\", lnum);\n\t} else if (lnum >= UBIFS_LOG_LNUM && lnum <= c->log_last) {\n\t\tif (write && chance(99, 100))\n\t\t\treturn 0;\n\t\tif (chance(399, 400))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in log LEB %d\", lnum);\n\t} else if (lnum >= c->lpt_first && lnum <= c->lpt_last) {\n\t\tif (write && chance(7, 8))\n\t\t\treturn 0;\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in LPT LEB %d\", lnum);\n\t} else if (lnum >= c->orph_first && lnum <= c->orph_last) {\n\t\tif (write && chance(1, 2))\n\t\t\treturn 0;\n\t\tif (chance(9, 10))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in orphan LEB %d\", lnum);\n\t} else if (lnum == c->ihead_lnum) {\n\t\tif (chance(99, 100))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in index head LEB %d\", lnum);\n\t} else if (c->jheads && lnum == c->jheads[GCHD].wbuf.lnum) {\n\t\tif (chance(9, 10))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in GC head LEB %d\", lnum);\n\t} else if (write && !RB_EMPTY_ROOT(&c->buds) &&\n\t\t   !ubifs_search_bud(c, lnum)) {\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in non-bud LEB %d\", lnum);\n\t} else if (c->cmt_state == COMMIT_RUNNING_BACKGROUND ||\n\t\t   c->cmt_state == COMMIT_RUNNING_REQUIRED) {\n\t\tif (chance(999, 1000))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in bud LEB %d commit running\", lnum);\n\t} else {\n\t\tif (chance(9999, 10000))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in bud LEB %d commit not running\", lnum);\n\t}\n\n\td->pc_happened = 1;\n\tubifs_warn(\"========== Power cut emulated ==========\");\n\tdump_stack();\n\treturn 1;\n}\n\nstatic int",
          "includes": [
            "fs.h\"\n\nstatic DEFIN",
            "ux/random.h>\n#include \"ubi",
            "ux/uaccess.h>\n#include <lin",
            "ux/math64.h>\n#include <lin",
            "ux/debugfs.h>\n#include <lin",
            "ux/module.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nwer_cut_emulated(struct ubifs_info *c, int lnum, int write)\n{\n\tstruct ubifs_debug_info *d = c->dbg;\n\n\tubifs_assert(dbg_is_tst_rcvry(c));\n\n\tif (!d->pc_cnt) {\n\t\t/* First call - decide delay to the power cut */\n\t\tif (chance(1, 2)) {\n\t\t\tunsigned long delay;\n\n\t\t\tif (chance(1, 2)) {\n\t\t\t\td->pc_delay = 1;\n\t\t\t\t/* Fail within 1 minute */\n\t\t\t\tdelay = prandom_u32() % 60000;\n\t\t\t\td->pc_timeout = jiffies;\n\t\t\t\td->pc_timeout += msecs_to_jiffies(delay);\n\t\t\t\tubifs_warn(\"failing after %lums\", delay);\n\t\t\t} else {\n\t\t\t\td->pc_delay = 2;\n\t\t\t\tdelay = prandom_u32() % 10000;\n\t\t\t\t/* Fail within 10000 operations */\n\t\t\t\td->pc_cnt_max = delay;\n\t\t\t\tubifs_warn(\"failing after %lu calls\", delay);\n\t\t\t}\n\t\t}\n\n\t\td->pc_cnt += 1;\n\t}\n\n\t/* Determine if failure delay has expired */\n\tif (d->pc_delay == 1 && time_before(jiffies, d->pc_timeout))\n\t\t\treturn 0;\n\tif (d->pc_delay == 2 && d->pc_cnt++ < d->pc_cnt_max)\n\t\t\treturn 0;\n\n\tif (lnum == UBIFS_SB_LNUM) {\n\t\tif (write && chance(1, 2))\n\t\t\treturn 0;\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in super block LEB %d\", lnum);\n\t} else if (lnum == UBIFS_MST_LNUM || lnum == UBIFS_MST_LNUM + 1) {\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in master LEB %d\", lnum);\n\t} else if (lnum >= UBIFS_LOG_LNUM && lnum <= c->log_last) {\n\t\tif (write && chance(99, 100))\n\t\t\treturn 0;\n\t\tif (chance(399, 400))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in log LEB %d\", lnum);\n\t} else if (lnum >= c->lpt_first && lnum <= c->lpt_last) {\n\t\tif (write && chance(7, 8))\n\t\t\treturn 0;\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in LPT LEB %d\", lnum);\n\t} else if (lnum >= c->orph_first && lnum <= c->orph_last) {\n\t\tif (write && chance(1, 2))\n\t\t\treturn 0;\n\t\tif (chance(9, 10))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in orphan LEB %d\", lnum);\n\t} else if (lnum == c->ihead_lnum) {\n\t\tif (chance(99, 100))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in index head LEB %d\", lnum);\n\t} else if (c->jheads && lnum == c->jheads[GCHD].wbuf.lnum) {\n\t\tif (chance(9, 10))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in GC head LEB %d\", lnum);\n\t} else if (write && !RB_EMPTY_ROOT(&c->buds) &&\n\t\t   !ubifs_search_bud(c, lnum)) {\n\t\tif (chance(19, 20))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in non-bud LEB %d\", lnum);\n\t} else if (c->cmt_state == COMMIT_RUNNING_BACKGROUND ||\n\t\t   c->cmt_state == COMMIT_RUNNING_REQUIRED) {\n\t\tif (chance(999, 1000))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in bud LEB %d commit running\", lnum);\n\t} else {\n\t\tif (chance(9999, 10000))\n\t\t\treturn 0;\n\t\tubifs_warn(\"failing in bud LEB %d commit not running\", lnum);\n\t}\n\n\td->pc_happened = 1;\n\tubifs_warn(\"========== Power cut emulated ==========\");\n\tdump_stack();\n\treturn 1;\n}\n\nstatic int"
        }
      },
      {
        "call_info": {
          "callee": "{\n\t\tbud",
          "args": [
            "="
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buds); r",
          "args": [
            "; rb = r"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad %s\\",
          "args": [
            "LEB %d\\n\",\n\t\t\t       d",
            "jheads[i].wbuf.jhead),\n\t\t\t       c",
            "wbuf.lnum);\n\tfor (rb ="
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jheads[i]",
          "args": [
            "wbuf.jhead),"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lnum %",
          "args": [
            ", ihead_lnum %d\\n\", c->gc_lnum,",
            "->ihead_ln",
            ");\n\n\t/* If we"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ty_pg_",
          "args": [
            "nt %ld, dirty_zn_cnt %ld, clean_zn_cnt %ld\\n\",\n\t       ato",
            "ead(&c->dirty_pg_cnt),\n\t       ato",
            "ead(&c->dirty_zn_cnt),\n\t       ato",
            "ead(&c->clean_zn_cnt));\n\tpr_err(\"\\"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ead(&c->clean_zn",
          "args": [
            "cnt));\n\tpr_err(\""
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ead(&c->dirty_zn",
          "args": [
            "cnt),\n\t       at"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ead(&c->dirty_pg",
          "args": [
            "cnt),\n\t       at"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eable_",
          "args": [
            "nt %d, calc_idx_sz %lld, idx_gc_cnt %d\\n\",\n\t       c->",
            "nt, c->calc_idx",
            "z, c->idx_gc_c",
            ");\n\tpr_err(\"\\"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_update_writeable_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "1029-1123",
          "snippet": "static int ceph_update_writeable_page(struct file *file,\n\t\t\t    loff_t pos, unsigned len,\n\t\t\t    struct page *page)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tloff_t page_off = pos & PAGE_CACHE_MASK;\n\tint pos_in_page = pos & ~PAGE_CACHE_MASK;\n\tint end_in_page = pos_in_page + len;\n\tloff_t i_size;\n\tint r;\n\tstruct ceph_snap_context *snapc, *oldest;\n\nretry_locked:\n\t/* writepages currently holds page lock, but if we change that later, */\n\twait_on_page_writeback(page);\n\n\t/* check snap context */\n\tBUG_ON(!ci->i_snap_realm);\n\tdown_read(&mdsc->snap_rwsem);\n\tBUG_ON(!ci->i_snap_realm->cached_context);\n\tsnapc = page_snap_context(page);\n\tif (snapc && snapc != ci->i_head_snapc) {\n\t\t/*\n\t\t * this page is already dirty in another (older) snap\n\t\t * context!  is it writeable now?\n\t\t */\n\t\toldest = get_oldest_context(inode, NULL);\n\t\tup_read(&mdsc->snap_rwsem);\n\n\t\tif (snapc->seq > oldest->seq) {\n\t\t\tceph_put_snap_context(oldest);\n\t\t\tdout(\" page %p snapc %p not current or oldest\\n\",\n\t\t\t     page, snapc);\n\t\t\t/*\n\t\t\t * queue for writeback, and wait for snapc to\n\t\t\t * be writeable or written\n\t\t\t */\n\t\t\tsnapc = ceph_get_snap_context(snapc);\n\t\t\tunlock_page(page);\n\t\t\tceph_queue_writeback(inode);\n\t\t\tr = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t       context_is_writeable_or_written(inode, snapc));\n\t\t\tceph_put_snap_context(snapc);\n\t\t\tif (r == -ERESTARTSYS)\n\t\t\t\treturn r;\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tceph_put_snap_context(oldest);\n\n\t\t/* yay, writeable, do it now (without dropping page lock) */\n\t\tdout(\" page %p snapc %p not current, but oldest\\n\",\n\t\t     page, snapc);\n\t\tif (!clear_page_dirty_for_io(page))\n\t\t\tgoto retry_locked;\n\t\tr = writepage_nounlock(page, NULL);\n\t\tif (r < 0)\n\t\t\tgoto fail_nosnap;\n\t\tgoto retry_locked;\n\t}\n\n\tif (PageUptodate(page)) {\n\t\tdout(\" page %p already uptodate\\n\", page);\n\t\treturn 0;\n\t}\n\n\t/* full page? */\n\tif (pos_in_page == 0 && len == PAGE_CACHE_SIZE)\n\t\treturn 0;\n\n\t/* past end of file? */\n\ti_size = inode->i_size;   /* caller holds i_mutex */\n\n\tif (page_off >= i_size ||\n\t    (pos_in_page == 0 && (pos+len) >= i_size &&\n\t     end_in_page - pos_in_page != PAGE_CACHE_SIZE)) {\n\t\tdout(\" zeroing %p 0 - %d and %d - %d\\n\",\n\t\t     page, pos_in_page, end_in_page, (int)PAGE_CACHE_SIZE);\n\t\tzero_user_segments(page,\n\t\t\t\t   0, pos_in_page,\n\t\t\t\t   end_in_page, PAGE_CACHE_SIZE);\n\t\treturn 0;\n\t}\n\n\t/* we need to read it. */\n\tup_read(&mdsc->snap_rwsem);\n\tr = readpage_nounlock(file, page);\n\tif (r < 0)\n\t\tgoto fail_nosnap;\n\tgoto retry_locked;\nfail_nosnap:\n\tunlock_page(page);\n\treturn r;\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_update_writeable_page(struct file *file,\n\t\t\t    loff_t pos, unsigned len,\n\t\t\t    struct page *page)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tloff_t page_off = pos & PAGE_CACHE_MASK;\n\tint pos_in_page = pos & ~PAGE_CACHE_MASK;\n\tint end_in_page = pos_in_page + len;\n\tloff_t i_size;\n\tint r;\n\tstruct ceph_snap_context *snapc, *oldest;\n\nretry_locked:\n\t/* writepages currently holds page lock, but if we change that later, */\n\twait_on_page_writeback(page);\n\n\t/* check snap context */\n\tBUG_ON(!ci->i_snap_realm);\n\tdown_read(&mdsc->snap_rwsem);\n\tBUG_ON(!ci->i_snap_realm->cached_context);\n\tsnapc = page_snap_context(page);\n\tif (snapc && snapc != ci->i_head_snapc) {\n\t\t/*\n\t\t * this page is already dirty in another (older) snap\n\t\t * context!  is it writeable now?\n\t\t */\n\t\toldest = get_oldest_context(inode, NULL);\n\t\tup_read(&mdsc->snap_rwsem);\n\n\t\tif (snapc->seq > oldest->seq) {\n\t\t\tceph_put_snap_context(oldest);\n\t\t\tdout(\" page %p snapc %p not current or oldest\\n\",\n\t\t\t     page, snapc);\n\t\t\t/*\n\t\t\t * queue for writeback, and wait for snapc to\n\t\t\t * be writeable or written\n\t\t\t */\n\t\t\tsnapc = ceph_get_snap_context(snapc);\n\t\t\tunlock_page(page);\n\t\t\tceph_queue_writeback(inode);\n\t\t\tr = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t       context_is_writeable_or_written(inode, snapc));\n\t\t\tceph_put_snap_context(snapc);\n\t\t\tif (r == -ERESTARTSYS)\n\t\t\t\treturn r;\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tceph_put_snap_context(oldest);\n\n\t\t/* yay, writeable, do it now (without dropping page lock) */\n\t\tdout(\" page %p snapc %p not current, but oldest\\n\",\n\t\t     page, snapc);\n\t\tif (!clear_page_dirty_for_io(page))\n\t\t\tgoto retry_locked;\n\t\tr = writepage_nounlock(page, NULL);\n\t\tif (r < 0)\n\t\t\tgoto fail_nosnap;\n\t\tgoto retry_locked;\n\t}\n\n\tif (PageUptodate(page)) {\n\t\tdout(\" page %p already uptodate\\n\", page);\n\t\treturn 0;\n\t}\n\n\t/* full page? */\n\tif (pos_in_page == 0 && len == PAGE_CACHE_SIZE)\n\t\treturn 0;\n\n\t/* past end of file? */\n\ti_size = inode->i_size;   /* caller holds i_mutex */\n\n\tif (page_off >= i_size ||\n\t    (pos_in_page == 0 && (pos+len) >= i_size &&\n\t     end_in_page - pos_in_page != PAGE_CACHE_SIZE)) {\n\t\tdout(\" zeroing %p 0 - %d and %d - %d\\n\",\n\t\t     page, pos_in_page, end_in_page, (int)PAGE_CACHE_SIZE);\n\t\tzero_user_segments(page,\n\t\t\t\t   0, pos_in_page,\n\t\t\t\t   end_in_page, PAGE_CACHE_SIZE);\n\t\treturn 0;\n\t}\n\n\t/* we need to read it. */\n\tup_read(&mdsc->snap_rwsem);\n\tr = readpage_nounlock(file, page);\n\tif (r < 0)\n\t\tgoto fail_nosnap;\n\tgoto retry_locked;\nfail_nosnap:\n\tunlock_page(page);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "k_wm %",
          "args": [
            ", dead_wm %d, max_idx_node_sz %d\\n\",\n\t       c->",
            "->dead_wm,",
            "->max_idx_",
            "de_sz);\n\n\tif (bi !"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pace %",
          "args": [
            ", nospace_rp %u\\n\", bi->nospace",
            "bi->nospace",
            "p);\n\tpr_err(\"\\"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_budg",
          "args": [
            "t %d, inode_budget %d, dent_budget %d\\n\",\n\t       bi-",
            "et, bi->inode_b",
            "get, bi->dent_bu",
            "et);\n\tpr_err(\"\\"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_idx_l",
          "args": [
            "bs %d, old_idx_sz %llu, uncommitted_idx %lld\\n\",\n\t       bi-",
            "ebs, bi->old_idx",
            "z, bi->uncommi",
            "ed_idx);\n\tpr_err(\"\\"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_data",
          "args": [
            "growth %lld, budg_dd_growth %lld, budg_idx_growth %lld\\n\",\n\t       bi-",
            "th, bi->dd_grow",
            ", bi->idx_gro",
            "h);\n\tpr_err(\"\\"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%d) Bu",
          "args": [
            "geting info: data budget sum %lld, total budget sum %lld\\n\",\n\t       cur",
            "bi->data_gr",
            "th + bi->dd_growth,\n\t       bi-",
            "th + bi->dd_growth + bi->idx_growth);\n\tpr_err(\"\\"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_lock);",
          "args": [
            "pr_err(\"("
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">space_lo",
          "args": [
            "k);\n\tspin_lock"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nmp_budg(struct ubifs_info *c, const struct ubifs_budg_info *bi)\n{\n\tint i;\n\tstruct rb_node *rb;\n\tstruct ubifs_bud *bud;\n\tstruct ubifs_gced_idx_leb *idx_gc;\n\tlong long available, outstanding, free;\n\n\tspin_lock(&c->space_lock);\n\tspin_lock(&dbg_lock);\n\tpr_err(\"(pid %d) Budgeting info: data budget sum %lld, total budget sum %lld\\n\",\n\t       current->pid, bi->data_growth + bi->dd_growth,\n\t       bi->data_growth + bi->dd_growth + bi->idx_growth);\n\tpr_err(\"\\tbudg_data_growth %lld, budg_dd_growth %lld, budg_idx_growth %lld\\n\",\n\t       bi->data_growth, bi->dd_growth, bi->idx_growth);\n\tpr_err(\"\\tmin_idx_lebs %d, old_idx_sz %llu, uncommitted_idx %lld\\n\",\n\t       bi->min_idx_lebs, bi->old_idx_sz, bi->uncommitted_idx);\n\tpr_err(\"\\tpage_budget %d, inode_budget %d, dent_budget %d\\n\",\n\t       bi->page_budget, bi->inode_budget, bi->dent_budget);\n\tpr_err(\"\\tnospace %u, nospace_rp %u\\n\", bi->nospace, bi->nospace_rp);\n\tpr_err(\"\\tdark_wm %d, dead_wm %d, max_idx_node_sz %d\\n\",\n\t       c->dark_wm, c->dead_wm, c->max_idx_node_sz);\n\n\tif (bi != &c->bi)\n\t\t/*\n\t\t * If we are dumping saved budgeting data, do not print\n\t\t * additional information which is about the current state, not\n\t\t * the old one which corresponded to the saved budgeting data.\n\t\t */\n\t\tgoto out_unlock;\n\n\tpr_err(\"\\tfreeable_cnt %d, calc_idx_sz %lld, idx_gc_cnt %d\\n\",\n\t       c->freeable_cnt, c->calc_idx_sz, c->idx_gc_cnt);\n\tpr_err(\"\\tdirty_pg_cnt %ld, dirty_zn_cnt %ld, clean_zn_cnt %ld\\n\",\n\t       atomic_long_read(&c->dirty_pg_cnt),\n\t       atomic_long_read(&c->dirty_zn_cnt),\n\t       atomic_long_read(&c->clean_zn_cnt));\n\tpr_err(\"\\tgc_lnum %d, ihead_lnum %d\\n\", c->gc_lnum, c->ihead_lnum);\n\n\t/* If we are in R/O mode, journal heads do not exist */\n\tif (c->jheads)\n\t\tfor (i = 0; i < c->jhead_cnt; i++)\n\t\t\tpr_err(\"\\tjhead %s\\t LEB %d\\n\",\n\t\t\t       dbg_jhead(c->jheads[i].wbuf.jhead),\n\t\t\t       c->jheads[i].wbuf.lnum);\n\tfor (rb = rb_first(&c->buds); rb; rb = rb_next(rb)) {\n\t\tbud = rb_entry(rb, struct ubifs_bud, rb);\n\t\tpr_err(\"\\tbud LEB %d\\n\", bud->lnum);\n\t}\n\tlist_for_each_entry(bud, &c->old_buds, list)\n\t\tpr_err(\"\\told bud LEB %d\\n\", bud->lnum);\n\tlist_for_each_entry(idx_gc, &c->idx_gc, list)\n\t\tpr_err(\"\\tGC'ed idx LEB %d unmap %d\\n\",\n\t\t       idx_gc->lnum, idx_gc->unmap);\n\tpr_err(\"\\tcommit state %d\\n\", c->cmt_state);\n\n\t/* Print budgeting predictions */\n\tavailable = ubifs_calc_available(c, c->bi.min_idx_lebs);\n\toutstanding = c->bi.data_growth + c->bi.dd_growth;\n\tfree = ubifs_get_free_space_nolock(c);\n\tpr_err(\"Budgeting predictions:\\n\");\n\tpr_err(\"\\tavailable: %lld, outstanding %lld, free %lld\\n\",\n\t       available, outstanding, free);\nout_unlock:\n\tspin_unlock(&dbg_lock);\n\tspin_unlock(&c->space_lock);\n}\n\nvoid ubifs_"
  },
  {
    "function_name": "tats(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "565-575",
    "snippet": "mp_lstats(const struct ubifs_lp_stats *lst)\n{\n\tspin_lock(&dbg_lock);\n\tpr_err(\"(pid %d) Lprops statistics: empty_lebs %d, idx_lebs  %d\\n\",\n\t       current->pid, lst->empty_lebs, lst->idx_lebs);\n\tpr_err(\"\\ttaken_empty_lebs %d, total_free %lld, total_dirty %lld\\n\",\n\t       lst->taken_empty_lebs, lst->total_free, lst->total_dirty);\n\tpr_err(\"\\ttotal_used %lld, total_dark %lld, total_dead %lld\\n\",\n\t       lst->total_used, lst->total_dark, lst->total_dead);\n\tspin_unlock(&dbg_lock);\n}\n\nvoid ubifs_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbg_lock);",
          "args": [
            "void ub"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "al_use",
          "args": [
            "%lld, total_dark %lld, total_dead %lld\\n\",\n\t       lst",
            "ed, lst->total_",
            "rk, lst->total_",
            "ad);\n\tspin_unlo"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en_emp",
          "args": [
            "y_lebs %d, total_free %lld, total_dirty %lld\\n\",\n\t       lst",
            "pty_lebs, lst->total_",
            "ee, lst->total_",
            "rty);\n\tpr_err(\"\\"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%d) Lp",
          "args": [
            "ops statistics: empty_lebs %d, idx_lebs  %d\\n\",\n\t       cur",
            "lst->empty_",
            "bs, lst->idx_le",
            ");\n\tpr_err(\"\\"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_lock);",
          "args": [
            "pr_err(\"("
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nmp_lstats(const struct ubifs_lp_stats *lst)\n{\n\tspin_lock(&dbg_lock);\n\tpr_err(\"(pid %d) Lprops statistics: empty_lebs %d, idx_lebs  %d\\n\",\n\t       current->pid, lst->empty_lebs, lst->idx_lebs);\n\tpr_err(\"\\ttaken_empty_lebs %d, total_free %lld, total_dirty %lld\\n\",\n\t       lst->taken_empty_lebs, lst->total_free, lst->total_dirty);\n\tpr_err(\"\\ttotal_used %lld, total_dark %lld, total_dead %lld\\n\",\n\t       lst->total_used, lst->total_dark, lst->total_dead);\n\tspin_unlock(&dbg_lock);\n}\n\nvoid ubifs_"
  },
  {
    "function_name": "dget_req(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "548-563",
    "snippet": "mp_budget_req(const struct ubifs_budget_req *req)\n{\n\tspin_lock(&dbg_lock);\n\tpr_err(\"Budgeting request: new_ino %d, dirtied_ino %d\\n\",\n\t       req->new_ino, req->dirtied_ino);\n\tpr_err(\"\\tnew_ino_d   %d, dirtied_ino_d %d\\n\",\n\t       req->new_ino_d, req->dirtied_ino_d);\n\tpr_err(\"\\tnew_page    %d, dirtied_page %d\\n\",\n\t       req->new_page, req->dirtied_page);\n\tpr_err(\"\\tnew_dent    %d, mod_dent     %d\\n\",\n\t       req->new_dent, req->mod_dent);\n\tpr_err(\"\\tidx_growth  %d\\n\", req->idx_growth);\n\tpr_err(\"\\tdata_growth %d dd_growth     %d\\n\",\n\t       req->data_growth, req->dd_growth);\n\tspin_unlock(&dbg_lock);\n}\n\nvoid ubifs_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbg_lock);",
          "args": [
            "void ub"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a_grow",
          "args": [
            "h %d dd_growth     %d\\n\",\n\t       req",
            "wth, req->dd_gro",
            "h);\n\tspin_unlo"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_grow_inode_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1994-2078",
          "snippet": "int\nxfs_da_grow_inode_int(\n\tstruct xfs_da_args\t*args,\n\txfs_fileoff_t\t\t*bno,\n\tint\t\t\tcount)\n{\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_inode\t*dp = args->dp;\n\tint\t\t\tw = args->whichfork;\n\txfs_rfsblock_t\t\tnblks = dp->i_d.di_nblocks;\n\tstruct xfs_bmbt_irec\tmap, *mapp;\n\tint\t\t\tnmap, error, got, i, mapi;\n\n\t/*\n\t * Find a spot in the file space to put the new block.\n\t */\n\terror = xfs_bmap_first_unused(tp, dp, count, bno, w);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Try mapping it in one filesystem block.\n\t */\n\tnmap = 1;\n\tASSERT(args->firstblock != NULL);\n\terror = xfs_bmapi_write(tp, dp, *bno, count,\n\t\t\txfs_bmapi_aflag(w)|XFS_BMAPI_METADATA|XFS_BMAPI_CONTIG,\n\t\t\targs->firstblock, args->total, &map, &nmap,\n\t\t\targs->flist);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(nmap <= 1);\n\tif (nmap == 1) {\n\t\tmapp = &map;\n\t\tmapi = 1;\n\t} else if (nmap == 0 && count > 1) {\n\t\txfs_fileoff_t\t\tb;\n\t\tint\t\t\tc;\n\n\t\t/*\n\t\t * If we didn't get it and the block might work if fragmented,\n\t\t * try without the CONTIG flag.  Loop until we get it all.\n\t\t */\n\t\tmapp = kmem_alloc(sizeof(*mapp) * count, KM_SLEEP);\n\t\tfor (b = *bno, mapi = 0; b < *bno + count; ) {\n\t\t\tnmap = MIN(XFS_BMAP_MAX_NMAP, count);\n\t\t\tc = (int)(*bno + count - b);\n\t\t\terror = xfs_bmapi_write(tp, dp, b, c,\n\t\t\t\t\txfs_bmapi_aflag(w)|XFS_BMAPI_METADATA,\n\t\t\t\t\targs->firstblock, args->total,\n\t\t\t\t\t&mapp[mapi], &nmap, args->flist);\n\t\t\tif (error)\n\t\t\t\tgoto out_free_map;\n\t\t\tif (nmap < 1)\n\t\t\t\tbreak;\n\t\t\tmapi += nmap;\n\t\t\tb = mapp[mapi - 1].br_startoff +\n\t\t\t    mapp[mapi - 1].br_blockcount;\n\t\t}\n\t} else {\n\t\tmapi = 0;\n\t\tmapp = NULL;\n\t}\n\n\t/*\n\t * Count the blocks we got, make sure it matches the total.\n\t */\n\tfor (i = 0, got = 0; i < mapi; i++)\n\t\tgot += mapp[i].br_blockcount;\n\tif (got != count || mapp[0].br_startoff != *bno ||\n\t    mapp[mapi - 1].br_startoff + mapp[mapi - 1].br_blockcount !=\n\t    *bno + count) {\n\t\terror = -ENOSPC;\n\t\tgoto out_free_map;\n\t}\n\n\t/* account for newly allocated blocks in reserved blocks total */\n\targs->total -= dp->i_d.di_nblocks - nblks;\n\nout_free_map:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_grow_inode_int(\n\tstruct xfs_da_args\t*args,\n\txfs_fileoff_t\t\t*bno,\n\tint\t\t\tcount)\n{\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_inode\t*dp = args->dp;\n\tint\t\t\tw = args->whichfork;\n\txfs_rfsblock_t\t\tnblks = dp->i_d.di_nblocks;\n\tstruct xfs_bmbt_irec\tmap, *mapp;\n\tint\t\t\tnmap, error, got, i, mapi;\n\n\t/*\n\t * Find a spot in the file space to put the new block.\n\t */\n\terror = xfs_bmap_first_unused(tp, dp, count, bno, w);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Try mapping it in one filesystem block.\n\t */\n\tnmap = 1;\n\tASSERT(args->firstblock != NULL);\n\terror = xfs_bmapi_write(tp, dp, *bno, count,\n\t\t\txfs_bmapi_aflag(w)|XFS_BMAPI_METADATA|XFS_BMAPI_CONTIG,\n\t\t\targs->firstblock, args->total, &map, &nmap,\n\t\t\targs->flist);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(nmap <= 1);\n\tif (nmap == 1) {\n\t\tmapp = &map;\n\t\tmapi = 1;\n\t} else if (nmap == 0 && count > 1) {\n\t\txfs_fileoff_t\t\tb;\n\t\tint\t\t\tc;\n\n\t\t/*\n\t\t * If we didn't get it and the block might work if fragmented,\n\t\t * try without the CONTIG flag.  Loop until we get it all.\n\t\t */\n\t\tmapp = kmem_alloc(sizeof(*mapp) * count, KM_SLEEP);\n\t\tfor (b = *bno, mapi = 0; b < *bno + count; ) {\n\t\t\tnmap = MIN(XFS_BMAP_MAX_NMAP, count);\n\t\t\tc = (int)(*bno + count - b);\n\t\t\terror = xfs_bmapi_write(tp, dp, b, c,\n\t\t\t\t\txfs_bmapi_aflag(w)|XFS_BMAPI_METADATA,\n\t\t\t\t\targs->firstblock, args->total,\n\t\t\t\t\t&mapp[mapi], &nmap, args->flist);\n\t\t\tif (error)\n\t\t\t\tgoto out_free_map;\n\t\t\tif (nmap < 1)\n\t\t\t\tbreak;\n\t\t\tmapi += nmap;\n\t\t\tb = mapp[mapi - 1].br_startoff +\n\t\t\t    mapp[mapi - 1].br_blockcount;\n\t\t}\n\t} else {\n\t\tmapi = 0;\n\t\tmapp = NULL;\n\t}\n\n\t/*\n\t * Count the blocks we got, make sure it matches the total.\n\t */\n\tfor (i = 0, got = 0; i < mapi; i++)\n\t\tgot += mapp[i].br_blockcount;\n\tif (got != count || mapp[0].br_startoff != *bno ||\n\t    mapp[mapi - 1].br_startoff + mapp[mapi - 1].br_blockcount !=\n\t    *bno + count) {\n\t\terror = -ENOSPC;\n\t\tgoto out_free_map;\n\t}\n\n\t/* account for newly allocated blocks in reserved blocks total */\n\targs->total -= dp->i_d.di_nblocks - nblks;\n\nout_free_map:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_growt",
          "args": [
            "%d\\n\", req->idx_gr",
            "th);\n\tpr_err(\"\\"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_dent",
          "args": [
            "%d, mod_dent     %d\\n\",\n\t       req",
            ", req->mod_de",
            ");\n\tpr_err(\"\\"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "seq_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "523-540",
          "snippet": "int seq_dentry(struct seq_file *m, struct dentry *dentry, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = dentry_path(dentry, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_dentry(struct seq_file *m, struct dentry *dentry, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = dentry_path(dentry, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_page",
          "args": [
            "%d, dirtied_page %d\\n\",\n\t       req",
            ", req->dirtie",
            "page);\n\tpr_err(\"\\"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "dio_send_cur_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/direct-io.c",
          "lines": "702-747",
          "snippet": "static inline int dio_send_cur_page(struct dio *dio, struct dio_submit *sdio,\n\t\tstruct buffer_head *map_bh)\n{\n\tint ret = 0;\n\n\tif (sdio->bio) {\n\t\tloff_t cur_offset = sdio->cur_page_fs_offset;\n\t\tloff_t bio_next_offset = sdio->logical_offset_in_bio +\n\t\t\tsdio->bio->bi_iter.bi_size;\n\n\t\t/*\n\t\t * See whether this new request is contiguous with the old.\n\t\t *\n\t\t * Btrfs cannot handle having logically non-contiguous requests\n\t\t * submitted.  For example if you have\n\t\t *\n\t\t * Logical:  [0-4095][HOLE][8192-12287]\n\t\t * Physical: [0-4095]      [4096-8191]\n\t\t *\n\t\t * We cannot submit those pages together as one BIO.  So if our\n\t\t * current logical offset in the file does not equal what would\n\t\t * be the next logical offset in the bio, submit the bio we\n\t\t * have.\n\t\t */\n\t\tif (sdio->final_block_in_bio != sdio->cur_page_block ||\n\t\t    cur_offset != bio_next_offset)\n\t\t\tdio_bio_submit(dio, sdio);\n\t}\n\n\tif (sdio->bio == NULL) {\n\t\tret = dio_new_bio(dio, sdio, sdio->cur_page_block, map_bh);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (dio_bio_add_page(sdio) != 0) {\n\t\tdio_bio_submit(dio, sdio);\n\t\tret = dio_new_bio(dio, sdio, sdio->cur_page_block, map_bh);\n\t\tif (ret == 0) {\n\t\t\tret = dio_bio_add_page(sdio);\n\t\t\tBUG_ON(ret != 0);\n\t\t}\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uio.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/err.h>",
            "#include <linux/wait.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dio {\n\tint flags;\t\t\t/* doesn't change */\n\tint rw;\n\tstruct inode *inode;\n\tloff_t i_size;\t\t\t/* i_size when submitted */\n\tdio_iodone_t *end_io;\t\t/* IO completion function */\n\n\tvoid *private;\t\t\t/* copy from map_bh.b_private */\n\n\t/* BIO completion state */\n\tspinlock_t bio_lock;\t\t/* protects BIO fields below */\n\tint page_errors;\t\t/* errno from get_user_pages() */\n\tint is_async;\t\t\t/* is IO async ? */\n\tbool defer_completion;\t\t/* defer AIO completion to workqueue? */\n\tint io_error;\t\t\t/* IO error in completion path */\n\tunsigned long refcount;\t\t/* direct_io_worker() and bios */\n\tstruct bio *bio_list;\t\t/* singly linked via bi_private */\n\tstruct task_struct *waiter;\t/* waiting task (NULL if none) */\n\n\t/* AIO related stuff */\n\tstruct kiocb *iocb;\t\t/* kiocb */\n\tssize_t result;                 /* IO result */\n\n\t/*\n\t * pages[] (and any fields placed after it) are not zeroed out at\n\t * allocation time.  Don't add new fields after pages[] unless you\n\t * wish that they not be zeroed.\n\t */\n\tunion {\n\t\tstruct page *pages[DIO_PAGES];\t/* page buffer */\n\t\tstruct work_struct complete_work;/* deferred AIO completion */\n\t};\n} ____cacheline_aligned_in_smp;",
            "static int dio_bio_complete(struct dio *dio, struct bio *bio);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/prefetch.h>\n#include <linux/atomic.h>\n#include <linux/uio.h>\n#include <linux/rwsem.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/err.h>\n#include <linux/wait.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct dio {\n\tint flags;\t\t\t/* doesn't change */\n\tint rw;\n\tstruct inode *inode;\n\tloff_t i_size;\t\t\t/* i_size when submitted */\n\tdio_iodone_t *end_io;\t\t/* IO completion function */\n\n\tvoid *private;\t\t\t/* copy from map_bh.b_private */\n\n\t/* BIO completion state */\n\tspinlock_t bio_lock;\t\t/* protects BIO fields below */\n\tint page_errors;\t\t/* errno from get_user_pages() */\n\tint is_async;\t\t\t/* is IO async ? */\n\tbool defer_completion;\t\t/* defer AIO completion to workqueue? */\n\tint io_error;\t\t\t/* IO error in completion path */\n\tunsigned long refcount;\t\t/* direct_io_worker() and bios */\n\tstruct bio *bio_list;\t\t/* singly linked via bi_private */\n\tstruct task_struct *waiter;\t/* waiting task (NULL if none) */\n\n\t/* AIO related stuff */\n\tstruct kiocb *iocb;\t\t/* kiocb */\n\tssize_t result;                 /* IO result */\n\n\t/*\n\t * pages[] (and any fields placed after it) are not zeroed out at\n\t * allocation time.  Don't add new fields after pages[] unless you\n\t * wish that they not be zeroed.\n\t */\n\tunion {\n\t\tstruct page *pages[DIO_PAGES];\t/* page buffer */\n\t\tstruct work_struct complete_work;/* deferred AIO completion */\n\t};\n} ____cacheline_aligned_in_smp;\nstatic int dio_bio_complete(struct dio *dio, struct bio *bio);\n\nstatic inline int dio_send_cur_page(struct dio *dio, struct dio_submit *sdio,\n\t\tstruct buffer_head *map_bh)\n{\n\tint ret = 0;\n\n\tif (sdio->bio) {\n\t\tloff_t cur_offset = sdio->cur_page_fs_offset;\n\t\tloff_t bio_next_offset = sdio->logical_offset_in_bio +\n\t\t\tsdio->bio->bi_iter.bi_size;\n\n\t\t/*\n\t\t * See whether this new request is contiguous with the old.\n\t\t *\n\t\t * Btrfs cannot handle having logically non-contiguous requests\n\t\t * submitted.  For example if you have\n\t\t *\n\t\t * Logical:  [0-4095][HOLE][8192-12287]\n\t\t * Physical: [0-4095]      [4096-8191]\n\t\t *\n\t\t * We cannot submit those pages together as one BIO.  So if our\n\t\t * current logical offset in the file does not equal what would\n\t\t * be the next logical offset in the bio, submit the bio we\n\t\t * have.\n\t\t */\n\t\tif (sdio->final_block_in_bio != sdio->cur_page_block ||\n\t\t    cur_offset != bio_next_offset)\n\t\t\tdio_bio_submit(dio, sdio);\n\t}\n\n\tif (sdio->bio == NULL) {\n\t\tret = dio_new_bio(dio, sdio, sdio->cur_page_block, map_bh);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (dio_bio_add_page(sdio) != 0) {\n\t\tdio_bio_submit(dio, sdio);\n\t\tret = dio_new_bio(dio, sdio, sdio->cur_page_block, map_bh);\n\t\tif (ret == 0) {\n\t\t\tret = dio_bio_add_page(sdio);\n\t\t\tBUG_ON(ret != 0);\n\t\t}\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ino_d",
          "args": [
            "%d, dirtied_ino_d %d\\n\",\n\t       req",
            "d, req->dirtie",
            "ino_d);\n\tpr_err(\"\\"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ting r",
          "args": [
            "quest: new_ino %d, dirtied_ino %d\\n\",\n\t       req",
            "req->dirtie",
            "ino);\n\tpr_err(\"\\"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_lock);",
          "args": [
            "pr_err(\"B"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nmp_budget_req(const struct ubifs_budget_req *req)\n{\n\tspin_lock(&dbg_lock);\n\tpr_err(\"Budgeting request: new_ino %d, dirtied_ino %d\\n\",\n\t       req->new_ino, req->dirtied_ino);\n\tpr_err(\"\\tnew_ino_d   %d, dirtied_ino_d %d\\n\",\n\t       req->new_ino_d, req->dirtied_ino_d);\n\tpr_err(\"\\tnew_page    %d, dirtied_page %d\\n\",\n\t       req->new_page, req->dirtied_page);\n\tpr_err(\"\\tnew_dent    %d, mod_dent     %d\\n\",\n\t       req->new_dent, req->mod_dent);\n\tpr_err(\"\\tidx_growth  %d\\n\", req->idx_growth);\n\tpr_err(\"\\tdata_growth %d dd_growth     %d\\n\",\n\t       req->data_growth, req->dd_growth);\n\tspin_unlock(&dbg_lock);\n}\n\nvoid ubifs_"
  },
  {
    "function_name": "de(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "301-546",
    "snippet": "mp_node(const struct ubifs_info *c, const void *node)\n{\n\tint i, n;\n\tunion ubifs_key key;\n\tconst struct ubifs_ch *ch = node;\n\tchar key_buf[DBG_KEY_BUF_LEN];\n\n\t/* If the magic is incorrect, just hexdump the first bytes */\n\tif (le32_to_cpu(ch->magic) != UBIFS_NODE_MAGIC) {\n\t\tpr_err(\"Not a node, first %zu bytes:\", UBIFS_CH_SZ);\n\t\tprint_hex_dump(KERN_ERR, \"\", DUMP_PREFIX_OFFSET, 32, 1,\n\t\t\t       (void *)node, UBIFS_CH_SZ, 1);\n\t\treturn;\n\t}\n\n\tspin_lock(&dbg_lock);\n\tdump_ch(node);\n\n\tswitch (ch->node_type) {\n\tcase UBIFS_PAD_NODE:\n\t{\n\t\tconst struct ubifs_pad_node *pad = node;\n\n\t\tpr_err(\"\\tpad_len        %u\\n\", le32_to_cpu(pad->pad_len));\n\t\tbreak;\n\t}\n\tcase UBIFS_SB_NODE:\n\t{\n\t\tconst struct ubifs_sb_node *sup = node;\n\t\tunsigned int sup_flags = le32_to_cpu(sup->flags);\n\n\t\tpr_err(\"\\tkey_hash       %d (%s)\\n\",\n\t\t       (int)sup->key_hash, get_key_hash(sup->key_hash));\n\t\tpr_err(\"\\tkey_fmt        %d (%s)\\n\",\n\t\t       (int)sup->key_fmt, get_key_fmt(sup->key_fmt));\n\t\tpr_err(\"\\tflags          %#x\\n\", sup_flags);\n\t\tpr_err(\"\\tbig_lpt        %u\\n\",\n\t\t       !!(sup_flags & UBIFS_FLG_BIGLPT));\n\t\tpr_err(\"\\tspace_fixup    %u\\n\",\n\t\t       !!(sup_flags & UBIFS_FLG_SPACE_FIXUP));\n\t\tpr_err(\"\\tmin_io_size    %u\\n\", le32_to_cpu(sup->min_io_size));\n\t\tpr_err(\"\\tleb_size       %u\\n\", le32_to_cpu(sup->leb_size));\n\t\tpr_err(\"\\tleb_cnt        %u\\n\", le32_to_cpu(sup->leb_cnt));\n\t\tpr_err(\"\\tmax_leb_cnt    %u\\n\", le32_to_cpu(sup->max_leb_cnt));\n\t\tpr_err(\"\\tmax_bud_bytes  %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(sup->max_bud_bytes));\n\t\tpr_err(\"\\tlog_lebs       %u\\n\", le32_to_cpu(sup->log_lebs));\n\t\tpr_err(\"\\tlpt_lebs       %u\\n\", le32_to_cpu(sup->lpt_lebs));\n\t\tpr_err(\"\\torph_lebs      %u\\n\", le32_to_cpu(sup->orph_lebs));\n\t\tpr_err(\"\\tjhead_cnt      %u\\n\", le32_to_cpu(sup->jhead_cnt));\n\t\tpr_err(\"\\tfanout         %u\\n\", le32_to_cpu(sup->fanout));\n\t\tpr_err(\"\\tlsave_cnt      %u\\n\", le32_to_cpu(sup->lsave_cnt));\n\t\tpr_err(\"\\tdefault_compr  %u\\n\",\n\t\t       (int)le16_to_cpu(sup->default_compr));\n\t\tpr_err(\"\\trp_size        %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(sup->rp_size));\n\t\tpr_err(\"\\trp_uid         %u\\n\", le32_to_cpu(sup->rp_uid));\n\t\tpr_err(\"\\trp_gid         %u\\n\", le32_to_cpu(sup->rp_gid));\n\t\tpr_err(\"\\tfmt_version    %u\\n\", le32_to_cpu(sup->fmt_version));\n\t\tpr_err(\"\\ttime_gran      %u\\n\", le32_to_cpu(sup->time_gran));\n\t\tpr_err(\"\\tUUID           %pUB\\n\", sup->uuid);\n\t\tbreak;\n\t}\n\tcase UBIFS_MST_NODE:\n\t{\n\t\tconst struct ubifs_mst_node *mst = node;\n\n\t\tpr_err(\"\\thighest_inum   %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(mst->highest_inum));\n\t\tpr_err(\"\\tcommit number  %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(mst->cmt_no));\n\t\tpr_err(\"\\tflags          %#x\\n\", le32_to_cpu(mst->flags));\n\t\tpr_err(\"\\tlog_lnum       %u\\n\", le32_to_cpu(mst->log_lnum));\n\t\tpr_err(\"\\troot_lnum      %u\\n\", le32_to_cpu(mst->root_lnum));\n\t\tpr_err(\"\\troot_offs      %u\\n\", le32_to_cpu(mst->root_offs));\n\t\tpr_err(\"\\troot_len       %u\\n\", le32_to_cpu(mst->root_len));\n\t\tpr_err(\"\\tgc_lnum        %u\\n\", le32_to_cpu(mst->gc_lnum));\n\t\tpr_err(\"\\tihead_lnum     %u\\n\", le32_to_cpu(mst->ihead_lnum));\n\t\tpr_err(\"\\tihead_offs     %u\\n\", le32_to_cpu(mst->ihead_offs));\n\t\tpr_err(\"\\tindex_size     %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(mst->index_size));\n\t\tpr_err(\"\\tlpt_lnum       %u\\n\", le32_to_cpu(mst->lpt_lnum));\n\t\tpr_err(\"\\tlpt_offs       %u\\n\", le32_to_cpu(mst->lpt_offs));\n\t\tpr_err(\"\\tnhead_lnum     %u\\n\", le32_to_cpu(mst->nhead_lnum));\n\t\tpr_err(\"\\tnhead_offs     %u\\n\", le32_to_cpu(mst->nhead_offs));\n\t\tpr_err(\"\\tltab_lnum      %u\\n\", le32_to_cpu(mst->ltab_lnum));\n\t\tpr_err(\"\\tltab_offs      %u\\n\", le32_to_cpu(mst->ltab_offs));\n\t\tpr_err(\"\\tlsave_lnum     %u\\n\", le32_to_cpu(mst->lsave_lnum));\n\t\tpr_err(\"\\tlsave_offs     %u\\n\", le32_to_cpu(mst->lsave_offs));\n\t\tpr_err(\"\\tlscan_lnum     %u\\n\", le32_to_cpu(mst->lscan_lnum));\n\t\tpr_err(\"\\tleb_cnt        %u\\n\", le32_to_cpu(mst->leb_cnt));\n\t\tpr_err(\"\\tempty_lebs     %u\\n\", le32_to_cpu(mst->empty_lebs));\n\t\tpr_err(\"\\tidx_lebs       %u\\n\", le32_to_cpu(mst->idx_lebs));\n\t\tpr_err(\"\\ttotal_free     %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(mst->total_free));\n\t\tpr_err(\"\\ttotal_dirty    %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(mst->total_dirty));\n\t\tpr_err(\"\\ttotal_used     %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(mst->total_used));\n\t\tpr_err(\"\\ttotal_dead     %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(mst->total_dead));\n\t\tpr_err(\"\\ttotal_dark     %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(mst->total_dark));\n\t\tbreak;\n\t}\n\tcase UBIFS_REF_NODE:\n\t{\n\t\tconst struct ubifs_ref_node *ref = node;\n\n\t\tpr_err(\"\\tlnum           %u\\n\", le32_to_cpu(ref->lnum));\n\t\tpr_err(\"\\toffs           %u\\n\", le32_to_cpu(ref->offs));\n\t\tpr_err(\"\\tjhead          %u\\n\", le32_to_cpu(ref->jhead));\n\t\tbreak;\n\t}\n\tcase UBIFS_INO_NODE:\n\t{\n\t\tconst struct ubifs_ino_node *ino = node;\n\n\t\tkey_read(c, &ino->key, &key);\n\t\tpr_err(\"\\tkey            %s\\n\",\n\t\t       dbg_snprintf_key(c, &key, key_buf, DBG_KEY_BUF_LEN));\n\t\tpr_err(\"\\tcreat_sqnum    %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(ino->creat_sqnum));\n\t\tpr_err(\"\\tsize           %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(ino->size));\n\t\tpr_err(\"\\tnlink          %u\\n\", le32_to_cpu(ino->nlink));\n\t\tpr_err(\"\\tatime          %lld.%u\\n\",\n\t\t       (long long)le64_to_cpu(ino->atime_sec),\n\t\t       le32_to_cpu(ino->atime_nsec));\n\t\tpr_err(\"\\tmtime          %lld.%u\\n\",\n\t\t       (long long)le64_to_cpu(ino->mtime_sec),\n\t\t       le32_to_cpu(ino->mtime_nsec));\n\t\tpr_err(\"\\tctime          %lld.%u\\n\",\n\t\t       (long long)le64_to_cpu(ino->ctime_sec),\n\t\t       le32_to_cpu(ino->ctime_nsec));\n\t\tpr_err(\"\\tuid            %u\\n\", le32_to_cpu(ino->uid));\n\t\tpr_err(\"\\tgid            %u\\n\", le32_to_cpu(ino->gid));\n\t\tpr_err(\"\\tmode           %u\\n\", le32_to_cpu(ino->mode));\n\t\tpr_err(\"\\tflags          %#x\\n\", le32_to_cpu(ino->flags));\n\t\tpr_err(\"\\txattr_cnt      %u\\n\", le32_to_cpu(ino->xattr_cnt));\n\t\tpr_err(\"\\txattr_size     %u\\n\", le32_to_cpu(ino->xattr_size));\n\t\tpr_err(\"\\txattr_names    %u\\n\", le32_to_cpu(ino->xattr_names));\n\t\tpr_err(\"\\tcompr_type     %#x\\n\",\n\t\t       (int)le16_to_cpu(ino->compr_type));\n\t\tpr_err(\"\\tdata len       %u\\n\", le32_to_cpu(ino->data_len));\n\t\tbreak;\n\t}\n\tcase UBIFS_DENT_NODE:\n\tcase UBIFS_XENT_NODE:\n\t{\n\t\tconst struct ubifs_dent_node *dent = node;\n\t\tint nlen = le16_to_cpu(dent->nlen);\n\n\t\tkey_read(c, &dent->key, &key);\n\t\tpr_err(\"\\tkey            %s\\n\",\n\t\t       dbg_snprintf_key(c, &key, key_buf, DBG_KEY_BUF_LEN));\n\t\tpr_err(\"\\tinum           %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(dent->inum));\n\t\tpr_err(\"\\ttype           %d\\n\", (int)dent->type);\n\t\tpr_err(\"\\tnlen           %d\\n\", nlen);\n\t\tpr_err(\"\\tname           \");\n\n\t\tif (nlen > UBIFS_MAX_NLEN)\n\t\t\tpr_err(\"(bad name length, not printing, bad or corrupted node)\");\n\t\telse {\n\t\t\tfor (i = 0; i < nlen && dent->name[i]; i++)\n\t\t\t\tpr_cont(\"%c\", dent->name[i]);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\n\t\tbreak;\n\t}\n\tcase UBIFS_DATA_NODE:\n\t{\n\t\tconst struct ubifs_data_node *dn = node;\n\t\tint dlen = le32_to_cpu(ch->len) - UBIFS_DATA_NODE_SZ;\n\n\t\tkey_read(c, &dn->key, &key);\n\t\tpr_err(\"\\tkey            %s\\n\",\n\t\t       dbg_snprintf_key(c, &key, key_buf, DBG_KEY_BUF_LEN));\n\t\tpr_err(\"\\tsize           %u\\n\", le32_to_cpu(dn->size));\n\t\tpr_err(\"\\tcompr_typ      %d\\n\",\n\t\t       (int)le16_to_cpu(dn->compr_type));\n\t\tpr_err(\"\\tdata size      %d\\n\", dlen);\n\t\tpr_err(\"\\tdata:\\n\");\n\t\tprint_hex_dump(KERN_ERR, \"\\t\", DUMP_PREFIX_OFFSET, 32, 1,\n\t\t\t       (void *)&dn->data, dlen, 0);\n\t\tbreak;\n\t}\n\tcase UBIFS_TRUN_NODE:\n\t{\n\t\tconst struct ubifs_trun_node *trun = node;\n\n\t\tpr_err(\"\\tinum           %u\\n\", le32_to_cpu(trun->inum));\n\t\tpr_err(\"\\told_size       %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(trun->old_size));\n\t\tpr_err(\"\\tnew_size       %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(trun->new_size));\n\t\tbreak;\n\t}\n\tcase UBIFS_IDX_NODE:\n\t{\n\t\tconst struct ubifs_idx_node *idx = node;\n\n\t\tn = le16_to_cpu(idx->child_cnt);\n\t\tpr_err(\"\\tchild_cnt      %d\\n\", n);\n\t\tpr_err(\"\\tlevel          %d\\n\", (int)le16_to_cpu(idx->level));\n\t\tpr_err(\"\\tBranches:\\n\");\n\n\t\tfor (i = 0; i < n && i < c->fanout - 1; i++) {\n\t\t\tconst struct ubifs_branch *br;\n\n\t\t\tbr = ubifs_idx_branch(c, idx, i);\n\t\t\tkey_read(c, &br->key, &key);\n\t\t\tpr_err(\"\\t%d: LEB %d:%d len %d key %s\\n\",\n\t\t\t       i, le32_to_cpu(br->lnum), le32_to_cpu(br->offs),\n\t\t\t       le32_to_cpu(br->len),\n\t\t\t       dbg_snprintf_key(c, &key, key_buf,\n\t\t\t\t\t\tDBG_KEY_BUF_LEN));\n\t\t}\n\t\tbreak;\n\t}\n\tcase UBIFS_CS_NODE:\n\t\tbreak;\n\tcase UBIFS_ORPH_NODE:\n\t{\n\t\tconst struct ubifs_orph_node *orph = node;\n\n\t\tpr_err(\"\\tcommit number  %llu\\n\",\n\t\t       (unsigned long long)\n\t\t\t\tle64_to_cpu(orph->cmt_no) & LLONG_MAX);\n\t\tpr_err(\"\\tlast node flag %llu\\n\",\n\t\t       (unsigned long long)(le64_to_cpu(orph->cmt_no)) >> 63);\n\t\tn = (le32_to_cpu(ch->len) - UBIFS_ORPH_NODE_SZ) >> 3;\n\t\tpr_err(\"\\t%d orphan inode numbers:\\n\", n);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tpr_err(\"\\t  ino %llu\\n\",\n\t\t\t       (unsigned long long)le64_to_cpu(orph->inos[i]));\n\t\tbreak;\n\t}\n\tdefault:\n\t\tpr_err(\"node type %d was not recognized\\n\",\n\t\t       (int)ch->node_type);\n\t}\n\tspin_unlock(&dbg_lock);\n}\n\nvoid ubifs_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbg_lock);",
          "args": [
            "void ub"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type %",
          "args": [
            "was not recognized\\n\",\n\t\t       (i",
            "_type);\n\t}\n\tspin_u"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no %ll",
          "args": [
            "\\n\",\n\t\t\t       (",
            "g long)le64_to_cpu(orph->inos[i]));\n\t\tbreak;"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rph->inos[i",
          "args": [
            "));\n\t\tbreak;"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphan",
          "args": [
            "inode numbers:\\n\", n);\n\t\tfor (",
            "="
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_scan_orphans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
          "lines": "879-911",
          "snippet": "static int dbg_scan_orphans(struct ubifs_info *c, struct check_info *ci)\n{\n\tint lnum, err = 0;\n\tvoid *buf;\n\n\t/* Check no-orphans flag and skip this if no orphans */\n\tif (c->no_orphs)\n\t\treturn 0;\n\n\tbuf = __vmalloc(c->leb_size, GFP_NOFS, PAGE_KERNEL);\n\tif (!buf) {\n\t\tubifs_err(\"cannot allocate memory to check orphans\");\n\t\treturn 0;\n\t}\n\n\tfor (lnum = c->orph_first; lnum <= c->orph_last; lnum++) {\n\t\tstruct ubifs_scan_leb *sleb;\n\n\t\tsleb = ubifs_scan(c, lnum, 0, buf, 0);\n\t\tif (IS_ERR(sleb)) {\n\t\t\terr = PTR_ERR(sleb);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = dbg_read_orphans(ci, sleb);\n\t\tubifs_scan_destroy(sleb);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tvfree(buf);\n\treturn err;\n}",
          "includes": [
            "#include \"ubifs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbg_check_orphans(struct ubifs_info *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic int dbg_scan_orphans(struct ubifs_info *c, struct check_info *ci)\n{\n\tint lnum, err = 0;\n\tvoid *buf;\n\n\t/* Check no-orphans flag and skip this if no orphans */\n\tif (c->no_orphs)\n\t\treturn 0;\n\n\tbuf = __vmalloc(c->leb_size, GFP_NOFS, PAGE_KERNEL);\n\tif (!buf) {\n\t\tubifs_err(\"cannot allocate memory to check orphans\");\n\t\treturn 0;\n\t}\n\n\tfor (lnum = c->orph_first; lnum <= c->orph_last; lnum++) {\n\t\tstruct ubifs_scan_leb *sleb;\n\n\t\tsleb = ubifs_scan(c, lnum, 0, buf, 0);\n\t\tif (IS_ERR(sleb)) {\n\t\t\terr = PTR_ERR(sleb);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = dbg_read_orphans(ci, sleb);\n\t\tubifs_scan_destroy(sleb);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tvfree(buf);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "h->len) - U",
          "args": [
            "IFS_ORP"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t node",
          "args": [
            "flag %llu\\n\",\n\t\t       (u",
            "g long)(le64_to_cpu(orph->cmt_no)) >> 63);\n\t\tn = (le3"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rph->cmt_no",
          "args": [
            ") >> 63);"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mit nu",
          "args": [
            "ber  %llu\\n\",\n\t\t       (u",
            "g long)\n\t\t\t\tle64_to_cpu(orph->cmt_no) & LLONG_MAX);\n\t\tpr_err(\""
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rph->cmt_no",
          "args": [
            "& LLONG_MAX"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEB %",
          "args": [
            ":%d len %d key %s\\n\",\n\t\t\t       i",
            "u",
            "r->lnum), le32_to_cpu",
            "r->offs),\n\t\t\t       l",
            "r->len),\n\t\t\t       d",
            "key(c, &key, key_buf,\n\t\t\t\t\t\tDBG_KEY_BUF_LEN));\n\t\t}\n\t\tbrea"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key(c, &key, key",
          "args": [
            "b",
            ",",
            "DBG_K",
            "EN));\n\t\t}\n\t\tbre"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r->len),",
          "args": [],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r->offs),",
          "args": [],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r->lnum), l",
          "args": [
            "32_to_cp"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "br->key,",
          "args": [
            "&",
            "y);\n\t\t\tp",
            "err("
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nch(c, idx, i);",
          "args": [
            "ey_",
            "a"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nches:",
          "args": [
            "n\");\n\n\t\tfor (i"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "el",
          "args": [
            "%d\\n\", (int)le16_t",
            "cpu(idx->level));\n\t\tpr_err(\""
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "elorder_next(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_misc.c",
          "lines": "40-118",
          "snippet": "znode *ubifs_tnc_levelorder_next(struct ubifs_znode *zr,\n\t\t\t\t\t      struct ubifs_znode *znode)\n{\n\tint level, iip, level_search = 0;\n\tstruct ubifs_znode *zn;\n\n\tubifs_assert(zr);\n\n\tif (unlikely(!znode))\n\t\treturn zr;\n\n\tif (unlikely(znode == zr)) {\n\t\tif (znode->level == 0)\n\t\t\treturn NULL;\n\t\treturn ubifs_tnc_find_child(zr, 0);\n\t}\n\n\tlevel = znode->level;\n\n\tiip = znode->iip;\n\twhile (1) {\n\t\tubifs_assert(znode->level <= zr->level);\n\n\t\t/*\n\t\t * First walk up until there is a znode with next branch to\n\t\t * look at.\n\t\t */\n\t\twhile (znode->parent != zr && iip >= znode->parent->child_cnt) {\n\t\t\tznode = znode->parent;\n\t\t\tiip = znode->iip;\n\t\t}\n\n\t\tif (unlikely(znode->parent == zr &&\n\t\t\t     iip >= znode->parent->child_cnt)) {\n\t\t\t/* This level is done, switch to the lower one */\n\t\t\tlevel -= 1;\n\t\t\tif (level_search || level < 0)\n\t\t\t\t/*\n\t\t\t\t * We were already looking for znode at lower\n\t\t\t\t * level ('level_search'). As we are here\n\t\t\t\t * again, it just does not exist. Or all levels\n\t\t\t\t * were finished ('level < 0').\n\t\t\t\t */\n\t\t\t\treturn NULL;\n\n\t\t\tlevel_search = 1;\n\t\t\tiip = -1;\n\t\t\tznode = ubifs_tnc_find_child(zr, 0);\n\t\t\tubifs_assert(znode);\n\t\t}\n\n\t\t/* Switch to the next index */\n\t\tzn = ubifs_tnc_find_child(znode->parent, iip + 1);\n\t\tif (!zn) {\n\t\t\t/* No more children to look at, we have walk up */\n\t\t\tiip = znode->parent->child_cnt;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Walk back down to the level we came from ('level') */\n\t\twhile (zn->level != level) {\n\t\t\tznode = zn;\n\t\t\tzn = ubifs_tnc_find_child(zn, 0);\n\t\t\tif (!zn) {\n\t\t\t\t/*\n\t\t\t\t * This path is not too deep so it does not\n\t\t\t\t * reach 'level'. Try next path.\n\t\t\t\t */\n\t\t\t\tiip = znode->iip;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (zn) {\n\t\t\tubifs_assert(zn->level >= 0);\n\t\t\treturn zn;\n\t\t}\n\t}\n}\n\n/**\n * ubif",
          "includes": [
            "fs.h\"\n\n/**\n * ubifs"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\n\nznode *ubifs_tnc_levelorder_next(struct ubifs_znode *zr,\n\t\t\t\t\t      struct ubifs_znode *znode)\n{\n\tint level, iip, level_search = 0;\n\tstruct ubifs_znode *zn;\n\n\tubifs_assert(zr);\n\n\tif (unlikely(!znode))\n\t\treturn zr;\n\n\tif (unlikely(znode == zr)) {\n\t\tif (znode->level == 0)\n\t\t\treturn NULL;\n\t\treturn ubifs_tnc_find_child(zr, 0);\n\t}\n\n\tlevel = znode->level;\n\n\tiip = znode->iip;\n\twhile (1) {\n\t\tubifs_assert(znode->level <= zr->level);\n\n\t\t/*\n\t\t * First walk up until there is a znode with next branch to\n\t\t * look at.\n\t\t */\n\t\twhile (znode->parent != zr && iip >= znode->parent->child_cnt) {\n\t\t\tznode = znode->parent;\n\t\t\tiip = znode->iip;\n\t\t}\n\n\t\tif (unlikely(znode->parent == zr &&\n\t\t\t     iip >= znode->parent->child_cnt)) {\n\t\t\t/* This level is done, switch to the lower one */\n\t\t\tlevel -= 1;\n\t\t\tif (level_search || level < 0)\n\t\t\t\t/*\n\t\t\t\t * We were already looking for znode at lower\n\t\t\t\t * level ('level_search'). As we are here\n\t\t\t\t * again, it just does not exist. Or all levels\n\t\t\t\t * were finished ('level < 0').\n\t\t\t\t */\n\t\t\t\treturn NULL;\n\n\t\t\tlevel_search = 1;\n\t\t\tiip = -1;\n\t\t\tznode = ubifs_tnc_find_child(zr, 0);\n\t\t\tubifs_assert(znode);\n\t\t}\n\n\t\t/* Switch to the next index */\n\t\tzn = ubifs_tnc_find_child(znode->parent, iip + 1);\n\t\tif (!zn) {\n\t\t\t/* No more children to look at, we have walk up */\n\t\t\tiip = znode->parent->child_cnt;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Walk back down to the level we came from ('level') */\n\t\twhile (zn->level != level) {\n\t\t\tznode = zn;\n\t\t\tzn = ubifs_tnc_find_child(zn, 0);\n\t\t\tif (!zn) {\n\t\t\t\t/*\n\t\t\t\t * This path is not too deep so it does not\n\t\t\t\t * reach 'level'. Try next path.\n\t\t\t\t */\n\t\t\t\tiip = znode->iip;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (zn) {\n\t\t\tubifs_assert(zn->level >= 0);\n\t\t\treturn zn;\n\t\t}\n\t}\n}\n\n/**\n * ubif"
        }
      },
      {
        "call_info": {
          "callee": "dx->level))",
          "args": [
            "pr_err("
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ld_cnt",
          "args": [
            "%d\\n\", n);\n\t\tpr_er",
            "\""
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx->child_c",
          "args": [
            "t);\n\t\tpr_err(\""
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_size",
          "args": [
            "%llu\\n\",\n\t\t       (u",
            "g long)le64_to_cpu(trun->new_size));\n\t\tbreak;"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "_size(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
          "lines": "1715-1737",
          "snippet": "_idx_size(struct ubifs_info *c, long long idx_size)\n{\n\tint err;\n\tlong long calc = 0;\n\n\tif (!dbg_is_chk_index(c))\n\t\treturn 0;\n\n\terr = dbg_walk_index(c, NULL, add_size, &calc);\n\tif (err) {\n\t\tubifs_err(\"error %d while walking the index\", err);\n\t\treturn err;\n\t}\n\n\tif (calc != idx_size) {\n\t\tubifs_err(\"index size check failed: calculated size is %lld, should be %lld\",\n\t\t\t  calc, idx_size);\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/**\n * stru",
          "includes": [
            "fs.h\"\n\nstatic DEFIN",
            "ux/random.h>\n#include \"ubi",
            "ux/uaccess.h>\n#include <lin",
            "ux/math64.h>\n#include <lin",
            "ux/debugfs.h>\n#include <lin",
            "ux/module.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [
            "global_debug_info ubifs_dbg;\n\nstatic stru"
          ],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nglobal_debug_info ubifs_dbg;\n\nstatic stru;\n\n_idx_size(struct ubifs_info *c, long long idx_size)\n{\n\tint err;\n\tlong long calc = 0;\n\n\tif (!dbg_is_chk_index(c))\n\t\treturn 0;\n\n\terr = dbg_walk_index(c, NULL, add_size, &calc);\n\tif (err) {\n\t\tubifs_err(\"error %d while walking the index\", err);\n\t\treturn err;\n\t}\n\n\tif (calc != idx_size) {\n\t\tubifs_err(\"index size check failed: calculated size is %lld, should be %lld\",\n\t\t\t  calc, idx_size);\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/**\n * stru"
        }
      },
      {
        "call_info": {
          "callee": "run->new_si",
          "args": [
            "e));\n\t\tbreak;"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run->old_si",
          "args": [
            "e));\n\t\tpr_err("
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m",
          "args": [
            "%u\\n\", le32_to_cpu",
            "run->inum));\n\t\tpr_err(\""
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "jffs2_dbg_dump_node(s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/debug.c",
          "lines": "772-865",
          "snippet": "id\n__jffs2_dbg_dump_node(struct jffs2_sb_info *c, uint32_t ofs)\n{\n\tunion jffs2_node_union node;\n\tint len = sizeof(union jffs2_node_union);\n\tsize_t retlen;\n\tuint32_t crc;\n\tint ret;\n\n\tprintk(JFFS2_DBG_MSG_PREFIX \" dump node at offset %#08x.\\n\", ofs);\n\n\tret = jffs2_flash_read(c, ofs, len, &retlen, (unsigned char *)&node);\n\tif (ret || (retlen != len)) {\n\t\tJFFS2_ERROR(\"read %d bytes failed or short. ret %d, retlen %zd.\\n\",\n\t\t\tlen, ret, retlen);\n\t\treturn;\n\t}\n\n\tprintk(JFFS2_DBG \"magic:\\t%#04x\\n\", je16_to_cpu(node.u.magic));\n\tprintk(JFFS2_DBG \"nodetype:\\t%#04x\\n\", je16_to_cpu(node.u.nodetype));\n\tprintk(JFFS2_DBG \"totlen:\\t%#08x\\n\", je32_to_cpu(node.u.totlen));\n\tprintk(JFFS2_DBG \"hdr_crc:\\t%#08x\\n\", je32_to_cpu(node.u.hdr_crc));\n\n\tcrc = crc32(0, &node.u, sizeof(node.u) - 4);\n\tif (crc != je32_to_cpu(node.u.hdr_crc)) {\n\t\tJFFS2_ERROR(\"wrong common header CRC.\\n\");\n\t\treturn;\n\t}\n\n\tif (je16_to_cpu(node.u.magic) != JFFS2_MAGIC_BITMASK &&\n\t\tje16_to_cpu(node.u.magic) != JFFS2_OLD_MAGIC_BITMASK)\n\t{\n\t\tJFFS2_ERROR(\"wrong node magic: %#04x instead of %#04x.\\n\",\n\t\t\tje16_to_cpu(node.u.magic), JFFS2_MAGIC_BITMASK);\n\t\treturn;\n\t}\n\n\tswitch(je16_to_cpu(node.u.nodetype)) {\n\n\tcase JFFS2_NODETYPE_INODE:\n\n\t\tprintk(JFFS2_DBG \"the node is inode node\\n\");\n\t\tprintk(JFFS2_DBG \"ino:\\t%#08x\\n\", je32_to_cpu(node.i.ino));\n\t\tprintk(JFFS2_DBG \"version:\\t%#08x\\n\", je32_to_cpu(node.i.version));\n\t\tprintk(JFFS2_DBG \"mode:\\t%#08x\\n\", node.i.mode.m);\n\t\tprintk(JFFS2_DBG \"uid:\\t%#04x\\n\", je16_to_cpu(node.i.uid));\n\t\tprintk(JFFS2_DBG \"gid:\\t%#04x\\n\", je16_to_cpu(node.i.gid));\n\t\tprintk(JFFS2_DBG \"isize:\\t%#08x\\n\", je32_to_cpu(node.i.isize));\n\t\tprintk(JFFS2_DBG \"atime:\\t%#08x\\n\", je32_to_cpu(node.i.atime));\n\t\tprintk(JFFS2_DBG \"mtime:\\t%#08x\\n\", je32_to_cpu(node.i.mtime));\n\t\tprintk(JFFS2_DBG \"ctime:\\t%#08x\\n\", je32_to_cpu(node.i.ctime));\n\t\tprintk(JFFS2_DBG \"offset:\\t%#08x\\n\", je32_to_cpu(node.i.offset));\n\t\tprintk(JFFS2_DBG \"csize:\\t%#08x\\n\", je32_to_cpu(node.i.csize));\n\t\tprintk(JFFS2_DBG \"dsize:\\t%#08x\\n\", je32_to_cpu(node.i.dsize));\n\t\tprintk(JFFS2_DBG \"compr:\\t%#02x\\n\", node.i.compr);\n\t\tprintk(JFFS2_DBG \"usercompr:\\t%#02x\\n\", node.i.usercompr);\n\t\tprintk(JFFS2_DBG \"flags:\\t%#04x\\n\", je16_to_cpu(node.i.flags));\n\t\tprintk(JFFS2_DBG \"data_crc:\\t%#08x\\n\", je32_to_cpu(node.i.data_crc));\n\t\tprintk(JFFS2_DBG \"node_crc:\\t%#08x\\n\", je32_to_cpu(node.i.node_crc));\n\n\t\tcrc = crc32(0, &node.i, sizeof(node.i) - 8);\n\t\tif (crc != je32_to_cpu(node.i.node_crc)) {\n\t\t\tJFFS2_ERROR(\"wrong node header CRC.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase JFFS2_NODETYPE_DIRENT:\n\n\t\tprintk(JFFS2_DBG \"the node is dirent node\\n\");\n\t\tprintk(JFFS2_DBG \"pino:\\t%#08x\\n\", je32_to_cpu(node.d.pino));\n\t\tprintk(JFFS2_DBG \"version:\\t%#08x\\n\", je32_to_cpu(node.d.version));\n\t\tprintk(JFFS2_DBG \"ino:\\t%#08x\\n\", je32_to_cpu(node.d.ino));\n\t\tprintk(JFFS2_DBG \"mctime:\\t%#08x\\n\", je32_to_cpu(node.d.mctime));\n\t\tprintk(JFFS2_DBG \"nsize:\\t%#02x\\n\", node.d.nsize);\n\t\tprintk(JFFS2_DBG \"type:\\t%#02x\\n\", node.d.type);\n\t\tprintk(JFFS2_DBG \"node_crc:\\t%#08x\\n\", je32_to_cpu(node.d.node_crc));\n\t\tprintk(JFFS2_DBG \"name_crc:\\t%#08x\\n\", je32_to_cpu(node.d.name_crc));\n\n\t\tnode.d.name[node.d.nsize] = '\\0';\n\t\tprintk(JFFS2_DBG \"name:\\t\\\"%s\\\"\\n\", node.d.name);\n\n\t\tcrc = crc32(0, &node.d, sizeof(node.d) - 8);\n\t\tif (crc != je32_to_cpu(node.d.node_crc)) {\n\t\t\tJFFS2_ERROR(\"wrong node header CRC.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(JFFS2_DBG \"node type is unknown\\n\");\n\t\tbreak;\n\t}\n}\n#",
          "includes": [
            "nclude \"debug.h\"\n\n#",
            "nclude \"nodelist.h\"\n#i",
            "nclude <linux/slab.h>\n#i",
            "nclude <linux/mtd/mtd.h>\n#i",
            "nclude <linux/jffs2.h>\n#i",
            "nclude <linux/crc32.h>\n#i",
            "nclude <linux/pagemap.h>\n#i",
            "nclude <linux/types.h>\n#i",
            "nclude <linux/kernel.h>\n#i"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "nclude \"debug.h\"\n\n#\nnclude \"nodelist.h\"\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/jffs2.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/types.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nid\n__jffs2_dbg_dump_node(struct jffs2_sb_info *c, uint32_t ofs)\n{\n\tunion jffs2_node_union node;\n\tint len = sizeof(union jffs2_node_union);\n\tsize_t retlen;\n\tuint32_t crc;\n\tint ret;\n\n\tprintk(JFFS2_DBG_MSG_PREFIX \" dump node at offset %#08x.\\n\", ofs);\n\n\tret = jffs2_flash_read(c, ofs, len, &retlen, (unsigned char *)&node);\n\tif (ret || (retlen != len)) {\n\t\tJFFS2_ERROR(\"read %d bytes failed or short. ret %d, retlen %zd.\\n\",\n\t\t\tlen, ret, retlen);\n\t\treturn;\n\t}\n\n\tprintk(JFFS2_DBG \"magic:\\t%#04x\\n\", je16_to_cpu(node.u.magic));\n\tprintk(JFFS2_DBG \"nodetype:\\t%#04x\\n\", je16_to_cpu(node.u.nodetype));\n\tprintk(JFFS2_DBG \"totlen:\\t%#08x\\n\", je32_to_cpu(node.u.totlen));\n\tprintk(JFFS2_DBG \"hdr_crc:\\t%#08x\\n\", je32_to_cpu(node.u.hdr_crc));\n\n\tcrc = crc32(0, &node.u, sizeof(node.u) - 4);\n\tif (crc != je32_to_cpu(node.u.hdr_crc)) {\n\t\tJFFS2_ERROR(\"wrong common header CRC.\\n\");\n\t\treturn;\n\t}\n\n\tif (je16_to_cpu(node.u.magic) != JFFS2_MAGIC_BITMASK &&\n\t\tje16_to_cpu(node.u.magic) != JFFS2_OLD_MAGIC_BITMASK)\n\t{\n\t\tJFFS2_ERROR(\"wrong node magic: %#04x instead of %#04x.\\n\",\n\t\t\tje16_to_cpu(node.u.magic), JFFS2_MAGIC_BITMASK);\n\t\treturn;\n\t}\n\n\tswitch(je16_to_cpu(node.u.nodetype)) {\n\n\tcase JFFS2_NODETYPE_INODE:\n\n\t\tprintk(JFFS2_DBG \"the node is inode node\\n\");\n\t\tprintk(JFFS2_DBG \"ino:\\t%#08x\\n\", je32_to_cpu(node.i.ino));\n\t\tprintk(JFFS2_DBG \"version:\\t%#08x\\n\", je32_to_cpu(node.i.version));\n\t\tprintk(JFFS2_DBG \"mode:\\t%#08x\\n\", node.i.mode.m);\n\t\tprintk(JFFS2_DBG \"uid:\\t%#04x\\n\", je16_to_cpu(node.i.uid));\n\t\tprintk(JFFS2_DBG \"gid:\\t%#04x\\n\", je16_to_cpu(node.i.gid));\n\t\tprintk(JFFS2_DBG \"isize:\\t%#08x\\n\", je32_to_cpu(node.i.isize));\n\t\tprintk(JFFS2_DBG \"atime:\\t%#08x\\n\", je32_to_cpu(node.i.atime));\n\t\tprintk(JFFS2_DBG \"mtime:\\t%#08x\\n\", je32_to_cpu(node.i.mtime));\n\t\tprintk(JFFS2_DBG \"ctime:\\t%#08x\\n\", je32_to_cpu(node.i.ctime));\n\t\tprintk(JFFS2_DBG \"offset:\\t%#08x\\n\", je32_to_cpu(node.i.offset));\n\t\tprintk(JFFS2_DBG \"csize:\\t%#08x\\n\", je32_to_cpu(node.i.csize));\n\t\tprintk(JFFS2_DBG \"dsize:\\t%#08x\\n\", je32_to_cpu(node.i.dsize));\n\t\tprintk(JFFS2_DBG \"compr:\\t%#02x\\n\", node.i.compr);\n\t\tprintk(JFFS2_DBG \"usercompr:\\t%#02x\\n\", node.i.usercompr);\n\t\tprintk(JFFS2_DBG \"flags:\\t%#04x\\n\", je16_to_cpu(node.i.flags));\n\t\tprintk(JFFS2_DBG \"data_crc:\\t%#08x\\n\", je32_to_cpu(node.i.data_crc));\n\t\tprintk(JFFS2_DBG \"node_crc:\\t%#08x\\n\", je32_to_cpu(node.i.node_crc));\n\n\t\tcrc = crc32(0, &node.i, sizeof(node.i) - 8);\n\t\tif (crc != je32_to_cpu(node.i.node_crc)) {\n\t\t\tJFFS2_ERROR(\"wrong node header CRC.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase JFFS2_NODETYPE_DIRENT:\n\n\t\tprintk(JFFS2_DBG \"the node is dirent node\\n\");\n\t\tprintk(JFFS2_DBG \"pino:\\t%#08x\\n\", je32_to_cpu(node.d.pino));\n\t\tprintk(JFFS2_DBG \"version:\\t%#08x\\n\", je32_to_cpu(node.d.version));\n\t\tprintk(JFFS2_DBG \"ino:\\t%#08x\\n\", je32_to_cpu(node.d.ino));\n\t\tprintk(JFFS2_DBG \"mctime:\\t%#08x\\n\", je32_to_cpu(node.d.mctime));\n\t\tprintk(JFFS2_DBG \"nsize:\\t%#02x\\n\", node.d.nsize);\n\t\tprintk(JFFS2_DBG \"type:\\t%#02x\\n\", node.d.type);\n\t\tprintk(JFFS2_DBG \"node_crc:\\t%#08x\\n\", je32_to_cpu(node.d.node_crc));\n\t\tprintk(JFFS2_DBG \"name_crc:\\t%#08x\\n\", je32_to_cpu(node.d.name_crc));\n\n\t\tnode.d.name[node.d.nsize] = '\\0';\n\t\tprintk(JFFS2_DBG \"name:\\t\\\"%s\\\"\\n\", node.d.name);\n\n\t\tcrc = crc32(0, &node.d, sizeof(node.d) - 8);\n\t\tif (crc != je32_to_cpu(node.d.node_crc)) {\n\t\t\tJFFS2_ERROR(\"wrong node header CRC.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(JFFS2_DBG \"node type is unknown\\n\");\n\t\tbreak;\n\t}\n}\n#"
        }
      },
      {
        "call_info": {
          "callee": "run->inum))",
          "args": [
            "pr_err("
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p(KERN_ERR, \"\\",
          "args": [
            "\", DUMP_",
            "EFIX",
            "FFSET, 32, 1,",
            "(",
            "data, dlen, 0);",
            "reak"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a:\\n\")",
          "args": [
            "print_he"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a size",
          "args": [
            "%d\\n\", dlen);\n\t\tpr",
            "rr(\""
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_typ",
          "args": [
            "%d\\n\",\n\t\t       (i",
            "cpu(dn->compr_type));\n\t\tpr_err(\""
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n->compr_ty",
          "args": [
            "e));\n\t\tpr_err("
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e",
          "args": [
            "%u\\n\", le32_to_cpu",
            "n->size));\n\t\tpr_err(\""
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "(struct inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
          "lines": "2648-2652",
          "snippet": "s_file_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = inode->i_private;\n\treturn nonseekable_open(inode, file);\n}\n\n/**\n * prov",
          "includes": [
            "fs.h\"\n\nstatic DEFIN",
            "ux/random.h>\n#include \"ubi",
            "ux/uaccess.h>\n#include <lin",
            "ux/math64.h>\n#include <lin",
            "ux/debugfs.h>\n#include <lin",
            "ux/module.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\ns_file_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = inode->i_private;\n\treturn nonseekable_open(inode, file);\n}\n\n/**\n * prov"
        }
      },
      {
        "call_info": {
          "callee": "n->size));",
          "args": [
            "pr_err("
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "%s\\n\",\n\t\t       db",
            "key(c, &key, key_buf, DBG_KEY_BUF_LEN));\n\t\tpr_err(\""
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key(c, &key, key",
          "args": [
            "b",
            ", DB",
            "KEY_BUF",
            "EN));\n\t\tpr_err("
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dn->key,",
          "args": [
            "&",
            "y);\n\t\tpr",
            "rr(\""
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->len) - U",
          "args": [
            "IFS_DAT"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\n\t\tbr",
          "args": [
            "ak;"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dent->",
          "args": [
            "ame[",
            ");\n\t\t}\n\t\tpr_c"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "link(struct dentr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
          "lines": "1303-1309",
          "snippet": "ubifs_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct ubifs_inode *ui = ubifs_inode(dentry->d_inode);\n\n\tnd_set_link(nd, ui->data);\n\treturn NULL;\n}\n\nint ubifs_f",
          "includes": [
            "ux/slab.h>\n\nstatic int r",
            "ux/namei.h>\n#include <lin",
            "ux/mount.h>\n#include <lin",
            "ux/aio.h>\n#include <lin",
            "fs.h\"\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nubifs_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct ubifs_inode *ui = ubifs_inode(dentry->d_inode);\n\n\tnd_set_link(nd, ui->data);\n\treturn NULL;\n}\n\nint ubifs_f"
        }
      },
      {
        "call_info": {
          "callee": "name l",
          "args": [
            "ngth, not printing, bad or corrupted node)\");\n\t\telse {"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e",
          "args": [
            "\");\n\n\t\tif (nle"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "ng_exit(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
          "lines": "3101-3104",
          "snippet": "bugging_exit(struct ubifs_info *c)\n{\n\tkfree(c->dbg);\n}",
          "includes": [
            "fs.h\"\n\nstatic DEFIN",
            "ux/random.h>\n#include \"ubi",
            "ux/uaccess.h>\n#include <lin",
            "ux/math64.h>\n#include <lin",
            "ux/debugfs.h>\n#include <lin",
            "ux/module.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nbugging_exit(struct ubifs_info *c)\n{\n\tkfree(c->dbg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "n",
          "args": [
            "%d\\n\", nlen);\n\t\tpr",
            "rr(\""
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "r_input(const char _",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
          "lines": "2718-2733",
          "snippet": "terpret_user_input(const char __user *u, size_t count)\n{\n\tsize_t buf_size;\n\tchar buf[8];\n\n\tbuf_size = min_t(size_t, count, (sizeof(buf) - 1));\n\tif (copy_from_user(buf, u, buf_size))\n\t\treturn -EFAULT;\n\n\tif (buf[0] == '1')\n\t\treturn 1;\n\telse if (buf[0] == '0')\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic ssiz",
          "includes": [
            "fs.h\"\n\nstatic DEFIN",
            "ux/random.h>\n#include \"ubi",
            "ux/uaccess.h>\n#include <lin",
            "ux/math64.h>\n#include <lin",
            "ux/debugfs.h>\n#include <lin",
            "ux/module.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [
            "dentry *dfs_tst_rcvry;\n\nstatic ssiz"
          ],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\ndentry *dfs_tst_rcvry;\n\nstatic ssiz;\n\nterpret_user_input(const char __user *u, size_t count)\n{\n\tsize_t buf_size;\n\tchar buf[8];\n\n\tbuf_size = min_t(size_t, count, (sizeof(buf) - 1));\n\tif (copy_from_user(buf, u, buf_size))\n\t\treturn -EFAULT;\n\n\tif (buf[0] == '1')\n\t\treturn 1;\n\telse if (buf[0] == '0')\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic ssiz"
        }
      },
      {
        "call_info": {
          "callee": "ent->inum))",
          "args": [
            "pr_err("
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "%s\\n\",\n\t\t       db",
            "key(c, &key, key_buf, DBG_KEY_BUF_LEN));\n\t\tpr_err(\""
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key(c, &key, key",
          "args": [
            "b",
            ", DB",
            "KEY_BUF",
            "EN));\n\t\tpr_err("
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dent->ke",
          "args": [
            ",",
            "key);\n\t\tpr",
            "rr(\""
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent->nlen);",
          "args": [
            "key_rea"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a len",
          "args": [
            "%u\\n\", le32_to_cpu",
            "no->data_len));\n\t\tbreak;"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->data_le",
          "args": [
            "));\n\t\tbreak;"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_typ",
          "args": [
            "%#x\\n\",\n\t\t       (i",
            "cpu(ino->compr_type));\n\t\tpr_err(\""
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->compr_t",
          "args": [
            "pe));\n\t\tpr_err("
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr_nam",
          "args": [
            "s    %u\\n\", le32_to_cpu",
            "no->xattr_names));\n\t\tpr_err(\""
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "__copy_xattr_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "512-534",
          "snippet": "static char *__copy_xattr_names(struct ceph_inode_info *ci,\n\t\t\t\tchar *dest)\n{\n\tstruct rb_node *p;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\n\tp = rb_first(&ci->i_xattrs.index);\n\tdout(\"__copy_xattr_names count=%d\\n\", ci->i_xattrs.count);\n\n\twhile (p) {\n\t\txattr = rb_entry(p, struct ceph_inode_xattr, node);\n\t\tmemcpy(dest, xattr->name, xattr->name_len);\n\t\tdest[xattr->name_len] = '\\0';\n\n\t\tdout(\"dest=%s %p (%s) (%d/%d)\\n\", dest, xattr, xattr->name,\n\t\t     xattr->name_len, ci->i_xattrs.names_size);\n\n\t\tdest += xattr->name_len + 1;\n\t\tp = rb_next(p);\n\t}\n\n\treturn dest;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic char *__copy_xattr_names(struct ceph_inode_info *ci,\n\t\t\t\tchar *dest)\n{\n\tstruct rb_node *p;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\n\tp = rb_first(&ci->i_xattrs.index);\n\tdout(\"__copy_xattr_names count=%d\\n\", ci->i_xattrs.count);\n\n\twhile (p) {\n\t\txattr = rb_entry(p, struct ceph_inode_xattr, node);\n\t\tmemcpy(dest, xattr->name, xattr->name_len);\n\t\tdest[xattr->name_len] = '\\0';\n\n\t\tdout(\"dest=%s %p (%s) (%d/%d)\\n\", dest, xattr, xattr->name,\n\t\t     xattr->name_len, ci->i_xattrs.names_size);\n\n\t\tdest += xattr->name_len + 1;\n\t\tp = rb_next(p);\n\t}\n\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "no->xattr_n",
          "args": [
            "mes));\n\t\tpr_err("
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr_siz",
          "args": [
            "%u\\n\", le32_to_cpu",
            "no->xattr_size));\n\t\tpr_err(\""
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_setattr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "742-964",
          "snippet": "int\nxfs_setattr_size(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\txfs_off_t\t\toldsize, newsize;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\tuint\t\t\tlock_flags = 0;\n\tuint\t\t\tcommit_flags = 0;\n\tbool\t\t\tdid_zeroing = false;\n\n\ttrace_xfs_setattr(ip);\n\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn -EROFS;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = inode_change_ok(inode, iattr);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(S_ISREG(ip->i_d.di_mode));\n\tASSERT((iattr->ia_valid & (ATTR_UID|ATTR_GID|ATTR_ATIME|ATTR_ATIME_SET|\n\t\tATTR_MTIME_SET|ATTR_KILL_PRIV|ATTR_TIMES_SET)) == 0);\n\n\toldsize = inode->i_size;\n\tnewsize = iattr->ia_size;\n\n\t/*\n\t * Short circuit the truncate case for zero length files.\n\t */\n\tif (newsize == 0 && oldsize == 0 && ip->i_d.di_nextents == 0) {\n\t\tif (!(iattr->ia_valid & (ATTR_CTIME|ATTR_MTIME)))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Use the regular setattr path to update the timestamps.\n\t\t */\n\t\tiattr->ia_valid &= ~ATTR_SIZE;\n\t\treturn xfs_setattr_nonsize(ip, iattr, 0);\n\t}\n\n\t/*\n\t * Make sure that the dquots are attached to the inode.\n\t */\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * File data changes must be complete before we start the transaction to\n\t * modify the inode.  This needs to be done before joining the inode to\n\t * the transaction because the inode cannot be unlocked once it is a\n\t * part of the transaction.\n\t *\n\t * Start with zeroing any data block beyond EOF that we may expose on\n\t * file extension.\n\t */\n\tif (newsize > oldsize) {\n\t\terror = xfs_zero_eof(ip, newsize, oldsize, &did_zeroing);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We are going to log the inode size change in this transaction so\n\t * any previous writes that are beyond the on disk EOF and the new\n\t * EOF that have not been written out need to be written here.  If we\n\t * do not write the data out, we expose ourselves to the null files\n\t * problem. Note that this includes any block zeroing we did above;\n\t * otherwise those blocks may not be zeroed after a crash.\n\t */\n\tif (newsize > ip->i_d.di_size &&\n\t    (oldsize != ip->i_d.di_size || did_zeroing)) {\n\t\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t\t      ip->i_d.di_size, newsize);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* Now wait for all direct I/O to complete. */\n\tinode_dio_wait(inode);\n\n\t/*\n\t * Do all the page cache truncate work outside the transaction context\n\t * as the \"lock\" order is page lock->log space reservation.  i.e.\n\t * locking pages inside the transaction can ABBA deadlock with\n\t * writeback. We have to do the VFS inode size update before we truncate\n\t * the pagecache, however, to avoid racing with page faults beyond the\n\t * new EOF they are not serialised against truncate operations except by\n\t * page locks and size updates.\n\t *\n\t * Hence we are in a situation where a truncate can fail with ENOMEM\n\t * from xfs_trans_reserve(), but having already truncated the in-memory\n\t * version of the file (i.e. made user visible changes). There's not\n\t * much we can do about this, except to hope that the caller sees ENOMEM\n\t * and retries the truncate operation.\n\t */\n\terror = block_truncate_page(inode->i_mapping, newsize, xfs_get_blocks);\n\tif (error)\n\t\treturn error;\n\ttruncate_setsize(inode, newsize);\n\n\t/*\n\t * The \"we can't serialise against page faults\" pain gets worse.\n\t *\n\t * If the file is mapped then we have to clean the page at the old EOF\n\t * when extending the file. Extending the file can expose changes the\n\t * underlying page mapping (e.g. from beyond EOF to a hole or\n\t * unwritten), and so on the next attempt to write to that page we need\n\t * to remap it for write. i.e. we need .page_mkwrite() to be called.\n\t * Hence we need to clean the page to clean the pte and so a new write\n\t * fault will be triggered appropriately.\n\t *\n\t * If we do it before we change the inode size, then we can race with a\n\t * page fault that maps the page with exactly the same problem. If we do\n\t * it after we change the file size, then a new page fault can come in\n\t * and allocate space before we've run the rest of the truncate\n\t * transaction. That's kinda grotesque, but it's better than have data\n\t * over a hole, and so that's the lesser evil that has been chosen here.\n\t *\n\t * The real solution, however, is to have some mechanism for locking out\n\t * page faults while a truncate is in progress.\n\t */\n\tif (newsize > oldsize && mapping_mapped(VFS_I(ip)->i_mapping)) {\n\t\terror = filemap_write_and_wait_range(\n\t\t\t\tVFS_I(ip)->i_mapping,\n\t\t\t\tround_down(oldsize, PAGE_CACHE_SIZE),\n\t\t\t\tround_up(oldsize, PAGE_CACHE_SIZE) - 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\tcommit_flags = XFS_TRANS_RELEASE_LOG_RES;\n\tlock_flags |= XFS_ILOCK_EXCL;\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Only change the c/mtime if we are changing the size or we are\n\t * explicitly asked to change it.  This handles the semantic difference\n\t * between truncate() and ftruncate() as implemented in the VFS.\n\t *\n\t * The regular truncate() case without ATTR_CTIME and ATTR_MTIME is a\n\t * special case where we need to update the times despite not having\n\t * these flags set.  For all other operations the VFS set these flags\n\t * explicitly if it wants a timestamp update.\n\t */\n\tif (newsize != oldsize &&\n\t    !(iattr->ia_valid & (ATTR_CTIME | ATTR_MTIME))) {\n\t\tiattr->ia_ctime = iattr->ia_mtime =\n\t\t\tcurrent_fs_time(inode->i_sb);\n\t\tiattr->ia_valid |= ATTR_CTIME | ATTR_MTIME;\n\t}\n\n\t/*\n\t * The first thing we do is set the size to new_size permanently on\n\t * disk.  This way we don't have to worry about anyone ever being able\n\t * to look at the data being freed even in the face of a crash.\n\t * What we're getting around here is the case where we free a block, it\n\t * is allocated to another file, it is written to, and then we crash.\n\t * If the new data gets written to the file but the log buffers\n\t * containing the free and reallocation don't, then we'd end up with\n\t * garbage in the blocks being freed.  As long as we make the new size\n\t * permanent before actually freeing any blocks it doesn't matter if\n\t * they get written to.\n\t */\n\tip->i_d.di_size = newsize;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tif (newsize <= oldsize) {\n\t\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, newsize);\n\t\tif (error)\n\t\t\tgoto out_trans_abort;\n\n\t\t/*\n\t\t * Truncated \"down\", so we're removing references to old data\n\t\t * here - if we delay flushing for a long time, we expose\n\t\t * ourselves unduly to the notorious NULL files problem.  So,\n\t\t * we mark this inode and flush it when the file is closed,\n\t\t * and do not wait the usual (long) time for writeout.\n\t\t */\n\t\txfs_iflags_set(ip, XFS_ITRUNCATED);\n\n\t\t/* A truncate down always removes post-EOF blocks. */\n\t\txfs_inode_clear_eofblocks_tag(ip);\n\t}\n\n\tif (iattr->ia_valid & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (iattr->ia_valid & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\nout_unlock:\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\n\treturn error;\n\nout_trans_abort:\n\tcommit_flags |= XFS_TRANS_ABORT;\nout_trans_cancel:\n\txfs_trans_cancel(tp, commit_flags);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_setattr_size(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\txfs_off_t\t\toldsize, newsize;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\tuint\t\t\tlock_flags = 0;\n\tuint\t\t\tcommit_flags = 0;\n\tbool\t\t\tdid_zeroing = false;\n\n\ttrace_xfs_setattr(ip);\n\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn -EROFS;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = inode_change_ok(inode, iattr);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(S_ISREG(ip->i_d.di_mode));\n\tASSERT((iattr->ia_valid & (ATTR_UID|ATTR_GID|ATTR_ATIME|ATTR_ATIME_SET|\n\t\tATTR_MTIME_SET|ATTR_KILL_PRIV|ATTR_TIMES_SET)) == 0);\n\n\toldsize = inode->i_size;\n\tnewsize = iattr->ia_size;\n\n\t/*\n\t * Short circuit the truncate case for zero length files.\n\t */\n\tif (newsize == 0 && oldsize == 0 && ip->i_d.di_nextents == 0) {\n\t\tif (!(iattr->ia_valid & (ATTR_CTIME|ATTR_MTIME)))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Use the regular setattr path to update the timestamps.\n\t\t */\n\t\tiattr->ia_valid &= ~ATTR_SIZE;\n\t\treturn xfs_setattr_nonsize(ip, iattr, 0);\n\t}\n\n\t/*\n\t * Make sure that the dquots are attached to the inode.\n\t */\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * File data changes must be complete before we start the transaction to\n\t * modify the inode.  This needs to be done before joining the inode to\n\t * the transaction because the inode cannot be unlocked once it is a\n\t * part of the transaction.\n\t *\n\t * Start with zeroing any data block beyond EOF that we may expose on\n\t * file extension.\n\t */\n\tif (newsize > oldsize) {\n\t\terror = xfs_zero_eof(ip, newsize, oldsize, &did_zeroing);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We are going to log the inode size change in this transaction so\n\t * any previous writes that are beyond the on disk EOF and the new\n\t * EOF that have not been written out need to be written here.  If we\n\t * do not write the data out, we expose ourselves to the null files\n\t * problem. Note that this includes any block zeroing we did above;\n\t * otherwise those blocks may not be zeroed after a crash.\n\t */\n\tif (newsize > ip->i_d.di_size &&\n\t    (oldsize != ip->i_d.di_size || did_zeroing)) {\n\t\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t\t      ip->i_d.di_size, newsize);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* Now wait for all direct I/O to complete. */\n\tinode_dio_wait(inode);\n\n\t/*\n\t * Do all the page cache truncate work outside the transaction context\n\t * as the \"lock\" order is page lock->log space reservation.  i.e.\n\t * locking pages inside the transaction can ABBA deadlock with\n\t * writeback. We have to do the VFS inode size update before we truncate\n\t * the pagecache, however, to avoid racing with page faults beyond the\n\t * new EOF they are not serialised against truncate operations except by\n\t * page locks and size updates.\n\t *\n\t * Hence we are in a situation where a truncate can fail with ENOMEM\n\t * from xfs_trans_reserve(), but having already truncated the in-memory\n\t * version of the file (i.e. made user visible changes). There's not\n\t * much we can do about this, except to hope that the caller sees ENOMEM\n\t * and retries the truncate operation.\n\t */\n\terror = block_truncate_page(inode->i_mapping, newsize, xfs_get_blocks);\n\tif (error)\n\t\treturn error;\n\ttruncate_setsize(inode, newsize);\n\n\t/*\n\t * The \"we can't serialise against page faults\" pain gets worse.\n\t *\n\t * If the file is mapped then we have to clean the page at the old EOF\n\t * when extending the file. Extending the file can expose changes the\n\t * underlying page mapping (e.g. from beyond EOF to a hole or\n\t * unwritten), and so on the next attempt to write to that page we need\n\t * to remap it for write. i.e. we need .page_mkwrite() to be called.\n\t * Hence we need to clean the page to clean the pte and so a new write\n\t * fault will be triggered appropriately.\n\t *\n\t * If we do it before we change the inode size, then we can race with a\n\t * page fault that maps the page with exactly the same problem. If we do\n\t * it after we change the file size, then a new page fault can come in\n\t * and allocate space before we've run the rest of the truncate\n\t * transaction. That's kinda grotesque, but it's better than have data\n\t * over a hole, and so that's the lesser evil that has been chosen here.\n\t *\n\t * The real solution, however, is to have some mechanism for locking out\n\t * page faults while a truncate is in progress.\n\t */\n\tif (newsize > oldsize && mapping_mapped(VFS_I(ip)->i_mapping)) {\n\t\terror = filemap_write_and_wait_range(\n\t\t\t\tVFS_I(ip)->i_mapping,\n\t\t\t\tround_down(oldsize, PAGE_CACHE_SIZE),\n\t\t\t\tround_up(oldsize, PAGE_CACHE_SIZE) - 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\tcommit_flags = XFS_TRANS_RELEASE_LOG_RES;\n\tlock_flags |= XFS_ILOCK_EXCL;\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Only change the c/mtime if we are changing the size or we are\n\t * explicitly asked to change it.  This handles the semantic difference\n\t * between truncate() and ftruncate() as implemented in the VFS.\n\t *\n\t * The regular truncate() case without ATTR_CTIME and ATTR_MTIME is a\n\t * special case where we need to update the times despite not having\n\t * these flags set.  For all other operations the VFS set these flags\n\t * explicitly if it wants a timestamp update.\n\t */\n\tif (newsize != oldsize &&\n\t    !(iattr->ia_valid & (ATTR_CTIME | ATTR_MTIME))) {\n\t\tiattr->ia_ctime = iattr->ia_mtime =\n\t\t\tcurrent_fs_time(inode->i_sb);\n\t\tiattr->ia_valid |= ATTR_CTIME | ATTR_MTIME;\n\t}\n\n\t/*\n\t * The first thing we do is set the size to new_size permanently on\n\t * disk.  This way we don't have to worry about anyone ever being able\n\t * to look at the data being freed even in the face of a crash.\n\t * What we're getting around here is the case where we free a block, it\n\t * is allocated to another file, it is written to, and then we crash.\n\t * If the new data gets written to the file but the log buffers\n\t * containing the free and reallocation don't, then we'd end up with\n\t * garbage in the blocks being freed.  As long as we make the new size\n\t * permanent before actually freeing any blocks it doesn't matter if\n\t * they get written to.\n\t */\n\tip->i_d.di_size = newsize;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tif (newsize <= oldsize) {\n\t\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, newsize);\n\t\tif (error)\n\t\t\tgoto out_trans_abort;\n\n\t\t/*\n\t\t * Truncated \"down\", so we're removing references to old data\n\t\t * here - if we delay flushing for a long time, we expose\n\t\t * ourselves unduly to the notorious NULL files problem.  So,\n\t\t * we mark this inode and flush it when the file is closed,\n\t\t * and do not wait the usual (long) time for writeout.\n\t\t */\n\t\txfs_iflags_set(ip, XFS_ITRUNCATED);\n\n\t\t/* A truncate down always removes post-EOF blocks. */\n\t\txfs_inode_clear_eofblocks_tag(ip);\n\t}\n\n\tif (iattr->ia_valid & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (iattr->ia_valid & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\nout_unlock:\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\n\treturn error;\n\nout_trans_abort:\n\tcommit_flags |= XFS_TRANS_ABORT;\nout_trans_cancel:\n\txfs_trans_cancel(tp, commit_flags);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "no->xattr_s",
          "args": [
            "ze));\n\t\tpr_err("
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr_cnt",
          "args": [
            "%u\\n\", le32_to_cpu",
            "no->xattr_cnt));\n\t\tpr_err(\""
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->xattr_c",
          "args": [
            "t));\n\t\tpr_err("
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gs",
          "args": [
            "%#x\\n\", le32_to_cpu",
            "no->flags));\n\t\tpr_err(\""
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "do_thread_regset_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1607-1612",
          "snippet": "static void do_thread_regset_writeback(struct task_struct *task,\n\t\t\t\t       const struct user_regset *regset)\n{\n\tif (regset->writeback)\n\t\tregset->writeback(task, regset, 1);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void do_thread_regset_writeback(struct task_struct *task,\n\t\t\t\t       const struct user_regset *regset)\n{\n\tif (regset->writeback)\n\t\tregset->writeback(task, regset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "no->flags))",
          "args": [
            "pr_err("
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->mode));",
          "args": [
            "pr_err("
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "%u\\n\", le32_to_cpu",
            "no->gid));\n\t\tpr_err(\""
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->gid));",
          "args": [
            "pr_err("
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "%u\\n\", le32_to_cpu",
            "no->uid));\n\t\tpr_err(\""
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->uid));",
          "args": [
            "pr_err("
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "me",
          "args": [
            "%lld.%u\\n\",\n\t\t       (l",
            "64_to_cpu(ino->ctime_sec),\n\t\t       le",
            "no->ctime_nsec));\n\t\tpr_err(\""
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "hes_name(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
          "lines": "809-855",
          "snippet": "llible_matches_name(struct ubifs_info *c,\n\t\t\t\t struct ubifs_zbranch *zbr,\n\t\t\t\t const struct qstr *nm)\n{\n\tstruct ubifs_dent_node *dent;\n\tint nlen, err;\n\n\t/* If possible, match against the dent in the leaf node cache */\n\tif (!zbr->leaf) {\n\t\tdent = kmalloc(zbr->len, GFP_NOFS);\n\t\tif (!dent)\n\t\t\treturn -ENOMEM;\n\n\t\terr = fallible_read_node(c, &zbr->key, zbr, dent);\n\t\tif (err < 0)\n\t\t\tgoto out_free;\n\t\tif (err == 0) {\n\t\t\t/* The node was not present */\n\t\t\terr = NOT_ON_MEDIA;\n\t\t\tgoto out_free;\n\t\t}\n\t\tubifs_assert(err == 1);\n\n\t\terr = lnc_add_directly(c, zbr, dent);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t} else\n\t\tdent = zbr->leaf;\n\n\tnlen = le16_to_cpu(dent->nlen);\n\terr = memcmp(dent->name, nm->name, min_t(int, nlen, nm->len));\n\tif (err == 0) {\n\t\tif (nlen == nm->len)\n\t\t\treturn NAME_MATCHES;\n\t\telse if (nlen < nm->len)\n\t\t\treturn NAME_LESS;\n\t\telse\n\t\t\treturn NAME_GREATER;\n\t} else if (err < 0)\n\t\treturn NAME_LESS;\n\telse\n\t\treturn NAME_GREATER;\n\nout_free:\n\tkfree(dent);\n\treturn err;\n}\n\n/**\n * fall",
          "includes": [
            "fs.h\"\n\n/*\n * Return",
            "ux/slab.h>\n#include \"ubi",
            "ux/crc32.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nllible_matches_name(struct ubifs_info *c,\n\t\t\t\t struct ubifs_zbranch *zbr,\n\t\t\t\t const struct qstr *nm)\n{\n\tstruct ubifs_dent_node *dent;\n\tint nlen, err;\n\n\t/* If possible, match against the dent in the leaf node cache */\n\tif (!zbr->leaf) {\n\t\tdent = kmalloc(zbr->len, GFP_NOFS);\n\t\tif (!dent)\n\t\t\treturn -ENOMEM;\n\n\t\terr = fallible_read_node(c, &zbr->key, zbr, dent);\n\t\tif (err < 0)\n\t\t\tgoto out_free;\n\t\tif (err == 0) {\n\t\t\t/* The node was not present */\n\t\t\terr = NOT_ON_MEDIA;\n\t\t\tgoto out_free;\n\t\t}\n\t\tubifs_assert(err == 1);\n\n\t\terr = lnc_add_directly(c, zbr, dent);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t} else\n\t\tdent = zbr->leaf;\n\n\tnlen = le16_to_cpu(dent->nlen);\n\terr = memcmp(dent->name, nm->name, min_t(int, nlen, nm->len));\n\tif (err == 0) {\n\t\tif (nlen == nm->len)\n\t\t\treturn NAME_MATCHES;\n\t\telse if (nlen < nm->len)\n\t\t\treturn NAME_LESS;\n\t\telse\n\t\t\treturn NAME_GREATER;\n\t} else if (err < 0)\n\t\treturn NAME_LESS;\n\telse\n\t\treturn NAME_GREATER;\n\nout_free:\n\tkfree(dent);\n\treturn err;\n}\n\n/**\n * fall"
        }
      },
      {
        "call_info": {
          "callee": "no->ctime_n",
          "args": [
            "ec));\n\t\tpr_err("
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->ctime_s",
          "args": [
            "c),\n\t\t       l"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->mtime_n",
          "args": [
            "ec));\n\t\tpr_err("
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->mtime_s",
          "args": [
            "c),\n\t\t       l"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->atime_n",
          "args": [
            "ec));\n\t\tpr_err("
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->atime_s",
          "args": [
            "c),\n\t\t       l"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->nlink))",
          "args": [
            "pr_err("
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->size));",
          "args": [
            "pr_err("
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "at_sqn",
          "args": [
            "m    %llu\\n\",\n\t\t       (u",
            "g long)le64_to_cpu(ino->creat_sqnum));\n\t\tpr_err(\""
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->creat_s",
          "args": [
            "num));\n\t\tpr_err("
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "%s\\n\",\n\t\t       db",
            "key(c, &key, key_buf, DBG_KEY_BUF_LEN));\n\t\tpr_err(\""
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key(c, &key, key",
          "args": [
            "b",
            ", DB",
            "KEY_BUF",
            "EN));\n\t\tpr_err("
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ino->key",
          "args": [
            "ey);\n\t\tpr",
            "rr(\""
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad",
          "args": [
            "%u\\n\", le32_to_cpu",
            "ef->jhead));\n\t\tbreak;"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "_inl_heads(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
          "lines": "966-983",
          "snippet": "over_inl_heads(struct ubifs_info *c, void *sbuf)\n{\n\tint err;\n\n\tubifs_assert(!c->ro_mount || c->remounting_rw);\n\n\tdbg_rcvry(\"checking index head at %d:%d\", c->ihead_lnum, c->ihead_offs);\n\terr = recover_head(c, c->ihead_lnum, c->ihead_offs, sbuf);\n\tif (err)\n\t\treturn err;\n\n\tdbg_rcvry(\"checking LPT head at %d:%d\", c->nhead_lnum, c->nhead_offs);\n\terr = recover_head(c, c->nhead_lnum, c->nhead_offs, sbuf);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n/**\n * clea",
          "includes": [
            "fs.h\"\n\n/**\n * is_em",
            "ux/slab.h>\n#include \"ubi",
            "ux/crc32.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nover_inl_heads(struct ubifs_info *c, void *sbuf)\n{\n\tint err;\n\n\tubifs_assert(!c->ro_mount || c->remounting_rw);\n\n\tdbg_rcvry(\"checking index head at %d:%d\", c->ihead_lnum, c->ihead_offs);\n\terr = recover_head(c, c->ihead_lnum, c->ihead_offs, sbuf);\n\tif (err)\n\t\treturn err;\n\n\tdbg_rcvry(\"checking LPT head at %d:%d\", c->nhead_lnum, c->nhead_offs);\n\terr = recover_head(c, c->nhead_lnum, c->nhead_offs, sbuf);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n/**\n * clea"
        }
      },
      {
        "call_info": {
          "callee": "ef->jhead))",
          "args": [
            "break;"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef->offs));",
          "args": [
            "pr_err("
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef->lnum));",
          "args": [
            "pr_err("
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "al_dar",
          "args": [
            "%llu\\n\",\n\t\t       (u",
            "g long)le64_to_cpu(mst->total_dark));\n\t\tbreak;"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->total_d",
          "args": [
            "rk));\n\t\tbreak;"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "al_dea",
          "args": [
            "%llu\\n\",\n\t\t       (u",
            "g long)le64_to_cpu(mst->total_dead));\n\t\tpr_err(\""
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->total_d",
          "args": [
            "ad));\n\t\tpr_err("
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "al_use",
          "args": [
            "%llu\\n\",\n\t\t       (u",
            "g long)le64_to_cpu(mst->total_used));\n\t\tpr_err(\""
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->total_u",
          "args": [
            "ed));\n\t\tpr_err("
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "al_dir",
          "args": [
            "y    %llu\\n\",\n\t\t       (u",
            "g long)le64_to_cpu(mst->total_dirty));\n\t\tpr_err(\""
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "st->total_d",
          "args": [
            "rty));\n\t\tpr_err("
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "al_fre",
          "args": [
            "%llu\\n\",\n\t\t       (u",
            "g long)le64_to_cpu(mst->total_free));\n\t\tpr_err(\""
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_local_free_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "813-870",
          "snippet": "static int ocfs2_local_free_info(struct super_block *sb, int type)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_quota_chunk *chunk;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint mark_clean = 1, len;\n\tint status;\n\n\tiput(oinfo->dqi_gqinode);\n\tocfs2_simple_drop_lockres(OCFS2_SB(sb), &oinfo->dqi_gqlock);\n\tocfs2_lock_res_free(&oinfo->dqi_gqlock);\n\tlist_for_each_entry(chunk, &oinfo->dqi_chunk, qc_chunk) {\n\t\tdchunk = (struct ocfs2_local_disk_chunk *)\n\t\t\t\t\t(chunk->qc_headerbh->b_data);\n\t\tif (chunk->qc_num < oinfo->dqi_chunks - 1) {\n\t\t\tlen = ol_chunk_entries(sb);\n\t\t} else {\n\t\t\tlen = (oinfo->dqi_blocks -\n\t\t\t       ol_quota_chunk_block(sb, chunk->qc_num) - 1)\n\t\t\t      * ol_quota_entries_per_block(sb);\n\t\t}\n\t\t/* Not all entries free? Bug! */\n\t\tif (le32_to_cpu(dchunk->dqc_free) != len) {\n\t\t\tmlog(ML_ERROR, \"releasing quota file with used \"\n\t\t\t\t\t\"entries (type=%d)\\n\", type);\n\t\t\tmark_clean = 0;\n\t\t}\n\t}\n\tocfs2_release_local_quota_bitmaps(&oinfo->dqi_chunk);\n\n\t/* dqonoff_mutex protects us against racing with recovery thread... */\n\tif (oinfo->dqi_rec) {\n\t\tocfs2_free_quota_recovery(oinfo->dqi_rec);\n\t\tmark_clean = 0;\n\t}\n\n\tif (!mark_clean)\n\t\tgoto out;\n\n\t/* Mark local file as clean */\n\toinfo->dqi_flags |= OLQF_CLEAN;\n\tstatus = ocfs2_modify_bh(sb_dqopt(sb)->files[type],\n\t\t\t\t oinfo->dqi_libh,\n\t\t\t\t olq_update_info,\n\t\t\t\t info);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\nout:\n\tocfs2_inode_unlock(sb_dqopt(sb)->files[type], 1);\n\tbrelse(oinfo->dqi_libh);\n\tbrelse(oinfo->dqi_lqi_bh);\n\tkfree(oinfo);\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_local_free_info(struct super_block *sb, int type)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_quota_chunk *chunk;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint mark_clean = 1, len;\n\tint status;\n\n\tiput(oinfo->dqi_gqinode);\n\tocfs2_simple_drop_lockres(OCFS2_SB(sb), &oinfo->dqi_gqlock);\n\tocfs2_lock_res_free(&oinfo->dqi_gqlock);\n\tlist_for_each_entry(chunk, &oinfo->dqi_chunk, qc_chunk) {\n\t\tdchunk = (struct ocfs2_local_disk_chunk *)\n\t\t\t\t\t(chunk->qc_headerbh->b_data);\n\t\tif (chunk->qc_num < oinfo->dqi_chunks - 1) {\n\t\t\tlen = ol_chunk_entries(sb);\n\t\t} else {\n\t\t\tlen = (oinfo->dqi_blocks -\n\t\t\t       ol_quota_chunk_block(sb, chunk->qc_num) - 1)\n\t\t\t      * ol_quota_entries_per_block(sb);\n\t\t}\n\t\t/* Not all entries free? Bug! */\n\t\tif (le32_to_cpu(dchunk->dqc_free) != len) {\n\t\t\tmlog(ML_ERROR, \"releasing quota file with used \"\n\t\t\t\t\t\"entries (type=%d)\\n\", type);\n\t\t\tmark_clean = 0;\n\t\t}\n\t}\n\tocfs2_release_local_quota_bitmaps(&oinfo->dqi_chunk);\n\n\t/* dqonoff_mutex protects us against racing with recovery thread... */\n\tif (oinfo->dqi_rec) {\n\t\tocfs2_free_quota_recovery(oinfo->dqi_rec);\n\t\tmark_clean = 0;\n\t}\n\n\tif (!mark_clean)\n\t\tgoto out;\n\n\t/* Mark local file as clean */\n\toinfo->dqi_flags |= OLQF_CLEAN;\n\tstatus = ocfs2_modify_bh(sb_dqopt(sb)->files[type],\n\t\t\t\t oinfo->dqi_libh,\n\t\t\t\t olq_update_info,\n\t\t\t\t info);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\nout:\n\tocfs2_inode_unlock(sb_dqopt(sb)->files[type], 1);\n\tbrelse(oinfo->dqi_libh);\n\tbrelse(oinfo->dqi_lqi_bh);\n\tkfree(oinfo);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "st->total_f",
          "args": [
            "ee));\n\t\tpr_err("
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_lebs",
          "args": [
            "%u\\n\", le32_to_cpu",
            "st->idx_lebs));\n\t\tpr_err(\""
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->idx_leb",
          "args": [
            "));\n\t\tpr_err("
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ty_leb",
          "args": [
            "%u\\n\", le32_to_cpu",
            "st->empty_lebs));\n\t\tpr_err(\""
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->empty_l",
          "args": [
            "bs));\n\t\tpr_err("
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_cnt",
          "args": [
            "%u\\n\", le32_to_cpu",
            "st->leb_cnt));\n\t\tpr_err(\""
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->leb_cnt",
          "args": [
            ");\n\t\tpr_err("
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "an_lnu",
          "args": [
            "%u\\n\", le32_to_cpu",
            "st->lscan_lnum));\n\t\tpr_err(\""
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->lscan_l",
          "args": [
            "um));\n\t\tpr_err("
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ve_off",
          "args": [
            "%u\\n\", le32_to_cpu",
            "st->lsave_offs));\n\t\tpr_err(\""
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->lsave_o",
          "args": [
            "fs));\n\t\tpr_err("
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ve_lnu",
          "args": [
            "%u\\n\", le32_to_cpu",
            "st->lsave_lnum));\n\t\tpr_err(\""
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->lsave_l",
          "args": [
            "um));\n\t\tpr_err("
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_offs",
          "args": [
            "%u\\n\", le32_to_cpu",
            "st->ltab_offs));\n\t\tpr_err(\""
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "get_usb_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "294-302",
          "snippet": "static inline void *get_usb_offset(struct ufs_sb_private_info *uspi,\n\t\t\t\t   unsigned int offset)\n{\n\tunsigned int index;\n\t\n\tindex = offset >> uspi->s_fshift;\n\toffset &= ~uspi->s_fmask;\n\treturn uspi->s_ubh.bh[index]->b_data + offset;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);",
            "extern struct page *ufs_get_locked_page(struct address_space *mapping,\n\t\t\t\t\tpgoff_t index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\nextern struct page *ufs_get_locked_page(struct address_space *mapping,\n\t\t\t\t\tpgoff_t index);\n\nstatic inline void *get_usb_offset(struct ufs_sb_private_info *uspi,\n\t\t\t\t   unsigned int offset)\n{\n\tunsigned int index;\n\t\n\tindex = offset >> uspi->s_fshift;\n\toffset &= ~uspi->s_fmask;\n\treturn uspi->s_ubh.bh[index]->b_data + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "st->ltab_of",
          "args": [
            "s));\n\t\tpr_err("
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_lnum",
          "args": [
            "%u\\n\", le32_to_cpu",
            "st->ltab_lnum));\n\t\tpr_err(\""
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "b_lnum(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/lpt_commit.c",
          "lines": "1630-1693",
          "snippet": "g_check_ltab_lnum(struct ubifs_info *c, int lnum)\n{\n\tint err, len = c->leb_size, dirty = 0, node_type, node_num, node_len;\n\tint ret;\n\tvoid *buf, *p;\n\n\tif (!dbg_is_chk_lprops(c))\n\t\treturn 0;\n\n\tbuf = p = __vmalloc(c->leb_size, GFP_NOFS, PAGE_KERNEL);\n\tif (!buf) {\n\t\tubifs_err(\"cannot allocate memory for ltab checking\");\n\t\treturn 0;\n\t}\n\n\tdbg_lp(\"LEB %d\", lnum);\n\n\terr = ubifs_leb_read(c, lnum, buf, 0, c->leb_size, 1);\n\tif (err)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tif (!is_a_node(c, p, len)) {\n\t\t\tint i, pad_len;\n\n\t\t\tpad_len = get_pad_len(c, p, len);\n\t\t\tif (pad_len) {\n\t\t\t\tp += pad_len;\n\t\t\t\tlen -= pad_len;\n\t\t\t\tdirty += pad_len;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!dbg_is_all_ff(p, len)) {\n\t\t\t\tubifs_err(\"invalid empty space in LEB %d at %d\",\n\t\t\t\t\t  lnum, c->leb_size - len);\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t\ti = lnum - c->lpt_first;\n\t\t\tif (len != c->ltab[i].free) {\n\t\t\t\tubifs_err(\"invalid free space in LEB %d (free %d, expected %d)\",\n\t\t\t\t\t  lnum, len, c->ltab[i].free);\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t\tif (dirty != c->ltab[i].dirty) {\n\t\t\t\tubifs_err(\"invalid dirty space in LEB %d (dirty %d, expected %d)\",\n\t\t\t\t\t  lnum, dirty, c->ltab[i].dirty);\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\tnode_type = get_lpt_node_type(c, p, &node_num);\n\t\tnode_len = get_lpt_node_len(c, node_type);\n\t\tret = dbg_is_node_dirty(c, node_type, lnum, c->leb_size - len);\n\t\tif (ret == 1)\n\t\t\tdirty += node_len;\n\t\tp += node_len;\n\t\tlen -= node_len;\n\t}\n\n\terr = 0;\nout:\n\tvfree(buf);\n\treturn err;\n}\n\n/**\n * dbg_",
          "includes": [
            "fs.h\"\n\nstatic int d",
            "ux/random.h>\n#include \"ubi",
            "ux/slab.h>\n#include <lin",
            "ux/crc16.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic int d\nux/random.h>\n#include \"ubi\nux/slab.h>\n#include <lin\nux/crc16.h>\n#include <lin\n\ng_check_ltab_lnum(struct ubifs_info *c, int lnum)\n{\n\tint err, len = c->leb_size, dirty = 0, node_type, node_num, node_len;\n\tint ret;\n\tvoid *buf, *p;\n\n\tif (!dbg_is_chk_lprops(c))\n\t\treturn 0;\n\n\tbuf = p = __vmalloc(c->leb_size, GFP_NOFS, PAGE_KERNEL);\n\tif (!buf) {\n\t\tubifs_err(\"cannot allocate memory for ltab checking\");\n\t\treturn 0;\n\t}\n\n\tdbg_lp(\"LEB %d\", lnum);\n\n\terr = ubifs_leb_read(c, lnum, buf, 0, c->leb_size, 1);\n\tif (err)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tif (!is_a_node(c, p, len)) {\n\t\t\tint i, pad_len;\n\n\t\t\tpad_len = get_pad_len(c, p, len);\n\t\t\tif (pad_len) {\n\t\t\t\tp += pad_len;\n\t\t\t\tlen -= pad_len;\n\t\t\t\tdirty += pad_len;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!dbg_is_all_ff(p, len)) {\n\t\t\t\tubifs_err(\"invalid empty space in LEB %d at %d\",\n\t\t\t\t\t  lnum, c->leb_size - len);\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t\ti = lnum - c->lpt_first;\n\t\t\tif (len != c->ltab[i].free) {\n\t\t\t\tubifs_err(\"invalid free space in LEB %d (free %d, expected %d)\",\n\t\t\t\t\t  lnum, len, c->ltab[i].free);\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t\tif (dirty != c->ltab[i].dirty) {\n\t\t\t\tubifs_err(\"invalid dirty space in LEB %d (dirty %d, expected %d)\",\n\t\t\t\t\t  lnum, dirty, c->ltab[i].dirty);\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\tnode_type = get_lpt_node_type(c, p, &node_num);\n\t\tnode_len = get_lpt_node_len(c, node_type);\n\t\tret = dbg_is_node_dirty(c, node_type, lnum, c->leb_size - len);\n\t\tif (ret == 1)\n\t\t\tdirty += node_len;\n\t\tp += node_len;\n\t\tlen -= node_len;\n\t}\n\n\terr = 0;\nout:\n\tvfree(buf);\n\treturn err;\n}\n\n/**\n * dbg_"
        }
      },
      {
        "call_info": {
          "callee": "st->ltab_ln",
          "args": [
            "m));\n\t\tpr_err("
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad_off",
          "args": [
            "%u\\n\", le32_to_cpu",
            "st->nhead_offs));\n\t\tpr_err(\""
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sb2_bad_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "456-461",
          "snippet": "static int nilfs_sb2_bad_offset(struct nilfs_super_block *sbp, u64 offset)\n{\n\treturn offset < ((le64_to_cpu(sbp->s_nsegments) *\n\t\t\t  le32_to_cpu(sbp->s_blocks_per_segment)) <<\n\t\t\t (le32_to_cpu(sbp->s_log_block_size) + 10));\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_valid_sb(struct nilfs_super_block *sbp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_valid_sb(struct nilfs_super_block *sbp);\n\nstatic int nilfs_sb2_bad_offset(struct nilfs_super_block *sbp, u64 offset)\n{\n\treturn offset < ((le64_to_cpu(sbp->s_nsegments) *\n\t\t\t  le32_to_cpu(sbp->s_blocks_per_segment)) <<\n\t\t\t (le32_to_cpu(sbp->s_log_block_size) + 10));\n}"
        }
      },
      {
        "call_info": {
          "callee": "st->nhead_o",
          "args": [
            "fs));\n\t\tpr_err("
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad_lnu",
          "args": [
            "%u\\n\", le32_to_cpu",
            "st->nhead_lnum));\n\t\tpr_err(\""
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->nhead_l",
          "args": [
            "um));\n\t\tpr_err("
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_offs",
          "args": [
            "%u\\n\", le32_to_cpu",
            "st->lpt_offs));\n\t\tpr_err(\""
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_max_file_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "591-636",
          "snippet": "static unsigned long long ocfs2_max_file_offset(unsigned int bbits,\n\t\t\t\t\t\tunsigned int cbits)\n{\n\tunsigned int bytes = 1 << cbits;\n\tunsigned int trim = bytes;\n\tunsigned int bitshift = 32;\n\n\t/*\n\t * i_size and all block offsets in ocfs2 are always 64 bits\n\t * wide. i_clusters is 32 bits, in cluster-sized units. So on\n\t * 64 bit platforms, cluster size will be the limiting factor.\n\t */\n\n#if BITS_PER_LONG == 32\n# if defined(CONFIG_LBDAF)\n\tBUILD_BUG_ON(sizeof(sector_t) != 8);\n\t/*\n\t * We might be limited by page cache size.\n\t */\n\tif (bytes > PAGE_CACHE_SIZE) {\n\t\tbytes = PAGE_CACHE_SIZE;\n\t\ttrim = 1;\n\t\t/*\n\t\t * Shift by 31 here so that we don't get larger than\n\t\t * MAX_LFS_FILESIZE\n\t\t */\n\t\tbitshift = 31;\n\t}\n# else\n\t/*\n\t * We are limited by the size of sector_t. Use block size, as\n\t * that's what we expose to the VFS.\n\t */\n\tbytes = 1 << bbits;\n\ttrim = 1;\n\tbitshift = 31;\n# endif\n#endif\n\n\t/*\n\t * Trim by a whole cluster when we can actually approach the\n\t * on-disk limits. Otherwise we can overflow i_clusters when\n\t * an extent start is at the max offset.\n\t */\n\treturn (((unsigned long long)bytes) << bitshift) - trim;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic unsigned long long ocfs2_max_file_offset(unsigned int bbits,\n\t\t\t\t\t\tunsigned int cbits)\n{\n\tunsigned int bytes = 1 << cbits;\n\tunsigned int trim = bytes;\n\tunsigned int bitshift = 32;\n\n\t/*\n\t * i_size and all block offsets in ocfs2 are always 64 bits\n\t * wide. i_clusters is 32 bits, in cluster-sized units. So on\n\t * 64 bit platforms, cluster size will be the limiting factor.\n\t */\n\n#if BITS_PER_LONG == 32\n# if defined(CONFIG_LBDAF)\n\tBUILD_BUG_ON(sizeof(sector_t) != 8);\n\t/*\n\t * We might be limited by page cache size.\n\t */\n\tif (bytes > PAGE_CACHE_SIZE) {\n\t\tbytes = PAGE_CACHE_SIZE;\n\t\ttrim = 1;\n\t\t/*\n\t\t * Shift by 31 here so that we don't get larger than\n\t\t * MAX_LFS_FILESIZE\n\t\t */\n\t\tbitshift = 31;\n\t}\n# else\n\t/*\n\t * We are limited by the size of sector_t. Use block size, as\n\t * that's what we expose to the VFS.\n\t */\n\tbytes = 1 << bbits;\n\ttrim = 1;\n\tbitshift = 31;\n# endif\n#endif\n\n\t/*\n\t * Trim by a whole cluster when we can actually approach the\n\t * on-disk limits. Otherwise we can overflow i_clusters when\n\t * an extent start is at the max offset.\n\t */\n\treturn (((unsigned long long)bytes) << bitshift) - trim;\n}"
        }
      },
      {
        "call_info": {
          "callee": "st->lpt_off",
          "args": [
            "));\n\t\tpr_err("
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_lnum",
          "args": [
            "%u\\n\", le32_to_cpu",
            "st->lpt_lnum));\n\t\tpr_err(\""
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "g_lnum(const struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/misc.h",
          "lines": "294-301",
          "snippet": "int ubifs_next_log_lnum(const struct ubifs_info *c, int lnum)\n{\n\tlnum += 1;\n\tif (lnum > c->log_last)\n\t\tlnum = UBIFS_LOG_LNUM;\n\n\treturn lnum;\n}\n\n#endif /* _",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "int ubifs_next_log_lnum(const struct ubifs_info *c, int lnum)\n{\n\tlnum += 1;\n\tif (lnum > c->log_last)\n\t\tlnum = UBIFS_LOG_LNUM;\n\n\treturn lnum;\n}\n\n#endif /* _"
        }
      },
      {
        "call_info": {
          "callee": "st->lpt_lnu",
          "args": [
            "));\n\t\tpr_err("
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ex_siz",
          "args": [
            "%llu\\n\",\n\t\t       (u",
            "g long)le64_to_cpu(mst->index_size));\n\t\tpr_err(\""
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->index_s",
          "args": [
            "ze));\n\t\tpr_err("
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->ihead_o",
          "args": [
            "fs));\n\t\tpr_err("
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad_lnu",
          "args": [
            "%u\\n\", le32_to_cpu",
            "st->ihead_lnum));\n\t\tpr_err(\""
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->ihead_l",
          "args": [
            "um));\n\t\tpr_err("
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->gc_lnum",
          "args": [
            ");\n\t\tpr_err("
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_len",
          "args": [
            "%u\\n\", le32_to_cpu",
            "st->root_len));\n\t\tpr_err(\""
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_adjust_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/name.c",
          "lines": "106-113",
          "snippet": "void hpfs_adjust_length(const unsigned char *name, unsigned *len)\n{\n\tif (!*len) return;\n\tif (*len == 1 && name[0] == '.') return;\n\tif (*len == 2 && name[0] == '.' && name[1] == '.') return;\n\twhile (*len && (name[*len - 1] == '.' || name[*len - 1] == ' '))\n\t\t(*len)--;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_adjust_length(const unsigned char *name, unsigned *len)\n{\n\tif (!*len) return;\n\tif (*len == 1 && name[0] == '.') return;\n\tif (*len == 2 && name[0] == '.' && name[1] == '.') return;\n\twhile (*len && (name[*len - 1] == '.' || name[*len - 1] == ' '))\n\t\t(*len)--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "st->root_le",
          "args": [
            "));\n\t\tpr_err("
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_offs",
          "args": [
            "%u\\n\", le32_to_cpu",
            "st->root_offs));\n\t\tpr_err(\""
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xa_bucket_offset_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "1705-1716",
          "snippet": "static void *ocfs2_xa_bucket_offset_pointer(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t    int offset)\n{\n\tstruct ocfs2_xattr_bucket *bucket = loc->xl_storage;\n\tint block, block_offset;\n\n\t/* The header is at the front of the bucket */\n\tblock = offset >> loc->xl_inode->i_sb->s_blocksize_bits;\n\tblock_offset = offset % loc->xl_inode->i_sb->s_blocksize;\n\n\treturn bucket_block(bucket, block) + block_offset;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void *ocfs2_xa_bucket_offset_pointer(struct ocfs2_xa_loc *loc,\n\t\t\t\t\t    int offset)\n{\n\tstruct ocfs2_xattr_bucket *bucket = loc->xl_storage;\n\tint block, block_offset;\n\n\t/* The header is at the front of the bucket */\n\tblock = offset >> loc->xl_inode->i_sb->s_blocksize_bits;\n\tblock_offset = offset % loc->xl_inode->i_sb->s_blocksize;\n\n\treturn bucket_block(bucket, block) + block_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "st->root_of",
          "args": [
            "s));\n\t\tpr_err("
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_lnum",
          "args": [
            "%u\\n\", le32_to_cpu",
            "st->root_lnum));\n\t\tpr_err(\""
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->root_ln",
          "args": [
            "m));\n\t\tpr_err("
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->log_lnu",
          "args": [
            "));\n\t\tpr_err("
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->flags))",
          "args": [
            "pr_err("
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mit nu",
          "args": [
            "ber  %llu\\n\",\n\t\t       (u",
            "g long)le64_to_cpu(mst->cmt_no));\n\t\tpr_err(\""
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->cmt_no)",
          "args": [
            ";\n\t\tpr_err("
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hest_i",
          "args": [
            "um   %llu\\n\",\n\t\t       (u",
            "g long)le64_to_cpu(mst->highest_inum));\n\t\tpr_err(\""
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->highest",
          "args": [
            "inum));\n\t\tpr_err("
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "%pUB\\n\", sup->uuid);",
            "break;"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBQFSDeviceInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "5211-5280",
          "snippet": "int\nCIFSSMBQFSDeviceInfo(const unsigned int xid, struct cifs_tcon *tcon)\n{\n/* level 0x104 SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_DEVICE_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSDeviceInfo\\n\");\nQFSDeviceRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_DEVICE_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFSDeviceInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) <\n\t\t\t  sizeof(FILE_SYSTEM_DEVICE_INFO))\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_DEVICE_INFO *)\n\t\t\t\t(((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tmemcpy(&tcon->fsDevInfo, response_data,\n\t\t\t       sizeof(FILE_SYSTEM_DEVICE_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSDeviceRetry;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBQFSDeviceInfo(const unsigned int xid, struct cifs_tcon *tcon)\n{\n/* level 0x104 SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_DEVICE_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSDeviceInfo\\n\");\nQFSDeviceRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_DEVICE_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFSDeviceInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) <\n\t\t\t  sizeof(FILE_SYSTEM_DEVICE_INFO))\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_DEVICE_INFO *)\n\t\t\t\t(((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tmemcpy(&tcon->fsDevInfo, response_data,\n\t\t\t       sizeof(FILE_SYSTEM_DEVICE_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSDeviceRetry;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "e_gran",
          "args": [
            "%u\\n\", le32_to_cpu",
            "up->time_gran));\n\t\tpr_err(\""
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "receive_grant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "4304-4333",
          "snippet": "static int receive_grant(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\treceive_flags_reply(lkb, ms);\n\tif (is_altmode(lkb))\n\t\tmunge_altmode(lkb, ms);\n\tgrant_lock_pc(r, lkb, ms);\n\tqueue_cast(r, lkb, 0);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic int receive_grant(struct dlm_ls *ls, struct dlm_message *ms)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_rsb *r;\n\tint error;\n\n\terror = find_lkb(ls, ms->m_remid, &lkb);\n\tif (error)\n\t\treturn error;\n\n\tr = lkb->lkb_resource;\n\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_message(lkb, ms);\n\tif (error)\n\t\tgoto out;\n\n\treceive_flags_reply(lkb, ms);\n\tif (is_altmode(lkb))\n\t\tmunge_altmode(lkb, ms);\n\tgrant_lock_pc(r, lkb, ms);\n\tqueue_cast(r, lkb, 0);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up->time_gr",
          "args": [
            "n));\n\t\tpr_err("
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_versi",
          "args": [
            "n    %u\\n\", le32_to_cpu",
            "up->fmt_version));\n\t\tpr_err(\""
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "lvb_to_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "805-815",
          "snippet": "static void lvb_to_version(char *lvb, struct ocfs2_protocol_version *ver)\n{\n\tstruct ocfs2_protocol_version *pv =\n\t\t(struct ocfs2_protocol_version *)lvb;\n\t/*\n\t * ocfs2_protocol_version has two u8 variables, so we don't\n\t * need any endian conversion.\n\t */\n\tver->pv_major = pv->pv_major;\n\tver->pv_minor = pv->pv_minor;\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void lvb_to_version(char *lvb, struct ocfs2_protocol_version *ver)\n{\n\tstruct ocfs2_protocol_version *pv =\n\t\t(struct ocfs2_protocol_version *)lvb;\n\t/*\n\t * ocfs2_protocol_version has two u8 variables, so we don't\n\t * need any endian conversion.\n\t */\n\tver->pv_major = pv->pv_major;\n\tver->pv_minor = pv->pv_minor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up->fmt_ver",
          "args": [
            "ion));\n\t\tpr_err("
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid",
          "args": [
            "%u\\n\", le32_to_cpu",
            "up->rp_gid));\n\t\tpr_err(\""
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "next_tgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "2806-2839",
          "snippet": "static struct tgid_iter next_tgid(struct pid_namespace *ns, struct tgid_iter iter)\n{\n\tstruct pid *pid;\n\n\tif (iter.task)\n\t\tput_task_struct(iter.task);\n\trcu_read_lock();\nretry:\n\titer.task = NULL;\n\tpid = find_ge_pid(iter.tgid, ns);\n\tif (pid) {\n\t\titer.tgid = pid_nr_ns(pid, ns);\n\t\titer.task = pid_task(pid, PIDTYPE_PID);\n\t\t/* What we to know is if the pid we have find is the\n\t\t * pid of a thread_group_leader.  Testing for task\n\t\t * being a thread_group_leader is the obvious thing\n\t\t * todo but there is a window when it fails, due to\n\t\t * the pid transfer logic in de_thread.\n\t\t *\n\t\t * So we perform the straight forward test of seeing\n\t\t * if the pid we have found is the pid of a thread\n\t\t * group leader, and don't worry if the task we have\n\t\t * found doesn't happen to be a thread group leader.\n\t\t * As we don't care in the case of readdir.\n\t\t */\n\t\tif (!iter.task || !has_group_leader_pid(iter.task)) {\n\t\t\titer.tgid += 1;\n\t\t\tgoto retry;\n\t\t}\n\t\tget_task_struct(iter.task);\n\t}\n\trcu_read_unlock();\n\treturn iter;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic struct tgid_iter next_tgid(struct pid_namespace *ns, struct tgid_iter iter)\n{\n\tstruct pid *pid;\n\n\tif (iter.task)\n\t\tput_task_struct(iter.task);\n\trcu_read_lock();\nretry:\n\titer.task = NULL;\n\tpid = find_ge_pid(iter.tgid, ns);\n\tif (pid) {\n\t\titer.tgid = pid_nr_ns(pid, ns);\n\t\titer.task = pid_task(pid, PIDTYPE_PID);\n\t\t/* What we to know is if the pid we have find is the\n\t\t * pid of a thread_group_leader.  Testing for task\n\t\t * being a thread_group_leader is the obvious thing\n\t\t * todo but there is a window when it fails, due to\n\t\t * the pid transfer logic in de_thread.\n\t\t *\n\t\t * So we perform the straight forward test of seeing\n\t\t * if the pid we have found is the pid of a thread\n\t\t * group leader, and don't worry if the task we have\n\t\t * found doesn't happen to be a thread group leader.\n\t\t * As we don't care in the case of readdir.\n\t\t */\n\t\tif (!iter.task || !has_group_leader_pid(iter.task)) {\n\t\t\titer.tgid += 1;\n\t\t\tgoto retry;\n\t\t}\n\t\tget_task_struct(iter.task);\n\t}\n\trcu_read_unlock();\n\treturn iter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up->rp_gid)",
          "args": [
            ";\n\t\tpr_err("
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid",
          "args": [
            "%u\\n\", le32_to_cpu",
            "up->rp_uid));\n\t\tpr_err(\""
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "f_getowner_uids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "237-240",
          "snippet": "static int f_getowner_uids(struct file *filp, unsigned long arg)\n{\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nstatic int f_getowner_uids(struct file *filp, unsigned long arg)\n{\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up->rp_uid)",
          "args": [
            ";\n\t\tpr_err("
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->rp_size",
          "args": [
            ");\n\t\tpr_err("
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ault_c",
          "args": [
            "mpr  %u\\n\",\n\t\t       (i",
            "cpu(sup->default_compr));\n\t\tpr_err(\""
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_set_default_crypt_stat_vals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "787-799",
          "snippet": "static void ecryptfs_set_default_crypt_stat_vals(\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tecryptfs_copy_mount_wide_flags_to_inode_flags(crypt_stat,\n\t\t\t\t\t\t      mount_crypt_stat);\n\tecryptfs_set_default_sizes(crypt_stat);\n\tstrcpy(crypt_stat->cipher, ECRYPTFS_DEFAULT_CIPHER);\n\tcrypt_stat->key_size = ECRYPTFS_DEFAULT_KEY_BYTES;\n\tcrypt_stat->flags &= ~(ECRYPTFS_KEY_VALID);\n\tcrypt_stat->file_version = ECRYPTFS_FILE_VERSION;\n\tcrypt_stat->mount_crypt_stat = mount_crypt_stat;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void ecryptfs_set_default_crypt_stat_vals(\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tecryptfs_copy_mount_wide_flags_to_inode_flags(crypt_stat,\n\t\t\t\t\t\t      mount_crypt_stat);\n\tecryptfs_set_default_sizes(crypt_stat);\n\tstrcpy(crypt_stat->cipher, ECRYPTFS_DEFAULT_CIPHER);\n\tcrypt_stat->key_size = ECRYPTFS_DEFAULT_KEY_BYTES;\n\tcrypt_stat->flags &= ~(ECRYPTFS_KEY_VALID);\n\tcrypt_stat->file_version = ECRYPTFS_FILE_VERSION;\n\tcrypt_stat->mount_crypt_stat = mount_crypt_stat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up->default",
          "args": [
            "compr));\n\t\tpr_err("
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ve_cnt",
          "args": [
            "%u\\n\", le32_to_cpu",
            "up->lsave_cnt));\n\t\tpr_err(\""
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->lsave_c",
          "args": [
            "t));\n\t\tpr_err("
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out",
          "args": [
            "%u\\n\", le32_to_cpu",
            "up->fanout));\n\t\tpr_err(\""
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "time_out_leases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1335-1349",
          "snippet": "static void time_out_leases(struct inode *inode, struct list_head *dispose)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl, *tmp;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list) {\n\t\ttrace_time_out_leases(inode, fl);\n\t\tif (past_time(fl->fl_downgrade_time))\n\t\t\tlease_modify(fl, F_RDLCK, dispose);\n\t\tif (past_time(fl->fl_break_time))\n\t\t\tlease_modify(fl, F_UNLCK, dispose);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void time_out_leases(struct inode *inode, struct list_head *dispose)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl, *tmp;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list) {\n\t\ttrace_time_out_leases(inode, fl);\n\t\tif (past_time(fl->fl_downgrade_time))\n\t\t\tlease_modify(fl, F_RDLCK, dispose);\n\t\tif (past_time(fl->fl_break_time))\n\t\t\tlease_modify(fl, F_UNLCK, dispose);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up->fanout)",
          "args": [
            ";\n\t\tpr_err("
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad_cnt",
          "args": [
            "%u\\n\", le32_to_cpu",
            "up->jhead_cnt));\n\t\tpr_err(\""
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->jhead_c",
          "args": [
            "t));\n\t\tpr_err("
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h_lebs",
          "args": [
            "%u\\n\", le32_to_cpu",
            "up->orph_lebs));\n\t\tpr_err(\""
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->orph_le",
          "args": [
            "s));\n\t\tpr_err("
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_lebs",
          "args": [
            "%u\\n\", le32_to_cpu",
            "up->lpt_lebs));\n\t\tpr_err(\""
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->lpt_leb",
          "args": [
            "));\n\t\tpr_err("
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_lebs",
          "args": [
            "%u\\n\", le32_to_cpu",
            "up->log_lebs));\n\t\tpr_err(\""
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->log_leb",
          "args": [
            "));\n\t\tpr_err("
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_bud_b",
          "args": [
            "tes  %llu\\n\",\n\t\t       (u",
            "g long)le64_to_cpu(sup->max_bud_bytes));\n\t\tpr_err(\""
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->max_bud",
          "args": [
            "bytes));\n\t\tpr_err("
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leb_c",
          "args": [
            "t    %u\\n\", le32_to_cpu",
            "up->max_leb_cnt));\n\t\tpr_err(\""
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->max_leb",
          "args": [
            "cnt));\n\t\tpr_err("
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_cnt",
          "args": [
            "%u\\n\", le32_to_cpu",
            "up->leb_cnt));\n\t\tpr_err(\""
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->leb_cnt",
          "args": [
            ");\n\t\tpr_err("
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->leb_siz",
          "args": [
            "));\n\t\tpr_err("
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_io_si",
          "args": [
            "e    %u\\n\", le32_to_cpu",
            "up->min_io_size));\n\t\tpr_err(\""
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->min_io_",
          "args": [
            "ize));\n\t\tpr_err("
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ce_fix",
          "args": [
            "p    %u\\n\",\n\t\t       !!",
            "& UBIFS_FLG_SPACE_FIXUP));\n\t\tpr_err(\""
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_lpt",
          "args": [
            "%u\\n\",\n\t\t       !!",
            "& UBIFS_FLG_BIGLPT));\n\t\tpr_err(\""
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_fmt",
          "args": [
            "%d (%s)\\n\",\n\t\t       (i",
            "_fmt, get_key_fmt",
            "up->key_fmt));\n\t\tpr_err(\""
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->key_fmt",
          "args": [
            ");\n\t\tpr_err("
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_hash",
          "args": [
            "%d (%s)\\n\",\n\t\t       (i",
            "_hash, get_key_has",
            "sup->key_hash));\n\t\tpr_err(\""
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "1385-1396",
          "snippet": "static struct dentry *__lookup_hash(struct qstr *name,\n\t\tstruct dentry *base, unsigned int flags)\n{\n\tbool need_lookup;\n\tstruct dentry *dentry;\n\n\tdentry = lookup_dcache(name, base, flags, &need_lookup);\n\tif (!need_lookup)\n\t\treturn dentry;\n\n\treturn lookup_real(base->d_inode, dentry, flags);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic struct dentry *__lookup_hash(struct qstr *name,\n\t\tstruct dentry *base, unsigned int flags)\n{\n\tbool need_lookup;\n\tstruct dentry *dentry;\n\n\tdentry = lookup_dcache(name, base, flags, &need_lookup);\n\tif (!need_lookup)\n\t\treturn dentry;\n\n\treturn lookup_real(base->d_inode, dentry, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sup->key_has",
          "args": [
            "));\n\t\tpr_err("
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->flags);",
          "args": [
            "pr_err("
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_len",
          "args": [
            "%u\\n\", le32_to_cpu",
            "ad->pad_len));\n\t\tbreak;"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "valid_arg_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "349-352",
          "snippet": "static bool valid_arg_len(struct linux_binprm *bprm, long len)\n{\n\treturn len <= bprm->p;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic bool valid_arg_len(struct linux_binprm *bprm, long len)\n{\n\treturn len <= bprm->p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad->pad_len",
          "args": [
            ");\n\t\tbreak;"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\n\tswi",
          "args": [
            "ch ("
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_lock);",
          "args": [
            "dump_ch(n"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p(KERN_ERR, \"\"",
          "args": [
            "DUMP_PR",
            "IX",
            "FFSET, 32, 1,",
            "(",
            "UBIFS_CH_SZ",
            "1);\n\t\tretur"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node,",
          "args": [
            "first %zu bytes:\", UBIFS_CH_SZ",
            "print_he"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->magic) !",
          "args": [
            "UBIFS_NO"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nmp_node(const struct ubifs_info *c, const void *node)\n{\n\tint i, n;\n\tunion ubifs_key key;\n\tconst struct ubifs_ch *ch = node;\n\tchar key_buf[DBG_KEY_BUF_LEN];\n\n\t/* If the magic is incorrect, just hexdump the first bytes */\n\tif (le32_to_cpu(ch->magic) != UBIFS_NODE_MAGIC) {\n\t\tpr_err(\"Not a node, first %zu bytes:\", UBIFS_CH_SZ);\n\t\tprint_hex_dump(KERN_ERR, \"\", DUMP_PREFIX_OFFSET, 32, 1,\n\t\t\t       (void *)node, UBIFS_CH_SZ, 1);\n\t\treturn;\n\t}\n\n\tspin_lock(&dbg_lock);\n\tdump_ch(node);\n\n\tswitch (ch->node_type) {\n\tcase UBIFS_PAD_NODE:\n\t{\n\t\tconst struct ubifs_pad_node *pad = node;\n\n\t\tpr_err(\"\\tpad_len        %u\\n\", le32_to_cpu(pad->pad_len));\n\t\tbreak;\n\t}\n\tcase UBIFS_SB_NODE:\n\t{\n\t\tconst struct ubifs_sb_node *sup = node;\n\t\tunsigned int sup_flags = le32_to_cpu(sup->flags);\n\n\t\tpr_err(\"\\tkey_hash       %d (%s)\\n\",\n\t\t       (int)sup->key_hash, get_key_hash(sup->key_hash));\n\t\tpr_err(\"\\tkey_fmt        %d (%s)\\n\",\n\t\t       (int)sup->key_fmt, get_key_fmt(sup->key_fmt));\n\t\tpr_err(\"\\tflags          %#x\\n\", sup_flags);\n\t\tpr_err(\"\\tbig_lpt        %u\\n\",\n\t\t       !!(sup_flags & UBIFS_FLG_BIGLPT));\n\t\tpr_err(\"\\tspace_fixup    %u\\n\",\n\t\t       !!(sup_flags & UBIFS_FLG_SPACE_FIXUP));\n\t\tpr_err(\"\\tmin_io_size    %u\\n\", le32_to_cpu(sup->min_io_size));\n\t\tpr_err(\"\\tleb_size       %u\\n\", le32_to_cpu(sup->leb_size));\n\t\tpr_err(\"\\tleb_cnt        %u\\n\", le32_to_cpu(sup->leb_cnt));\n\t\tpr_err(\"\\tmax_leb_cnt    %u\\n\", le32_to_cpu(sup->max_leb_cnt));\n\t\tpr_err(\"\\tmax_bud_bytes  %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(sup->max_bud_bytes));\n\t\tpr_err(\"\\tlog_lebs       %u\\n\", le32_to_cpu(sup->log_lebs));\n\t\tpr_err(\"\\tlpt_lebs       %u\\n\", le32_to_cpu(sup->lpt_lebs));\n\t\tpr_err(\"\\torph_lebs      %u\\n\", le32_to_cpu(sup->orph_lebs));\n\t\tpr_err(\"\\tjhead_cnt      %u\\n\", le32_to_cpu(sup->jhead_cnt));\n\t\tpr_err(\"\\tfanout         %u\\n\", le32_to_cpu(sup->fanout));\n\t\tpr_err(\"\\tlsave_cnt      %u\\n\", le32_to_cpu(sup->lsave_cnt));\n\t\tpr_err(\"\\tdefault_compr  %u\\n\",\n\t\t       (int)le16_to_cpu(sup->default_compr));\n\t\tpr_err(\"\\trp_size        %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(sup->rp_size));\n\t\tpr_err(\"\\trp_uid         %u\\n\", le32_to_cpu(sup->rp_uid));\n\t\tpr_err(\"\\trp_gid         %u\\n\", le32_to_cpu(sup->rp_gid));\n\t\tpr_err(\"\\tfmt_version    %u\\n\", le32_to_cpu(sup->fmt_version));\n\t\tpr_err(\"\\ttime_gran      %u\\n\", le32_to_cpu(sup->time_gran));\n\t\tpr_err(\"\\tUUID           %pUB\\n\", sup->uuid);\n\t\tbreak;\n\t}\n\tcase UBIFS_MST_NODE:\n\t{\n\t\tconst struct ubifs_mst_node *mst = node;\n\n\t\tpr_err(\"\\thighest_inum   %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(mst->highest_inum));\n\t\tpr_err(\"\\tcommit number  %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(mst->cmt_no));\n\t\tpr_err(\"\\tflags          %#x\\n\", le32_to_cpu(mst->flags));\n\t\tpr_err(\"\\tlog_lnum       %u\\n\", le32_to_cpu(mst->log_lnum));\n\t\tpr_err(\"\\troot_lnum      %u\\n\", le32_to_cpu(mst->root_lnum));\n\t\tpr_err(\"\\troot_offs      %u\\n\", le32_to_cpu(mst->root_offs));\n\t\tpr_err(\"\\troot_len       %u\\n\", le32_to_cpu(mst->root_len));\n\t\tpr_err(\"\\tgc_lnum        %u\\n\", le32_to_cpu(mst->gc_lnum));\n\t\tpr_err(\"\\tihead_lnum     %u\\n\", le32_to_cpu(mst->ihead_lnum));\n\t\tpr_err(\"\\tihead_offs     %u\\n\", le32_to_cpu(mst->ihead_offs));\n\t\tpr_err(\"\\tindex_size     %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(mst->index_size));\n\t\tpr_err(\"\\tlpt_lnum       %u\\n\", le32_to_cpu(mst->lpt_lnum));\n\t\tpr_err(\"\\tlpt_offs       %u\\n\", le32_to_cpu(mst->lpt_offs));\n\t\tpr_err(\"\\tnhead_lnum     %u\\n\", le32_to_cpu(mst->nhead_lnum));\n\t\tpr_err(\"\\tnhead_offs     %u\\n\", le32_to_cpu(mst->nhead_offs));\n\t\tpr_err(\"\\tltab_lnum      %u\\n\", le32_to_cpu(mst->ltab_lnum));\n\t\tpr_err(\"\\tltab_offs      %u\\n\", le32_to_cpu(mst->ltab_offs));\n\t\tpr_err(\"\\tlsave_lnum     %u\\n\", le32_to_cpu(mst->lsave_lnum));\n\t\tpr_err(\"\\tlsave_offs     %u\\n\", le32_to_cpu(mst->lsave_offs));\n\t\tpr_err(\"\\tlscan_lnum     %u\\n\", le32_to_cpu(mst->lscan_lnum));\n\t\tpr_err(\"\\tleb_cnt        %u\\n\", le32_to_cpu(mst->leb_cnt));\n\t\tpr_err(\"\\tempty_lebs     %u\\n\", le32_to_cpu(mst->empty_lebs));\n\t\tpr_err(\"\\tidx_lebs       %u\\n\", le32_to_cpu(mst->idx_lebs));\n\t\tpr_err(\"\\ttotal_free     %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(mst->total_free));\n\t\tpr_err(\"\\ttotal_dirty    %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(mst->total_dirty));\n\t\tpr_err(\"\\ttotal_used     %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(mst->total_used));\n\t\tpr_err(\"\\ttotal_dead     %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(mst->total_dead));\n\t\tpr_err(\"\\ttotal_dark     %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(mst->total_dark));\n\t\tbreak;\n\t}\n\tcase UBIFS_REF_NODE:\n\t{\n\t\tconst struct ubifs_ref_node *ref = node;\n\n\t\tpr_err(\"\\tlnum           %u\\n\", le32_to_cpu(ref->lnum));\n\t\tpr_err(\"\\toffs           %u\\n\", le32_to_cpu(ref->offs));\n\t\tpr_err(\"\\tjhead          %u\\n\", le32_to_cpu(ref->jhead));\n\t\tbreak;\n\t}\n\tcase UBIFS_INO_NODE:\n\t{\n\t\tconst struct ubifs_ino_node *ino = node;\n\n\t\tkey_read(c, &ino->key, &key);\n\t\tpr_err(\"\\tkey            %s\\n\",\n\t\t       dbg_snprintf_key(c, &key, key_buf, DBG_KEY_BUF_LEN));\n\t\tpr_err(\"\\tcreat_sqnum    %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(ino->creat_sqnum));\n\t\tpr_err(\"\\tsize           %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(ino->size));\n\t\tpr_err(\"\\tnlink          %u\\n\", le32_to_cpu(ino->nlink));\n\t\tpr_err(\"\\tatime          %lld.%u\\n\",\n\t\t       (long long)le64_to_cpu(ino->atime_sec),\n\t\t       le32_to_cpu(ino->atime_nsec));\n\t\tpr_err(\"\\tmtime          %lld.%u\\n\",\n\t\t       (long long)le64_to_cpu(ino->mtime_sec),\n\t\t       le32_to_cpu(ino->mtime_nsec));\n\t\tpr_err(\"\\tctime          %lld.%u\\n\",\n\t\t       (long long)le64_to_cpu(ino->ctime_sec),\n\t\t       le32_to_cpu(ino->ctime_nsec));\n\t\tpr_err(\"\\tuid            %u\\n\", le32_to_cpu(ino->uid));\n\t\tpr_err(\"\\tgid            %u\\n\", le32_to_cpu(ino->gid));\n\t\tpr_err(\"\\tmode           %u\\n\", le32_to_cpu(ino->mode));\n\t\tpr_err(\"\\tflags          %#x\\n\", le32_to_cpu(ino->flags));\n\t\tpr_err(\"\\txattr_cnt      %u\\n\", le32_to_cpu(ino->xattr_cnt));\n\t\tpr_err(\"\\txattr_size     %u\\n\", le32_to_cpu(ino->xattr_size));\n\t\tpr_err(\"\\txattr_names    %u\\n\", le32_to_cpu(ino->xattr_names));\n\t\tpr_err(\"\\tcompr_type     %#x\\n\",\n\t\t       (int)le16_to_cpu(ino->compr_type));\n\t\tpr_err(\"\\tdata len       %u\\n\", le32_to_cpu(ino->data_len));\n\t\tbreak;\n\t}\n\tcase UBIFS_DENT_NODE:\n\tcase UBIFS_XENT_NODE:\n\t{\n\t\tconst struct ubifs_dent_node *dent = node;\n\t\tint nlen = le16_to_cpu(dent->nlen);\n\n\t\tkey_read(c, &dent->key, &key);\n\t\tpr_err(\"\\tkey            %s\\n\",\n\t\t       dbg_snprintf_key(c, &key, key_buf, DBG_KEY_BUF_LEN));\n\t\tpr_err(\"\\tinum           %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(dent->inum));\n\t\tpr_err(\"\\ttype           %d\\n\", (int)dent->type);\n\t\tpr_err(\"\\tnlen           %d\\n\", nlen);\n\t\tpr_err(\"\\tname           \");\n\n\t\tif (nlen > UBIFS_MAX_NLEN)\n\t\t\tpr_err(\"(bad name length, not printing, bad or corrupted node)\");\n\t\telse {\n\t\t\tfor (i = 0; i < nlen && dent->name[i]; i++)\n\t\t\t\tpr_cont(\"%c\", dent->name[i]);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\n\t\tbreak;\n\t}\n\tcase UBIFS_DATA_NODE:\n\t{\n\t\tconst struct ubifs_data_node *dn = node;\n\t\tint dlen = le32_to_cpu(ch->len) - UBIFS_DATA_NODE_SZ;\n\n\t\tkey_read(c, &dn->key, &key);\n\t\tpr_err(\"\\tkey            %s\\n\",\n\t\t       dbg_snprintf_key(c, &key, key_buf, DBG_KEY_BUF_LEN));\n\t\tpr_err(\"\\tsize           %u\\n\", le32_to_cpu(dn->size));\n\t\tpr_err(\"\\tcompr_typ      %d\\n\",\n\t\t       (int)le16_to_cpu(dn->compr_type));\n\t\tpr_err(\"\\tdata size      %d\\n\", dlen);\n\t\tpr_err(\"\\tdata:\\n\");\n\t\tprint_hex_dump(KERN_ERR, \"\\t\", DUMP_PREFIX_OFFSET, 32, 1,\n\t\t\t       (void *)&dn->data, dlen, 0);\n\t\tbreak;\n\t}\n\tcase UBIFS_TRUN_NODE:\n\t{\n\t\tconst struct ubifs_trun_node *trun = node;\n\n\t\tpr_err(\"\\tinum           %u\\n\", le32_to_cpu(trun->inum));\n\t\tpr_err(\"\\told_size       %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(trun->old_size));\n\t\tpr_err(\"\\tnew_size       %llu\\n\",\n\t\t       (unsigned long long)le64_to_cpu(trun->new_size));\n\t\tbreak;\n\t}\n\tcase UBIFS_IDX_NODE:\n\t{\n\t\tconst struct ubifs_idx_node *idx = node;\n\n\t\tn = le16_to_cpu(idx->child_cnt);\n\t\tpr_err(\"\\tchild_cnt      %d\\n\", n);\n\t\tpr_err(\"\\tlevel          %d\\n\", (int)le16_to_cpu(idx->level));\n\t\tpr_err(\"\\tBranches:\\n\");\n\n\t\tfor (i = 0; i < n && i < c->fanout - 1; i++) {\n\t\t\tconst struct ubifs_branch *br;\n\n\t\t\tbr = ubifs_idx_branch(c, idx, i);\n\t\t\tkey_read(c, &br->key, &key);\n\t\t\tpr_err(\"\\t%d: LEB %d:%d len %d key %s\\n\",\n\t\t\t       i, le32_to_cpu(br->lnum), le32_to_cpu(br->offs),\n\t\t\t       le32_to_cpu(br->len),\n\t\t\t       dbg_snprintf_key(c, &key, key_buf,\n\t\t\t\t\t\tDBG_KEY_BUF_LEN));\n\t\t}\n\t\tbreak;\n\t}\n\tcase UBIFS_CS_NODE:\n\t\tbreak;\n\tcase UBIFS_ORPH_NODE:\n\t{\n\t\tconst struct ubifs_orph_node *orph = node;\n\n\t\tpr_err(\"\\tcommit number  %llu\\n\",\n\t\t       (unsigned long long)\n\t\t\t\tle64_to_cpu(orph->cmt_no) & LLONG_MAX);\n\t\tpr_err(\"\\tlast node flag %llu\\n\",\n\t\t       (unsigned long long)(le64_to_cpu(orph->cmt_no)) >> 63);\n\t\tn = (le32_to_cpu(ch->len) - UBIFS_ORPH_NODE_SZ) >> 3;\n\t\tpr_err(\"\\t%d orphan inode numbers:\\n\", n);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tpr_err(\"\\t  ino %llu\\n\",\n\t\t\t       (unsigned long long)le64_to_cpu(orph->inos[i]));\n\t\tbreak;\n\t}\n\tdefault:\n\t\tpr_err(\"node type %d was not recognized\\n\",\n\t\t       (int)ch->node_type);\n\t}\n\tspin_unlock(&dbg_lock);\n}\n\nvoid ubifs_"
  },
  {
    "function_name": "ode(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "233-299",
    "snippet": "mp_inode(struct ubifs_info *c, const struct inode *inode)\n{\n\tconst struct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct qstr nm = { .name = NULL };\n\tunion ubifs_key key;\n\tstruct ubifs_dent_node *dent, *pdent = NULL;\n\tint count = 2;\n\n\tpr_err(\"Dump in-memory inode:\");\n\tpr_err(\"\\tinode          %lu\\n\", inode->i_ino);\n\tpr_err(\"\\tsize           %llu\\n\",\n\t       (unsigned long long)i_size_read(inode));\n\tpr_err(\"\\tnlink          %u\\n\", inode->i_nlink);\n\tpr_err(\"\\tuid            %u\\n\", (unsigned int)i_uid_read(inode));\n\tpr_err(\"\\tgid            %u\\n\", (unsigned int)i_gid_read(inode));\n\tpr_err(\"\\tatime          %u.%u\\n\",\n\t       (unsigned int)inode->i_atime.tv_sec,\n\t       (unsigned int)inode->i_atime.tv_nsec);\n\tpr_err(\"\\tmtime          %u.%u\\n\",\n\t       (unsigned int)inode->i_mtime.tv_sec,\n\t       (unsigned int)inode->i_mtime.tv_nsec);\n\tpr_err(\"\\tctime          %u.%u\\n\",\n\t       (unsigned int)inode->i_ctime.tv_sec,\n\t       (unsigned int)inode->i_ctime.tv_nsec);\n\tpr_err(\"\\tcreat_sqnum    %llu\\n\", ui->creat_sqnum);\n\tpr_err(\"\\txattr_size     %u\\n\", ui->xattr_size);\n\tpr_err(\"\\txattr_cnt      %u\\n\", ui->xattr_cnt);\n\tpr_err(\"\\txattr_names    %u\\n\", ui->xattr_names);\n\tpr_err(\"\\tdirty          %u\\n\", ui->dirty);\n\tpr_err(\"\\txattr          %u\\n\", ui->xattr);\n\tpr_err(\"\\tbulk_read      %u\\n\", ui->xattr);\n\tpr_err(\"\\tsynced_i_size  %llu\\n\",\n\t       (unsigned long long)ui->synced_i_size);\n\tpr_err(\"\\tui_size        %llu\\n\",\n\t       (unsigned long long)ui->ui_size);\n\tpr_err(\"\\tflags          %d\\n\", ui->flags);\n\tpr_err(\"\\tcompr_type     %d\\n\", ui->compr_type);\n\tpr_err(\"\\tlast_page_read %lu\\n\", ui->last_page_read);\n\tpr_err(\"\\tread_in_a_row  %lu\\n\", ui->read_in_a_row);\n\tpr_err(\"\\tdata_len       %d\\n\", ui->data_len);\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tpr_err(\"List of directory entries:\\n\");\n\tubifs_assert(!mutex_is_locked(&c->tnc_mutex));\n\n\tlowest_dent_key(c, &key, inode->i_ino);\n\twhile (1) {\n\t\tdent = ubifs_tnc_next_ent(c, &key, &nm);\n\t\tif (IS_ERR(dent)) {\n\t\t\tif (PTR_ERR(dent) != -ENOENT)\n\t\t\t\tpr_err(\"error %ld\\n\", PTR_ERR(dent));\n\t\t\tbreak;\n\t\t}\n\n\t\tpr_err(\"\\t%d: %s (%s)\\n\",\n\t\t       count++, dent->name, get_dent_type(dent->type));\n\n\t\tnm.name = dent->name;\n\t\tnm.len = le16_to_cpu(dent->nlen);\n\t\tkfree(pdent);\n\t\tpdent = dent;\n\t\tkey_read(c, &dent->key, &key);\n\t}\n\tkfree(pdent);\n}\n\nvoid ubifs_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\nv",
          "args": [
            "id ub"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dent->ke",
          "args": [
            ",",
            "key);\n\t}",
            "ree("
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pd",
          "args": [
            "nt ="
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "update_mem_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/debug.c",
          "lines": "124-194",
          "snippet": "static void update_mem_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\n\tunsigned npages;\n\tint i;\n\n\tif (si->base_mem)\n\t\tgoto get_cache;\n\n\tsi->base_mem = sizeof(struct f2fs_sb_info) + sbi->sb->s_blocksize;\n\tsi->base_mem += 2 * sizeof(struct f2fs_inode_info);\n\tsi->base_mem += sizeof(*sbi->ckpt);\n\n\t/* build sm */\n\tsi->base_mem += sizeof(struct f2fs_sm_info);\n\n\t/* build sit */\n\tsi->base_mem += sizeof(struct sit_info);\n\tsi->base_mem += MAIN_SEGS(sbi) * sizeof(struct seg_entry);\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += 2 * SIT_VBLOCK_MAP_SIZE * MAIN_SEGS(sbi);\n\tsi->base_mem += SIT_VBLOCK_MAP_SIZE;\n\tif (sbi->segs_per_sec > 1)\n\t\tsi->base_mem += MAIN_SECS(sbi) * sizeof(struct sec_entry);\n\tsi->base_mem += __bitmap_size(sbi, SIT_BITMAP);\n\n\t/* build free segmap */\n\tsi->base_mem += sizeof(struct free_segmap_info);\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SECS(sbi));\n\n\t/* build curseg */\n\tsi->base_mem += sizeof(struct curseg_info) * NR_CURSEG_TYPE;\n\tsi->base_mem += PAGE_CACHE_SIZE * NR_CURSEG_TYPE;\n\n\t/* build dirty segmap */\n\tsi->base_mem += sizeof(struct dirty_seglist_info);\n\tsi->base_mem += NR_DIRTY_TYPE * f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SECS(sbi));\n\n\t/* build nm */\n\tsi->base_mem += sizeof(struct f2fs_nm_info);\n\tsi->base_mem += __bitmap_size(sbi, NAT_BITMAP);\n\nget_cache:\n\tsi->cache_mem = 0;\n\n\t/* build gc */\n\tif (sbi->gc_thread)\n\t\tsi->cache_mem += sizeof(struct f2fs_gc_kthread);\n\n\t/* build merge flush thread */\n\tif (SM_I(sbi)->cmd_control_info)\n\t\tsi->cache_mem += sizeof(struct flush_cmd_control);\n\n\t/* free nids */\n\tsi->cache_mem += NM_I(sbi)->fcnt * sizeof(struct free_nid);\n\tsi->cache_mem += NM_I(sbi)->nat_cnt * sizeof(struct nat_entry);\n\tsi->cache_mem += NM_I(sbi)->dirty_nat_cnt *\n\t\t\t\t\tsizeof(struct nat_entry_set);\n\tsi->cache_mem += si->inmem_pages * sizeof(struct inmem_pages);\n\tsi->cache_mem += sbi->n_dirty_dirs * sizeof(struct inode_entry);\n\tfor (i = 0; i <= UPDATE_INO; i++)\n\t\tsi->cache_mem += sbi->im[i].ino_num * sizeof(struct ino_entry);\n\n\tsi->page_mem = 0;\n\tnpages = NODE_MAPPING(sbi)->nrpages;\n\tsi->page_mem += npages << PAGE_CACHE_SHIFT;\n\tnpages = META_MAPPING(sbi)->nrpages;\n\tsi->page_mem += npages << PAGE_CACHE_SHIFT;\n}",
          "includes": [
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/blkdev.h>\n#include <linux/f2fs_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic void update_mem_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_stat_info *si = F2FS_STAT(sbi);\n\tunsigned npages;\n\tint i;\n\n\tif (si->base_mem)\n\t\tgoto get_cache;\n\n\tsi->base_mem = sizeof(struct f2fs_sb_info) + sbi->sb->s_blocksize;\n\tsi->base_mem += 2 * sizeof(struct f2fs_inode_info);\n\tsi->base_mem += sizeof(*sbi->ckpt);\n\n\t/* build sm */\n\tsi->base_mem += sizeof(struct f2fs_sm_info);\n\n\t/* build sit */\n\tsi->base_mem += sizeof(struct sit_info);\n\tsi->base_mem += MAIN_SEGS(sbi) * sizeof(struct seg_entry);\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += 2 * SIT_VBLOCK_MAP_SIZE * MAIN_SEGS(sbi);\n\tsi->base_mem += SIT_VBLOCK_MAP_SIZE;\n\tif (sbi->segs_per_sec > 1)\n\t\tsi->base_mem += MAIN_SECS(sbi) * sizeof(struct sec_entry);\n\tsi->base_mem += __bitmap_size(sbi, SIT_BITMAP);\n\n\t/* build free segmap */\n\tsi->base_mem += sizeof(struct free_segmap_info);\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SECS(sbi));\n\n\t/* build curseg */\n\tsi->base_mem += sizeof(struct curseg_info) * NR_CURSEG_TYPE;\n\tsi->base_mem += PAGE_CACHE_SIZE * NR_CURSEG_TYPE;\n\n\t/* build dirty segmap */\n\tsi->base_mem += sizeof(struct dirty_seglist_info);\n\tsi->base_mem += NR_DIRTY_TYPE * f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsi->base_mem += f2fs_bitmap_size(MAIN_SECS(sbi));\n\n\t/* build nm */\n\tsi->base_mem += sizeof(struct f2fs_nm_info);\n\tsi->base_mem += __bitmap_size(sbi, NAT_BITMAP);\n\nget_cache:\n\tsi->cache_mem = 0;\n\n\t/* build gc */\n\tif (sbi->gc_thread)\n\t\tsi->cache_mem += sizeof(struct f2fs_gc_kthread);\n\n\t/* build merge flush thread */\n\tif (SM_I(sbi)->cmd_control_info)\n\t\tsi->cache_mem += sizeof(struct flush_cmd_control);\n\n\t/* free nids */\n\tsi->cache_mem += NM_I(sbi)->fcnt * sizeof(struct free_nid);\n\tsi->cache_mem += NM_I(sbi)->nat_cnt * sizeof(struct nat_entry);\n\tsi->cache_mem += NM_I(sbi)->dirty_nat_cnt *\n\t\t\t\t\tsizeof(struct nat_entry_set);\n\tsi->cache_mem += si->inmem_pages * sizeof(struct inmem_pages);\n\tsi->cache_mem += sbi->n_dirty_dirs * sizeof(struct inode_entry);\n\tfor (i = 0; i <= UPDATE_INO; i++)\n\t\tsi->cache_mem += sbi->im[i].ino_num * sizeof(struct ino_entry);\n\n\tsi->page_mem = 0;\n\tnpages = NODE_MAPPING(sbi)->nrpages;\n\tsi->page_mem += npages << PAGE_CACHE_SHIFT;\n\tnpages = META_MAPPING(sbi)->nrpages;\n\tsi->page_mem += npages << PAGE_CACHE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ent->nlen);",
          "args": [
            "kfree(pd"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%s (%",
          "args": [
            ")\\n\",\n\t\t       co",
            "->name,",
            "et_dent_ty",
            "(dent->type));\n\n\t\tnm.name"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(dent->type))",
          "args": [
            "nm.nam"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%ld\\n",
          "args": [
            ", PTR_ERR(den",
            ");\n\t\t\tbreak;"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\t\tb",
          "args": [
            "eak;"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!= -EN",
          "args": [
            "ENT)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{",
          "args": [
            "f (P"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "xit(void)\n{\n\tif",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
          "lines": "3074-3078",
          "snippet": "gfs_exit(void)\n{\n\tif (IS_ENABLED(CONFIG_DEBUG_FS))\n\t\tdebugfs_remove_recursive(dfs_rootdir);\n}\n\n/**\n * ubif",
          "includes": [
            "fs.h\"\n\nstatic DEFIN",
            "ux/random.h>\n#include \"ubi",
            "ux/uaccess.h>\n#include <lin",
            "ux/math64.h>\n#include <lin",
            "ux/debugfs.h>\n#include <lin",
            "ux/module.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [
            "dentry *dfs_rootdir;\n\nstatic int"
          ],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\ndentry *dfs_rootdir;\n\nstatic int;\n\ngfs_exit(void)\n{\n\tif (IS_ENABLED(CONFIG_DEBUG_FS))\n\t\tdebugfs_remove_recursive(dfs_rootdir);\n}\n\n/**\n * ubif"
        }
      },
      {
        "call_info": {
          "callee": "t_ent(c, &key, &nm",
          "args": [
            ";",
            "if",
            "S_E"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey(c, &key, ino",
          "args": [
            "e",
            "i_in",
            ";\n\twhile (1)"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!mutex_is_lo",
          "args": [
            "ked(&c->tnc_mutex));\n\n\tlowest_d"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&c->tnc_mute",
          "args": [
            "));\n\n\tlowest_"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of dir",
          "args": [
            "ctory entries:\\n\");\n\tubifs_ass"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->i_mod",
          "args": [
            "))\n\t\treturn;"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a_len",
          "args": [
            "%d\\n\", ui->data_le",
            ";\n\n\tif (!S_I"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_in_a",
          "args": [
            "row  %lu\\n\", ui->read_in",
            "_row);\n\tpr_err(\"\\"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_find_in_attrdef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1306-1328",
          "snippet": "static ATTR_DEF *ntfs_attr_find_in_attrdef(const ntfs_volume *vol,\n\t\tconst ATTR_TYPE type)\n{\n\tATTR_DEF *ad;\n\n\tBUG_ON(!vol->attrdef);\n\tBUG_ON(!type);\n\tfor (ad = vol->attrdef; (u8*)ad - (u8*)vol->attrdef <\n\t\t\tvol->attrdef_size && ad->type; ++ad) {\n\t\t/* We have not found it yet, carry on searching. */\n\t\tif (likely(le32_to_cpu(ad->type) < le32_to_cpu(type)))\n\t\t\tcontinue;\n\t\t/* We found the attribute; return it. */\n\t\tif (likely(ad->type == type))\n\t\t\treturn ad;\n\t\t/* We have gone too far already.  No point in continuing. */\n\t\tbreak;\n\t}\n\t/* Attribute not found. */\n\tntfs_debug(\"Attribute type 0x%x not found in $AttrDef.\",\n\t\t\tle32_to_cpu(type));\n\treturn NULL;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nstatic ATTR_DEF *ntfs_attr_find_in_attrdef(const ntfs_volume *vol,\n\t\tconst ATTR_TYPE type)\n{\n\tATTR_DEF *ad;\n\n\tBUG_ON(!vol->attrdef);\n\tBUG_ON(!type);\n\tfor (ad = vol->attrdef; (u8*)ad - (u8*)vol->attrdef <\n\t\t\tvol->attrdef_size && ad->type; ++ad) {\n\t\t/* We have not found it yet, carry on searching. */\n\t\tif (likely(le32_to_cpu(ad->type) < le32_to_cpu(type)))\n\t\t\tcontinue;\n\t\t/* We found the attribute; return it. */\n\t\tif (likely(ad->type == type))\n\t\t\treturn ad;\n\t\t/* We have gone too far already.  No point in continuing. */\n\t\tbreak;\n\t}\n\t/* Attribute not found. */\n\tntfs_debug(\"Attribute type 0x%x not found in $AttrDef.\",\n\t\t\tle32_to_cpu(type));\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_page",
          "args": [
            "read %lu\\n\", ui->last_pa",
            "_read);\n\tpr_err(\"\\"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "dio_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/direct-io.c",
          "lines": "199-211",
          "snippet": "static inline struct page *dio_get_page(struct dio *dio,\n\t\t\t\t\tstruct dio_submit *sdio)\n{\n\tif (dio_pages_present(sdio) == 0) {\n\t\tint ret;\n\n\t\tret = dio_refill_pages(dio, sdio);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t\tBUG_ON(dio_pages_present(sdio) == 0);\n\t}\n\treturn dio->pages[sdio->head];\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uio.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/err.h>",
            "#include <linux/wait.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dio {\n\tint flags;\t\t\t/* doesn't change */\n\tint rw;\n\tstruct inode *inode;\n\tloff_t i_size;\t\t\t/* i_size when submitted */\n\tdio_iodone_t *end_io;\t\t/* IO completion function */\n\n\tvoid *private;\t\t\t/* copy from map_bh.b_private */\n\n\t/* BIO completion state */\n\tspinlock_t bio_lock;\t\t/* protects BIO fields below */\n\tint page_errors;\t\t/* errno from get_user_pages() */\n\tint is_async;\t\t\t/* is IO async ? */\n\tbool defer_completion;\t\t/* defer AIO completion to workqueue? */\n\tint io_error;\t\t\t/* IO error in completion path */\n\tunsigned long refcount;\t\t/* direct_io_worker() and bios */\n\tstruct bio *bio_list;\t\t/* singly linked via bi_private */\n\tstruct task_struct *waiter;\t/* waiting task (NULL if none) */\n\n\t/* AIO related stuff */\n\tstruct kiocb *iocb;\t\t/* kiocb */\n\tssize_t result;                 /* IO result */\n\n\t/*\n\t * pages[] (and any fields placed after it) are not zeroed out at\n\t * allocation time.  Don't add new fields after pages[] unless you\n\t * wish that they not be zeroed.\n\t */\n\tunion {\n\t\tstruct page *pages[DIO_PAGES];\t/* page buffer */\n\t\tstruct work_struct complete_work;/* deferred AIO completion */\n\t};\n} ____cacheline_aligned_in_smp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/prefetch.h>\n#include <linux/atomic.h>\n#include <linux/uio.h>\n#include <linux/rwsem.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/err.h>\n#include <linux/wait.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct dio {\n\tint flags;\t\t\t/* doesn't change */\n\tint rw;\n\tstruct inode *inode;\n\tloff_t i_size;\t\t\t/* i_size when submitted */\n\tdio_iodone_t *end_io;\t\t/* IO completion function */\n\n\tvoid *private;\t\t\t/* copy from map_bh.b_private */\n\n\t/* BIO completion state */\n\tspinlock_t bio_lock;\t\t/* protects BIO fields below */\n\tint page_errors;\t\t/* errno from get_user_pages() */\n\tint is_async;\t\t\t/* is IO async ? */\n\tbool defer_completion;\t\t/* defer AIO completion to workqueue? */\n\tint io_error;\t\t\t/* IO error in completion path */\n\tunsigned long refcount;\t\t/* direct_io_worker() and bios */\n\tstruct bio *bio_list;\t\t/* singly linked via bi_private */\n\tstruct task_struct *waiter;\t/* waiting task (NULL if none) */\n\n\t/* AIO related stuff */\n\tstruct kiocb *iocb;\t\t/* kiocb */\n\tssize_t result;                 /* IO result */\n\n\t/*\n\t * pages[] (and any fields placed after it) are not zeroed out at\n\t * allocation time.  Don't add new fields after pages[] unless you\n\t * wish that they not be zeroed.\n\t */\n\tunion {\n\t\tstruct page *pages[DIO_PAGES];\t/* page buffer */\n\t\tstruct work_struct complete_work;/* deferred AIO completion */\n\t};\n} ____cacheline_aligned_in_smp;\n\nstatic inline struct page *dio_get_page(struct dio *dio,\n\t\t\t\t\tstruct dio_submit *sdio)\n{\n\tif (dio_pages_present(sdio) == 0) {\n\t\tint ret;\n\n\t\tret = dio_refill_pages(dio, sdio);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t\tBUG_ON(dio_pages_present(sdio) == 0);\n\t}\n\treturn dio->pages[sdio->head];\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_typ",
          "args": [
            "%d\\n\", ui->compr_t",
            "e);\n\tpr_err(\"\\"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gs",
          "args": [
            "%d\\n\", ui->flags);",
            "pr_err(\"\\"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "do_thread_regset_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1607-1612",
          "snippet": "static void do_thread_regset_writeback(struct task_struct *task,\n\t\t\t\t       const struct user_regset *regset)\n{\n\tif (regset->writeback)\n\t\tregset->writeback(task, regset, 1);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void do_thread_regset_writeback(struct task_struct *task,\n\t\t\t\t       const struct user_regset *regset)\n{\n\tif (regset->writeback)\n\t\tregset->writeback(task, regset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "size",
          "args": [
            "%llu\\n\",\n\t       (un",
            "g long)ui->ui_size);\n\tpr_err(\"\\"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "_size(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
          "lines": "1715-1737",
          "snippet": "_idx_size(struct ubifs_info *c, long long idx_size)\n{\n\tint err;\n\tlong long calc = 0;\n\n\tif (!dbg_is_chk_index(c))\n\t\treturn 0;\n\n\terr = dbg_walk_index(c, NULL, add_size, &calc);\n\tif (err) {\n\t\tubifs_err(\"error %d while walking the index\", err);\n\t\treturn err;\n\t}\n\n\tif (calc != idx_size) {\n\t\tubifs_err(\"index size check failed: calculated size is %lld, should be %lld\",\n\t\t\t  calc, idx_size);\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/**\n * stru",
          "includes": [
            "fs.h\"\n\nstatic DEFIN",
            "ux/random.h>\n#include \"ubi",
            "ux/uaccess.h>\n#include <lin",
            "ux/math64.h>\n#include <lin",
            "ux/debugfs.h>\n#include <lin",
            "ux/module.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [
            "global_debug_info ubifs_dbg;\n\nstatic stru"
          ],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nglobal_debug_info ubifs_dbg;\n\nstatic stru;\n\n_idx_size(struct ubifs_info *c, long long idx_size)\n{\n\tint err;\n\tlong long calc = 0;\n\n\tif (!dbg_is_chk_index(c))\n\t\treturn 0;\n\n\terr = dbg_walk_index(c, NULL, add_size, &calc);\n\tif (err) {\n\t\tubifs_err(\"error %d while walking the index\", err);\n\t\treturn err;\n\t}\n\n\tif (calc != idx_size) {\n\t\tubifs_err(\"index size check failed: calculated size is %lld, should be %lld\",\n\t\t\t  calc, idx_size);\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/**\n * stru"
        }
      },
      {
        "call_info": {
          "callee": "ced_i_",
          "args": [
            "ize  %llu\\n\",\n\t       (un",
            "g long)ui->synced_i_size);\n\tpr_err(\"\\"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "ced_i_size(const struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
          "lines": "1067-1090",
          "snippet": "_synced_i_size(const struct ubifs_info *c, struct inode *inode)\n{\n\tint err = 0;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tif (!dbg_is_chk_gen(c))\n\t\treturn 0;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\n\tmutex_lock(&ui->ui_mutex);\n\tspin_lock(&ui->ui_lock);\n\tif (ui->ui_size != ui->synced_i_size && !ui->dirty) {\n\t\tubifs_err(\"ui_size is %lld, synced_i_size is %lld, but inode is clean\",\n\t\t\t  ui->ui_size, ui->synced_i_size);\n\t\tubifs_err(\"i_ino %lu, i_mode %#x, i_size %lld\", inode->i_ino,\n\t\t\t  inode->i_mode, i_size_read(inode));\n\t\tdump_stack();\n\t\terr = -EINVAL;\n\t}\n\tspin_unlock(&ui->ui_lock);\n\tmutex_unlock(&ui->ui_mutex);\n\treturn err;\n}\n\n/*\n * dbg_c",
          "includes": [
            "fs.h\"\n\nstatic DEFIN",
            "ux/random.h>\n#include \"ubi",
            "ux/uaccess.h>\n#include <lin",
            "ux/math64.h>\n#include <lin",
            "ux/debugfs.h>\n#include <lin",
            "ux/module.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\n_synced_i_size(const struct ubifs_info *c, struct inode *inode)\n{\n\tint err = 0;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tif (!dbg_is_chk_gen(c))\n\t\treturn 0;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\n\tmutex_lock(&ui->ui_mutex);\n\tspin_lock(&ui->ui_lock);\n\tif (ui->ui_size != ui->synced_i_size && !ui->dirty) {\n\t\tubifs_err(\"ui_size is %lld, synced_i_size is %lld, but inode is clean\",\n\t\t\t  ui->ui_size, ui->synced_i_size);\n\t\tubifs_err(\"i_ino %lu, i_mode %#x, i_size %lld\", inode->i_ino,\n\t\t\t  inode->i_mode, i_size_read(inode));\n\t\tdump_stack();\n\t\terr = -EINVAL;\n\t}\n\tspin_unlock(&ui->ui_lock);\n\tmutex_unlock(&ui->ui_mutex);\n\treturn err;\n}\n\n/*\n * dbg_c"
        }
      },
      {
        "call_info": {
          "callee": "k_read",
          "args": [
            "%u\\n\", ui->xattr);",
            "pr_err(\"\\"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "k_read(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
          "lines": "1735-1777",
          "snippet": "_bulk_read(struct ubifs_info *c, struct bu_info *bu)\n{\n\tint lnum = bu->zbranch[0].lnum, offs = bu->zbranch[0].offs, len, err, i;\n\tstruct ubifs_wbuf *wbuf;\n\tvoid *buf;\n\n\tlen = bu->zbranch[bu->cnt - 1].offs;\n\tlen += bu->zbranch[bu->cnt - 1].len - offs;\n\tif (len > bu->buf_len) {\n\t\tubifs_err(\"buffer too small %d vs %d\", bu->buf_len, len);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Do the read */\n\twbuf = ubifs_get_wbuf(c, lnum);\n\tif (wbuf)\n\t\terr = read_wbuf(wbuf, bu->buf, len, lnum, offs);\n\telse\n\t\terr = ubifs_leb_read(c, lnum, bu->buf, offs, len, 0);\n\n\t/* Check for a race with GC */\n\tif (maybe_leb_gced(c, lnum, bu->gc_seq))\n\t\treturn -EAGAIN;\n\n\tif (err && err != -EBADMSG) {\n\t\tubifs_err(\"failed to read from LEB %d:%d, error %d\",\n\t\t\t  lnum, offs, err);\n\t\tdump_stack();\n\t\tdbg_tnck(&bu->key, \"key \");\n\t\treturn err;\n\t}\n\n\t/* Validate the nodes read */\n\tbuf = bu->buf;\n\tfor (i = 0; i < bu->cnt; i++) {\n\t\terr = validate_data_node(c, buf, &bu->zbranch[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbuf = buf + ALIGN(bu->zbranch[i].len, 8);\n\t}\n\n\treturn 0;\n}\n\n/**\n * do_l",
          "includes": [
            "fs.h\"\n\n/*\n * Return",
            "ux/slab.h>\n#include \"ubi",
            "ux/crc32.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\n_bulk_read(struct ubifs_info *c, struct bu_info *bu)\n{\n\tint lnum = bu->zbranch[0].lnum, offs = bu->zbranch[0].offs, len, err, i;\n\tstruct ubifs_wbuf *wbuf;\n\tvoid *buf;\n\n\tlen = bu->zbranch[bu->cnt - 1].offs;\n\tlen += bu->zbranch[bu->cnt - 1].len - offs;\n\tif (len > bu->buf_len) {\n\t\tubifs_err(\"buffer too small %d vs %d\", bu->buf_len, len);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Do the read */\n\twbuf = ubifs_get_wbuf(c, lnum);\n\tif (wbuf)\n\t\terr = read_wbuf(wbuf, bu->buf, len, lnum, offs);\n\telse\n\t\terr = ubifs_leb_read(c, lnum, bu->buf, offs, len, 0);\n\n\t/* Check for a race with GC */\n\tif (maybe_leb_gced(c, lnum, bu->gc_seq))\n\t\treturn -EAGAIN;\n\n\tif (err && err != -EBADMSG) {\n\t\tubifs_err(\"failed to read from LEB %d:%d, error %d\",\n\t\t\t  lnum, offs, err);\n\t\tdump_stack();\n\t\tdbg_tnck(&bu->key, \"key \");\n\t\treturn err;\n\t}\n\n\t/* Validate the nodes read */\n\tbuf = bu->buf;\n\tfor (i = 0; i < bu->cnt; i++) {\n\t\terr = validate_data_node(c, buf, &bu->zbranch[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbuf = buf + ALIGN(bu->zbranch[i].len, 8);\n\t}\n\n\treturn 0;\n}\n\n/**\n * do_l"
        }
      },
      {
        "call_info": {
          "callee": "tr",
          "args": [
            "%u\\n\", ui->xattr);",
            "pr_err(\"\\"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "(struct inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
          "lines": "2648-2652",
          "snippet": "s_file_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = inode->i_private;\n\treturn nonseekable_open(inode, file);\n}\n\n/**\n * prov",
          "includes": [
            "fs.h\"\n\nstatic DEFIN",
            "ux/random.h>\n#include \"ubi",
            "ux/uaccess.h>\n#include <lin",
            "ux/math64.h>\n#include <lin",
            "ux/debugfs.h>\n#include <lin",
            "ux/module.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\ns_file_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = inode->i_private;\n\treturn nonseekable_open(inode, file);\n}\n\n/**\n * prov"
        }
      },
      {
        "call_info": {
          "callee": "ty",
          "args": [
            "%u\\n\", ui->dirty);",
            "pr_err(\"\\"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "jffs2_dbg_acct_sanity_check(s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/debug.c",
          "lines": "51-58",
          "snippet": "id\n__jffs2_dbg_acct_sanity_check(struct jffs2_sb_info *c,\n\t\t\t      struct jffs2_eraseblock *jeb)\n{\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tspin_unlock(&c->erase_completion_lock);\n}",
          "includes": [
            "nclude \"debug.h\"\n\n#",
            "nclude \"nodelist.h\"\n#i",
            "nclude <linux/slab.h>\n#i",
            "nclude <linux/mtd/mtd.h>\n#i",
            "nclude <linux/jffs2.h>\n#i",
            "nclude <linux/crc32.h>\n#i",
            "nclude <linux/pagemap.h>\n#i",
            "nclude <linux/types.h>\n#i",
            "nclude <linux/kernel.h>\n#i"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "nclude \"debug.h\"\n\n#\nnclude \"nodelist.h\"\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/jffs2.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/types.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nid\n__jffs2_dbg_acct_sanity_check(struct jffs2_sb_info *c,\n\t\t\t      struct jffs2_eraseblock *jeb)\n{\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tspin_unlock(&c->erase_completion_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tr_nam",
          "args": [
            "s    %u\\n\", ui->xattr_n",
            "es);\n\tpr_err(\"\\"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "__copy_xattr_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "512-534",
          "snippet": "static char *__copy_xattr_names(struct ceph_inode_info *ci,\n\t\t\t\tchar *dest)\n{\n\tstruct rb_node *p;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\n\tp = rb_first(&ci->i_xattrs.index);\n\tdout(\"__copy_xattr_names count=%d\\n\", ci->i_xattrs.count);\n\n\twhile (p) {\n\t\txattr = rb_entry(p, struct ceph_inode_xattr, node);\n\t\tmemcpy(dest, xattr->name, xattr->name_len);\n\t\tdest[xattr->name_len] = '\\0';\n\n\t\tdout(\"dest=%s %p (%s) (%d/%d)\\n\", dest, xattr, xattr->name,\n\t\t     xattr->name_len, ci->i_xattrs.names_size);\n\n\t\tdest += xattr->name_len + 1;\n\t\tp = rb_next(p);\n\t}\n\n\treturn dest;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nstatic char *__copy_xattr_names(struct ceph_inode_info *ci,\n\t\t\t\tchar *dest)\n{\n\tstruct rb_node *p;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\n\tp = rb_first(&ci->i_xattrs.index);\n\tdout(\"__copy_xattr_names count=%d\\n\", ci->i_xattrs.count);\n\n\twhile (p) {\n\t\txattr = rb_entry(p, struct ceph_inode_xattr, node);\n\t\tmemcpy(dest, xattr->name, xattr->name_len);\n\t\tdest[xattr->name_len] = '\\0';\n\n\t\tdout(\"dest=%s %p (%s) (%d/%d)\\n\", dest, xattr, xattr->name,\n\t\t     xattr->name_len, ci->i_xattrs.names_size);\n\n\t\tdest += xattr->name_len + 1;\n\t\tp = rb_next(p);\n\t}\n\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tr_cnt",
          "args": [
            "%u\\n\", ui->xattr_c",
            ");\n\tpr_err(\"\\"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr_siz",
          "args": [
            "%u\\n\", ui->xattr_s",
            "e);\n\tpr_err(\"\\"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_setattr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "742-964",
          "snippet": "int\nxfs_setattr_size(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\txfs_off_t\t\toldsize, newsize;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\tuint\t\t\tlock_flags = 0;\n\tuint\t\t\tcommit_flags = 0;\n\tbool\t\t\tdid_zeroing = false;\n\n\ttrace_xfs_setattr(ip);\n\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn -EROFS;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = inode_change_ok(inode, iattr);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(S_ISREG(ip->i_d.di_mode));\n\tASSERT((iattr->ia_valid & (ATTR_UID|ATTR_GID|ATTR_ATIME|ATTR_ATIME_SET|\n\t\tATTR_MTIME_SET|ATTR_KILL_PRIV|ATTR_TIMES_SET)) == 0);\n\n\toldsize = inode->i_size;\n\tnewsize = iattr->ia_size;\n\n\t/*\n\t * Short circuit the truncate case for zero length files.\n\t */\n\tif (newsize == 0 && oldsize == 0 && ip->i_d.di_nextents == 0) {\n\t\tif (!(iattr->ia_valid & (ATTR_CTIME|ATTR_MTIME)))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Use the regular setattr path to update the timestamps.\n\t\t */\n\t\tiattr->ia_valid &= ~ATTR_SIZE;\n\t\treturn xfs_setattr_nonsize(ip, iattr, 0);\n\t}\n\n\t/*\n\t * Make sure that the dquots are attached to the inode.\n\t */\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * File data changes must be complete before we start the transaction to\n\t * modify the inode.  This needs to be done before joining the inode to\n\t * the transaction because the inode cannot be unlocked once it is a\n\t * part of the transaction.\n\t *\n\t * Start with zeroing any data block beyond EOF that we may expose on\n\t * file extension.\n\t */\n\tif (newsize > oldsize) {\n\t\terror = xfs_zero_eof(ip, newsize, oldsize, &did_zeroing);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We are going to log the inode size change in this transaction so\n\t * any previous writes that are beyond the on disk EOF and the new\n\t * EOF that have not been written out need to be written here.  If we\n\t * do not write the data out, we expose ourselves to the null files\n\t * problem. Note that this includes any block zeroing we did above;\n\t * otherwise those blocks may not be zeroed after a crash.\n\t */\n\tif (newsize > ip->i_d.di_size &&\n\t    (oldsize != ip->i_d.di_size || did_zeroing)) {\n\t\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t\t      ip->i_d.di_size, newsize);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* Now wait for all direct I/O to complete. */\n\tinode_dio_wait(inode);\n\n\t/*\n\t * Do all the page cache truncate work outside the transaction context\n\t * as the \"lock\" order is page lock->log space reservation.  i.e.\n\t * locking pages inside the transaction can ABBA deadlock with\n\t * writeback. We have to do the VFS inode size update before we truncate\n\t * the pagecache, however, to avoid racing with page faults beyond the\n\t * new EOF they are not serialised against truncate operations except by\n\t * page locks and size updates.\n\t *\n\t * Hence we are in a situation where a truncate can fail with ENOMEM\n\t * from xfs_trans_reserve(), but having already truncated the in-memory\n\t * version of the file (i.e. made user visible changes). There's not\n\t * much we can do about this, except to hope that the caller sees ENOMEM\n\t * and retries the truncate operation.\n\t */\n\terror = block_truncate_page(inode->i_mapping, newsize, xfs_get_blocks);\n\tif (error)\n\t\treturn error;\n\ttruncate_setsize(inode, newsize);\n\n\t/*\n\t * The \"we can't serialise against page faults\" pain gets worse.\n\t *\n\t * If the file is mapped then we have to clean the page at the old EOF\n\t * when extending the file. Extending the file can expose changes the\n\t * underlying page mapping (e.g. from beyond EOF to a hole or\n\t * unwritten), and so on the next attempt to write to that page we need\n\t * to remap it for write. i.e. we need .page_mkwrite() to be called.\n\t * Hence we need to clean the page to clean the pte and so a new write\n\t * fault will be triggered appropriately.\n\t *\n\t * If we do it before we change the inode size, then we can race with a\n\t * page fault that maps the page with exactly the same problem. If we do\n\t * it after we change the file size, then a new page fault can come in\n\t * and allocate space before we've run the rest of the truncate\n\t * transaction. That's kinda grotesque, but it's better than have data\n\t * over a hole, and so that's the lesser evil that has been chosen here.\n\t *\n\t * The real solution, however, is to have some mechanism for locking out\n\t * page faults while a truncate is in progress.\n\t */\n\tif (newsize > oldsize && mapping_mapped(VFS_I(ip)->i_mapping)) {\n\t\terror = filemap_write_and_wait_range(\n\t\t\t\tVFS_I(ip)->i_mapping,\n\t\t\t\tround_down(oldsize, PAGE_CACHE_SIZE),\n\t\t\t\tround_up(oldsize, PAGE_CACHE_SIZE) - 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\tcommit_flags = XFS_TRANS_RELEASE_LOG_RES;\n\tlock_flags |= XFS_ILOCK_EXCL;\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Only change the c/mtime if we are changing the size or we are\n\t * explicitly asked to change it.  This handles the semantic difference\n\t * between truncate() and ftruncate() as implemented in the VFS.\n\t *\n\t * The regular truncate() case without ATTR_CTIME and ATTR_MTIME is a\n\t * special case where we need to update the times despite not having\n\t * these flags set.  For all other operations the VFS set these flags\n\t * explicitly if it wants a timestamp update.\n\t */\n\tif (newsize != oldsize &&\n\t    !(iattr->ia_valid & (ATTR_CTIME | ATTR_MTIME))) {\n\t\tiattr->ia_ctime = iattr->ia_mtime =\n\t\t\tcurrent_fs_time(inode->i_sb);\n\t\tiattr->ia_valid |= ATTR_CTIME | ATTR_MTIME;\n\t}\n\n\t/*\n\t * The first thing we do is set the size to new_size permanently on\n\t * disk.  This way we don't have to worry about anyone ever being able\n\t * to look at the data being freed even in the face of a crash.\n\t * What we're getting around here is the case where we free a block, it\n\t * is allocated to another file, it is written to, and then we crash.\n\t * If the new data gets written to the file but the log buffers\n\t * containing the free and reallocation don't, then we'd end up with\n\t * garbage in the blocks being freed.  As long as we make the new size\n\t * permanent before actually freeing any blocks it doesn't matter if\n\t * they get written to.\n\t */\n\tip->i_d.di_size = newsize;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tif (newsize <= oldsize) {\n\t\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, newsize);\n\t\tif (error)\n\t\t\tgoto out_trans_abort;\n\n\t\t/*\n\t\t * Truncated \"down\", so we're removing references to old data\n\t\t * here - if we delay flushing for a long time, we expose\n\t\t * ourselves unduly to the notorious NULL files problem.  So,\n\t\t * we mark this inode and flush it when the file is closed,\n\t\t * and do not wait the usual (long) time for writeout.\n\t\t */\n\t\txfs_iflags_set(ip, XFS_ITRUNCATED);\n\n\t\t/* A truncate down always removes post-EOF blocks. */\n\t\txfs_inode_clear_eofblocks_tag(ip);\n\t}\n\n\tif (iattr->ia_valid & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (iattr->ia_valid & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\nout_unlock:\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\n\treturn error;\n\nout_trans_abort:\n\tcommit_flags |= XFS_TRANS_ABORT;\nout_trans_cancel:\n\txfs_trans_cancel(tp, commit_flags);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_setattr_size(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\txfs_off_t\t\toldsize, newsize;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\tuint\t\t\tlock_flags = 0;\n\tuint\t\t\tcommit_flags = 0;\n\tbool\t\t\tdid_zeroing = false;\n\n\ttrace_xfs_setattr(ip);\n\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn -EROFS;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = inode_change_ok(inode, iattr);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(S_ISREG(ip->i_d.di_mode));\n\tASSERT((iattr->ia_valid & (ATTR_UID|ATTR_GID|ATTR_ATIME|ATTR_ATIME_SET|\n\t\tATTR_MTIME_SET|ATTR_KILL_PRIV|ATTR_TIMES_SET)) == 0);\n\n\toldsize = inode->i_size;\n\tnewsize = iattr->ia_size;\n\n\t/*\n\t * Short circuit the truncate case for zero length files.\n\t */\n\tif (newsize == 0 && oldsize == 0 && ip->i_d.di_nextents == 0) {\n\t\tif (!(iattr->ia_valid & (ATTR_CTIME|ATTR_MTIME)))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Use the regular setattr path to update the timestamps.\n\t\t */\n\t\tiattr->ia_valid &= ~ATTR_SIZE;\n\t\treturn xfs_setattr_nonsize(ip, iattr, 0);\n\t}\n\n\t/*\n\t * Make sure that the dquots are attached to the inode.\n\t */\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * File data changes must be complete before we start the transaction to\n\t * modify the inode.  This needs to be done before joining the inode to\n\t * the transaction because the inode cannot be unlocked once it is a\n\t * part of the transaction.\n\t *\n\t * Start with zeroing any data block beyond EOF that we may expose on\n\t * file extension.\n\t */\n\tif (newsize > oldsize) {\n\t\terror = xfs_zero_eof(ip, newsize, oldsize, &did_zeroing);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We are going to log the inode size change in this transaction so\n\t * any previous writes that are beyond the on disk EOF and the new\n\t * EOF that have not been written out need to be written here.  If we\n\t * do not write the data out, we expose ourselves to the null files\n\t * problem. Note that this includes any block zeroing we did above;\n\t * otherwise those blocks may not be zeroed after a crash.\n\t */\n\tif (newsize > ip->i_d.di_size &&\n\t    (oldsize != ip->i_d.di_size || did_zeroing)) {\n\t\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t\t      ip->i_d.di_size, newsize);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* Now wait for all direct I/O to complete. */\n\tinode_dio_wait(inode);\n\n\t/*\n\t * Do all the page cache truncate work outside the transaction context\n\t * as the \"lock\" order is page lock->log space reservation.  i.e.\n\t * locking pages inside the transaction can ABBA deadlock with\n\t * writeback. We have to do the VFS inode size update before we truncate\n\t * the pagecache, however, to avoid racing with page faults beyond the\n\t * new EOF they are not serialised against truncate operations except by\n\t * page locks and size updates.\n\t *\n\t * Hence we are in a situation where a truncate can fail with ENOMEM\n\t * from xfs_trans_reserve(), but having already truncated the in-memory\n\t * version of the file (i.e. made user visible changes). There's not\n\t * much we can do about this, except to hope that the caller sees ENOMEM\n\t * and retries the truncate operation.\n\t */\n\terror = block_truncate_page(inode->i_mapping, newsize, xfs_get_blocks);\n\tif (error)\n\t\treturn error;\n\ttruncate_setsize(inode, newsize);\n\n\t/*\n\t * The \"we can't serialise against page faults\" pain gets worse.\n\t *\n\t * If the file is mapped then we have to clean the page at the old EOF\n\t * when extending the file. Extending the file can expose changes the\n\t * underlying page mapping (e.g. from beyond EOF to a hole or\n\t * unwritten), and so on the next attempt to write to that page we need\n\t * to remap it for write. i.e. we need .page_mkwrite() to be called.\n\t * Hence we need to clean the page to clean the pte and so a new write\n\t * fault will be triggered appropriately.\n\t *\n\t * If we do it before we change the inode size, then we can race with a\n\t * page fault that maps the page with exactly the same problem. If we do\n\t * it after we change the file size, then a new page fault can come in\n\t * and allocate space before we've run the rest of the truncate\n\t * transaction. That's kinda grotesque, but it's better than have data\n\t * over a hole, and so that's the lesser evil that has been chosen here.\n\t *\n\t * The real solution, however, is to have some mechanism for locking out\n\t * page faults while a truncate is in progress.\n\t */\n\tif (newsize > oldsize && mapping_mapped(VFS_I(ip)->i_mapping)) {\n\t\terror = filemap_write_and_wait_range(\n\t\t\t\tVFS_I(ip)->i_mapping,\n\t\t\t\tround_down(oldsize, PAGE_CACHE_SIZE),\n\t\t\t\tround_up(oldsize, PAGE_CACHE_SIZE) - 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\tcommit_flags = XFS_TRANS_RELEASE_LOG_RES;\n\tlock_flags |= XFS_ILOCK_EXCL;\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Only change the c/mtime if we are changing the size or we are\n\t * explicitly asked to change it.  This handles the semantic difference\n\t * between truncate() and ftruncate() as implemented in the VFS.\n\t *\n\t * The regular truncate() case without ATTR_CTIME and ATTR_MTIME is a\n\t * special case where we need to update the times despite not having\n\t * these flags set.  For all other operations the VFS set these flags\n\t * explicitly if it wants a timestamp update.\n\t */\n\tif (newsize != oldsize &&\n\t    !(iattr->ia_valid & (ATTR_CTIME | ATTR_MTIME))) {\n\t\tiattr->ia_ctime = iattr->ia_mtime =\n\t\t\tcurrent_fs_time(inode->i_sb);\n\t\tiattr->ia_valid |= ATTR_CTIME | ATTR_MTIME;\n\t}\n\n\t/*\n\t * The first thing we do is set the size to new_size permanently on\n\t * disk.  This way we don't have to worry about anyone ever being able\n\t * to look at the data being freed even in the face of a crash.\n\t * What we're getting around here is the case where we free a block, it\n\t * is allocated to another file, it is written to, and then we crash.\n\t * If the new data gets written to the file but the log buffers\n\t * containing the free and reallocation don't, then we'd end up with\n\t * garbage in the blocks being freed.  As long as we make the new size\n\t * permanent before actually freeing any blocks it doesn't matter if\n\t * they get written to.\n\t */\n\tip->i_d.di_size = newsize;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tif (newsize <= oldsize) {\n\t\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, newsize);\n\t\tif (error)\n\t\t\tgoto out_trans_abort;\n\n\t\t/*\n\t\t * Truncated \"down\", so we're removing references to old data\n\t\t * here - if we delay flushing for a long time, we expose\n\t\t * ourselves unduly to the notorious NULL files problem.  So,\n\t\t * we mark this inode and flush it when the file is closed,\n\t\t * and do not wait the usual (long) time for writeout.\n\t\t */\n\t\txfs_iflags_set(ip, XFS_ITRUNCATED);\n\n\t\t/* A truncate down always removes post-EOF blocks. */\n\t\txfs_inode_clear_eofblocks_tag(ip);\n\t}\n\n\tif (iattr->ia_valid & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (iattr->ia_valid & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\nout_unlock:\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\n\treturn error;\n\nout_trans_abort:\n\tcommit_flags |= XFS_TRANS_ABORT;\nout_trans_cancel:\n\txfs_trans_cancel(tp, commit_flags);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "at_sqn",
          "args": [
            "m    %llu\\n\", ui->creat_s",
            "um);\n\tpr_err(\"\\"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "me",
          "args": [
            "%u.%u\\n\",\n\t       (un",
            ")inode->i_ctime.tv_sec,\n\t       (un",
            ")inode->i_ctime.tv_nsec);\n\tpr_err(\"\\"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "hes_name(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
          "lines": "809-855",
          "snippet": "llible_matches_name(struct ubifs_info *c,\n\t\t\t\t struct ubifs_zbranch *zbr,\n\t\t\t\t const struct qstr *nm)\n{\n\tstruct ubifs_dent_node *dent;\n\tint nlen, err;\n\n\t/* If possible, match against the dent in the leaf node cache */\n\tif (!zbr->leaf) {\n\t\tdent = kmalloc(zbr->len, GFP_NOFS);\n\t\tif (!dent)\n\t\t\treturn -ENOMEM;\n\n\t\terr = fallible_read_node(c, &zbr->key, zbr, dent);\n\t\tif (err < 0)\n\t\t\tgoto out_free;\n\t\tif (err == 0) {\n\t\t\t/* The node was not present */\n\t\t\terr = NOT_ON_MEDIA;\n\t\t\tgoto out_free;\n\t\t}\n\t\tubifs_assert(err == 1);\n\n\t\terr = lnc_add_directly(c, zbr, dent);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t} else\n\t\tdent = zbr->leaf;\n\n\tnlen = le16_to_cpu(dent->nlen);\n\terr = memcmp(dent->name, nm->name, min_t(int, nlen, nm->len));\n\tif (err == 0) {\n\t\tif (nlen == nm->len)\n\t\t\treturn NAME_MATCHES;\n\t\telse if (nlen < nm->len)\n\t\t\treturn NAME_LESS;\n\t\telse\n\t\t\treturn NAME_GREATER;\n\t} else if (err < 0)\n\t\treturn NAME_LESS;\n\telse\n\t\treturn NAME_GREATER;\n\nout_free:\n\tkfree(dent);\n\treturn err;\n}\n\n/**\n * fall",
          "includes": [
            "fs.h\"\n\n/*\n * Return",
            "ux/slab.h>\n#include \"ubi",
            "ux/crc32.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nllible_matches_name(struct ubifs_info *c,\n\t\t\t\t struct ubifs_zbranch *zbr,\n\t\t\t\t const struct qstr *nm)\n{\n\tstruct ubifs_dent_node *dent;\n\tint nlen, err;\n\n\t/* If possible, match against the dent in the leaf node cache */\n\tif (!zbr->leaf) {\n\t\tdent = kmalloc(zbr->len, GFP_NOFS);\n\t\tif (!dent)\n\t\t\treturn -ENOMEM;\n\n\t\terr = fallible_read_node(c, &zbr->key, zbr, dent);\n\t\tif (err < 0)\n\t\t\tgoto out_free;\n\t\tif (err == 0) {\n\t\t\t/* The node was not present */\n\t\t\terr = NOT_ON_MEDIA;\n\t\t\tgoto out_free;\n\t\t}\n\t\tubifs_assert(err == 1);\n\n\t\terr = lnc_add_directly(c, zbr, dent);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t} else\n\t\tdent = zbr->leaf;\n\n\tnlen = le16_to_cpu(dent->nlen);\n\terr = memcmp(dent->name, nm->name, min_t(int, nlen, nm->len));\n\tif (err == 0) {\n\t\tif (nlen == nm->len)\n\t\t\treturn NAME_MATCHES;\n\t\telse if (nlen < nm->len)\n\t\t\treturn NAME_LESS;\n\t\telse\n\t\t\treturn NAME_GREATER;\n\t} else if (err < 0)\n\t\treturn NAME_LESS;\n\telse\n\t\treturn NAME_GREATER;\n\nout_free:\n\tkfree(dent);\n\treturn err;\n}\n\n/**\n * fall"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "%u\\n\", (unsigned i",
            ")i_gid_read(inode));\n\tpr_err(\"\\"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode));\n\tpr",
          "args": [
            "err(\""
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "%u\\n\", (unsigned i",
            ")i_uid_read(inode));\n\tpr_err(\"\\"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode));\n\tpr",
          "args": [
            "err(\""
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nk",
          "args": [
            "%u\\n\", inode->i_nl",
            "k);\n\tpr_err(\"\\"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "link(struct dentr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
          "lines": "1303-1309",
          "snippet": "ubifs_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct ubifs_inode *ui = ubifs_inode(dentry->d_inode);\n\n\tnd_set_link(nd, ui->data);\n\treturn NULL;\n}\n\nint ubifs_f",
          "includes": [
            "ux/slab.h>\n\nstatic int r",
            "ux/namei.h>\n#include <lin",
            "ux/mount.h>\n#include <lin",
            "ux/aio.h>\n#include <lin",
            "fs.h\"\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nubifs_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct ubifs_inode *ui = ubifs_inode(dentry->d_inode);\n\n\tnd_set_link(nd, ui->data);\n\treturn NULL;\n}\n\nint ubifs_f"
        }
      },
      {
        "call_info": {
          "callee": "node));\n\tpr",
          "args": [
            "err(\""
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in-mem",
          "args": [
            "ry inode:\");\n\tpr_err(\"\\"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\tstr",
          "args": [
            "ct qs"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nmp_inode(struct ubifs_info *c, const struct inode *inode)\n{\n\tconst struct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct qstr nm = { .name = NULL };\n\tunion ubifs_key key;\n\tstruct ubifs_dent_node *dent, *pdent = NULL;\n\tint count = 2;\n\n\tpr_err(\"Dump in-memory inode:\");\n\tpr_err(\"\\tinode          %lu\\n\", inode->i_ino);\n\tpr_err(\"\\tsize           %llu\\n\",\n\t       (unsigned long long)i_size_read(inode));\n\tpr_err(\"\\tnlink          %u\\n\", inode->i_nlink);\n\tpr_err(\"\\tuid            %u\\n\", (unsigned int)i_uid_read(inode));\n\tpr_err(\"\\tgid            %u\\n\", (unsigned int)i_gid_read(inode));\n\tpr_err(\"\\tatime          %u.%u\\n\",\n\t       (unsigned int)inode->i_atime.tv_sec,\n\t       (unsigned int)inode->i_atime.tv_nsec);\n\tpr_err(\"\\tmtime          %u.%u\\n\",\n\t       (unsigned int)inode->i_mtime.tv_sec,\n\t       (unsigned int)inode->i_mtime.tv_nsec);\n\tpr_err(\"\\tctime          %u.%u\\n\",\n\t       (unsigned int)inode->i_ctime.tv_sec,\n\t       (unsigned int)inode->i_ctime.tv_nsec);\n\tpr_err(\"\\tcreat_sqnum    %llu\\n\", ui->creat_sqnum);\n\tpr_err(\"\\txattr_size     %u\\n\", ui->xattr_size);\n\tpr_err(\"\\txattr_cnt      %u\\n\", ui->xattr_cnt);\n\tpr_err(\"\\txattr_names    %u\\n\", ui->xattr_names);\n\tpr_err(\"\\tdirty          %u\\n\", ui->dirty);\n\tpr_err(\"\\txattr          %u\\n\", ui->xattr);\n\tpr_err(\"\\tbulk_read      %u\\n\", ui->xattr);\n\tpr_err(\"\\tsynced_i_size  %llu\\n\",\n\t       (unsigned long long)ui->synced_i_size);\n\tpr_err(\"\\tui_size        %llu\\n\",\n\t       (unsigned long long)ui->ui_size);\n\tpr_err(\"\\tflags          %d\\n\", ui->flags);\n\tpr_err(\"\\tcompr_type     %d\\n\", ui->compr_type);\n\tpr_err(\"\\tlast_page_read %lu\\n\", ui->last_page_read);\n\tpr_err(\"\\tread_in_a_row  %lu\\n\", ui->read_in_a_row);\n\tpr_err(\"\\tdata_len       %d\\n\", ui->data_len);\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tpr_err(\"List of directory entries:\\n\");\n\tubifs_assert(!mutex_is_locked(&c->tnc_mutex));\n\n\tlowest_dent_key(c, &key, inode->i_ino);\n\twhile (1) {\n\t\tdent = ubifs_tnc_next_ent(c, &key, &nm);\n\t\tif (IS_ERR(dent)) {\n\t\t\tif (PTR_ERR(dent) != -ENOENT)\n\t\t\t\tpr_err(\"error %ld\\n\", PTR_ERR(dent));\n\t\t\tbreak;\n\t\t}\n\n\t\tpr_err(\"\\t%d: %s (%s)\\n\",\n\t\t       count++, dent->name, get_dent_type(dent->type));\n\n\t\tnm.name = dent->name;\n\t\tnm.len = le16_to_cpu(dent->nlen);\n\t\tkfree(pdent);\n\t\tpdent = dent;\n\t\tkey_read(c, &dent->key, &key);\n\t}\n\tkfree(pdent);\n}\n\nvoid ubifs_"
  },
  {
    "function_name": "struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "220-231",
    "snippet": "ump_ch(const struct ubifs_ch *ch)\n{\n\tpr_err(\"\\tmagic          %#x\\n\", le32_to_cpu(ch->magic));\n\tpr_err(\"\\tcrc            %#x\\n\", le32_to_cpu(ch->crc));\n\tpr_err(\"\\tnode_type      %d (%s)\\n\", ch->node_type,\n\t       dbg_ntype(ch->node_type));\n\tpr_err(\"\\tgroup_type     %d (%s)\\n\", ch->group_type,\n\t       dbg_gtype(ch->group_type));\n\tpr_err(\"\\tsqnum          %llu\\n\",\n\t       (unsigned long long)le64_to_cpu(ch->sqnum));\n\tpr_err(\"\\tlen            %u\\n\", le32_to_cpu(ch->len));\n}\n\nvoid ubifs_",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "%u\\n\", le32_to_cpu",
            "h->len));\n}\n\nvoid ub"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->len));\n}",
          "args": [
            "void u"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "um",
          "args": [
            "%llu\\n\",\n\t       (un",
            "g long)le64_to_cpu(ch->sqnum));\n\tpr_err(\"\\"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "jffs2_dbg_dump_node(s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/debug.c",
          "lines": "772-865",
          "snippet": "id\n__jffs2_dbg_dump_node(struct jffs2_sb_info *c, uint32_t ofs)\n{\n\tunion jffs2_node_union node;\n\tint len = sizeof(union jffs2_node_union);\n\tsize_t retlen;\n\tuint32_t crc;\n\tint ret;\n\n\tprintk(JFFS2_DBG_MSG_PREFIX \" dump node at offset %#08x.\\n\", ofs);\n\n\tret = jffs2_flash_read(c, ofs, len, &retlen, (unsigned char *)&node);\n\tif (ret || (retlen != len)) {\n\t\tJFFS2_ERROR(\"read %d bytes failed or short. ret %d, retlen %zd.\\n\",\n\t\t\tlen, ret, retlen);\n\t\treturn;\n\t}\n\n\tprintk(JFFS2_DBG \"magic:\\t%#04x\\n\", je16_to_cpu(node.u.magic));\n\tprintk(JFFS2_DBG \"nodetype:\\t%#04x\\n\", je16_to_cpu(node.u.nodetype));\n\tprintk(JFFS2_DBG \"totlen:\\t%#08x\\n\", je32_to_cpu(node.u.totlen));\n\tprintk(JFFS2_DBG \"hdr_crc:\\t%#08x\\n\", je32_to_cpu(node.u.hdr_crc));\n\n\tcrc = crc32(0, &node.u, sizeof(node.u) - 4);\n\tif (crc != je32_to_cpu(node.u.hdr_crc)) {\n\t\tJFFS2_ERROR(\"wrong common header CRC.\\n\");\n\t\treturn;\n\t}\n\n\tif (je16_to_cpu(node.u.magic) != JFFS2_MAGIC_BITMASK &&\n\t\tje16_to_cpu(node.u.magic) != JFFS2_OLD_MAGIC_BITMASK)\n\t{\n\t\tJFFS2_ERROR(\"wrong node magic: %#04x instead of %#04x.\\n\",\n\t\t\tje16_to_cpu(node.u.magic), JFFS2_MAGIC_BITMASK);\n\t\treturn;\n\t}\n\n\tswitch(je16_to_cpu(node.u.nodetype)) {\n\n\tcase JFFS2_NODETYPE_INODE:\n\n\t\tprintk(JFFS2_DBG \"the node is inode node\\n\");\n\t\tprintk(JFFS2_DBG \"ino:\\t%#08x\\n\", je32_to_cpu(node.i.ino));\n\t\tprintk(JFFS2_DBG \"version:\\t%#08x\\n\", je32_to_cpu(node.i.version));\n\t\tprintk(JFFS2_DBG \"mode:\\t%#08x\\n\", node.i.mode.m);\n\t\tprintk(JFFS2_DBG \"uid:\\t%#04x\\n\", je16_to_cpu(node.i.uid));\n\t\tprintk(JFFS2_DBG \"gid:\\t%#04x\\n\", je16_to_cpu(node.i.gid));\n\t\tprintk(JFFS2_DBG \"isize:\\t%#08x\\n\", je32_to_cpu(node.i.isize));\n\t\tprintk(JFFS2_DBG \"atime:\\t%#08x\\n\", je32_to_cpu(node.i.atime));\n\t\tprintk(JFFS2_DBG \"mtime:\\t%#08x\\n\", je32_to_cpu(node.i.mtime));\n\t\tprintk(JFFS2_DBG \"ctime:\\t%#08x\\n\", je32_to_cpu(node.i.ctime));\n\t\tprintk(JFFS2_DBG \"offset:\\t%#08x\\n\", je32_to_cpu(node.i.offset));\n\t\tprintk(JFFS2_DBG \"csize:\\t%#08x\\n\", je32_to_cpu(node.i.csize));\n\t\tprintk(JFFS2_DBG \"dsize:\\t%#08x\\n\", je32_to_cpu(node.i.dsize));\n\t\tprintk(JFFS2_DBG \"compr:\\t%#02x\\n\", node.i.compr);\n\t\tprintk(JFFS2_DBG \"usercompr:\\t%#02x\\n\", node.i.usercompr);\n\t\tprintk(JFFS2_DBG \"flags:\\t%#04x\\n\", je16_to_cpu(node.i.flags));\n\t\tprintk(JFFS2_DBG \"data_crc:\\t%#08x\\n\", je32_to_cpu(node.i.data_crc));\n\t\tprintk(JFFS2_DBG \"node_crc:\\t%#08x\\n\", je32_to_cpu(node.i.node_crc));\n\n\t\tcrc = crc32(0, &node.i, sizeof(node.i) - 8);\n\t\tif (crc != je32_to_cpu(node.i.node_crc)) {\n\t\t\tJFFS2_ERROR(\"wrong node header CRC.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase JFFS2_NODETYPE_DIRENT:\n\n\t\tprintk(JFFS2_DBG \"the node is dirent node\\n\");\n\t\tprintk(JFFS2_DBG \"pino:\\t%#08x\\n\", je32_to_cpu(node.d.pino));\n\t\tprintk(JFFS2_DBG \"version:\\t%#08x\\n\", je32_to_cpu(node.d.version));\n\t\tprintk(JFFS2_DBG \"ino:\\t%#08x\\n\", je32_to_cpu(node.d.ino));\n\t\tprintk(JFFS2_DBG \"mctime:\\t%#08x\\n\", je32_to_cpu(node.d.mctime));\n\t\tprintk(JFFS2_DBG \"nsize:\\t%#02x\\n\", node.d.nsize);\n\t\tprintk(JFFS2_DBG \"type:\\t%#02x\\n\", node.d.type);\n\t\tprintk(JFFS2_DBG \"node_crc:\\t%#08x\\n\", je32_to_cpu(node.d.node_crc));\n\t\tprintk(JFFS2_DBG \"name_crc:\\t%#08x\\n\", je32_to_cpu(node.d.name_crc));\n\n\t\tnode.d.name[node.d.nsize] = '\\0';\n\t\tprintk(JFFS2_DBG \"name:\\t\\\"%s\\\"\\n\", node.d.name);\n\n\t\tcrc = crc32(0, &node.d, sizeof(node.d) - 8);\n\t\tif (crc != je32_to_cpu(node.d.node_crc)) {\n\t\t\tJFFS2_ERROR(\"wrong node header CRC.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(JFFS2_DBG \"node type is unknown\\n\");\n\t\tbreak;\n\t}\n}\n#",
          "includes": [
            "nclude \"debug.h\"\n\n#",
            "nclude \"nodelist.h\"\n#i",
            "nclude <linux/slab.h>\n#i",
            "nclude <linux/mtd/mtd.h>\n#i",
            "nclude <linux/jffs2.h>\n#i",
            "nclude <linux/crc32.h>\n#i",
            "nclude <linux/pagemap.h>\n#i",
            "nclude <linux/types.h>\n#i",
            "nclude <linux/kernel.h>\n#i"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "nclude \"debug.h\"\n\n#\nnclude \"nodelist.h\"\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/jffs2.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/types.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nid\n__jffs2_dbg_dump_node(struct jffs2_sb_info *c, uint32_t ofs)\n{\n\tunion jffs2_node_union node;\n\tint len = sizeof(union jffs2_node_union);\n\tsize_t retlen;\n\tuint32_t crc;\n\tint ret;\n\n\tprintk(JFFS2_DBG_MSG_PREFIX \" dump node at offset %#08x.\\n\", ofs);\n\n\tret = jffs2_flash_read(c, ofs, len, &retlen, (unsigned char *)&node);\n\tif (ret || (retlen != len)) {\n\t\tJFFS2_ERROR(\"read %d bytes failed or short. ret %d, retlen %zd.\\n\",\n\t\t\tlen, ret, retlen);\n\t\treturn;\n\t}\n\n\tprintk(JFFS2_DBG \"magic:\\t%#04x\\n\", je16_to_cpu(node.u.magic));\n\tprintk(JFFS2_DBG \"nodetype:\\t%#04x\\n\", je16_to_cpu(node.u.nodetype));\n\tprintk(JFFS2_DBG \"totlen:\\t%#08x\\n\", je32_to_cpu(node.u.totlen));\n\tprintk(JFFS2_DBG \"hdr_crc:\\t%#08x\\n\", je32_to_cpu(node.u.hdr_crc));\n\n\tcrc = crc32(0, &node.u, sizeof(node.u) - 4);\n\tif (crc != je32_to_cpu(node.u.hdr_crc)) {\n\t\tJFFS2_ERROR(\"wrong common header CRC.\\n\");\n\t\treturn;\n\t}\n\n\tif (je16_to_cpu(node.u.magic) != JFFS2_MAGIC_BITMASK &&\n\t\tje16_to_cpu(node.u.magic) != JFFS2_OLD_MAGIC_BITMASK)\n\t{\n\t\tJFFS2_ERROR(\"wrong node magic: %#04x instead of %#04x.\\n\",\n\t\t\tje16_to_cpu(node.u.magic), JFFS2_MAGIC_BITMASK);\n\t\treturn;\n\t}\n\n\tswitch(je16_to_cpu(node.u.nodetype)) {\n\n\tcase JFFS2_NODETYPE_INODE:\n\n\t\tprintk(JFFS2_DBG \"the node is inode node\\n\");\n\t\tprintk(JFFS2_DBG \"ino:\\t%#08x\\n\", je32_to_cpu(node.i.ino));\n\t\tprintk(JFFS2_DBG \"version:\\t%#08x\\n\", je32_to_cpu(node.i.version));\n\t\tprintk(JFFS2_DBG \"mode:\\t%#08x\\n\", node.i.mode.m);\n\t\tprintk(JFFS2_DBG \"uid:\\t%#04x\\n\", je16_to_cpu(node.i.uid));\n\t\tprintk(JFFS2_DBG \"gid:\\t%#04x\\n\", je16_to_cpu(node.i.gid));\n\t\tprintk(JFFS2_DBG \"isize:\\t%#08x\\n\", je32_to_cpu(node.i.isize));\n\t\tprintk(JFFS2_DBG \"atime:\\t%#08x\\n\", je32_to_cpu(node.i.atime));\n\t\tprintk(JFFS2_DBG \"mtime:\\t%#08x\\n\", je32_to_cpu(node.i.mtime));\n\t\tprintk(JFFS2_DBG \"ctime:\\t%#08x\\n\", je32_to_cpu(node.i.ctime));\n\t\tprintk(JFFS2_DBG \"offset:\\t%#08x\\n\", je32_to_cpu(node.i.offset));\n\t\tprintk(JFFS2_DBG \"csize:\\t%#08x\\n\", je32_to_cpu(node.i.csize));\n\t\tprintk(JFFS2_DBG \"dsize:\\t%#08x\\n\", je32_to_cpu(node.i.dsize));\n\t\tprintk(JFFS2_DBG \"compr:\\t%#02x\\n\", node.i.compr);\n\t\tprintk(JFFS2_DBG \"usercompr:\\t%#02x\\n\", node.i.usercompr);\n\t\tprintk(JFFS2_DBG \"flags:\\t%#04x\\n\", je16_to_cpu(node.i.flags));\n\t\tprintk(JFFS2_DBG \"data_crc:\\t%#08x\\n\", je32_to_cpu(node.i.data_crc));\n\t\tprintk(JFFS2_DBG \"node_crc:\\t%#08x\\n\", je32_to_cpu(node.i.node_crc));\n\n\t\tcrc = crc32(0, &node.i, sizeof(node.i) - 8);\n\t\tif (crc != je32_to_cpu(node.i.node_crc)) {\n\t\t\tJFFS2_ERROR(\"wrong node header CRC.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase JFFS2_NODETYPE_DIRENT:\n\n\t\tprintk(JFFS2_DBG \"the node is dirent node\\n\");\n\t\tprintk(JFFS2_DBG \"pino:\\t%#08x\\n\", je32_to_cpu(node.d.pino));\n\t\tprintk(JFFS2_DBG \"version:\\t%#08x\\n\", je32_to_cpu(node.d.version));\n\t\tprintk(JFFS2_DBG \"ino:\\t%#08x\\n\", je32_to_cpu(node.d.ino));\n\t\tprintk(JFFS2_DBG \"mctime:\\t%#08x\\n\", je32_to_cpu(node.d.mctime));\n\t\tprintk(JFFS2_DBG \"nsize:\\t%#02x\\n\", node.d.nsize);\n\t\tprintk(JFFS2_DBG \"type:\\t%#02x\\n\", node.d.type);\n\t\tprintk(JFFS2_DBG \"node_crc:\\t%#08x\\n\", je32_to_cpu(node.d.node_crc));\n\t\tprintk(JFFS2_DBG \"name_crc:\\t%#08x\\n\", je32_to_cpu(node.d.name_crc));\n\n\t\tnode.d.name[node.d.nsize] = '\\0';\n\t\tprintk(JFFS2_DBG \"name:\\t\\\"%s\\\"\\n\", node.d.name);\n\n\t\tcrc = crc32(0, &node.d, sizeof(node.d) - 8);\n\t\tif (crc != je32_to_cpu(node.d.node_crc)) {\n\t\t\tJFFS2_ERROR(\"wrong node header CRC.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(JFFS2_DBG \"node type is unknown\\n\");\n\t\tbreak;\n\t}\n}\n#"
        }
      },
      {
        "call_info": {
          "callee": "h->sqnum));",
          "args": [
            "pr_err(\""
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_typ",
          "args": [
            "%d (%s)\\n\", ch->group_t",
            "e,\n\t       dbg",
            ">group_type));\n\tpr_err(\"\\"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">group_ty",
          "args": [
            "e));\n\tpr_err(\""
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_type",
          "args": [
            "%d (%s)\\n\", ch->node_ty",
            ",\n\t       dbg",
            ">node_type));\n\tpr_err(\"\\"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_set_de_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "154-188",
          "snippet": "static inline void\nufs_set_de_type(struct super_block *sb, struct ufs_dir_entry *de, int mode)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) != UFS_DE_44BSD)\n\t\treturn;\n\n\t/*\n\t * TODO turn this into a table lookup\n\t */\n\tswitch (mode & S_IFMT) {\n\tcase S_IFSOCK:\n\t\tde->d_u.d_44.d_type = DT_SOCK;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tde->d_u.d_44.d_type = DT_LNK;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tde->d_u.d_44.d_type = DT_REG;\n\t\tbreak;\n\tcase S_IFBLK:\n\t\tde->d_u.d_44.d_type = DT_BLK;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tde->d_u.d_44.d_type = DT_DIR;\n\t\tbreak;\n\tcase S_IFCHR:\n\t\tde->d_u.d_44.d_type = DT_CHR;\n\t\tbreak;\n\tcase S_IFIFO:\n\t\tde->d_u.d_44.d_type = DT_FIFO;\n\t\tbreak;\n\tdefault:\n\t\tde->d_u.d_44.d_type = DT_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline void\nufs_set_de_type(struct super_block *sb, struct ufs_dir_entry *de, int mode)\n{\n\tif ((UFS_SB(sb)->s_flags & UFS_DE_MASK) != UFS_DE_44BSD)\n\t\treturn;\n\n\t/*\n\t * TODO turn this into a table lookup\n\t */\n\tswitch (mode & S_IFMT) {\n\tcase S_IFSOCK:\n\t\tde->d_u.d_44.d_type = DT_SOCK;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tde->d_u.d_44.d_type = DT_LNK;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tde->d_u.d_44.d_type = DT_REG;\n\t\tbreak;\n\tcase S_IFBLK:\n\t\tde->d_u.d_44.d_type = DT_BLK;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tde->d_u.d_44.d_type = DT_DIR;\n\t\tbreak;\n\tcase S_IFCHR:\n\t\tde->d_u.d_44.d_type = DT_CHR;\n\t\tbreak;\n\tcase S_IFIFO:\n\t\tde->d_u.d_44.d_type = DT_FIFO;\n\t\tbreak;\n\tdefault:\n\t\tde->d_u.d_44.d_type = DT_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": ">node_typ",
          "args": [
            "));\n\tpr_err(\""
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "%#x\\n\", le32_to_cpu",
            "h->crc));\n\tpr_err(\"\\"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->crc));",
          "args": [
            "r_err(\""
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ic",
          "args": [
            "%#x\\n\", le32_to_cpu",
            "h->magic));\n\tpr_err(\"\\"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "blk_to_logical",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ioctl.c",
          "lines": "225-228",
          "snippet": "static inline loff_t blk_to_logical(struct inode *inode, sector_t blk)\n{\n\treturn (blk << inode->i_blkbits);\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic inline loff_t blk_to_logical(struct inode *inode, sector_t blk)\n{\n\treturn (blk << inode->i_blkbits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "h->magic));",
          "args": [
            "pr_err(\""
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nump_ch(const struct ubifs_ch *ch)\n{\n\tpr_err(\"\\tmagic          %#x\\n\", le32_to_cpu(ch->magic));\n\tpr_err(\"\\tcrc            %#x\\n\", le32_to_cpu(ch->crc));\n\tpr_err(\"\\tnode_type      %d (%s)\\n\", ch->node_type,\n\t       dbg_ntype(ch->node_type));\n\tpr_err(\"\\tgroup_type     %d (%s)\\n\", ch->group_type,\n\t       dbg_gtype(ch->group_type));\n\tpr_err(\"\\tsqnum          %llu\\n\",\n\t       (unsigned long long)le64_to_cpu(ch->sqnum));\n\tpr_err(\"\\tlen            %u\\n\", le32_to_cpu(ch->len));\n}\n\nvoid ubifs_"
  },
  {
    "function_name": "jhead)\n{",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "206-218",
    "snippet": "bg_jhead(int jhead)\n{\n\tswitch (jhead) {\n\tcase GCHD:\n\t\treturn \"0 (GC)\";\n\tcase BASEHD:\n\t\treturn \"1 (base)\";\n\tcase DATAHD:\n\t\treturn \"2 (data)\";\n\tdefault:\n\t\treturn \"unknown journal head\";\n\t}\n}\n\nstatic void",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nbg_jhead(int jhead)\n{\n\tswitch (jhead) {\n\tcase GCHD:\n\t\treturn \"0 (GC)\";\n\tcase BASEHD:\n\t\treturn \"1 (base)\";\n\tcase DATAHD:\n\t\treturn \"2 (data)\";\n\tdefault:\n\t\treturn \"unknown journal head\";\n\t}\n}\n\nstatic void"
  },
  {
    "function_name": "t cmt_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "186-204",
    "snippet": "bg_cstate(int cmt_state)\n{\n\tswitch (cmt_state) {\n\tcase COMMIT_RESTING:\n\t\treturn \"commit resting\";\n\tcase COMMIT_BACKGROUND:\n\t\treturn \"background commit requested\";\n\tcase COMMIT_REQUIRED:\n\t\treturn \"commit required\";\n\tcase COMMIT_RUNNING_BACKGROUND:\n\t\treturn \"BACKGROUND commit running\";\n\tcase COMMIT_RUNNING_REQUIRED:\n\t\treturn \"commit running and required\";\n\tcase COMMIT_BROKEN:\n\t\treturn \"broken commit\";\n\tdefault:\n\t\treturn \"unknown commit state\";\n\t}\n}\n\nconst char",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nbg_cstate(int cmt_state)\n{\n\tswitch (cmt_state) {\n\tcase COMMIT_RESTING:\n\t\treturn \"commit resting\";\n\tcase COMMIT_BACKGROUND:\n\t\treturn \"background commit requested\";\n\tcase COMMIT_REQUIRED:\n\t\treturn \"commit required\";\n\tcase COMMIT_RUNNING_BACKGROUND:\n\t\treturn \"BACKGROUND commit running\";\n\tcase COMMIT_RUNNING_REQUIRED:\n\t\treturn \"commit running and required\";\n\tcase COMMIT_BROKEN:\n\t\treturn \"broken commit\";\n\tdefault:\n\t\treturn \"unknown commit state\";\n\t}\n}\n\nconst char"
  },
  {
    "function_name": "type)\n{",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "172-184",
    "snippet": "char *dbg_gtype(int type)\n{\n\tswitch (type) {\n\tcase UBIFS_NO_NODE_GROUP:\n\t\treturn \"no node group\";\n\tcase UBIFS_IN_NODE_GROUP:\n\t\treturn \"in node group\";\n\tcase UBIFS_LAST_OF_NODE_GROUP:\n\t\treturn \"last of node group\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nconst char",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nchar *dbg_gtype(int type)\n{\n\tswitch (type) {\n\tcase UBIFS_NO_NODE_GROUP:\n\t\treturn \"no node group\";\n\tcase UBIFS_IN_NODE_GROUP:\n\t\treturn \"in node group\";\n\tcase UBIFS_LAST_OF_NODE_GROUP:\n\t\treturn \"last of node group\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nconst char"
  },
  {
    "function_name": "type)\n{",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "140-170",
    "snippet": "bg_ntype(int type)\n{\n\tswitch (type) {\n\tcase UBIFS_PAD_NODE:\n\t\treturn \"padding node\";\n\tcase UBIFS_SB_NODE:\n\t\treturn \"superblock node\";\n\tcase UBIFS_MST_NODE:\n\t\treturn \"master node\";\n\tcase UBIFS_REF_NODE:\n\t\treturn \"reference node\";\n\tcase UBIFS_INO_NODE:\n\t\treturn \"inode node\";\n\tcase UBIFS_DENT_NODE:\n\t\treturn \"direntry node\";\n\tcase UBIFS_XENT_NODE:\n\t\treturn \"xentry node\";\n\tcase UBIFS_DATA_NODE:\n\t\treturn \"data node\";\n\tcase UBIFS_TRUN_NODE:\n\t\treturn \"truncate node\";\n\tcase UBIFS_IDX_NODE:\n\t\treturn \"indexing node\";\n\tcase UBIFS_CS_NODE:\n\t\treturn \"commit start node\";\n\tcase UBIFS_ORPH_NODE:\n\t\treturn \"orphan node\";\n\tdefault:\n\t\treturn \"unknown node\";\n\t}\n}\n\nstatic cons",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [
      "_SPINLOCK(dbg_lock);\n\nstatic cons"
    ],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\n_SPINLOCK(dbg_lock);\n\nstatic cons;\n\nbg_ntype(int type)\n{\n\tswitch (type) {\n\tcase UBIFS_PAD_NODE:\n\t\treturn \"padding node\";\n\tcase UBIFS_SB_NODE:\n\t\treturn \"superblock node\";\n\tcase UBIFS_MST_NODE:\n\t\treturn \"master node\";\n\tcase UBIFS_REF_NODE:\n\t\treturn \"reference node\";\n\tcase UBIFS_INO_NODE:\n\t\treturn \"inode node\";\n\tcase UBIFS_DENT_NODE:\n\t\treturn \"direntry node\";\n\tcase UBIFS_XENT_NODE:\n\t\treturn \"xentry node\";\n\tcase UBIFS_DATA_NODE:\n\t\treturn \"data node\";\n\tcase UBIFS_TRUN_NODE:\n\t\treturn \"truncate node\";\n\tcase UBIFS_IDX_NODE:\n\t\treturn \"indexing node\";\n\tcase UBIFS_CS_NODE:\n\t\treturn \"commit start node\";\n\tcase UBIFS_ORPH_NODE:\n\t\treturn \"orphan node\";\n\tdefault:\n\t\treturn \"unknown node\";\n\t}\n}\n\nstatic cons"
  },
  {
    "function_name": "key(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "101-138",
    "snippet": "bg_snprintf_key(const struct ubifs_info *c,\n\t\t\t     const union ubifs_key *key, char *buffer, int len)\n{\n\tchar *p = buffer;\n\tint type = key_type(c, key);\n\n\tif (c->key_fmt == UBIFS_SIMPLE_KEY_FMT) {\n\t\tswitch (type) {\n\t\tcase UBIFS_INO_KEY:\n\t\t\tlen -= snprintf(p, len, \"(%lu, %s)\",\n\t\t\t\t\t(unsigned long)key_inum(c, key),\n\t\t\t\t\tget_key_type(type));\n\t\t\tbreak;\n\t\tcase UBIFS_DENT_KEY:\n\t\tcase UBIFS_XENT_KEY:\n\t\t\tlen -= snprintf(p, len, \"(%lu, %s, %#08x)\",\n\t\t\t\t\t(unsigned long)key_inum(c, key),\n\t\t\t\t\tget_key_type(type), key_hash(c, key));\n\t\t\tbreak;\n\t\tcase UBIFS_DATA_KEY:\n\t\t\tlen -= snprintf(p, len, \"(%lu, %s, %u)\",\n\t\t\t\t\t(unsigned long)key_inum(c, key),\n\t\t\t\t\tget_key_type(type), key_block(c, key));\n\t\t\tbreak;\n\t\tcase UBIFS_TRUN_KEY:\n\t\t\tlen -= snprintf(p, len, \"(%lu, %s)\",\n\t\t\t\t\t(unsigned long)key_inum(c, key),\n\t\t\t\t\tget_key_type(type));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlen -= snprintf(p, len, \"(bad key type: %#08x, %#08x)\",\n\t\t\t\t\tkey->u32[0], key->u32[1]);\n\t\t}\n\t} else\n\t\tlen -= snprintf(p, len, \"bad key format %d\", c->key_fmt);\n\tubifs_assert(len > 0);\n\treturn p;\n}\n\nconst char",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "len > 0);\n\tr",
          "args": [
            "turn p;"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en, \"bad",
          "args": [
            "k",
            "fo",
            "at %d\", c->key_fmt)",
            "ubifs_ass"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en, \"(ba",
          "args": [
            "y t",
            "e: %#08x, %#08x)\",\n\t\t\t\t\tkey->u",
            "key->u32[1]",
            "}\n\t} els"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en, \"(%l",
          "args": [
            ",",
            "s)\"",
            "(unsig",
            "g)key_inum(c, key),\n\t\t\t\t\tget_ke",
            "type));\n\t\t\tbreak;"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type));\n\t\t\tb",
          "args": [
            "eak;"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey),",
          "args": [
            "t_k"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en, \"(%l",
          "args": [
            ",",
            "s,",
            ")\",\n\t\t\t\t\t(unsig",
            "g)key_inum(c, key),\n\t\t\t\t\tget_ke",
            "type), key_block(c",
            "key));\n\t\t\tbreak;"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key));",
          "args": [
            "b",
            "ak;"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type), key_b",
          "args": [
            "ock("
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey),",
          "args": [
            "t_k"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en, \"(%l",
          "args": [
            ",",
            "s,",
            "08x)\",\n\t\t\t\t\t(unsig",
            "g)key_inum(c, key),\n\t\t\t\t\tget_ke",
            "type), key_hash(c,",
            "ey));\n\t\t\tbreak;"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey));",
          "args": [
            "b",
            "ak;"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type), key_h",
          "args": [
            "sh(c"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey),",
          "args": [
            "t_k"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en, \"(%l",
          "args": [
            ",",
            "s)\"",
            "(unsig",
            "g)key_inum(c, key),\n\t\t\t\t\tget_ke",
            "type));\n\t\t\tbreak;"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type));\n\t\t\tb",
          "args": [
            "eak;"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey),",
          "args": [
            "t_k"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey);\n\n\ti",
          "args": [
            "->k"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nbg_snprintf_key(const struct ubifs_info *c,\n\t\t\t     const union ubifs_key *key, char *buffer, int len)\n{\n\tchar *p = buffer;\n\tint type = key_type(c, key);\n\n\tif (c->key_fmt == UBIFS_SIMPLE_KEY_FMT) {\n\t\tswitch (type) {\n\t\tcase UBIFS_INO_KEY:\n\t\t\tlen -= snprintf(p, len, \"(%lu, %s)\",\n\t\t\t\t\t(unsigned long)key_inum(c, key),\n\t\t\t\t\tget_key_type(type));\n\t\t\tbreak;\n\t\tcase UBIFS_DENT_KEY:\n\t\tcase UBIFS_XENT_KEY:\n\t\t\tlen -= snprintf(p, len, \"(%lu, %s, %#08x)\",\n\t\t\t\t\t(unsigned long)key_inum(c, key),\n\t\t\t\t\tget_key_type(type), key_hash(c, key));\n\t\t\tbreak;\n\t\tcase UBIFS_DATA_KEY:\n\t\t\tlen -= snprintf(p, len, \"(%lu, %s, %u)\",\n\t\t\t\t\t(unsigned long)key_inum(c, key),\n\t\t\t\t\tget_key_type(type), key_block(c, key));\n\t\t\tbreak;\n\t\tcase UBIFS_TRUN_KEY:\n\t\t\tlen -= snprintf(p, len, \"(%lu, %s)\",\n\t\t\t\t\t(unsigned long)key_inum(c, key),\n\t\t\t\t\tget_key_type(type));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlen -= snprintf(p, len, \"(bad key type: %#08x, %#08x)\",\n\t\t\t\t\tkey->u32[0], key->u32[1]);\n\t\t}\n\t} else\n\t\tlen -= snprintf(p, len, \"bad key format %d\", c->key_fmt);\n\tubifs_assert(len > 0);\n\treturn p;\n}\n\nconst char"
  },
  {
    "function_name": "(int type)\n{",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "79-99",
    "snippet": "char *get_dent_type(int type)\n{\n\tswitch (type) {\n\tcase UBIFS_ITYPE_REG:\n\t\treturn \"file\";\n\tcase UBIFS_ITYPE_DIR:\n\t\treturn \"dir\";\n\tcase UBIFS_ITYPE_LNK:\n\t\treturn \"symlink\";\n\tcase UBIFS_ITYPE_BLK:\n\t\treturn \"blkdev\";\n\tcase UBIFS_ITYPE_CHR:\n\t\treturn \"char dev\";\n\tcase UBIFS_ITYPE_FIFO:\n\t\treturn \"fifo\";\n\tcase UBIFS_ITYPE_SOCK:\n\t\treturn \"socket\";\n\tdefault:\n\t\treturn \"unknown/invalid type\";\n\t}\n}\n\nconst char",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\nchar *get_dent_type(int type)\n{\n\tswitch (type) {\n\tcase UBIFS_ITYPE_REG:\n\t\treturn \"file\";\n\tcase UBIFS_ITYPE_DIR:\n\t\treturn \"dir\";\n\tcase UBIFS_ITYPE_LNK:\n\t\treturn \"symlink\";\n\tcase UBIFS_ITYPE_BLK:\n\t\treturn \"blkdev\";\n\tcase UBIFS_ITYPE_CHR:\n\t\treturn \"char dev\";\n\tcase UBIFS_ITYPE_FIFO:\n\t\treturn \"fifo\";\n\tcase UBIFS_ITYPE_SOCK:\n\t\treturn \"socket\";\n\tdefault:\n\t\treturn \"unknown/invalid type\";\n\t}\n}\n\nconst char"
  },
  {
    "function_name": "int type)\n{",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "61-77",
    "snippet": "char *get_key_type(int type)\n{\n\tswitch (type) {\n\tcase UBIFS_INO_KEY:\n\t\treturn \"inode\";\n\tcase UBIFS_DENT_KEY:\n\t\treturn \"direntry\";\n\tcase UBIFS_XENT_KEY:\n\t\treturn \"xentry\";\n\tcase UBIFS_DATA_KEY:\n\t\treturn \"data\";\n\tcase UBIFS_TRUN_KEY:\n\t\treturn \"truncate\";\n\tdefault:\n\t\treturn \"unknown/invalid key\";\n\t}\n}\n\nstatic cons",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [
      "_SPINLOCK(dbg_lock);\n\nstatic cons"
    ],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\n_SPINLOCK(dbg_lock);\n\nstatic cons;\n\nchar *get_key_type(int type)\n{\n\tswitch (type) {\n\tcase UBIFS_INO_KEY:\n\t\treturn \"inode\";\n\tcase UBIFS_DENT_KEY:\n\t\treturn \"direntry\";\n\tcase UBIFS_XENT_KEY:\n\t\treturn \"xentry\";\n\tcase UBIFS_DATA_KEY:\n\t\treturn \"data\";\n\tcase UBIFS_TRUN_KEY:\n\t\treturn \"truncate\";\n\tdefault:\n\t\treturn \"unknown/invalid key\";\n\t}\n}\n\nstatic cons"
  },
  {
    "function_name": "int hash)\n{",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "49-59",
    "snippet": "char *get_key_hash(int hash)\n{\n\tswitch (hash) {\n\tcase UBIFS_KEY_HASH_R5:\n\t\treturn \"R5\";\n\tcase UBIFS_KEY_HASH_TEST:\n\t\treturn \"test\";\n\tdefault:\n\t\treturn \"unknown/invalid name hash\";\n\t}\n}\n\nstatic cons",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [
      "_SPINLOCK(dbg_lock);\n\nstatic cons"
    ],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\n_SPINLOCK(dbg_lock);\n\nstatic cons;\n\nchar *get_key_hash(int hash)\n{\n\tswitch (hash) {\n\tcase UBIFS_KEY_HASH_R5:\n\t\treturn \"R5\";\n\tcase UBIFS_KEY_HASH_TEST:\n\t\treturn \"test\";\n\tdefault:\n\t\treturn \"unknown/invalid name hash\";\n\t}\n}\n\nstatic cons"
  },
  {
    "function_name": "nt fmt)\n{",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/debug.c",
    "lines": "39-47",
    "snippet": "char *get_key_fmt(int fmt)\n{\n\tswitch (fmt) {\n\tcase UBIFS_SIMPLE_KEY_FMT:\n\t\treturn \"simple\";\n\tdefault:\n\t\treturn \"unknown/invalid format\";\n\t}\n}\n\nstatic cons",
    "includes": [
      "fs.h\"\n\nstatic DEFIN",
      "ux/random.h>\n#include \"ubi",
      "ux/uaccess.h>\n#include <lin",
      "ux/math64.h>\n#include <lin",
      "ux/debugfs.h>\n#include <lin",
      "ux/module.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [
      "_SPINLOCK(dbg_lock);\n\nstatic cons"
    ],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\nstatic DEFIN\nux/random.h>\n#include \"ubi\nux/uaccess.h>\n#include <lin\nux/math64.h>\n#include <lin\nux/debugfs.h>\n#include <lin\nux/module.h>\n#include <lin\n\n_SPINLOCK(dbg_lock);\n\nstatic cons;\n\nchar *get_key_fmt(int fmt)\n{\n\tswitch (fmt) {\n\tcase UBIFS_SIMPLE_KEY_FMT:\n\t\treturn \"simple\";\n\tdefault:\n\t\treturn \"unknown/invalid format\";\n\t}\n}\n\nstatic cons"
  }
]