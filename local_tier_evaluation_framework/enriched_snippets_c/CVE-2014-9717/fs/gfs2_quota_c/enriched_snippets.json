[
  {
    "function_name": "gfs2_quota_hash_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "1646-1652",
    "snippet": "void __init gfs2_quota_hash_init(void)\n{\n\tunsigned i;\n\n\tfor(i = 0; i < GFS2_QD_HASH_SIZE; i++)\n\t\tINIT_HLIST_BL_HEAD(&qd_hash_table[i]);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define GFS2_QD_HASH_SIZE       (1 << GFS2_QD_HASH_SHIFT)"
    ],
    "globals_used": [
      "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_HLIST_BL_HEAD",
          "args": [
            "&qd_hash_table[i]"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define GFS2_QD_HASH_SIZE       (1 << GFS2_QD_HASH_SHIFT)\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nvoid __init gfs2_quota_hash_init(void)\n{\n\tunsigned i;\n\n\tfor(i = 0; i < GFS2_QD_HASH_SIZE; i++)\n\t\tINIT_HLIST_BL_HEAD(&qd_hash_table[i]);\n}"
  },
  {
    "function_name": "gfs2_set_dqblk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "1539-1637",
    "snippet": "static int gfs2_set_dqblk(struct super_block *sb, struct kqid qid,\n\t\t\t  struct qc_dqblk *fdq)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_quota_data *qd;\n\tstruct gfs2_holder q_gh, i_gh;\n\tunsigned int data_blocks, ind_blocks;\n\tunsigned int blocks = 0;\n\tint alloc_required;\n\tloff_t offset;\n\tint error;\n\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn -ESRCH; /* Crazy XFS error code */\n\n\tif ((qid.type != USRQUOTA) &&\n\t    (qid.type != GRPQUOTA))\n\t\treturn -EINVAL;\n\n\tif (fdq->d_fieldmask & ~GFS2_FIELDMASK)\n\t\treturn -EINVAL;\n\n\terror = qd_get(sdp, qid, &qd);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\tgoto out_put;\n\n\tmutex_lock(&ip->i_inode.i_mutex);\n\terror = gfs2_glock_nq_init(qd->qd_gl, LM_ST_EXCLUSIVE, 0, &q_gh);\n\tif (error)\n\t\tgoto out_unlockput;\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &i_gh);\n\tif (error)\n\t\tgoto out_q;\n\n\t/* Check for existing entry, if none then alloc new blocks */\n\terror = update_qd(sdp, qd);\n\tif (error)\n\t\tgoto out_i;\n\n\t/* If nothing has changed, this is a no-op */\n\tif ((fdq->d_fieldmask & QC_SPC_SOFT) &&\n\t    ((fdq->d_spc_softlimit >> sdp->sd_sb.sb_bsize_shift) == be64_to_cpu(qd->qd_qb.qb_warn)))\n\t\tfdq->d_fieldmask ^= QC_SPC_SOFT;\n\n\tif ((fdq->d_fieldmask & QC_SPC_HARD) &&\n\t    ((fdq->d_spc_hardlimit >> sdp->sd_sb.sb_bsize_shift) == be64_to_cpu(qd->qd_qb.qb_limit)))\n\t\tfdq->d_fieldmask ^= QC_SPC_HARD;\n\n\tif ((fdq->d_fieldmask & QC_SPACE) &&\n\t    ((fdq->d_space >> sdp->sd_sb.sb_bsize_shift) == be64_to_cpu(qd->qd_qb.qb_value)))\n\t\tfdq->d_fieldmask ^= QC_SPACE;\n\n\tif (fdq->d_fieldmask == 0)\n\t\tgoto out_i;\n\n\toffset = qd2offset(qd);\n\talloc_required = gfs2_write_alloc_required(ip, offset, sizeof(struct gfs2_quota));\n\tif (gfs2_is_stuffed(ip))\n\t\talloc_required = 1;\n\tif (alloc_required) {\n\t\tstruct gfs2_alloc_parms ap = { .aflags = 0, };\n\t\tgfs2_write_calc_reserv(ip, sizeof(struct gfs2_quota),\n\t\t\t\t       &data_blocks, &ind_blocks);\n\t\tblocks = 1 + data_blocks + ind_blocks;\n\t\tap.target = blocks;\n\t\terror = gfs2_inplace_reserve(ip, &ap);\n\t\tif (error)\n\t\t\tgoto out_i;\n\t\tblocks += gfs2_rg_blocks(ip, blocks);\n\t}\n\n\t/* Some quotas span block boundaries and can update two blocks,\n\t   adding an extra block to the transaction to handle such quotas */\n\terror = gfs2_trans_begin(sdp, blocks + RES_DINODE + 2, 0);\n\tif (error)\n\t\tgoto out_release;\n\n\t/* Apply changes */\n\terror = gfs2_adjust_quota(ip, offset, 0, qd, fdq);\n\n\tgfs2_trans_end(sdp);\nout_release:\n\tif (alloc_required)\n\t\tgfs2_inplace_release(ip);\nout_i:\n\tgfs2_glock_dq_uninit(&i_gh);\nout_q:\n\tgfs2_glock_dq_uninit(&q_gh);\nout_unlockput:\n\tmutex_unlock(&ip->i_inode.i_mutex);\nout_put:\n\tqd_put(qd);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define GFS2_FIELDMASK (QC_SPC_SOFT|QC_SPC_HARD|QC_SPACE)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qd_put",
          "args": [
            "qd"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "qd_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "310-319",
          "snippet": "static void qd_put(struct gfs2_quota_data *qd)\n{\n\tif (lockref_put_or_lock(&qd->qd_lockref))\n\t\treturn;\n\n\tqd->qd_lockref.count = 0;\n\tlist_lru_add(&gfs2_qd_lru, &qd->qd_lru);\n\tspin_unlock(&qd->qd_lockref.lock);\n\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_lru gfs2_qd_lru;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct list_lru gfs2_qd_lru;\n\nstatic void qd_put(struct gfs2_quota_data *qd)\n{\n\tif (lockref_put_or_lock(&qd->qd_lockref))\n\t\treturn;\n\n\tqd->qd_lockref.count = 0;\n\tlist_lru_add(&gfs2_qd_lru, &qd->qd_lru);\n\tspin_unlock(&qd->qd_lockref.lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ip->i_inode.i_mutex"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&q_gh"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_inplace_release",
          "args": [
            "ip"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inplace_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2081-2087",
          "snippet": "void gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_adjust_quota",
          "args": [
            "ip",
            "offset",
            "0",
            "qd",
            "fdq"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_adjust_quota",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "669-789",
          "snippet": "static int gfs2_adjust_quota(struct gfs2_inode *ip, loff_t loc,\n\t\t\t     s64 change, struct gfs2_quota_data *qd,\n\t\t\t     struct qc_dqblk *fdq)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned long index = loc >> PAGE_CACHE_SHIFT;\n\tunsigned offset = loc & (PAGE_CACHE_SIZE - 1);\n\tunsigned blocksize, iblock, pos;\n\tstruct buffer_head *bh;\n\tstruct page *page;\n\tvoid *kaddr, *ptr;\n\tstruct gfs2_quota q;\n\tint err, nbytes;\n\tu64 size;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terr = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmemset(&q, 0, sizeof(struct gfs2_quota));\n\terr = gfs2_internal_read(ip, (char *)&q, &loc, sizeof(q));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EIO;\n\tbe64_add_cpu(&q.qu_value, change);\n\tqd->qd_qb.qb_value = q.qu_value;\n\tif (fdq) {\n\t\tif (fdq->d_fieldmask & QC_SPC_SOFT) {\n\t\t\tq.qu_warn = cpu_to_be64(fdq->d_spc_softlimit >> sdp->sd_sb.sb_bsize_shift);\n\t\t\tqd->qd_qb.qb_warn = q.qu_warn;\n\t\t}\n\t\tif (fdq->d_fieldmask & QC_SPC_HARD) {\n\t\t\tq.qu_limit = cpu_to_be64(fdq->d_spc_hardlimit >> sdp->sd_sb.sb_bsize_shift);\n\t\t\tqd->qd_qb.qb_limit = q.qu_limit;\n\t\t}\n\t\tif (fdq->d_fieldmask & QC_SPACE) {\n\t\t\tq.qu_value = cpu_to_be64(fdq->d_space >> sdp->sd_sb.sb_bsize_shift);\n\t\t\tqd->qd_qb.qb_value = q.qu_value;\n\t\t}\n\t}\n\n\t/* Write the quota into the quota file on disk */\n\tptr = &q;\n\tnbytes = sizeof(struct gfs2_quota);\nget_a_page:\n\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tiblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\tif (!buffer_mapped(bh)) {\n\t\tgfs2_block_map(inode, iblock, bh, 1);\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock_out;\n\t\t/* If it's a newly allocated disk block for quota, zero it */\n\t\tif (buffer_new(bh))\n\t\t\tzero_user(page, pos - blocksize, bh->b_size);\n\t}\n\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\tll_rw_block(READ | REQ_META, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock_out;\n\t}\n\n\tgfs2_trans_add_data(ip->i_gl, bh);\n\n\tkaddr = kmap_atomic(page);\n\tif (offset + sizeof(struct gfs2_quota) > PAGE_CACHE_SIZE)\n\t\tnbytes = PAGE_CACHE_SIZE - offset;\n\tmemcpy(kaddr + offset, ptr, nbytes);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\t/* If quota straddles page boundary, we need to update the rest of the\n\t * quota at the beginning of the next page */\n\tif ((offset + sizeof(struct gfs2_quota)) > PAGE_CACHE_SIZE) {\n\t\tptr = ptr + nbytes;\n\t\tnbytes = sizeof(struct gfs2_quota) - nbytes;\n\t\toffset = 0;\n\t\tindex++;\n\t\tgoto get_a_page;\n\t}\n\n\tsize = loc + sizeof(struct gfs2_quota);\n\tif (size > inode->i_size)\n\t\ti_size_write(inode, size);\n\tinode->i_mtime = inode->i_atime = CURRENT_TIME;\n\tmark_inode_dirty(inode);\n\tset_bit(QDF_REFRESH, &qd->qd_flags);\n\treturn 0;\n\nunlock_out:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_adjust_quota(struct gfs2_inode *ip, loff_t loc,\n\t\t\t     s64 change, struct gfs2_quota_data *qd,\n\t\t\t     struct qc_dqblk *fdq)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned long index = loc >> PAGE_CACHE_SHIFT;\n\tunsigned offset = loc & (PAGE_CACHE_SIZE - 1);\n\tunsigned blocksize, iblock, pos;\n\tstruct buffer_head *bh;\n\tstruct page *page;\n\tvoid *kaddr, *ptr;\n\tstruct gfs2_quota q;\n\tint err, nbytes;\n\tu64 size;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terr = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmemset(&q, 0, sizeof(struct gfs2_quota));\n\terr = gfs2_internal_read(ip, (char *)&q, &loc, sizeof(q));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EIO;\n\tbe64_add_cpu(&q.qu_value, change);\n\tqd->qd_qb.qb_value = q.qu_value;\n\tif (fdq) {\n\t\tif (fdq->d_fieldmask & QC_SPC_SOFT) {\n\t\t\tq.qu_warn = cpu_to_be64(fdq->d_spc_softlimit >> sdp->sd_sb.sb_bsize_shift);\n\t\t\tqd->qd_qb.qb_warn = q.qu_warn;\n\t\t}\n\t\tif (fdq->d_fieldmask & QC_SPC_HARD) {\n\t\t\tq.qu_limit = cpu_to_be64(fdq->d_spc_hardlimit >> sdp->sd_sb.sb_bsize_shift);\n\t\t\tqd->qd_qb.qb_limit = q.qu_limit;\n\t\t}\n\t\tif (fdq->d_fieldmask & QC_SPACE) {\n\t\t\tq.qu_value = cpu_to_be64(fdq->d_space >> sdp->sd_sb.sb_bsize_shift);\n\t\t\tqd->qd_qb.qb_value = q.qu_value;\n\t\t}\n\t}\n\n\t/* Write the quota into the quota file on disk */\n\tptr = &q;\n\tnbytes = sizeof(struct gfs2_quota);\nget_a_page:\n\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tiblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\tif (!buffer_mapped(bh)) {\n\t\tgfs2_block_map(inode, iblock, bh, 1);\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock_out;\n\t\t/* If it's a newly allocated disk block for quota, zero it */\n\t\tif (buffer_new(bh))\n\t\t\tzero_user(page, pos - blocksize, bh->b_size);\n\t}\n\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\tll_rw_block(READ | REQ_META, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock_out;\n\t}\n\n\tgfs2_trans_add_data(ip->i_gl, bh);\n\n\tkaddr = kmap_atomic(page);\n\tif (offset + sizeof(struct gfs2_quota) > PAGE_CACHE_SIZE)\n\t\tnbytes = PAGE_CACHE_SIZE - offset;\n\tmemcpy(kaddr + offset, ptr, nbytes);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\t/* If quota straddles page boundary, we need to update the rest of the\n\t * quota at the beginning of the next page */\n\tif ((offset + sizeof(struct gfs2_quota)) > PAGE_CACHE_SIZE) {\n\t\tptr = ptr + nbytes;\n\t\tnbytes = sizeof(struct gfs2_quota) - nbytes;\n\t\toffset = 0;\n\t\tindex++;\n\t\tgoto get_a_page;\n\t}\n\n\tsize = loc + sizeof(struct gfs2_quota);\n\tif (size > inode->i_size)\n\t\ti_size_write(inode, size);\n\tinode->i_mtime = inode->i_atime = CURRENT_TIME;\n\tmark_inode_dirty(inode);\n\tset_bit(QDF_REFRESH, &qd->qd_flags);\n\treturn 0;\n\nunlock_out:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "blocks + RES_DINODE + 2",
            "0"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rg_blocks",
          "args": [
            "ip",
            "blocks"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rg_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.h",
          "lines": "31-36",
          "snippet": "static inline unsigned int gfs2_rg_blocks(const struct gfs2_inode *ip, unsigned requested)\n{\n\tif (requested < ip->i_rgd->rd_length)\n\t\treturn requested + 1;\n\treturn ip->i_rgd->rd_length;\n}",
          "includes": [
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n\nstatic inline unsigned int gfs2_rg_blocks(const struct gfs2_inode *ip, unsigned requested)\n{\n\tif (requested < ip->i_rgd->rd_length)\n\t\treturn requested + 1;\n\treturn ip->i_rgd->rd_length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_inplace_reserve",
          "args": [
            "ip",
            "&ap"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inplace_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1952-2072",
          "snippet": "int gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *begin = NULL;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tint error = 0, rg_locked, flags = 0;\n\tu64 last_unlinked = NO_BLOCK;\n\tint loops = 0;\n\tu32 skip = 0;\n\n\tif (sdp->sd_args.ar_rgrplvb)\n\t\tflags |= GL_SKIP;\n\tif (gfs2_assert_warn(sdp, ap->target))\n\t\treturn -EINVAL;\n\tif (gfs2_rs_active(rs)) {\n\t\tbegin = rs->rs_rbm.rgd;\n\t} else if (ip->i_rgd && rgrp_contains_block(ip->i_rgd, ip->i_goal)) {\n\t\trs->rs_rbm.rgd = begin = ip->i_rgd;\n\t} else {\n\t\tcheck_and_update_goal(ip);\n\t\trs->rs_rbm.rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal, 1);\n\t}\n\tif (S_ISDIR(ip->i_inode.i_mode) && (ap->aflags & GFS2_AF_ORLOV))\n\t\tskip = gfs2_orlov_skip(ip);\n\tif (rs->rs_rbm.rgd == NULL)\n\t\treturn -EBADSLT;\n\n\twhile (loops < 3) {\n\t\trg_locked = 1;\n\n\t\tif (!gfs2_glock_is_locked_by_me(rs->rs_rbm.rgd->rd_gl)) {\n\t\t\trg_locked = 0;\n\t\t\tif (skip && skip--)\n\t\t\t\tgoto next_rgrp;\n\t\t\tif (!gfs2_rs_active(rs)) {\n\t\t\t\tif (loops == 0 &&\n\t\t\t\t    !fast_to_acquire(rs->rs_rbm.rgd))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t\tif ((loops < 2) &&\n\t\t\t\t    gfs2_rgrp_used_recently(rs, 1000) &&\n\t\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t}\n\t\t\terror = gfs2_glock_nq_init(rs->rs_rbm.rgd->rd_gl,\n\t\t\t\t\t\t   LM_ST_EXCLUSIVE, flags,\n\t\t\t\t\t\t   &rs->rs_rgd_gh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn error;\n\t\t\tif (!gfs2_rs_active(rs) && (loops < 2) &&\n\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\tgoto skip_rgrp;\n\t\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\t\terror = update_rgrp_lvb(rs->rs_rbm.rgd);\n\t\t\t\tif (unlikely(error)) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Skip unuseable resource groups */\n\t\tif ((rs->rs_rbm.rgd->rd_flags & (GFS2_RGF_NOALLOC |\n\t\t\t\t\t\t GFS2_RDF_ERROR)) ||\n\t\t    (ap->target > rs->rs_rbm.rgd->rd_extfail_pt))\n\t\t\tgoto skip_rgrp;\n\n\t\tif (sdp->sd_args.ar_rgrplvb)\n\t\t\tgfs2_rgrp_bh_get(rs->rs_rbm.rgd);\n\n\t\t/* Get a reservation if we don't already have one */\n\t\tif (!gfs2_rs_active(rs))\n\t\t\trg_mblk_search(rs->rs_rbm.rgd, ip, ap);\n\n\t\t/* Skip rgrps when we can't get a reservation on first pass */\n\t\tif (!gfs2_rs_active(rs) && (loops < 1))\n\t\t\tgoto check_rgrp;\n\n\t\t/* If rgrp has enough free space, use it */\n\t\tif (rs->rs_rbm.rgd->rd_free_clone >= ap->target) {\n\t\t\tip->i_rgd = rs->rs_rbm.rgd;\n\t\t\treturn 0;\n\t\t}\n\ncheck_rgrp:\n\t\t/* Check for unlinked inodes which can be reclaimed */\n\t\tif (rs->rs_rbm.rgd->rd_flags & GFS2_RDF_CHECK)\n\t\t\ttry_rgrp_unlink(rs->rs_rbm.rgd, &last_unlinked,\n\t\t\t\t\tip->i_no_addr);\nskip_rgrp:\n\t\t/* Drop reservation, if we couldn't use reserved rgrp */\n\t\tif (gfs2_rs_active(rs))\n\t\t\tgfs2_rs_deltree(rs);\n\n\t\t/* Unlock rgrp if required */\n\t\tif (!rg_locked)\n\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\nnext_rgrp:\n\t\t/* Find the next rgrp, and continue looking */\n\t\tif (gfs2_select_rgrp(&rs->rs_rbm.rgd, begin))\n\t\t\tcontinue;\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\t/* If we've scanned all the rgrps, but found no free blocks\n\t\t * then this checks for some less likely conditions before\n\t\t * trying again.\n\t\t */\n\t\tloops++;\n\t\t/* Check that fs hasn't grown if writing to rindex */\n\t\tif (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {\n\t\t\terror = gfs2_ri_update(ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t/* Flushing the log may release space */\n\t\tif (loops == 2)\n\t\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\t}\n\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define NO_BLOCK ((u64)~0)"
          ],
          "globals_used": [
            "static int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define NO_BLOCK ((u64)~0)\n\nstatic int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);\n\nint gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *begin = NULL;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tint error = 0, rg_locked, flags = 0;\n\tu64 last_unlinked = NO_BLOCK;\n\tint loops = 0;\n\tu32 skip = 0;\n\n\tif (sdp->sd_args.ar_rgrplvb)\n\t\tflags |= GL_SKIP;\n\tif (gfs2_assert_warn(sdp, ap->target))\n\t\treturn -EINVAL;\n\tif (gfs2_rs_active(rs)) {\n\t\tbegin = rs->rs_rbm.rgd;\n\t} else if (ip->i_rgd && rgrp_contains_block(ip->i_rgd, ip->i_goal)) {\n\t\trs->rs_rbm.rgd = begin = ip->i_rgd;\n\t} else {\n\t\tcheck_and_update_goal(ip);\n\t\trs->rs_rbm.rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal, 1);\n\t}\n\tif (S_ISDIR(ip->i_inode.i_mode) && (ap->aflags & GFS2_AF_ORLOV))\n\t\tskip = gfs2_orlov_skip(ip);\n\tif (rs->rs_rbm.rgd == NULL)\n\t\treturn -EBADSLT;\n\n\twhile (loops < 3) {\n\t\trg_locked = 1;\n\n\t\tif (!gfs2_glock_is_locked_by_me(rs->rs_rbm.rgd->rd_gl)) {\n\t\t\trg_locked = 0;\n\t\t\tif (skip && skip--)\n\t\t\t\tgoto next_rgrp;\n\t\t\tif (!gfs2_rs_active(rs)) {\n\t\t\t\tif (loops == 0 &&\n\t\t\t\t    !fast_to_acquire(rs->rs_rbm.rgd))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t\tif ((loops < 2) &&\n\t\t\t\t    gfs2_rgrp_used_recently(rs, 1000) &&\n\t\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t}\n\t\t\terror = gfs2_glock_nq_init(rs->rs_rbm.rgd->rd_gl,\n\t\t\t\t\t\t   LM_ST_EXCLUSIVE, flags,\n\t\t\t\t\t\t   &rs->rs_rgd_gh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn error;\n\t\t\tif (!gfs2_rs_active(rs) && (loops < 2) &&\n\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\tgoto skip_rgrp;\n\t\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\t\terror = update_rgrp_lvb(rs->rs_rbm.rgd);\n\t\t\t\tif (unlikely(error)) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Skip unuseable resource groups */\n\t\tif ((rs->rs_rbm.rgd->rd_flags & (GFS2_RGF_NOALLOC |\n\t\t\t\t\t\t GFS2_RDF_ERROR)) ||\n\t\t    (ap->target > rs->rs_rbm.rgd->rd_extfail_pt))\n\t\t\tgoto skip_rgrp;\n\n\t\tif (sdp->sd_args.ar_rgrplvb)\n\t\t\tgfs2_rgrp_bh_get(rs->rs_rbm.rgd);\n\n\t\t/* Get a reservation if we don't already have one */\n\t\tif (!gfs2_rs_active(rs))\n\t\t\trg_mblk_search(rs->rs_rbm.rgd, ip, ap);\n\n\t\t/* Skip rgrps when we can't get a reservation on first pass */\n\t\tif (!gfs2_rs_active(rs) && (loops < 1))\n\t\t\tgoto check_rgrp;\n\n\t\t/* If rgrp has enough free space, use it */\n\t\tif (rs->rs_rbm.rgd->rd_free_clone >= ap->target) {\n\t\t\tip->i_rgd = rs->rs_rbm.rgd;\n\t\t\treturn 0;\n\t\t}\n\ncheck_rgrp:\n\t\t/* Check for unlinked inodes which can be reclaimed */\n\t\tif (rs->rs_rbm.rgd->rd_flags & GFS2_RDF_CHECK)\n\t\t\ttry_rgrp_unlink(rs->rs_rbm.rgd, &last_unlinked,\n\t\t\t\t\tip->i_no_addr);\nskip_rgrp:\n\t\t/* Drop reservation, if we couldn't use reserved rgrp */\n\t\tif (gfs2_rs_active(rs))\n\t\t\tgfs2_rs_deltree(rs);\n\n\t\t/* Unlock rgrp if required */\n\t\tif (!rg_locked)\n\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\nnext_rgrp:\n\t\t/* Find the next rgrp, and continue looking */\n\t\tif (gfs2_select_rgrp(&rs->rs_rbm.rgd, begin))\n\t\t\tcontinue;\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\t/* If we've scanned all the rgrps, but found no free blocks\n\t\t * then this checks for some less likely conditions before\n\t\t * trying again.\n\t\t */\n\t\tloops++;\n\t\t/* Check that fs hasn't grown if writing to rindex */\n\t\tif (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {\n\t\t\terror = gfs2_ri_update(ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t/* Flushing the log may release space */\n\t\tif (loops == 2)\n\t\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\t}\n\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_write_calc_reserv",
          "args": [
            "ip",
            "sizeof(struct gfs2_quota)",
            "&data_blocks",
            "&ind_blocks"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_write_calc_reserv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.h",
          "lines": "29-45",
          "snippet": "static inline void gfs2_write_calc_reserv(const struct gfs2_inode *ip,\n\t\t\t\t\t  unsigned int len,\n\t\t\t\t\t  unsigned int *data_blocks,\n\t\t\t\t\t  unsigned int *ind_blocks)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int tmp;\n\n\tBUG_ON(gfs2_is_dir(ip));\n\t*data_blocks = (len >> sdp->sd_sb.sb_bsize_shift) + 3;\n\t*ind_blocks = 3 * (sdp->sd_max_height - 1);\n\n\tfor (tmp = *data_blocks; tmp > sdp->sd_diptrs;) {\n\t\ttmp = DIV_ROUND_UP(tmp, sdp->sd_inptrs);\n\t\t*ind_blocks += tmp;\n\t}\n}",
          "includes": [
            "#include \"inode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n\nstatic inline void gfs2_write_calc_reserv(const struct gfs2_inode *ip,\n\t\t\t\t\t  unsigned int len,\n\t\t\t\t\t  unsigned int *data_blocks,\n\t\t\t\t\t  unsigned int *ind_blocks)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int tmp;\n\n\tBUG_ON(gfs2_is_dir(ip));\n\t*data_blocks = (len >> sdp->sd_sb.sb_bsize_shift) + 3;\n\t*ind_blocks = 3 * (sdp->sd_max_height - 1);\n\n\tfor (tmp = *data_blocks; tmp > sdp->sd_diptrs;) {\n\t\ttmp = DIV_ROUND_UP(tmp, sdp->sd_inptrs);\n\t\t*ind_blocks += tmp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_stuffed",
          "args": [
            "ip"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_stuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "23-26",
          "snippet": "static inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_write_alloc_required",
          "args": [
            "ip",
            "offset",
            "sizeof(struct gfs2_quota)"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_write_alloc_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "1455-1494",
          "snippet": "int gfs2_write_alloc_required(struct gfs2_inode *ip, u64 offset,\n\t\t\t      unsigned int len)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head bh;\n\tunsigned int shift;\n\tu64 lblock, lblock_stop, size;\n\tu64 end_of_file;\n\n\tif (!len)\n\t\treturn 0;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\tif (offset + len >\n\t\t    sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tshift = sdp->sd_sb.sb_bsize_shift;\n\tBUG_ON(gfs2_is_dir(ip));\n\tend_of_file = (i_size_read(&ip->i_inode) + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tlblock = offset >> shift;\n\tlblock_stop = (offset + len + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tif (lblock_stop > end_of_file)\n\t\treturn 1;\n\n\tsize = (lblock_stop - lblock) << shift;\n\tdo {\n\t\tbh.b_state = 0;\n\t\tbh.b_size = size;\n\t\tgfs2_block_map(&ip->i_inode, lblock, &bh, 0);\n\t\tif (!buffer_mapped(&bh))\n\t\t\treturn 1;\n\t\tsize -= bh.b_size;\n\t\tlblock += (bh.b_size >> ip->i_inode.i_blkbits);\n\t} while(size > 0);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_write_alloc_required(struct gfs2_inode *ip, u64 offset,\n\t\t\t      unsigned int len)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head bh;\n\tunsigned int shift;\n\tu64 lblock, lblock_stop, size;\n\tu64 end_of_file;\n\n\tif (!len)\n\t\treturn 0;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\tif (offset + len >\n\t\t    sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tshift = sdp->sd_sb.sb_bsize_shift;\n\tBUG_ON(gfs2_is_dir(ip));\n\tend_of_file = (i_size_read(&ip->i_inode) + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tlblock = offset >> shift;\n\tlblock_stop = (offset + len + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tif (lblock_stop > end_of_file)\n\t\treturn 1;\n\n\tsize = (lblock_stop - lblock) << shift;\n\tdo {\n\t\tbh.b_state = 0;\n\t\tbh.b_size = size;\n\t\tgfs2_block_map(&ip->i_inode, lblock, &bh, 0);\n\t\tif (!buffer_mapped(&bh))\n\t\t\treturn 1;\n\t\tsize -= bh.b_size;\n\t\tlblock += (bh.b_size >> ip->i_inode.i_blkbits);\n\t} while(size > 0);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qd2offset",
          "args": [
            "qd"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "qd2offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "204-212",
          "snippet": "static u64 qd2offset(struct gfs2_quota_data *qd)\n{\n\tu64 offset;\n\n\toffset = qd2index(qd);\n\toffset *= sizeof(struct gfs2_quota);\n\n\treturn offset;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic u64 qd2offset(struct gfs2_quota_data *qd)\n{\n\tu64 offset;\n\n\toffset = qd2index(qd);\n\toffset *= sizeof(struct gfs2_quota);\n\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "qd->qd_qb.qb_value"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "qd->qd_qb.qb_limit"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "qd->qd_qb.qb_warn"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_qd",
          "args": [
            "sdp",
            "qd"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "update_qd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "888-911",
          "snippet": "static int update_qd(struct gfs2_sbd *sdp, struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_quota q;\n\tstruct gfs2_quota_lvb *qlvb;\n\tloff_t pos;\n\tint error;\n\n\tmemset(&q, 0, sizeof(struct gfs2_quota));\n\tpos = qd2offset(qd);\n\terror = gfs2_internal_read(ip, (char *)&q, &pos, sizeof(q));\n\tif (error < 0)\n\t\treturn error;\n\n\tqlvb = (struct gfs2_quota_lvb *)qd->qd_gl->gl_lksb.sb_lvbptr;\n\tqlvb->qb_magic = cpu_to_be32(GFS2_MAGIC);\n\tqlvb->__pad = 0;\n\tqlvb->qb_limit = q.qu_limit;\n\tqlvb->qb_warn = q.qu_warn;\n\tqlvb->qb_value = q.qu_value;\n\tqd->qd_qb = *qlvb;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int update_qd(struct gfs2_sbd *sdp, struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_quota q;\n\tstruct gfs2_quota_lvb *qlvb;\n\tloff_t pos;\n\tint error;\n\n\tmemset(&q, 0, sizeof(struct gfs2_quota));\n\tpos = qd2offset(qd);\n\terror = gfs2_internal_read(ip, (char *)&q, &pos, sizeof(q));\n\tif (error < 0)\n\t\treturn error;\n\n\tqlvb = (struct gfs2_quota_lvb *)qd->qd_gl->gl_lksb.sb_lvbptr;\n\tqlvb->qb_magic = cpu_to_be32(GFS2_MAGIC);\n\tqlvb->__pad = 0;\n\tqlvb->qb_limit = q.qu_limit;\n\tqlvb->qb_warn = q.qu_warn;\n\tqlvb->qb_value = q.qu_value;\n\tqd->qd_qb = *qlvb;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "ip->i_gl",
            "LM_ST_EXCLUSIVE",
            "0",
            "&i_gh"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ip->i_inode.i_mutex"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_rs_alloc",
          "args": [
            "ip"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "602-620",
          "snippet": "int gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qd_get",
          "args": [
            "sdp",
            "qid",
            "&qd"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "qd_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "265-300",
          "snippet": "static int qd_get(struct gfs2_sbd *sdp, struct kqid qid,\n\t\t  struct gfs2_quota_data **qdp)\n{\n\tstruct gfs2_quota_data *qd, *new_qd;\n\tunsigned int hash = gfs2_qd_hash(sdp, qid);\n\n\trcu_read_lock();\n\t*qdp = qd = gfs2_qd_search_bucket(hash, sdp, qid);\n\trcu_read_unlock();\n\n\tif (qd)\n\t\treturn 0;\n\n\tnew_qd = qd_alloc(hash, sdp, qid);\n\tif (!new_qd)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&qd_lock);\n\tspin_lock_bucket(hash);\n\t*qdp = qd = gfs2_qd_search_bucket(hash, sdp, qid);\n\tif (qd == NULL) {\n\t\t*qdp = new_qd;\n\t\tlist_add(&new_qd->qd_list, &sdp->sd_quota_list);\n\t\thlist_bl_add_head_rcu(&new_qd->qd_hlist, &qd_hash_table[hash]);\n\t\tatomic_inc(&sdp->sd_quota_count);\n\t}\n\tspin_unlock_bucket(hash);\n\tspin_unlock(&qd_lock);\n\n\tif (qd) {\n\t\tgfs2_glock_put(new_qd->qd_gl);\n\t\tkmem_cache_free(gfs2_quotad_cachep, new_qd);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(qd_lock);",
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic int qd_get(struct gfs2_sbd *sdp, struct kqid qid,\n\t\t  struct gfs2_quota_data **qdp)\n{\n\tstruct gfs2_quota_data *qd, *new_qd;\n\tunsigned int hash = gfs2_qd_hash(sdp, qid);\n\n\trcu_read_lock();\n\t*qdp = qd = gfs2_qd_search_bucket(hash, sdp, qid);\n\trcu_read_unlock();\n\n\tif (qd)\n\t\treturn 0;\n\n\tnew_qd = qd_alloc(hash, sdp, qid);\n\tif (!new_qd)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&qd_lock);\n\tspin_lock_bucket(hash);\n\t*qdp = qd = gfs2_qd_search_bucket(hash, sdp, qid);\n\tif (qd == NULL) {\n\t\t*qdp = new_qd;\n\t\tlist_add(&new_qd->qd_list, &sdp->sd_quota_list);\n\t\thlist_bl_add_head_rcu(&new_qd->qd_hlist, &qd_hash_table[hash]);\n\t\tatomic_inc(&sdp->sd_quota_count);\n\t}\n\tspin_unlock_bucket(hash);\n\tspin_unlock(&qd_lock);\n\n\tif (qd) {\n\t\tgfs2_glock_put(new_qd->qd_gl);\n\t\tkmem_cache_free(gfs2_quotad_cachep, new_qd);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "sdp->sd_quota_inode"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define GFS2_FIELDMASK (QC_SPC_SOFT|QC_SPC_HARD|QC_SPACE)\n\nstatic int gfs2_set_dqblk(struct super_block *sb, struct kqid qid,\n\t\t\t  struct qc_dqblk *fdq)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_quota_data *qd;\n\tstruct gfs2_holder q_gh, i_gh;\n\tunsigned int data_blocks, ind_blocks;\n\tunsigned int blocks = 0;\n\tint alloc_required;\n\tloff_t offset;\n\tint error;\n\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn -ESRCH; /* Crazy XFS error code */\n\n\tif ((qid.type != USRQUOTA) &&\n\t    (qid.type != GRPQUOTA))\n\t\treturn -EINVAL;\n\n\tif (fdq->d_fieldmask & ~GFS2_FIELDMASK)\n\t\treturn -EINVAL;\n\n\terror = qd_get(sdp, qid, &qd);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\tgoto out_put;\n\n\tmutex_lock(&ip->i_inode.i_mutex);\n\terror = gfs2_glock_nq_init(qd->qd_gl, LM_ST_EXCLUSIVE, 0, &q_gh);\n\tif (error)\n\t\tgoto out_unlockput;\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &i_gh);\n\tif (error)\n\t\tgoto out_q;\n\n\t/* Check for existing entry, if none then alloc new blocks */\n\terror = update_qd(sdp, qd);\n\tif (error)\n\t\tgoto out_i;\n\n\t/* If nothing has changed, this is a no-op */\n\tif ((fdq->d_fieldmask & QC_SPC_SOFT) &&\n\t    ((fdq->d_spc_softlimit >> sdp->sd_sb.sb_bsize_shift) == be64_to_cpu(qd->qd_qb.qb_warn)))\n\t\tfdq->d_fieldmask ^= QC_SPC_SOFT;\n\n\tif ((fdq->d_fieldmask & QC_SPC_HARD) &&\n\t    ((fdq->d_spc_hardlimit >> sdp->sd_sb.sb_bsize_shift) == be64_to_cpu(qd->qd_qb.qb_limit)))\n\t\tfdq->d_fieldmask ^= QC_SPC_HARD;\n\n\tif ((fdq->d_fieldmask & QC_SPACE) &&\n\t    ((fdq->d_space >> sdp->sd_sb.sb_bsize_shift) == be64_to_cpu(qd->qd_qb.qb_value)))\n\t\tfdq->d_fieldmask ^= QC_SPACE;\n\n\tif (fdq->d_fieldmask == 0)\n\t\tgoto out_i;\n\n\toffset = qd2offset(qd);\n\talloc_required = gfs2_write_alloc_required(ip, offset, sizeof(struct gfs2_quota));\n\tif (gfs2_is_stuffed(ip))\n\t\talloc_required = 1;\n\tif (alloc_required) {\n\t\tstruct gfs2_alloc_parms ap = { .aflags = 0, };\n\t\tgfs2_write_calc_reserv(ip, sizeof(struct gfs2_quota),\n\t\t\t\t       &data_blocks, &ind_blocks);\n\t\tblocks = 1 + data_blocks + ind_blocks;\n\t\tap.target = blocks;\n\t\terror = gfs2_inplace_reserve(ip, &ap);\n\t\tif (error)\n\t\t\tgoto out_i;\n\t\tblocks += gfs2_rg_blocks(ip, blocks);\n\t}\n\n\t/* Some quotas span block boundaries and can update two blocks,\n\t   adding an extra block to the transaction to handle such quotas */\n\terror = gfs2_trans_begin(sdp, blocks + RES_DINODE + 2, 0);\n\tif (error)\n\t\tgoto out_release;\n\n\t/* Apply changes */\n\terror = gfs2_adjust_quota(ip, offset, 0, qd, fdq);\n\n\tgfs2_trans_end(sdp);\nout_release:\n\tif (alloc_required)\n\t\tgfs2_inplace_release(ip);\nout_i:\n\tgfs2_glock_dq_uninit(&i_gh);\nout_q:\n\tgfs2_glock_dq_uninit(&q_gh);\nout_unlockput:\n\tmutex_unlock(&ip->i_inode.i_mutex);\nout_put:\n\tqd_put(qd);\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_get_dqblk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "1500-1534",
    "snippet": "static int gfs2_get_dqblk(struct super_block *sb, struct kqid qid,\n\t\t\t  struct qc_dqblk *fdq)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct gfs2_quota_lvb *qlvb;\n\tstruct gfs2_quota_data *qd;\n\tstruct gfs2_holder q_gh;\n\tint error;\n\n\tmemset(fdq, 0, sizeof(*fdq));\n\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn -ESRCH; /* Crazy XFS error code */\n\n\tif ((qid.type != USRQUOTA) &&\n\t    (qid.type != GRPQUOTA))\n\t\treturn -EINVAL;\n\n\terror = qd_get(sdp, qid, &qd);\n\tif (error)\n\t\treturn error;\n\terror = do_glock(qd, FORCE, &q_gh);\n\tif (error)\n\t\tgoto out;\n\n\tqlvb = (struct gfs2_quota_lvb *)qd->qd_gl->gl_lksb.sb_lvbptr;\n\tfdq->d_spc_hardlimit = be64_to_cpu(qlvb->qb_limit) << sdp->sd_sb.sb_bsize_shift;\n\tfdq->d_spc_softlimit = be64_to_cpu(qlvb->qb_warn) << sdp->sd_sb.sb_bsize_shift;\n\tfdq->d_space = be64_to_cpu(qlvb->qb_value) << sdp->sd_sb.sb_bsize_shift;\n\n\tgfs2_glock_dq_uninit(&q_gh);\nout:\n\tqd_put(qd);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qd_put",
          "args": [
            "qd"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "qd_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "310-319",
          "snippet": "static void qd_put(struct gfs2_quota_data *qd)\n{\n\tif (lockref_put_or_lock(&qd->qd_lockref))\n\t\treturn;\n\n\tqd->qd_lockref.count = 0;\n\tlist_lru_add(&gfs2_qd_lru, &qd->qd_lru);\n\tspin_unlock(&qd->qd_lockref.lock);\n\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_lru gfs2_qd_lru;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct list_lru gfs2_qd_lru;\n\nstatic void qd_put(struct gfs2_quota_data *qd)\n{\n\tif (lockref_put_or_lock(&qd->qd_lockref))\n\t\treturn;\n\n\tqd->qd_lockref.count = 0;\n\tlist_lru_add(&gfs2_qd_lru, &qd->qd_lru);\n\tspin_unlock(&qd->qd_lockref.lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&q_gh"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "qlvb->qb_value"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "qlvb->qb_warn"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "qlvb->qb_limit"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_glock",
          "args": [
            "qd",
            "FORCE",
            "&q_gh"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "do_glock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "913-956",
          "snippet": "static int do_glock(struct gfs2_quota_data *qd, int force_refresh,\n\t\t    struct gfs2_holder *q_gh)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_holder i_gh;\n\tint error;\n\nrestart:\n\terror = gfs2_glock_nq_init(qd->qd_gl, LM_ST_SHARED, 0, q_gh);\n\tif (error)\n\t\treturn error;\n\n\tqd->qd_qb = *(struct gfs2_quota_lvb *)qd->qd_gl->gl_lksb.sb_lvbptr;\n\n\tif (force_refresh || qd->qd_qb.qb_magic != cpu_to_be32(GFS2_MAGIC)) {\n\t\tgfs2_glock_dq_uninit(q_gh);\n\t\terror = gfs2_glock_nq_init(qd->qd_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t   GL_NOCACHE, q_gh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, 0, &i_gh);\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\terror = update_qd(sdp, qd);\n\t\tif (error)\n\t\t\tgoto fail_gunlock;\n\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\t\tgfs2_glock_dq_uninit(q_gh);\n\t\tforce_refresh = 0;\n\t\tgoto restart;\n\t}\n\n\treturn 0;\n\nfail_gunlock:\n\tgfs2_glock_dq_uninit(&i_gh);\nfail:\n\tgfs2_glock_dq_uninit(q_gh);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int do_glock(struct gfs2_quota_data *qd, int force_refresh,\n\t\t    struct gfs2_holder *q_gh)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_holder i_gh;\n\tint error;\n\nrestart:\n\terror = gfs2_glock_nq_init(qd->qd_gl, LM_ST_SHARED, 0, q_gh);\n\tif (error)\n\t\treturn error;\n\n\tqd->qd_qb = *(struct gfs2_quota_lvb *)qd->qd_gl->gl_lksb.sb_lvbptr;\n\n\tif (force_refresh || qd->qd_qb.qb_magic != cpu_to_be32(GFS2_MAGIC)) {\n\t\tgfs2_glock_dq_uninit(q_gh);\n\t\terror = gfs2_glock_nq_init(qd->qd_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t   GL_NOCACHE, q_gh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, 0, &i_gh);\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\terror = update_qd(sdp, qd);\n\t\tif (error)\n\t\t\tgoto fail_gunlock;\n\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\t\tgfs2_glock_dq_uninit(q_gh);\n\t\tforce_refresh = 0;\n\t\tgoto restart;\n\t}\n\n\treturn 0;\n\nfail_gunlock:\n\tgfs2_glock_dq_uninit(&i_gh);\nfail:\n\tgfs2_glock_dq_uninit(q_gh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qd_get",
          "args": [
            "sdp",
            "qid",
            "&qd"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "qd_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "265-300",
          "snippet": "static int qd_get(struct gfs2_sbd *sdp, struct kqid qid,\n\t\t  struct gfs2_quota_data **qdp)\n{\n\tstruct gfs2_quota_data *qd, *new_qd;\n\tunsigned int hash = gfs2_qd_hash(sdp, qid);\n\n\trcu_read_lock();\n\t*qdp = qd = gfs2_qd_search_bucket(hash, sdp, qid);\n\trcu_read_unlock();\n\n\tif (qd)\n\t\treturn 0;\n\n\tnew_qd = qd_alloc(hash, sdp, qid);\n\tif (!new_qd)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&qd_lock);\n\tspin_lock_bucket(hash);\n\t*qdp = qd = gfs2_qd_search_bucket(hash, sdp, qid);\n\tif (qd == NULL) {\n\t\t*qdp = new_qd;\n\t\tlist_add(&new_qd->qd_list, &sdp->sd_quota_list);\n\t\thlist_bl_add_head_rcu(&new_qd->qd_hlist, &qd_hash_table[hash]);\n\t\tatomic_inc(&sdp->sd_quota_count);\n\t}\n\tspin_unlock_bucket(hash);\n\tspin_unlock(&qd_lock);\n\n\tif (qd) {\n\t\tgfs2_glock_put(new_qd->qd_gl);\n\t\tkmem_cache_free(gfs2_quotad_cachep, new_qd);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(qd_lock);",
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic int qd_get(struct gfs2_sbd *sdp, struct kqid qid,\n\t\t  struct gfs2_quota_data **qdp)\n{\n\tstruct gfs2_quota_data *qd, *new_qd;\n\tunsigned int hash = gfs2_qd_hash(sdp, qid);\n\n\trcu_read_lock();\n\t*qdp = qd = gfs2_qd_search_bucket(hash, sdp, qid);\n\trcu_read_unlock();\n\n\tif (qd)\n\t\treturn 0;\n\n\tnew_qd = qd_alloc(hash, sdp, qid);\n\tif (!new_qd)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&qd_lock);\n\tspin_lock_bucket(hash);\n\t*qdp = qd = gfs2_qd_search_bucket(hash, sdp, qid);\n\tif (qd == NULL) {\n\t\t*qdp = new_qd;\n\t\tlist_add(&new_qd->qd_list, &sdp->sd_quota_list);\n\t\thlist_bl_add_head_rcu(&new_qd->qd_hlist, &qd_hash_table[hash]);\n\t\tatomic_inc(&sdp->sd_quota_count);\n\t}\n\tspin_unlock_bucket(hash);\n\tspin_unlock(&qd_lock);\n\n\tif (qd) {\n\t\tgfs2_glock_put(new_qd->qd_gl);\n\t\tkmem_cache_free(gfs2_quotad_cachep, new_qd);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fdq",
            "0",
            "sizeof(*fdq)"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_get_dqblk(struct super_block *sb, struct kqid qid,\n\t\t\t  struct qc_dqblk *fdq)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct gfs2_quota_lvb *qlvb;\n\tstruct gfs2_quota_data *qd;\n\tstruct gfs2_holder q_gh;\n\tint error;\n\n\tmemset(fdq, 0, sizeof(*fdq));\n\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn -ESRCH; /* Crazy XFS error code */\n\n\tif ((qid.type != USRQUOTA) &&\n\t    (qid.type != GRPQUOTA))\n\t\treturn -EINVAL;\n\n\terror = qd_get(sdp, qid, &qd);\n\tif (error)\n\t\treturn error;\n\terror = do_glock(qd, FORCE, &q_gh);\n\tif (error)\n\t\tgoto out;\n\n\tqlvb = (struct gfs2_quota_lvb *)qd->qd_gl->gl_lksb.sb_lvbptr;\n\tfdq->d_spc_hardlimit = be64_to_cpu(qlvb->qb_limit) << sdp->sd_sb.sb_bsize_shift;\n\tfdq->d_spc_softlimit = be64_to_cpu(qlvb->qb_warn) << sdp->sd_sb.sb_bsize_shift;\n\tfdq->d_space = be64_to_cpu(qlvb->qb_value) << sdp->sd_sb.sb_bsize_shift;\n\n\tgfs2_glock_dq_uninit(&q_gh);\nout:\n\tqd_put(qd);\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_quota_get_xstate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "1471-1498",
    "snippet": "static int gfs2_quota_get_xstate(struct super_block *sb,\n\t\t\t\t struct fs_quota_stat *fqs)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\n\tmemset(fqs, 0, sizeof(struct fs_quota_stat));\n\tfqs->qs_version = FS_QSTAT_VERSION;\n\n\tswitch (sdp->sd_args.ar_quota) {\n\tcase GFS2_QUOTA_ON:\n\t\tfqs->qs_flags |= (FS_QUOTA_UDQ_ENFD | FS_QUOTA_GDQ_ENFD);\n\t\t/*FALLTHRU*/\n\tcase GFS2_QUOTA_ACCOUNT:\n\t\tfqs->qs_flags |= (FS_QUOTA_UDQ_ACCT | FS_QUOTA_GDQ_ACCT);\n\t\tbreak;\n\tcase GFS2_QUOTA_OFF:\n\t\tbreak;\n\t}\n\n\tif (sdp->sd_quota_inode) {\n\t\tfqs->qs_uquota.qfs_ino = GFS2_I(sdp->sd_quota_inode)->i_no_addr;\n\t\tfqs->qs_uquota.qfs_nblks = sdp->sd_quota_inode->i_blocks;\n\t}\n\tfqs->qs_uquota.qfs_nextents = 1; /* unsupported */\n\tfqs->qs_gquota = fqs->qs_uquota; /* its the same inode in both cases */\n\tfqs->qs_incoredqs = list_lru_count(&gfs2_qd_lru);\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct list_lru gfs2_qd_lru;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_lru_count",
          "args": [
            "&gfs2_qd_lru"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "sdp->sd_quota_inode"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fqs",
            "0",
            "sizeof(struct fs_quota_stat)"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct list_lru gfs2_qd_lru;\n\nstatic int gfs2_quota_get_xstate(struct super_block *sb,\n\t\t\t\t struct fs_quota_stat *fqs)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\n\tmemset(fqs, 0, sizeof(struct fs_quota_stat));\n\tfqs->qs_version = FS_QSTAT_VERSION;\n\n\tswitch (sdp->sd_args.ar_quota) {\n\tcase GFS2_QUOTA_ON:\n\t\tfqs->qs_flags |= (FS_QUOTA_UDQ_ENFD | FS_QUOTA_GDQ_ENFD);\n\t\t/*FALLTHRU*/\n\tcase GFS2_QUOTA_ACCOUNT:\n\t\tfqs->qs_flags |= (FS_QUOTA_UDQ_ACCT | FS_QUOTA_GDQ_ACCT);\n\t\tbreak;\n\tcase GFS2_QUOTA_OFF:\n\t\tbreak;\n\t}\n\n\tif (sdp->sd_quota_inode) {\n\t\tfqs->qs_uquota.qfs_ino = GFS2_I(sdp->sd_quota_inode)->i_no_addr;\n\t\tfqs->qs_uquota.qfs_nblks = sdp->sd_quota_inode->i_blocks;\n\t}\n\tfqs->qs_uquota.qfs_nextents = 1; /* unsupported */\n\tfqs->qs_gquota = fqs->qs_uquota; /* its the same inode in both cases */\n\tfqs->qs_incoredqs = list_lru_count(&gfs2_qd_lru);\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_quotad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "1423-1469",
    "snippet": "int gfs2_quotad(void *data)\n{\n\tstruct gfs2_sbd *sdp = data;\n\tstruct gfs2_tune *tune = &sdp->sd_tune;\n\tunsigned long statfs_timeo = 0;\n\tunsigned long quotad_timeo = 0;\n\tunsigned long t = 0;\n\tDEFINE_WAIT(wait);\n\tint empty;\n\n\twhile (!kthread_should_stop()) {\n\n\t\t/* Update the master statfs file */\n\t\tif (sdp->sd_statfs_force_sync) {\n\t\t\tint error = gfs2_statfs_sync(sdp->sd_vfs, 0);\n\t\t\tquotad_error(sdp, \"statfs\", error);\n\t\t\tstatfs_timeo = gfs2_tune_get(sdp, gt_statfs_quantum) * HZ;\n\t\t}\n\t\telse\n\t\t\tquotad_check_timeo(sdp, \"statfs\", gfs2_statfs_sync, t,\n\t\t\t\t   \t   &statfs_timeo,\n\t\t\t\t\t   &tune->gt_statfs_quantum);\n\n\t\t/* Update quota file */\n\t\tquotad_check_timeo(sdp, \"sync\", gfs2_quota_sync, t,\n\t\t\t\t   &quotad_timeo, &tune->gt_quota_quantum);\n\n\t\t/* Check for & recover partially truncated inodes */\n\t\tquotad_check_trunc_list(sdp);\n\n\t\ttry_to_freeze();\n\n\t\tt = min(quotad_timeo, statfs_timeo);\n\n\t\tprepare_to_wait(&sdp->sd_quota_wait, &wait, TASK_INTERRUPTIBLE);\n\t\tspin_lock(&sdp->sd_trunc_lock);\n\t\tempty = list_empty(&sdp->sd_trunc_list);\n\t\tspin_unlock(&sdp->sd_trunc_lock);\n\t\tif (empty && !sdp->sd_statfs_force_sync)\n\t\t\tt -= schedule_timeout(t);\n\t\telse\n\t\t\tt = 0;\n\t\tfinish_wait(&sdp->sd_quota_wait, &wait);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&sdp->sd_quota_wait",
            "&wait"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "t"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sdp->sd_trunc_lock"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sdp->sd_trunc_list"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sdp->sd_trunc_lock"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&sdp->sd_quota_wait",
            "&wait",
            "TASK_INTERRUPTIBLE"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "quotad_timeo",
            "statfs_timeo"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quotad_check_trunc_list",
          "args": [
            "sdp"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "quotad_check_trunc_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1390-1407",
          "snippet": "static void quotad_check_trunc_list(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip;\n\n\twhile(1) {\n\t\tip = NULL;\n\t\tspin_lock(&sdp->sd_trunc_lock);\n\t\tif (!list_empty(&sdp->sd_trunc_list)) {\n\t\t\tip = list_entry(sdp->sd_trunc_list.next,\n\t\t\t\t\tstruct gfs2_inode, i_trunc_list);\n\t\t\tlist_del_init(&ip->i_trunc_list);\n\t\t}\n\t\tspin_unlock(&sdp->sd_trunc_lock);\n\t\tif (ip == NULL)\n\t\t\treturn;\n\t\tgfs2_glock_finish_truncate(ip);\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void quotad_check_trunc_list(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip;\n\n\twhile(1) {\n\t\tip = NULL;\n\t\tspin_lock(&sdp->sd_trunc_lock);\n\t\tif (!list_empty(&sdp->sd_trunc_list)) {\n\t\t\tip = list_entry(sdp->sd_trunc_list.next,\n\t\t\t\t\tstruct gfs2_inode, i_trunc_list);\n\t\t\tlist_del_init(&ip->i_trunc_list);\n\t\t}\n\t\tspin_unlock(&sdp->sd_trunc_lock);\n\t\tif (ip == NULL)\n\t\t\treturn;\n\t\tgfs2_glock_finish_truncate(ip);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "quotad_check_timeo",
          "args": [
            "sdp",
            "\"sync\"",
            "gfs2_quota_sync",
            "t",
            "&quotad_timeo",
            "&tune->gt_quota_quantum"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "quotad_check_timeo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1376-1388",
          "snippet": "static void quotad_check_timeo(struct gfs2_sbd *sdp, const char *msg,\n\t\t\t       int (*fxn)(struct super_block *sb, int type),\n\t\t\t       unsigned long t, unsigned long *timeo,\n\t\t\t       unsigned int *new_timeo)\n{\n\tif (t >= *timeo) {\n\t\tint error = fxn(sdp->sd_vfs, 0);\n\t\tquotad_error(sdp, msg, error);\n\t\t*timeo = gfs2_tune_get_i(&sdp->sd_tune, new_timeo) * HZ;\n\t} else {\n\t\t*timeo -= t;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void quotad_check_timeo(struct gfs2_sbd *sdp, const char *msg,\n\t\t\t       int (*fxn)(struct super_block *sb, int type),\n\t\t\t       unsigned long t, unsigned long *timeo,\n\t\t\t       unsigned int *new_timeo)\n{\n\tif (t >= *timeo) {\n\t\tint error = fxn(sdp->sd_vfs, 0);\n\t\tquotad_error(sdp, msg, error);\n\t\t*timeo = gfs2_tune_get_i(&sdp->sd_tune, new_timeo) * HZ;\n\t} else {\n\t\t*timeo -= t;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_tune_get",
          "args": [
            "sdp",
            "gt_statfs_quantum"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_tune_get_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.h",
          "lines": "155-163",
          "snippet": "static inline unsigned int gfs2_tune_get_i(struct gfs2_tune *gt,\n\t\t\t\t\t   unsigned int *p)\n{\n\tunsigned int x;\n\tspin_lock(&gt->gt_spin);\n\tx = *p;\n\tspin_unlock(&gt->gt_spin);\n\treturn x;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/mempool.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/mempool.h>\n\nstatic inline unsigned int gfs2_tune_get_i(struct gfs2_tune *gt,\n\t\t\t\t\t   unsigned int *p)\n{\n\tunsigned int x;\n\tspin_lock(&gt->gt_spin);\n\tx = *p;\n\tspin_unlock(&gt->gt_spin);\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "quotad_error",
          "args": [
            "sdp",
            "\"statfs\"",
            "error"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "quotad_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1368-1374",
          "snippet": "static void quotad_error(struct gfs2_sbd *sdp, const char *msg, int error)\n{\n\tif (error == 0 || error == -EROFS)\n\t\treturn;\n\tif (!test_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\tfs_err(sdp, \"gfs2_quotad: %s error %d\\n\", msg, error);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void quotad_error(struct gfs2_sbd *sdp, const char *msg, int error)\n{\n\tif (error == 0 || error == -EROFS)\n\t\treturn;\n\tif (!test_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\tfs_err(sdp, \"gfs2_quotad: %s error %d\\n\", msg, error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_statfs_sync",
          "args": [
            "sdp->sd_vfs",
            "0"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_statfs_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "573-625",
          "snippet": "int gfs2_statfs_sync(struct super_block *sb, int type)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct gfs2_inode *m_ip = GFS2_I(sdp->sd_statfs_inode);\n\tstruct gfs2_inode *l_ip = GFS2_I(sdp->sd_sc_inode);\n\tstruct gfs2_statfs_change_host *m_sc = &sdp->sd_statfs_master;\n\tstruct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;\n\tstruct gfs2_holder gh;\n\tstruct buffer_head *m_bh, *l_bh;\n\tint error;\n\n\tsb_start_write(sb);\n\terror = gfs2_glock_nq_init(m_ip->i_gl, LM_ST_EXCLUSIVE, GL_NOCACHE,\n\t\t\t\t   &gh);\n\tif (error)\n\t\tgoto out;\n\n\terror = gfs2_meta_inode_buffer(m_ip, &m_bh);\n\tif (error)\n\t\tgoto out_unlock;\n\n\tspin_lock(&sdp->sd_statfs_spin);\n\tgfs2_statfs_change_in(m_sc, m_bh->b_data +\n\t\t\t      sizeof(struct gfs2_dinode));\n\tif (!l_sc->sc_total && !l_sc->sc_free && !l_sc->sc_dinodes) {\n\t\tspin_unlock(&sdp->sd_statfs_spin);\n\t\tgoto out_bh;\n\t}\n\tspin_unlock(&sdp->sd_statfs_spin);\n\n\terror = gfs2_meta_inode_buffer(l_ip, &l_bh);\n\tif (error)\n\t\tgoto out_bh;\n\n\terror = gfs2_trans_begin(sdp, 2 * RES_DINODE, 0);\n\tif (error)\n\t\tgoto out_bh2;\n\n\tupdate_statfs(sdp, m_bh, l_bh);\n\tsdp->sd_statfs_force_sync = 0;\n\n\tgfs2_trans_end(sdp);\n\nout_bh2:\n\tbrelse(l_bh);\nout_bh:\n\tbrelse(m_bh);\nout_unlock:\n\tgfs2_glock_dq_uninit(&gh);\nout:\n\tsb_end_write(sb);\n\treturn error;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nint gfs2_statfs_sync(struct super_block *sb, int type)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct gfs2_inode *m_ip = GFS2_I(sdp->sd_statfs_inode);\n\tstruct gfs2_inode *l_ip = GFS2_I(sdp->sd_sc_inode);\n\tstruct gfs2_statfs_change_host *m_sc = &sdp->sd_statfs_master;\n\tstruct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;\n\tstruct gfs2_holder gh;\n\tstruct buffer_head *m_bh, *l_bh;\n\tint error;\n\n\tsb_start_write(sb);\n\terror = gfs2_glock_nq_init(m_ip->i_gl, LM_ST_EXCLUSIVE, GL_NOCACHE,\n\t\t\t\t   &gh);\n\tif (error)\n\t\tgoto out;\n\n\terror = gfs2_meta_inode_buffer(m_ip, &m_bh);\n\tif (error)\n\t\tgoto out_unlock;\n\n\tspin_lock(&sdp->sd_statfs_spin);\n\tgfs2_statfs_change_in(m_sc, m_bh->b_data +\n\t\t\t      sizeof(struct gfs2_dinode));\n\tif (!l_sc->sc_total && !l_sc->sc_free && !l_sc->sc_dinodes) {\n\t\tspin_unlock(&sdp->sd_statfs_spin);\n\t\tgoto out_bh;\n\t}\n\tspin_unlock(&sdp->sd_statfs_spin);\n\n\terror = gfs2_meta_inode_buffer(l_ip, &l_bh);\n\tif (error)\n\t\tgoto out_bh;\n\n\terror = gfs2_trans_begin(sdp, 2 * RES_DINODE, 0);\n\tif (error)\n\t\tgoto out_bh2;\n\n\tupdate_statfs(sdp, m_bh, l_bh);\n\tsdp->sd_statfs_force_sync = 0;\n\n\tgfs2_trans_end(sdp);\n\nout_bh2:\n\tbrelse(l_bh);\nout_bh:\n\tbrelse(m_bh);\nout_unlock:\n\tgfs2_glock_dq_uninit(&gh);\nout:\n\tsb_end_write(sb);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_quotad(void *data)\n{\n\tstruct gfs2_sbd *sdp = data;\n\tstruct gfs2_tune *tune = &sdp->sd_tune;\n\tunsigned long statfs_timeo = 0;\n\tunsigned long quotad_timeo = 0;\n\tunsigned long t = 0;\n\tDEFINE_WAIT(wait);\n\tint empty;\n\n\twhile (!kthread_should_stop()) {\n\n\t\t/* Update the master statfs file */\n\t\tif (sdp->sd_statfs_force_sync) {\n\t\t\tint error = gfs2_statfs_sync(sdp->sd_vfs, 0);\n\t\t\tquotad_error(sdp, \"statfs\", error);\n\t\t\tstatfs_timeo = gfs2_tune_get(sdp, gt_statfs_quantum) * HZ;\n\t\t}\n\t\telse\n\t\t\tquotad_check_timeo(sdp, \"statfs\", gfs2_statfs_sync, t,\n\t\t\t\t   \t   &statfs_timeo,\n\t\t\t\t\t   &tune->gt_statfs_quantum);\n\n\t\t/* Update quota file */\n\t\tquotad_check_timeo(sdp, \"sync\", gfs2_quota_sync, t,\n\t\t\t\t   &quotad_timeo, &tune->gt_quota_quantum);\n\n\t\t/* Check for & recover partially truncated inodes */\n\t\tquotad_check_trunc_list(sdp);\n\n\t\ttry_to_freeze();\n\n\t\tt = min(quotad_timeo, statfs_timeo);\n\n\t\tprepare_to_wait(&sdp->sd_quota_wait, &wait, TASK_INTERRUPTIBLE);\n\t\tspin_lock(&sdp->sd_trunc_lock);\n\t\tempty = list_empty(&sdp->sd_trunc_list);\n\t\tspin_unlock(&sdp->sd_trunc_lock);\n\t\tif (empty && !sdp->sd_statfs_force_sync)\n\t\t\tt -= schedule_timeout(t);\n\t\telse\n\t\t\tt = 0;\n\t\tfinish_wait(&sdp->sd_quota_wait, &wait);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_wake_up_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "1409-1414",
    "snippet": "void gfs2_wake_up_statfs(struct gfs2_sbd *sdp) {\n\tif (!sdp->sd_statfs_force_sync) {\n\t\tsdp->sd_statfs_force_sync = 1;\n\t\twake_up(&sdp->sd_quota_wait);\n\t}\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&sdp->sd_quota_wait"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_wake_up_statfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1409-1414",
          "snippet": "void gfs2_wake_up_statfs(struct gfs2_sbd *sdp) {\n\tif (!sdp->sd_statfs_force_sync) {\n\t\tsdp->sd_statfs_force_sync = 1;\n\t\twake_up(&sdp->sd_quota_wait);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_wake_up_statfs(struct gfs2_sbd *sdp) {\n\tif (!sdp->sd_statfs_force_sync) {\n\t\tsdp->sd_statfs_force_sync = 1;\n\t\twake_up(&sdp->sd_quota_wait);\n\t}\n}"
  },
  {
    "function_name": "quotad_check_trunc_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "1390-1407",
    "snippet": "static void quotad_check_trunc_list(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip;\n\n\twhile(1) {\n\t\tip = NULL;\n\t\tspin_lock(&sdp->sd_trunc_lock);\n\t\tif (!list_empty(&sdp->sd_trunc_list)) {\n\t\t\tip = list_entry(sdp->sd_trunc_list.next,\n\t\t\t\t\tstruct gfs2_inode, i_trunc_list);\n\t\t\tlist_del_init(&ip->i_trunc_list);\n\t\t}\n\t\tspin_unlock(&sdp->sd_trunc_lock);\n\t\tif (ip == NULL)\n\t\t\treturn;\n\t\tgfs2_glock_finish_truncate(ip);\n\t}\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_glock_finish_truncate",
          "args": [
            "ip"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_finish_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1565-1577",
          "snippet": "void gfs2_glock_finish_truncate(struct gfs2_inode *ip)\n{\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tint ret;\n\n\tret = gfs2_truncatei_resume(ip);\n\tgfs2_assert_withdraw(gl->gl_sbd, ret == 0);\n\n\tspin_lock(&gl->gl_spin);\n\tclear_bit(GLF_LOCK, &gl->gl_flags);\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_finish_truncate(struct gfs2_inode *ip)\n{\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tint ret;\n\n\tret = gfs2_truncatei_resume(ip);\n\tgfs2_assert_withdraw(gl->gl_sbd, ret == 0);\n\n\tspin_lock(&gl->gl_spin);\n\tclear_bit(GLF_LOCK, &gl->gl_flags);\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sdp->sd_trunc_lock"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ip->i_trunc_list"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "sdp->sd_trunc_list.next",
            "structgfs2_inode",
            "i_trunc_list"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sdp->sd_trunc_list"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sdp->sd_trunc_lock"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void quotad_check_trunc_list(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip;\n\n\twhile(1) {\n\t\tip = NULL;\n\t\tspin_lock(&sdp->sd_trunc_lock);\n\t\tif (!list_empty(&sdp->sd_trunc_list)) {\n\t\t\tip = list_entry(sdp->sd_trunc_list.next,\n\t\t\t\t\tstruct gfs2_inode, i_trunc_list);\n\t\t\tlist_del_init(&ip->i_trunc_list);\n\t\t}\n\t\tspin_unlock(&sdp->sd_trunc_lock);\n\t\tif (ip == NULL)\n\t\t\treturn;\n\t\tgfs2_glock_finish_truncate(ip);\n\t}\n}"
  },
  {
    "function_name": "quotad_check_timeo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "1376-1388",
    "snippet": "static void quotad_check_timeo(struct gfs2_sbd *sdp, const char *msg,\n\t\t\t       int (*fxn)(struct super_block *sb, int type),\n\t\t\t       unsigned long t, unsigned long *timeo,\n\t\t\t       unsigned int *new_timeo)\n{\n\tif (t >= *timeo) {\n\t\tint error = fxn(sdp->sd_vfs, 0);\n\t\tquotad_error(sdp, msg, error);\n\t\t*timeo = gfs2_tune_get_i(&sdp->sd_tune, new_timeo) * HZ;\n\t} else {\n\t\t*timeo -= t;\n\t}\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_tune_get_i",
          "args": [
            "&sdp->sd_tune",
            "new_timeo"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_tune_get_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.h",
          "lines": "155-163",
          "snippet": "static inline unsigned int gfs2_tune_get_i(struct gfs2_tune *gt,\n\t\t\t\t\t   unsigned int *p)\n{\n\tunsigned int x;\n\tspin_lock(&gt->gt_spin);\n\tx = *p;\n\tspin_unlock(&gt->gt_spin);\n\treturn x;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/mempool.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/mempool.h>\n\nstatic inline unsigned int gfs2_tune_get_i(struct gfs2_tune *gt,\n\t\t\t\t\t   unsigned int *p)\n{\n\tunsigned int x;\n\tspin_lock(&gt->gt_spin);\n\tx = *p;\n\tspin_unlock(&gt->gt_spin);\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "quotad_error",
          "args": [
            "sdp",
            "msg",
            "error"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "quotad_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1368-1374",
          "snippet": "static void quotad_error(struct gfs2_sbd *sdp, const char *msg, int error)\n{\n\tif (error == 0 || error == -EROFS)\n\t\treturn;\n\tif (!test_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\tfs_err(sdp, \"gfs2_quotad: %s error %d\\n\", msg, error);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void quotad_error(struct gfs2_sbd *sdp, const char *msg, int error)\n{\n\tif (error == 0 || error == -EROFS)\n\t\treturn;\n\tif (!test_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\tfs_err(sdp, \"gfs2_quotad: %s error %d\\n\", msg, error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fxn",
          "args": [
            "sdp->sd_vfs",
            "0"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void quotad_check_timeo(struct gfs2_sbd *sdp, const char *msg,\n\t\t\t       int (*fxn)(struct super_block *sb, int type),\n\t\t\t       unsigned long t, unsigned long *timeo,\n\t\t\t       unsigned int *new_timeo)\n{\n\tif (t >= *timeo) {\n\t\tint error = fxn(sdp->sd_vfs, 0);\n\t\tquotad_error(sdp, msg, error);\n\t\t*timeo = gfs2_tune_get_i(&sdp->sd_tune, new_timeo) * HZ;\n\t} else {\n\t\t*timeo -= t;\n\t}\n}"
  },
  {
    "function_name": "quotad_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "1368-1374",
    "snippet": "static void quotad_error(struct gfs2_sbd *sdp, const char *msg, int error)\n{\n\tif (error == 0 || error == -EROFS)\n\t\treturn;\n\tif (!test_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\tfs_err(sdp, \"gfs2_quotad: %s error %d\\n\", msg, error);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "sdp",
            "\"gfs2_quotad: %s error %d\\n\"",
            "msg",
            "error"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "SDF_SHUTDOWN",
            "&sdp->sd_flags"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void quotad_error(struct gfs2_sbd *sdp, const char *msg, int error)\n{\n\tif (error == 0 || error == -EROFS)\n\t\treturn;\n\tif (!test_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\tfs_err(sdp, \"gfs2_quotad: %s error %d\\n\", msg, error);\n}"
  },
  {
    "function_name": "gfs2_quota_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "1331-1366",
    "snippet": "void gfs2_quota_cleanup(struct gfs2_sbd *sdp)\n{\n\tstruct list_head *head = &sdp->sd_quota_list;\n\tstruct gfs2_quota_data *qd;\n\n\tspin_lock(&qd_lock);\n\twhile (!list_empty(head)) {\n\t\tqd = list_entry(head->prev, struct gfs2_quota_data, qd_list);\n\n\t\tlist_del(&qd->qd_list);\n\n\t\t/* Also remove if this qd exists in the reclaim list */\n\t\tlist_lru_del(&gfs2_qd_lru, &qd->qd_lru);\n\t\tatomic_dec(&sdp->sd_quota_count);\n\t\tspin_unlock(&qd_lock);\n\n\t\tspin_lock_bucket(qd->qd_hash);\n\t\thlist_bl_del_rcu(&qd->qd_hlist);\n\t\tspin_unlock_bucket(qd->qd_hash);\n\n\t\tgfs2_assert_warn(sdp, !qd->qd_change);\n\t\tgfs2_assert_warn(sdp, !qd->qd_slot_count);\n\t\tgfs2_assert_warn(sdp, !qd->qd_bh_count);\n\n\t\tgfs2_glock_put(qd->qd_gl);\n\t\tcall_rcu(&qd->qd_rcu, gfs2_qd_dealloc);\n\n\t\tspin_lock(&qd_lock);\n\t}\n\tspin_unlock(&qd_lock);\n\n\tgfs2_assert_warn(sdp, !atomic_read(&sdp->sd_quota_count));\n\n\tkvfree(sdp->sd_quota_bitmap);\n\tsdp->sd_quota_bitmap = NULL;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(qd_lock);",
      "struct list_lru gfs2_qd_lru;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "sdp->sd_quota_bitmap"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_assert_warn",
          "args": [
            "sdp",
            "!atomic_read(&sdp->sd_quota_count)"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sdp->sd_quota_count"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&qd_lock"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&qd_lock"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&qd->qd_rcu",
            "gfs2_qd_dealloc"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_put",
          "args": [
            "qd->qd_gl"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "193-212",
          "snippet": "void gfs2_glock_put(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\n\tif (lockref_put_or_lock(&gl->gl_lockref))\n\t\treturn;\n\n\tlockref_mark_dead(&gl->gl_lockref);\n\n\tgfs2_glock_remove_from_lru(gl);\n\tspin_unlock(&gl->gl_lockref.lock);\n\tspin_lock_bucket(gl->gl_hash);\n\thlist_bl_del_rcu(&gl->gl_list);\n\tspin_unlock_bucket(gl->gl_hash);\n\tGLOCK_BUG_ON(gl, !list_empty(&gl->gl_holders));\n\tGLOCK_BUG_ON(gl, mapping && mapping->nrpages);\n\ttrace_gfs2_glock_put(gl);\n\tsdp->sd_lockstruct.ls_ops->lm_put_lock(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_put(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\n\tif (lockref_put_or_lock(&gl->gl_lockref))\n\t\treturn;\n\n\tlockref_mark_dead(&gl->gl_lockref);\n\n\tgfs2_glock_remove_from_lru(gl);\n\tspin_unlock(&gl->gl_lockref.lock);\n\tspin_lock_bucket(gl->gl_hash);\n\thlist_bl_del_rcu(&gl->gl_list);\n\tspin_unlock_bucket(gl->gl_hash);\n\tGLOCK_BUG_ON(gl, !list_empty(&gl->gl_holders));\n\tGLOCK_BUG_ON(gl, mapping && mapping->nrpages);\n\ttrace_gfs2_glock_put(gl);\n\tsdp->sd_lockstruct.ls_ops->lm_put_lock(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_assert_warn",
          "args": [
            "sdp",
            "!qd->qd_bh_count"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_assert_warn",
          "args": [
            "sdp",
            "!qd->qd_slot_count"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_assert_warn",
          "args": [
            "sdp",
            "!qd->qd_change"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_bl_del_rcu",
          "args": [
            "&qd->qd_hlist"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&sdp->sd_quota_count"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_del",
          "args": [
            "&gfs2_qd_lru",
            "&qd->qd_lru"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&qd->qd_list"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "head->prev",
            "structgfs2_quota_data",
            "qd_list"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\nstruct list_lru gfs2_qd_lru;\n\nvoid gfs2_quota_cleanup(struct gfs2_sbd *sdp)\n{\n\tstruct list_head *head = &sdp->sd_quota_list;\n\tstruct gfs2_quota_data *qd;\n\n\tspin_lock(&qd_lock);\n\twhile (!list_empty(head)) {\n\t\tqd = list_entry(head->prev, struct gfs2_quota_data, qd_list);\n\n\t\tlist_del(&qd->qd_list);\n\n\t\t/* Also remove if this qd exists in the reclaim list */\n\t\tlist_lru_del(&gfs2_qd_lru, &qd->qd_lru);\n\t\tatomic_dec(&sdp->sd_quota_count);\n\t\tspin_unlock(&qd_lock);\n\n\t\tspin_lock_bucket(qd->qd_hash);\n\t\thlist_bl_del_rcu(&qd->qd_hlist);\n\t\tspin_unlock_bucket(qd->qd_hash);\n\n\t\tgfs2_assert_warn(sdp, !qd->qd_change);\n\t\tgfs2_assert_warn(sdp, !qd->qd_slot_count);\n\t\tgfs2_assert_warn(sdp, !qd->qd_bh_count);\n\n\t\tgfs2_glock_put(qd->qd_gl);\n\t\tcall_rcu(&qd->qd_rcu, gfs2_qd_dealloc);\n\n\t\tspin_lock(&qd_lock);\n\t}\n\tspin_unlock(&qd_lock);\n\n\tgfs2_assert_warn(sdp, !atomic_read(&sdp->sd_quota_count));\n\n\tkvfree(sdp->sd_quota_bitmap);\n\tsdp->sd_quota_bitmap = NULL;\n}"
  },
  {
    "function_name": "gfs2_quota_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "1230-1329",
    "snippet": "int gfs2_quota_init(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_qc_inode);\n\tu64 size = i_size_read(sdp->sd_qc_inode);\n\tunsigned int blocks = size >> sdp->sd_sb.sb_bsize_shift;\n\tunsigned int x, slot = 0;\n\tunsigned int found = 0;\n\tunsigned int hash;\n\tunsigned int bm_size;\n\tu64 dblock;\n\tu32 extlen = 0;\n\tint error;\n\n\tif (gfs2_check_internal_file_size(sdp->sd_qc_inode, 1, 64 << 20))\n\t\treturn -EIO;\n\n\tsdp->sd_quota_slots = blocks * sdp->sd_qc_per_block;\n\tbm_size = DIV_ROUND_UP(sdp->sd_quota_slots, 8 * sizeof(unsigned long));\n\tbm_size *= sizeof(unsigned long);\n\terror = -ENOMEM;\n\tsdp->sd_quota_bitmap = kzalloc(bm_size, GFP_NOFS | __GFP_NOWARN);\n\tif (sdp->sd_quota_bitmap == NULL)\n\t\tsdp->sd_quota_bitmap = __vmalloc(bm_size, GFP_NOFS |\n\t\t\t\t\t\t __GFP_ZERO, PAGE_KERNEL);\n\tif (!sdp->sd_quota_bitmap)\n\t\treturn error;\n\n\tfor (x = 0; x < blocks; x++) {\n\t\tstruct buffer_head *bh;\n\t\tconst struct gfs2_quota_change *qc;\n\t\tunsigned int y;\n\n\t\tif (!extlen) {\n\t\t\tint new = 0;\n\t\t\terror = gfs2_extent_map(&ip->i_inode, x, &new, &dblock, &extlen);\n\t\t\tif (error)\n\t\t\t\tgoto fail;\n\t\t}\n\t\terror = -EIO;\n\t\tbh = gfs2_meta_ra(ip->i_gl, dblock, extlen);\n\t\tif (!bh)\n\t\t\tgoto fail;\n\t\tif (gfs2_metatype_check(sdp, bh, GFS2_METATYPE_QC)) {\n\t\t\tbrelse(bh);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tqc = (const struct gfs2_quota_change *)(bh->b_data + sizeof(struct gfs2_meta_header));\n\t\tfor (y = 0; y < sdp->sd_qc_per_block && slot < sdp->sd_quota_slots;\n\t\t     y++, slot++) {\n\t\t\tstruct gfs2_quota_data *qd;\n\t\t\ts64 qc_change = be64_to_cpu(qc->qc_change);\n\t\t\tu32 qc_flags = be32_to_cpu(qc->qc_flags);\n\t\t\tenum quota_type qtype = (qc_flags & GFS2_QCF_USER) ?\n\t\t\t\t\t\tUSRQUOTA : GRPQUOTA;\n\t\t\tstruct kqid qc_id = make_kqid(&init_user_ns, qtype,\n\t\t\t\t\t\t      be32_to_cpu(qc->qc_id));\n\t\t\tqc++;\n\t\t\tif (!qc_change)\n\t\t\t\tcontinue;\n\n\t\t\thash = gfs2_qd_hash(sdp, qc_id);\n\t\t\tqd = qd_alloc(hash, sdp, qc_id);\n\t\t\tif (qd == NULL) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tset_bit(QDF_CHANGE, &qd->qd_flags);\n\t\t\tqd->qd_change = qc_change;\n\t\t\tqd->qd_slot = slot;\n\t\t\tqd->qd_slot_count = 1;\n\n\t\t\tspin_lock(&qd_lock);\n\t\t\tBUG_ON(test_and_set_bit(slot, sdp->sd_quota_bitmap));\n\t\t\tlist_add(&qd->qd_list, &sdp->sd_quota_list);\n\t\t\tatomic_inc(&sdp->sd_quota_count);\n\t\t\tspin_unlock(&qd_lock);\n\n\t\t\tspin_lock_bucket(hash);\n\t\t\thlist_bl_add_head_rcu(&qd->qd_hlist, &qd_hash_table[hash]);\n\t\t\tspin_unlock_bucket(hash);\n\n\t\t\tfound++;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tdblock++;\n\t\textlen--;\n\t}\n\n\tif (found)\n\t\tfs_info(sdp, \"found %u quota changes\\n\", found);\n\n\treturn 0;\n\nfail:\n\tgfs2_quota_cleanup(sdp);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(qd_lock);",
      "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_quota_cleanup",
          "args": [
            "sdp"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1331-1366",
          "snippet": "void gfs2_quota_cleanup(struct gfs2_sbd *sdp)\n{\n\tstruct list_head *head = &sdp->sd_quota_list;\n\tstruct gfs2_quota_data *qd;\n\n\tspin_lock(&qd_lock);\n\twhile (!list_empty(head)) {\n\t\tqd = list_entry(head->prev, struct gfs2_quota_data, qd_list);\n\n\t\tlist_del(&qd->qd_list);\n\n\t\t/* Also remove if this qd exists in the reclaim list */\n\t\tlist_lru_del(&gfs2_qd_lru, &qd->qd_lru);\n\t\tatomic_dec(&sdp->sd_quota_count);\n\t\tspin_unlock(&qd_lock);\n\n\t\tspin_lock_bucket(qd->qd_hash);\n\t\thlist_bl_del_rcu(&qd->qd_hlist);\n\t\tspin_unlock_bucket(qd->qd_hash);\n\n\t\tgfs2_assert_warn(sdp, !qd->qd_change);\n\t\tgfs2_assert_warn(sdp, !qd->qd_slot_count);\n\t\tgfs2_assert_warn(sdp, !qd->qd_bh_count);\n\n\t\tgfs2_glock_put(qd->qd_gl);\n\t\tcall_rcu(&qd->qd_rcu, gfs2_qd_dealloc);\n\n\t\tspin_lock(&qd_lock);\n\t}\n\tspin_unlock(&qd_lock);\n\n\tgfs2_assert_warn(sdp, !atomic_read(&sdp->sd_quota_count));\n\n\tkvfree(sdp->sd_quota_bitmap);\n\tsdp->sd_quota_bitmap = NULL;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(qd_lock);",
            "struct list_lru gfs2_qd_lru;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\nstruct list_lru gfs2_qd_lru;\n\nvoid gfs2_quota_cleanup(struct gfs2_sbd *sdp)\n{\n\tstruct list_head *head = &sdp->sd_quota_list;\n\tstruct gfs2_quota_data *qd;\n\n\tspin_lock(&qd_lock);\n\twhile (!list_empty(head)) {\n\t\tqd = list_entry(head->prev, struct gfs2_quota_data, qd_list);\n\n\t\tlist_del(&qd->qd_list);\n\n\t\t/* Also remove if this qd exists in the reclaim list */\n\t\tlist_lru_del(&gfs2_qd_lru, &qd->qd_lru);\n\t\tatomic_dec(&sdp->sd_quota_count);\n\t\tspin_unlock(&qd_lock);\n\n\t\tspin_lock_bucket(qd->qd_hash);\n\t\thlist_bl_del_rcu(&qd->qd_hlist);\n\t\tspin_unlock_bucket(qd->qd_hash);\n\n\t\tgfs2_assert_warn(sdp, !qd->qd_change);\n\t\tgfs2_assert_warn(sdp, !qd->qd_slot_count);\n\t\tgfs2_assert_warn(sdp, !qd->qd_bh_count);\n\n\t\tgfs2_glock_put(qd->qd_gl);\n\t\tcall_rcu(&qd->qd_rcu, gfs2_qd_dealloc);\n\n\t\tspin_lock(&qd_lock);\n\t}\n\tspin_unlock(&qd_lock);\n\n\tgfs2_assert_warn(sdp, !atomic_read(&sdp->sd_quota_count));\n\n\tkvfree(sdp->sd_quota_bitmap);\n\tsdp->sd_quota_bitmap = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_info",
          "args": [
            "sdp",
            "\"found %u quota changes\\n\"",
            "found"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "280-288",
          "snippet": "void reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_bucket",
          "args": [
            "hash"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_bl_add_head_rcu",
          "args": [
            "&qd->qd_hlist",
            "&qd_hash_table[hash]"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bucket",
          "args": [
            "hash"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sdp->sd_quota_count"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&qd->qd_list",
            "&sdp->sd_quota_list"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "test_and_set_bit(slot, sdp->sd_quota_bitmap)"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "slot",
            "sdp->sd_quota_bitmap"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "QDF_CHANGE",
            "&qd->qd_flags"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qd_alloc",
          "args": [
            "hash",
            "sdp",
            "qc_id"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "qd_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "214-241",
          "snippet": "static struct gfs2_quota_data *qd_alloc(unsigned hash, struct gfs2_sbd *sdp, struct kqid qid)\n{\n\tstruct gfs2_quota_data *qd;\n\tint error;\n\n\tqd = kmem_cache_zalloc(gfs2_quotad_cachep, GFP_NOFS);\n\tif (!qd)\n\t\treturn NULL;\n\n\tqd->qd_sbd = sdp;\n\tqd->qd_lockref.count = 1;\n\tspin_lock_init(&qd->qd_lockref.lock);\n\tqd->qd_id = qid;\n\tqd->qd_slot = -1;\n\tINIT_LIST_HEAD(&qd->qd_lru);\n\tqd->qd_hash = hash;\n\n\terror = gfs2_glock_get(sdp, qd2index(qd),\n\t\t\t      &gfs2_quota_glops, CREATE, &qd->qd_gl);\n\tif (error)\n\t\tgoto fail;\n\n\treturn qd;\n\nfail:\n\tkmem_cache_free(gfs2_quotad_cachep, qd);\n\treturn NULL;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct gfs2_quota_data *qd_alloc(unsigned hash, struct gfs2_sbd *sdp, struct kqid qid)\n{\n\tstruct gfs2_quota_data *qd;\n\tint error;\n\n\tqd = kmem_cache_zalloc(gfs2_quotad_cachep, GFP_NOFS);\n\tif (!qd)\n\t\treturn NULL;\n\n\tqd->qd_sbd = sdp;\n\tqd->qd_lockref.count = 1;\n\tspin_lock_init(&qd->qd_lockref.lock);\n\tqd->qd_id = qid;\n\tqd->qd_slot = -1;\n\tINIT_LIST_HEAD(&qd->qd_lru);\n\tqd->qd_hash = hash;\n\n\terror = gfs2_glock_get(sdp, qd2index(qd),\n\t\t\t      &gfs2_quota_glops, CREATE, &qd->qd_gl);\n\tif (error)\n\t\tgoto fail;\n\n\treturn qd;\n\nfail:\n\tkmem_cache_free(gfs2_quotad_cachep, qd);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_qd_hash",
          "args": [
            "sdp",
            "qc_id"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_qd_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "88-97",
          "snippet": "static unsigned int gfs2_qd_hash(const struct gfs2_sbd *sdp,\n\t\t\t\t const struct kqid qid)\n{\n\tunsigned int h;\n\n\th = jhash(&sdp, sizeof(struct gfs2_sbd *), 0);\n\th = jhash(&qid, sizeof(struct kqid), h);\n\n\treturn h & GFS2_QD_HASH_MASK;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define GFS2_QD_HASH_MASK       (GFS2_QD_HASH_SIZE - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define GFS2_QD_HASH_MASK       (GFS2_QD_HASH_SIZE - 1)\n\nstatic unsigned int gfs2_qd_hash(const struct gfs2_sbd *sdp,\n\t\t\t\t const struct kqid qid)\n{\n\tunsigned int h;\n\n\th = jhash(&sdp, sizeof(struct gfs2_sbd *), 0);\n\th = jhash(&qid, sizeof(struct kqid), h);\n\n\treturn h & GFS2_QD_HASH_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kqid",
          "args": [
            "&init_user_ns",
            "qtype",
            "be32_to_cpu(qc->qc_id)"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "qc->qc_id"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "qc->qc_flags"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "qc->qc_change"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_metatype_check",
          "args": [
            "sdp",
            "bh",
            "GFS2_METATYPE_QC"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_meta_ra",
          "args": [
            "ip->i_gl",
            "dblock",
            "extlen"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "363-402",
          "snippet": "struct buffer_head *gfs2_meta_ra(struct gfs2_glock *gl, u64 dblock, u32 extlen)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct buffer_head *first_bh, *bh;\n\tu32 max_ra = gfs2_tune_get(sdp, gt_max_readahead) >>\n\t\t\t  sdp->sd_sb.sb_bsize_shift;\n\n\tBUG_ON(!extlen);\n\n\tif (max_ra < 1)\n\t\tmax_ra = 1;\n\tif (extlen > max_ra)\n\t\textlen = max_ra;\n\n\tfirst_bh = gfs2_getbuf(gl, dblock, CREATE);\n\n\tif (buffer_uptodate(first_bh))\n\t\tgoto out;\n\tif (!buffer_locked(first_bh))\n\t\tll_rw_block(READ_SYNC | REQ_META, 1, &first_bh);\n\n\tdblock++;\n\textlen--;\n\n\twhile (extlen) {\n\t\tbh = gfs2_getbuf(gl, dblock, CREATE);\n\n\t\tif (!buffer_uptodate(bh) && !buffer_locked(bh))\n\t\t\tll_rw_block(READA | REQ_META, 1, &bh);\n\t\tbrelse(bh);\n\t\tdblock++;\n\t\textlen--;\n\t\tif (!buffer_locked(first_bh) && buffer_uptodate(first_bh))\n\t\t\tgoto out;\n\t}\n\n\twait_on_buffer(first_bh);\nout:\n\treturn first_bh;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct buffer_head *gfs2_meta_ra(struct gfs2_glock *gl, u64 dblock, u32 extlen)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct buffer_head *first_bh, *bh;\n\tu32 max_ra = gfs2_tune_get(sdp, gt_max_readahead) >>\n\t\t\t  sdp->sd_sb.sb_bsize_shift;\n\n\tBUG_ON(!extlen);\n\n\tif (max_ra < 1)\n\t\tmax_ra = 1;\n\tif (extlen > max_ra)\n\t\textlen = max_ra;\n\n\tfirst_bh = gfs2_getbuf(gl, dblock, CREATE);\n\n\tif (buffer_uptodate(first_bh))\n\t\tgoto out;\n\tif (!buffer_locked(first_bh))\n\t\tll_rw_block(READ_SYNC | REQ_META, 1, &first_bh);\n\n\tdblock++;\n\textlen--;\n\n\twhile (extlen) {\n\t\tbh = gfs2_getbuf(gl, dblock, CREATE);\n\n\t\tif (!buffer_uptodate(bh) && !buffer_locked(bh))\n\t\t\tll_rw_block(READA | REQ_META, 1, &bh);\n\t\tbrelse(bh);\n\t\tdblock++;\n\t\textlen--;\n\t\tif (!buffer_locked(first_bh) && buffer_uptodate(first_bh))\n\t\t\tgoto out;\n\t}\n\n\twait_on_buffer(first_bh);\nout:\n\treturn first_bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_extent_map",
          "args": [
            "&ip->i_inode",
            "x",
            "&new",
            "&dblock",
            "&extlen"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "682-701",
          "snippet": "int gfs2_extent_map(struct inode *inode, u64 lblock, int *new, u64 *dblock, unsigned *extlen)\n{\n\tstruct buffer_head bh = { .b_state = 0, .b_blocknr = 0 };\n\tint ret;\n\tint create = *new;\n\n\tBUG_ON(!extlen);\n\tBUG_ON(!dblock);\n\tBUG_ON(!new);\n\n\tbh.b_size = 1 << (inode->i_blkbits + (create ? 0 : 5));\n\tret = gfs2_block_map(inode, lblock, &bh, create);\n\t*extlen = bh.b_size >> inode->i_blkbits;\n\t*dblock = bh.b_blocknr;\n\tif (buffer_new(&bh))\n\t\t*new = 1;\n\telse\n\t\t*new = 0;\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_extent_map(struct inode *inode, u64 lblock, int *new, u64 *dblock, unsigned *extlen)\n{\n\tstruct buffer_head bh = { .b_state = 0, .b_blocknr = 0 };\n\tint ret;\n\tint create = *new;\n\n\tBUG_ON(!extlen);\n\tBUG_ON(!dblock);\n\tBUG_ON(!new);\n\n\tbh.b_size = 1 << (inode->i_blkbits + (create ? 0 : 5));\n\tret = gfs2_block_map(inode, lblock, &bh, create);\n\t*extlen = bh.b_size >> inode->i_blkbits;\n\t*dblock = bh.b_blocknr;\n\tif (buffer_new(&bh))\n\t\t*new = 1;\n\telse\n\t\t*new = 0;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__vmalloc",
          "args": [
            "bm_size",
            "GFP_NOFS |\n\t\t\t\t\t\t __GFP_ZERO",
            "PAGE_KERNEL"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "bm_size",
            "GFP_NOFS | __GFP_NOWARN"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "sdp->sd_quota_slots",
            "8 * sizeof(unsigned long)"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_check_internal_file_size",
          "args": [
            "sdp->sd_qc_inode",
            "1",
            "64 << 20"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_check_internal_file_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "82-94",
          "snippet": "static inline int gfs2_check_internal_file_size(struct inode *inode,\n\t\t\t\t\t\tu64 minsize, u64 maxsize)\n{\n\tu64 size = i_size_read(inode);\n\tif (size < minsize || size > maxsize)\n\t\tgoto err;\n\tif (size & ((1 << inode->i_blkbits) - 1))\n\t\tgoto err;\n\treturn 0;\nerr:\n\tgfs2_consist_inode(GFS2_I(inode));\n\treturn -EIO;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_check_internal_file_size(struct inode *inode,\n\t\t\t\t\t\tu64 minsize, u64 maxsize)\n{\n\tu64 size = i_size_read(inode);\n\tif (size < minsize || size > maxsize)\n\t\tgoto err;\n\tif (size & ((1 << inode->i_blkbits) - 1))\n\t\tgoto err;\n\treturn 0;\nerr:\n\tgfs2_consist_inode(GFS2_I(inode));\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "sdp->sd_qc_inode"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "sdp->sd_qc_inode"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nint gfs2_quota_init(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_qc_inode);\n\tu64 size = i_size_read(sdp->sd_qc_inode);\n\tunsigned int blocks = size >> sdp->sd_sb.sb_bsize_shift;\n\tunsigned int x, slot = 0;\n\tunsigned int found = 0;\n\tunsigned int hash;\n\tunsigned int bm_size;\n\tu64 dblock;\n\tu32 extlen = 0;\n\tint error;\n\n\tif (gfs2_check_internal_file_size(sdp->sd_qc_inode, 1, 64 << 20))\n\t\treturn -EIO;\n\n\tsdp->sd_quota_slots = blocks * sdp->sd_qc_per_block;\n\tbm_size = DIV_ROUND_UP(sdp->sd_quota_slots, 8 * sizeof(unsigned long));\n\tbm_size *= sizeof(unsigned long);\n\terror = -ENOMEM;\n\tsdp->sd_quota_bitmap = kzalloc(bm_size, GFP_NOFS | __GFP_NOWARN);\n\tif (sdp->sd_quota_bitmap == NULL)\n\t\tsdp->sd_quota_bitmap = __vmalloc(bm_size, GFP_NOFS |\n\t\t\t\t\t\t __GFP_ZERO, PAGE_KERNEL);\n\tif (!sdp->sd_quota_bitmap)\n\t\treturn error;\n\n\tfor (x = 0; x < blocks; x++) {\n\t\tstruct buffer_head *bh;\n\t\tconst struct gfs2_quota_change *qc;\n\t\tunsigned int y;\n\n\t\tif (!extlen) {\n\t\t\tint new = 0;\n\t\t\terror = gfs2_extent_map(&ip->i_inode, x, &new, &dblock, &extlen);\n\t\t\tif (error)\n\t\t\t\tgoto fail;\n\t\t}\n\t\terror = -EIO;\n\t\tbh = gfs2_meta_ra(ip->i_gl, dblock, extlen);\n\t\tif (!bh)\n\t\t\tgoto fail;\n\t\tif (gfs2_metatype_check(sdp, bh, GFS2_METATYPE_QC)) {\n\t\t\tbrelse(bh);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tqc = (const struct gfs2_quota_change *)(bh->b_data + sizeof(struct gfs2_meta_header));\n\t\tfor (y = 0; y < sdp->sd_qc_per_block && slot < sdp->sd_quota_slots;\n\t\t     y++, slot++) {\n\t\t\tstruct gfs2_quota_data *qd;\n\t\t\ts64 qc_change = be64_to_cpu(qc->qc_change);\n\t\t\tu32 qc_flags = be32_to_cpu(qc->qc_flags);\n\t\t\tenum quota_type qtype = (qc_flags & GFS2_QCF_USER) ?\n\t\t\t\t\t\tUSRQUOTA : GRPQUOTA;\n\t\t\tstruct kqid qc_id = make_kqid(&init_user_ns, qtype,\n\t\t\t\t\t\t      be32_to_cpu(qc->qc_id));\n\t\t\tqc++;\n\t\t\tif (!qc_change)\n\t\t\t\tcontinue;\n\n\t\t\thash = gfs2_qd_hash(sdp, qc_id);\n\t\t\tqd = qd_alloc(hash, sdp, qc_id);\n\t\t\tif (qd == NULL) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tset_bit(QDF_CHANGE, &qd->qd_flags);\n\t\t\tqd->qd_change = qc_change;\n\t\t\tqd->qd_slot = slot;\n\t\t\tqd->qd_slot_count = 1;\n\n\t\t\tspin_lock(&qd_lock);\n\t\t\tBUG_ON(test_and_set_bit(slot, sdp->sd_quota_bitmap));\n\t\t\tlist_add(&qd->qd_list, &sdp->sd_quota_list);\n\t\t\tatomic_inc(&sdp->sd_quota_count);\n\t\t\tspin_unlock(&qd_lock);\n\n\t\t\tspin_lock_bucket(hash);\n\t\t\thlist_bl_add_head_rcu(&qd->qd_hlist, &qd_hash_table[hash]);\n\t\t\tspin_unlock_bucket(hash);\n\n\t\t\tfound++;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tdblock++;\n\t\textlen--;\n\t}\n\n\tif (found)\n\t\tfs_info(sdp, \"found %u quota changes\\n\", found);\n\n\treturn 0;\n\nfail:\n\tgfs2_quota_cleanup(sdp);\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_quota_refresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "1212-1228",
    "snippet": "int gfs2_quota_refresh(struct gfs2_sbd *sdp, struct kqid qid)\n{\n\tstruct gfs2_quota_data *qd;\n\tstruct gfs2_holder q_gh;\n\tint error;\n\n\terror = qd_get(sdp, qid, &qd);\n\tif (error)\n\t\treturn error;\n\n\terror = do_glock(qd, FORCE, &q_gh);\n\tif (!error)\n\t\tgfs2_glock_dq_uninit(&q_gh);\n\n\tqd_put(qd);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qd_put",
          "args": [
            "qd"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "qd_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "310-319",
          "snippet": "static void qd_put(struct gfs2_quota_data *qd)\n{\n\tif (lockref_put_or_lock(&qd->qd_lockref))\n\t\treturn;\n\n\tqd->qd_lockref.count = 0;\n\tlist_lru_add(&gfs2_qd_lru, &qd->qd_lru);\n\tspin_unlock(&qd->qd_lockref.lock);\n\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_lru gfs2_qd_lru;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct list_lru gfs2_qd_lru;\n\nstatic void qd_put(struct gfs2_quota_data *qd)\n{\n\tif (lockref_put_or_lock(&qd->qd_lockref))\n\t\treturn;\n\n\tqd->qd_lockref.count = 0;\n\tlist_lru_add(&gfs2_qd_lru, &qd->qd_lru);\n\tspin_unlock(&qd->qd_lockref.lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&q_gh"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_glock",
          "args": [
            "qd",
            "FORCE",
            "&q_gh"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "do_glock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "913-956",
          "snippet": "static int do_glock(struct gfs2_quota_data *qd, int force_refresh,\n\t\t    struct gfs2_holder *q_gh)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_holder i_gh;\n\tint error;\n\nrestart:\n\terror = gfs2_glock_nq_init(qd->qd_gl, LM_ST_SHARED, 0, q_gh);\n\tif (error)\n\t\treturn error;\n\n\tqd->qd_qb = *(struct gfs2_quota_lvb *)qd->qd_gl->gl_lksb.sb_lvbptr;\n\n\tif (force_refresh || qd->qd_qb.qb_magic != cpu_to_be32(GFS2_MAGIC)) {\n\t\tgfs2_glock_dq_uninit(q_gh);\n\t\terror = gfs2_glock_nq_init(qd->qd_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t   GL_NOCACHE, q_gh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, 0, &i_gh);\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\terror = update_qd(sdp, qd);\n\t\tif (error)\n\t\t\tgoto fail_gunlock;\n\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\t\tgfs2_glock_dq_uninit(q_gh);\n\t\tforce_refresh = 0;\n\t\tgoto restart;\n\t}\n\n\treturn 0;\n\nfail_gunlock:\n\tgfs2_glock_dq_uninit(&i_gh);\nfail:\n\tgfs2_glock_dq_uninit(q_gh);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int do_glock(struct gfs2_quota_data *qd, int force_refresh,\n\t\t    struct gfs2_holder *q_gh)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_holder i_gh;\n\tint error;\n\nrestart:\n\terror = gfs2_glock_nq_init(qd->qd_gl, LM_ST_SHARED, 0, q_gh);\n\tif (error)\n\t\treturn error;\n\n\tqd->qd_qb = *(struct gfs2_quota_lvb *)qd->qd_gl->gl_lksb.sb_lvbptr;\n\n\tif (force_refresh || qd->qd_qb.qb_magic != cpu_to_be32(GFS2_MAGIC)) {\n\t\tgfs2_glock_dq_uninit(q_gh);\n\t\terror = gfs2_glock_nq_init(qd->qd_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t   GL_NOCACHE, q_gh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, 0, &i_gh);\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\terror = update_qd(sdp, qd);\n\t\tif (error)\n\t\t\tgoto fail_gunlock;\n\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\t\tgfs2_glock_dq_uninit(q_gh);\n\t\tforce_refresh = 0;\n\t\tgoto restart;\n\t}\n\n\treturn 0;\n\nfail_gunlock:\n\tgfs2_glock_dq_uninit(&i_gh);\nfail:\n\tgfs2_glock_dq_uninit(q_gh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qd_get",
          "args": [
            "sdp",
            "qid",
            "&qd"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "qd_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "265-300",
          "snippet": "static int qd_get(struct gfs2_sbd *sdp, struct kqid qid,\n\t\t  struct gfs2_quota_data **qdp)\n{\n\tstruct gfs2_quota_data *qd, *new_qd;\n\tunsigned int hash = gfs2_qd_hash(sdp, qid);\n\n\trcu_read_lock();\n\t*qdp = qd = gfs2_qd_search_bucket(hash, sdp, qid);\n\trcu_read_unlock();\n\n\tif (qd)\n\t\treturn 0;\n\n\tnew_qd = qd_alloc(hash, sdp, qid);\n\tif (!new_qd)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&qd_lock);\n\tspin_lock_bucket(hash);\n\t*qdp = qd = gfs2_qd_search_bucket(hash, sdp, qid);\n\tif (qd == NULL) {\n\t\t*qdp = new_qd;\n\t\tlist_add(&new_qd->qd_list, &sdp->sd_quota_list);\n\t\thlist_bl_add_head_rcu(&new_qd->qd_hlist, &qd_hash_table[hash]);\n\t\tatomic_inc(&sdp->sd_quota_count);\n\t}\n\tspin_unlock_bucket(hash);\n\tspin_unlock(&qd_lock);\n\n\tif (qd) {\n\t\tgfs2_glock_put(new_qd->qd_gl);\n\t\tkmem_cache_free(gfs2_quotad_cachep, new_qd);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(qd_lock);",
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic int qd_get(struct gfs2_sbd *sdp, struct kqid qid,\n\t\t  struct gfs2_quota_data **qdp)\n{\n\tstruct gfs2_quota_data *qd, *new_qd;\n\tunsigned int hash = gfs2_qd_hash(sdp, qid);\n\n\trcu_read_lock();\n\t*qdp = qd = gfs2_qd_search_bucket(hash, sdp, qid);\n\trcu_read_unlock();\n\n\tif (qd)\n\t\treturn 0;\n\n\tnew_qd = qd_alloc(hash, sdp, qid);\n\tif (!new_qd)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&qd_lock);\n\tspin_lock_bucket(hash);\n\t*qdp = qd = gfs2_qd_search_bucket(hash, sdp, qid);\n\tif (qd == NULL) {\n\t\t*qdp = new_qd;\n\t\tlist_add(&new_qd->qd_list, &sdp->sd_quota_list);\n\t\thlist_bl_add_head_rcu(&new_qd->qd_hlist, &qd_hash_table[hash]);\n\t\tatomic_inc(&sdp->sd_quota_count);\n\t}\n\tspin_unlock_bucket(hash);\n\tspin_unlock(&qd_lock);\n\n\tif (qd) {\n\t\tgfs2_glock_put(new_qd->qd_gl);\n\t\tkmem_cache_free(gfs2_quotad_cachep, new_qd);\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_quota_refresh(struct gfs2_sbd *sdp, struct kqid qid)\n{\n\tstruct gfs2_quota_data *qd;\n\tstruct gfs2_holder q_gh;\n\tint error;\n\n\terror = qd_get(sdp, qid, &qd);\n\tif (error)\n\t\treturn error;\n\n\terror = do_glock(qd, FORCE, &q_gh);\n\tif (!error)\n\t\tgfs2_glock_dq_uninit(&q_gh);\n\n\tqd_put(qd);\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_quota_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "1166-1210",
    "snippet": "int gfs2_quota_sync(struct super_block *sb, int type)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct gfs2_quota_data **qda;\n\tunsigned int max_qd = PAGE_SIZE/sizeof(struct gfs2_holder);\n\tunsigned int num_qd;\n\tunsigned int x;\n\tint error = 0;\n\n\tqda = kcalloc(max_qd, sizeof(struct gfs2_quota_data *), GFP_KERNEL);\n\tif (!qda)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&sdp->sd_quota_sync_mutex);\n\tsdp->sd_quota_sync_gen++;\n\n\tdo {\n\t\tnum_qd = 0;\n\n\t\tfor (;;) {\n\t\t\terror = qd_fish(sdp, qda + num_qd);\n\t\t\tif (error || !qda[num_qd])\n\t\t\t\tbreak;\n\t\t\tif (++num_qd == max_qd)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (num_qd) {\n\t\t\tif (!error)\n\t\t\t\terror = do_sync(num_qd, qda);\n\t\t\tif (!error)\n\t\t\t\tfor (x = 0; x < num_qd; x++)\n\t\t\t\t\tqda[x]->qd_sync_gen =\n\t\t\t\t\t\tsdp->sd_quota_sync_gen;\n\n\t\t\tfor (x = 0; x < num_qd; x++)\n\t\t\t\tqd_unlock(qda[x]);\n\t\t}\n\t} while (!error && num_qd == max_qd);\n\n\tmutex_unlock(&sdp->sd_quota_sync_mutex);\n\tkfree(qda);\n\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "qda"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sdp->sd_quota_sync_mutex"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qd_unlock",
          "args": [
            "qda[x]"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "qd_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "487-495",
          "snippet": "static void qd_unlock(struct gfs2_quota_data *qd)\n{\n\tgfs2_assert_warn(qd->qd_gl->gl_sbd,\n\t\t\t test_bit(QDF_LOCKED, &qd->qd_flags));\n\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\tbh_put(qd);\n\tslot_put(qd);\n\tqd_put(qd);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void qd_unlock(struct gfs2_quota_data *qd)\n{\n\tgfs2_assert_warn(qd->qd_gl->gl_sbd,\n\t\t\t test_bit(QDF_LOCKED, &qd->qd_flags));\n\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\tbh_put(qd);\n\tslot_put(qd);\n\tqd_put(qd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_sync",
          "args": [
            "num_qd",
            "qda"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "do_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "791-886",
          "snippet": "static int do_sync(unsigned int num_qd, struct gfs2_quota_data **qda)\n{\n\tstruct gfs2_sbd *sdp = (*qda)->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_alloc_parms ap = { .aflags = 0, };\n\tunsigned int data_blocks, ind_blocks;\n\tstruct gfs2_holder *ghs, i_gh;\n\tunsigned int qx, x;\n\tstruct gfs2_quota_data *qd;\n\tunsigned reserved;\n\tloff_t offset;\n\tunsigned int nalloc = 0, blocks;\n\tint error;\n\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\treturn error;\n\n\tgfs2_write_calc_reserv(ip, sizeof(struct gfs2_quota),\n\t\t\t      &data_blocks, &ind_blocks);\n\n\tghs = kcalloc(num_qd, sizeof(struct gfs2_holder), GFP_NOFS);\n\tif (!ghs)\n\t\treturn -ENOMEM;\n\n\tsort(qda, num_qd, sizeof(struct gfs2_quota_data *), sort_qd, NULL);\n\tmutex_lock(&ip->i_inode.i_mutex);\n\tfor (qx = 0; qx < num_qd; qx++) {\n\t\terror = gfs2_glock_nq_init(qda[qx]->qd_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t   GL_NOCACHE, &ghs[qx]);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &i_gh);\n\tif (error)\n\t\tgoto out;\n\n\tfor (x = 0; x < num_qd; x++) {\n\t\toffset = qd2offset(qda[x]);\n\t\tif (gfs2_write_alloc_required(ip, offset,\n\t\t\t\t\t      sizeof(struct gfs2_quota)))\n\t\t\tnalloc++;\n\t}\n\n\t/* \n\t * 1 blk for unstuffing inode if stuffed. We add this extra\n\t * block to the reservation unconditionally. If the inode\n\t * doesn't need unstuffing, the block will be released to the \n\t * rgrp since it won't be allocated during the transaction\n\t */\n\t/* +3 in the end for unstuffing block, inode size update block\n\t * and another block in case quota straddles page boundary and \n\t * two blocks need to be updated instead of 1 */\n\tblocks = num_qd * data_blocks + RES_DINODE + num_qd + 3;\n\n\treserved = 1 + (nalloc * (data_blocks + ind_blocks));\n\tap.target = reserved;\n\terror = gfs2_inplace_reserve(ip, &ap);\n\tif (error)\n\t\tgoto out_alloc;\n\n\tif (nalloc)\n\t\tblocks += gfs2_rg_blocks(ip, reserved) + nalloc * ind_blocks + RES_STATFS;\n\n\terror = gfs2_trans_begin(sdp, blocks, 0);\n\tif (error)\n\t\tgoto out_ipres;\n\n\tfor (x = 0; x < num_qd; x++) {\n\t\tqd = qda[x];\n\t\toffset = qd2offset(qd);\n\t\terror = gfs2_adjust_quota(ip, offset, qd->qd_change_sync, qd, NULL);\n\t\tif (error)\n\t\t\tgoto out_end_trans;\n\n\t\tdo_qc(qd, -qd->qd_change_sync);\n\t\tset_bit(QDF_REFRESH, &qd->qd_flags);\n\t}\n\n\terror = 0;\n\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_ipres:\n\tgfs2_inplace_release(ip);\nout_alloc:\n\tgfs2_glock_dq_uninit(&i_gh);\nout:\n\twhile (qx--)\n\t\tgfs2_glock_dq_uninit(&ghs[qx]);\n\tmutex_unlock(&ip->i_inode.i_mutex);\n\tkfree(ghs);\n\tgfs2_log_flush(ip->i_gl->gl_sbd, ip->i_gl, NORMAL_FLUSH);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int do_sync(unsigned int num_qd, struct gfs2_quota_data **qda)\n{\n\tstruct gfs2_sbd *sdp = (*qda)->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_alloc_parms ap = { .aflags = 0, };\n\tunsigned int data_blocks, ind_blocks;\n\tstruct gfs2_holder *ghs, i_gh;\n\tunsigned int qx, x;\n\tstruct gfs2_quota_data *qd;\n\tunsigned reserved;\n\tloff_t offset;\n\tunsigned int nalloc = 0, blocks;\n\tint error;\n\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\treturn error;\n\n\tgfs2_write_calc_reserv(ip, sizeof(struct gfs2_quota),\n\t\t\t      &data_blocks, &ind_blocks);\n\n\tghs = kcalloc(num_qd, sizeof(struct gfs2_holder), GFP_NOFS);\n\tif (!ghs)\n\t\treturn -ENOMEM;\n\n\tsort(qda, num_qd, sizeof(struct gfs2_quota_data *), sort_qd, NULL);\n\tmutex_lock(&ip->i_inode.i_mutex);\n\tfor (qx = 0; qx < num_qd; qx++) {\n\t\terror = gfs2_glock_nq_init(qda[qx]->qd_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t   GL_NOCACHE, &ghs[qx]);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &i_gh);\n\tif (error)\n\t\tgoto out;\n\n\tfor (x = 0; x < num_qd; x++) {\n\t\toffset = qd2offset(qda[x]);\n\t\tif (gfs2_write_alloc_required(ip, offset,\n\t\t\t\t\t      sizeof(struct gfs2_quota)))\n\t\t\tnalloc++;\n\t}\n\n\t/* \n\t * 1 blk for unstuffing inode if stuffed. We add this extra\n\t * block to the reservation unconditionally. If the inode\n\t * doesn't need unstuffing, the block will be released to the \n\t * rgrp since it won't be allocated during the transaction\n\t */\n\t/* +3 in the end for unstuffing block, inode size update block\n\t * and another block in case quota straddles page boundary and \n\t * two blocks need to be updated instead of 1 */\n\tblocks = num_qd * data_blocks + RES_DINODE + num_qd + 3;\n\n\treserved = 1 + (nalloc * (data_blocks + ind_blocks));\n\tap.target = reserved;\n\terror = gfs2_inplace_reserve(ip, &ap);\n\tif (error)\n\t\tgoto out_alloc;\n\n\tif (nalloc)\n\t\tblocks += gfs2_rg_blocks(ip, reserved) + nalloc * ind_blocks + RES_STATFS;\n\n\terror = gfs2_trans_begin(sdp, blocks, 0);\n\tif (error)\n\t\tgoto out_ipres;\n\n\tfor (x = 0; x < num_qd; x++) {\n\t\tqd = qda[x];\n\t\toffset = qd2offset(qd);\n\t\terror = gfs2_adjust_quota(ip, offset, qd->qd_change_sync, qd, NULL);\n\t\tif (error)\n\t\t\tgoto out_end_trans;\n\n\t\tdo_qc(qd, -qd->qd_change_sync);\n\t\tset_bit(QDF_REFRESH, &qd->qd_flags);\n\t}\n\n\terror = 0;\n\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_ipres:\n\tgfs2_inplace_release(ip);\nout_alloc:\n\tgfs2_glock_dq_uninit(&i_gh);\nout:\n\twhile (qx--)\n\t\tgfs2_glock_dq_uninit(&ghs[qx]);\n\tmutex_unlock(&ip->i_inode.i_mutex);\n\tkfree(ghs);\n\tgfs2_log_flush(ip->i_gl->gl_sbd, ip->i_gl, NORMAL_FLUSH);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qd_fish",
          "args": [
            "sdp",
            "qda + num_qd"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "qd_fish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "447-485",
          "snippet": "static int qd_fish(struct gfs2_sbd *sdp, struct gfs2_quota_data **qdp)\n{\n\tstruct gfs2_quota_data *qd = NULL;\n\tint error;\n\tint found = 0;\n\n\t*qdp = NULL;\n\n\tif (sdp->sd_vfs->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tspin_lock(&qd_lock);\n\n\tlist_for_each_entry(qd, &sdp->sd_quota_list, qd_list) {\n\t\tfound = qd_check_sync(sdp, qd, &sdp->sd_quota_sync_gen);\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\n\tif (!found)\n\t\tqd = NULL;\n\n\tspin_unlock(&qd_lock);\n\n\tif (qd) {\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\terror = bh_get(qd);\n\t\tif (error) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\t*qdp = qd;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(qd_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\n\nstatic int qd_fish(struct gfs2_sbd *sdp, struct gfs2_quota_data **qdp)\n{\n\tstruct gfs2_quota_data *qd = NULL;\n\tint error;\n\tint found = 0;\n\n\t*qdp = NULL;\n\n\tif (sdp->sd_vfs->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tspin_lock(&qd_lock);\n\n\tlist_for_each_entry(qd, &sdp->sd_quota_list, qd_list) {\n\t\tfound = qd_check_sync(sdp, qd, &sdp->sd_quota_sync_gen);\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\n\tif (!found)\n\t\tqd = NULL;\n\n\tspin_unlock(&qd_lock);\n\n\tif (qd) {\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\terror = bh_get(qd);\n\t\tif (error) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\t*qdp = qd;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sdp->sd_quota_sync_mutex"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "max_qd",
            "sizeof(struct gfs2_quota_data *)",
            "GFP_KERNEL"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_quota_sync(struct super_block *sb, int type)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct gfs2_quota_data **qda;\n\tunsigned int max_qd = PAGE_SIZE/sizeof(struct gfs2_holder);\n\tunsigned int num_qd;\n\tunsigned int x;\n\tint error = 0;\n\n\tqda = kcalloc(max_qd, sizeof(struct gfs2_quota_data *), GFP_KERNEL);\n\tif (!qda)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&sdp->sd_quota_sync_mutex);\n\tsdp->sd_quota_sync_gen++;\n\n\tdo {\n\t\tnum_qd = 0;\n\n\t\tfor (;;) {\n\t\t\terror = qd_fish(sdp, qda + num_qd);\n\t\t\tif (error || !qda[num_qd])\n\t\t\t\tbreak;\n\t\t\tif (++num_qd == max_qd)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (num_qd) {\n\t\t\tif (!error)\n\t\t\t\terror = do_sync(num_qd, qda);\n\t\t\tif (!error)\n\t\t\t\tfor (x = 0; x < num_qd; x++)\n\t\t\t\t\tqda[x]->qd_sync_gen =\n\t\t\t\t\t\tsdp->sd_quota_sync_gen;\n\n\t\t\tfor (x = 0; x < num_qd; x++)\n\t\t\t\tqd_unlock(qda[x]);\n\t\t}\n\t} while (!error && num_qd == max_qd);\n\n\tmutex_unlock(&sdp->sd_quota_sync_mutex);\n\tkfree(qda);\n\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_quota_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "1145-1164",
    "snippet": "void gfs2_quota_change(struct gfs2_inode *ip, s64 change,\n\t\t       kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_quota_data *qd;\n\tunsigned int x;\n\n\tif (gfs2_assert_warn(GFS2_SB(&ip->i_inode), change))\n\t\treturn;\n\tif (ip->i_diskflags & GFS2_DIF_SYSTEM)\n\t\treturn;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\n\t\tif (qid_eq(qd->qd_id, make_kqid_uid(uid)) ||\n\t\t    qid_eq(qd->qd_id, make_kqid_gid(gid))) {\n\t\t\tdo_qc(qd, change);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_qc",
          "args": [
            "qd",
            "change"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "do_qc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "615-653",
          "snippet": "static void do_qc(struct gfs2_quota_data *qd, s64 change)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_qc_inode);\n\tstruct gfs2_quota_change *qc = qd->qd_bh_qc;\n\ts64 x;\n\n\tmutex_lock(&sdp->sd_quota_mutex);\n\tgfs2_trans_add_meta(ip->i_gl, qd->qd_bh);\n\n\tif (!test_bit(QDF_CHANGE, &qd->qd_flags)) {\n\t\tqc->qc_change = 0;\n\t\tqc->qc_flags = 0;\n\t\tif (qd->qd_id.type == USRQUOTA)\n\t\t\tqc->qc_flags = cpu_to_be32(GFS2_QCF_USER);\n\t\tqc->qc_id = cpu_to_be32(from_kqid(&init_user_ns, qd->qd_id));\n\t}\n\n\tx = be64_to_cpu(qc->qc_change) + change;\n\tqc->qc_change = cpu_to_be64(x);\n\n\tspin_lock(&qd_lock);\n\tqd->qd_change = x;\n\tspin_unlock(&qd_lock);\n\n\tif (!x) {\n\t\tgfs2_assert_warn(sdp, test_bit(QDF_CHANGE, &qd->qd_flags));\n\t\tclear_bit(QDF_CHANGE, &qd->qd_flags);\n\t\tqc->qc_flags = 0;\n\t\tqc->qc_id = 0;\n\t\tslot_put(qd);\n\t\tqd_put(qd);\n\t} else if (!test_and_set_bit(QDF_CHANGE, &qd->qd_flags)) {\n\t\tqd_hold(qd);\n\t\tslot_hold(qd);\n\t}\n\n\tmutex_unlock(&sdp->sd_quota_mutex);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(qd_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\n\nstatic void do_qc(struct gfs2_quota_data *qd, s64 change)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_qc_inode);\n\tstruct gfs2_quota_change *qc = qd->qd_bh_qc;\n\ts64 x;\n\n\tmutex_lock(&sdp->sd_quota_mutex);\n\tgfs2_trans_add_meta(ip->i_gl, qd->qd_bh);\n\n\tif (!test_bit(QDF_CHANGE, &qd->qd_flags)) {\n\t\tqc->qc_change = 0;\n\t\tqc->qc_flags = 0;\n\t\tif (qd->qd_id.type == USRQUOTA)\n\t\t\tqc->qc_flags = cpu_to_be32(GFS2_QCF_USER);\n\t\tqc->qc_id = cpu_to_be32(from_kqid(&init_user_ns, qd->qd_id));\n\t}\n\n\tx = be64_to_cpu(qc->qc_change) + change;\n\tqc->qc_change = cpu_to_be64(x);\n\n\tspin_lock(&qd_lock);\n\tqd->qd_change = x;\n\tspin_unlock(&qd_lock);\n\n\tif (!x) {\n\t\tgfs2_assert_warn(sdp, test_bit(QDF_CHANGE, &qd->qd_flags));\n\t\tclear_bit(QDF_CHANGE, &qd->qd_flags);\n\t\tqc->qc_flags = 0;\n\t\tqc->qc_id = 0;\n\t\tslot_put(qd);\n\t\tqd_put(qd);\n\t} else if (!test_and_set_bit(QDF_CHANGE, &qd->qd_flags)) {\n\t\tqd_hold(qd);\n\t\tslot_hold(qd);\n\t}\n\n\tmutex_unlock(&sdp->sd_quota_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qid_eq",
          "args": [
            "qd->qd_id",
            "make_kqid_gid(gid)"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "qid_eq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/kqid.c",
          "lines": "12-26",
          "snippet": "bool qid_eq(struct kqid left, struct kqid right)\n{\n\tif (left.type != right.type)\n\t\treturn false;\n\tswitch(left.type) {\n\tcase USRQUOTA:\n\t\treturn uid_eq(left.uid, right.uid);\n\tcase GRPQUOTA:\n\t\treturn gid_eq(left.gid, right.gid);\n\tcase PRJQUOTA:\n\t\treturn projid_eq(left.projid, right.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/quota.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/quota.h>\n#include <linux/fs.h>\n\nbool qid_eq(struct kqid left, struct kqid right)\n{\n\tif (left.type != right.type)\n\t\treturn false;\n\tswitch(left.type) {\n\tcase USRQUOTA:\n\t\treturn uid_eq(left.uid, right.uid);\n\tcase GRPQUOTA:\n\t\treturn gid_eq(left.gid, right.gid);\n\tcase PRJQUOTA:\n\t\treturn projid_eq(left.projid, right.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kqid_gid",
          "args": [
            "gid"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kqid_uid",
          "args": [
            "uid"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_assert_warn",
          "args": [
            "GFS2_SB(&ip->i_inode)",
            "change"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_quota_change(struct gfs2_inode *ip, s64 change,\n\t\t       kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_quota_data *qd;\n\tunsigned int x;\n\n\tif (gfs2_assert_warn(GFS2_SB(&ip->i_inode), change))\n\t\treturn;\n\tif (ip->i_diskflags & GFS2_DIF_SYSTEM)\n\t\treturn;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\n\t\tif (qid_eq(qd->qd_id, make_kqid_uid(uid)) ||\n\t\t    qid_eq(qd->qd_id, make_kqid_gid(gid))) {\n\t\t\tdo_qc(qd, change);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "gfs2_quota_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "1097-1143",
    "snippet": "int gfs2_quota_check(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qd;\n\ts64 value;\n\tunsigned int x;\n\tint error = 0;\n\n\tif (!test_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\treturn 0;\n\n        if (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n                return 0;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\n\t\tif (!(qid_eq(qd->qd_id, make_kqid_uid(uid)) ||\n\t\t      qid_eq(qd->qd_id, make_kqid_gid(gid))))\n\t\t\tcontinue;\n\n\t\tvalue = (s64)be64_to_cpu(qd->qd_qb.qb_value);\n\t\tspin_lock(&qd_lock);\n\t\tvalue += qd->qd_change;\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (be64_to_cpu(qd->qd_qb.qb_limit) && (s64)be64_to_cpu(qd->qd_qb.qb_limit) < value) {\n\t\t\tprint_message(qd, \"exceeded\");\n\t\t\tquota_send_warning(qd->qd_id,\n\t\t\t\t\t   sdp->sd_vfs->s_dev, QUOTA_NL_BHARDWARN);\n\n\t\t\terror = -EDQUOT;\n\t\t\tbreak;\n\t\t} else if (be64_to_cpu(qd->qd_qb.qb_warn) &&\n\t\t\t   (s64)be64_to_cpu(qd->qd_qb.qb_warn) < value &&\n\t\t\t   time_after_eq(jiffies, qd->qd_last_warn +\n\t\t\t\t\t gfs2_tune_get(sdp,\n\t\t\t\t\t\tgt_quota_warn_period) * HZ)) {\n\t\t\tquota_send_warning(qd->qd_id,\n\t\t\t\t\t   sdp->sd_vfs->s_dev, QUOTA_NL_BSOFTWARN);\n\t\t\terror = print_message(qd, \"warning\");\n\t\t\tqd->qd_last_warn = jiffies;\n\t\t}\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(qd_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_message",
          "args": [
            "qd",
            "\"warning\""
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "print_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1085-1095",
          "snippet": "static int print_message(struct gfs2_quota_data *qd, char *type)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\n\tfs_info(sdp, \"quota %s for %s %u\\n\",\n\t\ttype,\n\t\t(qd->qd_id.type == USRQUOTA) ? \"user\" : \"group\",\n\t\tfrom_kqid(&init_user_ns, qd->qd_id));\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int print_message(struct gfs2_quota_data *qd, char *type)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\n\tfs_info(sdp, \"quota %s for %s %u\\n\",\n\t\ttype,\n\t\t(qd->qd_id.type == USRQUOTA) ? \"user\" : \"group\",\n\t\tfrom_kqid(&init_user_ns, qd->qd_id));\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "quota_send_warning",
          "args": [
            "qd->qd_id",
            "sdp->sd_vfs->s_dev",
            "QUOTA_NL_BSOFTWARN"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "quota_send_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/netlink.c",
          "lines": "44-98",
          "snippet": "void quota_send_warning(struct kqid qid, dev_t dev,\n\t\t\tconst char warntype)\n{\n\tstatic atomic_t seq;\n\tstruct sk_buff *skb;\n\tvoid *msg_head;\n\tint ret;\n\tint msg_size = 4 * nla_total_size(sizeof(u32)) +\n\t\t       2 * nla_total_size(sizeof(u64));\n\n\t/* We have to allocate using GFP_NOFS as we are called from a\n\t * filesystem performing write and thus further recursion into\n\t * the fs to free some data could cause deadlocks. */\n\tskb = genlmsg_new(msg_size, GFP_NOFS);\n\tif (!skb) {\n\t\tprintk(KERN_ERR\n\t\t  \"VFS: Not enough memory to send quota warning.\\n\");\n\t\treturn;\n\t}\n\tmsg_head = genlmsg_put(skb, 0, atomic_add_return(1, &seq),\n\t\t\t&quota_genl_family, 0, QUOTA_NL_C_WARNING);\n\tif (!msg_head) {\n\t\tprintk(KERN_ERR\n\t\t  \"VFS: Cannot store netlink header in quota warning.\\n\");\n\t\tgoto err_out;\n\t}\n\tret = nla_put_u32(skb, QUOTA_NL_A_QTYPE, qid.type);\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u64(skb, QUOTA_NL_A_EXCESS_ID,\n\t\t\t  from_kqid_munged(&init_user_ns, qid));\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u32(skb, QUOTA_NL_A_WARNING, warntype);\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u32(skb, QUOTA_NL_A_DEV_MAJOR, MAJOR(dev));\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u32(skb, QUOTA_NL_A_DEV_MINOR, MINOR(dev));\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u64(skb, QUOTA_NL_A_CAUSED_ID,\n\t\t\t  from_kuid_munged(&init_user_ns, current_uid()));\n\tif (ret)\n\t\tgoto attr_err_out;\n\tgenlmsg_end(skb, msg_head);\n\n\tgenlmsg_multicast(&quota_genl_family, skb, 0, 0, GFP_NOFS);\n\treturn;\nattr_err_out:\n\tprintk(KERN_ERR \"VFS: Not enough space to compose quota message!\\n\");\nerr_out:\n\tkfree_skb(skb);\n}",
          "includes": [
            "#include <net/genetlink.h>",
            "#include <net/netlink.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct genl_family quota_genl_family = {\n\t/*\n\t * Needed due to multicast group ID abuse - old code assumed\n\t * the family ID was also a valid multicast group ID (which\n\t * isn't true) and userspace might thus rely on it. Assign a\n\t * static ID for this group to make dealing with that easier.\n\t */\n\t.id = GENL_ID_VFS_DQUOT,\n\t.hdrsize = 0,\n\t.name = \"VFS_DQUOT\",\n\t.version = 1,\n\t.maxattr = QUOTA_NL_A_MAX,\n\t.mcgrps = quota_mcgrps,\n\t.n_mcgrps = ARRAY_SIZE(quota_mcgrps),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/genetlink.h>\n#include <net/netlink.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/cred.h>\n\nstatic struct genl_family quota_genl_family = {\n\t/*\n\t * Needed due to multicast group ID abuse - old code assumed\n\t * the family ID was also a valid multicast group ID (which\n\t * isn't true) and userspace might thus rely on it. Assign a\n\t * static ID for this group to make dealing with that easier.\n\t */\n\t.id = GENL_ID_VFS_DQUOT,\n\t.hdrsize = 0,\n\t.name = \"VFS_DQUOT\",\n\t.version = 1,\n\t.maxattr = QUOTA_NL_A_MAX,\n\t.mcgrps = quota_mcgrps,\n\t.n_mcgrps = ARRAY_SIZE(quota_mcgrps),\n};\n\nvoid quota_send_warning(struct kqid qid, dev_t dev,\n\t\t\tconst char warntype)\n{\n\tstatic atomic_t seq;\n\tstruct sk_buff *skb;\n\tvoid *msg_head;\n\tint ret;\n\tint msg_size = 4 * nla_total_size(sizeof(u32)) +\n\t\t       2 * nla_total_size(sizeof(u64));\n\n\t/* We have to allocate using GFP_NOFS as we are called from a\n\t * filesystem performing write and thus further recursion into\n\t * the fs to free some data could cause deadlocks. */\n\tskb = genlmsg_new(msg_size, GFP_NOFS);\n\tif (!skb) {\n\t\tprintk(KERN_ERR\n\t\t  \"VFS: Not enough memory to send quota warning.\\n\");\n\t\treturn;\n\t}\n\tmsg_head = genlmsg_put(skb, 0, atomic_add_return(1, &seq),\n\t\t\t&quota_genl_family, 0, QUOTA_NL_C_WARNING);\n\tif (!msg_head) {\n\t\tprintk(KERN_ERR\n\t\t  \"VFS: Cannot store netlink header in quota warning.\\n\");\n\t\tgoto err_out;\n\t}\n\tret = nla_put_u32(skb, QUOTA_NL_A_QTYPE, qid.type);\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u64(skb, QUOTA_NL_A_EXCESS_ID,\n\t\t\t  from_kqid_munged(&init_user_ns, qid));\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u32(skb, QUOTA_NL_A_WARNING, warntype);\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u32(skb, QUOTA_NL_A_DEV_MAJOR, MAJOR(dev));\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u32(skb, QUOTA_NL_A_DEV_MINOR, MINOR(dev));\n\tif (ret)\n\t\tgoto attr_err_out;\n\tret = nla_put_u64(skb, QUOTA_NL_A_CAUSED_ID,\n\t\t\t  from_kuid_munged(&init_user_ns, current_uid()));\n\tif (ret)\n\t\tgoto attr_err_out;\n\tgenlmsg_end(skb, msg_head);\n\n\tgenlmsg_multicast(&quota_genl_family, skb, 0, 0, GFP_NOFS);\n\treturn;\nattr_err_out:\n\tprintk(KERN_ERR \"VFS: Not enough space to compose quota message!\\n\");\nerr_out:\n\tkfree_skb(skb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "jiffies",
            "qd->qd_last_warn +\n\t\t\t\t\t gfs2_tune_get(sdp,\n\t\t\t\t\t\tgt_quota_warn_period) * HZ"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_tune_get",
          "args": [
            "sdp",
            "gt_quota_warn_period"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_tune_get_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.h",
          "lines": "155-163",
          "snippet": "static inline unsigned int gfs2_tune_get_i(struct gfs2_tune *gt,\n\t\t\t\t\t   unsigned int *p)\n{\n\tunsigned int x;\n\tspin_lock(&gt->gt_spin);\n\tx = *p;\n\tspin_unlock(&gt->gt_spin);\n\treturn x;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/mempool.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/mempool.h>\n\nstatic inline unsigned int gfs2_tune_get_i(struct gfs2_tune *gt,\n\t\t\t\t\t   unsigned int *p)\n{\n\tunsigned int x;\n\tspin_lock(&gt->gt_spin);\n\tx = *p;\n\tspin_unlock(&gt->gt_spin);\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "qd->qd_qb.qb_warn"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "qd->qd_qb.qb_warn"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "qd->qd_qb.qb_limit"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "qd->qd_qb.qb_limit"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&qd_lock"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&qd_lock"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "qd->qd_qb.qb_value"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qid_eq",
          "args": [
            "qd->qd_id",
            "make_kqid_gid(gid)"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "qid_eq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/kqid.c",
          "lines": "12-26",
          "snippet": "bool qid_eq(struct kqid left, struct kqid right)\n{\n\tif (left.type != right.type)\n\t\treturn false;\n\tswitch(left.type) {\n\tcase USRQUOTA:\n\t\treturn uid_eq(left.uid, right.uid);\n\tcase GRPQUOTA:\n\t\treturn gid_eq(left.gid, right.gid);\n\tcase PRJQUOTA:\n\t\treturn projid_eq(left.projid, right.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/quota.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/quota.h>\n#include <linux/fs.h>\n\nbool qid_eq(struct kqid left, struct kqid right)\n{\n\tif (left.type != right.type)\n\t\treturn false;\n\tswitch(left.type) {\n\tcase USRQUOTA:\n\t\treturn uid_eq(left.uid, right.uid);\n\tcase GRPQUOTA:\n\t\treturn gid_eq(left.gid, right.gid);\n\tcase PRJQUOTA:\n\t\treturn projid_eq(left.projid, right.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kqid_gid",
          "args": [
            "gid"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kqid_uid",
          "args": [
            "uid"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "GIF_QD_LOCKED",
            "&ip->i_flags"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\n\nint gfs2_quota_check(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qd;\n\ts64 value;\n\tunsigned int x;\n\tint error = 0;\n\n\tif (!test_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\treturn 0;\n\n        if (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n                return 0;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\n\t\tif (!(qid_eq(qd->qd_id, make_kqid_uid(uid)) ||\n\t\t      qid_eq(qd->qd_id, make_kqid_gid(gid))))\n\t\t\tcontinue;\n\n\t\tvalue = (s64)be64_to_cpu(qd->qd_qb.qb_value);\n\t\tspin_lock(&qd_lock);\n\t\tvalue += qd->qd_change;\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (be64_to_cpu(qd->qd_qb.qb_limit) && (s64)be64_to_cpu(qd->qd_qb.qb_limit) < value) {\n\t\t\tprint_message(qd, \"exceeded\");\n\t\t\tquota_send_warning(qd->qd_id,\n\t\t\t\t\t   sdp->sd_vfs->s_dev, QUOTA_NL_BHARDWARN);\n\n\t\t\terror = -EDQUOT;\n\t\t\tbreak;\n\t\t} else if (be64_to_cpu(qd->qd_qb.qb_warn) &&\n\t\t\t   (s64)be64_to_cpu(qd->qd_qb.qb_warn) < value &&\n\t\t\t   time_after_eq(jiffies, qd->qd_last_warn +\n\t\t\t\t\t gfs2_tune_get(sdp,\n\t\t\t\t\t\tgt_quota_warn_period) * HZ)) {\n\t\t\tquota_send_warning(qd->qd_id,\n\t\t\t\t\t   sdp->sd_vfs->s_dev, QUOTA_NL_BSOFTWARN);\n\t\t\terror = print_message(qd, \"warning\");\n\t\t\tqd->qd_last_warn = jiffies;\n\t\t}\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "print_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "1085-1095",
    "snippet": "static int print_message(struct gfs2_quota_data *qd, char *type)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\n\tfs_info(sdp, \"quota %s for %s %u\\n\",\n\t\ttype,\n\t\t(qd->qd_id.type == USRQUOTA) ? \"user\" : \"group\",\n\t\tfrom_kqid(&init_user_ns, qd->qd_id));\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_info",
          "args": [
            "sdp",
            "\"quota %s for %s %u\\n\"",
            "type",
            "(qd->qd_id.type == USRQUOTA) ? \"user\" : \"group\"",
            "from_kqid(&init_user_ns, qd->qd_id)"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "280-288",
          "snippet": "void reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kqid",
          "args": [
            "&init_user_ns",
            "qd->qd_id"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "from_kqid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/kqid.c",
          "lines": "100-112",
          "snippet": "qid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/quota.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/quota.h>\n#include <linux/fs.h>\n\nqid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int print_message(struct gfs2_quota_data *qd, char *type)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\n\tfs_info(sdp, \"quota %s for %s %u\\n\",\n\t\ttype,\n\t\t(qd->qd_id.type == USRQUOTA) ? \"user\" : \"group\",\n\t\tfrom_kqid(&init_user_ns, qd->qd_id));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_quota_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "1033-1081",
    "snippet": "void gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(qd_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_quota_unhold",
          "args": [
            "ip"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_unhold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "587-601",
          "snippet": "void gfs2_quota_unhold(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int x;\n\n\tif (ip->i_res == NULL)\n\t\treturn;\n\tgfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags));\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqdsb_put(ip->i_res->rs_qa_qd[x]);\n\t\tip->i_res->rs_qa_qd[x] = NULL;\n\t}\n\tip->i_res->rs_qa_qd_num = 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_quota_unhold(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int x;\n\n\tif (ip->i_res == NULL)\n\t\treturn;\n\tgfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags));\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqdsb_put(ip->i_res->rs_qa_qd[x]);\n\t\tip->i_res->rs_qa_qd[x] = NULL;\n\t}\n\tip->i_res->rs_qa_qd_num = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qd_unlock",
          "args": [
            "qda[x]"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "qd_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "487-495",
          "snippet": "static void qd_unlock(struct gfs2_quota_data *qd)\n{\n\tgfs2_assert_warn(qd->qd_gl->gl_sbd,\n\t\t\t test_bit(QDF_LOCKED, &qd->qd_flags));\n\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\tbh_put(qd);\n\tslot_put(qd);\n\tqd_put(qd);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void qd_unlock(struct gfs2_quota_data *qd)\n{\n\tgfs2_assert_warn(qd->qd_gl->gl_sbd,\n\t\t\t test_bit(QDF_LOCKED, &qd->qd_flags));\n\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\tbh_put(qd);\n\tslot_put(qd);\n\tqd_put(qd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_sync",
          "args": [
            "count",
            "qda"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "do_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "791-886",
          "snippet": "static int do_sync(unsigned int num_qd, struct gfs2_quota_data **qda)\n{\n\tstruct gfs2_sbd *sdp = (*qda)->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_alloc_parms ap = { .aflags = 0, };\n\tunsigned int data_blocks, ind_blocks;\n\tstruct gfs2_holder *ghs, i_gh;\n\tunsigned int qx, x;\n\tstruct gfs2_quota_data *qd;\n\tunsigned reserved;\n\tloff_t offset;\n\tunsigned int nalloc = 0, blocks;\n\tint error;\n\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\treturn error;\n\n\tgfs2_write_calc_reserv(ip, sizeof(struct gfs2_quota),\n\t\t\t      &data_blocks, &ind_blocks);\n\n\tghs = kcalloc(num_qd, sizeof(struct gfs2_holder), GFP_NOFS);\n\tif (!ghs)\n\t\treturn -ENOMEM;\n\n\tsort(qda, num_qd, sizeof(struct gfs2_quota_data *), sort_qd, NULL);\n\tmutex_lock(&ip->i_inode.i_mutex);\n\tfor (qx = 0; qx < num_qd; qx++) {\n\t\terror = gfs2_glock_nq_init(qda[qx]->qd_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t   GL_NOCACHE, &ghs[qx]);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &i_gh);\n\tif (error)\n\t\tgoto out;\n\n\tfor (x = 0; x < num_qd; x++) {\n\t\toffset = qd2offset(qda[x]);\n\t\tif (gfs2_write_alloc_required(ip, offset,\n\t\t\t\t\t      sizeof(struct gfs2_quota)))\n\t\t\tnalloc++;\n\t}\n\n\t/* \n\t * 1 blk for unstuffing inode if stuffed. We add this extra\n\t * block to the reservation unconditionally. If the inode\n\t * doesn't need unstuffing, the block will be released to the \n\t * rgrp since it won't be allocated during the transaction\n\t */\n\t/* +3 in the end for unstuffing block, inode size update block\n\t * and another block in case quota straddles page boundary and \n\t * two blocks need to be updated instead of 1 */\n\tblocks = num_qd * data_blocks + RES_DINODE + num_qd + 3;\n\n\treserved = 1 + (nalloc * (data_blocks + ind_blocks));\n\tap.target = reserved;\n\terror = gfs2_inplace_reserve(ip, &ap);\n\tif (error)\n\t\tgoto out_alloc;\n\n\tif (nalloc)\n\t\tblocks += gfs2_rg_blocks(ip, reserved) + nalloc * ind_blocks + RES_STATFS;\n\n\terror = gfs2_trans_begin(sdp, blocks, 0);\n\tif (error)\n\t\tgoto out_ipres;\n\n\tfor (x = 0; x < num_qd; x++) {\n\t\tqd = qda[x];\n\t\toffset = qd2offset(qd);\n\t\terror = gfs2_adjust_quota(ip, offset, qd->qd_change_sync, qd, NULL);\n\t\tif (error)\n\t\t\tgoto out_end_trans;\n\n\t\tdo_qc(qd, -qd->qd_change_sync);\n\t\tset_bit(QDF_REFRESH, &qd->qd_flags);\n\t}\n\n\terror = 0;\n\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_ipres:\n\tgfs2_inplace_release(ip);\nout_alloc:\n\tgfs2_glock_dq_uninit(&i_gh);\nout:\n\twhile (qx--)\n\t\tgfs2_glock_dq_uninit(&ghs[qx]);\n\tmutex_unlock(&ip->i_inode.i_mutex);\n\tkfree(ghs);\n\tgfs2_log_flush(ip->i_gl->gl_sbd, ip->i_gl, NORMAL_FLUSH);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int do_sync(unsigned int num_qd, struct gfs2_quota_data **qda)\n{\n\tstruct gfs2_sbd *sdp = (*qda)->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_alloc_parms ap = { .aflags = 0, };\n\tunsigned int data_blocks, ind_blocks;\n\tstruct gfs2_holder *ghs, i_gh;\n\tunsigned int qx, x;\n\tstruct gfs2_quota_data *qd;\n\tunsigned reserved;\n\tloff_t offset;\n\tunsigned int nalloc = 0, blocks;\n\tint error;\n\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\treturn error;\n\n\tgfs2_write_calc_reserv(ip, sizeof(struct gfs2_quota),\n\t\t\t      &data_blocks, &ind_blocks);\n\n\tghs = kcalloc(num_qd, sizeof(struct gfs2_holder), GFP_NOFS);\n\tif (!ghs)\n\t\treturn -ENOMEM;\n\n\tsort(qda, num_qd, sizeof(struct gfs2_quota_data *), sort_qd, NULL);\n\tmutex_lock(&ip->i_inode.i_mutex);\n\tfor (qx = 0; qx < num_qd; qx++) {\n\t\terror = gfs2_glock_nq_init(qda[qx]->qd_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t   GL_NOCACHE, &ghs[qx]);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &i_gh);\n\tif (error)\n\t\tgoto out;\n\n\tfor (x = 0; x < num_qd; x++) {\n\t\toffset = qd2offset(qda[x]);\n\t\tif (gfs2_write_alloc_required(ip, offset,\n\t\t\t\t\t      sizeof(struct gfs2_quota)))\n\t\t\tnalloc++;\n\t}\n\n\t/* \n\t * 1 blk for unstuffing inode if stuffed. We add this extra\n\t * block to the reservation unconditionally. If the inode\n\t * doesn't need unstuffing, the block will be released to the \n\t * rgrp since it won't be allocated during the transaction\n\t */\n\t/* +3 in the end for unstuffing block, inode size update block\n\t * and another block in case quota straddles page boundary and \n\t * two blocks need to be updated instead of 1 */\n\tblocks = num_qd * data_blocks + RES_DINODE + num_qd + 3;\n\n\treserved = 1 + (nalloc * (data_blocks + ind_blocks));\n\tap.target = reserved;\n\terror = gfs2_inplace_reserve(ip, &ap);\n\tif (error)\n\t\tgoto out_alloc;\n\n\tif (nalloc)\n\t\tblocks += gfs2_rg_blocks(ip, reserved) + nalloc * ind_blocks + RES_STATFS;\n\n\terror = gfs2_trans_begin(sdp, blocks, 0);\n\tif (error)\n\t\tgoto out_ipres;\n\n\tfor (x = 0; x < num_qd; x++) {\n\t\tqd = qda[x];\n\t\toffset = qd2offset(qd);\n\t\terror = gfs2_adjust_quota(ip, offset, qd->qd_change_sync, qd, NULL);\n\t\tif (error)\n\t\t\tgoto out_end_trans;\n\n\t\tdo_qc(qd, -qd->qd_change_sync);\n\t\tset_bit(QDF_REFRESH, &qd->qd_flags);\n\t}\n\n\terror = 0;\n\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_ipres:\n\tgfs2_inplace_release(ip);\nout_alloc:\n\tgfs2_glock_dq_uninit(&i_gh);\nout:\n\twhile (qx--)\n\t\tgfs2_glock_dq_uninit(&ghs[qx]);\n\tmutex_unlock(&ip->i_inode.i_mutex);\n\tkfree(ghs);\n\tgfs2_log_flush(ip->i_gl->gl_sbd, ip->i_gl, NORMAL_FLUSH);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qd_put",
          "args": [
            "qd"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "qd_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "310-319",
          "snippet": "static void qd_put(struct gfs2_quota_data *qd)\n{\n\tif (lockref_put_or_lock(&qd->qd_lockref))\n\t\treturn;\n\n\tqd->qd_lockref.count = 0;\n\tlist_lru_add(&gfs2_qd_lru, &qd->qd_lru);\n\tspin_unlock(&qd->qd_lockref.lock);\n\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_lru gfs2_qd_lru;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct list_lru gfs2_qd_lru;\n\nstatic void qd_put(struct gfs2_quota_data *qd)\n{\n\tif (lockref_put_or_lock(&qd->qd_lockref))\n\t\treturn;\n\n\tqd->qd_lockref.count = 0;\n\tlist_lru_add(&gfs2_qd_lru, &qd->qd_lru);\n\tspin_unlock(&qd->qd_lockref.lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "slot_put",
          "args": [
            "qd"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "slot_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "355-366",
          "snippet": "static void slot_put(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tgfs2_assert(sdp, qd->qd_slot_count);\n\tif (!--qd->qd_slot_count) {\n\t\tBUG_ON(!test_and_clear_bit(qd->qd_slot, sdp->sd_quota_bitmap));\n\t\tqd->qd_slot = -1;\n\t}\n\tspin_unlock(&sdp->sd_bitmap_lock);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void slot_put(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tgfs2_assert(sdp, qd->qd_slot_count);\n\tif (!--qd->qd_slot_count) {\n\t\tBUG_ON(!test_and_clear_bit(qd->qd_slot, sdp->sd_quota_bitmap));\n\t\tqd->qd_slot = -1;\n\t}\n\tspin_unlock(&sdp->sd_bitmap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "QDF_LOCKED",
            "&qd->qd_flags"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bh_get",
          "args": [
            "qd"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "bh_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "368-413",
          "snippet": "static int bh_get(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_qc_inode);\n\tunsigned int block, offset;\n\tstruct buffer_head *bh;\n\tint error;\n\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n\n\tmutex_lock(&sdp->sd_quota_mutex);\n\n\tif (qd->qd_bh_count++) {\n\t\tmutex_unlock(&sdp->sd_quota_mutex);\n\t\treturn 0;\n\t}\n\n\tblock = qd->qd_slot / sdp->sd_qc_per_block;\n\toffset = qd->qd_slot % sdp->sd_qc_per_block;\n\n\tbh_map.b_size = 1 << ip->i_inode.i_blkbits;\n\terror = gfs2_block_map(&ip->i_inode, block, &bh_map, 0);\n\tif (error)\n\t\tgoto fail;\n\terror = gfs2_meta_read(ip->i_gl, bh_map.b_blocknr, DIO_WAIT, &bh);\n\tif (error)\n\t\tgoto fail;\n\terror = -EIO;\n\tif (gfs2_metatype_check(sdp, bh, GFS2_METATYPE_QC))\n\t\tgoto fail_brelse;\n\n\tqd->qd_bh = bh;\n\tqd->qd_bh_qc = (struct gfs2_quota_change *)\n\t\t(bh->b_data + sizeof(struct gfs2_meta_header) +\n\t\t offset * sizeof(struct gfs2_quota_change));\n\n\tmutex_unlock(&sdp->sd_quota_mutex);\n\n\treturn 0;\n\nfail_brelse:\n\tbrelse(bh);\nfail:\n\tqd->qd_bh_count--;\n\tmutex_unlock(&sdp->sd_quota_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int bh_get(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_qc_inode);\n\tunsigned int block, offset;\n\tstruct buffer_head *bh;\n\tint error;\n\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n\n\tmutex_lock(&sdp->sd_quota_mutex);\n\n\tif (qd->qd_bh_count++) {\n\t\tmutex_unlock(&sdp->sd_quota_mutex);\n\t\treturn 0;\n\t}\n\n\tblock = qd->qd_slot / sdp->sd_qc_per_block;\n\toffset = qd->qd_slot % sdp->sd_qc_per_block;\n\n\tbh_map.b_size = 1 << ip->i_inode.i_blkbits;\n\terror = gfs2_block_map(&ip->i_inode, block, &bh_map, 0);\n\tif (error)\n\t\tgoto fail;\n\terror = gfs2_meta_read(ip->i_gl, bh_map.b_blocknr, DIO_WAIT, &bh);\n\tif (error)\n\t\tgoto fail;\n\terror = -EIO;\n\tif (gfs2_metatype_check(sdp, bh, GFS2_METATYPE_QC))\n\t\tgoto fail_brelse;\n\n\tqd->qd_bh = bh;\n\tqd->qd_bh_qc = (struct gfs2_quota_change *)\n\t\t(bh->b_data + sizeof(struct gfs2_meta_header) +\n\t\t offset * sizeof(struct gfs2_quota_change));\n\n\tmutex_unlock(&sdp->sd_quota_mutex);\n\n\treturn 0;\n\nfail_brelse:\n\tbrelse(bh);\nfail:\n\tqd->qd_bh_count--;\n\tmutex_unlock(&sdp->sd_quota_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_assert_warn",
          "args": [
            "sdp",
            "qd->qd_change_sync"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&qd_lock"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qd_check_sync",
          "args": [
            "sdp",
            "qd",
            "NULL"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "qd_check_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "429-445",
          "snippet": "static int qd_check_sync(struct gfs2_sbd *sdp, struct gfs2_quota_data *qd,\n\t\t\t u64 *sync_gen)\n{\n\tif (test_bit(QDF_LOCKED, &qd->qd_flags) ||\n\t    !test_bit(QDF_CHANGE, &qd->qd_flags) ||\n\t    (sync_gen && (qd->qd_sync_gen >= *sync_gen)))\n\t\treturn 0;\n\n\tif (!lockref_get_not_dead(&qd->qd_lockref))\n\t\treturn 0;\n\n\tlist_move_tail(&qd->qd_list, &sdp->sd_quota_list);\n\tset_bit(QDF_LOCKED, &qd->qd_flags);\n\tqd->qd_change_sync = qd->qd_change;\n\tslot_hold(qd);\n\treturn 1;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int qd_check_sync(struct gfs2_sbd *sdp, struct gfs2_quota_data *qd,\n\t\t\t u64 *sync_gen)\n{\n\tif (test_bit(QDF_LOCKED, &qd->qd_flags) ||\n\t    !test_bit(QDF_CHANGE, &qd->qd_flags) ||\n\t    (sync_gen && (qd->qd_sync_gen >= *sync_gen)))\n\t\treturn 0;\n\n\tif (!lockref_get_not_dead(&qd->qd_lockref))\n\t\treturn 0;\n\n\tlist_move_tail(&qd->qd_list, &sdp->sd_quota_list);\n\tset_bit(QDF_LOCKED, &qd->qd_flags);\n\tqd->qd_change_sync = qd->qd_change;\n\tslot_hold(qd);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&qd_lock"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&ip->i_res->rs_qa_qd_ghs[x]"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_sync",
          "args": [
            "qd"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "need_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "997-1031",
          "snippet": "static int need_sync(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_tune *gt = &sdp->sd_tune;\n\ts64 value;\n\tunsigned int num, den;\n\tint do_sync = 1;\n\n\tif (!qd->qd_qb.qb_limit)\n\t\treturn 0;\n\n\tspin_lock(&qd_lock);\n\tvalue = qd->qd_change;\n\tspin_unlock(&qd_lock);\n\n\tspin_lock(&gt->gt_spin);\n\tnum = gt->gt_quota_scale_num;\n\tden = gt->gt_quota_scale_den;\n\tspin_unlock(&gt->gt_spin);\n\n\tif (value < 0)\n\t\tdo_sync = 0;\n\telse if ((s64)be64_to_cpu(qd->qd_qb.qb_value) >=\n\t\t (s64)be64_to_cpu(qd->qd_qb.qb_limit))\n\t\tdo_sync = 0;\n\telse {\n\t\tvalue *= gfs2_jindex_size(sdp) * num;\n\t\tvalue = div_s64(value, den);\n\t\tvalue += (s64)be64_to_cpu(qd->qd_qb.qb_value);\n\t\tif (value < (s64)be64_to_cpu(qd->qd_qb.qb_limit))\n\t\t\tdo_sync = 0;\n\t}\n\n\treturn do_sync;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(qd_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\n\nstatic int need_sync(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_tune *gt = &sdp->sd_tune;\n\ts64 value;\n\tunsigned int num, den;\n\tint do_sync = 1;\n\n\tif (!qd->qd_qb.qb_limit)\n\t\treturn 0;\n\n\tspin_lock(&qd_lock);\n\tvalue = qd->qd_change;\n\tspin_unlock(&qd_lock);\n\n\tspin_lock(&gt->gt_spin);\n\tnum = gt->gt_quota_scale_num;\n\tden = gt->gt_quota_scale_den;\n\tspin_unlock(&gt->gt_spin);\n\n\tif (value < 0)\n\t\tdo_sync = 0;\n\telse if ((s64)be64_to_cpu(qd->qd_qb.qb_value) >=\n\t\t (s64)be64_to_cpu(qd->qd_qb.qb_limit))\n\t\tdo_sync = 0;\n\telse {\n\t\tvalue *= gfs2_jindex_size(sdp) * num;\n\t\tvalue = div_s64(value, den);\n\t\tvalue += (s64)be64_to_cpu(qd->qd_qb.qb_value);\n\t\tif (value < (s64)be64_to_cpu(qd->qd_qb.qb_limit))\n\t\t\tdo_sync = 0;\n\t}\n\n\treturn do_sync;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "GIF_QD_LOCKED",
            "&ip->i_flags"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\n\nvoid gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}"
  },
  {
    "function_name": "need_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "997-1031",
    "snippet": "static int need_sync(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_tune *gt = &sdp->sd_tune;\n\ts64 value;\n\tunsigned int num, den;\n\tint do_sync = 1;\n\n\tif (!qd->qd_qb.qb_limit)\n\t\treturn 0;\n\n\tspin_lock(&qd_lock);\n\tvalue = qd->qd_change;\n\tspin_unlock(&qd_lock);\n\n\tspin_lock(&gt->gt_spin);\n\tnum = gt->gt_quota_scale_num;\n\tden = gt->gt_quota_scale_den;\n\tspin_unlock(&gt->gt_spin);\n\n\tif (value < 0)\n\t\tdo_sync = 0;\n\telse if ((s64)be64_to_cpu(qd->qd_qb.qb_value) >=\n\t\t (s64)be64_to_cpu(qd->qd_qb.qb_limit))\n\t\tdo_sync = 0;\n\telse {\n\t\tvalue *= gfs2_jindex_size(sdp) * num;\n\t\tvalue = div_s64(value, den);\n\t\tvalue += (s64)be64_to_cpu(qd->qd_qb.qb_value);\n\t\tif (value < (s64)be64_to_cpu(qd->qd_qb.qb_limit))\n\t\t\tdo_sync = 0;\n\t}\n\n\treturn do_sync;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(qd_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "qd->qd_qb.qb_limit"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "qd->qd_qb.qb_value"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_s64",
          "args": [
            "value",
            "den"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_jindex_size",
          "args": [
            "sdp"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_jindex_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.h",
          "lines": "19-26",
          "snippet": "static inline unsigned int gfs2_jindex_size(struct gfs2_sbd *sdp)\n{\n\tunsigned int x;\n\tspin_lock(&sdp->sd_jindex_spin);\n\tx = sdp->sd_journals;\n\tspin_unlock(&sdp->sd_jindex_spin);\n\treturn x;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/dcache.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int gfs2_jindex_size(struct gfs2_sbd *sdp)\n{\n\tunsigned int x;\n\tspin_lock(&sdp->sd_jindex_spin);\n\tx = sdp->sd_journals;\n\tspin_unlock(&sdp->sd_jindex_spin);\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "qd->qd_qb.qb_limit"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "qd->qd_qb.qb_value"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&gt->gt_spin"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&gt->gt_spin"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\n\nstatic int need_sync(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_tune *gt = &sdp->sd_tune;\n\ts64 value;\n\tunsigned int num, den;\n\tint do_sync = 1;\n\n\tif (!qd->qd_qb.qb_limit)\n\t\treturn 0;\n\n\tspin_lock(&qd_lock);\n\tvalue = qd->qd_change;\n\tspin_unlock(&qd_lock);\n\n\tspin_lock(&gt->gt_spin);\n\tnum = gt->gt_quota_scale_num;\n\tden = gt->gt_quota_scale_den;\n\tspin_unlock(&gt->gt_spin);\n\n\tif (value < 0)\n\t\tdo_sync = 0;\n\telse if ((s64)be64_to_cpu(qd->qd_qb.qb_value) >=\n\t\t (s64)be64_to_cpu(qd->qd_qb.qb_limit))\n\t\tdo_sync = 0;\n\telse {\n\t\tvalue *= gfs2_jindex_size(sdp) * num;\n\t\tvalue = div_s64(value, den);\n\t\tvalue += (s64)be64_to_cpu(qd->qd_qb.qb_value);\n\t\tif (value < (s64)be64_to_cpu(qd->qd_qb.qb_limit))\n\t\t\tdo_sync = 0;\n\t}\n\n\treturn do_sync;\n}"
  },
  {
    "function_name": "gfs2_quota_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "958-995",
    "snippet": "int gfs2_quota_lock(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qd;\n\tunsigned int x;\n\tint error = 0;\n\n\terror = gfs2_quota_hold(ip, uid, gid);\n\tif (error)\n\t\treturn error;\n\n\tif (capable(CAP_SYS_RESOURCE) ||\n\t    sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\n\tsort(ip->i_res->rs_qa_qd, ip->i_res->rs_qa_qd_num,\n\t     sizeof(struct gfs2_quota_data *), sort_qd, NULL);\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tint force = NO_FORCE;\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tif (test_and_clear_bit(QDF_REFRESH, &qd->qd_flags))\n\t\t\tforce = FORCE;\n\t\terror = do_glock(qd, force, &ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\tif (!error)\n\t\tset_bit(GIF_QD_LOCKED, &ip->i_flags);\n\telse {\n\t\twhile (x--)\n\t\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tgfs2_quota_unhold(ip);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_quota_unhold",
          "args": [
            "ip"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_unhold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "587-601",
          "snippet": "void gfs2_quota_unhold(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int x;\n\n\tif (ip->i_res == NULL)\n\t\treturn;\n\tgfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags));\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqdsb_put(ip->i_res->rs_qa_qd[x]);\n\t\tip->i_res->rs_qa_qd[x] = NULL;\n\t}\n\tip->i_res->rs_qa_qd_num = 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_quota_unhold(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int x;\n\n\tif (ip->i_res == NULL)\n\t\treturn;\n\tgfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags));\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqdsb_put(ip->i_res->rs_qa_qd[x]);\n\t\tip->i_res->rs_qa_qd[x] = NULL;\n\t}\n\tip->i_res->rs_qa_qd_num = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&ip->i_res->rs_qa_qd_ghs[x]"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "GIF_QD_LOCKED",
            "&ip->i_flags"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_glock",
          "args": [
            "qd",
            "force",
            "&ip->i_res->rs_qa_qd_ghs[x]"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "do_glock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "913-956",
          "snippet": "static int do_glock(struct gfs2_quota_data *qd, int force_refresh,\n\t\t    struct gfs2_holder *q_gh)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_holder i_gh;\n\tint error;\n\nrestart:\n\terror = gfs2_glock_nq_init(qd->qd_gl, LM_ST_SHARED, 0, q_gh);\n\tif (error)\n\t\treturn error;\n\n\tqd->qd_qb = *(struct gfs2_quota_lvb *)qd->qd_gl->gl_lksb.sb_lvbptr;\n\n\tif (force_refresh || qd->qd_qb.qb_magic != cpu_to_be32(GFS2_MAGIC)) {\n\t\tgfs2_glock_dq_uninit(q_gh);\n\t\terror = gfs2_glock_nq_init(qd->qd_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t   GL_NOCACHE, q_gh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, 0, &i_gh);\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\terror = update_qd(sdp, qd);\n\t\tif (error)\n\t\t\tgoto fail_gunlock;\n\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\t\tgfs2_glock_dq_uninit(q_gh);\n\t\tforce_refresh = 0;\n\t\tgoto restart;\n\t}\n\n\treturn 0;\n\nfail_gunlock:\n\tgfs2_glock_dq_uninit(&i_gh);\nfail:\n\tgfs2_glock_dq_uninit(q_gh);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int do_glock(struct gfs2_quota_data *qd, int force_refresh,\n\t\t    struct gfs2_holder *q_gh)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_holder i_gh;\n\tint error;\n\nrestart:\n\terror = gfs2_glock_nq_init(qd->qd_gl, LM_ST_SHARED, 0, q_gh);\n\tif (error)\n\t\treturn error;\n\n\tqd->qd_qb = *(struct gfs2_quota_lvb *)qd->qd_gl->gl_lksb.sb_lvbptr;\n\n\tif (force_refresh || qd->qd_qb.qb_magic != cpu_to_be32(GFS2_MAGIC)) {\n\t\tgfs2_glock_dq_uninit(q_gh);\n\t\terror = gfs2_glock_nq_init(qd->qd_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t   GL_NOCACHE, q_gh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, 0, &i_gh);\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\terror = update_qd(sdp, qd);\n\t\tif (error)\n\t\t\tgoto fail_gunlock;\n\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\t\tgfs2_glock_dq_uninit(q_gh);\n\t\tforce_refresh = 0;\n\t\tgoto restart;\n\t}\n\n\treturn 0;\n\nfail_gunlock:\n\tgfs2_glock_dq_uninit(&i_gh);\nfail:\n\tgfs2_glock_dq_uninit(q_gh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "QDF_REFRESH",
            "&qd->qd_flags"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "ip->i_res->rs_qa_qd",
            "ip->i_res->rs_qa_qd_num",
            "sizeof(struct gfs2_quota_data *)",
            "sort_qd",
            "NULL"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_RESOURCE"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_quota_hold",
          "args": [
            "ip",
            "uid",
            "gid"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_hold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "530-585",
          "snippet": "int gfs2_quota_hold(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data **qd;\n\tint error;\n\n\tif (ip->i_res == NULL) {\n\t\terror = gfs2_rs_alloc(ip);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tqd = ip->i_res->rs_qa_qd;\n\n\tif (gfs2_assert_warn(sdp, !ip->i_res->rs_qa_qd_num) ||\n\t    gfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags)))\n\t\treturn -EIO;\n\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\n\terror = qdsb_get(sdp, make_kqid_uid(ip->i_inode.i_uid), qd);\n\tif (error)\n\t\tgoto out;\n\tip->i_res->rs_qa_qd_num++;\n\tqd++;\n\n\terror = qdsb_get(sdp, make_kqid_gid(ip->i_inode.i_gid), qd);\n\tif (error)\n\t\tgoto out;\n\tip->i_res->rs_qa_qd_num++;\n\tqd++;\n\n\tif (!uid_eq(uid, NO_UID_QUOTA_CHANGE) &&\n\t    !uid_eq(uid, ip->i_inode.i_uid)) {\n\t\terror = qdsb_get(sdp, make_kqid_uid(uid), qd);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tip->i_res->rs_qa_qd_num++;\n\t\tqd++;\n\t}\n\n\tif (!gid_eq(gid, NO_GID_QUOTA_CHANGE) &&\n\t    !gid_eq(gid, ip->i_inode.i_gid)) {\n\t\terror = qdsb_get(sdp, make_kqid_gid(gid), qd);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tip->i_res->rs_qa_qd_num++;\n\t\tqd++;\n\t}\n\nout:\n\tif (error)\n\t\tgfs2_quota_unhold(ip);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_quota_hold(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data **qd;\n\tint error;\n\n\tif (ip->i_res == NULL) {\n\t\terror = gfs2_rs_alloc(ip);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tqd = ip->i_res->rs_qa_qd;\n\n\tif (gfs2_assert_warn(sdp, !ip->i_res->rs_qa_qd_num) ||\n\t    gfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags)))\n\t\treturn -EIO;\n\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\n\terror = qdsb_get(sdp, make_kqid_uid(ip->i_inode.i_uid), qd);\n\tif (error)\n\t\tgoto out;\n\tip->i_res->rs_qa_qd_num++;\n\tqd++;\n\n\terror = qdsb_get(sdp, make_kqid_gid(ip->i_inode.i_gid), qd);\n\tif (error)\n\t\tgoto out;\n\tip->i_res->rs_qa_qd_num++;\n\tqd++;\n\n\tif (!uid_eq(uid, NO_UID_QUOTA_CHANGE) &&\n\t    !uid_eq(uid, ip->i_inode.i_uid)) {\n\t\terror = qdsb_get(sdp, make_kqid_uid(uid), qd);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tip->i_res->rs_qa_qd_num++;\n\t\tqd++;\n\t}\n\n\tif (!gid_eq(gid, NO_GID_QUOTA_CHANGE) &&\n\t    !gid_eq(gid, ip->i_inode.i_gid)) {\n\t\terror = qdsb_get(sdp, make_kqid_gid(gid), qd);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tip->i_res->rs_qa_qd_num++;\n\t\tqd++;\n\t}\n\nout:\n\tif (error)\n\t\tgfs2_quota_unhold(ip);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_quota_lock(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qd;\n\tunsigned int x;\n\tint error = 0;\n\n\terror = gfs2_quota_hold(ip, uid, gid);\n\tif (error)\n\t\treturn error;\n\n\tif (capable(CAP_SYS_RESOURCE) ||\n\t    sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\n\tsort(ip->i_res->rs_qa_qd, ip->i_res->rs_qa_qd_num,\n\t     sizeof(struct gfs2_quota_data *), sort_qd, NULL);\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tint force = NO_FORCE;\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tif (test_and_clear_bit(QDF_REFRESH, &qd->qd_flags))\n\t\t\tforce = FORCE;\n\t\terror = do_glock(qd, force, &ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\tif (!error)\n\t\tset_bit(GIF_QD_LOCKED, &ip->i_flags);\n\telse {\n\t\twhile (x--)\n\t\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tgfs2_quota_unhold(ip);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "do_glock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "913-956",
    "snippet": "static int do_glock(struct gfs2_quota_data *qd, int force_refresh,\n\t\t    struct gfs2_holder *q_gh)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_holder i_gh;\n\tint error;\n\nrestart:\n\terror = gfs2_glock_nq_init(qd->qd_gl, LM_ST_SHARED, 0, q_gh);\n\tif (error)\n\t\treturn error;\n\n\tqd->qd_qb = *(struct gfs2_quota_lvb *)qd->qd_gl->gl_lksb.sb_lvbptr;\n\n\tif (force_refresh || qd->qd_qb.qb_magic != cpu_to_be32(GFS2_MAGIC)) {\n\t\tgfs2_glock_dq_uninit(q_gh);\n\t\terror = gfs2_glock_nq_init(qd->qd_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t   GL_NOCACHE, q_gh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, 0, &i_gh);\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\terror = update_qd(sdp, qd);\n\t\tif (error)\n\t\t\tgoto fail_gunlock;\n\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\t\tgfs2_glock_dq_uninit(q_gh);\n\t\tforce_refresh = 0;\n\t\tgoto restart;\n\t}\n\n\treturn 0;\n\nfail_gunlock:\n\tgfs2_glock_dq_uninit(&i_gh);\nfail:\n\tgfs2_glock_dq_uninit(q_gh);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "q_gh"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_qd",
          "args": [
            "sdp",
            "qd"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "update_qd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "888-911",
          "snippet": "static int update_qd(struct gfs2_sbd *sdp, struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_quota q;\n\tstruct gfs2_quota_lvb *qlvb;\n\tloff_t pos;\n\tint error;\n\n\tmemset(&q, 0, sizeof(struct gfs2_quota));\n\tpos = qd2offset(qd);\n\terror = gfs2_internal_read(ip, (char *)&q, &pos, sizeof(q));\n\tif (error < 0)\n\t\treturn error;\n\n\tqlvb = (struct gfs2_quota_lvb *)qd->qd_gl->gl_lksb.sb_lvbptr;\n\tqlvb->qb_magic = cpu_to_be32(GFS2_MAGIC);\n\tqlvb->__pad = 0;\n\tqlvb->qb_limit = q.qu_limit;\n\tqlvb->qb_warn = q.qu_warn;\n\tqlvb->qb_value = q.qu_value;\n\tqd->qd_qb = *qlvb;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int update_qd(struct gfs2_sbd *sdp, struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_quota q;\n\tstruct gfs2_quota_lvb *qlvb;\n\tloff_t pos;\n\tint error;\n\n\tmemset(&q, 0, sizeof(struct gfs2_quota));\n\tpos = qd2offset(qd);\n\terror = gfs2_internal_read(ip, (char *)&q, &pos, sizeof(q));\n\tif (error < 0)\n\t\treturn error;\n\n\tqlvb = (struct gfs2_quota_lvb *)qd->qd_gl->gl_lksb.sb_lvbptr;\n\tqlvb->qb_magic = cpu_to_be32(GFS2_MAGIC);\n\tqlvb->__pad = 0;\n\tqlvb->qb_limit = q.qu_limit;\n\tqlvb->qb_warn = q.qu_warn;\n\tqlvb->qb_value = q.qu_value;\n\tqd->qd_qb = *qlvb;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "ip->i_gl",
            "LM_ST_SHARED",
            "0",
            "&i_gh"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "GFS2_MAGIC"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "sdp->sd_quota_inode"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int do_glock(struct gfs2_quota_data *qd, int force_refresh,\n\t\t    struct gfs2_holder *q_gh)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_holder i_gh;\n\tint error;\n\nrestart:\n\terror = gfs2_glock_nq_init(qd->qd_gl, LM_ST_SHARED, 0, q_gh);\n\tif (error)\n\t\treturn error;\n\n\tqd->qd_qb = *(struct gfs2_quota_lvb *)qd->qd_gl->gl_lksb.sb_lvbptr;\n\n\tif (force_refresh || qd->qd_qb.qb_magic != cpu_to_be32(GFS2_MAGIC)) {\n\t\tgfs2_glock_dq_uninit(q_gh);\n\t\terror = gfs2_glock_nq_init(qd->qd_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t   GL_NOCACHE, q_gh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, 0, &i_gh);\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\terror = update_qd(sdp, qd);\n\t\tif (error)\n\t\t\tgoto fail_gunlock;\n\n\t\tgfs2_glock_dq_uninit(&i_gh);\n\t\tgfs2_glock_dq_uninit(q_gh);\n\t\tforce_refresh = 0;\n\t\tgoto restart;\n\t}\n\n\treturn 0;\n\nfail_gunlock:\n\tgfs2_glock_dq_uninit(&i_gh);\nfail:\n\tgfs2_glock_dq_uninit(q_gh);\n\treturn error;\n}"
  },
  {
    "function_name": "update_qd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "888-911",
    "snippet": "static int update_qd(struct gfs2_sbd *sdp, struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_quota q;\n\tstruct gfs2_quota_lvb *qlvb;\n\tloff_t pos;\n\tint error;\n\n\tmemset(&q, 0, sizeof(struct gfs2_quota));\n\tpos = qd2offset(qd);\n\terror = gfs2_internal_read(ip, (char *)&q, &pos, sizeof(q));\n\tif (error < 0)\n\t\treturn error;\n\n\tqlvb = (struct gfs2_quota_lvb *)qd->qd_gl->gl_lksb.sb_lvbptr;\n\tqlvb->qb_magic = cpu_to_be32(GFS2_MAGIC);\n\tqlvb->__pad = 0;\n\tqlvb->qb_limit = q.qu_limit;\n\tqlvb->qb_warn = q.qu_warn;\n\tqlvb->qb_value = q.qu_value;\n\tqd->qd_qb = *qlvb;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "GFS2_MAGIC"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_internal_read",
          "args": [
            "ip",
            "(char *)&q",
            "&pos",
            "sizeof(q)"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_internal_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
          "lines": "559-587",
          "snippet": "int gfs2_internal_read(struct gfs2_inode *ip, char *buf, loff_t *pos,\n                       unsigned size)\n{\n\tstruct address_space *mapping = ip->i_inode.i_mapping;\n\tunsigned long index = *pos / PAGE_CACHE_SIZE;\n\tunsigned offset = *pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned copied = 0;\n\tunsigned amt;\n\tstruct page *page;\n\tvoid *p;\n\n\tdo {\n\t\tamt = size - copied;\n\t\tif (offset + size > PAGE_CACHE_SIZE)\n\t\t\tamt = PAGE_CACHE_SIZE - offset;\n\t\tpage = read_cache_page(mapping, index, __gfs2_readpage, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tp = kmap_atomic(page);\n\t\tmemcpy(buf + copied, p + offset, amt);\n\t\tkunmap_atomic(p);\n\t\tpage_cache_release(page);\n\t\tcopied += amt;\n\t\tindex++;\n\t\toffset = 0;\n\t} while(copied < size);\n\t(*pos) += size;\n\treturn size;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"trans.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fs.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_internal_read(struct gfs2_inode *ip, char *buf, loff_t *pos,\n                       unsigned size)\n{\n\tstruct address_space *mapping = ip->i_inode.i_mapping;\n\tunsigned long index = *pos / PAGE_CACHE_SIZE;\n\tunsigned offset = *pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned copied = 0;\n\tunsigned amt;\n\tstruct page *page;\n\tvoid *p;\n\n\tdo {\n\t\tamt = size - copied;\n\t\tif (offset + size > PAGE_CACHE_SIZE)\n\t\t\tamt = PAGE_CACHE_SIZE - offset;\n\t\tpage = read_cache_page(mapping, index, __gfs2_readpage, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tp = kmap_atomic(page);\n\t\tmemcpy(buf + copied, p + offset, amt);\n\t\tkunmap_atomic(p);\n\t\tpage_cache_release(page);\n\t\tcopied += amt;\n\t\tindex++;\n\t\toffset = 0;\n\t} while(copied < size);\n\t(*pos) += size;\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qd2offset",
          "args": [
            "qd"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "qd2offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "204-212",
          "snippet": "static u64 qd2offset(struct gfs2_quota_data *qd)\n{\n\tu64 offset;\n\n\toffset = qd2index(qd);\n\toffset *= sizeof(struct gfs2_quota);\n\n\treturn offset;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic u64 qd2offset(struct gfs2_quota_data *qd)\n{\n\tu64 offset;\n\n\toffset = qd2index(qd);\n\toffset *= sizeof(struct gfs2_quota);\n\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&q",
            "0",
            "sizeof(struct gfs2_quota)"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "sdp->sd_quota_inode"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int update_qd(struct gfs2_sbd *sdp, struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_quota q;\n\tstruct gfs2_quota_lvb *qlvb;\n\tloff_t pos;\n\tint error;\n\n\tmemset(&q, 0, sizeof(struct gfs2_quota));\n\tpos = qd2offset(qd);\n\terror = gfs2_internal_read(ip, (char *)&q, &pos, sizeof(q));\n\tif (error < 0)\n\t\treturn error;\n\n\tqlvb = (struct gfs2_quota_lvb *)qd->qd_gl->gl_lksb.sb_lvbptr;\n\tqlvb->qb_magic = cpu_to_be32(GFS2_MAGIC);\n\tqlvb->__pad = 0;\n\tqlvb->qb_limit = q.qu_limit;\n\tqlvb->qb_warn = q.qu_warn;\n\tqlvb->qb_value = q.qu_value;\n\tqd->qd_qb = *qlvb;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "do_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "791-886",
    "snippet": "static int do_sync(unsigned int num_qd, struct gfs2_quota_data **qda)\n{\n\tstruct gfs2_sbd *sdp = (*qda)->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_alloc_parms ap = { .aflags = 0, };\n\tunsigned int data_blocks, ind_blocks;\n\tstruct gfs2_holder *ghs, i_gh;\n\tunsigned int qx, x;\n\tstruct gfs2_quota_data *qd;\n\tunsigned reserved;\n\tloff_t offset;\n\tunsigned int nalloc = 0, blocks;\n\tint error;\n\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\treturn error;\n\n\tgfs2_write_calc_reserv(ip, sizeof(struct gfs2_quota),\n\t\t\t      &data_blocks, &ind_blocks);\n\n\tghs = kcalloc(num_qd, sizeof(struct gfs2_holder), GFP_NOFS);\n\tif (!ghs)\n\t\treturn -ENOMEM;\n\n\tsort(qda, num_qd, sizeof(struct gfs2_quota_data *), sort_qd, NULL);\n\tmutex_lock(&ip->i_inode.i_mutex);\n\tfor (qx = 0; qx < num_qd; qx++) {\n\t\terror = gfs2_glock_nq_init(qda[qx]->qd_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t   GL_NOCACHE, &ghs[qx]);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &i_gh);\n\tif (error)\n\t\tgoto out;\n\n\tfor (x = 0; x < num_qd; x++) {\n\t\toffset = qd2offset(qda[x]);\n\t\tif (gfs2_write_alloc_required(ip, offset,\n\t\t\t\t\t      sizeof(struct gfs2_quota)))\n\t\t\tnalloc++;\n\t}\n\n\t/* \n\t * 1 blk for unstuffing inode if stuffed. We add this extra\n\t * block to the reservation unconditionally. If the inode\n\t * doesn't need unstuffing, the block will be released to the \n\t * rgrp since it won't be allocated during the transaction\n\t */\n\t/* +3 in the end for unstuffing block, inode size update block\n\t * and another block in case quota straddles page boundary and \n\t * two blocks need to be updated instead of 1 */\n\tblocks = num_qd * data_blocks + RES_DINODE + num_qd + 3;\n\n\treserved = 1 + (nalloc * (data_blocks + ind_blocks));\n\tap.target = reserved;\n\terror = gfs2_inplace_reserve(ip, &ap);\n\tif (error)\n\t\tgoto out_alloc;\n\n\tif (nalloc)\n\t\tblocks += gfs2_rg_blocks(ip, reserved) + nalloc * ind_blocks + RES_STATFS;\n\n\terror = gfs2_trans_begin(sdp, blocks, 0);\n\tif (error)\n\t\tgoto out_ipres;\n\n\tfor (x = 0; x < num_qd; x++) {\n\t\tqd = qda[x];\n\t\toffset = qd2offset(qd);\n\t\terror = gfs2_adjust_quota(ip, offset, qd->qd_change_sync, qd, NULL);\n\t\tif (error)\n\t\t\tgoto out_end_trans;\n\n\t\tdo_qc(qd, -qd->qd_change_sync);\n\t\tset_bit(QDF_REFRESH, &qd->qd_flags);\n\t}\n\n\terror = 0;\n\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_ipres:\n\tgfs2_inplace_release(ip);\nout_alloc:\n\tgfs2_glock_dq_uninit(&i_gh);\nout:\n\twhile (qx--)\n\t\tgfs2_glock_dq_uninit(&ghs[qx]);\n\tmutex_unlock(&ip->i_inode.i_mutex);\n\tkfree(ghs);\n\tgfs2_log_flush(ip->i_gl->gl_sbd, ip->i_gl, NORMAL_FLUSH);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_log_flush",
          "args": [
            "ip->i_gl->gl_sbd",
            "ip->i_gl",
            "NORMAL_FLUSH"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.c",
          "lines": "704-787",
          "snippet": "void gfs2_log_flush(struct gfs2_sbd *sdp, struct gfs2_glock *gl,\n\t\t    enum gfs2_flush_type type)\n{\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\n\t/* Log might have been flushed while we waited for the flush lock */\n\tif (gl && !test_bit(GLF_LFLUSH, &gl->gl_flags)) {\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\treturn;\n\t}\n\ttrace_gfs2_log_flush(sdp, 1);\n\n\tsdp->sd_log_flush_head = sdp->sd_log_head;\n\tsdp->sd_log_flush_wrapped = 0;\n\ttr = sdp->sd_log_tr;\n\tif (tr) {\n\t\tsdp->sd_log_tr = NULL;\n\t\tINIT_LIST_HEAD(&tr->tr_ail1_list);\n\t\tINIT_LIST_HEAD(&tr->tr_ail2_list);\n\t\ttr->tr_first = sdp->sd_log_flush_head;\n\t\tif (unlikely (state == SFS_FROZEN))\n\t\t\tgfs2_assert_withdraw(sdp, !tr->tr_num_buf_new && !tr->tr_num_databuf_new);\n\t}\n\n\tif (unlikely(state == SFS_FROZEN))\n\t\tgfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\n\tgfs2_assert_withdraw(sdp,\n\t\t\tsdp->sd_log_num_revoke == sdp->sd_log_commited_revoke);\n\n\tgfs2_ordered_write(sdp);\n\tlops_before_commit(sdp, tr);\n\tgfs2_log_flush_bio(sdp, WRITE);\n\n\tif (sdp->sd_log_head != sdp->sd_log_flush_head) {\n\t\tlog_flush_wait(sdp);\n\t\tlog_write_header(sdp, 0);\n\t} else if (sdp->sd_log_tail != current_tail(sdp) && !sdp->sd_log_idle){\n\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\tlog_write_header(sdp, 0);\n\t}\n\tlops_after_commit(sdp, tr);\n\n\tgfs2_log_lock(sdp);\n\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\tsdp->sd_log_blks_reserved = 0;\n\tsdp->sd_log_commited_revoke = 0;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && !list_empty(&tr->tr_ail1_list)) {\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\t\ttr = NULL;\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\n\tif (type != NORMAL_FLUSH) {\n\t\tif (!sdp->sd_log_idle) {\n\t\t\tfor (;;) {\n\t\t\t\tgfs2_ail1_start(sdp);\n\t\t\t\tgfs2_ail1_wait(sdp);\n\t\t\t\tif (gfs2_ail1_empty(sdp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\t\tsdp->sd_log_flush_wrapped = 0;\n\t\t\tlog_write_header(sdp, 0);\n\t\t\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\t\t}\n\t\tif (type == SHUTDOWN_FLUSH || type == FREEZE_FLUSH)\n\t\t\tgfs2_log_shutdown(sdp);\n\t\tif (type == FREEZE_FLUSH)\n\t\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);\n\t}\n\n\ttrace_gfs2_log_flush(sdp, 0);\n\tup_write(&sdp->sd_log_flush_lock);\n\n\tkfree(tr);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/list_sort.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_log_flush(struct gfs2_sbd *sdp, struct gfs2_glock *gl,\n\t\t    enum gfs2_flush_type type)\n{\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\n\t/* Log might have been flushed while we waited for the flush lock */\n\tif (gl && !test_bit(GLF_LFLUSH, &gl->gl_flags)) {\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\treturn;\n\t}\n\ttrace_gfs2_log_flush(sdp, 1);\n\n\tsdp->sd_log_flush_head = sdp->sd_log_head;\n\tsdp->sd_log_flush_wrapped = 0;\n\ttr = sdp->sd_log_tr;\n\tif (tr) {\n\t\tsdp->sd_log_tr = NULL;\n\t\tINIT_LIST_HEAD(&tr->tr_ail1_list);\n\t\tINIT_LIST_HEAD(&tr->tr_ail2_list);\n\t\ttr->tr_first = sdp->sd_log_flush_head;\n\t\tif (unlikely (state == SFS_FROZEN))\n\t\t\tgfs2_assert_withdraw(sdp, !tr->tr_num_buf_new && !tr->tr_num_databuf_new);\n\t}\n\n\tif (unlikely(state == SFS_FROZEN))\n\t\tgfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\n\tgfs2_assert_withdraw(sdp,\n\t\t\tsdp->sd_log_num_revoke == sdp->sd_log_commited_revoke);\n\n\tgfs2_ordered_write(sdp);\n\tlops_before_commit(sdp, tr);\n\tgfs2_log_flush_bio(sdp, WRITE);\n\n\tif (sdp->sd_log_head != sdp->sd_log_flush_head) {\n\t\tlog_flush_wait(sdp);\n\t\tlog_write_header(sdp, 0);\n\t} else if (sdp->sd_log_tail != current_tail(sdp) && !sdp->sd_log_idle){\n\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\tlog_write_header(sdp, 0);\n\t}\n\tlops_after_commit(sdp, tr);\n\n\tgfs2_log_lock(sdp);\n\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\tsdp->sd_log_blks_reserved = 0;\n\tsdp->sd_log_commited_revoke = 0;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && !list_empty(&tr->tr_ail1_list)) {\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\t\ttr = NULL;\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\n\tif (type != NORMAL_FLUSH) {\n\t\tif (!sdp->sd_log_idle) {\n\t\t\tfor (;;) {\n\t\t\t\tgfs2_ail1_start(sdp);\n\t\t\t\tgfs2_ail1_wait(sdp);\n\t\t\t\tif (gfs2_ail1_empty(sdp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\t\tsdp->sd_log_flush_wrapped = 0;\n\t\t\tlog_write_header(sdp, 0);\n\t\t\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\t\t}\n\t\tif (type == SHUTDOWN_FLUSH || type == FREEZE_FLUSH)\n\t\t\tgfs2_log_shutdown(sdp);\n\t\tif (type == FREEZE_FLUSH)\n\t\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);\n\t}\n\n\ttrace_gfs2_log_flush(sdp, 0);\n\tup_write(&sdp->sd_log_flush_lock);\n\n\tkfree(tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ghs"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ip->i_inode.i_mutex"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&ghs[qx]"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_inplace_release",
          "args": [
            "ip"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inplace_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2081-2087",
          "snippet": "void gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "QDF_REFRESH",
            "&qd->qd_flags"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_qc",
          "args": [
            "qd",
            "-qd->qd_change_sync"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "do_qc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "615-653",
          "snippet": "static void do_qc(struct gfs2_quota_data *qd, s64 change)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_qc_inode);\n\tstruct gfs2_quota_change *qc = qd->qd_bh_qc;\n\ts64 x;\n\n\tmutex_lock(&sdp->sd_quota_mutex);\n\tgfs2_trans_add_meta(ip->i_gl, qd->qd_bh);\n\n\tif (!test_bit(QDF_CHANGE, &qd->qd_flags)) {\n\t\tqc->qc_change = 0;\n\t\tqc->qc_flags = 0;\n\t\tif (qd->qd_id.type == USRQUOTA)\n\t\t\tqc->qc_flags = cpu_to_be32(GFS2_QCF_USER);\n\t\tqc->qc_id = cpu_to_be32(from_kqid(&init_user_ns, qd->qd_id));\n\t}\n\n\tx = be64_to_cpu(qc->qc_change) + change;\n\tqc->qc_change = cpu_to_be64(x);\n\n\tspin_lock(&qd_lock);\n\tqd->qd_change = x;\n\tspin_unlock(&qd_lock);\n\n\tif (!x) {\n\t\tgfs2_assert_warn(sdp, test_bit(QDF_CHANGE, &qd->qd_flags));\n\t\tclear_bit(QDF_CHANGE, &qd->qd_flags);\n\t\tqc->qc_flags = 0;\n\t\tqc->qc_id = 0;\n\t\tslot_put(qd);\n\t\tqd_put(qd);\n\t} else if (!test_and_set_bit(QDF_CHANGE, &qd->qd_flags)) {\n\t\tqd_hold(qd);\n\t\tslot_hold(qd);\n\t}\n\n\tmutex_unlock(&sdp->sd_quota_mutex);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(qd_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\n\nstatic void do_qc(struct gfs2_quota_data *qd, s64 change)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_qc_inode);\n\tstruct gfs2_quota_change *qc = qd->qd_bh_qc;\n\ts64 x;\n\n\tmutex_lock(&sdp->sd_quota_mutex);\n\tgfs2_trans_add_meta(ip->i_gl, qd->qd_bh);\n\n\tif (!test_bit(QDF_CHANGE, &qd->qd_flags)) {\n\t\tqc->qc_change = 0;\n\t\tqc->qc_flags = 0;\n\t\tif (qd->qd_id.type == USRQUOTA)\n\t\t\tqc->qc_flags = cpu_to_be32(GFS2_QCF_USER);\n\t\tqc->qc_id = cpu_to_be32(from_kqid(&init_user_ns, qd->qd_id));\n\t}\n\n\tx = be64_to_cpu(qc->qc_change) + change;\n\tqc->qc_change = cpu_to_be64(x);\n\n\tspin_lock(&qd_lock);\n\tqd->qd_change = x;\n\tspin_unlock(&qd_lock);\n\n\tif (!x) {\n\t\tgfs2_assert_warn(sdp, test_bit(QDF_CHANGE, &qd->qd_flags));\n\t\tclear_bit(QDF_CHANGE, &qd->qd_flags);\n\t\tqc->qc_flags = 0;\n\t\tqc->qc_id = 0;\n\t\tslot_put(qd);\n\t\tqd_put(qd);\n\t} else if (!test_and_set_bit(QDF_CHANGE, &qd->qd_flags)) {\n\t\tqd_hold(qd);\n\t\tslot_hold(qd);\n\t}\n\n\tmutex_unlock(&sdp->sd_quota_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_adjust_quota",
          "args": [
            "ip",
            "offset",
            "qd->qd_change_sync",
            "qd",
            "NULL"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_adjust_quota",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "669-789",
          "snippet": "static int gfs2_adjust_quota(struct gfs2_inode *ip, loff_t loc,\n\t\t\t     s64 change, struct gfs2_quota_data *qd,\n\t\t\t     struct qc_dqblk *fdq)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned long index = loc >> PAGE_CACHE_SHIFT;\n\tunsigned offset = loc & (PAGE_CACHE_SIZE - 1);\n\tunsigned blocksize, iblock, pos;\n\tstruct buffer_head *bh;\n\tstruct page *page;\n\tvoid *kaddr, *ptr;\n\tstruct gfs2_quota q;\n\tint err, nbytes;\n\tu64 size;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terr = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmemset(&q, 0, sizeof(struct gfs2_quota));\n\terr = gfs2_internal_read(ip, (char *)&q, &loc, sizeof(q));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EIO;\n\tbe64_add_cpu(&q.qu_value, change);\n\tqd->qd_qb.qb_value = q.qu_value;\n\tif (fdq) {\n\t\tif (fdq->d_fieldmask & QC_SPC_SOFT) {\n\t\t\tq.qu_warn = cpu_to_be64(fdq->d_spc_softlimit >> sdp->sd_sb.sb_bsize_shift);\n\t\t\tqd->qd_qb.qb_warn = q.qu_warn;\n\t\t}\n\t\tif (fdq->d_fieldmask & QC_SPC_HARD) {\n\t\t\tq.qu_limit = cpu_to_be64(fdq->d_spc_hardlimit >> sdp->sd_sb.sb_bsize_shift);\n\t\t\tqd->qd_qb.qb_limit = q.qu_limit;\n\t\t}\n\t\tif (fdq->d_fieldmask & QC_SPACE) {\n\t\t\tq.qu_value = cpu_to_be64(fdq->d_space >> sdp->sd_sb.sb_bsize_shift);\n\t\t\tqd->qd_qb.qb_value = q.qu_value;\n\t\t}\n\t}\n\n\t/* Write the quota into the quota file on disk */\n\tptr = &q;\n\tnbytes = sizeof(struct gfs2_quota);\nget_a_page:\n\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tiblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\tif (!buffer_mapped(bh)) {\n\t\tgfs2_block_map(inode, iblock, bh, 1);\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock_out;\n\t\t/* If it's a newly allocated disk block for quota, zero it */\n\t\tif (buffer_new(bh))\n\t\t\tzero_user(page, pos - blocksize, bh->b_size);\n\t}\n\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\tll_rw_block(READ | REQ_META, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock_out;\n\t}\n\n\tgfs2_trans_add_data(ip->i_gl, bh);\n\n\tkaddr = kmap_atomic(page);\n\tif (offset + sizeof(struct gfs2_quota) > PAGE_CACHE_SIZE)\n\t\tnbytes = PAGE_CACHE_SIZE - offset;\n\tmemcpy(kaddr + offset, ptr, nbytes);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\t/* If quota straddles page boundary, we need to update the rest of the\n\t * quota at the beginning of the next page */\n\tif ((offset + sizeof(struct gfs2_quota)) > PAGE_CACHE_SIZE) {\n\t\tptr = ptr + nbytes;\n\t\tnbytes = sizeof(struct gfs2_quota) - nbytes;\n\t\toffset = 0;\n\t\tindex++;\n\t\tgoto get_a_page;\n\t}\n\n\tsize = loc + sizeof(struct gfs2_quota);\n\tif (size > inode->i_size)\n\t\ti_size_write(inode, size);\n\tinode->i_mtime = inode->i_atime = CURRENT_TIME;\n\tmark_inode_dirty(inode);\n\tset_bit(QDF_REFRESH, &qd->qd_flags);\n\treturn 0;\n\nunlock_out:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_adjust_quota(struct gfs2_inode *ip, loff_t loc,\n\t\t\t     s64 change, struct gfs2_quota_data *qd,\n\t\t\t     struct qc_dqblk *fdq)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned long index = loc >> PAGE_CACHE_SHIFT;\n\tunsigned offset = loc & (PAGE_CACHE_SIZE - 1);\n\tunsigned blocksize, iblock, pos;\n\tstruct buffer_head *bh;\n\tstruct page *page;\n\tvoid *kaddr, *ptr;\n\tstruct gfs2_quota q;\n\tint err, nbytes;\n\tu64 size;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terr = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmemset(&q, 0, sizeof(struct gfs2_quota));\n\terr = gfs2_internal_read(ip, (char *)&q, &loc, sizeof(q));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EIO;\n\tbe64_add_cpu(&q.qu_value, change);\n\tqd->qd_qb.qb_value = q.qu_value;\n\tif (fdq) {\n\t\tif (fdq->d_fieldmask & QC_SPC_SOFT) {\n\t\t\tq.qu_warn = cpu_to_be64(fdq->d_spc_softlimit >> sdp->sd_sb.sb_bsize_shift);\n\t\t\tqd->qd_qb.qb_warn = q.qu_warn;\n\t\t}\n\t\tif (fdq->d_fieldmask & QC_SPC_HARD) {\n\t\t\tq.qu_limit = cpu_to_be64(fdq->d_spc_hardlimit >> sdp->sd_sb.sb_bsize_shift);\n\t\t\tqd->qd_qb.qb_limit = q.qu_limit;\n\t\t}\n\t\tif (fdq->d_fieldmask & QC_SPACE) {\n\t\t\tq.qu_value = cpu_to_be64(fdq->d_space >> sdp->sd_sb.sb_bsize_shift);\n\t\t\tqd->qd_qb.qb_value = q.qu_value;\n\t\t}\n\t}\n\n\t/* Write the quota into the quota file on disk */\n\tptr = &q;\n\tnbytes = sizeof(struct gfs2_quota);\nget_a_page:\n\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tiblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\tif (!buffer_mapped(bh)) {\n\t\tgfs2_block_map(inode, iblock, bh, 1);\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock_out;\n\t\t/* If it's a newly allocated disk block for quota, zero it */\n\t\tif (buffer_new(bh))\n\t\t\tzero_user(page, pos - blocksize, bh->b_size);\n\t}\n\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\tll_rw_block(READ | REQ_META, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock_out;\n\t}\n\n\tgfs2_trans_add_data(ip->i_gl, bh);\n\n\tkaddr = kmap_atomic(page);\n\tif (offset + sizeof(struct gfs2_quota) > PAGE_CACHE_SIZE)\n\t\tnbytes = PAGE_CACHE_SIZE - offset;\n\tmemcpy(kaddr + offset, ptr, nbytes);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\t/* If quota straddles page boundary, we need to update the rest of the\n\t * quota at the beginning of the next page */\n\tif ((offset + sizeof(struct gfs2_quota)) > PAGE_CACHE_SIZE) {\n\t\tptr = ptr + nbytes;\n\t\tnbytes = sizeof(struct gfs2_quota) - nbytes;\n\t\toffset = 0;\n\t\tindex++;\n\t\tgoto get_a_page;\n\t}\n\n\tsize = loc + sizeof(struct gfs2_quota);\n\tif (size > inode->i_size)\n\t\ti_size_write(inode, size);\n\tinode->i_mtime = inode->i_atime = CURRENT_TIME;\n\tmark_inode_dirty(inode);\n\tset_bit(QDF_REFRESH, &qd->qd_flags);\n\treturn 0;\n\nunlock_out:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qd2offset",
          "args": [
            "qd"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "qd2offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "204-212",
          "snippet": "static u64 qd2offset(struct gfs2_quota_data *qd)\n{\n\tu64 offset;\n\n\toffset = qd2index(qd);\n\toffset *= sizeof(struct gfs2_quota);\n\n\treturn offset;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic u64 qd2offset(struct gfs2_quota_data *qd)\n{\n\tu64 offset;\n\n\toffset = qd2index(qd);\n\toffset *= sizeof(struct gfs2_quota);\n\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "blocks",
            "0"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rg_blocks",
          "args": [
            "ip",
            "reserved"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rg_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.h",
          "lines": "31-36",
          "snippet": "static inline unsigned int gfs2_rg_blocks(const struct gfs2_inode *ip, unsigned requested)\n{\n\tif (requested < ip->i_rgd->rd_length)\n\t\treturn requested + 1;\n\treturn ip->i_rgd->rd_length;\n}",
          "includes": [
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n\nstatic inline unsigned int gfs2_rg_blocks(const struct gfs2_inode *ip, unsigned requested)\n{\n\tif (requested < ip->i_rgd->rd_length)\n\t\treturn requested + 1;\n\treturn ip->i_rgd->rd_length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_inplace_reserve",
          "args": [
            "ip",
            "&ap"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inplace_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1952-2072",
          "snippet": "int gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *begin = NULL;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tint error = 0, rg_locked, flags = 0;\n\tu64 last_unlinked = NO_BLOCK;\n\tint loops = 0;\n\tu32 skip = 0;\n\n\tif (sdp->sd_args.ar_rgrplvb)\n\t\tflags |= GL_SKIP;\n\tif (gfs2_assert_warn(sdp, ap->target))\n\t\treturn -EINVAL;\n\tif (gfs2_rs_active(rs)) {\n\t\tbegin = rs->rs_rbm.rgd;\n\t} else if (ip->i_rgd && rgrp_contains_block(ip->i_rgd, ip->i_goal)) {\n\t\trs->rs_rbm.rgd = begin = ip->i_rgd;\n\t} else {\n\t\tcheck_and_update_goal(ip);\n\t\trs->rs_rbm.rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal, 1);\n\t}\n\tif (S_ISDIR(ip->i_inode.i_mode) && (ap->aflags & GFS2_AF_ORLOV))\n\t\tskip = gfs2_orlov_skip(ip);\n\tif (rs->rs_rbm.rgd == NULL)\n\t\treturn -EBADSLT;\n\n\twhile (loops < 3) {\n\t\trg_locked = 1;\n\n\t\tif (!gfs2_glock_is_locked_by_me(rs->rs_rbm.rgd->rd_gl)) {\n\t\t\trg_locked = 0;\n\t\t\tif (skip && skip--)\n\t\t\t\tgoto next_rgrp;\n\t\t\tif (!gfs2_rs_active(rs)) {\n\t\t\t\tif (loops == 0 &&\n\t\t\t\t    !fast_to_acquire(rs->rs_rbm.rgd))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t\tif ((loops < 2) &&\n\t\t\t\t    gfs2_rgrp_used_recently(rs, 1000) &&\n\t\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t}\n\t\t\terror = gfs2_glock_nq_init(rs->rs_rbm.rgd->rd_gl,\n\t\t\t\t\t\t   LM_ST_EXCLUSIVE, flags,\n\t\t\t\t\t\t   &rs->rs_rgd_gh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn error;\n\t\t\tif (!gfs2_rs_active(rs) && (loops < 2) &&\n\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\tgoto skip_rgrp;\n\t\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\t\terror = update_rgrp_lvb(rs->rs_rbm.rgd);\n\t\t\t\tif (unlikely(error)) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Skip unuseable resource groups */\n\t\tif ((rs->rs_rbm.rgd->rd_flags & (GFS2_RGF_NOALLOC |\n\t\t\t\t\t\t GFS2_RDF_ERROR)) ||\n\t\t    (ap->target > rs->rs_rbm.rgd->rd_extfail_pt))\n\t\t\tgoto skip_rgrp;\n\n\t\tif (sdp->sd_args.ar_rgrplvb)\n\t\t\tgfs2_rgrp_bh_get(rs->rs_rbm.rgd);\n\n\t\t/* Get a reservation if we don't already have one */\n\t\tif (!gfs2_rs_active(rs))\n\t\t\trg_mblk_search(rs->rs_rbm.rgd, ip, ap);\n\n\t\t/* Skip rgrps when we can't get a reservation on first pass */\n\t\tif (!gfs2_rs_active(rs) && (loops < 1))\n\t\t\tgoto check_rgrp;\n\n\t\t/* If rgrp has enough free space, use it */\n\t\tif (rs->rs_rbm.rgd->rd_free_clone >= ap->target) {\n\t\t\tip->i_rgd = rs->rs_rbm.rgd;\n\t\t\treturn 0;\n\t\t}\n\ncheck_rgrp:\n\t\t/* Check for unlinked inodes which can be reclaimed */\n\t\tif (rs->rs_rbm.rgd->rd_flags & GFS2_RDF_CHECK)\n\t\t\ttry_rgrp_unlink(rs->rs_rbm.rgd, &last_unlinked,\n\t\t\t\t\tip->i_no_addr);\nskip_rgrp:\n\t\t/* Drop reservation, if we couldn't use reserved rgrp */\n\t\tif (gfs2_rs_active(rs))\n\t\t\tgfs2_rs_deltree(rs);\n\n\t\t/* Unlock rgrp if required */\n\t\tif (!rg_locked)\n\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\nnext_rgrp:\n\t\t/* Find the next rgrp, and continue looking */\n\t\tif (gfs2_select_rgrp(&rs->rs_rbm.rgd, begin))\n\t\t\tcontinue;\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\t/* If we've scanned all the rgrps, but found no free blocks\n\t\t * then this checks for some less likely conditions before\n\t\t * trying again.\n\t\t */\n\t\tloops++;\n\t\t/* Check that fs hasn't grown if writing to rindex */\n\t\tif (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {\n\t\t\terror = gfs2_ri_update(ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t/* Flushing the log may release space */\n\t\tif (loops == 2)\n\t\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\t}\n\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define NO_BLOCK ((u64)~0)"
          ],
          "globals_used": [
            "static int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define NO_BLOCK ((u64)~0)\n\nstatic int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);\n\nint gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *begin = NULL;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tint error = 0, rg_locked, flags = 0;\n\tu64 last_unlinked = NO_BLOCK;\n\tint loops = 0;\n\tu32 skip = 0;\n\n\tif (sdp->sd_args.ar_rgrplvb)\n\t\tflags |= GL_SKIP;\n\tif (gfs2_assert_warn(sdp, ap->target))\n\t\treturn -EINVAL;\n\tif (gfs2_rs_active(rs)) {\n\t\tbegin = rs->rs_rbm.rgd;\n\t} else if (ip->i_rgd && rgrp_contains_block(ip->i_rgd, ip->i_goal)) {\n\t\trs->rs_rbm.rgd = begin = ip->i_rgd;\n\t} else {\n\t\tcheck_and_update_goal(ip);\n\t\trs->rs_rbm.rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal, 1);\n\t}\n\tif (S_ISDIR(ip->i_inode.i_mode) && (ap->aflags & GFS2_AF_ORLOV))\n\t\tskip = gfs2_orlov_skip(ip);\n\tif (rs->rs_rbm.rgd == NULL)\n\t\treturn -EBADSLT;\n\n\twhile (loops < 3) {\n\t\trg_locked = 1;\n\n\t\tif (!gfs2_glock_is_locked_by_me(rs->rs_rbm.rgd->rd_gl)) {\n\t\t\trg_locked = 0;\n\t\t\tif (skip && skip--)\n\t\t\t\tgoto next_rgrp;\n\t\t\tif (!gfs2_rs_active(rs)) {\n\t\t\t\tif (loops == 0 &&\n\t\t\t\t    !fast_to_acquire(rs->rs_rbm.rgd))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t\tif ((loops < 2) &&\n\t\t\t\t    gfs2_rgrp_used_recently(rs, 1000) &&\n\t\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t}\n\t\t\terror = gfs2_glock_nq_init(rs->rs_rbm.rgd->rd_gl,\n\t\t\t\t\t\t   LM_ST_EXCLUSIVE, flags,\n\t\t\t\t\t\t   &rs->rs_rgd_gh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn error;\n\t\t\tif (!gfs2_rs_active(rs) && (loops < 2) &&\n\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\tgoto skip_rgrp;\n\t\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\t\terror = update_rgrp_lvb(rs->rs_rbm.rgd);\n\t\t\t\tif (unlikely(error)) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Skip unuseable resource groups */\n\t\tif ((rs->rs_rbm.rgd->rd_flags & (GFS2_RGF_NOALLOC |\n\t\t\t\t\t\t GFS2_RDF_ERROR)) ||\n\t\t    (ap->target > rs->rs_rbm.rgd->rd_extfail_pt))\n\t\t\tgoto skip_rgrp;\n\n\t\tif (sdp->sd_args.ar_rgrplvb)\n\t\t\tgfs2_rgrp_bh_get(rs->rs_rbm.rgd);\n\n\t\t/* Get a reservation if we don't already have one */\n\t\tif (!gfs2_rs_active(rs))\n\t\t\trg_mblk_search(rs->rs_rbm.rgd, ip, ap);\n\n\t\t/* Skip rgrps when we can't get a reservation on first pass */\n\t\tif (!gfs2_rs_active(rs) && (loops < 1))\n\t\t\tgoto check_rgrp;\n\n\t\t/* If rgrp has enough free space, use it */\n\t\tif (rs->rs_rbm.rgd->rd_free_clone >= ap->target) {\n\t\t\tip->i_rgd = rs->rs_rbm.rgd;\n\t\t\treturn 0;\n\t\t}\n\ncheck_rgrp:\n\t\t/* Check for unlinked inodes which can be reclaimed */\n\t\tif (rs->rs_rbm.rgd->rd_flags & GFS2_RDF_CHECK)\n\t\t\ttry_rgrp_unlink(rs->rs_rbm.rgd, &last_unlinked,\n\t\t\t\t\tip->i_no_addr);\nskip_rgrp:\n\t\t/* Drop reservation, if we couldn't use reserved rgrp */\n\t\tif (gfs2_rs_active(rs))\n\t\t\tgfs2_rs_deltree(rs);\n\n\t\t/* Unlock rgrp if required */\n\t\tif (!rg_locked)\n\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\nnext_rgrp:\n\t\t/* Find the next rgrp, and continue looking */\n\t\tif (gfs2_select_rgrp(&rs->rs_rbm.rgd, begin))\n\t\t\tcontinue;\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\t/* If we've scanned all the rgrps, but found no free blocks\n\t\t * then this checks for some less likely conditions before\n\t\t * trying again.\n\t\t */\n\t\tloops++;\n\t\t/* Check that fs hasn't grown if writing to rindex */\n\t\tif (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {\n\t\t\terror = gfs2_ri_update(ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t/* Flushing the log may release space */\n\t\tif (loops == 2)\n\t\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\t}\n\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_write_alloc_required",
          "args": [
            "ip",
            "offset",
            "sizeof(struct gfs2_quota)"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_write_alloc_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "1455-1494",
          "snippet": "int gfs2_write_alloc_required(struct gfs2_inode *ip, u64 offset,\n\t\t\t      unsigned int len)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head bh;\n\tunsigned int shift;\n\tu64 lblock, lblock_stop, size;\n\tu64 end_of_file;\n\n\tif (!len)\n\t\treturn 0;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\tif (offset + len >\n\t\t    sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tshift = sdp->sd_sb.sb_bsize_shift;\n\tBUG_ON(gfs2_is_dir(ip));\n\tend_of_file = (i_size_read(&ip->i_inode) + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tlblock = offset >> shift;\n\tlblock_stop = (offset + len + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tif (lblock_stop > end_of_file)\n\t\treturn 1;\n\n\tsize = (lblock_stop - lblock) << shift;\n\tdo {\n\t\tbh.b_state = 0;\n\t\tbh.b_size = size;\n\t\tgfs2_block_map(&ip->i_inode, lblock, &bh, 0);\n\t\tif (!buffer_mapped(&bh))\n\t\t\treturn 1;\n\t\tsize -= bh.b_size;\n\t\tlblock += (bh.b_size >> ip->i_inode.i_blkbits);\n\t} while(size > 0);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_write_alloc_required(struct gfs2_inode *ip, u64 offset,\n\t\t\t      unsigned int len)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head bh;\n\tunsigned int shift;\n\tu64 lblock, lblock_stop, size;\n\tu64 end_of_file;\n\n\tif (!len)\n\t\treturn 0;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\tif (offset + len >\n\t\t    sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tshift = sdp->sd_sb.sb_bsize_shift;\n\tBUG_ON(gfs2_is_dir(ip));\n\tend_of_file = (i_size_read(&ip->i_inode) + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tlblock = offset >> shift;\n\tlblock_stop = (offset + len + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tif (lblock_stop > end_of_file)\n\t\treturn 1;\n\n\tsize = (lblock_stop - lblock) << shift;\n\tdo {\n\t\tbh.b_state = 0;\n\t\tbh.b_size = size;\n\t\tgfs2_block_map(&ip->i_inode, lblock, &bh, 0);\n\t\tif (!buffer_mapped(&bh))\n\t\t\treturn 1;\n\t\tsize -= bh.b_size;\n\t\tlblock += (bh.b_size >> ip->i_inode.i_blkbits);\n\t} while(size > 0);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "ip->i_gl",
            "LM_ST_EXCLUSIVE",
            "0",
            "&i_gh"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ip->i_inode.i_mutex"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "qda",
            "num_qd",
            "sizeof(struct gfs2_quota_data *)",
            "sort_qd",
            "NULL"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "num_qd",
            "sizeof(struct gfs2_holder)",
            "GFP_NOFS"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_write_calc_reserv",
          "args": [
            "ip",
            "sizeof(struct gfs2_quota)",
            "&data_blocks",
            "&ind_blocks"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_write_calc_reserv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.h",
          "lines": "29-45",
          "snippet": "static inline void gfs2_write_calc_reserv(const struct gfs2_inode *ip,\n\t\t\t\t\t  unsigned int len,\n\t\t\t\t\t  unsigned int *data_blocks,\n\t\t\t\t\t  unsigned int *ind_blocks)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int tmp;\n\n\tBUG_ON(gfs2_is_dir(ip));\n\t*data_blocks = (len >> sdp->sd_sb.sb_bsize_shift) + 3;\n\t*ind_blocks = 3 * (sdp->sd_max_height - 1);\n\n\tfor (tmp = *data_blocks; tmp > sdp->sd_diptrs;) {\n\t\ttmp = DIV_ROUND_UP(tmp, sdp->sd_inptrs);\n\t\t*ind_blocks += tmp;\n\t}\n}",
          "includes": [
            "#include \"inode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n\nstatic inline void gfs2_write_calc_reserv(const struct gfs2_inode *ip,\n\t\t\t\t\t  unsigned int len,\n\t\t\t\t\t  unsigned int *data_blocks,\n\t\t\t\t\t  unsigned int *ind_blocks)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int tmp;\n\n\tBUG_ON(gfs2_is_dir(ip));\n\t*data_blocks = (len >> sdp->sd_sb.sb_bsize_shift) + 3;\n\t*ind_blocks = 3 * (sdp->sd_max_height - 1);\n\n\tfor (tmp = *data_blocks; tmp > sdp->sd_diptrs;) {\n\t\ttmp = DIV_ROUND_UP(tmp, sdp->sd_inptrs);\n\t\t*ind_blocks += tmp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rs_alloc",
          "args": [
            "ip"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "602-620",
          "snippet": "int gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "sdp->sd_quota_inode"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int do_sync(unsigned int num_qd, struct gfs2_quota_data **qda)\n{\n\tstruct gfs2_sbd *sdp = (*qda)->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tstruct gfs2_alloc_parms ap = { .aflags = 0, };\n\tunsigned int data_blocks, ind_blocks;\n\tstruct gfs2_holder *ghs, i_gh;\n\tunsigned int qx, x;\n\tstruct gfs2_quota_data *qd;\n\tunsigned reserved;\n\tloff_t offset;\n\tunsigned int nalloc = 0, blocks;\n\tint error;\n\n\terror = gfs2_rs_alloc(ip);\n\tif (error)\n\t\treturn error;\n\n\tgfs2_write_calc_reserv(ip, sizeof(struct gfs2_quota),\n\t\t\t      &data_blocks, &ind_blocks);\n\n\tghs = kcalloc(num_qd, sizeof(struct gfs2_holder), GFP_NOFS);\n\tif (!ghs)\n\t\treturn -ENOMEM;\n\n\tsort(qda, num_qd, sizeof(struct gfs2_quota_data *), sort_qd, NULL);\n\tmutex_lock(&ip->i_inode.i_mutex);\n\tfor (qx = 0; qx < num_qd; qx++) {\n\t\terror = gfs2_glock_nq_init(qda[qx]->qd_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t   GL_NOCACHE, &ghs[qx]);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &i_gh);\n\tif (error)\n\t\tgoto out;\n\n\tfor (x = 0; x < num_qd; x++) {\n\t\toffset = qd2offset(qda[x]);\n\t\tif (gfs2_write_alloc_required(ip, offset,\n\t\t\t\t\t      sizeof(struct gfs2_quota)))\n\t\t\tnalloc++;\n\t}\n\n\t/* \n\t * 1 blk for unstuffing inode if stuffed. We add this extra\n\t * block to the reservation unconditionally. If the inode\n\t * doesn't need unstuffing, the block will be released to the \n\t * rgrp since it won't be allocated during the transaction\n\t */\n\t/* +3 in the end for unstuffing block, inode size update block\n\t * and another block in case quota straddles page boundary and \n\t * two blocks need to be updated instead of 1 */\n\tblocks = num_qd * data_blocks + RES_DINODE + num_qd + 3;\n\n\treserved = 1 + (nalloc * (data_blocks + ind_blocks));\n\tap.target = reserved;\n\terror = gfs2_inplace_reserve(ip, &ap);\n\tif (error)\n\t\tgoto out_alloc;\n\n\tif (nalloc)\n\t\tblocks += gfs2_rg_blocks(ip, reserved) + nalloc * ind_blocks + RES_STATFS;\n\n\terror = gfs2_trans_begin(sdp, blocks, 0);\n\tif (error)\n\t\tgoto out_ipres;\n\n\tfor (x = 0; x < num_qd; x++) {\n\t\tqd = qda[x];\n\t\toffset = qd2offset(qd);\n\t\terror = gfs2_adjust_quota(ip, offset, qd->qd_change_sync, qd, NULL);\n\t\tif (error)\n\t\t\tgoto out_end_trans;\n\n\t\tdo_qc(qd, -qd->qd_change_sync);\n\t\tset_bit(QDF_REFRESH, &qd->qd_flags);\n\t}\n\n\terror = 0;\n\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_ipres:\n\tgfs2_inplace_release(ip);\nout_alloc:\n\tgfs2_glock_dq_uninit(&i_gh);\nout:\n\twhile (qx--)\n\t\tgfs2_glock_dq_uninit(&ghs[qx]);\n\tmutex_unlock(&ip->i_inode.i_mutex);\n\tkfree(ghs);\n\tgfs2_log_flush(ip->i_gl->gl_sbd, ip->i_gl, NORMAL_FLUSH);\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_adjust_quota",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "669-789",
    "snippet": "static int gfs2_adjust_quota(struct gfs2_inode *ip, loff_t loc,\n\t\t\t     s64 change, struct gfs2_quota_data *qd,\n\t\t\t     struct qc_dqblk *fdq)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned long index = loc >> PAGE_CACHE_SHIFT;\n\tunsigned offset = loc & (PAGE_CACHE_SIZE - 1);\n\tunsigned blocksize, iblock, pos;\n\tstruct buffer_head *bh;\n\tstruct page *page;\n\tvoid *kaddr, *ptr;\n\tstruct gfs2_quota q;\n\tint err, nbytes;\n\tu64 size;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terr = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmemset(&q, 0, sizeof(struct gfs2_quota));\n\terr = gfs2_internal_read(ip, (char *)&q, &loc, sizeof(q));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EIO;\n\tbe64_add_cpu(&q.qu_value, change);\n\tqd->qd_qb.qb_value = q.qu_value;\n\tif (fdq) {\n\t\tif (fdq->d_fieldmask & QC_SPC_SOFT) {\n\t\t\tq.qu_warn = cpu_to_be64(fdq->d_spc_softlimit >> sdp->sd_sb.sb_bsize_shift);\n\t\t\tqd->qd_qb.qb_warn = q.qu_warn;\n\t\t}\n\t\tif (fdq->d_fieldmask & QC_SPC_HARD) {\n\t\t\tq.qu_limit = cpu_to_be64(fdq->d_spc_hardlimit >> sdp->sd_sb.sb_bsize_shift);\n\t\t\tqd->qd_qb.qb_limit = q.qu_limit;\n\t\t}\n\t\tif (fdq->d_fieldmask & QC_SPACE) {\n\t\t\tq.qu_value = cpu_to_be64(fdq->d_space >> sdp->sd_sb.sb_bsize_shift);\n\t\t\tqd->qd_qb.qb_value = q.qu_value;\n\t\t}\n\t}\n\n\t/* Write the quota into the quota file on disk */\n\tptr = &q;\n\tnbytes = sizeof(struct gfs2_quota);\nget_a_page:\n\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tiblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\tif (!buffer_mapped(bh)) {\n\t\tgfs2_block_map(inode, iblock, bh, 1);\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock_out;\n\t\t/* If it's a newly allocated disk block for quota, zero it */\n\t\tif (buffer_new(bh))\n\t\t\tzero_user(page, pos - blocksize, bh->b_size);\n\t}\n\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\tll_rw_block(READ | REQ_META, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock_out;\n\t}\n\n\tgfs2_trans_add_data(ip->i_gl, bh);\n\n\tkaddr = kmap_atomic(page);\n\tif (offset + sizeof(struct gfs2_quota) > PAGE_CACHE_SIZE)\n\t\tnbytes = PAGE_CACHE_SIZE - offset;\n\tmemcpy(kaddr + offset, ptr, nbytes);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\t/* If quota straddles page boundary, we need to update the rest of the\n\t * quota at the beginning of the next page */\n\tif ((offset + sizeof(struct gfs2_quota)) > PAGE_CACHE_SIZE) {\n\t\tptr = ptr + nbytes;\n\t\tnbytes = sizeof(struct gfs2_quota) - nbytes;\n\t\toffset = 0;\n\t\tindex++;\n\t\tgoto get_a_page;\n\t}\n\n\tsize = loc + sizeof(struct gfs2_quota);\n\tif (size > inode->i_size)\n\t\ti_size_write(inode, size);\n\tinode->i_mtime = inode->i_atime = CURRENT_TIME;\n\tmark_inode_dirty(inode);\n\tset_bit(QDF_REFRESH, &qd->qd_flags);\n\treturn 0;\n\nunlock_out:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "QDF_REFRESH",
            "&qd->qd_flags"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "size"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kaddr + offset",
            "ptr",
            "nbytes"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_data",
          "args": [
            "ip->i_gl",
            "bh"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "158-193",
          "snippet": "void gfs2_trans_add_data(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = bh->b_page->mapping;\n\tstruct gfs2_inode *ip = GFS2_I(mapping->host);\n\tstruct gfs2_bufdata *bd;\n\n\tif (!gfs2_is_jdata(ip)) {\n\t\tgfs2_ordered_add_inode(ip);\n\t\treturn;\n\t}\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_databuf_lops);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\ttr->tr_touched = 1;\n\tif (list_empty(&bd->bd_list)) {\n\t\tset_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);\n\t\tset_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);\n\t\tgfs2_pin(sdp, bd->bd_bh);\n\t\ttr->tr_num_databuf_new++;\n\t\tlist_add_tail(&bd->bd_list, &tr->tr_databuf);\n\t}\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_data(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = bh->b_page->mapping;\n\tstruct gfs2_inode *ip = GFS2_I(mapping->host);\n\tstruct gfs2_bufdata *bd;\n\n\tif (!gfs2_is_jdata(ip)) {\n\t\tgfs2_ordered_add_inode(ip);\n\t\treturn;\n\t}\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_databuf_lops);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\ttr->tr_touched = 1;\n\tif (list_empty(&bd->bd_list)) {\n\t\tset_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);\n\t\tset_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);\n\t\tgfs2_pin(sdp, bd->bd_bh);\n\t\ttr->tr_num_databuf_new++;\n\t\tlist_add_tail(&bd->bd_list, &tr->tr_databuf);\n\t}\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READ | REQ_META",
            "1",
            "&bh"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "pos - blocksize",
            "bh->b_size"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "bh"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_block_map",
          "args": [
            "inode",
            "iblock",
            "bh",
            "1"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_block_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "603-677",
          "snippet": "int gfs2_block_map(struct inode *inode, sector_t lblock,\n\t\t   struct buffer_head *bh_map, int create)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int bsize = sdp->sd_sb.sb_bsize;\n\tconst size_t maxlen = bh_map->b_size >> inode->i_blkbits;\n\tconst u64 *arr = sdp->sd_heightsize;\n\t__be64 *ptr;\n\tu64 size;\n\tstruct metapath mp;\n\tint ret;\n\tint eob;\n\tunsigned int len;\n\tstruct buffer_head *bh;\n\tu8 height;\n\n\tBUG_ON(maxlen == 0);\n\n\tmemset(mp.mp_bh, 0, sizeof(mp.mp_bh));\n\tbmap_lock(ip, create);\n\tclear_buffer_mapped(bh_map);\n\tclear_buffer_new(bh_map);\n\tclear_buffer_boundary(bh_map);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, 1);\n\tif (gfs2_is_dir(ip)) {\n\t\tbsize = sdp->sd_jbsize;\n\t\tarr = sdp->sd_jheightsize;\n\t}\n\n\tret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);\n\tif (ret)\n\t\tgoto out;\n\n\theight = ip->i_height;\n\tsize = (lblock + 1) * bsize;\n\twhile (size > arr[height])\n\t\theight++;\n\tfind_metapath(sdp, lblock, &mp, height);\n\tret = 1;\n\tif (height > ip->i_height || gfs2_is_stuffed(ip))\n\t\tgoto do_alloc;\n\tret = lookup_metapath(ip, &mp);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret != ip->i_height)\n\t\tgoto do_alloc;\n\tptr = metapointer(ip->i_height - 1, &mp);\n\tif (*ptr == 0)\n\t\tgoto do_alloc;\n\tmap_bh(bh_map, inode->i_sb, be64_to_cpu(*ptr));\n\tbh = mp.mp_bh[ip->i_height - 1];\n\tlen = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen, &eob);\n\tbh_map->b_size = (len << inode->i_blkbits);\n\tif (eob)\n\t\tset_buffer_boundary(bh_map);\n\tret = 0;\nout:\n\trelease_metapath(&mp);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, ret);\n\tbmap_unlock(ip, create);\n\treturn ret;\n\ndo_alloc:\n\t/* All allocations are done here, firstly check create flag */\n\tif (!create) {\n\t\tBUG_ON(gfs2_is_stuffed(ip));\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* At this point ret is the tree depth of already allocated blocks */\n\tret = gfs2_bmap_alloc(inode, lblock, bh_map, &mp, ret, height, maxlen);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_block_map(struct inode *inode, sector_t lblock,\n\t\t   struct buffer_head *bh_map, int create)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int bsize = sdp->sd_sb.sb_bsize;\n\tconst size_t maxlen = bh_map->b_size >> inode->i_blkbits;\n\tconst u64 *arr = sdp->sd_heightsize;\n\t__be64 *ptr;\n\tu64 size;\n\tstruct metapath mp;\n\tint ret;\n\tint eob;\n\tunsigned int len;\n\tstruct buffer_head *bh;\n\tu8 height;\n\n\tBUG_ON(maxlen == 0);\n\n\tmemset(mp.mp_bh, 0, sizeof(mp.mp_bh));\n\tbmap_lock(ip, create);\n\tclear_buffer_mapped(bh_map);\n\tclear_buffer_new(bh_map);\n\tclear_buffer_boundary(bh_map);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, 1);\n\tif (gfs2_is_dir(ip)) {\n\t\tbsize = sdp->sd_jbsize;\n\t\tarr = sdp->sd_jheightsize;\n\t}\n\n\tret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);\n\tif (ret)\n\t\tgoto out;\n\n\theight = ip->i_height;\n\tsize = (lblock + 1) * bsize;\n\twhile (size > arr[height])\n\t\theight++;\n\tfind_metapath(sdp, lblock, &mp, height);\n\tret = 1;\n\tif (height > ip->i_height || gfs2_is_stuffed(ip))\n\t\tgoto do_alloc;\n\tret = lookup_metapath(ip, &mp);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret != ip->i_height)\n\t\tgoto do_alloc;\n\tptr = metapointer(ip->i_height - 1, &mp);\n\tif (*ptr == 0)\n\t\tgoto do_alloc;\n\tmap_bh(bh_map, inode->i_sb, be64_to_cpu(*ptr));\n\tbh = mp.mp_bh[ip->i_height - 1];\n\tlen = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen, &eob);\n\tbh_map->b_size = (len << inode->i_blkbits);\n\tif (eob)\n\t\tset_buffer_boundary(bh_map);\n\tret = 0;\nout:\n\trelease_metapath(&mp);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, ret);\n\tbmap_unlock(ip, create);\n\treturn ret;\n\ndo_alloc:\n\t/* All allocations are done here, firstly check create flag */\n\tif (!create) {\n\t\tBUG_ON(gfs2_is_stuffed(ip));\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* At this point ret is the tree depth of already allocated blocks */\n\tret = gfs2_bmap_alloc(inode, lblock, bh_map, &mp, ret, height, maxlen);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_empty_buffers",
          "args": [
            "page",
            "blocksize",
            "0"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1564-1591",
          "snippet": "void create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "mapping",
            "index",
            "GFP_NOFS"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "fdq->d_space >> sdp->sd_sb.sb_bsize_shift"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "fdq->d_spc_hardlimit >> sdp->sd_sb.sb_bsize_shift"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "fdq->d_spc_softlimit >> sdp->sd_sb.sb_bsize_shift"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_add_cpu",
          "args": [
            "&q.qu_value",
            "change"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_internal_read",
          "args": [
            "ip",
            "(char *)&q",
            "&loc",
            "sizeof(q)"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_internal_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
          "lines": "559-587",
          "snippet": "int gfs2_internal_read(struct gfs2_inode *ip, char *buf, loff_t *pos,\n                       unsigned size)\n{\n\tstruct address_space *mapping = ip->i_inode.i_mapping;\n\tunsigned long index = *pos / PAGE_CACHE_SIZE;\n\tunsigned offset = *pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned copied = 0;\n\tunsigned amt;\n\tstruct page *page;\n\tvoid *p;\n\n\tdo {\n\t\tamt = size - copied;\n\t\tif (offset + size > PAGE_CACHE_SIZE)\n\t\t\tamt = PAGE_CACHE_SIZE - offset;\n\t\tpage = read_cache_page(mapping, index, __gfs2_readpage, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tp = kmap_atomic(page);\n\t\tmemcpy(buf + copied, p + offset, amt);\n\t\tkunmap_atomic(p);\n\t\tpage_cache_release(page);\n\t\tcopied += amt;\n\t\tindex++;\n\t\toffset = 0;\n\t} while(copied < size);\n\t(*pos) += size;\n\treturn size;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"trans.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fs.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_internal_read(struct gfs2_inode *ip, char *buf, loff_t *pos,\n                       unsigned size)\n{\n\tstruct address_space *mapping = ip->i_inode.i_mapping;\n\tunsigned long index = *pos / PAGE_CACHE_SIZE;\n\tunsigned offset = *pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned copied = 0;\n\tunsigned amt;\n\tstruct page *page;\n\tvoid *p;\n\n\tdo {\n\t\tamt = size - copied;\n\t\tif (offset + size > PAGE_CACHE_SIZE)\n\t\t\tamt = PAGE_CACHE_SIZE - offset;\n\t\tpage = read_cache_page(mapping, index, __gfs2_readpage, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tp = kmap_atomic(page);\n\t\tmemcpy(buf + copied, p + offset, amt);\n\t\tkunmap_atomic(p);\n\t\tpage_cache_release(page);\n\t\tcopied += amt;\n\t\tindex++;\n\t\toffset = 0;\n\t} while(copied < size);\n\t(*pos) += size;\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&q",
            "0",
            "sizeof(struct gfs2_quota)"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_unstuff_dinode",
          "args": [
            "ip",
            "NULL"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_unstuff_dinode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "118-175",
          "snippet": "int gfs2_unstuff_dinode(struct gfs2_inode *ip, struct page *page)\n{\n\tstruct buffer_head *bh, *dibh;\n\tstruct gfs2_dinode *di;\n\tu64 block = 0;\n\tint isdir = gfs2_is_dir(ip);\n\tint error;\n\n\tdown_write(&ip->i_rw_mutex);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t/* Get a free block, fill it with the stuffed data,\n\t\t   and write it out to disk */\n\n\t\tunsigned int n = 1;\n\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\tif (error)\n\t\t\tgoto out_brelse;\n\t\tif (isdir) {\n\t\t\tgfs2_trans_add_unrevoke(GFS2_SB(&ip->i_inode), block, 1);\n\t\t\terror = gfs2_dir_get_new_buffer(ip, block, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t\tgfs2_buffer_copy_tail(bh, sizeof(struct gfs2_meta_header),\n\t\t\t\t\t      dibh, sizeof(struct gfs2_dinode));\n\t\t\tbrelse(bh);\n\t\t} else {\n\t\t\terror = gfs2_unstuffer_page(ip, dibh, block, page);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t}\n\t}\n\n\t/*  Set up the pointer to the new block  */\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tdi = (struct gfs2_dinode *)dibh->b_data;\n\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t*(__be64 *)(di + 1) = cpu_to_be64(block);\n\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\t\tdi->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\t}\n\n\tip->i_height = 1;\n\tdi->di_height = cpu_to_be16(1);\n\nout_brelse:\n\tbrelse(dibh);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_unstuff_dinode(struct gfs2_inode *ip, struct page *page)\n{\n\tstruct buffer_head *bh, *dibh;\n\tstruct gfs2_dinode *di;\n\tu64 block = 0;\n\tint isdir = gfs2_is_dir(ip);\n\tint error;\n\n\tdown_write(&ip->i_rw_mutex);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t/* Get a free block, fill it with the stuffed data,\n\t\t   and write it out to disk */\n\n\t\tunsigned int n = 1;\n\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\tif (error)\n\t\t\tgoto out_brelse;\n\t\tif (isdir) {\n\t\t\tgfs2_trans_add_unrevoke(GFS2_SB(&ip->i_inode), block, 1);\n\t\t\terror = gfs2_dir_get_new_buffer(ip, block, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t\tgfs2_buffer_copy_tail(bh, sizeof(struct gfs2_meta_header),\n\t\t\t\t\t      dibh, sizeof(struct gfs2_dinode));\n\t\t\tbrelse(bh);\n\t\t} else {\n\t\t\terror = gfs2_unstuffer_page(ip, dibh, block, page);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t}\n\t}\n\n\t/*  Set up the pointer to the new block  */\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tdi = (struct gfs2_dinode *)dibh->b_data;\n\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t*(__be64 *)(di + 1) = cpu_to_be64(block);\n\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\t\tdi->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\t}\n\n\tip->i_height = 1;\n\tdi->di_height = cpu_to_be16(1);\n\nout_brelse:\n\tbrelse(dibh);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_stuffed",
          "args": [
            "ip"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_stuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "23-26",
          "snippet": "static inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_adjust_quota(struct gfs2_inode *ip, loff_t loc,\n\t\t\t     s64 change, struct gfs2_quota_data *qd,\n\t\t\t     struct qc_dqblk *fdq)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned long index = loc >> PAGE_CACHE_SHIFT;\n\tunsigned offset = loc & (PAGE_CACHE_SIZE - 1);\n\tunsigned blocksize, iblock, pos;\n\tstruct buffer_head *bh;\n\tstruct page *page;\n\tvoid *kaddr, *ptr;\n\tstruct gfs2_quota q;\n\tint err, nbytes;\n\tu64 size;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terr = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmemset(&q, 0, sizeof(struct gfs2_quota));\n\terr = gfs2_internal_read(ip, (char *)&q, &loc, sizeof(q));\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EIO;\n\tbe64_add_cpu(&q.qu_value, change);\n\tqd->qd_qb.qb_value = q.qu_value;\n\tif (fdq) {\n\t\tif (fdq->d_fieldmask & QC_SPC_SOFT) {\n\t\t\tq.qu_warn = cpu_to_be64(fdq->d_spc_softlimit >> sdp->sd_sb.sb_bsize_shift);\n\t\t\tqd->qd_qb.qb_warn = q.qu_warn;\n\t\t}\n\t\tif (fdq->d_fieldmask & QC_SPC_HARD) {\n\t\t\tq.qu_limit = cpu_to_be64(fdq->d_spc_hardlimit >> sdp->sd_sb.sb_bsize_shift);\n\t\t\tqd->qd_qb.qb_limit = q.qu_limit;\n\t\t}\n\t\tif (fdq->d_fieldmask & QC_SPACE) {\n\t\t\tq.qu_value = cpu_to_be64(fdq->d_space >> sdp->sd_sb.sb_bsize_shift);\n\t\t\tqd->qd_qb.qb_value = q.qu_value;\n\t\t}\n\t}\n\n\t/* Write the quota into the quota file on disk */\n\tptr = &q;\n\tnbytes = sizeof(struct gfs2_quota);\nget_a_page:\n\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tiblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\tif (!buffer_mapped(bh)) {\n\t\tgfs2_block_map(inode, iblock, bh, 1);\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock_out;\n\t\t/* If it's a newly allocated disk block for quota, zero it */\n\t\tif (buffer_new(bh))\n\t\t\tzero_user(page, pos - blocksize, bh->b_size);\n\t}\n\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\tll_rw_block(READ | REQ_META, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock_out;\n\t}\n\n\tgfs2_trans_add_data(ip->i_gl, bh);\n\n\tkaddr = kmap_atomic(page);\n\tif (offset + sizeof(struct gfs2_quota) > PAGE_CACHE_SIZE)\n\t\tnbytes = PAGE_CACHE_SIZE - offset;\n\tmemcpy(kaddr + offset, ptr, nbytes);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\t/* If quota straddles page boundary, we need to update the rest of the\n\t * quota at the beginning of the next page */\n\tif ((offset + sizeof(struct gfs2_quota)) > PAGE_CACHE_SIZE) {\n\t\tptr = ptr + nbytes;\n\t\tnbytes = sizeof(struct gfs2_quota) - nbytes;\n\t\toffset = 0;\n\t\tindex++;\n\t\tgoto get_a_page;\n\t}\n\n\tsize = loc + sizeof(struct gfs2_quota);\n\tif (size > inode->i_size)\n\t\ti_size_write(inode, size);\n\tinode->i_mtime = inode->i_atime = CURRENT_TIME;\n\tmark_inode_dirty(inode);\n\tset_bit(QDF_REFRESH, &qd->qd_flags);\n\treturn 0;\n\nunlock_out:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}"
  },
  {
    "function_name": "do_qc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "615-653",
    "snippet": "static void do_qc(struct gfs2_quota_data *qd, s64 change)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_qc_inode);\n\tstruct gfs2_quota_change *qc = qd->qd_bh_qc;\n\ts64 x;\n\n\tmutex_lock(&sdp->sd_quota_mutex);\n\tgfs2_trans_add_meta(ip->i_gl, qd->qd_bh);\n\n\tif (!test_bit(QDF_CHANGE, &qd->qd_flags)) {\n\t\tqc->qc_change = 0;\n\t\tqc->qc_flags = 0;\n\t\tif (qd->qd_id.type == USRQUOTA)\n\t\t\tqc->qc_flags = cpu_to_be32(GFS2_QCF_USER);\n\t\tqc->qc_id = cpu_to_be32(from_kqid(&init_user_ns, qd->qd_id));\n\t}\n\n\tx = be64_to_cpu(qc->qc_change) + change;\n\tqc->qc_change = cpu_to_be64(x);\n\n\tspin_lock(&qd_lock);\n\tqd->qd_change = x;\n\tspin_unlock(&qd_lock);\n\n\tif (!x) {\n\t\tgfs2_assert_warn(sdp, test_bit(QDF_CHANGE, &qd->qd_flags));\n\t\tclear_bit(QDF_CHANGE, &qd->qd_flags);\n\t\tqc->qc_flags = 0;\n\t\tqc->qc_id = 0;\n\t\tslot_put(qd);\n\t\tqd_put(qd);\n\t} else if (!test_and_set_bit(QDF_CHANGE, &qd->qd_flags)) {\n\t\tqd_hold(qd);\n\t\tslot_hold(qd);\n\t}\n\n\tmutex_unlock(&sdp->sd_quota_mutex);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(qd_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sdp->sd_quota_mutex"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot_hold",
          "args": [
            "qd"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "slot_hold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "345-353",
          "snippet": "static void slot_hold(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tgfs2_assert(sdp, qd->qd_slot_count);\n\tqd->qd_slot_count++;\n\tspin_unlock(&sdp->sd_bitmap_lock);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void slot_hold(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tgfs2_assert(sdp, qd->qd_slot_count);\n\tqd->qd_slot_count++;\n\tspin_unlock(&sdp->sd_bitmap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qd_hold",
          "args": [
            "qd"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "qd_hold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "303-308",
          "snippet": "static void qd_hold(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tgfs2_assert(sdp, !__lockref_is_dead(&qd->qd_lockref));\n\tlockref_get(&qd->qd_lockref);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void qd_hold(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tgfs2_assert(sdp, !__lockref_is_dead(&qd->qd_lockref));\n\tlockref_get(&qd->qd_lockref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "QDF_CHANGE",
            "&qd->qd_flags"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qd_put",
          "args": [
            "qd"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "qd_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "310-319",
          "snippet": "static void qd_put(struct gfs2_quota_data *qd)\n{\n\tif (lockref_put_or_lock(&qd->qd_lockref))\n\t\treturn;\n\n\tqd->qd_lockref.count = 0;\n\tlist_lru_add(&gfs2_qd_lru, &qd->qd_lru);\n\tspin_unlock(&qd->qd_lockref.lock);\n\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_lru gfs2_qd_lru;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct list_lru gfs2_qd_lru;\n\nstatic void qd_put(struct gfs2_quota_data *qd)\n{\n\tif (lockref_put_or_lock(&qd->qd_lockref))\n\t\treturn;\n\n\tqd->qd_lockref.count = 0;\n\tlist_lru_add(&gfs2_qd_lru, &qd->qd_lru);\n\tspin_unlock(&qd->qd_lockref.lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "slot_put",
          "args": [
            "qd"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "slot_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "355-366",
          "snippet": "static void slot_put(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tgfs2_assert(sdp, qd->qd_slot_count);\n\tif (!--qd->qd_slot_count) {\n\t\tBUG_ON(!test_and_clear_bit(qd->qd_slot, sdp->sd_quota_bitmap));\n\t\tqd->qd_slot = -1;\n\t}\n\tspin_unlock(&sdp->sd_bitmap_lock);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void slot_put(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tgfs2_assert(sdp, qd->qd_slot_count);\n\tif (!--qd->qd_slot_count) {\n\t\tBUG_ON(!test_and_clear_bit(qd->qd_slot, sdp->sd_quota_bitmap));\n\t\tqd->qd_slot = -1;\n\t}\n\tspin_unlock(&sdp->sd_bitmap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "QDF_CHANGE",
            "&qd->qd_flags"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_assert_warn",
          "args": [
            "sdp",
            "test_bit(QDF_CHANGE, &qd->qd_flags)"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "QDF_CHANGE",
            "&qd->qd_flags"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&qd_lock"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&qd_lock"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "x"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "qc->qc_change"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from_kqid(&init_user_ns, qd->qd_id)"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kqid",
          "args": [
            "&init_user_ns",
            "qd->qd_id"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "from_kqid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/kqid.c",
          "lines": "100-112",
          "snippet": "qid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/quota.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/quota.h>\n#include <linux/fs.h>\n\nqid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "GFS2_QCF_USER"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "qd->qd_bh"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sdp->sd_quota_mutex"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "sdp->sd_qc_inode"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\n\nstatic void do_qc(struct gfs2_quota_data *qd, s64 change)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_qc_inode);\n\tstruct gfs2_quota_change *qc = qd->qd_bh_qc;\n\ts64 x;\n\n\tmutex_lock(&sdp->sd_quota_mutex);\n\tgfs2_trans_add_meta(ip->i_gl, qd->qd_bh);\n\n\tif (!test_bit(QDF_CHANGE, &qd->qd_flags)) {\n\t\tqc->qc_change = 0;\n\t\tqc->qc_flags = 0;\n\t\tif (qd->qd_id.type == USRQUOTA)\n\t\t\tqc->qc_flags = cpu_to_be32(GFS2_QCF_USER);\n\t\tqc->qc_id = cpu_to_be32(from_kqid(&init_user_ns, qd->qd_id));\n\t}\n\n\tx = be64_to_cpu(qc->qc_change) + change;\n\tqc->qc_change = cpu_to_be64(x);\n\n\tspin_lock(&qd_lock);\n\tqd->qd_change = x;\n\tspin_unlock(&qd_lock);\n\n\tif (!x) {\n\t\tgfs2_assert_warn(sdp, test_bit(QDF_CHANGE, &qd->qd_flags));\n\t\tclear_bit(QDF_CHANGE, &qd->qd_flags);\n\t\tqc->qc_flags = 0;\n\t\tqc->qc_id = 0;\n\t\tslot_put(qd);\n\t\tqd_put(qd);\n\t} else if (!test_and_set_bit(QDF_CHANGE, &qd->qd_flags)) {\n\t\tqd_hold(qd);\n\t\tslot_hold(qd);\n\t}\n\n\tmutex_unlock(&sdp->sd_quota_mutex);\n}"
  },
  {
    "function_name": "sort_qd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "603-613",
    "snippet": "static int sort_qd(const void *a, const void *b)\n{\n\tconst struct gfs2_quota_data *qd_a = *(const struct gfs2_quota_data **)a;\n\tconst struct gfs2_quota_data *qd_b = *(const struct gfs2_quota_data **)b;\n\n\tif (qid_lt(qd_a->qd_id, qd_b->qd_id))\n\t\treturn -1;\n\tif (qid_lt(qd_b->qd_id, qd_a->qd_id))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qid_lt",
          "args": [
            "qd_b->qd_id",
            "qd_a->qd_id"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "qid_lt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/kqid.c",
          "lines": "36-52",
          "snippet": "bool qid_lt(struct kqid left, struct kqid right)\n{\n\tif (left.type < right.type)\n\t\treturn true;\n\tif (left.type > right.type)\n\t\treturn false;\n\tswitch (left.type) {\n\tcase USRQUOTA:\n\t\treturn uid_lt(left.uid, right.uid);\n\tcase GRPQUOTA:\n\t\treturn gid_lt(left.gid, right.gid);\n\tcase PRJQUOTA:\n\t\treturn projid_lt(left.projid, right.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/quota.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/quota.h>\n#include <linux/fs.h>\n\nbool qid_lt(struct kqid left, struct kqid right)\n{\n\tif (left.type < right.type)\n\t\treturn true;\n\tif (left.type > right.type)\n\t\treturn false;\n\tswitch (left.type) {\n\tcase USRQUOTA:\n\t\treturn uid_lt(left.uid, right.uid);\n\tcase GRPQUOTA:\n\t\treturn gid_lt(left.gid, right.gid);\n\tcase PRJQUOTA:\n\t\treturn projid_lt(left.projid, right.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int sort_qd(const void *a, const void *b)\n{\n\tconst struct gfs2_quota_data *qd_a = *(const struct gfs2_quota_data **)a;\n\tconst struct gfs2_quota_data *qd_b = *(const struct gfs2_quota_data **)b;\n\n\tif (qid_lt(qd_a->qd_id, qd_b->qd_id))\n\t\treturn -1;\n\tif (qid_lt(qd_b->qd_id, qd_a->qd_id))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_quota_unhold",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "587-601",
    "snippet": "void gfs2_quota_unhold(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int x;\n\n\tif (ip->i_res == NULL)\n\t\treturn;\n\tgfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags));\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqdsb_put(ip->i_res->rs_qa_qd[x]);\n\t\tip->i_res->rs_qa_qd[x] = NULL;\n\t}\n\tip->i_res->rs_qa_qd_num = 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qdsb_put",
          "args": [
            "ip->i_res->rs_qa_qd[x]"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "qdsb_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "523-528",
          "snippet": "static void qdsb_put(struct gfs2_quota_data *qd)\n{\n\tbh_put(qd);\n\tslot_put(qd);\n\tqd_put(qd);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void qdsb_put(struct gfs2_quota_data *qd)\n{\n\tbh_put(qd);\n\tslot_put(qd);\n\tqd_put(qd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_assert_warn",
          "args": [
            "sdp",
            "!test_bit(GIF_QD_LOCKED, &ip->i_flags)"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "GIF_QD_LOCKED",
            "&ip->i_flags"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_quota_unhold(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int x;\n\n\tif (ip->i_res == NULL)\n\t\treturn;\n\tgfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags));\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqdsb_put(ip->i_res->rs_qa_qd[x]);\n\t\tip->i_res->rs_qa_qd[x] = NULL;\n\t}\n\tip->i_res->rs_qa_qd_num = 0;\n}"
  },
  {
    "function_name": "gfs2_quota_hold",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "530-585",
    "snippet": "int gfs2_quota_hold(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data **qd;\n\tint error;\n\n\tif (ip->i_res == NULL) {\n\t\terror = gfs2_rs_alloc(ip);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tqd = ip->i_res->rs_qa_qd;\n\n\tif (gfs2_assert_warn(sdp, !ip->i_res->rs_qa_qd_num) ||\n\t    gfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags)))\n\t\treturn -EIO;\n\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\n\terror = qdsb_get(sdp, make_kqid_uid(ip->i_inode.i_uid), qd);\n\tif (error)\n\t\tgoto out;\n\tip->i_res->rs_qa_qd_num++;\n\tqd++;\n\n\terror = qdsb_get(sdp, make_kqid_gid(ip->i_inode.i_gid), qd);\n\tif (error)\n\t\tgoto out;\n\tip->i_res->rs_qa_qd_num++;\n\tqd++;\n\n\tif (!uid_eq(uid, NO_UID_QUOTA_CHANGE) &&\n\t    !uid_eq(uid, ip->i_inode.i_uid)) {\n\t\terror = qdsb_get(sdp, make_kqid_uid(uid), qd);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tip->i_res->rs_qa_qd_num++;\n\t\tqd++;\n\t}\n\n\tif (!gid_eq(gid, NO_GID_QUOTA_CHANGE) &&\n\t    !gid_eq(gid, ip->i_inode.i_gid)) {\n\t\terror = qdsb_get(sdp, make_kqid_gid(gid), qd);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tip->i_res->rs_qa_qd_num++;\n\t\tqd++;\n\t}\n\nout:\n\tif (error)\n\t\tgfs2_quota_unhold(ip);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_quota_unhold",
          "args": [
            "ip"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_unhold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "587-601",
          "snippet": "void gfs2_quota_unhold(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int x;\n\n\tif (ip->i_res == NULL)\n\t\treturn;\n\tgfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags));\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqdsb_put(ip->i_res->rs_qa_qd[x]);\n\t\tip->i_res->rs_qa_qd[x] = NULL;\n\t}\n\tip->i_res->rs_qa_qd_num = 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_quota_unhold(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int x;\n\n\tif (ip->i_res == NULL)\n\t\treturn;\n\tgfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags));\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqdsb_put(ip->i_res->rs_qa_qd[x]);\n\t\tip->i_res->rs_qa_qd[x] = NULL;\n\t}\n\tip->i_res->rs_qa_qd_num = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qdsb_get",
          "args": [
            "sdp",
            "make_kqid_gid(gid)",
            "qd"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "qdsb_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "497-521",
          "snippet": "static int qdsb_get(struct gfs2_sbd *sdp, struct kqid qid,\n\t\t    struct gfs2_quota_data **qdp)\n{\n\tint error;\n\n\terror = qd_get(sdp, qid, qdp);\n\tif (error)\n\t\treturn error;\n\n\terror = slot_get(*qdp);\n\tif (error)\n\t\tgoto fail;\n\n\terror = bh_get(*qdp);\n\tif (error)\n\t\tgoto fail_slot;\n\n\treturn 0;\n\nfail_slot:\n\tslot_put(*qdp);\nfail:\n\tqd_put(*qdp);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int qdsb_get(struct gfs2_sbd *sdp, struct kqid qid,\n\t\t    struct gfs2_quota_data **qdp)\n{\n\tint error;\n\n\terror = qd_get(sdp, qid, qdp);\n\tif (error)\n\t\treturn error;\n\n\terror = slot_get(*qdp);\n\tif (error)\n\t\tgoto fail;\n\n\terror = bh_get(*qdp);\n\tif (error)\n\t\tgoto fail_slot;\n\n\treturn 0;\n\nfail_slot:\n\tslot_put(*qdp);\nfail:\n\tqd_put(*qdp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kqid_gid",
          "args": [
            "gid"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "gid",
            "ip->i_inode.i_gid"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "gid",
            "NO_GID_QUOTA_CHANGE"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kqid_uid",
          "args": [
            "uid"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "uid",
            "ip->i_inode.i_uid"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kqid_gid",
          "args": [
            "ip->i_inode.i_gid"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kqid_uid",
          "args": [
            "ip->i_inode.i_uid"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_assert_warn",
          "args": [
            "sdp",
            "!test_bit(GIF_QD_LOCKED, &ip->i_flags)"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "GIF_QD_LOCKED",
            "&ip->i_flags"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_assert_warn",
          "args": [
            "sdp",
            "!ip->i_res->rs_qa_qd_num"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_rs_alloc",
          "args": [
            "ip"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "602-620",
          "snippet": "int gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_quota_hold(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data **qd;\n\tint error;\n\n\tif (ip->i_res == NULL) {\n\t\terror = gfs2_rs_alloc(ip);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tqd = ip->i_res->rs_qa_qd;\n\n\tif (gfs2_assert_warn(sdp, !ip->i_res->rs_qa_qd_num) ||\n\t    gfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags)))\n\t\treturn -EIO;\n\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\n\terror = qdsb_get(sdp, make_kqid_uid(ip->i_inode.i_uid), qd);\n\tif (error)\n\t\tgoto out;\n\tip->i_res->rs_qa_qd_num++;\n\tqd++;\n\n\terror = qdsb_get(sdp, make_kqid_gid(ip->i_inode.i_gid), qd);\n\tif (error)\n\t\tgoto out;\n\tip->i_res->rs_qa_qd_num++;\n\tqd++;\n\n\tif (!uid_eq(uid, NO_UID_QUOTA_CHANGE) &&\n\t    !uid_eq(uid, ip->i_inode.i_uid)) {\n\t\terror = qdsb_get(sdp, make_kqid_uid(uid), qd);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tip->i_res->rs_qa_qd_num++;\n\t\tqd++;\n\t}\n\n\tif (!gid_eq(gid, NO_GID_QUOTA_CHANGE) &&\n\t    !gid_eq(gid, ip->i_inode.i_gid)) {\n\t\terror = qdsb_get(sdp, make_kqid_gid(gid), qd);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tip->i_res->rs_qa_qd_num++;\n\t\tqd++;\n\t}\n\nout:\n\tif (error)\n\t\tgfs2_quota_unhold(ip);\n\treturn error;\n}"
  },
  {
    "function_name": "qdsb_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "523-528",
    "snippet": "static void qdsb_put(struct gfs2_quota_data *qd)\n{\n\tbh_put(qd);\n\tslot_put(qd);\n\tqd_put(qd);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qd_put",
          "args": [
            "qd"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "qd_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "310-319",
          "snippet": "static void qd_put(struct gfs2_quota_data *qd)\n{\n\tif (lockref_put_or_lock(&qd->qd_lockref))\n\t\treturn;\n\n\tqd->qd_lockref.count = 0;\n\tlist_lru_add(&gfs2_qd_lru, &qd->qd_lru);\n\tspin_unlock(&qd->qd_lockref.lock);\n\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_lru gfs2_qd_lru;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct list_lru gfs2_qd_lru;\n\nstatic void qd_put(struct gfs2_quota_data *qd)\n{\n\tif (lockref_put_or_lock(&qd->qd_lockref))\n\t\treturn;\n\n\tqd->qd_lockref.count = 0;\n\tlist_lru_add(&gfs2_qd_lru, &qd->qd_lru);\n\tspin_unlock(&qd->qd_lockref.lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "slot_put",
          "args": [
            "qd"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "slot_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "355-366",
          "snippet": "static void slot_put(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tgfs2_assert(sdp, qd->qd_slot_count);\n\tif (!--qd->qd_slot_count) {\n\t\tBUG_ON(!test_and_clear_bit(qd->qd_slot, sdp->sd_quota_bitmap));\n\t\tqd->qd_slot = -1;\n\t}\n\tspin_unlock(&sdp->sd_bitmap_lock);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void slot_put(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tgfs2_assert(sdp, qd->qd_slot_count);\n\tif (!--qd->qd_slot_count) {\n\t\tBUG_ON(!test_and_clear_bit(qd->qd_slot, sdp->sd_quota_bitmap));\n\t\tqd->qd_slot = -1;\n\t}\n\tspin_unlock(&sdp->sd_bitmap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bh_put",
          "args": [
            "qd"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "bh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "415-427",
          "snippet": "static void bh_put(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\n\tmutex_lock(&sdp->sd_quota_mutex);\n\tgfs2_assert(sdp, qd->qd_bh_count);\n\tif (!--qd->qd_bh_count) {\n\t\tbrelse(qd->qd_bh);\n\t\tqd->qd_bh = NULL;\n\t\tqd->qd_bh_qc = NULL;\n\t}\n\tmutex_unlock(&sdp->sd_quota_mutex);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void bh_put(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\n\tmutex_lock(&sdp->sd_quota_mutex);\n\tgfs2_assert(sdp, qd->qd_bh_count);\n\tif (!--qd->qd_bh_count) {\n\t\tbrelse(qd->qd_bh);\n\t\tqd->qd_bh = NULL;\n\t\tqd->qd_bh_qc = NULL;\n\t}\n\tmutex_unlock(&sdp->sd_quota_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void qdsb_put(struct gfs2_quota_data *qd)\n{\n\tbh_put(qd);\n\tslot_put(qd);\n\tqd_put(qd);\n}"
  },
  {
    "function_name": "qdsb_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "497-521",
    "snippet": "static int qdsb_get(struct gfs2_sbd *sdp, struct kqid qid,\n\t\t    struct gfs2_quota_data **qdp)\n{\n\tint error;\n\n\terror = qd_get(sdp, qid, qdp);\n\tif (error)\n\t\treturn error;\n\n\terror = slot_get(*qdp);\n\tif (error)\n\t\tgoto fail;\n\n\terror = bh_get(*qdp);\n\tif (error)\n\t\tgoto fail_slot;\n\n\treturn 0;\n\nfail_slot:\n\tslot_put(*qdp);\nfail:\n\tqd_put(*qdp);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qd_put",
          "args": [
            "*qdp"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "qd_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "310-319",
          "snippet": "static void qd_put(struct gfs2_quota_data *qd)\n{\n\tif (lockref_put_or_lock(&qd->qd_lockref))\n\t\treturn;\n\n\tqd->qd_lockref.count = 0;\n\tlist_lru_add(&gfs2_qd_lru, &qd->qd_lru);\n\tspin_unlock(&qd->qd_lockref.lock);\n\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_lru gfs2_qd_lru;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct list_lru gfs2_qd_lru;\n\nstatic void qd_put(struct gfs2_quota_data *qd)\n{\n\tif (lockref_put_or_lock(&qd->qd_lockref))\n\t\treturn;\n\n\tqd->qd_lockref.count = 0;\n\tlist_lru_add(&gfs2_qd_lru, &qd->qd_lru);\n\tspin_unlock(&qd->qd_lockref.lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "slot_put",
          "args": [
            "*qdp"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "slot_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "355-366",
          "snippet": "static void slot_put(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tgfs2_assert(sdp, qd->qd_slot_count);\n\tif (!--qd->qd_slot_count) {\n\t\tBUG_ON(!test_and_clear_bit(qd->qd_slot, sdp->sd_quota_bitmap));\n\t\tqd->qd_slot = -1;\n\t}\n\tspin_unlock(&sdp->sd_bitmap_lock);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void slot_put(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tgfs2_assert(sdp, qd->qd_slot_count);\n\tif (!--qd->qd_slot_count) {\n\t\tBUG_ON(!test_and_clear_bit(qd->qd_slot, sdp->sd_quota_bitmap));\n\t\tqd->qd_slot = -1;\n\t}\n\tspin_unlock(&sdp->sd_bitmap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bh_get",
          "args": [
            "*qdp"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "bh_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "368-413",
          "snippet": "static int bh_get(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_qc_inode);\n\tunsigned int block, offset;\n\tstruct buffer_head *bh;\n\tint error;\n\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n\n\tmutex_lock(&sdp->sd_quota_mutex);\n\n\tif (qd->qd_bh_count++) {\n\t\tmutex_unlock(&sdp->sd_quota_mutex);\n\t\treturn 0;\n\t}\n\n\tblock = qd->qd_slot / sdp->sd_qc_per_block;\n\toffset = qd->qd_slot % sdp->sd_qc_per_block;\n\n\tbh_map.b_size = 1 << ip->i_inode.i_blkbits;\n\terror = gfs2_block_map(&ip->i_inode, block, &bh_map, 0);\n\tif (error)\n\t\tgoto fail;\n\terror = gfs2_meta_read(ip->i_gl, bh_map.b_blocknr, DIO_WAIT, &bh);\n\tif (error)\n\t\tgoto fail;\n\terror = -EIO;\n\tif (gfs2_metatype_check(sdp, bh, GFS2_METATYPE_QC))\n\t\tgoto fail_brelse;\n\n\tqd->qd_bh = bh;\n\tqd->qd_bh_qc = (struct gfs2_quota_change *)\n\t\t(bh->b_data + sizeof(struct gfs2_meta_header) +\n\t\t offset * sizeof(struct gfs2_quota_change));\n\n\tmutex_unlock(&sdp->sd_quota_mutex);\n\n\treturn 0;\n\nfail_brelse:\n\tbrelse(bh);\nfail:\n\tqd->qd_bh_count--;\n\tmutex_unlock(&sdp->sd_quota_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int bh_get(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_qc_inode);\n\tunsigned int block, offset;\n\tstruct buffer_head *bh;\n\tint error;\n\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n\n\tmutex_lock(&sdp->sd_quota_mutex);\n\n\tif (qd->qd_bh_count++) {\n\t\tmutex_unlock(&sdp->sd_quota_mutex);\n\t\treturn 0;\n\t}\n\n\tblock = qd->qd_slot / sdp->sd_qc_per_block;\n\toffset = qd->qd_slot % sdp->sd_qc_per_block;\n\n\tbh_map.b_size = 1 << ip->i_inode.i_blkbits;\n\terror = gfs2_block_map(&ip->i_inode, block, &bh_map, 0);\n\tif (error)\n\t\tgoto fail;\n\terror = gfs2_meta_read(ip->i_gl, bh_map.b_blocknr, DIO_WAIT, &bh);\n\tif (error)\n\t\tgoto fail;\n\terror = -EIO;\n\tif (gfs2_metatype_check(sdp, bh, GFS2_METATYPE_QC))\n\t\tgoto fail_brelse;\n\n\tqd->qd_bh = bh;\n\tqd->qd_bh_qc = (struct gfs2_quota_change *)\n\t\t(bh->b_data + sizeof(struct gfs2_meta_header) +\n\t\t offset * sizeof(struct gfs2_quota_change));\n\n\tmutex_unlock(&sdp->sd_quota_mutex);\n\n\treturn 0;\n\nfail_brelse:\n\tbrelse(bh);\nfail:\n\tqd->qd_bh_count--;\n\tmutex_unlock(&sdp->sd_quota_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slot_get",
          "args": [
            "*qdp"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "slot_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "321-343",
          "snippet": "static int slot_get(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\tunsigned int bit;\n\tint error = 0;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tif (qd->qd_slot_count != 0)\n\t\tgoto out;\n\n\terror = -ENOSPC;\n\tbit = find_first_zero_bit(sdp->sd_quota_bitmap, sdp->sd_quota_slots);\n\tif (bit < sdp->sd_quota_slots) {\n\t\tset_bit(bit, sdp->sd_quota_bitmap);\n\t\tqd->qd_slot = bit;\n\t\terror = 0;\nout:\n\t\tqd->qd_slot_count++;\n\t}\n\tspin_unlock(&sdp->sd_bitmap_lock);\n\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int slot_get(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\tunsigned int bit;\n\tint error = 0;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tif (qd->qd_slot_count != 0)\n\t\tgoto out;\n\n\terror = -ENOSPC;\n\tbit = find_first_zero_bit(sdp->sd_quota_bitmap, sdp->sd_quota_slots);\n\tif (bit < sdp->sd_quota_slots) {\n\t\tset_bit(bit, sdp->sd_quota_bitmap);\n\t\tqd->qd_slot = bit;\n\t\terror = 0;\nout:\n\t\tqd->qd_slot_count++;\n\t}\n\tspin_unlock(&sdp->sd_bitmap_lock);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qd_get",
          "args": [
            "sdp",
            "qid",
            "qdp"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "qd_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "265-300",
          "snippet": "static int qd_get(struct gfs2_sbd *sdp, struct kqid qid,\n\t\t  struct gfs2_quota_data **qdp)\n{\n\tstruct gfs2_quota_data *qd, *new_qd;\n\tunsigned int hash = gfs2_qd_hash(sdp, qid);\n\n\trcu_read_lock();\n\t*qdp = qd = gfs2_qd_search_bucket(hash, sdp, qid);\n\trcu_read_unlock();\n\n\tif (qd)\n\t\treturn 0;\n\n\tnew_qd = qd_alloc(hash, sdp, qid);\n\tif (!new_qd)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&qd_lock);\n\tspin_lock_bucket(hash);\n\t*qdp = qd = gfs2_qd_search_bucket(hash, sdp, qid);\n\tif (qd == NULL) {\n\t\t*qdp = new_qd;\n\t\tlist_add(&new_qd->qd_list, &sdp->sd_quota_list);\n\t\thlist_bl_add_head_rcu(&new_qd->qd_hlist, &qd_hash_table[hash]);\n\t\tatomic_inc(&sdp->sd_quota_count);\n\t}\n\tspin_unlock_bucket(hash);\n\tspin_unlock(&qd_lock);\n\n\tif (qd) {\n\t\tgfs2_glock_put(new_qd->qd_gl);\n\t\tkmem_cache_free(gfs2_quotad_cachep, new_qd);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(qd_lock);",
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic int qd_get(struct gfs2_sbd *sdp, struct kqid qid,\n\t\t  struct gfs2_quota_data **qdp)\n{\n\tstruct gfs2_quota_data *qd, *new_qd;\n\tunsigned int hash = gfs2_qd_hash(sdp, qid);\n\n\trcu_read_lock();\n\t*qdp = qd = gfs2_qd_search_bucket(hash, sdp, qid);\n\trcu_read_unlock();\n\n\tif (qd)\n\t\treturn 0;\n\n\tnew_qd = qd_alloc(hash, sdp, qid);\n\tif (!new_qd)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&qd_lock);\n\tspin_lock_bucket(hash);\n\t*qdp = qd = gfs2_qd_search_bucket(hash, sdp, qid);\n\tif (qd == NULL) {\n\t\t*qdp = new_qd;\n\t\tlist_add(&new_qd->qd_list, &sdp->sd_quota_list);\n\t\thlist_bl_add_head_rcu(&new_qd->qd_hlist, &qd_hash_table[hash]);\n\t\tatomic_inc(&sdp->sd_quota_count);\n\t}\n\tspin_unlock_bucket(hash);\n\tspin_unlock(&qd_lock);\n\n\tif (qd) {\n\t\tgfs2_glock_put(new_qd->qd_gl);\n\t\tkmem_cache_free(gfs2_quotad_cachep, new_qd);\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int qdsb_get(struct gfs2_sbd *sdp, struct kqid qid,\n\t\t    struct gfs2_quota_data **qdp)\n{\n\tint error;\n\n\terror = qd_get(sdp, qid, qdp);\n\tif (error)\n\t\treturn error;\n\n\terror = slot_get(*qdp);\n\tif (error)\n\t\tgoto fail;\n\n\terror = bh_get(*qdp);\n\tif (error)\n\t\tgoto fail_slot;\n\n\treturn 0;\n\nfail_slot:\n\tslot_put(*qdp);\nfail:\n\tqd_put(*qdp);\n\treturn error;\n}"
  },
  {
    "function_name": "qd_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "487-495",
    "snippet": "static void qd_unlock(struct gfs2_quota_data *qd)\n{\n\tgfs2_assert_warn(qd->qd_gl->gl_sbd,\n\t\t\t test_bit(QDF_LOCKED, &qd->qd_flags));\n\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\tbh_put(qd);\n\tslot_put(qd);\n\tqd_put(qd);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qd_put",
          "args": [
            "qd"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "qd_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "310-319",
          "snippet": "static void qd_put(struct gfs2_quota_data *qd)\n{\n\tif (lockref_put_or_lock(&qd->qd_lockref))\n\t\treturn;\n\n\tqd->qd_lockref.count = 0;\n\tlist_lru_add(&gfs2_qd_lru, &qd->qd_lru);\n\tspin_unlock(&qd->qd_lockref.lock);\n\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_lru gfs2_qd_lru;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct list_lru gfs2_qd_lru;\n\nstatic void qd_put(struct gfs2_quota_data *qd)\n{\n\tif (lockref_put_or_lock(&qd->qd_lockref))\n\t\treturn;\n\n\tqd->qd_lockref.count = 0;\n\tlist_lru_add(&gfs2_qd_lru, &qd->qd_lru);\n\tspin_unlock(&qd->qd_lockref.lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "slot_put",
          "args": [
            "qd"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "slot_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "355-366",
          "snippet": "static void slot_put(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tgfs2_assert(sdp, qd->qd_slot_count);\n\tif (!--qd->qd_slot_count) {\n\t\tBUG_ON(!test_and_clear_bit(qd->qd_slot, sdp->sd_quota_bitmap));\n\t\tqd->qd_slot = -1;\n\t}\n\tspin_unlock(&sdp->sd_bitmap_lock);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void slot_put(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tgfs2_assert(sdp, qd->qd_slot_count);\n\tif (!--qd->qd_slot_count) {\n\t\tBUG_ON(!test_and_clear_bit(qd->qd_slot, sdp->sd_quota_bitmap));\n\t\tqd->qd_slot = -1;\n\t}\n\tspin_unlock(&sdp->sd_bitmap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bh_put",
          "args": [
            "qd"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "bh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "415-427",
          "snippet": "static void bh_put(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\n\tmutex_lock(&sdp->sd_quota_mutex);\n\tgfs2_assert(sdp, qd->qd_bh_count);\n\tif (!--qd->qd_bh_count) {\n\t\tbrelse(qd->qd_bh);\n\t\tqd->qd_bh = NULL;\n\t\tqd->qd_bh_qc = NULL;\n\t}\n\tmutex_unlock(&sdp->sd_quota_mutex);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void bh_put(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\n\tmutex_lock(&sdp->sd_quota_mutex);\n\tgfs2_assert(sdp, qd->qd_bh_count);\n\tif (!--qd->qd_bh_count) {\n\t\tbrelse(qd->qd_bh);\n\t\tqd->qd_bh = NULL;\n\t\tqd->qd_bh_qc = NULL;\n\t}\n\tmutex_unlock(&sdp->sd_quota_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "QDF_LOCKED",
            "&qd->qd_flags"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_assert_warn",
          "args": [
            "qd->qd_gl->gl_sbd",
            "test_bit(QDF_LOCKED, &qd->qd_flags)"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "QDF_LOCKED",
            "&qd->qd_flags"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void qd_unlock(struct gfs2_quota_data *qd)\n{\n\tgfs2_assert_warn(qd->qd_gl->gl_sbd,\n\t\t\t test_bit(QDF_LOCKED, &qd->qd_flags));\n\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\tbh_put(qd);\n\tslot_put(qd);\n\tqd_put(qd);\n}"
  },
  {
    "function_name": "qd_fish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "447-485",
    "snippet": "static int qd_fish(struct gfs2_sbd *sdp, struct gfs2_quota_data **qdp)\n{\n\tstruct gfs2_quota_data *qd = NULL;\n\tint error;\n\tint found = 0;\n\n\t*qdp = NULL;\n\n\tif (sdp->sd_vfs->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tspin_lock(&qd_lock);\n\n\tlist_for_each_entry(qd, &sdp->sd_quota_list, qd_list) {\n\t\tfound = qd_check_sync(sdp, qd, &sdp->sd_quota_sync_gen);\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\n\tif (!found)\n\t\tqd = NULL;\n\n\tspin_unlock(&qd_lock);\n\n\tif (qd) {\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\terror = bh_get(qd);\n\t\tif (error) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\t*qdp = qd;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(qd_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "qd_put",
          "args": [
            "qd"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "qd_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "310-319",
          "snippet": "static void qd_put(struct gfs2_quota_data *qd)\n{\n\tif (lockref_put_or_lock(&qd->qd_lockref))\n\t\treturn;\n\n\tqd->qd_lockref.count = 0;\n\tlist_lru_add(&gfs2_qd_lru, &qd->qd_lru);\n\tspin_unlock(&qd->qd_lockref.lock);\n\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_lru gfs2_qd_lru;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct list_lru gfs2_qd_lru;\n\nstatic void qd_put(struct gfs2_quota_data *qd)\n{\n\tif (lockref_put_or_lock(&qd->qd_lockref))\n\t\treturn;\n\n\tqd->qd_lockref.count = 0;\n\tlist_lru_add(&gfs2_qd_lru, &qd->qd_lru);\n\tspin_unlock(&qd->qd_lockref.lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "slot_put",
          "args": [
            "qd"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "slot_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "355-366",
          "snippet": "static void slot_put(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tgfs2_assert(sdp, qd->qd_slot_count);\n\tif (!--qd->qd_slot_count) {\n\t\tBUG_ON(!test_and_clear_bit(qd->qd_slot, sdp->sd_quota_bitmap));\n\t\tqd->qd_slot = -1;\n\t}\n\tspin_unlock(&sdp->sd_bitmap_lock);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void slot_put(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tgfs2_assert(sdp, qd->qd_slot_count);\n\tif (!--qd->qd_slot_count) {\n\t\tBUG_ON(!test_and_clear_bit(qd->qd_slot, sdp->sd_quota_bitmap));\n\t\tqd->qd_slot = -1;\n\t}\n\tspin_unlock(&sdp->sd_bitmap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "QDF_LOCKED",
            "&qd->qd_flags"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bh_get",
          "args": [
            "qd"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "bh_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "368-413",
          "snippet": "static int bh_get(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_qc_inode);\n\tunsigned int block, offset;\n\tstruct buffer_head *bh;\n\tint error;\n\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n\n\tmutex_lock(&sdp->sd_quota_mutex);\n\n\tif (qd->qd_bh_count++) {\n\t\tmutex_unlock(&sdp->sd_quota_mutex);\n\t\treturn 0;\n\t}\n\n\tblock = qd->qd_slot / sdp->sd_qc_per_block;\n\toffset = qd->qd_slot % sdp->sd_qc_per_block;\n\n\tbh_map.b_size = 1 << ip->i_inode.i_blkbits;\n\terror = gfs2_block_map(&ip->i_inode, block, &bh_map, 0);\n\tif (error)\n\t\tgoto fail;\n\terror = gfs2_meta_read(ip->i_gl, bh_map.b_blocknr, DIO_WAIT, &bh);\n\tif (error)\n\t\tgoto fail;\n\terror = -EIO;\n\tif (gfs2_metatype_check(sdp, bh, GFS2_METATYPE_QC))\n\t\tgoto fail_brelse;\n\n\tqd->qd_bh = bh;\n\tqd->qd_bh_qc = (struct gfs2_quota_change *)\n\t\t(bh->b_data + sizeof(struct gfs2_meta_header) +\n\t\t offset * sizeof(struct gfs2_quota_change));\n\n\tmutex_unlock(&sdp->sd_quota_mutex);\n\n\treturn 0;\n\nfail_brelse:\n\tbrelse(bh);\nfail:\n\tqd->qd_bh_count--;\n\tmutex_unlock(&sdp->sd_quota_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int bh_get(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_qc_inode);\n\tunsigned int block, offset;\n\tstruct buffer_head *bh;\n\tint error;\n\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n\n\tmutex_lock(&sdp->sd_quota_mutex);\n\n\tif (qd->qd_bh_count++) {\n\t\tmutex_unlock(&sdp->sd_quota_mutex);\n\t\treturn 0;\n\t}\n\n\tblock = qd->qd_slot / sdp->sd_qc_per_block;\n\toffset = qd->qd_slot % sdp->sd_qc_per_block;\n\n\tbh_map.b_size = 1 << ip->i_inode.i_blkbits;\n\terror = gfs2_block_map(&ip->i_inode, block, &bh_map, 0);\n\tif (error)\n\t\tgoto fail;\n\terror = gfs2_meta_read(ip->i_gl, bh_map.b_blocknr, DIO_WAIT, &bh);\n\tif (error)\n\t\tgoto fail;\n\terror = -EIO;\n\tif (gfs2_metatype_check(sdp, bh, GFS2_METATYPE_QC))\n\t\tgoto fail_brelse;\n\n\tqd->qd_bh = bh;\n\tqd->qd_bh_qc = (struct gfs2_quota_change *)\n\t\t(bh->b_data + sizeof(struct gfs2_meta_header) +\n\t\t offset * sizeof(struct gfs2_quota_change));\n\n\tmutex_unlock(&sdp->sd_quota_mutex);\n\n\treturn 0;\n\nfail_brelse:\n\tbrelse(bh);\nfail:\n\tqd->qd_bh_count--;\n\tmutex_unlock(&sdp->sd_quota_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_assert_warn",
          "args": [
            "sdp",
            "qd->qd_change_sync"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&qd_lock"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qd_check_sync",
          "args": [
            "sdp",
            "qd",
            "&sdp->sd_quota_sync_gen"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "qd_check_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "429-445",
          "snippet": "static int qd_check_sync(struct gfs2_sbd *sdp, struct gfs2_quota_data *qd,\n\t\t\t u64 *sync_gen)\n{\n\tif (test_bit(QDF_LOCKED, &qd->qd_flags) ||\n\t    !test_bit(QDF_CHANGE, &qd->qd_flags) ||\n\t    (sync_gen && (qd->qd_sync_gen >= *sync_gen)))\n\t\treturn 0;\n\n\tif (!lockref_get_not_dead(&qd->qd_lockref))\n\t\treturn 0;\n\n\tlist_move_tail(&qd->qd_list, &sdp->sd_quota_list);\n\tset_bit(QDF_LOCKED, &qd->qd_flags);\n\tqd->qd_change_sync = qd->qd_change;\n\tslot_hold(qd);\n\treturn 1;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int qd_check_sync(struct gfs2_sbd *sdp, struct gfs2_quota_data *qd,\n\t\t\t u64 *sync_gen)\n{\n\tif (test_bit(QDF_LOCKED, &qd->qd_flags) ||\n\t    !test_bit(QDF_CHANGE, &qd->qd_flags) ||\n\t    (sync_gen && (qd->qd_sync_gen >= *sync_gen)))\n\t\treturn 0;\n\n\tif (!lockref_get_not_dead(&qd->qd_lockref))\n\t\treturn 0;\n\n\tlist_move_tail(&qd->qd_list, &sdp->sd_quota_list);\n\tset_bit(QDF_LOCKED, &qd->qd_flags);\n\tqd->qd_change_sync = qd->qd_change;\n\tslot_hold(qd);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "qd",
            "&sdp->sd_quota_list",
            "qd_list"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&qd_lock"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\n\nstatic int qd_fish(struct gfs2_sbd *sdp, struct gfs2_quota_data **qdp)\n{\n\tstruct gfs2_quota_data *qd = NULL;\n\tint error;\n\tint found = 0;\n\n\t*qdp = NULL;\n\n\tif (sdp->sd_vfs->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tspin_lock(&qd_lock);\n\n\tlist_for_each_entry(qd, &sdp->sd_quota_list, qd_list) {\n\t\tfound = qd_check_sync(sdp, qd, &sdp->sd_quota_sync_gen);\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\n\tif (!found)\n\t\tqd = NULL;\n\n\tspin_unlock(&qd_lock);\n\n\tif (qd) {\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\terror = bh_get(qd);\n\t\tif (error) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\t*qdp = qd;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "qd_check_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "429-445",
    "snippet": "static int qd_check_sync(struct gfs2_sbd *sdp, struct gfs2_quota_data *qd,\n\t\t\t u64 *sync_gen)\n{\n\tif (test_bit(QDF_LOCKED, &qd->qd_flags) ||\n\t    !test_bit(QDF_CHANGE, &qd->qd_flags) ||\n\t    (sync_gen && (qd->qd_sync_gen >= *sync_gen)))\n\t\treturn 0;\n\n\tif (!lockref_get_not_dead(&qd->qd_lockref))\n\t\treturn 0;\n\n\tlist_move_tail(&qd->qd_list, &sdp->sd_quota_list);\n\tset_bit(QDF_LOCKED, &qd->qd_flags);\n\tqd->qd_change_sync = qd->qd_change;\n\tslot_hold(qd);\n\treturn 1;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slot_hold",
          "args": [
            "qd"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "slot_hold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "345-353",
          "snippet": "static void slot_hold(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tgfs2_assert(sdp, qd->qd_slot_count);\n\tqd->qd_slot_count++;\n\tspin_unlock(&sdp->sd_bitmap_lock);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void slot_hold(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tgfs2_assert(sdp, qd->qd_slot_count);\n\tqd->qd_slot_count++;\n\tspin_unlock(&sdp->sd_bitmap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "QDF_LOCKED",
            "&qd->qd_flags"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&qd->qd_list",
            "&sdp->sd_quota_list"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockref_get_not_dead",
          "args": [
            "&qd->qd_lockref"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "QDF_CHANGE",
            "&qd->qd_flags"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int qd_check_sync(struct gfs2_sbd *sdp, struct gfs2_quota_data *qd,\n\t\t\t u64 *sync_gen)\n{\n\tif (test_bit(QDF_LOCKED, &qd->qd_flags) ||\n\t    !test_bit(QDF_CHANGE, &qd->qd_flags) ||\n\t    (sync_gen && (qd->qd_sync_gen >= *sync_gen)))\n\t\treturn 0;\n\n\tif (!lockref_get_not_dead(&qd->qd_lockref))\n\t\treturn 0;\n\n\tlist_move_tail(&qd->qd_list, &sdp->sd_quota_list);\n\tset_bit(QDF_LOCKED, &qd->qd_flags);\n\tqd->qd_change_sync = qd->qd_change;\n\tslot_hold(qd);\n\treturn 1;\n}"
  },
  {
    "function_name": "bh_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "415-427",
    "snippet": "static void bh_put(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\n\tmutex_lock(&sdp->sd_quota_mutex);\n\tgfs2_assert(sdp, qd->qd_bh_count);\n\tif (!--qd->qd_bh_count) {\n\t\tbrelse(qd->qd_bh);\n\t\tqd->qd_bh = NULL;\n\t\tqd->qd_bh_qc = NULL;\n\t}\n\tmutex_unlock(&sdp->sd_quota_mutex);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sdp->sd_quota_mutex"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "qd->qd_bh"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_assert",
          "args": [
            "sdp",
            "qd->qd_bh_count"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sdp->sd_quota_mutex"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void bh_put(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\n\tmutex_lock(&sdp->sd_quota_mutex);\n\tgfs2_assert(sdp, qd->qd_bh_count);\n\tif (!--qd->qd_bh_count) {\n\t\tbrelse(qd->qd_bh);\n\t\tqd->qd_bh = NULL;\n\t\tqd->qd_bh_qc = NULL;\n\t}\n\tmutex_unlock(&sdp->sd_quota_mutex);\n}"
  },
  {
    "function_name": "bh_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "368-413",
    "snippet": "static int bh_get(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_qc_inode);\n\tunsigned int block, offset;\n\tstruct buffer_head *bh;\n\tint error;\n\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n\n\tmutex_lock(&sdp->sd_quota_mutex);\n\n\tif (qd->qd_bh_count++) {\n\t\tmutex_unlock(&sdp->sd_quota_mutex);\n\t\treturn 0;\n\t}\n\n\tblock = qd->qd_slot / sdp->sd_qc_per_block;\n\toffset = qd->qd_slot % sdp->sd_qc_per_block;\n\n\tbh_map.b_size = 1 << ip->i_inode.i_blkbits;\n\terror = gfs2_block_map(&ip->i_inode, block, &bh_map, 0);\n\tif (error)\n\t\tgoto fail;\n\terror = gfs2_meta_read(ip->i_gl, bh_map.b_blocknr, DIO_WAIT, &bh);\n\tif (error)\n\t\tgoto fail;\n\terror = -EIO;\n\tif (gfs2_metatype_check(sdp, bh, GFS2_METATYPE_QC))\n\t\tgoto fail_brelse;\n\n\tqd->qd_bh = bh;\n\tqd->qd_bh_qc = (struct gfs2_quota_change *)\n\t\t(bh->b_data + sizeof(struct gfs2_meta_header) +\n\t\t offset * sizeof(struct gfs2_quota_change));\n\n\tmutex_unlock(&sdp->sd_quota_mutex);\n\n\treturn 0;\n\nfail_brelse:\n\tbrelse(bh);\nfail:\n\tqd->qd_bh_count--;\n\tmutex_unlock(&sdp->sd_quota_mutex);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sdp->sd_quota_mutex"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sdp->sd_quota_mutex"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_metatype_check",
          "args": [
            "sdp",
            "bh",
            "GFS2_METATYPE_QC"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_meta_read",
          "args": [
            "ip->i_gl",
            "bh_map.b_blocknr",
            "DIO_WAIT",
            "&bh"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "200-235",
          "snippet": "int gfs2_meta_read(struct gfs2_glock *gl, u64 blkno, int flags,\n\t\t   struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct buffer_head *bh;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags))) {\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh = gfs2_getbuf(gl, blkno, CREATE);\n\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn 0;\n\t}\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(READ_SYNC | REQ_META | REQ_PRIO, bh);\n\tif (!(flags & DIO_WAIT))\n\t\treturn 0;\n\n\twait_on_buffer(bh);\n\tif (unlikely(!buffer_uptodate(bh))) {\n\t\tstruct gfs2_trans *tr = current->journal_info;\n\t\tif (tr && tr->tr_touched)\n\t\t\tgfs2_io_error_bh(sdp, bh);\n\t\tbrelse(bh);\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_meta_read(struct gfs2_glock *gl, u64 blkno, int flags,\n\t\t   struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct buffer_head *bh;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags))) {\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh = gfs2_getbuf(gl, blkno, CREATE);\n\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn 0;\n\t}\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(READ_SYNC | REQ_META | REQ_PRIO, bh);\n\tif (!(flags & DIO_WAIT))\n\t\treturn 0;\n\n\twait_on_buffer(bh);\n\tif (unlikely(!buffer_uptodate(bh))) {\n\t\tstruct gfs2_trans *tr = current->journal_info;\n\t\tif (tr && tr->tr_touched)\n\t\t\tgfs2_io_error_bh(sdp, bh);\n\t\tbrelse(bh);\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_block_map",
          "args": [
            "&ip->i_inode",
            "block",
            "&bh_map",
            "0"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_block_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "603-677",
          "snippet": "int gfs2_block_map(struct inode *inode, sector_t lblock,\n\t\t   struct buffer_head *bh_map, int create)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int bsize = sdp->sd_sb.sb_bsize;\n\tconst size_t maxlen = bh_map->b_size >> inode->i_blkbits;\n\tconst u64 *arr = sdp->sd_heightsize;\n\t__be64 *ptr;\n\tu64 size;\n\tstruct metapath mp;\n\tint ret;\n\tint eob;\n\tunsigned int len;\n\tstruct buffer_head *bh;\n\tu8 height;\n\n\tBUG_ON(maxlen == 0);\n\n\tmemset(mp.mp_bh, 0, sizeof(mp.mp_bh));\n\tbmap_lock(ip, create);\n\tclear_buffer_mapped(bh_map);\n\tclear_buffer_new(bh_map);\n\tclear_buffer_boundary(bh_map);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, 1);\n\tif (gfs2_is_dir(ip)) {\n\t\tbsize = sdp->sd_jbsize;\n\t\tarr = sdp->sd_jheightsize;\n\t}\n\n\tret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);\n\tif (ret)\n\t\tgoto out;\n\n\theight = ip->i_height;\n\tsize = (lblock + 1) * bsize;\n\twhile (size > arr[height])\n\t\theight++;\n\tfind_metapath(sdp, lblock, &mp, height);\n\tret = 1;\n\tif (height > ip->i_height || gfs2_is_stuffed(ip))\n\t\tgoto do_alloc;\n\tret = lookup_metapath(ip, &mp);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret != ip->i_height)\n\t\tgoto do_alloc;\n\tptr = metapointer(ip->i_height - 1, &mp);\n\tif (*ptr == 0)\n\t\tgoto do_alloc;\n\tmap_bh(bh_map, inode->i_sb, be64_to_cpu(*ptr));\n\tbh = mp.mp_bh[ip->i_height - 1];\n\tlen = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen, &eob);\n\tbh_map->b_size = (len << inode->i_blkbits);\n\tif (eob)\n\t\tset_buffer_boundary(bh_map);\n\tret = 0;\nout:\n\trelease_metapath(&mp);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, ret);\n\tbmap_unlock(ip, create);\n\treturn ret;\n\ndo_alloc:\n\t/* All allocations are done here, firstly check create flag */\n\tif (!create) {\n\t\tBUG_ON(gfs2_is_stuffed(ip));\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* At this point ret is the tree depth of already allocated blocks */\n\tret = gfs2_bmap_alloc(inode, lblock, bh_map, &mp, ret, height, maxlen);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_block_map(struct inode *inode, sector_t lblock,\n\t\t   struct buffer_head *bh_map, int create)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int bsize = sdp->sd_sb.sb_bsize;\n\tconst size_t maxlen = bh_map->b_size >> inode->i_blkbits;\n\tconst u64 *arr = sdp->sd_heightsize;\n\t__be64 *ptr;\n\tu64 size;\n\tstruct metapath mp;\n\tint ret;\n\tint eob;\n\tunsigned int len;\n\tstruct buffer_head *bh;\n\tu8 height;\n\n\tBUG_ON(maxlen == 0);\n\n\tmemset(mp.mp_bh, 0, sizeof(mp.mp_bh));\n\tbmap_lock(ip, create);\n\tclear_buffer_mapped(bh_map);\n\tclear_buffer_new(bh_map);\n\tclear_buffer_boundary(bh_map);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, 1);\n\tif (gfs2_is_dir(ip)) {\n\t\tbsize = sdp->sd_jbsize;\n\t\tarr = sdp->sd_jheightsize;\n\t}\n\n\tret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);\n\tif (ret)\n\t\tgoto out;\n\n\theight = ip->i_height;\n\tsize = (lblock + 1) * bsize;\n\twhile (size > arr[height])\n\t\theight++;\n\tfind_metapath(sdp, lblock, &mp, height);\n\tret = 1;\n\tif (height > ip->i_height || gfs2_is_stuffed(ip))\n\t\tgoto do_alloc;\n\tret = lookup_metapath(ip, &mp);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret != ip->i_height)\n\t\tgoto do_alloc;\n\tptr = metapointer(ip->i_height - 1, &mp);\n\tif (*ptr == 0)\n\t\tgoto do_alloc;\n\tmap_bh(bh_map, inode->i_sb, be64_to_cpu(*ptr));\n\tbh = mp.mp_bh[ip->i_height - 1];\n\tlen = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen, &eob);\n\tbh_map->b_size = (len << inode->i_blkbits);\n\tif (eob)\n\t\tset_buffer_boundary(bh_map);\n\tret = 0;\nout:\n\trelease_metapath(&mp);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, ret);\n\tbmap_unlock(ip, create);\n\treturn ret;\n\ndo_alloc:\n\t/* All allocations are done here, firstly check create flag */\n\tif (!create) {\n\t\tBUG_ON(gfs2_is_stuffed(ip));\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* At this point ret is the tree depth of already allocated blocks */\n\tret = gfs2_bmap_alloc(inode, lblock, bh_map, &mp, ret, height, maxlen);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sdp->sd_quota_mutex"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sdp->sd_quota_mutex"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "sdp->sd_qc_inode"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int bh_get(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_qc_inode);\n\tunsigned int block, offset;\n\tstruct buffer_head *bh;\n\tint error;\n\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n\n\tmutex_lock(&sdp->sd_quota_mutex);\n\n\tif (qd->qd_bh_count++) {\n\t\tmutex_unlock(&sdp->sd_quota_mutex);\n\t\treturn 0;\n\t}\n\n\tblock = qd->qd_slot / sdp->sd_qc_per_block;\n\toffset = qd->qd_slot % sdp->sd_qc_per_block;\n\n\tbh_map.b_size = 1 << ip->i_inode.i_blkbits;\n\terror = gfs2_block_map(&ip->i_inode, block, &bh_map, 0);\n\tif (error)\n\t\tgoto fail;\n\terror = gfs2_meta_read(ip->i_gl, bh_map.b_blocknr, DIO_WAIT, &bh);\n\tif (error)\n\t\tgoto fail;\n\terror = -EIO;\n\tif (gfs2_metatype_check(sdp, bh, GFS2_METATYPE_QC))\n\t\tgoto fail_brelse;\n\n\tqd->qd_bh = bh;\n\tqd->qd_bh_qc = (struct gfs2_quota_change *)\n\t\t(bh->b_data + sizeof(struct gfs2_meta_header) +\n\t\t offset * sizeof(struct gfs2_quota_change));\n\n\tmutex_unlock(&sdp->sd_quota_mutex);\n\n\treturn 0;\n\nfail_brelse:\n\tbrelse(bh);\nfail:\n\tqd->qd_bh_count--;\n\tmutex_unlock(&sdp->sd_quota_mutex);\n\treturn error;\n}"
  },
  {
    "function_name": "slot_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "355-366",
    "snippet": "static void slot_put(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tgfs2_assert(sdp, qd->qd_slot_count);\n\tif (!--qd->qd_slot_count) {\n\t\tBUG_ON(!test_and_clear_bit(qd->qd_slot, sdp->sd_quota_bitmap));\n\t\tqd->qd_slot = -1;\n\t}\n\tspin_unlock(&sdp->sd_bitmap_lock);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sdp->sd_bitmap_lock"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!test_and_clear_bit(qd->qd_slot, sdp->sd_quota_bitmap)"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "qd->qd_slot",
            "sdp->sd_quota_bitmap"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_assert",
          "args": [
            "sdp",
            "qd->qd_slot_count"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sdp->sd_bitmap_lock"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void slot_put(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tgfs2_assert(sdp, qd->qd_slot_count);\n\tif (!--qd->qd_slot_count) {\n\t\tBUG_ON(!test_and_clear_bit(qd->qd_slot, sdp->sd_quota_bitmap));\n\t\tqd->qd_slot = -1;\n\t}\n\tspin_unlock(&sdp->sd_bitmap_lock);\n}"
  },
  {
    "function_name": "slot_hold",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "345-353",
    "snippet": "static void slot_hold(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tgfs2_assert(sdp, qd->qd_slot_count);\n\tqd->qd_slot_count++;\n\tspin_unlock(&sdp->sd_bitmap_lock);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sdp->sd_bitmap_lock"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_assert",
          "args": [
            "sdp",
            "qd->qd_slot_count"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sdp->sd_bitmap_lock"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void slot_hold(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tgfs2_assert(sdp, qd->qd_slot_count);\n\tqd->qd_slot_count++;\n\tspin_unlock(&sdp->sd_bitmap_lock);\n}"
  },
  {
    "function_name": "slot_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "321-343",
    "snippet": "static int slot_get(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\tunsigned int bit;\n\tint error = 0;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tif (qd->qd_slot_count != 0)\n\t\tgoto out;\n\n\terror = -ENOSPC;\n\tbit = find_first_zero_bit(sdp->sd_quota_bitmap, sdp->sd_quota_slots);\n\tif (bit < sdp->sd_quota_slots) {\n\t\tset_bit(bit, sdp->sd_quota_bitmap);\n\t\tqd->qd_slot = bit;\n\t\terror = 0;\nout:\n\t\tqd->qd_slot_count++;\n\t}\n\tspin_unlock(&sdp->sd_bitmap_lock);\n\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sdp->sd_bitmap_lock"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "bit",
            "sdp->sd_quota_bitmap"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_first_zero_bit",
          "args": [
            "sdp->sd_quota_bitmap",
            "sdp->sd_quota_slots"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "minix_find_first_zero_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/minix.h",
          "lines": "124-140",
          "snippet": "static inline int minix_find_first_zero_bit(const void *vaddr, unsigned size)\n{\n\tconst unsigned short *p = vaddr, *addr = vaddr;\n\tunsigned short num;\n\n\tif (!size)\n\t\treturn 0;\n\n\tsize >>= 4;\n\twhile (*p++ == 0xffff) {\n\t\tif (--size == 0)\n\t\t\treturn (p - addr) << 4;\n\t}\n\n\tnum = *--p;\n\treturn ((p - addr) << 4) + ffz(num);\n}",
          "includes": [
            "#include <linux/minix_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define minix_find_first_zero_bit\tfind_first_zero_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/minix_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\n#define minix_find_first_zero_bit\tfind_first_zero_bit_le\n\nstatic inline int minix_find_first_zero_bit(const void *vaddr, unsigned size)\n{\n\tconst unsigned short *p = vaddr, *addr = vaddr;\n\tunsigned short num;\n\n\tif (!size)\n\t\treturn 0;\n\n\tsize >>= 4;\n\twhile (*p++ == 0xffff) {\n\t\tif (--size == 0)\n\t\t\treturn (p - addr) << 4;\n\t}\n\n\tnum = *--p;\n\treturn ((p - addr) << 4) + ffz(num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sdp->sd_bitmap_lock"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int slot_get(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_sbd;\n\tunsigned int bit;\n\tint error = 0;\n\n\tspin_lock(&sdp->sd_bitmap_lock);\n\tif (qd->qd_slot_count != 0)\n\t\tgoto out;\n\n\terror = -ENOSPC;\n\tbit = find_first_zero_bit(sdp->sd_quota_bitmap, sdp->sd_quota_slots);\n\tif (bit < sdp->sd_quota_slots) {\n\t\tset_bit(bit, sdp->sd_quota_bitmap);\n\t\tqd->qd_slot = bit;\n\t\terror = 0;\nout:\n\t\tqd->qd_slot_count++;\n\t}\n\tspin_unlock(&sdp->sd_bitmap_lock);\n\n\treturn error;\n}"
  },
  {
    "function_name": "qd_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "310-319",
    "snippet": "static void qd_put(struct gfs2_quota_data *qd)\n{\n\tif (lockref_put_or_lock(&qd->qd_lockref))\n\t\treturn;\n\n\tqd->qd_lockref.count = 0;\n\tlist_lru_add(&gfs2_qd_lru, &qd->qd_lru);\n\tspin_unlock(&qd->qd_lockref.lock);\n\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct list_lru gfs2_qd_lru;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&qd->qd_lockref.lock"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_lru_add",
          "args": [
            "&gfs2_qd_lru",
            "&qd->qd_lru"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockref_put_or_lock",
          "args": [
            "&qd->qd_lockref"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct list_lru gfs2_qd_lru;\n\nstatic void qd_put(struct gfs2_quota_data *qd)\n{\n\tif (lockref_put_or_lock(&qd->qd_lockref))\n\t\treturn;\n\n\tqd->qd_lockref.count = 0;\n\tlist_lru_add(&gfs2_qd_lru, &qd->qd_lru);\n\tspin_unlock(&qd->qd_lockref.lock);\n\n}"
  },
  {
    "function_name": "qd_hold",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "303-308",
    "snippet": "static void qd_hold(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tgfs2_assert(sdp, !__lockref_is_dead(&qd->qd_lockref));\n\tlockref_get(&qd->qd_lockref);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockref_get",
          "args": [
            "&qd->qd_lockref"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_assert",
          "args": [
            "sdp",
            "!__lockref_is_dead(&qd->qd_lockref)"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lockref_is_dead",
          "args": [
            "&qd->qd_lockref"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void qd_hold(struct gfs2_quota_data *qd)\n{\n\tstruct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;\n\tgfs2_assert(sdp, !__lockref_is_dead(&qd->qd_lockref));\n\tlockref_get(&qd->qd_lockref);\n}"
  },
  {
    "function_name": "qd_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "265-300",
    "snippet": "static int qd_get(struct gfs2_sbd *sdp, struct kqid qid,\n\t\t  struct gfs2_quota_data **qdp)\n{\n\tstruct gfs2_quota_data *qd, *new_qd;\n\tunsigned int hash = gfs2_qd_hash(sdp, qid);\n\n\trcu_read_lock();\n\t*qdp = qd = gfs2_qd_search_bucket(hash, sdp, qid);\n\trcu_read_unlock();\n\n\tif (qd)\n\t\treturn 0;\n\n\tnew_qd = qd_alloc(hash, sdp, qid);\n\tif (!new_qd)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&qd_lock);\n\tspin_lock_bucket(hash);\n\t*qdp = qd = gfs2_qd_search_bucket(hash, sdp, qid);\n\tif (qd == NULL) {\n\t\t*qdp = new_qd;\n\t\tlist_add(&new_qd->qd_list, &sdp->sd_quota_list);\n\t\thlist_bl_add_head_rcu(&new_qd->qd_hlist, &qd_hash_table[hash]);\n\t\tatomic_inc(&sdp->sd_quota_count);\n\t}\n\tspin_unlock_bucket(hash);\n\tspin_unlock(&qd_lock);\n\n\tif (qd) {\n\t\tgfs2_glock_put(new_qd->qd_gl);\n\t\tkmem_cache_free(gfs2_quotad_cachep, new_qd);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(qd_lock);",
      "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "gfs2_quotad_cachep",
            "new_qd"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_put",
          "args": [
            "new_qd->qd_gl"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "193-212",
          "snippet": "void gfs2_glock_put(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\n\tif (lockref_put_or_lock(&gl->gl_lockref))\n\t\treturn;\n\n\tlockref_mark_dead(&gl->gl_lockref);\n\n\tgfs2_glock_remove_from_lru(gl);\n\tspin_unlock(&gl->gl_lockref.lock);\n\tspin_lock_bucket(gl->gl_hash);\n\thlist_bl_del_rcu(&gl->gl_list);\n\tspin_unlock_bucket(gl->gl_hash);\n\tGLOCK_BUG_ON(gl, !list_empty(&gl->gl_holders));\n\tGLOCK_BUG_ON(gl, mapping && mapping->nrpages);\n\ttrace_gfs2_glock_put(gl);\n\tsdp->sd_lockstruct.ls_ops->lm_put_lock(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_put(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\n\tif (lockref_put_or_lock(&gl->gl_lockref))\n\t\treturn;\n\n\tlockref_mark_dead(&gl->gl_lockref);\n\n\tgfs2_glock_remove_from_lru(gl);\n\tspin_unlock(&gl->gl_lockref.lock);\n\tspin_lock_bucket(gl->gl_hash);\n\thlist_bl_del_rcu(&gl->gl_list);\n\tspin_unlock_bucket(gl->gl_hash);\n\tGLOCK_BUG_ON(gl, !list_empty(&gl->gl_holders));\n\tGLOCK_BUG_ON(gl, mapping && mapping->nrpages);\n\ttrace_gfs2_glock_put(gl);\n\tsdp->sd_lockstruct.ls_ops->lm_put_lock(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&qd_lock"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sdp->sd_quota_count"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_bl_add_head_rcu",
          "args": [
            "&new_qd->qd_hlist",
            "&qd_hash_table[hash]"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&new_qd->qd_list",
            "&sdp->sd_quota_list"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_qd_search_bucket",
          "args": [
            "hash",
            "sdp",
            "qid"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_qd_search_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "243-262",
          "snippet": "static struct gfs2_quota_data *gfs2_qd_search_bucket(unsigned int hash,\n\t\t\t\t\t\t     const struct gfs2_sbd *sdp,\n\t\t\t\t\t\t     struct kqid qid)\n{\n\tstruct gfs2_quota_data *qd;\n\tstruct hlist_bl_node *h;\n\n\thlist_bl_for_each_entry_rcu(qd, h, &qd_hash_table[hash], qd_hlist) {\n\t\tif (!qid_eq(qd->qd_id, qid))\n\t\t\tcontinue;\n\t\tif (qd->qd_sbd != sdp)\n\t\t\tcontinue;\n\t\tif (lockref_get_not_dead(&qd->qd_lockref)) {\n\t\t\tlist_lru_del(&gfs2_qd_lru, &qd->qd_lru);\n\t\t\treturn qd;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_lru gfs2_qd_lru;",
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct list_lru gfs2_qd_lru;\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic struct gfs2_quota_data *gfs2_qd_search_bucket(unsigned int hash,\n\t\t\t\t\t\t     const struct gfs2_sbd *sdp,\n\t\t\t\t\t\t     struct kqid qid)\n{\n\tstruct gfs2_quota_data *qd;\n\tstruct hlist_bl_node *h;\n\n\thlist_bl_for_each_entry_rcu(qd, h, &qd_hash_table[hash], qd_hlist) {\n\t\tif (!qid_eq(qd->qd_id, qid))\n\t\t\tcontinue;\n\t\tif (qd->qd_sbd != sdp)\n\t\t\tcontinue;\n\t\tif (lockref_get_not_dead(&qd->qd_lockref)) {\n\t\t\tlist_lru_del(&gfs2_qd_lru, &qd->qd_lru);\n\t\t\treturn qd;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bucket",
          "args": [
            "hash"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qd_alloc",
          "args": [
            "hash",
            "sdp",
            "qid"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "qd_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "214-241",
          "snippet": "static struct gfs2_quota_data *qd_alloc(unsigned hash, struct gfs2_sbd *sdp, struct kqid qid)\n{\n\tstruct gfs2_quota_data *qd;\n\tint error;\n\n\tqd = kmem_cache_zalloc(gfs2_quotad_cachep, GFP_NOFS);\n\tif (!qd)\n\t\treturn NULL;\n\n\tqd->qd_sbd = sdp;\n\tqd->qd_lockref.count = 1;\n\tspin_lock_init(&qd->qd_lockref.lock);\n\tqd->qd_id = qid;\n\tqd->qd_slot = -1;\n\tINIT_LIST_HEAD(&qd->qd_lru);\n\tqd->qd_hash = hash;\n\n\terror = gfs2_glock_get(sdp, qd2index(qd),\n\t\t\t      &gfs2_quota_glops, CREATE, &qd->qd_gl);\n\tif (error)\n\t\tgoto fail;\n\n\treturn qd;\n\nfail:\n\tkmem_cache_free(gfs2_quotad_cachep, qd);\n\treturn NULL;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct gfs2_quota_data *qd_alloc(unsigned hash, struct gfs2_sbd *sdp, struct kqid qid)\n{\n\tstruct gfs2_quota_data *qd;\n\tint error;\n\n\tqd = kmem_cache_zalloc(gfs2_quotad_cachep, GFP_NOFS);\n\tif (!qd)\n\t\treturn NULL;\n\n\tqd->qd_sbd = sdp;\n\tqd->qd_lockref.count = 1;\n\tspin_lock_init(&qd->qd_lockref.lock);\n\tqd->qd_id = qid;\n\tqd->qd_slot = -1;\n\tINIT_LIST_HEAD(&qd->qd_lru);\n\tqd->qd_hash = hash;\n\n\terror = gfs2_glock_get(sdp, qd2index(qd),\n\t\t\t      &gfs2_quota_glops, CREATE, &qd->qd_gl);\n\tif (error)\n\t\tgoto fail;\n\n\treturn qd;\n\nfail:\n\tkmem_cache_free(gfs2_quotad_cachep, qd);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_qd_hash",
          "args": [
            "sdp",
            "qid"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_qd_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "88-97",
          "snippet": "static unsigned int gfs2_qd_hash(const struct gfs2_sbd *sdp,\n\t\t\t\t const struct kqid qid)\n{\n\tunsigned int h;\n\n\th = jhash(&sdp, sizeof(struct gfs2_sbd *), 0);\n\th = jhash(&qid, sizeof(struct kqid), h);\n\n\treturn h & GFS2_QD_HASH_MASK;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define GFS2_QD_HASH_MASK       (GFS2_QD_HASH_SIZE - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define GFS2_QD_HASH_MASK       (GFS2_QD_HASH_SIZE - 1)\n\nstatic unsigned int gfs2_qd_hash(const struct gfs2_sbd *sdp,\n\t\t\t\t const struct kqid qid)\n{\n\tunsigned int h;\n\n\th = jhash(&sdp, sizeof(struct gfs2_sbd *), 0);\n\th = jhash(&qid, sizeof(struct kqid), h);\n\n\treturn h & GFS2_QD_HASH_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic int qd_get(struct gfs2_sbd *sdp, struct kqid qid,\n\t\t  struct gfs2_quota_data **qdp)\n{\n\tstruct gfs2_quota_data *qd, *new_qd;\n\tunsigned int hash = gfs2_qd_hash(sdp, qid);\n\n\trcu_read_lock();\n\t*qdp = qd = gfs2_qd_search_bucket(hash, sdp, qid);\n\trcu_read_unlock();\n\n\tif (qd)\n\t\treturn 0;\n\n\tnew_qd = qd_alloc(hash, sdp, qid);\n\tif (!new_qd)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&qd_lock);\n\tspin_lock_bucket(hash);\n\t*qdp = qd = gfs2_qd_search_bucket(hash, sdp, qid);\n\tif (qd == NULL) {\n\t\t*qdp = new_qd;\n\t\tlist_add(&new_qd->qd_list, &sdp->sd_quota_list);\n\t\thlist_bl_add_head_rcu(&new_qd->qd_hlist, &qd_hash_table[hash]);\n\t\tatomic_inc(&sdp->sd_quota_count);\n\t}\n\tspin_unlock_bucket(hash);\n\tspin_unlock(&qd_lock);\n\n\tif (qd) {\n\t\tgfs2_glock_put(new_qd->qd_gl);\n\t\tkmem_cache_free(gfs2_quotad_cachep, new_qd);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_qd_search_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "243-262",
    "snippet": "static struct gfs2_quota_data *gfs2_qd_search_bucket(unsigned int hash,\n\t\t\t\t\t\t     const struct gfs2_sbd *sdp,\n\t\t\t\t\t\t     struct kqid qid)\n{\n\tstruct gfs2_quota_data *qd;\n\tstruct hlist_bl_node *h;\n\n\thlist_bl_for_each_entry_rcu(qd, h, &qd_hash_table[hash], qd_hlist) {\n\t\tif (!qid_eq(qd->qd_id, qid))\n\t\t\tcontinue;\n\t\tif (qd->qd_sbd != sdp)\n\t\t\tcontinue;\n\t\tif (lockref_get_not_dead(&qd->qd_lockref)) {\n\t\t\tlist_lru_del(&gfs2_qd_lru, &qd->qd_lru);\n\t\t\treturn qd;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct list_lru gfs2_qd_lru;",
      "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_lru_del",
          "args": [
            "&gfs2_qd_lru",
            "&qd->qd_lru"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockref_get_not_dead",
          "args": [
            "&qd->qd_lockref"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qid_eq",
          "args": [
            "qd->qd_id",
            "qid"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "qid_eq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/kqid.c",
          "lines": "12-26",
          "snippet": "bool qid_eq(struct kqid left, struct kqid right)\n{\n\tif (left.type != right.type)\n\t\treturn false;\n\tswitch(left.type) {\n\tcase USRQUOTA:\n\t\treturn uid_eq(left.uid, right.uid);\n\tcase GRPQUOTA:\n\t\treturn gid_eq(left.gid, right.gid);\n\tcase PRJQUOTA:\n\t\treturn projid_eq(left.projid, right.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/quota.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/quota.h>\n#include <linux/fs.h>\n\nbool qid_eq(struct kqid left, struct kqid right)\n{\n\tif (left.type != right.type)\n\t\treturn false;\n\tswitch(left.type) {\n\tcase USRQUOTA:\n\t\treturn uid_eq(left.uid, right.uid);\n\tcase GRPQUOTA:\n\t\treturn gid_eq(left.gid, right.gid);\n\tcase PRJQUOTA:\n\t\treturn projid_eq(left.projid, right.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_bl_for_each_entry_rcu",
          "args": [
            "qd",
            "h",
            "&qd_hash_table[hash]",
            "qd_hlist"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct list_lru gfs2_qd_lru;\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic struct gfs2_quota_data *gfs2_qd_search_bucket(unsigned int hash,\n\t\t\t\t\t\t     const struct gfs2_sbd *sdp,\n\t\t\t\t\t\t     struct kqid qid)\n{\n\tstruct gfs2_quota_data *qd;\n\tstruct hlist_bl_node *h;\n\n\thlist_bl_for_each_entry_rcu(qd, h, &qd_hash_table[hash], qd_hlist) {\n\t\tif (!qid_eq(qd->qd_id, qid))\n\t\t\tcontinue;\n\t\tif (qd->qd_sbd != sdp)\n\t\t\tcontinue;\n\t\tif (lockref_get_not_dead(&qd->qd_lockref)) {\n\t\t\tlist_lru_del(&gfs2_qd_lru, &qd->qd_lru);\n\t\t\treturn qd;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "qd_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "214-241",
    "snippet": "static struct gfs2_quota_data *qd_alloc(unsigned hash, struct gfs2_sbd *sdp, struct kqid qid)\n{\n\tstruct gfs2_quota_data *qd;\n\tint error;\n\n\tqd = kmem_cache_zalloc(gfs2_quotad_cachep, GFP_NOFS);\n\tif (!qd)\n\t\treturn NULL;\n\n\tqd->qd_sbd = sdp;\n\tqd->qd_lockref.count = 1;\n\tspin_lock_init(&qd->qd_lockref.lock);\n\tqd->qd_id = qid;\n\tqd->qd_slot = -1;\n\tINIT_LIST_HEAD(&qd->qd_lru);\n\tqd->qd_hash = hash;\n\n\terror = gfs2_glock_get(sdp, qd2index(qd),\n\t\t\t      &gfs2_quota_glops, CREATE, &qd->qd_gl);\n\tif (error)\n\t\tgoto fail;\n\n\treturn qd;\n\nfail:\n\tkmem_cache_free(gfs2_quotad_cachep, qd);\n\treturn NULL;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "gfs2_quotad_cachep",
            "qd"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_get",
          "args": [
            "sdp",
            "qd2index(qd)",
            "&gfs2_quota_glops",
            "CREATE",
            "&qd->qd_gl"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "702-790",
          "snippet": "int gfs2_glock_get(struct gfs2_sbd *sdp, u64 number,\n\t\t   const struct gfs2_glock_operations *glops, int create,\n\t\t   struct gfs2_glock **glp)\n{\n\tstruct super_block *s = sdp->sd_vfs;\n\tstruct lm_lockname name = { .ln_number = number, .ln_type = glops->go_type };\n\tstruct gfs2_glock *gl, *tmp;\n\tunsigned int hash = gl_hash(sdp, &name);\n\tstruct address_space *mapping;\n\tstruct kmem_cache *cachep;\n\n\trcu_read_lock();\n\tgl = search_bucket(hash, sdp, &name);\n\trcu_read_unlock();\n\n\t*glp = gl;\n\tif (gl)\n\t\treturn 0;\n\tif (!create)\n\t\treturn -ENOENT;\n\n\tif (glops->go_flags & GLOF_ASPACE)\n\t\tcachep = gfs2_glock_aspace_cachep;\n\telse\n\t\tcachep = gfs2_glock_cachep;\n\tgl = kmem_cache_alloc(cachep, GFP_NOFS);\n\tif (!gl)\n\t\treturn -ENOMEM;\n\n\tmemset(&gl->gl_lksb, 0, sizeof(struct dlm_lksb));\n\n\tif (glops->go_flags & GLOF_LVB) {\n\t\tgl->gl_lksb.sb_lvbptr = kzalloc(GFS2_MIN_LVB_SIZE, GFP_NOFS);\n\t\tif (!gl->gl_lksb.sb_lvbptr) {\n\t\t\tkmem_cache_free(cachep, gl);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tatomic_inc(&sdp->sd_glock_disposal);\n\tgl->gl_sbd = sdp;\n\tgl->gl_flags = 0;\n\tgl->gl_name = name;\n\tgl->gl_lockref.count = 1;\n\tgl->gl_state = LM_ST_UNLOCKED;\n\tgl->gl_target = LM_ST_UNLOCKED;\n\tgl->gl_demote_state = LM_ST_EXCLUSIVE;\n\tgl->gl_hash = hash;\n\tgl->gl_ops = glops;\n\tgl->gl_dstamp = ktime_set(0, 0);\n\tpreempt_disable();\n\t/* We use the global stats to estimate the initial per-glock stats */\n\tgl->gl_stats = this_cpu_ptr(sdp->sd_lkstats)->lkstats[glops->go_type];\n\tpreempt_enable();\n\tgl->gl_stats.stats[GFS2_LKS_DCOUNT] = 0;\n\tgl->gl_stats.stats[GFS2_LKS_QCOUNT] = 0;\n\tgl->gl_tchange = jiffies;\n\tgl->gl_object = NULL;\n\tgl->gl_hold_time = GL_GLOCK_DFT_HOLD;\n\tINIT_DELAYED_WORK(&gl->gl_work, glock_work_func);\n\tINIT_WORK(&gl->gl_delete, delete_work_func);\n\n\tmapping = gfs2_glock2aspace(gl);\n\tif (mapping) {\n                mapping->a_ops = &gfs2_meta_aops;\n\t\tmapping->host = s->s_bdev->bd_inode;\n\t\tmapping->flags = 0;\n\t\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\t\tmapping->private_data = NULL;\n\t\tmapping->writeback_index = 0;\n\t}\n\n\tspin_lock_bucket(hash);\n\ttmp = search_bucket(hash, sdp, &name);\n\tif (tmp) {\n\t\tspin_unlock_bucket(hash);\n\t\tkfree(gl->gl_lksb.sb_lvbptr);\n\t\tkmem_cache_free(cachep, gl);\n\t\tatomic_dec(&sdp->sd_glock_disposal);\n\t\tgl = tmp;\n\t} else {\n\t\thlist_bl_add_head_rcu(&gl->gl_list, &gl_hash_table[hash]);\n\t\tspin_unlock_bucket(hash);\n\t}\n\n\t*glp = gl;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head gl_hash_table[GFS2_GL_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head gl_hash_table[GFS2_GL_HASH_SIZE];\n\nint gfs2_glock_get(struct gfs2_sbd *sdp, u64 number,\n\t\t   const struct gfs2_glock_operations *glops, int create,\n\t\t   struct gfs2_glock **glp)\n{\n\tstruct super_block *s = sdp->sd_vfs;\n\tstruct lm_lockname name = { .ln_number = number, .ln_type = glops->go_type };\n\tstruct gfs2_glock *gl, *tmp;\n\tunsigned int hash = gl_hash(sdp, &name);\n\tstruct address_space *mapping;\n\tstruct kmem_cache *cachep;\n\n\trcu_read_lock();\n\tgl = search_bucket(hash, sdp, &name);\n\trcu_read_unlock();\n\n\t*glp = gl;\n\tif (gl)\n\t\treturn 0;\n\tif (!create)\n\t\treturn -ENOENT;\n\n\tif (glops->go_flags & GLOF_ASPACE)\n\t\tcachep = gfs2_glock_aspace_cachep;\n\telse\n\t\tcachep = gfs2_glock_cachep;\n\tgl = kmem_cache_alloc(cachep, GFP_NOFS);\n\tif (!gl)\n\t\treturn -ENOMEM;\n\n\tmemset(&gl->gl_lksb, 0, sizeof(struct dlm_lksb));\n\n\tif (glops->go_flags & GLOF_LVB) {\n\t\tgl->gl_lksb.sb_lvbptr = kzalloc(GFS2_MIN_LVB_SIZE, GFP_NOFS);\n\t\tif (!gl->gl_lksb.sb_lvbptr) {\n\t\t\tkmem_cache_free(cachep, gl);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tatomic_inc(&sdp->sd_glock_disposal);\n\tgl->gl_sbd = sdp;\n\tgl->gl_flags = 0;\n\tgl->gl_name = name;\n\tgl->gl_lockref.count = 1;\n\tgl->gl_state = LM_ST_UNLOCKED;\n\tgl->gl_target = LM_ST_UNLOCKED;\n\tgl->gl_demote_state = LM_ST_EXCLUSIVE;\n\tgl->gl_hash = hash;\n\tgl->gl_ops = glops;\n\tgl->gl_dstamp = ktime_set(0, 0);\n\tpreempt_disable();\n\t/* We use the global stats to estimate the initial per-glock stats */\n\tgl->gl_stats = this_cpu_ptr(sdp->sd_lkstats)->lkstats[glops->go_type];\n\tpreempt_enable();\n\tgl->gl_stats.stats[GFS2_LKS_DCOUNT] = 0;\n\tgl->gl_stats.stats[GFS2_LKS_QCOUNT] = 0;\n\tgl->gl_tchange = jiffies;\n\tgl->gl_object = NULL;\n\tgl->gl_hold_time = GL_GLOCK_DFT_HOLD;\n\tINIT_DELAYED_WORK(&gl->gl_work, glock_work_func);\n\tINIT_WORK(&gl->gl_delete, delete_work_func);\n\n\tmapping = gfs2_glock2aspace(gl);\n\tif (mapping) {\n                mapping->a_ops = &gfs2_meta_aops;\n\t\tmapping->host = s->s_bdev->bd_inode;\n\t\tmapping->flags = 0;\n\t\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\t\tmapping->private_data = NULL;\n\t\tmapping->writeback_index = 0;\n\t}\n\n\tspin_lock_bucket(hash);\n\ttmp = search_bucket(hash, sdp, &name);\n\tif (tmp) {\n\t\tspin_unlock_bucket(hash);\n\t\tkfree(gl->gl_lksb.sb_lvbptr);\n\t\tkmem_cache_free(cachep, gl);\n\t\tatomic_dec(&sdp->sd_glock_disposal);\n\t\tgl = tmp;\n\t} else {\n\t\thlist_bl_add_head_rcu(&gl->gl_list, &gl_hash_table[hash]);\n\t\tspin_unlock_bucket(hash);\n\t}\n\n\t*glp = gl;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qd2index",
          "args": [
            "qd"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "qd2index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "197-202",
          "snippet": "static u64 qd2index(struct gfs2_quota_data *qd)\n{\n\tstruct kqid qid = qd->qd_id;\n\treturn (2 * (u64)from_kqid(&init_user_ns, qid)) +\n\t\t((qid.type == USRQUOTA) ? 0 : 1);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic u64 qd2index(struct gfs2_quota_data *qd)\n{\n\tstruct kqid qid = qd->qd_id;\n\treturn (2 * (u64)from_kqid(&init_user_ns, qid)) +\n\t\t((qid.type == USRQUOTA) ? 0 : 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&qd->qd_lru"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&qd->qd_lockref.lock"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "gfs2_quotad_cachep",
            "GFP_NOFS"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct gfs2_quota_data *qd_alloc(unsigned hash, struct gfs2_sbd *sdp, struct kqid qid)\n{\n\tstruct gfs2_quota_data *qd;\n\tint error;\n\n\tqd = kmem_cache_zalloc(gfs2_quotad_cachep, GFP_NOFS);\n\tif (!qd)\n\t\treturn NULL;\n\n\tqd->qd_sbd = sdp;\n\tqd->qd_lockref.count = 1;\n\tspin_lock_init(&qd->qd_lockref.lock);\n\tqd->qd_id = qid;\n\tqd->qd_slot = -1;\n\tINIT_LIST_HEAD(&qd->qd_lru);\n\tqd->qd_hash = hash;\n\n\terror = gfs2_glock_get(sdp, qd2index(qd),\n\t\t\t      &gfs2_quota_glops, CREATE, &qd->qd_gl);\n\tif (error)\n\t\tgoto fail;\n\n\treturn qd;\n\nfail:\n\tkmem_cache_free(gfs2_quotad_cachep, qd);\n\treturn NULL;\n}"
  },
  {
    "function_name": "qd2offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "204-212",
    "snippet": "static u64 qd2offset(struct gfs2_quota_data *qd)\n{\n\tu64 offset;\n\n\toffset = qd2index(qd);\n\toffset *= sizeof(struct gfs2_quota);\n\n\treturn offset;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qd2index",
          "args": [
            "qd"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "qd2index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "197-202",
          "snippet": "static u64 qd2index(struct gfs2_quota_data *qd)\n{\n\tstruct kqid qid = qd->qd_id;\n\treturn (2 * (u64)from_kqid(&init_user_ns, qid)) +\n\t\t((qid.type == USRQUOTA) ? 0 : 1);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic u64 qd2index(struct gfs2_quota_data *qd)\n{\n\tstruct kqid qid = qd->qd_id;\n\treturn (2 * (u64)from_kqid(&init_user_ns, qid)) +\n\t\t((qid.type == USRQUOTA) ? 0 : 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic u64 qd2offset(struct gfs2_quota_data *qd)\n{\n\tu64 offset;\n\n\toffset = qd2index(qd);\n\toffset *= sizeof(struct gfs2_quota);\n\n\treturn offset;\n}"
  },
  {
    "function_name": "qd2index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "197-202",
    "snippet": "static u64 qd2index(struct gfs2_quota_data *qd)\n{\n\tstruct kqid qid = qd->qd_id;\n\treturn (2 * (u64)from_kqid(&init_user_ns, qid)) +\n\t\t((qid.type == USRQUOTA) ? 0 : 1);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "from_kqid",
          "args": [
            "&init_user_ns",
            "qid"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "from_kqid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/kqid.c",
          "lines": "100-112",
          "snippet": "qid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/quota.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/quota.h>\n#include <linux/fs.h>\n\nqid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic u64 qd2index(struct gfs2_quota_data *qd)\n{\n\tstruct kqid qid = qd->qd_id;\n\treturn (2 * (u64)from_kqid(&init_user_ns, qid)) +\n\t\t((qid.type == USRQUOTA) ? 0 : 1);\n}"
  },
  {
    "function_name": "gfs2_qd_shrink_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "183-187",
    "snippet": "static unsigned long gfs2_qd_shrink_count(struct shrinker *shrink,\n\t\t\t\t\t  struct shrink_control *sc)\n{\n\treturn vfs_pressure_ratio(list_lru_shrink_count(&gfs2_qd_lru, sc));\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct list_lru gfs2_qd_lru;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfs_pressure_ratio",
          "args": [
            "list_lru_shrink_count(&gfs2_qd_lru, sc)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_shrink_count",
          "args": [
            "&gfs2_qd_lru",
            "sc"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct list_lru gfs2_qd_lru;\n\nstatic unsigned long gfs2_qd_shrink_count(struct shrinker *shrink,\n\t\t\t\t\t  struct shrink_control *sc)\n{\n\treturn vfs_pressure_ratio(list_lru_shrink_count(&gfs2_qd_lru, sc));\n}"
  },
  {
    "function_name": "gfs2_qd_shrink_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "166-181",
    "snippet": "static unsigned long gfs2_qd_shrink_scan(struct shrinker *shrink,\n\t\t\t\t\t struct shrink_control *sc)\n{\n\tLIST_HEAD(dispose);\n\tunsigned long freed;\n\n\tif (!(sc->gfp_mask & __GFP_FS))\n\t\treturn SHRINK_STOP;\n\n\tfreed = list_lru_shrink_walk(&gfs2_qd_lru, sc,\n\t\t\t\t     gfs2_qd_isolate, &dispose);\n\n\tgfs2_qd_dispose(&dispose);\n\n\treturn freed;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct list_lru gfs2_qd_lru;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_qd_dispose",
          "args": [
            "&dispose"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_qd_dispose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "115-145",
          "snippet": "static void gfs2_qd_dispose(struct list_head *list)\n{\n\tstruct gfs2_quota_data *qd;\n\tstruct gfs2_sbd *sdp;\n\n\twhile (!list_empty(list)) {\n\t\tqd = list_entry(list->next, struct gfs2_quota_data, qd_lru);\n\t\tsdp = qd->qd_gl->gl_sbd;\n\n\t\tlist_del(&qd->qd_lru);\n\n\t\t/* Free from the filesystem-specific list */\n\t\tspin_lock(&qd_lock);\n\t\tlist_del(&qd->qd_list);\n\t\tspin_unlock(&qd_lock);\n\n\t\tspin_lock_bucket(qd->qd_hash);\n\t\thlist_bl_del_rcu(&qd->qd_hlist);\n\t\tspin_unlock_bucket(qd->qd_hash);\n\n\t\tgfs2_assert_warn(sdp, !qd->qd_change);\n\t\tgfs2_assert_warn(sdp, !qd->qd_slot_count);\n\t\tgfs2_assert_warn(sdp, !qd->qd_bh_count);\n\n\t\tgfs2_glock_put(qd->qd_gl);\n\t\tatomic_dec(&sdp->sd_quota_count);\n\n\t\t/* Delete it from the common reclaim list */\n\t\tcall_rcu(&qd->qd_rcu, gfs2_qd_dealloc);\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(qd_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\n\nstatic void gfs2_qd_dispose(struct list_head *list)\n{\n\tstruct gfs2_quota_data *qd;\n\tstruct gfs2_sbd *sdp;\n\n\twhile (!list_empty(list)) {\n\t\tqd = list_entry(list->next, struct gfs2_quota_data, qd_lru);\n\t\tsdp = qd->qd_gl->gl_sbd;\n\n\t\tlist_del(&qd->qd_lru);\n\n\t\t/* Free from the filesystem-specific list */\n\t\tspin_lock(&qd_lock);\n\t\tlist_del(&qd->qd_list);\n\t\tspin_unlock(&qd_lock);\n\n\t\tspin_lock_bucket(qd->qd_hash);\n\t\thlist_bl_del_rcu(&qd->qd_hlist);\n\t\tspin_unlock_bucket(qd->qd_hash);\n\n\t\tgfs2_assert_warn(sdp, !qd->qd_change);\n\t\tgfs2_assert_warn(sdp, !qd->qd_slot_count);\n\t\tgfs2_assert_warn(sdp, !qd->qd_bh_count);\n\n\t\tgfs2_glock_put(qd->qd_gl);\n\t\tatomic_dec(&sdp->sd_quota_count);\n\n\t\t/* Delete it from the common reclaim list */\n\t\tcall_rcu(&qd->qd_rcu, gfs2_qd_dealloc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_lru_shrink_walk",
          "args": [
            "&gfs2_qd_lru",
            "sc",
            "gfs2_qd_isolate",
            "&dispose"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dispose"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct list_lru gfs2_qd_lru;\n\nstatic unsigned long gfs2_qd_shrink_scan(struct shrinker *shrink,\n\t\t\t\t\t struct shrink_control *sc)\n{\n\tLIST_HEAD(dispose);\n\tunsigned long freed;\n\n\tif (!(sc->gfp_mask & __GFP_FS))\n\t\treturn SHRINK_STOP;\n\n\tfreed = list_lru_shrink_walk(&gfs2_qd_lru, sc,\n\t\t\t\t     gfs2_qd_isolate, &dispose);\n\n\tgfs2_qd_dispose(&dispose);\n\n\treturn freed;\n}"
  },
  {
    "function_name": "gfs2_qd_isolate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "148-164",
    "snippet": "static enum lru_status gfs2_qd_isolate(struct list_head *item,\n\t\tstruct list_lru_one *lru, spinlock_t *lru_lock, void *arg)\n{\n\tstruct list_head *dispose = arg;\n\tstruct gfs2_quota_data *qd = list_entry(item, struct gfs2_quota_data, qd_lru);\n\n\tif (!spin_trylock(&qd->qd_lockref.lock))\n\t\treturn LRU_SKIP;\n\n\tif (qd->qd_lockref.count == 0) {\n\t\tlockref_mark_dead(&qd->qd_lockref);\n\t\tlist_lru_isolate_move(lru, &qd->qd_lru, dispose);\n\t}\n\n\tspin_unlock(&qd->qd_lockref.lock);\n\treturn LRU_REMOVED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&qd->qd_lockref.lock"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_lru_isolate_move",
          "args": [
            "lru",
            "&qd->qd_lru",
            "dispose"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockref_mark_dead",
          "args": [
            "&qd->qd_lockref"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_trylock",
          "args": [
            "&qd->qd_lockref.lock"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "item",
            "structgfs2_quota_data",
            "qd_lru"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic enum lru_status gfs2_qd_isolate(struct list_head *item,\n\t\tstruct list_lru_one *lru, spinlock_t *lru_lock, void *arg)\n{\n\tstruct list_head *dispose = arg;\n\tstruct gfs2_quota_data *qd = list_entry(item, struct gfs2_quota_data, qd_lru);\n\n\tif (!spin_trylock(&qd->qd_lockref.lock))\n\t\treturn LRU_SKIP;\n\n\tif (qd->qd_lockref.count == 0) {\n\t\tlockref_mark_dead(&qd->qd_lockref);\n\t\tlist_lru_isolate_move(lru, &qd->qd_lru, dispose);\n\t}\n\n\tspin_unlock(&qd->qd_lockref.lock);\n\treturn LRU_REMOVED;\n}"
  },
  {
    "function_name": "gfs2_qd_dispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "115-145",
    "snippet": "static void gfs2_qd_dispose(struct list_head *list)\n{\n\tstruct gfs2_quota_data *qd;\n\tstruct gfs2_sbd *sdp;\n\n\twhile (!list_empty(list)) {\n\t\tqd = list_entry(list->next, struct gfs2_quota_data, qd_lru);\n\t\tsdp = qd->qd_gl->gl_sbd;\n\n\t\tlist_del(&qd->qd_lru);\n\n\t\t/* Free from the filesystem-specific list */\n\t\tspin_lock(&qd_lock);\n\t\tlist_del(&qd->qd_list);\n\t\tspin_unlock(&qd_lock);\n\n\t\tspin_lock_bucket(qd->qd_hash);\n\t\thlist_bl_del_rcu(&qd->qd_hlist);\n\t\tspin_unlock_bucket(qd->qd_hash);\n\n\t\tgfs2_assert_warn(sdp, !qd->qd_change);\n\t\tgfs2_assert_warn(sdp, !qd->qd_slot_count);\n\t\tgfs2_assert_warn(sdp, !qd->qd_bh_count);\n\n\t\tgfs2_glock_put(qd->qd_gl);\n\t\tatomic_dec(&sdp->sd_quota_count);\n\n\t\t/* Delete it from the common reclaim list */\n\t\tcall_rcu(&qd->qd_rcu, gfs2_qd_dealloc);\n\t}\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(qd_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&qd->qd_rcu",
            "gfs2_qd_dealloc"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&sdp->sd_quota_count"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_put",
          "args": [
            "qd->qd_gl"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "193-212",
          "snippet": "void gfs2_glock_put(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\n\tif (lockref_put_or_lock(&gl->gl_lockref))\n\t\treturn;\n\n\tlockref_mark_dead(&gl->gl_lockref);\n\n\tgfs2_glock_remove_from_lru(gl);\n\tspin_unlock(&gl->gl_lockref.lock);\n\tspin_lock_bucket(gl->gl_hash);\n\thlist_bl_del_rcu(&gl->gl_list);\n\tspin_unlock_bucket(gl->gl_hash);\n\tGLOCK_BUG_ON(gl, !list_empty(&gl->gl_holders));\n\tGLOCK_BUG_ON(gl, mapping && mapping->nrpages);\n\ttrace_gfs2_glock_put(gl);\n\tsdp->sd_lockstruct.ls_ops->lm_put_lock(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_put(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\n\tif (lockref_put_or_lock(&gl->gl_lockref))\n\t\treturn;\n\n\tlockref_mark_dead(&gl->gl_lockref);\n\n\tgfs2_glock_remove_from_lru(gl);\n\tspin_unlock(&gl->gl_lockref.lock);\n\tspin_lock_bucket(gl->gl_hash);\n\thlist_bl_del_rcu(&gl->gl_list);\n\tspin_unlock_bucket(gl->gl_hash);\n\tGLOCK_BUG_ON(gl, !list_empty(&gl->gl_holders));\n\tGLOCK_BUG_ON(gl, mapping && mapping->nrpages);\n\ttrace_gfs2_glock_put(gl);\n\tsdp->sd_lockstruct.ls_ops->lm_put_lock(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_assert_warn",
          "args": [
            "sdp",
            "!qd->qd_bh_count"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_assert_warn",
          "args": [
            "sdp",
            "!qd->qd_slot_count"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_assert_warn",
          "args": [
            "sdp",
            "!qd->qd_change"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bucket",
          "args": [
            "qd->qd_hash"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_bl_del_rcu",
          "args": [
            "&qd->qd_hlist"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bucket",
          "args": [
            "qd->qd_hash"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&qd->qd_list"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "list->next",
            "structgfs2_quota_data",
            "qd_lru"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "list"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\n\nstatic void gfs2_qd_dispose(struct list_head *list)\n{\n\tstruct gfs2_quota_data *qd;\n\tstruct gfs2_sbd *sdp;\n\n\twhile (!list_empty(list)) {\n\t\tqd = list_entry(list->next, struct gfs2_quota_data, qd_lru);\n\t\tsdp = qd->qd_gl->gl_sbd;\n\n\t\tlist_del(&qd->qd_lru);\n\n\t\t/* Free from the filesystem-specific list */\n\t\tspin_lock(&qd_lock);\n\t\tlist_del(&qd->qd_list);\n\t\tspin_unlock(&qd_lock);\n\n\t\tspin_lock_bucket(qd->qd_hash);\n\t\thlist_bl_del_rcu(&qd->qd_hlist);\n\t\tspin_unlock_bucket(qd->qd_hash);\n\n\t\tgfs2_assert_warn(sdp, !qd->qd_change);\n\t\tgfs2_assert_warn(sdp, !qd->qd_slot_count);\n\t\tgfs2_assert_warn(sdp, !qd->qd_bh_count);\n\n\t\tgfs2_glock_put(qd->qd_gl);\n\t\tatomic_dec(&sdp->sd_quota_count);\n\n\t\t/* Delete it from the common reclaim list */\n\t\tcall_rcu(&qd->qd_rcu, gfs2_qd_dealloc);\n\t}\n}"
  },
  {
    "function_name": "gfs2_qd_dealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "109-113",
    "snippet": "static void gfs2_qd_dealloc(struct rcu_head *rcu)\n{\n\tstruct gfs2_quota_data *qd = container_of(rcu, struct gfs2_quota_data, qd_rcu);\n\tkmem_cache_free(gfs2_quotad_cachep, qd);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "gfs2_quotad_cachep",
            "qd"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structgfs2_quota_data",
            "qd_rcu"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void gfs2_qd_dealloc(struct rcu_head *rcu)\n{\n\tstruct gfs2_quota_data *qd = container_of(rcu, struct gfs2_quota_data, qd_rcu);\n\tkmem_cache_free(gfs2_quotad_cachep, qd);\n}"
  },
  {
    "function_name": "spin_unlock_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "104-107",
    "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_bl_unlock",
          "args": [
            "&qd_hash_table[hash]"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
  },
  {
    "function_name": "spin_lock_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "99-102",
    "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_bl_lock",
          "args": [
            "&qd_hash_table[hash]"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
  },
  {
    "function_name": "gfs2_qd_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
    "lines": "88-97",
    "snippet": "static unsigned int gfs2_qd_hash(const struct gfs2_sbd *sdp,\n\t\t\t\t const struct kqid qid)\n{\n\tunsigned int h;\n\n\th = jhash(&sdp, sizeof(struct gfs2_sbd *), 0);\n\th = jhash(&qid, sizeof(struct kqid), h);\n\n\treturn h & GFS2_QD_HASH_MASK;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"inode.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/lockref.h>",
      "#include <linux/dqblk_xfs.h>",
      "#include <linux/quota.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/bio.h>",
      "#include <linux/fs.h>",
      "#include <linux/sort.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define GFS2_QD_HASH_MASK       (GFS2_QD_HASH_SIZE - 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jhash",
          "args": [
            "&qid",
            "sizeof(struct kqid)",
            "h"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jhash",
          "args": [
            "&sdp",
            "sizeof(struct gfs2_sbd *)",
            "0"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define GFS2_QD_HASH_MASK       (GFS2_QD_HASH_SIZE - 1)\n\nstatic unsigned int gfs2_qd_hash(const struct gfs2_sbd *sdp,\n\t\t\t\t const struct kqid qid)\n{\n\tunsigned int h;\n\n\th = jhash(&sdp, sizeof(struct gfs2_sbd *), 0);\n\th = jhash(&qid, sizeof(struct kqid), h);\n\n\treturn h & GFS2_QD_HASH_MASK;\n}"
  }
]