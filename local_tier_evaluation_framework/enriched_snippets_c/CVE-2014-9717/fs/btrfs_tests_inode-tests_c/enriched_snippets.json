[
  {
    "function_name": "btrfs_test_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/inode-tests.c",
    "lines": "1105-1123",
    "snippet": "int btrfs_test_inodes(void)\n{\n\tint ret;\n\n\tset_bit(EXTENT_FLAG_COMPRESSED, &compressed_only);\n\tset_bit(EXTENT_FLAG_VACANCY, &vacancy_only);\n\tset_bit(EXTENT_FLAG_PREALLOC, &prealloc_only);\n\n\ttest_msg(\"Running btrfs_get_extent tests\\n\");\n\tret = test_btrfs_get_extent();\n\tif (ret)\n\t\treturn ret;\n\ttest_msg(\"Running hole first btrfs_get_extent test\\n\");\n\tret = test_hole_first();\n\tif (ret)\n\t\treturn ret;\n\ttest_msg(\"Running outstanding_extents tests\\n\");\n\treturn test_extent_accounting();\n}",
    "includes": [
      "#include \"../volumes.h\"",
      "#include \"../extent_io.h\"",
      "#include \"../disk-io.h\"",
      "#include \"../btrfs_inode.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long prealloc_only = 0;",
      "static unsigned long compressed_only = 0;",
      "static unsigned long vacancy_only = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_extent_accounting",
          "args": [],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "test_extent_accounting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/inode-tests.c",
          "lines": "914-1103",
          "snippet": "static int test_extent_accounting(void)\n{\n\tstruct inode *inode = NULL;\n\tstruct btrfs_root *root = NULL;\n\tint ret = -ENOMEM;\n\n\tinode = btrfs_new_test_inode();\n\tif (!inode) {\n\t\ttest_msg(\"Couldn't allocate inode\\n\");\n\t\treturn ret;\n\t}\n\n\troot = btrfs_alloc_dummy_root();\n\tif (IS_ERR(root)) {\n\t\ttest_msg(\"Couldn't allocate root\\n\");\n\t\tgoto out;\n\t}\n\n\troot->fs_info = btrfs_alloc_dummy_fs_info();\n\tif (!root->fs_info) {\n\t\ttest_msg(\"Couldn't allocate dummy fs info\\n\");\n\t\tgoto out;\n\t}\n\n\tBTRFS_I(inode)->root = root;\n\tbtrfs_test_inode_set_ops(inode);\n\n\t/* [BTRFS_MAX_EXTENT_SIZE] */\n\tBTRFS_I(inode)->outstanding_extents++;\n\tret = btrfs_set_extent_delalloc(inode, 0, BTRFS_MAX_EXTENT_SIZE - 1,\n\t\t\t\t\tNULL);\n\tif (ret) {\n\t\ttest_msg(\"btrfs_set_extent_delalloc returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 1) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 1, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/* [BTRFS_MAX_EXTENT_SIZE][4k] */\n\tBTRFS_I(inode)->outstanding_extents++;\n\tret = btrfs_set_extent_delalloc(inode, BTRFS_MAX_EXTENT_SIZE,\n\t\t\t\t\tBTRFS_MAX_EXTENT_SIZE + 4095, NULL);\n\tif (ret) {\n\t\ttest_msg(\"btrfs_set_extent_delalloc returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 2) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 2, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/* [BTRFS_MAX_EXTENT_SIZE/2][4K HOLE][the rest] */\n\tret = clear_extent_bit(&BTRFS_I(inode)->io_tree,\n\t\t\t       BTRFS_MAX_EXTENT_SIZE >> 1,\n\t\t\t       (BTRFS_MAX_EXTENT_SIZE >> 1) + 4095,\n\t\t\t       EXTENT_DELALLOC | EXTENT_DIRTY |\n\t\t\t       EXTENT_UPTODATE | EXTENT_DO_ACCOUNTING, 0, 0,\n\t\t\t       NULL, GFP_NOFS);\n\tif (ret) {\n\t\ttest_msg(\"clear_extent_bit returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 2) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 2, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/* [BTRFS_MAX_EXTENT_SIZE][4K] */\n\tBTRFS_I(inode)->outstanding_extents++;\n\tret = btrfs_set_extent_delalloc(inode, BTRFS_MAX_EXTENT_SIZE >> 1,\n\t\t\t\t\t(BTRFS_MAX_EXTENT_SIZE >> 1) + 4095,\n\t\t\t\t\tNULL);\n\tif (ret) {\n\t\ttest_msg(\"btrfs_set_extent_delalloc returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 2) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 2, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * [BTRFS_MAX_EXTENT_SIZE+4K][4K HOLE][BTRFS_MAX_EXTENT_SIZE+4K]\n\t *\n\t * I'm artificially adding 2 to outstanding_extents because in the\n\t * buffered IO case we'd add things up as we go, but I don't feel like\n\t * doing that here, this isn't the interesting case we want to test.\n\t */\n\tBTRFS_I(inode)->outstanding_extents += 2;\n\tret = btrfs_set_extent_delalloc(inode, BTRFS_MAX_EXTENT_SIZE + 8192,\n\t\t\t\t\t(BTRFS_MAX_EXTENT_SIZE << 1) + 12287,\n\t\t\t\t\tNULL);\n\tif (ret) {\n\t\ttest_msg(\"btrfs_set_extent_delalloc returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 4) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 4, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/* [BTRFS_MAX_EXTENT_SIZE+4k][4k][BTRFS_MAX_EXTENT_SIZE+4k] */\n\tBTRFS_I(inode)->outstanding_extents++;\n\tret = btrfs_set_extent_delalloc(inode, BTRFS_MAX_EXTENT_SIZE+4096,\n\t\t\t\t\tBTRFS_MAX_EXTENT_SIZE+8191, NULL);\n\tif (ret) {\n\t\ttest_msg(\"btrfs_set_extent_delalloc returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 3) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 3, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/* [BTRFS_MAX_EXTENT_SIZE+4k][4K HOLE][BTRFS_MAX_EXTENT_SIZE+4k] */\n\tret = clear_extent_bit(&BTRFS_I(inode)->io_tree,\n\t\t\t       BTRFS_MAX_EXTENT_SIZE+4096,\n\t\t\t       BTRFS_MAX_EXTENT_SIZE+8191,\n\t\t\t       EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t       EXTENT_DO_ACCOUNTING | EXTENT_UPTODATE, 0, 0,\n\t\t\t       NULL, GFP_NOFS);\n\tif (ret) {\n\t\ttest_msg(\"clear_extent_bit returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 4) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 4, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Refill the hole again just for good measure, because I thought it\n\t * might fail and I'd rather satisfy my paranoia at this point.\n\t */\n\tBTRFS_I(inode)->outstanding_extents++;\n\tret = btrfs_set_extent_delalloc(inode, BTRFS_MAX_EXTENT_SIZE+4096,\n\t\t\t\t\tBTRFS_MAX_EXTENT_SIZE+8191, NULL);\n\tif (ret) {\n\t\ttest_msg(\"btrfs_set_extent_delalloc returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 3) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 3, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/* Empty */\n\tret = clear_extent_bit(&BTRFS_I(inode)->io_tree, 0, (u64)-1,\n\t\t\t       EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t       EXTENT_DO_ACCOUNTING | EXTENT_UPTODATE, 0, 0,\n\t\t\t       NULL, GFP_NOFS);\n\tif (ret) {\n\t\ttest_msg(\"clear_extent_bit returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 0, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tif (ret)\n\t\tclear_extent_bit(&BTRFS_I(inode)->io_tree, 0, (u64)-1,\n\t\t\t\t EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t\t EXTENT_DO_ACCOUNTING | EXTENT_UPTODATE, 0, 0,\n\t\t\t\t NULL, GFP_NOFS);\n\tiput(inode);\n\tbtrfs_free_dummy_root(root);\n\treturn ret;\n}",
          "includes": [
            "#include \"../volumes.h\"",
            "#include \"../extent_io.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../btrfs_inode.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../volumes.h\"\n#include \"../extent_io.h\"\n#include \"../disk-io.h\"\n#include \"../btrfs_inode.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic int test_extent_accounting(void)\n{\n\tstruct inode *inode = NULL;\n\tstruct btrfs_root *root = NULL;\n\tint ret = -ENOMEM;\n\n\tinode = btrfs_new_test_inode();\n\tif (!inode) {\n\t\ttest_msg(\"Couldn't allocate inode\\n\");\n\t\treturn ret;\n\t}\n\n\troot = btrfs_alloc_dummy_root();\n\tif (IS_ERR(root)) {\n\t\ttest_msg(\"Couldn't allocate root\\n\");\n\t\tgoto out;\n\t}\n\n\troot->fs_info = btrfs_alloc_dummy_fs_info();\n\tif (!root->fs_info) {\n\t\ttest_msg(\"Couldn't allocate dummy fs info\\n\");\n\t\tgoto out;\n\t}\n\n\tBTRFS_I(inode)->root = root;\n\tbtrfs_test_inode_set_ops(inode);\n\n\t/* [BTRFS_MAX_EXTENT_SIZE] */\n\tBTRFS_I(inode)->outstanding_extents++;\n\tret = btrfs_set_extent_delalloc(inode, 0, BTRFS_MAX_EXTENT_SIZE - 1,\n\t\t\t\t\tNULL);\n\tif (ret) {\n\t\ttest_msg(\"btrfs_set_extent_delalloc returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 1) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 1, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/* [BTRFS_MAX_EXTENT_SIZE][4k] */\n\tBTRFS_I(inode)->outstanding_extents++;\n\tret = btrfs_set_extent_delalloc(inode, BTRFS_MAX_EXTENT_SIZE,\n\t\t\t\t\tBTRFS_MAX_EXTENT_SIZE + 4095, NULL);\n\tif (ret) {\n\t\ttest_msg(\"btrfs_set_extent_delalloc returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 2) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 2, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/* [BTRFS_MAX_EXTENT_SIZE/2][4K HOLE][the rest] */\n\tret = clear_extent_bit(&BTRFS_I(inode)->io_tree,\n\t\t\t       BTRFS_MAX_EXTENT_SIZE >> 1,\n\t\t\t       (BTRFS_MAX_EXTENT_SIZE >> 1) + 4095,\n\t\t\t       EXTENT_DELALLOC | EXTENT_DIRTY |\n\t\t\t       EXTENT_UPTODATE | EXTENT_DO_ACCOUNTING, 0, 0,\n\t\t\t       NULL, GFP_NOFS);\n\tif (ret) {\n\t\ttest_msg(\"clear_extent_bit returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 2) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 2, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/* [BTRFS_MAX_EXTENT_SIZE][4K] */\n\tBTRFS_I(inode)->outstanding_extents++;\n\tret = btrfs_set_extent_delalloc(inode, BTRFS_MAX_EXTENT_SIZE >> 1,\n\t\t\t\t\t(BTRFS_MAX_EXTENT_SIZE >> 1) + 4095,\n\t\t\t\t\tNULL);\n\tif (ret) {\n\t\ttest_msg(\"btrfs_set_extent_delalloc returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 2) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 2, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * [BTRFS_MAX_EXTENT_SIZE+4K][4K HOLE][BTRFS_MAX_EXTENT_SIZE+4K]\n\t *\n\t * I'm artificially adding 2 to outstanding_extents because in the\n\t * buffered IO case we'd add things up as we go, but I don't feel like\n\t * doing that here, this isn't the interesting case we want to test.\n\t */\n\tBTRFS_I(inode)->outstanding_extents += 2;\n\tret = btrfs_set_extent_delalloc(inode, BTRFS_MAX_EXTENT_SIZE + 8192,\n\t\t\t\t\t(BTRFS_MAX_EXTENT_SIZE << 1) + 12287,\n\t\t\t\t\tNULL);\n\tif (ret) {\n\t\ttest_msg(\"btrfs_set_extent_delalloc returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 4) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 4, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/* [BTRFS_MAX_EXTENT_SIZE+4k][4k][BTRFS_MAX_EXTENT_SIZE+4k] */\n\tBTRFS_I(inode)->outstanding_extents++;\n\tret = btrfs_set_extent_delalloc(inode, BTRFS_MAX_EXTENT_SIZE+4096,\n\t\t\t\t\tBTRFS_MAX_EXTENT_SIZE+8191, NULL);\n\tif (ret) {\n\t\ttest_msg(\"btrfs_set_extent_delalloc returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 3) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 3, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/* [BTRFS_MAX_EXTENT_SIZE+4k][4K HOLE][BTRFS_MAX_EXTENT_SIZE+4k] */\n\tret = clear_extent_bit(&BTRFS_I(inode)->io_tree,\n\t\t\t       BTRFS_MAX_EXTENT_SIZE+4096,\n\t\t\t       BTRFS_MAX_EXTENT_SIZE+8191,\n\t\t\t       EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t       EXTENT_DO_ACCOUNTING | EXTENT_UPTODATE, 0, 0,\n\t\t\t       NULL, GFP_NOFS);\n\tif (ret) {\n\t\ttest_msg(\"clear_extent_bit returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 4) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 4, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Refill the hole again just for good measure, because I thought it\n\t * might fail and I'd rather satisfy my paranoia at this point.\n\t */\n\tBTRFS_I(inode)->outstanding_extents++;\n\tret = btrfs_set_extent_delalloc(inode, BTRFS_MAX_EXTENT_SIZE+4096,\n\t\t\t\t\tBTRFS_MAX_EXTENT_SIZE+8191, NULL);\n\tif (ret) {\n\t\ttest_msg(\"btrfs_set_extent_delalloc returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 3) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 3, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/* Empty */\n\tret = clear_extent_bit(&BTRFS_I(inode)->io_tree, 0, (u64)-1,\n\t\t\t       EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t       EXTENT_DO_ACCOUNTING | EXTENT_UPTODATE, 0, 0,\n\t\t\t       NULL, GFP_NOFS);\n\tif (ret) {\n\t\ttest_msg(\"clear_extent_bit returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 0, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tif (ret)\n\t\tclear_extent_bit(&BTRFS_I(inode)->io_tree, 0, (u64)-1,\n\t\t\t\t EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t\t EXTENT_DO_ACCOUNTING | EXTENT_UPTODATE, 0, 0,\n\t\t\t\t NULL, GFP_NOFS);\n\tiput(inode);\n\tbtrfs_free_dummy_root(root);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Running outstanding_extents tests\\n\""
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_hole_first",
          "args": [],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "test_hole_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/inode-tests.c",
          "lines": "817-912",
          "snippet": "static int test_hole_first(void)\n{\n\tstruct inode *inode = NULL;\n\tstruct btrfs_root *root = NULL;\n\tstruct extent_map *em = NULL;\n\tint ret = -ENOMEM;\n\n\tinode = btrfs_new_test_inode();\n\tif (!inode) {\n\t\ttest_msg(\"Couldn't allocate inode\\n\");\n\t\treturn ret;\n\t}\n\n\tBTRFS_I(inode)->location.type = BTRFS_INODE_ITEM_KEY;\n\tBTRFS_I(inode)->location.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tBTRFS_I(inode)->location.offset = 0;\n\n\troot = btrfs_alloc_dummy_root();\n\tif (IS_ERR(root)) {\n\t\ttest_msg(\"Couldn't allocate root\\n\");\n\t\tgoto out;\n\t}\n\n\troot->fs_info = btrfs_alloc_dummy_fs_info();\n\tif (!root->fs_info) {\n\t\ttest_msg(\"Couldn't allocate dummy fs info\\n\");\n\t\tgoto out;\n\t}\n\n\troot->node = alloc_dummy_extent_buffer(NULL, 4096);\n\tif (!root->node) {\n\t\ttest_msg(\"Couldn't allocate dummy buffer\\n\");\n\t\tgoto out;\n\t}\n\n\textent_buffer_get(root->node);\n\tbtrfs_set_header_nritems(root->node, 0);\n\tbtrfs_set_header_level(root->node, 0);\n\tBTRFS_I(inode)->root = root;\n\tret = -EINVAL;\n\n\t/*\n\t * Need a blank inode item here just so we don't confuse\n\t * btrfs_get_extent.\n\t */\n\tinsert_inode_item_key(root);\n\tinsert_extent(root, 4096, 4096, 4096, 0, 4096, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, 1);\n\tem = btrfs_get_extent(inode, NULL, 0, 0, 8192, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a hole, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != 0 || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start 0 len 4096, got start \"\n\t\t\t \"%llu len %llu\\n\", em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != vacancy_only) {\n\t\ttest_msg(\"Wrong flags, wanted %lu, have %lu\\n\", vacancy_only,\n\t\t\t em->flags);\n\t\tgoto out;\n\t}\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, 4096, 8192, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != 4096) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != 4096 || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start 4096 len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, wanted 0 got %lu\\n\",\n\t\t\t em->flags);\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tif (!IS_ERR(em))\n\t\tfree_extent_map(em);\n\tiput(inode);\n\tbtrfs_free_dummy_root(root);\n\treturn ret;\n}",
          "includes": [
            "#include \"../volumes.h\"",
            "#include \"../extent_io.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../btrfs_inode.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long vacancy_only = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../volumes.h\"\n#include \"../extent_io.h\"\n#include \"../disk-io.h\"\n#include \"../btrfs_inode.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic unsigned long vacancy_only = 0;\n\nstatic int test_hole_first(void)\n{\n\tstruct inode *inode = NULL;\n\tstruct btrfs_root *root = NULL;\n\tstruct extent_map *em = NULL;\n\tint ret = -ENOMEM;\n\n\tinode = btrfs_new_test_inode();\n\tif (!inode) {\n\t\ttest_msg(\"Couldn't allocate inode\\n\");\n\t\treturn ret;\n\t}\n\n\tBTRFS_I(inode)->location.type = BTRFS_INODE_ITEM_KEY;\n\tBTRFS_I(inode)->location.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tBTRFS_I(inode)->location.offset = 0;\n\n\troot = btrfs_alloc_dummy_root();\n\tif (IS_ERR(root)) {\n\t\ttest_msg(\"Couldn't allocate root\\n\");\n\t\tgoto out;\n\t}\n\n\troot->fs_info = btrfs_alloc_dummy_fs_info();\n\tif (!root->fs_info) {\n\t\ttest_msg(\"Couldn't allocate dummy fs info\\n\");\n\t\tgoto out;\n\t}\n\n\troot->node = alloc_dummy_extent_buffer(NULL, 4096);\n\tif (!root->node) {\n\t\ttest_msg(\"Couldn't allocate dummy buffer\\n\");\n\t\tgoto out;\n\t}\n\n\textent_buffer_get(root->node);\n\tbtrfs_set_header_nritems(root->node, 0);\n\tbtrfs_set_header_level(root->node, 0);\n\tBTRFS_I(inode)->root = root;\n\tret = -EINVAL;\n\n\t/*\n\t * Need a blank inode item here just so we don't confuse\n\t * btrfs_get_extent.\n\t */\n\tinsert_inode_item_key(root);\n\tinsert_extent(root, 4096, 4096, 4096, 0, 4096, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, 1);\n\tem = btrfs_get_extent(inode, NULL, 0, 0, 8192, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a hole, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != 0 || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start 0 len 4096, got start \"\n\t\t\t \"%llu len %llu\\n\", em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != vacancy_only) {\n\t\ttest_msg(\"Wrong flags, wanted %lu, have %lu\\n\", vacancy_only,\n\t\t\t em->flags);\n\t\tgoto out;\n\t}\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, 4096, 8192, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != 4096) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != 4096 || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start 4096 len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, wanted 0 got %lu\\n\",\n\t\t\t em->flags);\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tif (!IS_ERR(em))\n\t\tfree_extent_map(em);\n\tiput(inode);\n\tbtrfs_free_dummy_root(root);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Running hole first btrfs_get_extent test\\n\""
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_btrfs_get_extent",
          "args": [],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "test_btrfs_get_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/inode-tests.c",
          "lines": "222-815",
          "snippet": "static noinline int test_btrfs_get_extent(void)\n{\n\tstruct inode *inode = NULL;\n\tstruct btrfs_root *root = NULL;\n\tstruct extent_map *em = NULL;\n\tu64 orig_start;\n\tu64 disk_bytenr;\n\tu64 offset;\n\tint ret = -ENOMEM;\n\n\tinode = btrfs_new_test_inode();\n\tif (!inode) {\n\t\ttest_msg(\"Couldn't allocate inode\\n\");\n\t\treturn ret;\n\t}\n\n\tBTRFS_I(inode)->location.type = BTRFS_INODE_ITEM_KEY;\n\tBTRFS_I(inode)->location.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tBTRFS_I(inode)->location.offset = 0;\n\n\troot = btrfs_alloc_dummy_root();\n\tif (IS_ERR(root)) {\n\t\ttest_msg(\"Couldn't allocate root\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We do this since btrfs_get_extent wants to assign em->bdev to\n\t * root->fs_info->fs_devices->latest_bdev.\n\t */\n\troot->fs_info = btrfs_alloc_dummy_fs_info();\n\tif (!root->fs_info) {\n\t\ttest_msg(\"Couldn't allocate dummy fs info\\n\");\n\t\tgoto out;\n\t}\n\n\troot->node = alloc_dummy_extent_buffer(NULL, 4096);\n\tif (!root->node) {\n\t\ttest_msg(\"Couldn't allocate dummy buffer\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We will just free a dummy node if it's ref count is 2 so we need an\n\t * extra ref so our searches don't accidently release our page.\n\t */\n\textent_buffer_get(root->node);\n\tbtrfs_set_header_nritems(root->node, 0);\n\tbtrfs_set_header_level(root->node, 0);\n\tret = -EINVAL;\n\n\t/* First with no extents */\n\tBTRFS_I(inode)->root = root;\n\tem = btrfs_get_extent(inode, NULL, 0, 0, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\tem = NULL;\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a hole, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (!test_bit(EXTENT_FLAG_VACANCY, &em->flags)) {\n\t\ttest_msg(\"Vacancy flag wasn't set properly\\n\");\n\t\tgoto out;\n\t}\n\tfree_extent_map(em);\n\tbtrfs_drop_extent_cache(inode, 0, (u64)-1, 0);\n\n\t/*\n\t * All of the magic numbers are based on the mapping setup in\n\t * setup_file_extents, so if you change anything there you need to\n\t * update the comment and update the expected values below.\n\t */\n\tsetup_file_extents(root);\n\n\tem = btrfs_get_extent(inode, NULL, 0, 0, (u64)-1, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a hole, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != 0 || em->len != 5) {\n\t\ttest_msg(\"Unexpected extent wanted start 0 len 5, got start \"\n\t\t\t \"%llu len %llu\\n\", em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_INLINE) {\n\t\ttest_msg(\"Expected an inline, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4091) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 1, got start \"\n\t\t\t \"%llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\t/*\n\t * We don't test anything else for inline since it doesn't get set\n\t * unless we have a page for it to write into.  Maybe we should change\n\t * this?\n\t */\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a hole, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4, got start \"\n\t\t\t \"%llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* Regular extent */\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4095) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4095, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* The next 3 are split extents */\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\tdisk_bytenr = em->block_start;\n\torig_start = em->start;\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a hole, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 8192) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 8192, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != orig_start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\",\n\t\t\t orig_start, em->orig_start);\n\t\tgoto out;\n\t}\n\tdisk_bytenr += (em->start - orig_start);\n\tif (em->block_start != disk_bytenr) {\n\t\ttest_msg(\"Wrong block start, want %llu, have %llu\\n\",\n\t\t\t disk_bytenr, em->block_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* Prealloc extent */\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != prealloc_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t prealloc_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* The next 3 are a half written prealloc extent */\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != prealloc_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t prealloc_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\tdisk_bytenr = em->block_start;\n\torig_start = em->start;\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != orig_start) {\n\t\ttest_msg(\"Unexpected orig offset, wanted %llu, have %llu\\n\",\n\t\t\t orig_start, em->orig_start);\n\t\tgoto out;\n\t}\n\tif (em->block_start != (disk_bytenr + (em->start - em->orig_start))) {\n\t\ttest_msg(\"Unexpected block start, wanted %llu, have %llu\\n\",\n\t\t\t disk_bytenr + (em->start - em->orig_start),\n\t\t\t em->block_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 8192) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 8192, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != prealloc_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t prealloc_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != orig_start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", orig_start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\tif (em->block_start != (disk_bytenr + (em->start - em->orig_start))) {\n\t\ttest_msg(\"Unexpected block start, wanted %llu, have %llu\\n\",\n\t\t\t disk_bytenr + (em->start - em->orig_start),\n\t\t\t em->block_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* Now for the compressed extent */\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 8192) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 8192, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != compressed_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t compressed_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\",\n\t\t\t em->start, em->orig_start);\n\t\tgoto out;\n\t}\n\tif (em->compress_type != BTRFS_COMPRESS_ZLIB) {\n\t\ttest_msg(\"Unexpected compress type, wanted %d, got %d\\n\",\n\t\t\t BTRFS_COMPRESS_ZLIB, em->compress_type);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* Split compressed extent */\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != compressed_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t compressed_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\",\n\t\t\t em->start, em->orig_start);\n\t\tgoto out;\n\t}\n\tif (em->compress_type != BTRFS_COMPRESS_ZLIB) {\n\t\ttest_msg(\"Unexpected compress type, wanted %d, got %d\\n\",\n\t\t\t BTRFS_COMPRESS_ZLIB, em->compress_type);\n\t\tgoto out;\n\t}\n\tdisk_bytenr = em->block_start;\n\torig_start = em->start;\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != disk_bytenr) {\n\t\ttest_msg(\"Block start does not match, want %llu got %llu\\n\",\n\t\t\t disk_bytenr, em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 8192) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 8192, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != compressed_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t compressed_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != orig_start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\",\n\t\t\t em->start, orig_start);\n\t\tgoto out;\n\t}\n\tif (em->compress_type != BTRFS_COMPRESS_ZLIB) {\n\t\ttest_msg(\"Unexpected compress type, wanted %d, got %d\\n\",\n\t\t\t BTRFS_COMPRESS_ZLIB, em->compress_type);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* A hole between regular extents but no hole extent */\n\tem = btrfs_get_extent(inode, NULL, 0, offset + 6, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096 * 1024, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a hole extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\t/*\n\t * Currently we just return a length that we requested rather than the\n\t * length of the actual hole, if this changes we'll have to change this\n\t * test.\n\t */\n\tif (em->start != offset || em->len != 12288) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 12288, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != vacancy_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t vacancy_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tif (!IS_ERR(em))\n\t\tfree_extent_map(em);\n\tiput(inode);\n\tbtrfs_free_dummy_root(root);\n\treturn ret;\n}",
          "includes": [
            "#include \"../volumes.h\"",
            "#include \"../extent_io.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../btrfs_inode.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long prealloc_only = 0;",
            "static unsigned long compressed_only = 0;",
            "static unsigned long vacancy_only = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../volumes.h\"\n#include \"../extent_io.h\"\n#include \"../disk-io.h\"\n#include \"../btrfs_inode.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic unsigned long prealloc_only = 0;\nstatic unsigned long compressed_only = 0;\nstatic unsigned long vacancy_only = 0;\n\nstatic noinline int test_btrfs_get_extent(void)\n{\n\tstruct inode *inode = NULL;\n\tstruct btrfs_root *root = NULL;\n\tstruct extent_map *em = NULL;\n\tu64 orig_start;\n\tu64 disk_bytenr;\n\tu64 offset;\n\tint ret = -ENOMEM;\n\n\tinode = btrfs_new_test_inode();\n\tif (!inode) {\n\t\ttest_msg(\"Couldn't allocate inode\\n\");\n\t\treturn ret;\n\t}\n\n\tBTRFS_I(inode)->location.type = BTRFS_INODE_ITEM_KEY;\n\tBTRFS_I(inode)->location.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tBTRFS_I(inode)->location.offset = 0;\n\n\troot = btrfs_alloc_dummy_root();\n\tif (IS_ERR(root)) {\n\t\ttest_msg(\"Couldn't allocate root\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We do this since btrfs_get_extent wants to assign em->bdev to\n\t * root->fs_info->fs_devices->latest_bdev.\n\t */\n\troot->fs_info = btrfs_alloc_dummy_fs_info();\n\tif (!root->fs_info) {\n\t\ttest_msg(\"Couldn't allocate dummy fs info\\n\");\n\t\tgoto out;\n\t}\n\n\troot->node = alloc_dummy_extent_buffer(NULL, 4096);\n\tif (!root->node) {\n\t\ttest_msg(\"Couldn't allocate dummy buffer\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We will just free a dummy node if it's ref count is 2 so we need an\n\t * extra ref so our searches don't accidently release our page.\n\t */\n\textent_buffer_get(root->node);\n\tbtrfs_set_header_nritems(root->node, 0);\n\tbtrfs_set_header_level(root->node, 0);\n\tret = -EINVAL;\n\n\t/* First with no extents */\n\tBTRFS_I(inode)->root = root;\n\tem = btrfs_get_extent(inode, NULL, 0, 0, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\tem = NULL;\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a hole, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (!test_bit(EXTENT_FLAG_VACANCY, &em->flags)) {\n\t\ttest_msg(\"Vacancy flag wasn't set properly\\n\");\n\t\tgoto out;\n\t}\n\tfree_extent_map(em);\n\tbtrfs_drop_extent_cache(inode, 0, (u64)-1, 0);\n\n\t/*\n\t * All of the magic numbers are based on the mapping setup in\n\t * setup_file_extents, so if you change anything there you need to\n\t * update the comment and update the expected values below.\n\t */\n\tsetup_file_extents(root);\n\n\tem = btrfs_get_extent(inode, NULL, 0, 0, (u64)-1, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a hole, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != 0 || em->len != 5) {\n\t\ttest_msg(\"Unexpected extent wanted start 0 len 5, got start \"\n\t\t\t \"%llu len %llu\\n\", em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_INLINE) {\n\t\ttest_msg(\"Expected an inline, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4091) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 1, got start \"\n\t\t\t \"%llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\t/*\n\t * We don't test anything else for inline since it doesn't get set\n\t * unless we have a page for it to write into.  Maybe we should change\n\t * this?\n\t */\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a hole, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4, got start \"\n\t\t\t \"%llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* Regular extent */\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4095) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4095, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* The next 3 are split extents */\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\tdisk_bytenr = em->block_start;\n\torig_start = em->start;\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a hole, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 8192) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 8192, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != orig_start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\",\n\t\t\t orig_start, em->orig_start);\n\t\tgoto out;\n\t}\n\tdisk_bytenr += (em->start - orig_start);\n\tif (em->block_start != disk_bytenr) {\n\t\ttest_msg(\"Wrong block start, want %llu, have %llu\\n\",\n\t\t\t disk_bytenr, em->block_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* Prealloc extent */\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != prealloc_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t prealloc_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* The next 3 are a half written prealloc extent */\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != prealloc_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t prealloc_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\tdisk_bytenr = em->block_start;\n\torig_start = em->start;\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != orig_start) {\n\t\ttest_msg(\"Unexpected orig offset, wanted %llu, have %llu\\n\",\n\t\t\t orig_start, em->orig_start);\n\t\tgoto out;\n\t}\n\tif (em->block_start != (disk_bytenr + (em->start - em->orig_start))) {\n\t\ttest_msg(\"Unexpected block start, wanted %llu, have %llu\\n\",\n\t\t\t disk_bytenr + (em->start - em->orig_start),\n\t\t\t em->block_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 8192) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 8192, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != prealloc_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t prealloc_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != orig_start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", orig_start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\tif (em->block_start != (disk_bytenr + (em->start - em->orig_start))) {\n\t\ttest_msg(\"Unexpected block start, wanted %llu, have %llu\\n\",\n\t\t\t disk_bytenr + (em->start - em->orig_start),\n\t\t\t em->block_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* Now for the compressed extent */\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 8192) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 8192, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != compressed_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t compressed_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\",\n\t\t\t em->start, em->orig_start);\n\t\tgoto out;\n\t}\n\tif (em->compress_type != BTRFS_COMPRESS_ZLIB) {\n\t\ttest_msg(\"Unexpected compress type, wanted %d, got %d\\n\",\n\t\t\t BTRFS_COMPRESS_ZLIB, em->compress_type);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* Split compressed extent */\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != compressed_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t compressed_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\",\n\t\t\t em->start, em->orig_start);\n\t\tgoto out;\n\t}\n\tif (em->compress_type != BTRFS_COMPRESS_ZLIB) {\n\t\ttest_msg(\"Unexpected compress type, wanted %d, got %d\\n\",\n\t\t\t BTRFS_COMPRESS_ZLIB, em->compress_type);\n\t\tgoto out;\n\t}\n\tdisk_bytenr = em->block_start;\n\torig_start = em->start;\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != disk_bytenr) {\n\t\ttest_msg(\"Block start does not match, want %llu got %llu\\n\",\n\t\t\t disk_bytenr, em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 8192) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 8192, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != compressed_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t compressed_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != orig_start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\",\n\t\t\t em->start, orig_start);\n\t\tgoto out;\n\t}\n\tif (em->compress_type != BTRFS_COMPRESS_ZLIB) {\n\t\ttest_msg(\"Unexpected compress type, wanted %d, got %d\\n\",\n\t\t\t BTRFS_COMPRESS_ZLIB, em->compress_type);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* A hole between regular extents but no hole extent */\n\tem = btrfs_get_extent(inode, NULL, 0, offset + 6, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096 * 1024, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a hole extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\t/*\n\t * Currently we just return a length that we requested rather than the\n\t * length of the actual hole, if this changes we'll have to change this\n\t * test.\n\t */\n\tif (em->start != offset || em->len != 12288) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 12288, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != vacancy_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t vacancy_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tif (!IS_ERR(em))\n\t\tfree_extent_map(em);\n\tiput(inode);\n\tbtrfs_free_dummy_root(root);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Running btrfs_get_extent tests\\n\""
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EXTENT_FLAG_PREALLOC",
            "&prealloc_only"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../volumes.h\"\n#include \"../extent_io.h\"\n#include \"../disk-io.h\"\n#include \"../btrfs_inode.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic unsigned long prealloc_only = 0;\nstatic unsigned long compressed_only = 0;\nstatic unsigned long vacancy_only = 0;\n\nint btrfs_test_inodes(void)\n{\n\tint ret;\n\n\tset_bit(EXTENT_FLAG_COMPRESSED, &compressed_only);\n\tset_bit(EXTENT_FLAG_VACANCY, &vacancy_only);\n\tset_bit(EXTENT_FLAG_PREALLOC, &prealloc_only);\n\n\ttest_msg(\"Running btrfs_get_extent tests\\n\");\n\tret = test_btrfs_get_extent();\n\tif (ret)\n\t\treturn ret;\n\ttest_msg(\"Running hole first btrfs_get_extent test\\n\");\n\tret = test_hole_first();\n\tif (ret)\n\t\treturn ret;\n\ttest_msg(\"Running outstanding_extents tests\\n\");\n\treturn test_extent_accounting();\n}"
  },
  {
    "function_name": "test_extent_accounting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/inode-tests.c",
    "lines": "914-1103",
    "snippet": "static int test_extent_accounting(void)\n{\n\tstruct inode *inode = NULL;\n\tstruct btrfs_root *root = NULL;\n\tint ret = -ENOMEM;\n\n\tinode = btrfs_new_test_inode();\n\tif (!inode) {\n\t\ttest_msg(\"Couldn't allocate inode\\n\");\n\t\treturn ret;\n\t}\n\n\troot = btrfs_alloc_dummy_root();\n\tif (IS_ERR(root)) {\n\t\ttest_msg(\"Couldn't allocate root\\n\");\n\t\tgoto out;\n\t}\n\n\troot->fs_info = btrfs_alloc_dummy_fs_info();\n\tif (!root->fs_info) {\n\t\ttest_msg(\"Couldn't allocate dummy fs info\\n\");\n\t\tgoto out;\n\t}\n\n\tBTRFS_I(inode)->root = root;\n\tbtrfs_test_inode_set_ops(inode);\n\n\t/* [BTRFS_MAX_EXTENT_SIZE] */\n\tBTRFS_I(inode)->outstanding_extents++;\n\tret = btrfs_set_extent_delalloc(inode, 0, BTRFS_MAX_EXTENT_SIZE - 1,\n\t\t\t\t\tNULL);\n\tif (ret) {\n\t\ttest_msg(\"btrfs_set_extent_delalloc returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 1) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 1, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/* [BTRFS_MAX_EXTENT_SIZE][4k] */\n\tBTRFS_I(inode)->outstanding_extents++;\n\tret = btrfs_set_extent_delalloc(inode, BTRFS_MAX_EXTENT_SIZE,\n\t\t\t\t\tBTRFS_MAX_EXTENT_SIZE + 4095, NULL);\n\tif (ret) {\n\t\ttest_msg(\"btrfs_set_extent_delalloc returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 2) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 2, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/* [BTRFS_MAX_EXTENT_SIZE/2][4K HOLE][the rest] */\n\tret = clear_extent_bit(&BTRFS_I(inode)->io_tree,\n\t\t\t       BTRFS_MAX_EXTENT_SIZE >> 1,\n\t\t\t       (BTRFS_MAX_EXTENT_SIZE >> 1) + 4095,\n\t\t\t       EXTENT_DELALLOC | EXTENT_DIRTY |\n\t\t\t       EXTENT_UPTODATE | EXTENT_DO_ACCOUNTING, 0, 0,\n\t\t\t       NULL, GFP_NOFS);\n\tif (ret) {\n\t\ttest_msg(\"clear_extent_bit returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 2) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 2, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/* [BTRFS_MAX_EXTENT_SIZE][4K] */\n\tBTRFS_I(inode)->outstanding_extents++;\n\tret = btrfs_set_extent_delalloc(inode, BTRFS_MAX_EXTENT_SIZE >> 1,\n\t\t\t\t\t(BTRFS_MAX_EXTENT_SIZE >> 1) + 4095,\n\t\t\t\t\tNULL);\n\tif (ret) {\n\t\ttest_msg(\"btrfs_set_extent_delalloc returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 2) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 2, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * [BTRFS_MAX_EXTENT_SIZE+4K][4K HOLE][BTRFS_MAX_EXTENT_SIZE+4K]\n\t *\n\t * I'm artificially adding 2 to outstanding_extents because in the\n\t * buffered IO case we'd add things up as we go, but I don't feel like\n\t * doing that here, this isn't the interesting case we want to test.\n\t */\n\tBTRFS_I(inode)->outstanding_extents += 2;\n\tret = btrfs_set_extent_delalloc(inode, BTRFS_MAX_EXTENT_SIZE + 8192,\n\t\t\t\t\t(BTRFS_MAX_EXTENT_SIZE << 1) + 12287,\n\t\t\t\t\tNULL);\n\tif (ret) {\n\t\ttest_msg(\"btrfs_set_extent_delalloc returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 4) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 4, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/* [BTRFS_MAX_EXTENT_SIZE+4k][4k][BTRFS_MAX_EXTENT_SIZE+4k] */\n\tBTRFS_I(inode)->outstanding_extents++;\n\tret = btrfs_set_extent_delalloc(inode, BTRFS_MAX_EXTENT_SIZE+4096,\n\t\t\t\t\tBTRFS_MAX_EXTENT_SIZE+8191, NULL);\n\tif (ret) {\n\t\ttest_msg(\"btrfs_set_extent_delalloc returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 3) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 3, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/* [BTRFS_MAX_EXTENT_SIZE+4k][4K HOLE][BTRFS_MAX_EXTENT_SIZE+4k] */\n\tret = clear_extent_bit(&BTRFS_I(inode)->io_tree,\n\t\t\t       BTRFS_MAX_EXTENT_SIZE+4096,\n\t\t\t       BTRFS_MAX_EXTENT_SIZE+8191,\n\t\t\t       EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t       EXTENT_DO_ACCOUNTING | EXTENT_UPTODATE, 0, 0,\n\t\t\t       NULL, GFP_NOFS);\n\tif (ret) {\n\t\ttest_msg(\"clear_extent_bit returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 4) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 4, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Refill the hole again just for good measure, because I thought it\n\t * might fail and I'd rather satisfy my paranoia at this point.\n\t */\n\tBTRFS_I(inode)->outstanding_extents++;\n\tret = btrfs_set_extent_delalloc(inode, BTRFS_MAX_EXTENT_SIZE+4096,\n\t\t\t\t\tBTRFS_MAX_EXTENT_SIZE+8191, NULL);\n\tif (ret) {\n\t\ttest_msg(\"btrfs_set_extent_delalloc returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 3) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 3, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/* Empty */\n\tret = clear_extent_bit(&BTRFS_I(inode)->io_tree, 0, (u64)-1,\n\t\t\t       EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t       EXTENT_DO_ACCOUNTING | EXTENT_UPTODATE, 0, 0,\n\t\t\t       NULL, GFP_NOFS);\n\tif (ret) {\n\t\ttest_msg(\"clear_extent_bit returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 0, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tif (ret)\n\t\tclear_extent_bit(&BTRFS_I(inode)->io_tree, 0, (u64)-1,\n\t\t\t\t EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t\t EXTENT_DO_ACCOUNTING | EXTENT_UPTODATE, 0, 0,\n\t\t\t\t NULL, GFP_NOFS);\n\tiput(inode);\n\tbtrfs_free_dummy_root(root);\n\treturn ret;\n}",
    "includes": [
      "#include \"../volumes.h\"",
      "#include \"../extent_io.h\"",
      "#include \"../disk-io.h\"",
      "#include \"../btrfs_inode.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_dummy_root",
          "args": [
            "root"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_dummy_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.c",
          "lines": "161-170",
          "snippet": "void btrfs_free_dummy_root(struct btrfs_root *root)\n{\n\tif (!root)\n\t\treturn;\n\tif (root->node)\n\t\tfree_extent_buffer(root->node);\n\tif (root->fs_info)\n\t\tbtrfs_free_dummy_fs_info(root->fs_info);\n\tkfree(root);\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../volumes.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\"",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../volumes.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid btrfs_free_dummy_root(struct btrfs_root *root)\n{\n\tif (!root)\n\t\treturn;\n\tif (root->node)\n\t\tfree_extent_buffer(root->node);\n\tif (root->fs_info)\n\t\tbtrfs_free_dummy_fs_info(root->fs_info);\n\tkfree(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_extent_bit",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "0",
            "(u64)-1",
            "EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t\t EXTENT_DO_ACCOUNTING | EXTENT_UPTODATE",
            "0",
            "0",
            "NULL",
            "GFP_NOFS"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "572-724",
          "snippet": "int clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Miscount, wanted 0, got %u\\n\"",
            "BTRFS_I(inode)->outstanding_extents"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"clear_extent_bit returned %d\\n\"",
            "ret"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Miscount, wanted 3, got %u\\n\"",
            "BTRFS_I(inode)->outstanding_extents"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"btrfs_set_extent_delalloc returned %d\\n\"",
            "ret"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_extent_delalloc",
          "args": [
            "inode",
            "BTRFS_MAX_EXTENT_SIZE+4096",
            "BTRFS_MAX_EXTENT_SIZE+8191",
            "NULL"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_extent_delalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "1933-1939",
          "snippet": "int btrfs_set_extent_delalloc(struct inode *inode, u64 start, u64 end,\n\t\t\t      struct extent_state **cached_state)\n{\n\tWARN_ON((end & (PAGE_CACHE_SIZE - 1)) == 0);\n\treturn set_extent_delalloc(&BTRFS_I(inode)->io_tree, start, end,\n\t\t\t\t   cached_state, GFP_NOFS);\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_set_extent_delalloc(struct inode *inode, u64 start, u64 end,\n\t\t\t      struct extent_state **cached_state)\n{\n\tWARN_ON((end & (PAGE_CACHE_SIZE - 1)) == 0);\n\treturn set_extent_delalloc(&BTRFS_I(inode)->io_tree, start, end,\n\t\t\t\t   cached_state, GFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Miscount, wanted 4, got %u\\n\"",
            "BTRFS_I(inode)->outstanding_extents"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"clear_extent_bit returned %d\\n\"",
            "ret"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Miscount, wanted 3, got %u\\n\"",
            "BTRFS_I(inode)->outstanding_extents"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"btrfs_set_extent_delalloc returned %d\\n\"",
            "ret"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Miscount, wanted 4, got %u\\n\"",
            "BTRFS_I(inode)->outstanding_extents"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"btrfs_set_extent_delalloc returned %d\\n\"",
            "ret"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Miscount, wanted 2, got %u\\n\"",
            "BTRFS_I(inode)->outstanding_extents"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"btrfs_set_extent_delalloc returned %d\\n\"",
            "ret"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Miscount, wanted 2, got %u\\n\"",
            "BTRFS_I(inode)->outstanding_extents"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"clear_extent_bit returned %d\\n\"",
            "ret"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Miscount, wanted 2, got %u\\n\"",
            "BTRFS_I(inode)->outstanding_extents"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"btrfs_set_extent_delalloc returned %d\\n\"",
            "ret"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Miscount, wanted 1, got %u\\n\"",
            "BTRFS_I(inode)->outstanding_extents"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"btrfs_set_extent_delalloc returned %d\\n\"",
            "ret"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_inode_set_ops",
          "args": [
            "inode"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_test_inode_set_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "112-115",
          "snippet": "void btrfs_test_inode_set_ops(struct inode *inode)\n{\n\tBTRFS_I(inode)->io_tree.ops = &btrfs_extent_io_ops;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct extent_io_ops btrfs_extent_io_ops;",
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);",
            "static struct extent_io_ops btrfs_extent_io_ops = {\n\t.fill_delalloc = run_delalloc_range,\n\t.submit_bio_hook = btrfs_submit_bio_hook,\n\t.merge_bio_hook = btrfs_merge_bio_hook,\n\t.readpage_end_io_hook = btrfs_readpage_end_io_hook,\n\t.writepage_end_io_hook = btrfs_writepage_end_io_hook,\n\t.writepage_start_hook = btrfs_writepage_start_hook,\n\t.set_bit_hook = btrfs_set_bit_hook,\n\t.clear_bit_hook = btrfs_clear_bit_hook,\n\t.merge_extent_hook = btrfs_merge_extent_hook,\n\t.split_extent_hook = btrfs_split_extent_hook,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic struct extent_io_ops btrfs_extent_io_ops;\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\nstatic struct extent_io_ops btrfs_extent_io_ops = {\n\t.fill_delalloc = run_delalloc_range,\n\t.submit_bio_hook = btrfs_submit_bio_hook,\n\t.merge_bio_hook = btrfs_merge_bio_hook,\n\t.readpage_end_io_hook = btrfs_readpage_end_io_hook,\n\t.writepage_end_io_hook = btrfs_writepage_end_io_hook,\n\t.writepage_start_hook = btrfs_writepage_start_hook,\n\t.set_bit_hook = btrfs_set_bit_hook,\n\t.clear_bit_hook = btrfs_clear_bit_hook,\n\t.merge_extent_hook = btrfs_merge_extent_hook,\n\t.split_extent_hook = btrfs_split_extent_hook,\n};\n\nvoid btrfs_test_inode_set_ops(struct inode *inode)\n{\n\tBTRFS_I(inode)->io_tree.ops = &btrfs_extent_io_ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't allocate dummy fs info\\n\""
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_dummy_fs_info",
          "args": [],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_dummy_fs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.c",
          "lines": "79-126",
          "snippet": "struct btrfs_fs_info *btrfs_alloc_dummy_fs_info(void)\n{\n\tstruct btrfs_fs_info *fs_info = kzalloc(sizeof(struct btrfs_fs_info),\n\t\t\t\t\t\tGFP_NOFS);\n\n\tif (!fs_info)\n\t\treturn fs_info;\n\tfs_info->fs_devices = kzalloc(sizeof(struct btrfs_fs_devices),\n\t\t\t\t      GFP_NOFS);\n\tif (!fs_info->fs_devices) {\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\tfs_info->super_copy = kzalloc(sizeof(struct btrfs_super_block),\n\t\t\t\t      GFP_NOFS);\n\tif (!fs_info->super_copy) {\n\t\tkfree(fs_info->fs_devices);\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\n\tif (init_srcu_struct(&fs_info->subvol_srcu)) {\n\t\tkfree(fs_info->fs_devices);\n\t\tkfree(fs_info->super_copy);\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_init(&fs_info->buffer_lock);\n\tspin_lock_init(&fs_info->qgroup_lock);\n\tspin_lock_init(&fs_info->qgroup_op_lock);\n\tspin_lock_init(&fs_info->super_lock);\n\tspin_lock_init(&fs_info->fs_roots_radix_lock);\n\tspin_lock_init(&fs_info->tree_mod_seq_lock);\n\tmutex_init(&fs_info->qgroup_ioctl_lock);\n\tmutex_init(&fs_info->qgroup_rescan_lock);\n\trwlock_init(&fs_info->tree_mod_log_lock);\n\tfs_info->running_transaction = NULL;\n\tfs_info->qgroup_tree = RB_ROOT;\n\tfs_info->qgroup_ulist = NULL;\n\tatomic64_set(&fs_info->tree_mod_seq, 0);\n\tINIT_LIST_HEAD(&fs_info->dirty_qgroups);\n\tINIT_LIST_HEAD(&fs_info->dead_roots);\n\tINIT_LIST_HEAD(&fs_info->tree_mod_seq_list);\n\tINIT_RADIX_TREE(&fs_info->buffer_radix, GFP_ATOMIC);\n\tINIT_RADIX_TREE(&fs_info->fs_roots_radix, GFP_ATOMIC);\n\treturn fs_info;\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../volumes.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\"",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../volumes.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstruct btrfs_fs_info *btrfs_alloc_dummy_fs_info(void)\n{\n\tstruct btrfs_fs_info *fs_info = kzalloc(sizeof(struct btrfs_fs_info),\n\t\t\t\t\t\tGFP_NOFS);\n\n\tif (!fs_info)\n\t\treturn fs_info;\n\tfs_info->fs_devices = kzalloc(sizeof(struct btrfs_fs_devices),\n\t\t\t\t      GFP_NOFS);\n\tif (!fs_info->fs_devices) {\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\tfs_info->super_copy = kzalloc(sizeof(struct btrfs_super_block),\n\t\t\t\t      GFP_NOFS);\n\tif (!fs_info->super_copy) {\n\t\tkfree(fs_info->fs_devices);\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\n\tif (init_srcu_struct(&fs_info->subvol_srcu)) {\n\t\tkfree(fs_info->fs_devices);\n\t\tkfree(fs_info->super_copy);\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_init(&fs_info->buffer_lock);\n\tspin_lock_init(&fs_info->qgroup_lock);\n\tspin_lock_init(&fs_info->qgroup_op_lock);\n\tspin_lock_init(&fs_info->super_lock);\n\tspin_lock_init(&fs_info->fs_roots_radix_lock);\n\tspin_lock_init(&fs_info->tree_mod_seq_lock);\n\tmutex_init(&fs_info->qgroup_ioctl_lock);\n\tmutex_init(&fs_info->qgroup_rescan_lock);\n\trwlock_init(&fs_info->tree_mod_log_lock);\n\tfs_info->running_transaction = NULL;\n\tfs_info->qgroup_tree = RB_ROOT;\n\tfs_info->qgroup_ulist = NULL;\n\tatomic64_set(&fs_info->tree_mod_seq, 0);\n\tINIT_LIST_HEAD(&fs_info->dirty_qgroups);\n\tINIT_LIST_HEAD(&fs_info->dead_roots);\n\tINIT_LIST_HEAD(&fs_info->tree_mod_seq_list);\n\tINIT_RADIX_TREE(&fs_info->buffer_radix, GFP_ATOMIC);\n\tINIT_RADIX_TREE(&fs_info->fs_roots_radix, GFP_ATOMIC);\n\treturn fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't allocate root\\n\""
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_dummy_root",
          "args": [],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_dummy_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1298-1310",
          "snippet": "struct btrfs_root *btrfs_alloc_dummy_root(void)\n{\n\tstruct btrfs_root *root;\n\n\troot = btrfs_alloc_root(NULL);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\t__setup_root(4096, 4096, 4096, root, NULL, 1);\n\tset_bit(BTRFS_ROOT_DUMMY_ROOT, &root->state);\n\troot->alloc_bytenr = 0;\n\n\treturn root;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct btrfs_root *btrfs_alloc_dummy_root(void)\n{\n\tstruct btrfs_root *root;\n\n\troot = btrfs_alloc_root(NULL);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\t__setup_root(4096, 4096, 4096, root, NULL, 1);\n\tset_bit(BTRFS_ROOT_DUMMY_ROOT, &root->state);\n\troot->alloc_bytenr = 0;\n\n\treturn root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't allocate inode\\n\""
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_new_test_inode",
          "args": [],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_new_test_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.c",
          "lines": "49-52",
          "snippet": "struct inode *btrfs_new_test_inode(void)\n{\n\treturn new_inode(test_mnt->mnt_sb);\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../volumes.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\"",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *test_mnt = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../volumes.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct vfsmount *test_mnt = NULL;\n\nstruct inode *btrfs_new_test_inode(void)\n{\n\treturn new_inode(test_mnt->mnt_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../volumes.h\"\n#include \"../extent_io.h\"\n#include \"../disk-io.h\"\n#include \"../btrfs_inode.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic int test_extent_accounting(void)\n{\n\tstruct inode *inode = NULL;\n\tstruct btrfs_root *root = NULL;\n\tint ret = -ENOMEM;\n\n\tinode = btrfs_new_test_inode();\n\tif (!inode) {\n\t\ttest_msg(\"Couldn't allocate inode\\n\");\n\t\treturn ret;\n\t}\n\n\troot = btrfs_alloc_dummy_root();\n\tif (IS_ERR(root)) {\n\t\ttest_msg(\"Couldn't allocate root\\n\");\n\t\tgoto out;\n\t}\n\n\troot->fs_info = btrfs_alloc_dummy_fs_info();\n\tif (!root->fs_info) {\n\t\ttest_msg(\"Couldn't allocate dummy fs info\\n\");\n\t\tgoto out;\n\t}\n\n\tBTRFS_I(inode)->root = root;\n\tbtrfs_test_inode_set_ops(inode);\n\n\t/* [BTRFS_MAX_EXTENT_SIZE] */\n\tBTRFS_I(inode)->outstanding_extents++;\n\tret = btrfs_set_extent_delalloc(inode, 0, BTRFS_MAX_EXTENT_SIZE - 1,\n\t\t\t\t\tNULL);\n\tif (ret) {\n\t\ttest_msg(\"btrfs_set_extent_delalloc returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 1) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 1, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/* [BTRFS_MAX_EXTENT_SIZE][4k] */\n\tBTRFS_I(inode)->outstanding_extents++;\n\tret = btrfs_set_extent_delalloc(inode, BTRFS_MAX_EXTENT_SIZE,\n\t\t\t\t\tBTRFS_MAX_EXTENT_SIZE + 4095, NULL);\n\tif (ret) {\n\t\ttest_msg(\"btrfs_set_extent_delalloc returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 2) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 2, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/* [BTRFS_MAX_EXTENT_SIZE/2][4K HOLE][the rest] */\n\tret = clear_extent_bit(&BTRFS_I(inode)->io_tree,\n\t\t\t       BTRFS_MAX_EXTENT_SIZE >> 1,\n\t\t\t       (BTRFS_MAX_EXTENT_SIZE >> 1) + 4095,\n\t\t\t       EXTENT_DELALLOC | EXTENT_DIRTY |\n\t\t\t       EXTENT_UPTODATE | EXTENT_DO_ACCOUNTING, 0, 0,\n\t\t\t       NULL, GFP_NOFS);\n\tif (ret) {\n\t\ttest_msg(\"clear_extent_bit returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 2) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 2, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/* [BTRFS_MAX_EXTENT_SIZE][4K] */\n\tBTRFS_I(inode)->outstanding_extents++;\n\tret = btrfs_set_extent_delalloc(inode, BTRFS_MAX_EXTENT_SIZE >> 1,\n\t\t\t\t\t(BTRFS_MAX_EXTENT_SIZE >> 1) + 4095,\n\t\t\t\t\tNULL);\n\tif (ret) {\n\t\ttest_msg(\"btrfs_set_extent_delalloc returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 2) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 2, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * [BTRFS_MAX_EXTENT_SIZE+4K][4K HOLE][BTRFS_MAX_EXTENT_SIZE+4K]\n\t *\n\t * I'm artificially adding 2 to outstanding_extents because in the\n\t * buffered IO case we'd add things up as we go, but I don't feel like\n\t * doing that here, this isn't the interesting case we want to test.\n\t */\n\tBTRFS_I(inode)->outstanding_extents += 2;\n\tret = btrfs_set_extent_delalloc(inode, BTRFS_MAX_EXTENT_SIZE + 8192,\n\t\t\t\t\t(BTRFS_MAX_EXTENT_SIZE << 1) + 12287,\n\t\t\t\t\tNULL);\n\tif (ret) {\n\t\ttest_msg(\"btrfs_set_extent_delalloc returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 4) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 4, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/* [BTRFS_MAX_EXTENT_SIZE+4k][4k][BTRFS_MAX_EXTENT_SIZE+4k] */\n\tBTRFS_I(inode)->outstanding_extents++;\n\tret = btrfs_set_extent_delalloc(inode, BTRFS_MAX_EXTENT_SIZE+4096,\n\t\t\t\t\tBTRFS_MAX_EXTENT_SIZE+8191, NULL);\n\tif (ret) {\n\t\ttest_msg(\"btrfs_set_extent_delalloc returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 3) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 3, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/* [BTRFS_MAX_EXTENT_SIZE+4k][4K HOLE][BTRFS_MAX_EXTENT_SIZE+4k] */\n\tret = clear_extent_bit(&BTRFS_I(inode)->io_tree,\n\t\t\t       BTRFS_MAX_EXTENT_SIZE+4096,\n\t\t\t       BTRFS_MAX_EXTENT_SIZE+8191,\n\t\t\t       EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t       EXTENT_DO_ACCOUNTING | EXTENT_UPTODATE, 0, 0,\n\t\t\t       NULL, GFP_NOFS);\n\tif (ret) {\n\t\ttest_msg(\"clear_extent_bit returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 4) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 4, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Refill the hole again just for good measure, because I thought it\n\t * might fail and I'd rather satisfy my paranoia at this point.\n\t */\n\tBTRFS_I(inode)->outstanding_extents++;\n\tret = btrfs_set_extent_delalloc(inode, BTRFS_MAX_EXTENT_SIZE+4096,\n\t\t\t\t\tBTRFS_MAX_EXTENT_SIZE+8191, NULL);\n\tif (ret) {\n\t\ttest_msg(\"btrfs_set_extent_delalloc returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents != 3) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 3, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\n\t/* Empty */\n\tret = clear_extent_bit(&BTRFS_I(inode)->io_tree, 0, (u64)-1,\n\t\t\t       EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t       EXTENT_DO_ACCOUNTING | EXTENT_UPTODATE, 0, 0,\n\t\t\t       NULL, GFP_NOFS);\n\tif (ret) {\n\t\ttest_msg(\"clear_extent_bit returned %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (BTRFS_I(inode)->outstanding_extents) {\n\t\tret = -EINVAL;\n\t\ttest_msg(\"Miscount, wanted 0, got %u\\n\",\n\t\t\t BTRFS_I(inode)->outstanding_extents);\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tif (ret)\n\t\tclear_extent_bit(&BTRFS_I(inode)->io_tree, 0, (u64)-1,\n\t\t\t\t EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t\t EXTENT_DO_ACCOUNTING | EXTENT_UPTODATE, 0, 0,\n\t\t\t\t NULL, GFP_NOFS);\n\tiput(inode);\n\tbtrfs_free_dummy_root(root);\n\treturn ret;\n}"
  },
  {
    "function_name": "test_hole_first",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/inode-tests.c",
    "lines": "817-912",
    "snippet": "static int test_hole_first(void)\n{\n\tstruct inode *inode = NULL;\n\tstruct btrfs_root *root = NULL;\n\tstruct extent_map *em = NULL;\n\tint ret = -ENOMEM;\n\n\tinode = btrfs_new_test_inode();\n\tif (!inode) {\n\t\ttest_msg(\"Couldn't allocate inode\\n\");\n\t\treturn ret;\n\t}\n\n\tBTRFS_I(inode)->location.type = BTRFS_INODE_ITEM_KEY;\n\tBTRFS_I(inode)->location.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tBTRFS_I(inode)->location.offset = 0;\n\n\troot = btrfs_alloc_dummy_root();\n\tif (IS_ERR(root)) {\n\t\ttest_msg(\"Couldn't allocate root\\n\");\n\t\tgoto out;\n\t}\n\n\troot->fs_info = btrfs_alloc_dummy_fs_info();\n\tif (!root->fs_info) {\n\t\ttest_msg(\"Couldn't allocate dummy fs info\\n\");\n\t\tgoto out;\n\t}\n\n\troot->node = alloc_dummy_extent_buffer(NULL, 4096);\n\tif (!root->node) {\n\t\ttest_msg(\"Couldn't allocate dummy buffer\\n\");\n\t\tgoto out;\n\t}\n\n\textent_buffer_get(root->node);\n\tbtrfs_set_header_nritems(root->node, 0);\n\tbtrfs_set_header_level(root->node, 0);\n\tBTRFS_I(inode)->root = root;\n\tret = -EINVAL;\n\n\t/*\n\t * Need a blank inode item here just so we don't confuse\n\t * btrfs_get_extent.\n\t */\n\tinsert_inode_item_key(root);\n\tinsert_extent(root, 4096, 4096, 4096, 0, 4096, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, 1);\n\tem = btrfs_get_extent(inode, NULL, 0, 0, 8192, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a hole, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != 0 || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start 0 len 4096, got start \"\n\t\t\t \"%llu len %llu\\n\", em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != vacancy_only) {\n\t\ttest_msg(\"Wrong flags, wanted %lu, have %lu\\n\", vacancy_only,\n\t\t\t em->flags);\n\t\tgoto out;\n\t}\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, 4096, 8192, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != 4096) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != 4096 || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start 4096 len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, wanted 0 got %lu\\n\",\n\t\t\t em->flags);\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tif (!IS_ERR(em))\n\t\tfree_extent_map(em);\n\tiput(inode);\n\tbtrfs_free_dummy_root(root);\n\treturn ret;\n}",
    "includes": [
      "#include \"../volumes.h\"",
      "#include \"../extent_io.h\"",
      "#include \"../disk-io.h\"",
      "#include \"../btrfs_inode.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long vacancy_only = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_dummy_root",
          "args": [
            "root"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_dummy_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.c",
          "lines": "161-170",
          "snippet": "void btrfs_free_dummy_root(struct btrfs_root *root)\n{\n\tif (!root)\n\t\treturn;\n\tif (root->node)\n\t\tfree_extent_buffer(root->node);\n\tif (root->fs_info)\n\t\tbtrfs_free_dummy_fs_info(root->fs_info);\n\tkfree(root);\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../volumes.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\"",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../volumes.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid btrfs_free_dummy_root(struct btrfs_root *root)\n{\n\tif (!root)\n\t\treturn;\n\tif (root->node)\n\t\tfree_extent_buffer(root->node);\n\tif (root->fs_info)\n\t\tbtrfs_free_dummy_fs_info(root->fs_info);\n\tkfree(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected flags set, wanted 0 got %lu\\n\"",
            "em->flags"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected extent wanted start 4096 len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\"",
            "em->start",
            "em->len"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "nlm4svc_proc_test_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
          "lines": "276-281",
          "snippet": "static __be32 nlm4svc_proc_test_msg(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t\t     void\t     *resp)\n{\n\tdprintk(\"lockd: TEST_MSG      called\\n\");\n\treturn nlm4svc_callback(rqstp, NLMPROC_TEST_RES, argp, nlm4svc_proc_test);\n}",
          "includes": [
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/time.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32 nlm4svc_proc_test_msg(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t\t     void\t     *resp)\n{\n\tdprintk(\"lockd: TEST_MSG      called\\n\");\n\treturn nlm4svc_callback(rqstp, NLMPROC_TEST_RES, argp, nlm4svc_proc_test);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected a real extent, got %llu\\n\"",
            "em->block_start"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Got an error when we shouldn't have\\n\""
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_extent",
          "args": [
            "inode",
            "NULL",
            "0",
            "4096",
            "8192",
            "0"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_extent_fiemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "6744-6869",
          "snippet": "struct extent_map *btrfs_get_extent_fiemap(struct inode *inode, struct page *page,\n\t\t\t\t\t   size_t pg_offset, u64 start, u64 len,\n\t\t\t\t\t   int create)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *hole_em = NULL;\n\tu64 range_start = start;\n\tu64 end;\n\tu64 found;\n\tu64 found_end;\n\tint err = 0;\n\n\tem = btrfs_get_extent(inode, page, pg_offset, start, len, create);\n\tif (IS_ERR(em))\n\t\treturn em;\n\tif (em) {\n\t\t/*\n\t\t * if our em maps to\n\t\t * -  a hole or\n\t\t * -  a pre-alloc extent,\n\t\t * there might actually be delalloc bytes behind it.\n\t\t */\n\t\tif (em->block_start != EXTENT_MAP_HOLE &&\n\t\t    !test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\treturn em;\n\t\telse\n\t\t\thole_em = em;\n\t}\n\n\t/* check to see if we've wrapped (len == -1 or similar) */\n\tend = start + len;\n\tif (end < start)\n\t\tend = (u64)-1;\n\telse\n\t\tend -= 1;\n\n\tem = NULL;\n\n\t/* ok, we didn't find anything, lets look for delalloc */\n\tfound = count_range_bits(&BTRFS_I(inode)->io_tree, &range_start,\n\t\t\t\t end, len, EXTENT_DELALLOC, 1);\n\tfound_end = range_start + found;\n\tif (found_end < range_start)\n\t\tfound_end = (u64)-1;\n\n\t/*\n\t * we didn't find anything useful, return\n\t * the original results from get_extent()\n\t */\n\tif (range_start > end || found_end <= start) {\n\t\tem = hole_em;\n\t\thole_em = NULL;\n\t\tgoto out;\n\t}\n\n\t/* adjust the range_start to make sure it doesn't\n\t * go backwards from the start they passed in\n\t */\n\trange_start = max(start, range_start);\n\tfound = found_end - range_start;\n\n\tif (found > 0) {\n\t\tu64 hole_start = start;\n\t\tu64 hole_len = len;\n\n\t\tem = alloc_extent_map();\n\t\tif (!em) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * when btrfs_get_extent can't find anything it\n\t\t * returns one huge hole\n\t\t *\n\t\t * make sure what it found really fits our range, and\n\t\t * adjust to make sure it is based on the start from\n\t\t * the caller\n\t\t */\n\t\tif (hole_em) {\n\t\t\tu64 calc_end = extent_map_end(hole_em);\n\n\t\t\tif (calc_end <= start || (hole_em->start > end)) {\n\t\t\t\tfree_extent_map(hole_em);\n\t\t\t\thole_em = NULL;\n\t\t\t} else {\n\t\t\t\thole_start = max(hole_em->start, start);\n\t\t\t\thole_len = calc_end - hole_start;\n\t\t\t}\n\t\t}\n\t\tem->bdev = NULL;\n\t\tif (hole_em && range_start > hole_start) {\n\t\t\t/* our hole starts before our delalloc, so we\n\t\t\t * have to return just the parts of the hole\n\t\t\t * that go until  the delalloc starts\n\t\t\t */\n\t\t\tem->len = min(hole_len,\n\t\t\t\t      range_start - hole_start);\n\t\t\tem->start = hole_start;\n\t\t\tem->orig_start = hole_start;\n\t\t\t/*\n\t\t\t * don't adjust block start at all,\n\t\t\t * it is fixed at EXTENT_MAP_HOLE\n\t\t\t */\n\t\t\tem->block_start = hole_em->block_start;\n\t\t\tem->block_len = hole_len;\n\t\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &hole_em->flags))\n\t\t\t\tset_bit(EXTENT_FLAG_PREALLOC, &em->flags);\n\t\t} else {\n\t\t\tem->start = range_start;\n\t\t\tem->len = found;\n\t\t\tem->orig_start = range_start;\n\t\t\tem->block_start = EXTENT_MAP_DELALLOC;\n\t\t\tem->block_len = found;\n\t\t}\n\t} else if (hole_em) {\n\t\treturn hole_em;\n\t}\nout:\n\n\tfree_extent_map(hole_em);\n\tif (err) {\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn em;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nstruct extent_map *btrfs_get_extent_fiemap(struct inode *inode, struct page *page,\n\t\t\t\t\t   size_t pg_offset, u64 start, u64 len,\n\t\t\t\t\t   int create)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *hole_em = NULL;\n\tu64 range_start = start;\n\tu64 end;\n\tu64 found;\n\tu64 found_end;\n\tint err = 0;\n\n\tem = btrfs_get_extent(inode, page, pg_offset, start, len, create);\n\tif (IS_ERR(em))\n\t\treturn em;\n\tif (em) {\n\t\t/*\n\t\t * if our em maps to\n\t\t * -  a hole or\n\t\t * -  a pre-alloc extent,\n\t\t * there might actually be delalloc bytes behind it.\n\t\t */\n\t\tif (em->block_start != EXTENT_MAP_HOLE &&\n\t\t    !test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\treturn em;\n\t\telse\n\t\t\thole_em = em;\n\t}\n\n\t/* check to see if we've wrapped (len == -1 or similar) */\n\tend = start + len;\n\tif (end < start)\n\t\tend = (u64)-1;\n\telse\n\t\tend -= 1;\n\n\tem = NULL;\n\n\t/* ok, we didn't find anything, lets look for delalloc */\n\tfound = count_range_bits(&BTRFS_I(inode)->io_tree, &range_start,\n\t\t\t\t end, len, EXTENT_DELALLOC, 1);\n\tfound_end = range_start + found;\n\tif (found_end < range_start)\n\t\tfound_end = (u64)-1;\n\n\t/*\n\t * we didn't find anything useful, return\n\t * the original results from get_extent()\n\t */\n\tif (range_start > end || found_end <= start) {\n\t\tem = hole_em;\n\t\thole_em = NULL;\n\t\tgoto out;\n\t}\n\n\t/* adjust the range_start to make sure it doesn't\n\t * go backwards from the start they passed in\n\t */\n\trange_start = max(start, range_start);\n\tfound = found_end - range_start;\n\n\tif (found > 0) {\n\t\tu64 hole_start = start;\n\t\tu64 hole_len = len;\n\n\t\tem = alloc_extent_map();\n\t\tif (!em) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * when btrfs_get_extent can't find anything it\n\t\t * returns one huge hole\n\t\t *\n\t\t * make sure what it found really fits our range, and\n\t\t * adjust to make sure it is based on the start from\n\t\t * the caller\n\t\t */\n\t\tif (hole_em) {\n\t\t\tu64 calc_end = extent_map_end(hole_em);\n\n\t\t\tif (calc_end <= start || (hole_em->start > end)) {\n\t\t\t\tfree_extent_map(hole_em);\n\t\t\t\thole_em = NULL;\n\t\t\t} else {\n\t\t\t\thole_start = max(hole_em->start, start);\n\t\t\t\thole_len = calc_end - hole_start;\n\t\t\t}\n\t\t}\n\t\tem->bdev = NULL;\n\t\tif (hole_em && range_start > hole_start) {\n\t\t\t/* our hole starts before our delalloc, so we\n\t\t\t * have to return just the parts of the hole\n\t\t\t * that go until  the delalloc starts\n\t\t\t */\n\t\t\tem->len = min(hole_len,\n\t\t\t\t      range_start - hole_start);\n\t\t\tem->start = hole_start;\n\t\t\tem->orig_start = hole_start;\n\t\t\t/*\n\t\t\t * don't adjust block start at all,\n\t\t\t * it is fixed at EXTENT_MAP_HOLE\n\t\t\t */\n\t\t\tem->block_start = hole_em->block_start;\n\t\t\tem->block_len = hole_len;\n\t\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &hole_em->flags))\n\t\t\t\tset_bit(EXTENT_FLAG_PREALLOC, &em->flags);\n\t\t} else {\n\t\t\tem->start = range_start;\n\t\t\tem->len = found;\n\t\t\tem->orig_start = range_start;\n\t\t\tem->block_start = EXTENT_MAP_DELALLOC;\n\t\t\tem->block_len = found;\n\t\t}\n\t} else if (hole_em) {\n\t\treturn hole_em;\n\t}\nout:\n\n\tfree_extent_map(hole_em);\n\tif (err) {\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn em;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected a hole, got %llu\\n\"",
            "em->block_start"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Got an error when we shouldn't have\\n\""
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_extent",
          "args": [
            "root",
            "4096",
            "4096",
            "4096",
            "0",
            "4096",
            "4096",
            "BTRFS_FILE_EXTENT_REG",
            "0",
            "1"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/inode-tests.c",
          "lines": "26-60",
          "snippet": "static void insert_extent(struct btrfs_root *root, u64 start, u64 len,\n\t\t\t  u64 ram_bytes, u64 offset, u64 disk_bytenr,\n\t\t\t  u64 disk_len, u32 type, u8 compression, int slot)\n{\n\tstruct btrfs_path path;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_buffer *leaf = root->node;\n\tstruct btrfs_key key;\n\tu32 value_len = sizeof(struct btrfs_file_extent_item);\n\n\tif (type == BTRFS_FILE_EXTENT_INLINE)\n\t\tvalue_len += len;\n\tmemset(&path, 0, sizeof(path));\n\n\tpath.nodes[0] = leaf;\n\tpath.slots[0] = slot;\n\n\tkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = start;\n\n\tsetup_items_for_insert(root, &path, &key, &value_len, value_len,\n\t\t\t       value_len + sizeof(struct btrfs_item), 1);\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\tbtrfs_set_file_extent_generation(leaf, fi, 1);\n\tbtrfs_set_file_extent_type(leaf, fi, type);\n\tbtrfs_set_file_extent_disk_bytenr(leaf, fi, disk_bytenr);\n\tbtrfs_set_file_extent_disk_num_bytes(leaf, fi, disk_len);\n\tbtrfs_set_file_extent_offset(leaf, fi, offset);\n\tbtrfs_set_file_extent_num_bytes(leaf, fi, len);\n\tbtrfs_set_file_extent_ram_bytes(leaf, fi, ram_bytes);\n\tbtrfs_set_file_extent_compression(leaf, fi, compression);\n\tbtrfs_set_file_extent_encryption(leaf, fi, 0);\n\tbtrfs_set_file_extent_other_encoding(leaf, fi, 0);\n}",
          "includes": [
            "#include \"../volumes.h\"",
            "#include \"../extent_io.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../btrfs_inode.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../volumes.h\"\n#include \"../extent_io.h\"\n#include \"../disk-io.h\"\n#include \"../btrfs_inode.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic void insert_extent(struct btrfs_root *root, u64 start, u64 len,\n\t\t\t  u64 ram_bytes, u64 offset, u64 disk_bytenr,\n\t\t\t  u64 disk_len, u32 type, u8 compression, int slot)\n{\n\tstruct btrfs_path path;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_buffer *leaf = root->node;\n\tstruct btrfs_key key;\n\tu32 value_len = sizeof(struct btrfs_file_extent_item);\n\n\tif (type == BTRFS_FILE_EXTENT_INLINE)\n\t\tvalue_len += len;\n\tmemset(&path, 0, sizeof(path));\n\n\tpath.nodes[0] = leaf;\n\tpath.slots[0] = slot;\n\n\tkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = start;\n\n\tsetup_items_for_insert(root, &path, &key, &value_len, value_len,\n\t\t\t       value_len + sizeof(struct btrfs_item), 1);\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\tbtrfs_set_file_extent_generation(leaf, fi, 1);\n\tbtrfs_set_file_extent_type(leaf, fi, type);\n\tbtrfs_set_file_extent_disk_bytenr(leaf, fi, disk_bytenr);\n\tbtrfs_set_file_extent_disk_num_bytes(leaf, fi, disk_len);\n\tbtrfs_set_file_extent_offset(leaf, fi, offset);\n\tbtrfs_set_file_extent_num_bytes(leaf, fi, len);\n\tbtrfs_set_file_extent_ram_bytes(leaf, fi, ram_bytes);\n\tbtrfs_set_file_extent_compression(leaf, fi, compression);\n\tbtrfs_set_file_extent_encryption(leaf, fi, 0);\n\tbtrfs_set_file_extent_other_encoding(leaf, fi, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_inode_item_key",
          "args": [
            "root"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "insert_inode_item_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/inode-tests.c",
          "lines": "62-80",
          "snippet": "static void insert_inode_item_key(struct btrfs_root *root)\n{\n\tstruct btrfs_path path;\n\tstruct extent_buffer *leaf = root->node;\n\tstruct btrfs_key key;\n\tu32 value_len = 0;\n\n\tmemset(&path, 0, sizeof(path));\n\n\tpath.nodes[0] = leaf;\n\tpath.slots[0] = 0;\n\n\tkey.objectid = BTRFS_INODE_ITEM_KEY;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tsetup_items_for_insert(root, &path, &key, &value_len, value_len,\n\t\t\t       value_len + sizeof(struct btrfs_item), 1);\n}",
          "includes": [
            "#include \"../volumes.h\"",
            "#include \"../extent_io.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../btrfs_inode.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../volumes.h\"\n#include \"../extent_io.h\"\n#include \"../disk-io.h\"\n#include \"../btrfs_inode.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic void insert_inode_item_key(struct btrfs_root *root)\n{\n\tstruct btrfs_path path;\n\tstruct extent_buffer *leaf = root->node;\n\tstruct btrfs_key key;\n\tu32 value_len = 0;\n\n\tmemset(&path, 0, sizeof(path));\n\n\tpath.nodes[0] = leaf;\n\tpath.slots[0] = 0;\n\n\tkey.objectid = BTRFS_INODE_ITEM_KEY;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tsetup_items_for_insert(root, &path, &key, &value_len, value_len,\n\t\t\t       value_len + sizeof(struct btrfs_item), 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_level",
          "args": [
            "root->node",
            "0"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_nritems",
          "args": [
            "root->node",
            "0"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_buffer_get",
          "args": [
            "root->node"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "287-290",
          "snippet": "static inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't allocate dummy buffer\\n\""
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_dummy_extent_buffer",
          "args": [
            "NULL",
            "4096"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_dummy_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4672-4710",
          "snippet": "struct extent_buffer *alloc_dummy_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tu64 start)\n{\n\tstruct extent_buffer *eb;\n\tunsigned long len;\n\tunsigned long num_pages;\n\tunsigned long i;\n\n\tif (!fs_info) {\n\t\t/*\n\t\t * Called only from tests that don't always have a fs_info\n\t\t * available, but we know that nodesize is 4096\n\t\t */\n\t\tlen = 4096;\n\t} else {\n\t\tlen = fs_info->tree_root->nodesize;\n\t}\n\tnum_pages = num_extent_pages(0, len);\n\n\teb = __alloc_extent_buffer(fs_info, start, len);\n\tif (!eb)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\teb->pages[i] = alloc_page(GFP_NOFS);\n\t\tif (!eb->pages[i])\n\t\t\tgoto err;\n\t}\n\tset_extent_buffer_uptodate(eb);\n\tbtrfs_set_header_nritems(eb, 0);\n\tset_bit(EXTENT_BUFFER_DUMMY, &eb->bflags);\n\n\treturn eb;\nerr:\n\tfor (; i > 0; i--)\n\t\t__free_page(eb->pages[i - 1]);\n\t__free_extent_buffer(eb);\n\treturn NULL;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstruct extent_buffer *alloc_dummy_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tu64 start)\n{\n\tstruct extent_buffer *eb;\n\tunsigned long len;\n\tunsigned long num_pages;\n\tunsigned long i;\n\n\tif (!fs_info) {\n\t\t/*\n\t\t * Called only from tests that don't always have a fs_info\n\t\t * available, but we know that nodesize is 4096\n\t\t */\n\t\tlen = 4096;\n\t} else {\n\t\tlen = fs_info->tree_root->nodesize;\n\t}\n\tnum_pages = num_extent_pages(0, len);\n\n\teb = __alloc_extent_buffer(fs_info, start, len);\n\tif (!eb)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\teb->pages[i] = alloc_page(GFP_NOFS);\n\t\tif (!eb->pages[i])\n\t\t\tgoto err;\n\t}\n\tset_extent_buffer_uptodate(eb);\n\tbtrfs_set_header_nritems(eb, 0);\n\tset_bit(EXTENT_BUFFER_DUMMY, &eb->bflags);\n\n\treturn eb;\nerr:\n\tfor (; i > 0; i--)\n\t\t__free_page(eb->pages[i - 1]);\n\t__free_extent_buffer(eb);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't allocate dummy fs info\\n\""
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_dummy_fs_info",
          "args": [],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_dummy_fs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.c",
          "lines": "79-126",
          "snippet": "struct btrfs_fs_info *btrfs_alloc_dummy_fs_info(void)\n{\n\tstruct btrfs_fs_info *fs_info = kzalloc(sizeof(struct btrfs_fs_info),\n\t\t\t\t\t\tGFP_NOFS);\n\n\tif (!fs_info)\n\t\treturn fs_info;\n\tfs_info->fs_devices = kzalloc(sizeof(struct btrfs_fs_devices),\n\t\t\t\t      GFP_NOFS);\n\tif (!fs_info->fs_devices) {\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\tfs_info->super_copy = kzalloc(sizeof(struct btrfs_super_block),\n\t\t\t\t      GFP_NOFS);\n\tif (!fs_info->super_copy) {\n\t\tkfree(fs_info->fs_devices);\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\n\tif (init_srcu_struct(&fs_info->subvol_srcu)) {\n\t\tkfree(fs_info->fs_devices);\n\t\tkfree(fs_info->super_copy);\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_init(&fs_info->buffer_lock);\n\tspin_lock_init(&fs_info->qgroup_lock);\n\tspin_lock_init(&fs_info->qgroup_op_lock);\n\tspin_lock_init(&fs_info->super_lock);\n\tspin_lock_init(&fs_info->fs_roots_radix_lock);\n\tspin_lock_init(&fs_info->tree_mod_seq_lock);\n\tmutex_init(&fs_info->qgroup_ioctl_lock);\n\tmutex_init(&fs_info->qgroup_rescan_lock);\n\trwlock_init(&fs_info->tree_mod_log_lock);\n\tfs_info->running_transaction = NULL;\n\tfs_info->qgroup_tree = RB_ROOT;\n\tfs_info->qgroup_ulist = NULL;\n\tatomic64_set(&fs_info->tree_mod_seq, 0);\n\tINIT_LIST_HEAD(&fs_info->dirty_qgroups);\n\tINIT_LIST_HEAD(&fs_info->dead_roots);\n\tINIT_LIST_HEAD(&fs_info->tree_mod_seq_list);\n\tINIT_RADIX_TREE(&fs_info->buffer_radix, GFP_ATOMIC);\n\tINIT_RADIX_TREE(&fs_info->fs_roots_radix, GFP_ATOMIC);\n\treturn fs_info;\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../volumes.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\"",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../volumes.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstruct btrfs_fs_info *btrfs_alloc_dummy_fs_info(void)\n{\n\tstruct btrfs_fs_info *fs_info = kzalloc(sizeof(struct btrfs_fs_info),\n\t\t\t\t\t\tGFP_NOFS);\n\n\tif (!fs_info)\n\t\treturn fs_info;\n\tfs_info->fs_devices = kzalloc(sizeof(struct btrfs_fs_devices),\n\t\t\t\t      GFP_NOFS);\n\tif (!fs_info->fs_devices) {\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\tfs_info->super_copy = kzalloc(sizeof(struct btrfs_super_block),\n\t\t\t\t      GFP_NOFS);\n\tif (!fs_info->super_copy) {\n\t\tkfree(fs_info->fs_devices);\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\n\tif (init_srcu_struct(&fs_info->subvol_srcu)) {\n\t\tkfree(fs_info->fs_devices);\n\t\tkfree(fs_info->super_copy);\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_init(&fs_info->buffer_lock);\n\tspin_lock_init(&fs_info->qgroup_lock);\n\tspin_lock_init(&fs_info->qgroup_op_lock);\n\tspin_lock_init(&fs_info->super_lock);\n\tspin_lock_init(&fs_info->fs_roots_radix_lock);\n\tspin_lock_init(&fs_info->tree_mod_seq_lock);\n\tmutex_init(&fs_info->qgroup_ioctl_lock);\n\tmutex_init(&fs_info->qgroup_rescan_lock);\n\trwlock_init(&fs_info->tree_mod_log_lock);\n\tfs_info->running_transaction = NULL;\n\tfs_info->qgroup_tree = RB_ROOT;\n\tfs_info->qgroup_ulist = NULL;\n\tatomic64_set(&fs_info->tree_mod_seq, 0);\n\tINIT_LIST_HEAD(&fs_info->dirty_qgroups);\n\tINIT_LIST_HEAD(&fs_info->dead_roots);\n\tINIT_LIST_HEAD(&fs_info->tree_mod_seq_list);\n\tINIT_RADIX_TREE(&fs_info->buffer_radix, GFP_ATOMIC);\n\tINIT_RADIX_TREE(&fs_info->fs_roots_radix, GFP_ATOMIC);\n\treturn fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't allocate root\\n\""
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_dummy_root",
          "args": [],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_dummy_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1298-1310",
          "snippet": "struct btrfs_root *btrfs_alloc_dummy_root(void)\n{\n\tstruct btrfs_root *root;\n\n\troot = btrfs_alloc_root(NULL);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\t__setup_root(4096, 4096, 4096, root, NULL, 1);\n\tset_bit(BTRFS_ROOT_DUMMY_ROOT, &root->state);\n\troot->alloc_bytenr = 0;\n\n\treturn root;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct btrfs_root *btrfs_alloc_dummy_root(void)\n{\n\tstruct btrfs_root *root;\n\n\troot = btrfs_alloc_root(NULL);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\t__setup_root(4096, 4096, 4096, root, NULL, 1);\n\tset_bit(BTRFS_ROOT_DUMMY_ROOT, &root->state);\n\troot->alloc_bytenr = 0;\n\n\treturn root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't allocate inode\\n\""
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_new_test_inode",
          "args": [],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_new_test_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.c",
          "lines": "49-52",
          "snippet": "struct inode *btrfs_new_test_inode(void)\n{\n\treturn new_inode(test_mnt->mnt_sb);\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../volumes.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\"",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *test_mnt = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../volumes.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct vfsmount *test_mnt = NULL;\n\nstruct inode *btrfs_new_test_inode(void)\n{\n\treturn new_inode(test_mnt->mnt_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../volumes.h\"\n#include \"../extent_io.h\"\n#include \"../disk-io.h\"\n#include \"../btrfs_inode.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic unsigned long vacancy_only = 0;\n\nstatic int test_hole_first(void)\n{\n\tstruct inode *inode = NULL;\n\tstruct btrfs_root *root = NULL;\n\tstruct extent_map *em = NULL;\n\tint ret = -ENOMEM;\n\n\tinode = btrfs_new_test_inode();\n\tif (!inode) {\n\t\ttest_msg(\"Couldn't allocate inode\\n\");\n\t\treturn ret;\n\t}\n\n\tBTRFS_I(inode)->location.type = BTRFS_INODE_ITEM_KEY;\n\tBTRFS_I(inode)->location.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tBTRFS_I(inode)->location.offset = 0;\n\n\troot = btrfs_alloc_dummy_root();\n\tif (IS_ERR(root)) {\n\t\ttest_msg(\"Couldn't allocate root\\n\");\n\t\tgoto out;\n\t}\n\n\troot->fs_info = btrfs_alloc_dummy_fs_info();\n\tif (!root->fs_info) {\n\t\ttest_msg(\"Couldn't allocate dummy fs info\\n\");\n\t\tgoto out;\n\t}\n\n\troot->node = alloc_dummy_extent_buffer(NULL, 4096);\n\tif (!root->node) {\n\t\ttest_msg(\"Couldn't allocate dummy buffer\\n\");\n\t\tgoto out;\n\t}\n\n\textent_buffer_get(root->node);\n\tbtrfs_set_header_nritems(root->node, 0);\n\tbtrfs_set_header_level(root->node, 0);\n\tBTRFS_I(inode)->root = root;\n\tret = -EINVAL;\n\n\t/*\n\t * Need a blank inode item here just so we don't confuse\n\t * btrfs_get_extent.\n\t */\n\tinsert_inode_item_key(root);\n\tinsert_extent(root, 4096, 4096, 4096, 0, 4096, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, 1);\n\tem = btrfs_get_extent(inode, NULL, 0, 0, 8192, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a hole, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != 0 || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start 0 len 4096, got start \"\n\t\t\t \"%llu len %llu\\n\", em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != vacancy_only) {\n\t\ttest_msg(\"Wrong flags, wanted %lu, have %lu\\n\", vacancy_only,\n\t\t\t em->flags);\n\t\tgoto out;\n\t}\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, 4096, 8192, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != 4096) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != 4096 || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start 4096 len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, wanted 0 got %lu\\n\",\n\t\t\t em->flags);\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tif (!IS_ERR(em))\n\t\tfree_extent_map(em);\n\tiput(inode);\n\tbtrfs_free_dummy_root(root);\n\treturn ret;\n}"
  },
  {
    "function_name": "test_btrfs_get_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/inode-tests.c",
    "lines": "222-815",
    "snippet": "static noinline int test_btrfs_get_extent(void)\n{\n\tstruct inode *inode = NULL;\n\tstruct btrfs_root *root = NULL;\n\tstruct extent_map *em = NULL;\n\tu64 orig_start;\n\tu64 disk_bytenr;\n\tu64 offset;\n\tint ret = -ENOMEM;\n\n\tinode = btrfs_new_test_inode();\n\tif (!inode) {\n\t\ttest_msg(\"Couldn't allocate inode\\n\");\n\t\treturn ret;\n\t}\n\n\tBTRFS_I(inode)->location.type = BTRFS_INODE_ITEM_KEY;\n\tBTRFS_I(inode)->location.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tBTRFS_I(inode)->location.offset = 0;\n\n\troot = btrfs_alloc_dummy_root();\n\tif (IS_ERR(root)) {\n\t\ttest_msg(\"Couldn't allocate root\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We do this since btrfs_get_extent wants to assign em->bdev to\n\t * root->fs_info->fs_devices->latest_bdev.\n\t */\n\troot->fs_info = btrfs_alloc_dummy_fs_info();\n\tif (!root->fs_info) {\n\t\ttest_msg(\"Couldn't allocate dummy fs info\\n\");\n\t\tgoto out;\n\t}\n\n\troot->node = alloc_dummy_extent_buffer(NULL, 4096);\n\tif (!root->node) {\n\t\ttest_msg(\"Couldn't allocate dummy buffer\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We will just free a dummy node if it's ref count is 2 so we need an\n\t * extra ref so our searches don't accidently release our page.\n\t */\n\textent_buffer_get(root->node);\n\tbtrfs_set_header_nritems(root->node, 0);\n\tbtrfs_set_header_level(root->node, 0);\n\tret = -EINVAL;\n\n\t/* First with no extents */\n\tBTRFS_I(inode)->root = root;\n\tem = btrfs_get_extent(inode, NULL, 0, 0, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\tem = NULL;\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a hole, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (!test_bit(EXTENT_FLAG_VACANCY, &em->flags)) {\n\t\ttest_msg(\"Vacancy flag wasn't set properly\\n\");\n\t\tgoto out;\n\t}\n\tfree_extent_map(em);\n\tbtrfs_drop_extent_cache(inode, 0, (u64)-1, 0);\n\n\t/*\n\t * All of the magic numbers are based on the mapping setup in\n\t * setup_file_extents, so if you change anything there you need to\n\t * update the comment and update the expected values below.\n\t */\n\tsetup_file_extents(root);\n\n\tem = btrfs_get_extent(inode, NULL, 0, 0, (u64)-1, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a hole, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != 0 || em->len != 5) {\n\t\ttest_msg(\"Unexpected extent wanted start 0 len 5, got start \"\n\t\t\t \"%llu len %llu\\n\", em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_INLINE) {\n\t\ttest_msg(\"Expected an inline, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4091) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 1, got start \"\n\t\t\t \"%llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\t/*\n\t * We don't test anything else for inline since it doesn't get set\n\t * unless we have a page for it to write into.  Maybe we should change\n\t * this?\n\t */\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a hole, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4, got start \"\n\t\t\t \"%llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* Regular extent */\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4095) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4095, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* The next 3 are split extents */\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\tdisk_bytenr = em->block_start;\n\torig_start = em->start;\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a hole, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 8192) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 8192, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != orig_start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\",\n\t\t\t orig_start, em->orig_start);\n\t\tgoto out;\n\t}\n\tdisk_bytenr += (em->start - orig_start);\n\tif (em->block_start != disk_bytenr) {\n\t\ttest_msg(\"Wrong block start, want %llu, have %llu\\n\",\n\t\t\t disk_bytenr, em->block_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* Prealloc extent */\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != prealloc_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t prealloc_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* The next 3 are a half written prealloc extent */\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != prealloc_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t prealloc_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\tdisk_bytenr = em->block_start;\n\torig_start = em->start;\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != orig_start) {\n\t\ttest_msg(\"Unexpected orig offset, wanted %llu, have %llu\\n\",\n\t\t\t orig_start, em->orig_start);\n\t\tgoto out;\n\t}\n\tif (em->block_start != (disk_bytenr + (em->start - em->orig_start))) {\n\t\ttest_msg(\"Unexpected block start, wanted %llu, have %llu\\n\",\n\t\t\t disk_bytenr + (em->start - em->orig_start),\n\t\t\t em->block_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 8192) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 8192, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != prealloc_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t prealloc_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != orig_start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", orig_start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\tif (em->block_start != (disk_bytenr + (em->start - em->orig_start))) {\n\t\ttest_msg(\"Unexpected block start, wanted %llu, have %llu\\n\",\n\t\t\t disk_bytenr + (em->start - em->orig_start),\n\t\t\t em->block_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* Now for the compressed extent */\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 8192) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 8192, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != compressed_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t compressed_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\",\n\t\t\t em->start, em->orig_start);\n\t\tgoto out;\n\t}\n\tif (em->compress_type != BTRFS_COMPRESS_ZLIB) {\n\t\ttest_msg(\"Unexpected compress type, wanted %d, got %d\\n\",\n\t\t\t BTRFS_COMPRESS_ZLIB, em->compress_type);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* Split compressed extent */\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != compressed_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t compressed_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\",\n\t\t\t em->start, em->orig_start);\n\t\tgoto out;\n\t}\n\tif (em->compress_type != BTRFS_COMPRESS_ZLIB) {\n\t\ttest_msg(\"Unexpected compress type, wanted %d, got %d\\n\",\n\t\t\t BTRFS_COMPRESS_ZLIB, em->compress_type);\n\t\tgoto out;\n\t}\n\tdisk_bytenr = em->block_start;\n\torig_start = em->start;\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != disk_bytenr) {\n\t\ttest_msg(\"Block start does not match, want %llu got %llu\\n\",\n\t\t\t disk_bytenr, em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 8192) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 8192, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != compressed_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t compressed_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != orig_start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\",\n\t\t\t em->start, orig_start);\n\t\tgoto out;\n\t}\n\tif (em->compress_type != BTRFS_COMPRESS_ZLIB) {\n\t\ttest_msg(\"Unexpected compress type, wanted %d, got %d\\n\",\n\t\t\t BTRFS_COMPRESS_ZLIB, em->compress_type);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* A hole between regular extents but no hole extent */\n\tem = btrfs_get_extent(inode, NULL, 0, offset + 6, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096 * 1024, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a hole extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\t/*\n\t * Currently we just return a length that we requested rather than the\n\t * length of the actual hole, if this changes we'll have to change this\n\t * test.\n\t */\n\tif (em->start != offset || em->len != 12288) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 12288, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != vacancy_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t vacancy_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tif (!IS_ERR(em))\n\t\tfree_extent_map(em);\n\tiput(inode);\n\tbtrfs_free_dummy_root(root);\n\treturn ret;\n}",
    "includes": [
      "#include \"../volumes.h\"",
      "#include \"../extent_io.h\"",
      "#include \"../disk-io.h\"",
      "#include \"../btrfs_inode.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long prealloc_only = 0;",
      "static unsigned long compressed_only = 0;",
      "static unsigned long vacancy_only = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_dummy_root",
          "args": [
            "root"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_dummy_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.c",
          "lines": "161-170",
          "snippet": "void btrfs_free_dummy_root(struct btrfs_root *root)\n{\n\tif (!root)\n\t\treturn;\n\tif (root->node)\n\t\tfree_extent_buffer(root->node);\n\tif (root->fs_info)\n\t\tbtrfs_free_dummy_fs_info(root->fs_info);\n\tkfree(root);\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../volumes.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\"",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../volumes.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid btrfs_free_dummy_root(struct btrfs_root *root)\n{\n\tif (!root)\n\t\treturn;\n\tif (root->node)\n\t\tfree_extent_buffer(root->node);\n\tif (root->fs_info)\n\t\tbtrfs_free_dummy_fs_info(root->fs_info);\n\tkfree(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Wrong orig offset, want %llu, have %llu\\n\"",
            "em->start",
            "em->orig_start"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "nlm4svc_proc_test_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
          "lines": "276-281",
          "snippet": "static __be32 nlm4svc_proc_test_msg(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t\t     void\t     *resp)\n{\n\tdprintk(\"lockd: TEST_MSG      called\\n\");\n\treturn nlm4svc_callback(rqstp, NLMPROC_TEST_RES, argp, nlm4svc_proc_test);\n}",
          "includes": [
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/time.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32 nlm4svc_proc_test_msg(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t\t     void\t     *resp)\n{\n\tdprintk(\"lockd: TEST_MSG      called\\n\");\n\treturn nlm4svc_callback(rqstp, NLMPROC_TEST_RES, argp, nlm4svc_proc_test);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected flags set, want 0 have %lu\\n\"",
            "em->flags"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\"",
            "offset",
            "em->start",
            "em->len"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected a real extent, got %llu\\n\"",
            "em->block_start"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Got an error when we shouldn't have\\n\""
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_extent",
          "args": [
            "inode",
            "NULL",
            "0",
            "offset",
            "4096",
            "0"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_extent_fiemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "6744-6869",
          "snippet": "struct extent_map *btrfs_get_extent_fiemap(struct inode *inode, struct page *page,\n\t\t\t\t\t   size_t pg_offset, u64 start, u64 len,\n\t\t\t\t\t   int create)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *hole_em = NULL;\n\tu64 range_start = start;\n\tu64 end;\n\tu64 found;\n\tu64 found_end;\n\tint err = 0;\n\n\tem = btrfs_get_extent(inode, page, pg_offset, start, len, create);\n\tif (IS_ERR(em))\n\t\treturn em;\n\tif (em) {\n\t\t/*\n\t\t * if our em maps to\n\t\t * -  a hole or\n\t\t * -  a pre-alloc extent,\n\t\t * there might actually be delalloc bytes behind it.\n\t\t */\n\t\tif (em->block_start != EXTENT_MAP_HOLE &&\n\t\t    !test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\treturn em;\n\t\telse\n\t\t\thole_em = em;\n\t}\n\n\t/* check to see if we've wrapped (len == -1 or similar) */\n\tend = start + len;\n\tif (end < start)\n\t\tend = (u64)-1;\n\telse\n\t\tend -= 1;\n\n\tem = NULL;\n\n\t/* ok, we didn't find anything, lets look for delalloc */\n\tfound = count_range_bits(&BTRFS_I(inode)->io_tree, &range_start,\n\t\t\t\t end, len, EXTENT_DELALLOC, 1);\n\tfound_end = range_start + found;\n\tif (found_end < range_start)\n\t\tfound_end = (u64)-1;\n\n\t/*\n\t * we didn't find anything useful, return\n\t * the original results from get_extent()\n\t */\n\tif (range_start > end || found_end <= start) {\n\t\tem = hole_em;\n\t\thole_em = NULL;\n\t\tgoto out;\n\t}\n\n\t/* adjust the range_start to make sure it doesn't\n\t * go backwards from the start they passed in\n\t */\n\trange_start = max(start, range_start);\n\tfound = found_end - range_start;\n\n\tif (found > 0) {\n\t\tu64 hole_start = start;\n\t\tu64 hole_len = len;\n\n\t\tem = alloc_extent_map();\n\t\tif (!em) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * when btrfs_get_extent can't find anything it\n\t\t * returns one huge hole\n\t\t *\n\t\t * make sure what it found really fits our range, and\n\t\t * adjust to make sure it is based on the start from\n\t\t * the caller\n\t\t */\n\t\tif (hole_em) {\n\t\t\tu64 calc_end = extent_map_end(hole_em);\n\n\t\t\tif (calc_end <= start || (hole_em->start > end)) {\n\t\t\t\tfree_extent_map(hole_em);\n\t\t\t\thole_em = NULL;\n\t\t\t} else {\n\t\t\t\thole_start = max(hole_em->start, start);\n\t\t\t\thole_len = calc_end - hole_start;\n\t\t\t}\n\t\t}\n\t\tem->bdev = NULL;\n\t\tif (hole_em && range_start > hole_start) {\n\t\t\t/* our hole starts before our delalloc, so we\n\t\t\t * have to return just the parts of the hole\n\t\t\t * that go until  the delalloc starts\n\t\t\t */\n\t\t\tem->len = min(hole_len,\n\t\t\t\t      range_start - hole_start);\n\t\t\tem->start = hole_start;\n\t\t\tem->orig_start = hole_start;\n\t\t\t/*\n\t\t\t * don't adjust block start at all,\n\t\t\t * it is fixed at EXTENT_MAP_HOLE\n\t\t\t */\n\t\t\tem->block_start = hole_em->block_start;\n\t\t\tem->block_len = hole_len;\n\t\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &hole_em->flags))\n\t\t\t\tset_bit(EXTENT_FLAG_PREALLOC, &em->flags);\n\t\t} else {\n\t\t\tem->start = range_start;\n\t\t\tem->len = found;\n\t\t\tem->orig_start = range_start;\n\t\t\tem->block_start = EXTENT_MAP_DELALLOC;\n\t\t\tem->block_len = found;\n\t\t}\n\t} else if (hole_em) {\n\t\treturn hole_em;\n\t}\nout:\n\n\tfree_extent_map(hole_em);\n\tif (err) {\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn em;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nstruct extent_map *btrfs_get_extent_fiemap(struct inode *inode, struct page *page,\n\t\t\t\t\t   size_t pg_offset, u64 start, u64 len,\n\t\t\t\t\t   int create)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *hole_em = NULL;\n\tu64 range_start = start;\n\tu64 end;\n\tu64 found;\n\tu64 found_end;\n\tint err = 0;\n\n\tem = btrfs_get_extent(inode, page, pg_offset, start, len, create);\n\tif (IS_ERR(em))\n\t\treturn em;\n\tif (em) {\n\t\t/*\n\t\t * if our em maps to\n\t\t * -  a hole or\n\t\t * -  a pre-alloc extent,\n\t\t * there might actually be delalloc bytes behind it.\n\t\t */\n\t\tif (em->block_start != EXTENT_MAP_HOLE &&\n\t\t    !test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\treturn em;\n\t\telse\n\t\t\thole_em = em;\n\t}\n\n\t/* check to see if we've wrapped (len == -1 or similar) */\n\tend = start + len;\n\tif (end < start)\n\t\tend = (u64)-1;\n\telse\n\t\tend -= 1;\n\n\tem = NULL;\n\n\t/* ok, we didn't find anything, lets look for delalloc */\n\tfound = count_range_bits(&BTRFS_I(inode)->io_tree, &range_start,\n\t\t\t\t end, len, EXTENT_DELALLOC, 1);\n\tfound_end = range_start + found;\n\tif (found_end < range_start)\n\t\tfound_end = (u64)-1;\n\n\t/*\n\t * we didn't find anything useful, return\n\t * the original results from get_extent()\n\t */\n\tif (range_start > end || found_end <= start) {\n\t\tem = hole_em;\n\t\thole_em = NULL;\n\t\tgoto out;\n\t}\n\n\t/* adjust the range_start to make sure it doesn't\n\t * go backwards from the start they passed in\n\t */\n\trange_start = max(start, range_start);\n\tfound = found_end - range_start;\n\n\tif (found > 0) {\n\t\tu64 hole_start = start;\n\t\tu64 hole_len = len;\n\n\t\tem = alloc_extent_map();\n\t\tif (!em) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * when btrfs_get_extent can't find anything it\n\t\t * returns one huge hole\n\t\t *\n\t\t * make sure what it found really fits our range, and\n\t\t * adjust to make sure it is based on the start from\n\t\t * the caller\n\t\t */\n\t\tif (hole_em) {\n\t\t\tu64 calc_end = extent_map_end(hole_em);\n\n\t\t\tif (calc_end <= start || (hole_em->start > end)) {\n\t\t\t\tfree_extent_map(hole_em);\n\t\t\t\thole_em = NULL;\n\t\t\t} else {\n\t\t\t\thole_start = max(hole_em->start, start);\n\t\t\t\thole_len = calc_end - hole_start;\n\t\t\t}\n\t\t}\n\t\tem->bdev = NULL;\n\t\tif (hole_em && range_start > hole_start) {\n\t\t\t/* our hole starts before our delalloc, so we\n\t\t\t * have to return just the parts of the hole\n\t\t\t * that go until  the delalloc starts\n\t\t\t */\n\t\t\tem->len = min(hole_len,\n\t\t\t\t      range_start - hole_start);\n\t\t\tem->start = hole_start;\n\t\t\tem->orig_start = hole_start;\n\t\t\t/*\n\t\t\t * don't adjust block start at all,\n\t\t\t * it is fixed at EXTENT_MAP_HOLE\n\t\t\t */\n\t\t\tem->block_start = hole_em->block_start;\n\t\t\tem->block_len = hole_len;\n\t\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &hole_em->flags))\n\t\t\t\tset_bit(EXTENT_FLAG_PREALLOC, &em->flags);\n\t\t} else {\n\t\t\tem->start = range_start;\n\t\t\tem->len = found;\n\t\t\tem->orig_start = range_start;\n\t\t\tem->block_start = EXTENT_MAP_DELALLOC;\n\t\t\tem->block_len = found;\n\t\t}\n\t} else if (hole_em) {\n\t\treturn hole_em;\n\t}\nout:\n\n\tfree_extent_map(hole_em);\n\tif (err) {\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn em;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected extent wanted start %llu len 12288, got \"\n\t\t\t \"start %llu len %llu\\n\"",
            "offset",
            "em->start",
            "em->len"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected a hole extent, got %llu\\n\"",
            "em->block_start"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Got an error when we shouldn't have\\n\""
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected flags set, want 0 have %lu\\n\"",
            "em->flags"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\"",
            "offset",
            "em->start",
            "em->len"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected a real extent, got %llu\\n\"",
            "em->block_start"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Got an error when we shouldn't have\\n\""
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected extent wanted start %llu len 8192, got \"\n\t\t\t \"start %llu len %llu\\n\"",
            "offset",
            "em->start",
            "em->len"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Got an error when we shouldn't have\\n\""
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected flags set, want 0 have %lu\\n\"",
            "em->flags"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\"",
            "offset",
            "em->start",
            "em->len"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected a real extent, got %llu\\n\"",
            "em->block_start"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Got an error when we shouldn't have\\n\""
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\"",
            "offset",
            "em->start",
            "em->len"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected a real extent, got %llu\\n\"",
            "em->block_start"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Got an error when we shouldn't have\\n\""
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected extent wanted start %llu len 8192, got \"\n\t\t\t \"start %llu len %llu\\n\"",
            "offset",
            "em->start",
            "em->len"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected a real extent, got %llu\\n\"",
            "em->block_start"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Got an error when we shouldn't have\\n\""
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected extent wanted start %llu len 8192, got \"\n\t\t\t \"start %llu len %llu\\n\"",
            "offset",
            "em->start",
            "em->len"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected a real extent, got %llu\\n\"",
            "em->block_start"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Got an error when we shouldn't have\\n\""
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected flags set, want 0 have %lu\\n\"",
            "em->flags"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\"",
            "offset",
            "em->start",
            "em->len"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected a real extent, got %llu\\n\"",
            "em->block_start"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Got an error when we shouldn't have\\n\""
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\"",
            "offset",
            "em->start",
            "em->len"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected a real extent, got %llu\\n\"",
            "em->block_start"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Got an error when we shouldn't have\\n\""
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\"",
            "offset",
            "em->start",
            "em->len"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected a real extent, got %llu\\n\"",
            "em->block_start"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Got an error when we shouldn't have\\n\""
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected flags set, want 0 have %lu\\n\"",
            "em->flags"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected extent wanted start %llu len 8192, got \"\n\t\t\t \"start %llu len %llu\\n\"",
            "offset",
            "em->start",
            "em->len"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected a real extent, got %llu\\n\"",
            "em->block_start"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Got an error when we shouldn't have\\n\""
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected flags set, want 0 have %lu\\n\"",
            "em->flags"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\"",
            "offset",
            "em->start",
            "em->len"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected a hole, got %llu\\n\"",
            "em->block_start"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Got an error when we shouldn't have\\n\""
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected flags set, want 0 have %lu\\n\"",
            "em->flags"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\"",
            "offset",
            "em->start",
            "em->len"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected a real extent, got %llu\\n\"",
            "em->block_start"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Got an error when we shouldn't have\\n\""
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected flags set, want 0 have %lu\\n\"",
            "em->flags"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected extent wanted start %llu len 4095, got \"\n\t\t\t \"start %llu len %llu\\n\"",
            "offset",
            "em->start",
            "em->len"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected a real extent, got %llu\\n\"",
            "em->block_start"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Got an error when we shouldn't have\\n\""
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected flags set, want 0 have %lu\\n\"",
            "em->flags"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected extent wanted start %llu len 4, got start \"\n\t\t\t \"%llu len %llu\\n\"",
            "offset",
            "em->start",
            "em->len"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected a hole, got %llu\\n\"",
            "em->block_start"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Got an error when we shouldn't have\\n\""
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected flags set, want 0 have %lu\\n\"",
            "em->flags"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected extent wanted start %llu len 1, got start \"\n\t\t\t \"%llu len %llu\\n\"",
            "offset",
            "em->start",
            "em->len"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected an inline, got %llu\\n\"",
            "em->block_start"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Got an error when we shouldn't have\\n\""
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Unexpected flags set, want 0 have %lu\\n\"",
            "em->flags"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected a hole, got %llu\\n\"",
            "em->block_start"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Got an error when we shouldn't have\\n\""
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_file_extents",
          "args": [
            "root"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "setup_file_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/inode-tests.c",
          "lines": "100-216",
          "snippet": "static void setup_file_extents(struct btrfs_root *root)\n{\n\tint slot = 0;\n\tu64 disk_bytenr = 1 * 1024 * 1024;\n\tu64 offset = 0;\n\n\t/* First we want a hole */\n\tinsert_extent(root, offset, 5, 5, 0, 0, 0, BTRFS_FILE_EXTENT_REG, 0,\n\t\t      slot);\n\tslot++;\n\toffset += 5;\n\n\t/*\n\t * Now we want an inline extent, I don't think this is possible but hey\n\t * why not?  Also keep in mind if we have an inline extent it counts as\n\t * the whole first page.  If we were to expand it we would have to cow\n\t * and we wouldn't have an inline extent anymore.\n\t */\n\tinsert_extent(root, offset, 1, 1, 0, 0, 0, BTRFS_FILE_EXTENT_INLINE, 0,\n\t\t      slot);\n\tslot++;\n\toffset = 4096;\n\n\t/* Now another hole */\n\tinsert_extent(root, offset, 4, 4, 0, 0, 0, BTRFS_FILE_EXTENT_REG, 0,\n\t\t      slot);\n\tslot++;\n\toffset += 4;\n\n\t/* Now for a regular extent */\n\tinsert_extent(root, offset, 4095, 4095, 0, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n\tslot++;\n\tdisk_bytenr += 4096;\n\toffset += 4095;\n\n\t/*\n\t * Now for 3 extents that were split from a hole punch so we test\n\t * offsets properly.\n\t */\n\tinsert_extent(root, offset, 4096, 16384, 0, disk_bytenr, 16384,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n\tslot++;\n\toffset += 4096;\n\tinsert_extent(root, offset, 4096, 4096, 0, 0, 0, BTRFS_FILE_EXTENT_REG,\n\t\t      0, slot);\n\tslot++;\n\toffset += 4096;\n\tinsert_extent(root, offset, 8192, 16384, 8192, disk_bytenr, 16384,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n\tslot++;\n\toffset += 8192;\n\tdisk_bytenr += 16384;\n\n\t/* Now for a unwritten prealloc extent */\n\tinsert_extent(root, offset, 4096, 4096, 0, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_PREALLOC, 0, slot);\n\tslot++;\n\toffset += 4096;\n\n\t/*\n\t * We want to jack up disk_bytenr a little more so the em stuff doesn't\n\t * merge our records.\n\t */\n\tdisk_bytenr += 8192;\n\n\t/*\n\t * Now for a partially written prealloc extent, basically the same as\n\t * the hole punch example above.  Ram_bytes never changes when you mark\n\t * extents written btw.\n\t */\n\tinsert_extent(root, offset, 4096, 16384, 0, disk_bytenr, 16384,\n\t\t      BTRFS_FILE_EXTENT_PREALLOC, 0, slot);\n\tslot++;\n\toffset += 4096;\n\tinsert_extent(root, offset, 4096, 16384, 4096, disk_bytenr, 16384,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n\tslot++;\n\toffset += 4096;\n\tinsert_extent(root, offset, 8192, 16384, 8192, disk_bytenr, 16384,\n\t\t      BTRFS_FILE_EXTENT_PREALLOC, 0, slot);\n\tslot++;\n\toffset += 8192;\n\tdisk_bytenr += 16384;\n\n\t/* Now a normal compressed extent */\n\tinsert_extent(root, offset, 8192, 8192, 0, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, BTRFS_COMPRESS_ZLIB, slot);\n\tslot++;\n\toffset += 8192;\n\t/* No merges */\n\tdisk_bytenr += 8192;\n\n\t/* Now a split compressed extent */\n\tinsert_extent(root, offset, 4096, 16384, 0, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, BTRFS_COMPRESS_ZLIB, slot);\n\tslot++;\n\toffset += 4096;\n\tinsert_extent(root, offset, 4096, 4096, 0, disk_bytenr + 4096, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n\tslot++;\n\toffset += 4096;\n\tinsert_extent(root, offset, 8192, 16384, 8192, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, BTRFS_COMPRESS_ZLIB, slot);\n\tslot++;\n\toffset += 8192;\n\tdisk_bytenr += 8192;\n\n\t/* Now extents that have a hole but no hole extent */\n\tinsert_extent(root, offset, 4096, 4096, 0, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n\tslot++;\n\toffset += 16384;\n\tdisk_bytenr += 4096;\n\tinsert_extent(root, offset, 4096, 4096, 0, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n}",
          "includes": [
            "#include \"../volumes.h\"",
            "#include \"../extent_io.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../btrfs_inode.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../volumes.h\"\n#include \"../extent_io.h\"\n#include \"../disk-io.h\"\n#include \"../btrfs_inode.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic void setup_file_extents(struct btrfs_root *root)\n{\n\tint slot = 0;\n\tu64 disk_bytenr = 1 * 1024 * 1024;\n\tu64 offset = 0;\n\n\t/* First we want a hole */\n\tinsert_extent(root, offset, 5, 5, 0, 0, 0, BTRFS_FILE_EXTENT_REG, 0,\n\t\t      slot);\n\tslot++;\n\toffset += 5;\n\n\t/*\n\t * Now we want an inline extent, I don't think this is possible but hey\n\t * why not?  Also keep in mind if we have an inline extent it counts as\n\t * the whole first page.  If we were to expand it we would have to cow\n\t * and we wouldn't have an inline extent anymore.\n\t */\n\tinsert_extent(root, offset, 1, 1, 0, 0, 0, BTRFS_FILE_EXTENT_INLINE, 0,\n\t\t      slot);\n\tslot++;\n\toffset = 4096;\n\n\t/* Now another hole */\n\tinsert_extent(root, offset, 4, 4, 0, 0, 0, BTRFS_FILE_EXTENT_REG, 0,\n\t\t      slot);\n\tslot++;\n\toffset += 4;\n\n\t/* Now for a regular extent */\n\tinsert_extent(root, offset, 4095, 4095, 0, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n\tslot++;\n\tdisk_bytenr += 4096;\n\toffset += 4095;\n\n\t/*\n\t * Now for 3 extents that were split from a hole punch so we test\n\t * offsets properly.\n\t */\n\tinsert_extent(root, offset, 4096, 16384, 0, disk_bytenr, 16384,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n\tslot++;\n\toffset += 4096;\n\tinsert_extent(root, offset, 4096, 4096, 0, 0, 0, BTRFS_FILE_EXTENT_REG,\n\t\t      0, slot);\n\tslot++;\n\toffset += 4096;\n\tinsert_extent(root, offset, 8192, 16384, 8192, disk_bytenr, 16384,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n\tslot++;\n\toffset += 8192;\n\tdisk_bytenr += 16384;\n\n\t/* Now for a unwritten prealloc extent */\n\tinsert_extent(root, offset, 4096, 4096, 0, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_PREALLOC, 0, slot);\n\tslot++;\n\toffset += 4096;\n\n\t/*\n\t * We want to jack up disk_bytenr a little more so the em stuff doesn't\n\t * merge our records.\n\t */\n\tdisk_bytenr += 8192;\n\n\t/*\n\t * Now for a partially written prealloc extent, basically the same as\n\t * the hole punch example above.  Ram_bytes never changes when you mark\n\t * extents written btw.\n\t */\n\tinsert_extent(root, offset, 4096, 16384, 0, disk_bytenr, 16384,\n\t\t      BTRFS_FILE_EXTENT_PREALLOC, 0, slot);\n\tslot++;\n\toffset += 4096;\n\tinsert_extent(root, offset, 4096, 16384, 4096, disk_bytenr, 16384,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n\tslot++;\n\toffset += 4096;\n\tinsert_extent(root, offset, 8192, 16384, 8192, disk_bytenr, 16384,\n\t\t      BTRFS_FILE_EXTENT_PREALLOC, 0, slot);\n\tslot++;\n\toffset += 8192;\n\tdisk_bytenr += 16384;\n\n\t/* Now a normal compressed extent */\n\tinsert_extent(root, offset, 8192, 8192, 0, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, BTRFS_COMPRESS_ZLIB, slot);\n\tslot++;\n\toffset += 8192;\n\t/* No merges */\n\tdisk_bytenr += 8192;\n\n\t/* Now a split compressed extent */\n\tinsert_extent(root, offset, 4096, 16384, 0, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, BTRFS_COMPRESS_ZLIB, slot);\n\tslot++;\n\toffset += 4096;\n\tinsert_extent(root, offset, 4096, 4096, 0, disk_bytenr + 4096, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n\tslot++;\n\toffset += 4096;\n\tinsert_extent(root, offset, 8192, 16384, 8192, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, BTRFS_COMPRESS_ZLIB, slot);\n\tslot++;\n\toffset += 8192;\n\tdisk_bytenr += 8192;\n\n\t/* Now extents that have a hole but no hole extent */\n\tinsert_extent(root, offset, 4096, 4096, 0, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n\tslot++;\n\toffset += 16384;\n\tdisk_bytenr += 4096;\n\tinsert_extent(root, offset, 4096, 4096, 0, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_drop_extent_cache",
          "args": [
            "inode",
            "0",
            "(u64)-1",
            "0"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_drop_extent_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "535-684",
          "snippet": "void btrfs_drop_extent_cache(struct inode *inode, u64 start, u64 end,\n\t\t\t     int skip_pinned)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *split = NULL;\n\tstruct extent_map *split2 = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 len = end - start + 1;\n\tu64 gen;\n\tint ret;\n\tint testend = 1;\n\tunsigned long flags;\n\tint compressed = 0;\n\tbool modified;\n\n\tWARN_ON(end < start);\n\tif (end == (u64)-1) {\n\t\tlen = (u64)-1;\n\t\ttestend = 0;\n\t}\n\twhile (1) {\n\t\tint no_splits = 0;\n\n\t\tmodified = false;\n\t\tif (!split)\n\t\t\tsplit = alloc_extent_map();\n\t\tif (!split2)\n\t\t\tsplit2 = alloc_extent_map();\n\t\tif (!split || !split2)\n\t\t\tno_splits = 1;\n\n\t\twrite_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, start, len);\n\t\tif (!em) {\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tbreak;\n\t\t}\n\t\tflags = em->flags;\n\t\tgen = em->generation;\n\t\tif (skip_pinned && test_bit(EXTENT_FLAG_PINNED, &em->flags)) {\n\t\t\tif (testend && em->start + em->len >= start + len) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\twrite_unlock(&em_tree->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart = em->start + em->len;\n\t\t\tif (testend)\n\t\t\t\tlen = start + len - (em->start + em->len);\n\t\t\tfree_extent_map(em);\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tcontinue;\n\t\t}\n\t\tcompressed = test_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_PINNED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_LOGGING, &flags);\n\t\tmodified = !list_empty(&em->list);\n\t\tif (no_splits)\n\t\t\tgoto next;\n\n\t\tif (em->start < start) {\n\t\t\tsplit->start = em->start;\n\t\t\tsplit->len = start - em->start;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\tsplit->block_start = em->block_start;\n\n\t\t\t\tif (compressed)\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\telse\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\tsplit->orig_block_len = max(split->block_len,\n\t\t\t\t\t\tem->orig_block_len);\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t} else {\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t}\n\n\t\t\tsplit->generation = gen;\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\treplace_extent_mapping(em_tree, em, split, modified);\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = split2;\n\t\t\tsplit2 = NULL;\n\t\t}\n\t\tif (testend && em->start + em->len > start + len) {\n\t\t\tu64 diff = start + len - em->start;\n\n\t\t\tsplit->start = start + len;\n\t\t\tsplit->len = em->start + em->len - (start + len);\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\tsplit->generation = gen;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_block_len = max(em->block_len,\n\t\t\t\t\t\t    em->orig_block_len);\n\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t\tif (compressed) {\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t} else {\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\t\tsplit->block_start = em->block_start\n\t\t\t\t\t\t+ diff;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t}\n\n\t\t\tif (extent_map_in_tree(em)) {\n\t\t\t\treplace_extent_mapping(em_tree, em, split,\n\t\t\t\t\t\t       modified);\n\t\t\t} else {\n\t\t\t\tret = add_extent_mapping(em_tree, split,\n\t\t\t\t\t\t\t modified);\n\t\t\t\tASSERT(ret == 0); /* Logic error */\n\t\t\t}\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = NULL;\n\t\t}\nnext:\n\t\tif (extent_map_in_tree(em))\n\t\t\tremove_extent_mapping(em_tree, em);\n\t\twrite_unlock(&em_tree->lock);\n\n\t\t/* once for us */\n\t\tfree_extent_map(em);\n\t\t/* once for the tree*/\n\t\tfree_extent_map(em);\n\t}\n\tif (split)\n\t\tfree_extent_map(split);\n\tif (split2)\n\t\tfree_extent_map(split2);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nvoid btrfs_drop_extent_cache(struct inode *inode, u64 start, u64 end,\n\t\t\t     int skip_pinned)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *split = NULL;\n\tstruct extent_map *split2 = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 len = end - start + 1;\n\tu64 gen;\n\tint ret;\n\tint testend = 1;\n\tunsigned long flags;\n\tint compressed = 0;\n\tbool modified;\n\n\tWARN_ON(end < start);\n\tif (end == (u64)-1) {\n\t\tlen = (u64)-1;\n\t\ttestend = 0;\n\t}\n\twhile (1) {\n\t\tint no_splits = 0;\n\n\t\tmodified = false;\n\t\tif (!split)\n\t\t\tsplit = alloc_extent_map();\n\t\tif (!split2)\n\t\t\tsplit2 = alloc_extent_map();\n\t\tif (!split || !split2)\n\t\t\tno_splits = 1;\n\n\t\twrite_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, start, len);\n\t\tif (!em) {\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tbreak;\n\t\t}\n\t\tflags = em->flags;\n\t\tgen = em->generation;\n\t\tif (skip_pinned && test_bit(EXTENT_FLAG_PINNED, &em->flags)) {\n\t\t\tif (testend && em->start + em->len >= start + len) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\twrite_unlock(&em_tree->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart = em->start + em->len;\n\t\t\tif (testend)\n\t\t\t\tlen = start + len - (em->start + em->len);\n\t\t\tfree_extent_map(em);\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tcontinue;\n\t\t}\n\t\tcompressed = test_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_PINNED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_LOGGING, &flags);\n\t\tmodified = !list_empty(&em->list);\n\t\tif (no_splits)\n\t\t\tgoto next;\n\n\t\tif (em->start < start) {\n\t\t\tsplit->start = em->start;\n\t\t\tsplit->len = start - em->start;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\tsplit->block_start = em->block_start;\n\n\t\t\t\tif (compressed)\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\telse\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\tsplit->orig_block_len = max(split->block_len,\n\t\t\t\t\t\tem->orig_block_len);\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t} else {\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t}\n\n\t\t\tsplit->generation = gen;\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\treplace_extent_mapping(em_tree, em, split, modified);\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = split2;\n\t\t\tsplit2 = NULL;\n\t\t}\n\t\tif (testend && em->start + em->len > start + len) {\n\t\t\tu64 diff = start + len - em->start;\n\n\t\t\tsplit->start = start + len;\n\t\t\tsplit->len = em->start + em->len - (start + len);\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\tsplit->generation = gen;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_block_len = max(em->block_len,\n\t\t\t\t\t\t    em->orig_block_len);\n\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t\tif (compressed) {\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t} else {\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\t\tsplit->block_start = em->block_start\n\t\t\t\t\t\t+ diff;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t}\n\n\t\t\tif (extent_map_in_tree(em)) {\n\t\t\t\treplace_extent_mapping(em_tree, em, split,\n\t\t\t\t\t\t       modified);\n\t\t\t} else {\n\t\t\t\tret = add_extent_mapping(em_tree, split,\n\t\t\t\t\t\t\t modified);\n\t\t\t\tASSERT(ret == 0); /* Logic error */\n\t\t\t}\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = NULL;\n\t\t}\nnext:\n\t\tif (extent_map_in_tree(em))\n\t\t\tremove_extent_mapping(em_tree, em);\n\t\twrite_unlock(&em_tree->lock);\n\n\t\t/* once for us */\n\t\tfree_extent_map(em);\n\t\t/* once for the tree*/\n\t\tfree_extent_map(em);\n\t}\n\tif (split)\n\t\tfree_extent_map(split);\n\tif (split2)\n\t\tfree_extent_map(split2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Vacancy flag wasn't set properly\\n\""
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_FLAG_VACANCY",
            "&em->flags"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected a hole, got %llu\\n\"",
            "em->block_start"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Got an error when we shouldn't have\\n\""
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_level",
          "args": [
            "root->node",
            "0"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_nritems",
          "args": [
            "root->node",
            "0"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_buffer_get",
          "args": [
            "root->node"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "287-290",
          "snippet": "static inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't allocate dummy buffer\\n\""
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_dummy_extent_buffer",
          "args": [
            "NULL",
            "4096"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_dummy_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4672-4710",
          "snippet": "struct extent_buffer *alloc_dummy_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tu64 start)\n{\n\tstruct extent_buffer *eb;\n\tunsigned long len;\n\tunsigned long num_pages;\n\tunsigned long i;\n\n\tif (!fs_info) {\n\t\t/*\n\t\t * Called only from tests that don't always have a fs_info\n\t\t * available, but we know that nodesize is 4096\n\t\t */\n\t\tlen = 4096;\n\t} else {\n\t\tlen = fs_info->tree_root->nodesize;\n\t}\n\tnum_pages = num_extent_pages(0, len);\n\n\teb = __alloc_extent_buffer(fs_info, start, len);\n\tif (!eb)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\teb->pages[i] = alloc_page(GFP_NOFS);\n\t\tif (!eb->pages[i])\n\t\t\tgoto err;\n\t}\n\tset_extent_buffer_uptodate(eb);\n\tbtrfs_set_header_nritems(eb, 0);\n\tset_bit(EXTENT_BUFFER_DUMMY, &eb->bflags);\n\n\treturn eb;\nerr:\n\tfor (; i > 0; i--)\n\t\t__free_page(eb->pages[i - 1]);\n\t__free_extent_buffer(eb);\n\treturn NULL;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstruct extent_buffer *alloc_dummy_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tu64 start)\n{\n\tstruct extent_buffer *eb;\n\tunsigned long len;\n\tunsigned long num_pages;\n\tunsigned long i;\n\n\tif (!fs_info) {\n\t\t/*\n\t\t * Called only from tests that don't always have a fs_info\n\t\t * available, but we know that nodesize is 4096\n\t\t */\n\t\tlen = 4096;\n\t} else {\n\t\tlen = fs_info->tree_root->nodesize;\n\t}\n\tnum_pages = num_extent_pages(0, len);\n\n\teb = __alloc_extent_buffer(fs_info, start, len);\n\tif (!eb)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\teb->pages[i] = alloc_page(GFP_NOFS);\n\t\tif (!eb->pages[i])\n\t\t\tgoto err;\n\t}\n\tset_extent_buffer_uptodate(eb);\n\tbtrfs_set_header_nritems(eb, 0);\n\tset_bit(EXTENT_BUFFER_DUMMY, &eb->bflags);\n\n\treturn eb;\nerr:\n\tfor (; i > 0; i--)\n\t\t__free_page(eb->pages[i - 1]);\n\t__free_extent_buffer(eb);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't allocate dummy fs info\\n\""
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_dummy_fs_info",
          "args": [],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_dummy_fs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.c",
          "lines": "79-126",
          "snippet": "struct btrfs_fs_info *btrfs_alloc_dummy_fs_info(void)\n{\n\tstruct btrfs_fs_info *fs_info = kzalloc(sizeof(struct btrfs_fs_info),\n\t\t\t\t\t\tGFP_NOFS);\n\n\tif (!fs_info)\n\t\treturn fs_info;\n\tfs_info->fs_devices = kzalloc(sizeof(struct btrfs_fs_devices),\n\t\t\t\t      GFP_NOFS);\n\tif (!fs_info->fs_devices) {\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\tfs_info->super_copy = kzalloc(sizeof(struct btrfs_super_block),\n\t\t\t\t      GFP_NOFS);\n\tif (!fs_info->super_copy) {\n\t\tkfree(fs_info->fs_devices);\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\n\tif (init_srcu_struct(&fs_info->subvol_srcu)) {\n\t\tkfree(fs_info->fs_devices);\n\t\tkfree(fs_info->super_copy);\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_init(&fs_info->buffer_lock);\n\tspin_lock_init(&fs_info->qgroup_lock);\n\tspin_lock_init(&fs_info->qgroup_op_lock);\n\tspin_lock_init(&fs_info->super_lock);\n\tspin_lock_init(&fs_info->fs_roots_radix_lock);\n\tspin_lock_init(&fs_info->tree_mod_seq_lock);\n\tmutex_init(&fs_info->qgroup_ioctl_lock);\n\tmutex_init(&fs_info->qgroup_rescan_lock);\n\trwlock_init(&fs_info->tree_mod_log_lock);\n\tfs_info->running_transaction = NULL;\n\tfs_info->qgroup_tree = RB_ROOT;\n\tfs_info->qgroup_ulist = NULL;\n\tatomic64_set(&fs_info->tree_mod_seq, 0);\n\tINIT_LIST_HEAD(&fs_info->dirty_qgroups);\n\tINIT_LIST_HEAD(&fs_info->dead_roots);\n\tINIT_LIST_HEAD(&fs_info->tree_mod_seq_list);\n\tINIT_RADIX_TREE(&fs_info->buffer_radix, GFP_ATOMIC);\n\tINIT_RADIX_TREE(&fs_info->fs_roots_radix, GFP_ATOMIC);\n\treturn fs_info;\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../volumes.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\"",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../volumes.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstruct btrfs_fs_info *btrfs_alloc_dummy_fs_info(void)\n{\n\tstruct btrfs_fs_info *fs_info = kzalloc(sizeof(struct btrfs_fs_info),\n\t\t\t\t\t\tGFP_NOFS);\n\n\tif (!fs_info)\n\t\treturn fs_info;\n\tfs_info->fs_devices = kzalloc(sizeof(struct btrfs_fs_devices),\n\t\t\t\t      GFP_NOFS);\n\tif (!fs_info->fs_devices) {\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\tfs_info->super_copy = kzalloc(sizeof(struct btrfs_super_block),\n\t\t\t\t      GFP_NOFS);\n\tif (!fs_info->super_copy) {\n\t\tkfree(fs_info->fs_devices);\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\n\tif (init_srcu_struct(&fs_info->subvol_srcu)) {\n\t\tkfree(fs_info->fs_devices);\n\t\tkfree(fs_info->super_copy);\n\t\tkfree(fs_info);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_init(&fs_info->buffer_lock);\n\tspin_lock_init(&fs_info->qgroup_lock);\n\tspin_lock_init(&fs_info->qgroup_op_lock);\n\tspin_lock_init(&fs_info->super_lock);\n\tspin_lock_init(&fs_info->fs_roots_radix_lock);\n\tspin_lock_init(&fs_info->tree_mod_seq_lock);\n\tmutex_init(&fs_info->qgroup_ioctl_lock);\n\tmutex_init(&fs_info->qgroup_rescan_lock);\n\trwlock_init(&fs_info->tree_mod_log_lock);\n\tfs_info->running_transaction = NULL;\n\tfs_info->qgroup_tree = RB_ROOT;\n\tfs_info->qgroup_ulist = NULL;\n\tatomic64_set(&fs_info->tree_mod_seq, 0);\n\tINIT_LIST_HEAD(&fs_info->dirty_qgroups);\n\tINIT_LIST_HEAD(&fs_info->dead_roots);\n\tINIT_LIST_HEAD(&fs_info->tree_mod_seq_list);\n\tINIT_RADIX_TREE(&fs_info->buffer_radix, GFP_ATOMIC);\n\tINIT_RADIX_TREE(&fs_info->fs_roots_radix, GFP_ATOMIC);\n\treturn fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't allocate root\\n\""
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_dummy_root",
          "args": [],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_dummy_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1298-1310",
          "snippet": "struct btrfs_root *btrfs_alloc_dummy_root(void)\n{\n\tstruct btrfs_root *root;\n\n\troot = btrfs_alloc_root(NULL);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\t__setup_root(4096, 4096, 4096, root, NULL, 1);\n\tset_bit(BTRFS_ROOT_DUMMY_ROOT, &root->state);\n\troot->alloc_bytenr = 0;\n\n\treturn root;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct btrfs_root *btrfs_alloc_dummy_root(void)\n{\n\tstruct btrfs_root *root;\n\n\troot = btrfs_alloc_root(NULL);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\t__setup_root(4096, 4096, 4096, root, NULL, 1);\n\tset_bit(BTRFS_ROOT_DUMMY_ROOT, &root->state);\n\troot->alloc_bytenr = 0;\n\n\treturn root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't allocate inode\\n\""
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_new_test_inode",
          "args": [],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_new_test_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.c",
          "lines": "49-52",
          "snippet": "struct inode *btrfs_new_test_inode(void)\n{\n\treturn new_inode(test_mnt->mnt_sb);\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../volumes.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\"",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *test_mnt = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../volumes.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct vfsmount *test_mnt = NULL;\n\nstruct inode *btrfs_new_test_inode(void)\n{\n\treturn new_inode(test_mnt->mnt_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../volumes.h\"\n#include \"../extent_io.h\"\n#include \"../disk-io.h\"\n#include \"../btrfs_inode.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic unsigned long prealloc_only = 0;\nstatic unsigned long compressed_only = 0;\nstatic unsigned long vacancy_only = 0;\n\nstatic noinline int test_btrfs_get_extent(void)\n{\n\tstruct inode *inode = NULL;\n\tstruct btrfs_root *root = NULL;\n\tstruct extent_map *em = NULL;\n\tu64 orig_start;\n\tu64 disk_bytenr;\n\tu64 offset;\n\tint ret = -ENOMEM;\n\n\tinode = btrfs_new_test_inode();\n\tif (!inode) {\n\t\ttest_msg(\"Couldn't allocate inode\\n\");\n\t\treturn ret;\n\t}\n\n\tBTRFS_I(inode)->location.type = BTRFS_INODE_ITEM_KEY;\n\tBTRFS_I(inode)->location.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tBTRFS_I(inode)->location.offset = 0;\n\n\troot = btrfs_alloc_dummy_root();\n\tif (IS_ERR(root)) {\n\t\ttest_msg(\"Couldn't allocate root\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We do this since btrfs_get_extent wants to assign em->bdev to\n\t * root->fs_info->fs_devices->latest_bdev.\n\t */\n\troot->fs_info = btrfs_alloc_dummy_fs_info();\n\tif (!root->fs_info) {\n\t\ttest_msg(\"Couldn't allocate dummy fs info\\n\");\n\t\tgoto out;\n\t}\n\n\troot->node = alloc_dummy_extent_buffer(NULL, 4096);\n\tif (!root->node) {\n\t\ttest_msg(\"Couldn't allocate dummy buffer\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We will just free a dummy node if it's ref count is 2 so we need an\n\t * extra ref so our searches don't accidently release our page.\n\t */\n\textent_buffer_get(root->node);\n\tbtrfs_set_header_nritems(root->node, 0);\n\tbtrfs_set_header_level(root->node, 0);\n\tret = -EINVAL;\n\n\t/* First with no extents */\n\tBTRFS_I(inode)->root = root;\n\tem = btrfs_get_extent(inode, NULL, 0, 0, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\tem = NULL;\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a hole, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (!test_bit(EXTENT_FLAG_VACANCY, &em->flags)) {\n\t\ttest_msg(\"Vacancy flag wasn't set properly\\n\");\n\t\tgoto out;\n\t}\n\tfree_extent_map(em);\n\tbtrfs_drop_extent_cache(inode, 0, (u64)-1, 0);\n\n\t/*\n\t * All of the magic numbers are based on the mapping setup in\n\t * setup_file_extents, so if you change anything there you need to\n\t * update the comment and update the expected values below.\n\t */\n\tsetup_file_extents(root);\n\n\tem = btrfs_get_extent(inode, NULL, 0, 0, (u64)-1, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a hole, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != 0 || em->len != 5) {\n\t\ttest_msg(\"Unexpected extent wanted start 0 len 5, got start \"\n\t\t\t \"%llu len %llu\\n\", em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_INLINE) {\n\t\ttest_msg(\"Expected an inline, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4091) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 1, got start \"\n\t\t\t \"%llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\t/*\n\t * We don't test anything else for inline since it doesn't get set\n\t * unless we have a page for it to write into.  Maybe we should change\n\t * this?\n\t */\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a hole, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4, got start \"\n\t\t\t \"%llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* Regular extent */\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4095) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4095, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* The next 3 are split extents */\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\tdisk_bytenr = em->block_start;\n\torig_start = em->start;\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a hole, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 8192) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 8192, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != orig_start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\",\n\t\t\t orig_start, em->orig_start);\n\t\tgoto out;\n\t}\n\tdisk_bytenr += (em->start - orig_start);\n\tif (em->block_start != disk_bytenr) {\n\t\ttest_msg(\"Wrong block start, want %llu, have %llu\\n\",\n\t\t\t disk_bytenr, em->block_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* Prealloc extent */\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != prealloc_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t prealloc_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* The next 3 are a half written prealloc extent */\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != prealloc_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t prealloc_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\tdisk_bytenr = em->block_start;\n\torig_start = em->start;\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != orig_start) {\n\t\ttest_msg(\"Unexpected orig offset, wanted %llu, have %llu\\n\",\n\t\t\t orig_start, em->orig_start);\n\t\tgoto out;\n\t}\n\tif (em->block_start != (disk_bytenr + (em->start - em->orig_start))) {\n\t\ttest_msg(\"Unexpected block start, wanted %llu, have %llu\\n\",\n\t\t\t disk_bytenr + (em->start - em->orig_start),\n\t\t\t em->block_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 8192) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 8192, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != prealloc_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t prealloc_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != orig_start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", orig_start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\tif (em->block_start != (disk_bytenr + (em->start - em->orig_start))) {\n\t\ttest_msg(\"Unexpected block start, wanted %llu, have %llu\\n\",\n\t\t\t disk_bytenr + (em->start - em->orig_start),\n\t\t\t em->block_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* Now for the compressed extent */\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 8192) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 8192, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != compressed_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t compressed_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\",\n\t\t\t em->start, em->orig_start);\n\t\tgoto out;\n\t}\n\tif (em->compress_type != BTRFS_COMPRESS_ZLIB) {\n\t\ttest_msg(\"Unexpected compress type, wanted %d, got %d\\n\",\n\t\t\t BTRFS_COMPRESS_ZLIB, em->compress_type);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* Split compressed extent */\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != compressed_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t compressed_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\",\n\t\t\t em->start, em->orig_start);\n\t\tgoto out;\n\t}\n\tif (em->compress_type != BTRFS_COMPRESS_ZLIB) {\n\t\ttest_msg(\"Unexpected compress type, wanted %d, got %d\\n\",\n\t\t\t BTRFS_COMPRESS_ZLIB, em->compress_type);\n\t\tgoto out;\n\t}\n\tdisk_bytenr = em->block_start;\n\torig_start = em->start;\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != disk_bytenr) {\n\t\ttest_msg(\"Block start does not match, want %llu got %llu\\n\",\n\t\t\t disk_bytenr, em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 8192) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 8192, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != compressed_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t compressed_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != orig_start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\",\n\t\t\t em->start, orig_start);\n\t\tgoto out;\n\t}\n\tif (em->compress_type != BTRFS_COMPRESS_ZLIB) {\n\t\ttest_msg(\"Unexpected compress type, wanted %d, got %d\\n\",\n\t\t\t BTRFS_COMPRESS_ZLIB, em->compress_type);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\t/* A hole between regular extents but no hole extent */\n\tem = btrfs_get_extent(inode, NULL, 0, offset + 6, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096 * 1024, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start != EXTENT_MAP_HOLE) {\n\t\ttest_msg(\"Expected a hole extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\t/*\n\t * Currently we just return a length that we requested rather than the\n\t * length of the actual hole, if this changes we'll have to change this\n\t * test.\n\t */\n\tif (em->start != offset || em->len != 12288) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 12288, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != vacancy_only) {\n\t\ttest_msg(\"Unexpected flags set, want %lu have %lu\\n\",\n\t\t\t vacancy_only, em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\toffset = em->start + em->len;\n\tfree_extent_map(em);\n\n\tem = btrfs_get_extent(inode, NULL, 0, offset, 4096, 0);\n\tif (IS_ERR(em)) {\n\t\ttest_msg(\"Got an error when we shouldn't have\\n\");\n\t\tgoto out;\n\t}\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\ttest_msg(\"Expected a real extent, got %llu\\n\", em->block_start);\n\t\tgoto out;\n\t}\n\tif (em->start != offset || em->len != 4096) {\n\t\ttest_msg(\"Unexpected extent wanted start %llu len 4096, got \"\n\t\t\t \"start %llu len %llu\\n\", offset, em->start, em->len);\n\t\tgoto out;\n\t}\n\tif (em->flags != 0) {\n\t\ttest_msg(\"Unexpected flags set, want 0 have %lu\\n\", em->flags);\n\t\tgoto out;\n\t}\n\tif (em->orig_start != em->start) {\n\t\ttest_msg(\"Wrong orig offset, want %llu, have %llu\\n\", em->start,\n\t\t\t em->orig_start);\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tif (!IS_ERR(em))\n\t\tfree_extent_map(em);\n\tiput(inode);\n\tbtrfs_free_dummy_root(root);\n\treturn ret;\n}"
  },
  {
    "function_name": "setup_file_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/inode-tests.c",
    "lines": "100-216",
    "snippet": "static void setup_file_extents(struct btrfs_root *root)\n{\n\tint slot = 0;\n\tu64 disk_bytenr = 1 * 1024 * 1024;\n\tu64 offset = 0;\n\n\t/* First we want a hole */\n\tinsert_extent(root, offset, 5, 5, 0, 0, 0, BTRFS_FILE_EXTENT_REG, 0,\n\t\t      slot);\n\tslot++;\n\toffset += 5;\n\n\t/*\n\t * Now we want an inline extent, I don't think this is possible but hey\n\t * why not?  Also keep in mind if we have an inline extent it counts as\n\t * the whole first page.  If we were to expand it we would have to cow\n\t * and we wouldn't have an inline extent anymore.\n\t */\n\tinsert_extent(root, offset, 1, 1, 0, 0, 0, BTRFS_FILE_EXTENT_INLINE, 0,\n\t\t      slot);\n\tslot++;\n\toffset = 4096;\n\n\t/* Now another hole */\n\tinsert_extent(root, offset, 4, 4, 0, 0, 0, BTRFS_FILE_EXTENT_REG, 0,\n\t\t      slot);\n\tslot++;\n\toffset += 4;\n\n\t/* Now for a regular extent */\n\tinsert_extent(root, offset, 4095, 4095, 0, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n\tslot++;\n\tdisk_bytenr += 4096;\n\toffset += 4095;\n\n\t/*\n\t * Now for 3 extents that were split from a hole punch so we test\n\t * offsets properly.\n\t */\n\tinsert_extent(root, offset, 4096, 16384, 0, disk_bytenr, 16384,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n\tslot++;\n\toffset += 4096;\n\tinsert_extent(root, offset, 4096, 4096, 0, 0, 0, BTRFS_FILE_EXTENT_REG,\n\t\t      0, slot);\n\tslot++;\n\toffset += 4096;\n\tinsert_extent(root, offset, 8192, 16384, 8192, disk_bytenr, 16384,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n\tslot++;\n\toffset += 8192;\n\tdisk_bytenr += 16384;\n\n\t/* Now for a unwritten prealloc extent */\n\tinsert_extent(root, offset, 4096, 4096, 0, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_PREALLOC, 0, slot);\n\tslot++;\n\toffset += 4096;\n\n\t/*\n\t * We want to jack up disk_bytenr a little more so the em stuff doesn't\n\t * merge our records.\n\t */\n\tdisk_bytenr += 8192;\n\n\t/*\n\t * Now for a partially written prealloc extent, basically the same as\n\t * the hole punch example above.  Ram_bytes never changes when you mark\n\t * extents written btw.\n\t */\n\tinsert_extent(root, offset, 4096, 16384, 0, disk_bytenr, 16384,\n\t\t      BTRFS_FILE_EXTENT_PREALLOC, 0, slot);\n\tslot++;\n\toffset += 4096;\n\tinsert_extent(root, offset, 4096, 16384, 4096, disk_bytenr, 16384,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n\tslot++;\n\toffset += 4096;\n\tinsert_extent(root, offset, 8192, 16384, 8192, disk_bytenr, 16384,\n\t\t      BTRFS_FILE_EXTENT_PREALLOC, 0, slot);\n\tslot++;\n\toffset += 8192;\n\tdisk_bytenr += 16384;\n\n\t/* Now a normal compressed extent */\n\tinsert_extent(root, offset, 8192, 8192, 0, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, BTRFS_COMPRESS_ZLIB, slot);\n\tslot++;\n\toffset += 8192;\n\t/* No merges */\n\tdisk_bytenr += 8192;\n\n\t/* Now a split compressed extent */\n\tinsert_extent(root, offset, 4096, 16384, 0, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, BTRFS_COMPRESS_ZLIB, slot);\n\tslot++;\n\toffset += 4096;\n\tinsert_extent(root, offset, 4096, 4096, 0, disk_bytenr + 4096, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n\tslot++;\n\toffset += 4096;\n\tinsert_extent(root, offset, 8192, 16384, 8192, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, BTRFS_COMPRESS_ZLIB, slot);\n\tslot++;\n\toffset += 8192;\n\tdisk_bytenr += 8192;\n\n\t/* Now extents that have a hole but no hole extent */\n\tinsert_extent(root, offset, 4096, 4096, 0, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n\tslot++;\n\toffset += 16384;\n\tdisk_bytenr += 4096;\n\tinsert_extent(root, offset, 4096, 4096, 0, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n}",
    "includes": [
      "#include \"../volumes.h\"",
      "#include \"../extent_io.h\"",
      "#include \"../disk-io.h\"",
      "#include \"../btrfs_inode.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert_extent",
          "args": [
            "root",
            "offset",
            "4096",
            "4096",
            "0",
            "disk_bytenr",
            "4096",
            "BTRFS_FILE_EXTENT_REG",
            "0",
            "slot"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/inode-tests.c",
          "lines": "26-60",
          "snippet": "static void insert_extent(struct btrfs_root *root, u64 start, u64 len,\n\t\t\t  u64 ram_bytes, u64 offset, u64 disk_bytenr,\n\t\t\t  u64 disk_len, u32 type, u8 compression, int slot)\n{\n\tstruct btrfs_path path;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_buffer *leaf = root->node;\n\tstruct btrfs_key key;\n\tu32 value_len = sizeof(struct btrfs_file_extent_item);\n\n\tif (type == BTRFS_FILE_EXTENT_INLINE)\n\t\tvalue_len += len;\n\tmemset(&path, 0, sizeof(path));\n\n\tpath.nodes[0] = leaf;\n\tpath.slots[0] = slot;\n\n\tkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = start;\n\n\tsetup_items_for_insert(root, &path, &key, &value_len, value_len,\n\t\t\t       value_len + sizeof(struct btrfs_item), 1);\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\tbtrfs_set_file_extent_generation(leaf, fi, 1);\n\tbtrfs_set_file_extent_type(leaf, fi, type);\n\tbtrfs_set_file_extent_disk_bytenr(leaf, fi, disk_bytenr);\n\tbtrfs_set_file_extent_disk_num_bytes(leaf, fi, disk_len);\n\tbtrfs_set_file_extent_offset(leaf, fi, offset);\n\tbtrfs_set_file_extent_num_bytes(leaf, fi, len);\n\tbtrfs_set_file_extent_ram_bytes(leaf, fi, ram_bytes);\n\tbtrfs_set_file_extent_compression(leaf, fi, compression);\n\tbtrfs_set_file_extent_encryption(leaf, fi, 0);\n\tbtrfs_set_file_extent_other_encoding(leaf, fi, 0);\n}",
          "includes": [
            "#include \"../volumes.h\"",
            "#include \"../extent_io.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../btrfs_inode.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../volumes.h\"\n#include \"../extent_io.h\"\n#include \"../disk-io.h\"\n#include \"../btrfs_inode.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic void insert_extent(struct btrfs_root *root, u64 start, u64 len,\n\t\t\t  u64 ram_bytes, u64 offset, u64 disk_bytenr,\n\t\t\t  u64 disk_len, u32 type, u8 compression, int slot)\n{\n\tstruct btrfs_path path;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_buffer *leaf = root->node;\n\tstruct btrfs_key key;\n\tu32 value_len = sizeof(struct btrfs_file_extent_item);\n\n\tif (type == BTRFS_FILE_EXTENT_INLINE)\n\t\tvalue_len += len;\n\tmemset(&path, 0, sizeof(path));\n\n\tpath.nodes[0] = leaf;\n\tpath.slots[0] = slot;\n\n\tkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = start;\n\n\tsetup_items_for_insert(root, &path, &key, &value_len, value_len,\n\t\t\t       value_len + sizeof(struct btrfs_item), 1);\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\tbtrfs_set_file_extent_generation(leaf, fi, 1);\n\tbtrfs_set_file_extent_type(leaf, fi, type);\n\tbtrfs_set_file_extent_disk_bytenr(leaf, fi, disk_bytenr);\n\tbtrfs_set_file_extent_disk_num_bytes(leaf, fi, disk_len);\n\tbtrfs_set_file_extent_offset(leaf, fi, offset);\n\tbtrfs_set_file_extent_num_bytes(leaf, fi, len);\n\tbtrfs_set_file_extent_ram_bytes(leaf, fi, ram_bytes);\n\tbtrfs_set_file_extent_compression(leaf, fi, compression);\n\tbtrfs_set_file_extent_encryption(leaf, fi, 0);\n\tbtrfs_set_file_extent_other_encoding(leaf, fi, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../volumes.h\"\n#include \"../extent_io.h\"\n#include \"../disk-io.h\"\n#include \"../btrfs_inode.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic void setup_file_extents(struct btrfs_root *root)\n{\n\tint slot = 0;\n\tu64 disk_bytenr = 1 * 1024 * 1024;\n\tu64 offset = 0;\n\n\t/* First we want a hole */\n\tinsert_extent(root, offset, 5, 5, 0, 0, 0, BTRFS_FILE_EXTENT_REG, 0,\n\t\t      slot);\n\tslot++;\n\toffset += 5;\n\n\t/*\n\t * Now we want an inline extent, I don't think this is possible but hey\n\t * why not?  Also keep in mind if we have an inline extent it counts as\n\t * the whole first page.  If we were to expand it we would have to cow\n\t * and we wouldn't have an inline extent anymore.\n\t */\n\tinsert_extent(root, offset, 1, 1, 0, 0, 0, BTRFS_FILE_EXTENT_INLINE, 0,\n\t\t      slot);\n\tslot++;\n\toffset = 4096;\n\n\t/* Now another hole */\n\tinsert_extent(root, offset, 4, 4, 0, 0, 0, BTRFS_FILE_EXTENT_REG, 0,\n\t\t      slot);\n\tslot++;\n\toffset += 4;\n\n\t/* Now for a regular extent */\n\tinsert_extent(root, offset, 4095, 4095, 0, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n\tslot++;\n\tdisk_bytenr += 4096;\n\toffset += 4095;\n\n\t/*\n\t * Now for 3 extents that were split from a hole punch so we test\n\t * offsets properly.\n\t */\n\tinsert_extent(root, offset, 4096, 16384, 0, disk_bytenr, 16384,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n\tslot++;\n\toffset += 4096;\n\tinsert_extent(root, offset, 4096, 4096, 0, 0, 0, BTRFS_FILE_EXTENT_REG,\n\t\t      0, slot);\n\tslot++;\n\toffset += 4096;\n\tinsert_extent(root, offset, 8192, 16384, 8192, disk_bytenr, 16384,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n\tslot++;\n\toffset += 8192;\n\tdisk_bytenr += 16384;\n\n\t/* Now for a unwritten prealloc extent */\n\tinsert_extent(root, offset, 4096, 4096, 0, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_PREALLOC, 0, slot);\n\tslot++;\n\toffset += 4096;\n\n\t/*\n\t * We want to jack up disk_bytenr a little more so the em stuff doesn't\n\t * merge our records.\n\t */\n\tdisk_bytenr += 8192;\n\n\t/*\n\t * Now for a partially written prealloc extent, basically the same as\n\t * the hole punch example above.  Ram_bytes never changes when you mark\n\t * extents written btw.\n\t */\n\tinsert_extent(root, offset, 4096, 16384, 0, disk_bytenr, 16384,\n\t\t      BTRFS_FILE_EXTENT_PREALLOC, 0, slot);\n\tslot++;\n\toffset += 4096;\n\tinsert_extent(root, offset, 4096, 16384, 4096, disk_bytenr, 16384,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n\tslot++;\n\toffset += 4096;\n\tinsert_extent(root, offset, 8192, 16384, 8192, disk_bytenr, 16384,\n\t\t      BTRFS_FILE_EXTENT_PREALLOC, 0, slot);\n\tslot++;\n\toffset += 8192;\n\tdisk_bytenr += 16384;\n\n\t/* Now a normal compressed extent */\n\tinsert_extent(root, offset, 8192, 8192, 0, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, BTRFS_COMPRESS_ZLIB, slot);\n\tslot++;\n\toffset += 8192;\n\t/* No merges */\n\tdisk_bytenr += 8192;\n\n\t/* Now a split compressed extent */\n\tinsert_extent(root, offset, 4096, 16384, 0, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, BTRFS_COMPRESS_ZLIB, slot);\n\tslot++;\n\toffset += 4096;\n\tinsert_extent(root, offset, 4096, 4096, 0, disk_bytenr + 4096, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n\tslot++;\n\toffset += 4096;\n\tinsert_extent(root, offset, 8192, 16384, 8192, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, BTRFS_COMPRESS_ZLIB, slot);\n\tslot++;\n\toffset += 8192;\n\tdisk_bytenr += 8192;\n\n\t/* Now extents that have a hole but no hole extent */\n\tinsert_extent(root, offset, 4096, 4096, 0, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n\tslot++;\n\toffset += 16384;\n\tdisk_bytenr += 4096;\n\tinsert_extent(root, offset, 4096, 4096, 0, disk_bytenr, 4096,\n\t\t      BTRFS_FILE_EXTENT_REG, 0, slot);\n}"
  },
  {
    "function_name": "insert_inode_item_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/inode-tests.c",
    "lines": "62-80",
    "snippet": "static void insert_inode_item_key(struct btrfs_root *root)\n{\n\tstruct btrfs_path path;\n\tstruct extent_buffer *leaf = root->node;\n\tstruct btrfs_key key;\n\tu32 value_len = 0;\n\n\tmemset(&path, 0, sizeof(path));\n\n\tpath.nodes[0] = leaf;\n\tpath.slots[0] = 0;\n\n\tkey.objectid = BTRFS_INODE_ITEM_KEY;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tsetup_items_for_insert(root, &path, &key, &value_len, value_len,\n\t\t\t       value_len + sizeof(struct btrfs_item), 1);\n}",
    "includes": [
      "#include \"../volumes.h\"",
      "#include \"../extent_io.h\"",
      "#include \"../disk-io.h\"",
      "#include \"../btrfs_inode.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setup_items_for_insert",
          "args": [
            "root",
            "&path",
            "&key",
            "&value_len",
            "value_len",
            "value_len + sizeof(struct btrfs_item)",
            "1"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "setup_items_for_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4704-4789",
          "snippet": "void setup_items_for_insert(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *cpu_key, u32 *data_size,\n\t\t\t    u32 total_data, u32 total_size, int nr)\n{\n\tstruct btrfs_item *item;\n\tint i;\n\tu32 nritems;\n\tunsigned int data_end;\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tstruct btrfs_map_token token;\n\n\tif (path->slots[0] == 0) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key);\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\tbtrfs_unlock_up_safe(path, 1);\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < total_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"not enough freespace need %u have %d\",\n\t\t       total_size, btrfs_leaf_free_space(root, leaf));\n\t\tBUG();\n\t}\n\n\tif (slot != nritems) {\n\t\tunsigned int old_data = btrfs_item_end_nr(leaf, slot);\n\n\t\tif (old_data < data_end) {\n\t\t\tbtrfs_print_leaf(root, leaf);\n\t\t\tbtrfs_crit(root->fs_info, \"slot %d old_data %d data_end %d\",\n\t\t\t       slot, old_data, data_end);\n\t\t\tBUG_ON(1);\n\t\t}\n\t\t/*\n\t\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t\t */\n\t\t/* first correct the data pointers */\n\t\tfor (i = slot; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr( i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff - total_data, &token);\n\t\t}\n\t\t/* shift the items */\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot + nr),\n\t\t\t      btrfs_item_nr_offset(slot),\n\t\t\t      (nritems - slot) * sizeof(struct btrfs_item));\n\n\t\t/* shift the data */\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end - total_data, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data - data_end);\n\t\tdata_end = old_data;\n\t}\n\n\t/* setup the item for the new data */\n\tfor (i = 0; i < nr; i++) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key + i);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot + i);\n\t\titem = btrfs_item_nr(slot + i);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    data_end - data_size[i], &token);\n\t\tdata_end -= data_size[i];\n\t\tbtrfs_set_token_item_size(leaf, item, data_size[i], &token);\n\t}\n\n\tbtrfs_set_header_nritems(leaf, nritems + nr);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nvoid setup_items_for_insert(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *cpu_key, u32 *data_size,\n\t\t\t    u32 total_data, u32 total_size, int nr)\n{\n\tstruct btrfs_item *item;\n\tint i;\n\tu32 nritems;\n\tunsigned int data_end;\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tstruct btrfs_map_token token;\n\n\tif (path->slots[0] == 0) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key);\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\tbtrfs_unlock_up_safe(path, 1);\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < total_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"not enough freespace need %u have %d\",\n\t\t       total_size, btrfs_leaf_free_space(root, leaf));\n\t\tBUG();\n\t}\n\n\tif (slot != nritems) {\n\t\tunsigned int old_data = btrfs_item_end_nr(leaf, slot);\n\n\t\tif (old_data < data_end) {\n\t\t\tbtrfs_print_leaf(root, leaf);\n\t\t\tbtrfs_crit(root->fs_info, \"slot %d old_data %d data_end %d\",\n\t\t\t       slot, old_data, data_end);\n\t\t\tBUG_ON(1);\n\t\t}\n\t\t/*\n\t\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t\t */\n\t\t/* first correct the data pointers */\n\t\tfor (i = slot; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr( i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff - total_data, &token);\n\t\t}\n\t\t/* shift the items */\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot + nr),\n\t\t\t      btrfs_item_nr_offset(slot),\n\t\t\t      (nritems - slot) * sizeof(struct btrfs_item));\n\n\t\t/* shift the data */\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end - total_data, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data - data_end);\n\t\tdata_end = old_data;\n\t}\n\n\t/* setup the item for the new data */\n\tfor (i = 0; i < nr; i++) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key + i);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot + i);\n\t\titem = btrfs_item_nr(slot + i);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    data_end - data_size[i], &token);\n\t\tdata_end -= data_size[i];\n\t\tbtrfs_set_token_item_size(leaf, item, data_size[i], &token);\n\t}\n\n\tbtrfs_set_header_nritems(leaf, nritems + nr);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&path",
            "0",
            "sizeof(path)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../volumes.h\"\n#include \"../extent_io.h\"\n#include \"../disk-io.h\"\n#include \"../btrfs_inode.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic void insert_inode_item_key(struct btrfs_root *root)\n{\n\tstruct btrfs_path path;\n\tstruct extent_buffer *leaf = root->node;\n\tstruct btrfs_key key;\n\tu32 value_len = 0;\n\n\tmemset(&path, 0, sizeof(path));\n\n\tpath.nodes[0] = leaf;\n\tpath.slots[0] = 0;\n\n\tkey.objectid = BTRFS_INODE_ITEM_KEY;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tsetup_items_for_insert(root, &path, &key, &value_len, value_len,\n\t\t\t       value_len + sizeof(struct btrfs_item), 1);\n}"
  },
  {
    "function_name": "insert_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/inode-tests.c",
    "lines": "26-60",
    "snippet": "static void insert_extent(struct btrfs_root *root, u64 start, u64 len,\n\t\t\t  u64 ram_bytes, u64 offset, u64 disk_bytenr,\n\t\t\t  u64 disk_len, u32 type, u8 compression, int slot)\n{\n\tstruct btrfs_path path;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_buffer *leaf = root->node;\n\tstruct btrfs_key key;\n\tu32 value_len = sizeof(struct btrfs_file_extent_item);\n\n\tif (type == BTRFS_FILE_EXTENT_INLINE)\n\t\tvalue_len += len;\n\tmemset(&path, 0, sizeof(path));\n\n\tpath.nodes[0] = leaf;\n\tpath.slots[0] = slot;\n\n\tkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = start;\n\n\tsetup_items_for_insert(root, &path, &key, &value_len, value_len,\n\t\t\t       value_len + sizeof(struct btrfs_item), 1);\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\tbtrfs_set_file_extent_generation(leaf, fi, 1);\n\tbtrfs_set_file_extent_type(leaf, fi, type);\n\tbtrfs_set_file_extent_disk_bytenr(leaf, fi, disk_bytenr);\n\tbtrfs_set_file_extent_disk_num_bytes(leaf, fi, disk_len);\n\tbtrfs_set_file_extent_offset(leaf, fi, offset);\n\tbtrfs_set_file_extent_num_bytes(leaf, fi, len);\n\tbtrfs_set_file_extent_ram_bytes(leaf, fi, ram_bytes);\n\tbtrfs_set_file_extent_compression(leaf, fi, compression);\n\tbtrfs_set_file_extent_encryption(leaf, fi, 0);\n\tbtrfs_set_file_extent_other_encoding(leaf, fi, 0);\n}",
    "includes": [
      "#include \"../volumes.h\"",
      "#include \"../extent_io.h\"",
      "#include \"../disk-io.h\"",
      "#include \"../btrfs_inode.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_other_encoding",
          "args": [
            "leaf",
            "fi",
            "0"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_encryption",
          "args": [
            "leaf",
            "fi",
            "0"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_compression",
          "args": [
            "leaf",
            "fi",
            "compression"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_ram_bytes",
          "args": [
            "leaf",
            "fi",
            "ram_bytes"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_num_bytes",
          "args": [
            "leaf",
            "fi",
            "len"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_offset",
          "args": [
            "leaf",
            "fi",
            "offset"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_disk_num_bytes",
          "args": [
            "leaf",
            "fi",
            "disk_len"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_disk_bytenr",
          "args": [
            "leaf",
            "fi",
            "disk_bytenr"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_type",
          "args": [
            "leaf",
            "fi",
            "type"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_generation",
          "args": [
            "leaf",
            "fi",
            "1"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "slot",
            "structbtrfs_file_extent_item"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_items_for_insert",
          "args": [
            "root",
            "&path",
            "&key",
            "&value_len",
            "value_len",
            "value_len + sizeof(struct btrfs_item)",
            "1"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "setup_items_for_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4704-4789",
          "snippet": "void setup_items_for_insert(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *cpu_key, u32 *data_size,\n\t\t\t    u32 total_data, u32 total_size, int nr)\n{\n\tstruct btrfs_item *item;\n\tint i;\n\tu32 nritems;\n\tunsigned int data_end;\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tstruct btrfs_map_token token;\n\n\tif (path->slots[0] == 0) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key);\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\tbtrfs_unlock_up_safe(path, 1);\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < total_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"not enough freespace need %u have %d\",\n\t\t       total_size, btrfs_leaf_free_space(root, leaf));\n\t\tBUG();\n\t}\n\n\tif (slot != nritems) {\n\t\tunsigned int old_data = btrfs_item_end_nr(leaf, slot);\n\n\t\tif (old_data < data_end) {\n\t\t\tbtrfs_print_leaf(root, leaf);\n\t\t\tbtrfs_crit(root->fs_info, \"slot %d old_data %d data_end %d\",\n\t\t\t       slot, old_data, data_end);\n\t\t\tBUG_ON(1);\n\t\t}\n\t\t/*\n\t\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t\t */\n\t\t/* first correct the data pointers */\n\t\tfor (i = slot; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr( i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff - total_data, &token);\n\t\t}\n\t\t/* shift the items */\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot + nr),\n\t\t\t      btrfs_item_nr_offset(slot),\n\t\t\t      (nritems - slot) * sizeof(struct btrfs_item));\n\n\t\t/* shift the data */\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end - total_data, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data - data_end);\n\t\tdata_end = old_data;\n\t}\n\n\t/* setup the item for the new data */\n\tfor (i = 0; i < nr; i++) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key + i);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot + i);\n\t\titem = btrfs_item_nr(slot + i);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    data_end - data_size[i], &token);\n\t\tdata_end -= data_size[i];\n\t\tbtrfs_set_token_item_size(leaf, item, data_size[i], &token);\n\t}\n\n\tbtrfs_set_header_nritems(leaf, nritems + nr);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nvoid setup_items_for_insert(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *cpu_key, u32 *data_size,\n\t\t\t    u32 total_data, u32 total_size, int nr)\n{\n\tstruct btrfs_item *item;\n\tint i;\n\tu32 nritems;\n\tunsigned int data_end;\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tstruct btrfs_map_token token;\n\n\tif (path->slots[0] == 0) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key);\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\tbtrfs_unlock_up_safe(path, 1);\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < total_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"not enough freespace need %u have %d\",\n\t\t       total_size, btrfs_leaf_free_space(root, leaf));\n\t\tBUG();\n\t}\n\n\tif (slot != nritems) {\n\t\tunsigned int old_data = btrfs_item_end_nr(leaf, slot);\n\n\t\tif (old_data < data_end) {\n\t\t\tbtrfs_print_leaf(root, leaf);\n\t\t\tbtrfs_crit(root->fs_info, \"slot %d old_data %d data_end %d\",\n\t\t\t       slot, old_data, data_end);\n\t\t\tBUG_ON(1);\n\t\t}\n\t\t/*\n\t\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t\t */\n\t\t/* first correct the data pointers */\n\t\tfor (i = slot; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr( i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff - total_data, &token);\n\t\t}\n\t\t/* shift the items */\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot + nr),\n\t\t\t      btrfs_item_nr_offset(slot),\n\t\t\t      (nritems - slot) * sizeof(struct btrfs_item));\n\n\t\t/* shift the data */\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end - total_data, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data - data_end);\n\t\tdata_end = old_data;\n\t}\n\n\t/* setup the item for the new data */\n\tfor (i = 0; i < nr; i++) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key + i);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot + i);\n\t\titem = btrfs_item_nr(slot + i);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    data_end - data_size[i], &token);\n\t\tdata_end -= data_size[i];\n\t\tbtrfs_set_token_item_size(leaf, item, data_size[i], &token);\n\t}\n\n\tbtrfs_set_header_nritems(leaf, nritems + nr);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&path",
            "0",
            "sizeof(path)"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../volumes.h\"\n#include \"../extent_io.h\"\n#include \"../disk-io.h\"\n#include \"../btrfs_inode.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nstatic void insert_extent(struct btrfs_root *root, u64 start, u64 len,\n\t\t\t  u64 ram_bytes, u64 offset, u64 disk_bytenr,\n\t\t\t  u64 disk_len, u32 type, u8 compression, int slot)\n{\n\tstruct btrfs_path path;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_buffer *leaf = root->node;\n\tstruct btrfs_key key;\n\tu32 value_len = sizeof(struct btrfs_file_extent_item);\n\n\tif (type == BTRFS_FILE_EXTENT_INLINE)\n\t\tvalue_len += len;\n\tmemset(&path, 0, sizeof(path));\n\n\tpath.nodes[0] = leaf;\n\tpath.slots[0] = slot;\n\n\tkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = start;\n\n\tsetup_items_for_insert(root, &path, &key, &value_len, value_len,\n\t\t\t       value_len + sizeof(struct btrfs_item), 1);\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\tbtrfs_set_file_extent_generation(leaf, fi, 1);\n\tbtrfs_set_file_extent_type(leaf, fi, type);\n\tbtrfs_set_file_extent_disk_bytenr(leaf, fi, disk_bytenr);\n\tbtrfs_set_file_extent_disk_num_bytes(leaf, fi, disk_len);\n\tbtrfs_set_file_extent_offset(leaf, fi, offset);\n\tbtrfs_set_file_extent_num_bytes(leaf, fi, len);\n\tbtrfs_set_file_extent_ram_bytes(leaf, fi, ram_bytes);\n\tbtrfs_set_file_extent_compression(leaf, fi, compression);\n\tbtrfs_set_file_extent_encryption(leaf, fi, 0);\n\tbtrfs_set_file_extent_other_encoding(leaf, fi, 0);\n}"
  }
]