[
  {
    "function_name": "udf_translate_to_linux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/unicode.c",
    "lines": "411-496",
    "snippet": "static int udf_translate_to_linux(uint8_t *newName, int newLen,\n\t\t\t\t  uint8_t *udfName, int udfLen,\n\t\t\t\t  uint8_t *fidName, int fidNameLen)\n{\n\tint index, newIndex = 0, needsCRC = 0;\n\tint extIndex = 0, newExtIndex = 0, hasExt = 0;\n\tunsigned short valueCRC;\n\tuint8_t curr;\n\n\tif (udfName[0] == '.' &&\n\t    (udfLen == 1 || (udfLen == 2 && udfName[1] == '.'))) {\n\t\tneedsCRC = 1;\n\t\tnewIndex = udfLen;\n\t\tmemcpy(newName, udfName, udfLen);\n\t} else {\n\t\tfor (index = 0; index < udfLen; index++) {\n\t\t\tcurr = udfName[index];\n\t\t\tif (curr == '/' || curr == 0) {\n\t\t\t\tneedsCRC = 1;\n\t\t\t\tcurr = ILLEGAL_CHAR_MARK;\n\t\t\t\twhile (index + 1 < udfLen &&\n\t\t\t\t\t\t(udfName[index + 1] == '/' ||\n\t\t\t\t\t\t udfName[index + 1] == 0))\n\t\t\t\t\tindex++;\n\t\t\t}\n\t\t\tif (curr == EXT_MARK &&\n\t\t\t\t\t(udfLen - index - 1) <= EXT_SIZE) {\n\t\t\t\tif (udfLen == index + 1)\n\t\t\t\t\thasExt = 0;\n\t\t\t\telse {\n\t\t\t\t\thasExt = 1;\n\t\t\t\t\textIndex = index;\n\t\t\t\t\tnewExtIndex = newIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newIndex < newLen)\n\t\t\t\tnewName[newIndex++] = curr;\n\t\t\telse\n\t\t\t\tneedsCRC = 1;\n\t\t}\n\t}\n\tif (needsCRC) {\n\t\tuint8_t ext[EXT_SIZE];\n\t\tint localExtIndex = 0;\n\n\t\tif (hasExt) {\n\t\t\tint maxFilenameLen;\n\t\t\tfor (index = 0;\n\t\t\t     index < EXT_SIZE && extIndex + index + 1 < udfLen;\n\t\t\t     index++) {\n\t\t\t\tcurr = udfName[extIndex + index + 1];\n\n\t\t\t\tif (curr == '/' || curr == 0) {\n\t\t\t\t\tneedsCRC = 1;\n\t\t\t\t\tcurr = ILLEGAL_CHAR_MARK;\n\t\t\t\t\twhile (extIndex + index + 2 < udfLen &&\n\t\t\t\t\t      (index + 1 < EXT_SIZE &&\n\t\t\t\t\t\t(udfName[extIndex + index + 2] == '/' ||\n\t\t\t\t\t\t udfName[extIndex + index + 2] == 0)))\n\t\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\text[localExtIndex++] = curr;\n\t\t\t}\n\t\t\tmaxFilenameLen = newLen - CRC_LEN - localExtIndex;\n\t\t\tif (newIndex > maxFilenameLen)\n\t\t\t\tnewIndex = maxFilenameLen;\n\t\t\telse\n\t\t\t\tnewIndex = newExtIndex;\n\t\t} else if (newIndex > newLen - CRC_LEN)\n\t\t\tnewIndex = newLen - CRC_LEN;\n\t\tnewName[newIndex++] = CRC_MARK;\n\t\tvalueCRC = crc_itu_t(0, fidName, fidNameLen);\n\t\tnewName[newIndex++] = hex_asc_upper_hi(valueCRC >> 8);\n\t\tnewName[newIndex++] = hex_asc_upper_lo(valueCRC >> 8);\n\t\tnewName[newIndex++] = hex_asc_upper_hi(valueCRC);\n\t\tnewName[newIndex++] = hex_asc_upper_lo(valueCRC);\n\n\t\tif (hasExt) {\n\t\t\tnewName[newIndex++] = EXT_MARK;\n\t\t\tfor (index = 0; index < localExtIndex; index++)\n\t\t\t\tnewName[newIndex++] = ext[index];\n\t\t}\n\t}\n\n\treturn newIndex;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include <linux/slab.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/nls.h>",
      "#include <linux/string.h>\t/* for memset */",
      "#include <linux/kernel.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [
      "#define CRC_LEN\t\t\t5",
      "#define EXT_SIZE \t\t5",
      "#define CRC_MARK\t\t'#'",
      "#define EXT_MARK\t\t'.'",
      "#define ILLEGAL_CHAR_MARK\t'_'"
    ],
    "globals_used": [
      "static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hex_asc_upper_lo",
          "args": [
            "valueCRC"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_asc_upper_hi",
          "args": [
            "valueCRC"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_asc_upper_lo",
          "args": [
            "valueCRC >> 8"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_asc_upper_hi",
          "args": [
            "valueCRC >> 8"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc_itu_t",
          "args": [
            "0",
            "fidName",
            "fidNameLen"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "newName",
            "udfName",
            "udfLen"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include <linux/slab.h>\n#include <linux/crc-itu-t.h>\n#include <linux/nls.h>\n#include <linux/string.h>\t/* for memset */\n#include <linux/kernel.h>\n#include \"udfdecl.h\"\n\n#define CRC_LEN\t\t\t5\n#define EXT_SIZE \t\t5\n#define CRC_MARK\t\t'#'\n#define EXT_MARK\t\t'.'\n#define ILLEGAL_CHAR_MARK\t'_'\n\nstatic int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);\n\nstatic int udf_translate_to_linux(uint8_t *newName, int newLen,\n\t\t\t\t  uint8_t *udfName, int udfLen,\n\t\t\t\t  uint8_t *fidName, int fidNameLen)\n{\n\tint index, newIndex = 0, needsCRC = 0;\n\tint extIndex = 0, newExtIndex = 0, hasExt = 0;\n\tunsigned short valueCRC;\n\tuint8_t curr;\n\n\tif (udfName[0] == '.' &&\n\t    (udfLen == 1 || (udfLen == 2 && udfName[1] == '.'))) {\n\t\tneedsCRC = 1;\n\t\tnewIndex = udfLen;\n\t\tmemcpy(newName, udfName, udfLen);\n\t} else {\n\t\tfor (index = 0; index < udfLen; index++) {\n\t\t\tcurr = udfName[index];\n\t\t\tif (curr == '/' || curr == 0) {\n\t\t\t\tneedsCRC = 1;\n\t\t\t\tcurr = ILLEGAL_CHAR_MARK;\n\t\t\t\twhile (index + 1 < udfLen &&\n\t\t\t\t\t\t(udfName[index + 1] == '/' ||\n\t\t\t\t\t\t udfName[index + 1] == 0))\n\t\t\t\t\tindex++;\n\t\t\t}\n\t\t\tif (curr == EXT_MARK &&\n\t\t\t\t\t(udfLen - index - 1) <= EXT_SIZE) {\n\t\t\t\tif (udfLen == index + 1)\n\t\t\t\t\thasExt = 0;\n\t\t\t\telse {\n\t\t\t\t\thasExt = 1;\n\t\t\t\t\textIndex = index;\n\t\t\t\t\tnewExtIndex = newIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newIndex < newLen)\n\t\t\t\tnewName[newIndex++] = curr;\n\t\t\telse\n\t\t\t\tneedsCRC = 1;\n\t\t}\n\t}\n\tif (needsCRC) {\n\t\tuint8_t ext[EXT_SIZE];\n\t\tint localExtIndex = 0;\n\n\t\tif (hasExt) {\n\t\t\tint maxFilenameLen;\n\t\t\tfor (index = 0;\n\t\t\t     index < EXT_SIZE && extIndex + index + 1 < udfLen;\n\t\t\t     index++) {\n\t\t\t\tcurr = udfName[extIndex + index + 1];\n\n\t\t\t\tif (curr == '/' || curr == 0) {\n\t\t\t\t\tneedsCRC = 1;\n\t\t\t\t\tcurr = ILLEGAL_CHAR_MARK;\n\t\t\t\t\twhile (extIndex + index + 2 < udfLen &&\n\t\t\t\t\t      (index + 1 < EXT_SIZE &&\n\t\t\t\t\t\t(udfName[extIndex + index + 2] == '/' ||\n\t\t\t\t\t\t udfName[extIndex + index + 2] == 0)))\n\t\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\text[localExtIndex++] = curr;\n\t\t\t}\n\t\t\tmaxFilenameLen = newLen - CRC_LEN - localExtIndex;\n\t\t\tif (newIndex > maxFilenameLen)\n\t\t\t\tnewIndex = maxFilenameLen;\n\t\t\telse\n\t\t\t\tnewIndex = newExtIndex;\n\t\t} else if (newIndex > newLen - CRC_LEN)\n\t\t\tnewIndex = newLen - CRC_LEN;\n\t\tnewName[newIndex++] = CRC_MARK;\n\t\tvalueCRC = crc_itu_t(0, fidName, fidNameLen);\n\t\tnewName[newIndex++] = hex_asc_upper_hi(valueCRC >> 8);\n\t\tnewName[newIndex++] = hex_asc_upper_lo(valueCRC >> 8);\n\t\tnewName[newIndex++] = hex_asc_upper_hi(valueCRC);\n\t\tnewName[newIndex++] = hex_asc_upper_lo(valueCRC);\n\n\t\tif (hasExt) {\n\t\t\tnewName[newIndex++] = EXT_MARK;\n\t\t\tfor (index = 0; index < localExtIndex; index++)\n\t\t\t\tnewName[newIndex++] = ext[index];\n\t\t}\n\t}\n\n\treturn newIndex;\n}"
  },
  {
    "function_name": "udf_put_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/unicode.c",
    "lines": "380-402",
    "snippet": "int udf_put_filename(struct super_block *sb, const uint8_t *sname,\n\t\t     uint8_t *dname, int flen)\n{\n\tstruct ustr unifilename;\n\tint namelen;\n\n\tif (!udf_char_to_ustr(&unifilename, sname, flen))\n\t\treturn 0;\n\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n\t\tnamelen = udf_UTF8toCS0(dname, &unifilename, UDF_NAME_LEN);\n\t\tif (!namelen)\n\t\t\treturn 0;\n\t} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {\n\t\tnamelen = udf_NLStoCS0(UDF_SB(sb)->s_nls_map, dname,\n\t\t\t\t\t&unifilename, UDF_NAME_LEN);\n\t\tif (!namelen)\n\t\t\treturn 0;\n\t} else\n\t\treturn 0;\n\n\treturn namelen;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include <linux/slab.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/nls.h>",
      "#include <linux/string.h>\t/* for memset */",
      "#include <linux/kernel.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_NLStoCS0",
          "args": [
            "UDF_SB(sb)->s_nls_map",
            "dname",
            "&unifilename",
            "UDF_NAME_LEN"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "udf_NLStoCS0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/unicode.c",
          "lines": "297-335",
          "snippet": "static int udf_NLStoCS0(struct nls_table *nls, dstring *ocu, struct ustr *uni,\n\t\t\tint length)\n{\n\tint len;\n\tunsigned i, max_val;\n\tuint16_t uni_char;\n\tint u_len;\n\n\tmemset(ocu, 0, sizeof(dstring) * length);\n\tocu[0] = 8;\n\tmax_val = 0xffU;\n\ntry_again:\n\tu_len = 0U;\n\tfor (i = 0U; i < uni->u_len; i++) {\n\t\tlen = nls->char2uni(&uni->u_name[i], uni->u_len - i, &uni_char);\n\t\tif (!len)\n\t\t\tcontinue;\n\t\t/* Invalid character, deal with it */\n\t\tif (len < 0) {\n\t\t\tlen = 1;\n\t\t\tuni_char = '?';\n\t\t}\n\n\t\tif (uni_char > max_val) {\n\t\t\tmax_val = 0xffffU;\n\t\t\tocu[0] = (uint8_t)0x10U;\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tif (max_val == 0xffffU)\n\t\t\tocu[++u_len] = (uint8_t)(uni_char >> 8);\n\t\tocu[++u_len] = (uint8_t)(uni_char & 0xffU);\n\t\ti += len - 1;\n\t}\n\n\tocu[length - 1] = (uint8_t)u_len + 1;\n\treturn u_len + 1;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>\t/* for memset */",
            "#include <linux/kernel.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include <linux/slab.h>\n#include <linux/crc-itu-t.h>\n#include <linux/nls.h>\n#include <linux/string.h>\t/* for memset */\n#include <linux/kernel.h>\n#include \"udfdecl.h\"\n\nstatic int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);\n\nstatic int udf_NLStoCS0(struct nls_table *nls, dstring *ocu, struct ustr *uni,\n\t\t\tint length)\n{\n\tint len;\n\tunsigned i, max_val;\n\tuint16_t uni_char;\n\tint u_len;\n\n\tmemset(ocu, 0, sizeof(dstring) * length);\n\tocu[0] = 8;\n\tmax_val = 0xffU;\n\ntry_again:\n\tu_len = 0U;\n\tfor (i = 0U; i < uni->u_len; i++) {\n\t\tlen = nls->char2uni(&uni->u_name[i], uni->u_len - i, &uni_char);\n\t\tif (!len)\n\t\t\tcontinue;\n\t\t/* Invalid character, deal with it */\n\t\tif (len < 0) {\n\t\t\tlen = 1;\n\t\t\tuni_char = '?';\n\t\t}\n\n\t\tif (uni_char > max_val) {\n\t\t\tmax_val = 0xffffU;\n\t\t\tocu[0] = (uint8_t)0x10U;\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tif (max_val == 0xffffU)\n\t\t\tocu[++u_len] = (uint8_t)(uni_char >> 8);\n\t\tocu[++u_len] = (uint8_t)(uni_char & 0xffU);\n\t\ti += len - 1;\n\t}\n\n\tocu[length - 1] = (uint8_t)u_len + 1;\n\treturn u_len + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_QUERY_FLAG",
          "args": [
            "sb",
            "UDF_FLAG_NLS_MAP"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_QUERY_FLAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "169-172",
          "snippet": "static inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_UTF8toCS0",
          "args": [
            "dname",
            "&unifilename",
            "UDF_NAME_LEN"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "udf_UTF8toCS0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/unicode.c",
          "lines": "178-252",
          "snippet": "static int udf_UTF8toCS0(dstring *ocu, struct ustr *utf, int length)\n{\n\tunsigned c, i, max_val, utf_char;\n\tint utf_cnt, u_len;\n\n\tmemset(ocu, 0, sizeof(dstring) * length);\n\tocu[0] = 8;\n\tmax_val = 0xffU;\n\ntry_again:\n\tu_len = 0U;\n\tutf_char = 0U;\n\tutf_cnt = 0U;\n\tfor (i = 0U; i < utf->u_len; i++) {\n\t\tc = (uint8_t)utf->u_name[i];\n\n\t\t/* Complete a multi-byte UTF-8 character */\n\t\tif (utf_cnt) {\n\t\t\tutf_char = (utf_char << 6) | (c & 0x3fU);\n\t\t\tif (--utf_cnt)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\t/* Check for a multi-byte UTF-8 character */\n\t\t\tif (c & 0x80U) {\n\t\t\t\t/* Start a multi-byte UTF-8 character */\n\t\t\t\tif ((c & 0xe0U) == 0xc0U) {\n\t\t\t\t\tutf_char = c & 0x1fU;\n\t\t\t\t\tutf_cnt = 1;\n\t\t\t\t} else if ((c & 0xf0U) == 0xe0U) {\n\t\t\t\t\tutf_char = c & 0x0fU;\n\t\t\t\t\tutf_cnt = 2;\n\t\t\t\t} else if ((c & 0xf8U) == 0xf0U) {\n\t\t\t\t\tutf_char = c & 0x07U;\n\t\t\t\t\tutf_cnt = 3;\n\t\t\t\t} else if ((c & 0xfcU) == 0xf8U) {\n\t\t\t\t\tutf_char = c & 0x03U;\n\t\t\t\t\tutf_cnt = 4;\n\t\t\t\t} else if ((c & 0xfeU) == 0xfcU) {\n\t\t\t\t\tutf_char = c & 0x01U;\n\t\t\t\t\tutf_cnt = 5;\n\t\t\t\t} else {\n\t\t\t\t\tgoto error_out;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t/* Single byte UTF-8 character (most common) */\n\t\t\t\tutf_char = c;\n\t\t\t}\n\t\t}\n\n\t\t/* Choose no compression if necessary */\n\t\tif (utf_char > max_val) {\n\t\t\tif (max_val == 0xffU) {\n\t\t\t\tmax_val = 0xffffU;\n\t\t\t\tocu[0] = (uint8_t)0x10U;\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tif (max_val == 0xffffU)\n\t\t\tocu[++u_len] = (uint8_t)(utf_char >> 8);\n\t\tocu[++u_len] = (uint8_t)(utf_char & 0xffU);\n\t}\n\n\tif (utf_cnt) {\nerror_out:\n\t\tocu[++u_len] = '?';\n\t\tprintk(KERN_DEBUG pr_fmt(\"bad UTF-8 character\\n\"));\n\t}\n\n\tocu[length - 1] = (uint8_t)u_len + 1;\n\n\treturn u_len + 1;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>\t/* for memset */",
            "#include <linux/kernel.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include <linux/slab.h>\n#include <linux/crc-itu-t.h>\n#include <linux/nls.h>\n#include <linux/string.h>\t/* for memset */\n#include <linux/kernel.h>\n#include \"udfdecl.h\"\n\nstatic int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);\n\nstatic int udf_UTF8toCS0(dstring *ocu, struct ustr *utf, int length)\n{\n\tunsigned c, i, max_val, utf_char;\n\tint utf_cnt, u_len;\n\n\tmemset(ocu, 0, sizeof(dstring) * length);\n\tocu[0] = 8;\n\tmax_val = 0xffU;\n\ntry_again:\n\tu_len = 0U;\n\tutf_char = 0U;\n\tutf_cnt = 0U;\n\tfor (i = 0U; i < utf->u_len; i++) {\n\t\tc = (uint8_t)utf->u_name[i];\n\n\t\t/* Complete a multi-byte UTF-8 character */\n\t\tif (utf_cnt) {\n\t\t\tutf_char = (utf_char << 6) | (c & 0x3fU);\n\t\t\tif (--utf_cnt)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\t/* Check for a multi-byte UTF-8 character */\n\t\t\tif (c & 0x80U) {\n\t\t\t\t/* Start a multi-byte UTF-8 character */\n\t\t\t\tif ((c & 0xe0U) == 0xc0U) {\n\t\t\t\t\tutf_char = c & 0x1fU;\n\t\t\t\t\tutf_cnt = 1;\n\t\t\t\t} else if ((c & 0xf0U) == 0xe0U) {\n\t\t\t\t\tutf_char = c & 0x0fU;\n\t\t\t\t\tutf_cnt = 2;\n\t\t\t\t} else if ((c & 0xf8U) == 0xf0U) {\n\t\t\t\t\tutf_char = c & 0x07U;\n\t\t\t\t\tutf_cnt = 3;\n\t\t\t\t} else if ((c & 0xfcU) == 0xf8U) {\n\t\t\t\t\tutf_char = c & 0x03U;\n\t\t\t\t\tutf_cnt = 4;\n\t\t\t\t} else if ((c & 0xfeU) == 0xfcU) {\n\t\t\t\t\tutf_char = c & 0x01U;\n\t\t\t\t\tutf_cnt = 5;\n\t\t\t\t} else {\n\t\t\t\t\tgoto error_out;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t/* Single byte UTF-8 character (most common) */\n\t\t\t\tutf_char = c;\n\t\t\t}\n\t\t}\n\n\t\t/* Choose no compression if necessary */\n\t\tif (utf_char > max_val) {\n\t\t\tif (max_val == 0xffU) {\n\t\t\t\tmax_val = 0xffffU;\n\t\t\t\tocu[0] = (uint8_t)0x10U;\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tif (max_val == 0xffffU)\n\t\t\tocu[++u_len] = (uint8_t)(utf_char >> 8);\n\t\tocu[++u_len] = (uint8_t)(utf_char & 0xffU);\n\t}\n\n\tif (utf_cnt) {\nerror_out:\n\t\tocu[++u_len] = '?';\n\t\tprintk(KERN_DEBUG pr_fmt(\"bad UTF-8 character\\n\"));\n\t}\n\n\tocu[length - 1] = (uint8_t)u_len + 1;\n\n\treturn u_len + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_char_to_ustr",
          "args": [
            "&unifilename",
            "sname",
            "flen"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "udf_char_to_ustr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/unicode.c",
          "lines": "34-45",
          "snippet": "static int udf_char_to_ustr(struct ustr *dest, const uint8_t *src, int strlen)\n{\n\tif ((!dest) || (!src) || (!strlen) || (strlen > UDF_NAME_LEN - 2))\n\t\treturn 0;\n\n\tmemset(dest, 0, sizeof(struct ustr));\n\tmemcpy(dest->u_name, src, strlen);\n\tdest->u_cmpID = 0x08;\n\tdest->u_len = strlen;\n\n\treturn strlen;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>\t/* for memset */",
            "#include <linux/kernel.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include <linux/slab.h>\n#include <linux/crc-itu-t.h>\n#include <linux/nls.h>\n#include <linux/string.h>\t/* for memset */\n#include <linux/kernel.h>\n#include \"udfdecl.h\"\n\nstatic int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);\n\nstatic int udf_char_to_ustr(struct ustr *dest, const uint8_t *src, int strlen)\n{\n\tif ((!dest) || (!src) || (!strlen) || (strlen > UDF_NAME_LEN - 2))\n\t\treturn 0;\n\n\tmemset(dest, 0, sizeof(struct ustr));\n\tmemcpy(dest->u_name, src, strlen);\n\tdest->u_cmpID = 0x08;\n\tdest->u_len = strlen;\n\n\treturn strlen;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include <linux/slab.h>\n#include <linux/crc-itu-t.h>\n#include <linux/nls.h>\n#include <linux/string.h>\t/* for memset */\n#include <linux/kernel.h>\n#include \"udfdecl.h\"\n\nstatic int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);\n\nint udf_put_filename(struct super_block *sb, const uint8_t *sname,\n\t\t     uint8_t *dname, int flen)\n{\n\tstruct ustr unifilename;\n\tint namelen;\n\n\tif (!udf_char_to_ustr(&unifilename, sname, flen))\n\t\treturn 0;\n\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n\t\tnamelen = udf_UTF8toCS0(dname, &unifilename, UDF_NAME_LEN);\n\t\tif (!namelen)\n\t\t\treturn 0;\n\t} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {\n\t\tnamelen = udf_NLStoCS0(UDF_SB(sb)->s_nls_map, dname,\n\t\t\t\t\t&unifilename, UDF_NAME_LEN);\n\t\tif (!namelen)\n\t\t\treturn 0;\n\t} else\n\t\treturn 0;\n\n\treturn namelen;\n}"
  },
  {
    "function_name": "udf_get_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/unicode.c",
    "lines": "337-378",
    "snippet": "int udf_get_filename(struct super_block *sb, uint8_t *sname, int slen,\n\t\t     uint8_t *dname, int dlen)\n{\n\tstruct ustr *filename, *unifilename;\n\tint len = 0;\n\n\tfilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!filename)\n\t\treturn 0;\n\n\tunifilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!unifilename)\n\t\tgoto out1;\n\n\tif (udf_build_ustr_exact(unifilename, sname, slen))\n\t\tgoto out2;\n\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n\t\tif (!udf_CS0toUTF8(filename, unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {\n\t\tif (!udf_CS0toNLS(UDF_SB(sb)->s_nls_map, filename,\n\t\t\t\t  unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else\n\t\tgoto out2;\n\n\tlen = udf_translate_to_linux(dname, dlen,\n\t\t\t\t     filename->u_name, filename->u_len,\n\t\t\t\t     unifilename->u_name, unifilename->u_len);\nout2:\n\tkfree(unifilename);\nout1:\n\tkfree(filename);\n\treturn len;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include <linux/slab.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/nls.h>",
      "#include <linux/string.h>\t/* for memset */",
      "#include <linux/kernel.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "filename"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "unifilename"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_translate_to_linux",
          "args": [
            "dname",
            "dlen",
            "filename->u_name",
            "filename->u_len",
            "unifilename->u_name",
            "unifilename->u_len"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "udf_translate_to_linux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/unicode.c",
          "lines": "411-496",
          "snippet": "static int udf_translate_to_linux(uint8_t *newName, int newLen,\n\t\t\t\t  uint8_t *udfName, int udfLen,\n\t\t\t\t  uint8_t *fidName, int fidNameLen)\n{\n\tint index, newIndex = 0, needsCRC = 0;\n\tint extIndex = 0, newExtIndex = 0, hasExt = 0;\n\tunsigned short valueCRC;\n\tuint8_t curr;\n\n\tif (udfName[0] == '.' &&\n\t    (udfLen == 1 || (udfLen == 2 && udfName[1] == '.'))) {\n\t\tneedsCRC = 1;\n\t\tnewIndex = udfLen;\n\t\tmemcpy(newName, udfName, udfLen);\n\t} else {\n\t\tfor (index = 0; index < udfLen; index++) {\n\t\t\tcurr = udfName[index];\n\t\t\tif (curr == '/' || curr == 0) {\n\t\t\t\tneedsCRC = 1;\n\t\t\t\tcurr = ILLEGAL_CHAR_MARK;\n\t\t\t\twhile (index + 1 < udfLen &&\n\t\t\t\t\t\t(udfName[index + 1] == '/' ||\n\t\t\t\t\t\t udfName[index + 1] == 0))\n\t\t\t\t\tindex++;\n\t\t\t}\n\t\t\tif (curr == EXT_MARK &&\n\t\t\t\t\t(udfLen - index - 1) <= EXT_SIZE) {\n\t\t\t\tif (udfLen == index + 1)\n\t\t\t\t\thasExt = 0;\n\t\t\t\telse {\n\t\t\t\t\thasExt = 1;\n\t\t\t\t\textIndex = index;\n\t\t\t\t\tnewExtIndex = newIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newIndex < newLen)\n\t\t\t\tnewName[newIndex++] = curr;\n\t\t\telse\n\t\t\t\tneedsCRC = 1;\n\t\t}\n\t}\n\tif (needsCRC) {\n\t\tuint8_t ext[EXT_SIZE];\n\t\tint localExtIndex = 0;\n\n\t\tif (hasExt) {\n\t\t\tint maxFilenameLen;\n\t\t\tfor (index = 0;\n\t\t\t     index < EXT_SIZE && extIndex + index + 1 < udfLen;\n\t\t\t     index++) {\n\t\t\t\tcurr = udfName[extIndex + index + 1];\n\n\t\t\t\tif (curr == '/' || curr == 0) {\n\t\t\t\t\tneedsCRC = 1;\n\t\t\t\t\tcurr = ILLEGAL_CHAR_MARK;\n\t\t\t\t\twhile (extIndex + index + 2 < udfLen &&\n\t\t\t\t\t      (index + 1 < EXT_SIZE &&\n\t\t\t\t\t\t(udfName[extIndex + index + 2] == '/' ||\n\t\t\t\t\t\t udfName[extIndex + index + 2] == 0)))\n\t\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\text[localExtIndex++] = curr;\n\t\t\t}\n\t\t\tmaxFilenameLen = newLen - CRC_LEN - localExtIndex;\n\t\t\tif (newIndex > maxFilenameLen)\n\t\t\t\tnewIndex = maxFilenameLen;\n\t\t\telse\n\t\t\t\tnewIndex = newExtIndex;\n\t\t} else if (newIndex > newLen - CRC_LEN)\n\t\t\tnewIndex = newLen - CRC_LEN;\n\t\tnewName[newIndex++] = CRC_MARK;\n\t\tvalueCRC = crc_itu_t(0, fidName, fidNameLen);\n\t\tnewName[newIndex++] = hex_asc_upper_hi(valueCRC >> 8);\n\t\tnewName[newIndex++] = hex_asc_upper_lo(valueCRC >> 8);\n\t\tnewName[newIndex++] = hex_asc_upper_hi(valueCRC);\n\t\tnewName[newIndex++] = hex_asc_upper_lo(valueCRC);\n\n\t\tif (hasExt) {\n\t\t\tnewName[newIndex++] = EXT_MARK;\n\t\t\tfor (index = 0; index < localExtIndex; index++)\n\t\t\t\tnewName[newIndex++] = ext[index];\n\t\t}\n\t}\n\n\treturn newIndex;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>\t/* for memset */",
            "#include <linux/kernel.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [
            "#define CRC_LEN\t\t\t5",
            "#define EXT_SIZE \t\t5",
            "#define CRC_MARK\t\t'#'",
            "#define EXT_MARK\t\t'.'",
            "#define ILLEGAL_CHAR_MARK\t'_'"
          ],
          "globals_used": [
            "static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include <linux/slab.h>\n#include <linux/crc-itu-t.h>\n#include <linux/nls.h>\n#include <linux/string.h>\t/* for memset */\n#include <linux/kernel.h>\n#include \"udfdecl.h\"\n\n#define CRC_LEN\t\t\t5\n#define EXT_SIZE \t\t5\n#define CRC_MARK\t\t'#'\n#define EXT_MARK\t\t'.'\n#define ILLEGAL_CHAR_MARK\t'_'\n\nstatic int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);\n\nstatic int udf_translate_to_linux(uint8_t *newName, int newLen,\n\t\t\t\t  uint8_t *udfName, int udfLen,\n\t\t\t\t  uint8_t *fidName, int fidNameLen)\n{\n\tint index, newIndex = 0, needsCRC = 0;\n\tint extIndex = 0, newExtIndex = 0, hasExt = 0;\n\tunsigned short valueCRC;\n\tuint8_t curr;\n\n\tif (udfName[0] == '.' &&\n\t    (udfLen == 1 || (udfLen == 2 && udfName[1] == '.'))) {\n\t\tneedsCRC = 1;\n\t\tnewIndex = udfLen;\n\t\tmemcpy(newName, udfName, udfLen);\n\t} else {\n\t\tfor (index = 0; index < udfLen; index++) {\n\t\t\tcurr = udfName[index];\n\t\t\tif (curr == '/' || curr == 0) {\n\t\t\t\tneedsCRC = 1;\n\t\t\t\tcurr = ILLEGAL_CHAR_MARK;\n\t\t\t\twhile (index + 1 < udfLen &&\n\t\t\t\t\t\t(udfName[index + 1] == '/' ||\n\t\t\t\t\t\t udfName[index + 1] == 0))\n\t\t\t\t\tindex++;\n\t\t\t}\n\t\t\tif (curr == EXT_MARK &&\n\t\t\t\t\t(udfLen - index - 1) <= EXT_SIZE) {\n\t\t\t\tif (udfLen == index + 1)\n\t\t\t\t\thasExt = 0;\n\t\t\t\telse {\n\t\t\t\t\thasExt = 1;\n\t\t\t\t\textIndex = index;\n\t\t\t\t\tnewExtIndex = newIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newIndex < newLen)\n\t\t\t\tnewName[newIndex++] = curr;\n\t\t\telse\n\t\t\t\tneedsCRC = 1;\n\t\t}\n\t}\n\tif (needsCRC) {\n\t\tuint8_t ext[EXT_SIZE];\n\t\tint localExtIndex = 0;\n\n\t\tif (hasExt) {\n\t\t\tint maxFilenameLen;\n\t\t\tfor (index = 0;\n\t\t\t     index < EXT_SIZE && extIndex + index + 1 < udfLen;\n\t\t\t     index++) {\n\t\t\t\tcurr = udfName[extIndex + index + 1];\n\n\t\t\t\tif (curr == '/' || curr == 0) {\n\t\t\t\t\tneedsCRC = 1;\n\t\t\t\t\tcurr = ILLEGAL_CHAR_MARK;\n\t\t\t\t\twhile (extIndex + index + 2 < udfLen &&\n\t\t\t\t\t      (index + 1 < EXT_SIZE &&\n\t\t\t\t\t\t(udfName[extIndex + index + 2] == '/' ||\n\t\t\t\t\t\t udfName[extIndex + index + 2] == 0)))\n\t\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\text[localExtIndex++] = curr;\n\t\t\t}\n\t\t\tmaxFilenameLen = newLen - CRC_LEN - localExtIndex;\n\t\t\tif (newIndex > maxFilenameLen)\n\t\t\t\tnewIndex = maxFilenameLen;\n\t\t\telse\n\t\t\t\tnewIndex = newExtIndex;\n\t\t} else if (newIndex > newLen - CRC_LEN)\n\t\t\tnewIndex = newLen - CRC_LEN;\n\t\tnewName[newIndex++] = CRC_MARK;\n\t\tvalueCRC = crc_itu_t(0, fidName, fidNameLen);\n\t\tnewName[newIndex++] = hex_asc_upper_hi(valueCRC >> 8);\n\t\tnewName[newIndex++] = hex_asc_upper_lo(valueCRC >> 8);\n\t\tnewName[newIndex++] = hex_asc_upper_hi(valueCRC);\n\t\tnewName[newIndex++] = hex_asc_upper_lo(valueCRC);\n\n\t\tif (hasExt) {\n\t\t\tnewName[newIndex++] = EXT_MARK;\n\t\t\tfor (index = 0; index < localExtIndex; index++)\n\t\t\t\tnewName[newIndex++] = ext[index];\n\t\t}\n\t}\n\n\treturn newIndex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Failed in udf_get_filename: sname = %s\\n\"",
            "sname"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_CS0toNLS",
          "args": [
            "UDF_SB(sb)->s_nls_map",
            "filename",
            "unifilename"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "udf_CS0toNLS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/unicode.c",
          "lines": "254-295",
          "snippet": "static int udf_CS0toNLS(struct nls_table *nls, struct ustr *utf_o,\n\t\t\tconst struct ustr *ocu_i)\n{\n\tconst uint8_t *ocu;\n\tuint8_t cmp_id, ocu_len;\n\tint i, len;\n\n\n\tocu_len = ocu_i->u_len;\n\tif (ocu_len == 0) {\n\t\tmemset(utf_o, 0, sizeof(struct ustr));\n\t\treturn 0;\n\t}\n\n\tcmp_id = ocu_i->u_cmpID;\n\tif (cmp_id != 8 && cmp_id != 16) {\n\t\tmemset(utf_o, 0, sizeof(struct ustr));\n\t\tpr_err(\"unknown compression code (%d) stri=%s\\n\",\n\t\t       cmp_id, ocu_i->u_name);\n\t\treturn 0;\n\t}\n\n\tocu = ocu_i->u_name;\n\tutf_o->u_len = 0;\n\tfor (i = 0; (i < ocu_len) && (utf_o->u_len <= (UDF_NAME_LEN - 3));) {\n\t\t/* Expand OSTA compressed Unicode to Unicode */\n\t\tuint32_t c = ocu[i++];\n\t\tif (cmp_id == 16)\n\t\t\tc = (c << 8) | ocu[i++];\n\n\t\tlen = nls->uni2char(c, &utf_o->u_name[utf_o->u_len],\n\t\t\t\t    UDF_NAME_LEN - utf_o->u_len);\n\t\t/* Valid character? */\n\t\tif (len >= 0)\n\t\t\tutf_o->u_len += len;\n\t\telse\n\t\t\tutf_o->u_name[utf_o->u_len++] = '?';\n\t}\n\tutf_o->u_cmpID = 8;\n\n\treturn utf_o->u_len;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>\t/* for memset */",
            "#include <linux/kernel.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include <linux/slab.h>\n#include <linux/crc-itu-t.h>\n#include <linux/nls.h>\n#include <linux/string.h>\t/* for memset */\n#include <linux/kernel.h>\n#include \"udfdecl.h\"\n\nstatic int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);\n\nstatic int udf_CS0toNLS(struct nls_table *nls, struct ustr *utf_o,\n\t\t\tconst struct ustr *ocu_i)\n{\n\tconst uint8_t *ocu;\n\tuint8_t cmp_id, ocu_len;\n\tint i, len;\n\n\n\tocu_len = ocu_i->u_len;\n\tif (ocu_len == 0) {\n\t\tmemset(utf_o, 0, sizeof(struct ustr));\n\t\treturn 0;\n\t}\n\n\tcmp_id = ocu_i->u_cmpID;\n\tif (cmp_id != 8 && cmp_id != 16) {\n\t\tmemset(utf_o, 0, sizeof(struct ustr));\n\t\tpr_err(\"unknown compression code (%d) stri=%s\\n\",\n\t\t       cmp_id, ocu_i->u_name);\n\t\treturn 0;\n\t}\n\n\tocu = ocu_i->u_name;\n\tutf_o->u_len = 0;\n\tfor (i = 0; (i < ocu_len) && (utf_o->u_len <= (UDF_NAME_LEN - 3));) {\n\t\t/* Expand OSTA compressed Unicode to Unicode */\n\t\tuint32_t c = ocu[i++];\n\t\tif (cmp_id == 16)\n\t\t\tc = (c << 8) | ocu[i++];\n\n\t\tlen = nls->uni2char(c, &utf_o->u_name[utf_o->u_len],\n\t\t\t\t    UDF_NAME_LEN - utf_o->u_len);\n\t\t/* Valid character? */\n\t\tif (len >= 0)\n\t\t\tutf_o->u_len += len;\n\t\telse\n\t\t\tutf_o->u_name[utf_o->u_len++] = '?';\n\t}\n\tutf_o->u_cmpID = 8;\n\n\treturn utf_o->u_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_QUERY_FLAG",
          "args": [
            "sb",
            "UDF_FLAG_NLS_MAP"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_QUERY_FLAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "169-172",
          "snippet": "static inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Failed in udf_get_filename: sname = %s\\n\"",
            "sname"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_CS0toUTF8",
          "args": [
            "filename",
            "unifilename"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "udf_CS0toUTF8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/unicode.c",
          "lines": "103-153",
          "snippet": "int udf_CS0toUTF8(struct ustr *utf_o, const struct ustr *ocu_i)\n{\n\tconst uint8_t *ocu;\n\tuint8_t cmp_id, ocu_len;\n\tint i;\n\n\tocu_len = ocu_i->u_len;\n\tif (ocu_len == 0) {\n\t\tmemset(utf_o, 0, sizeof(struct ustr));\n\t\treturn 0;\n\t}\n\n\tcmp_id = ocu_i->u_cmpID;\n\tif (cmp_id != 8 && cmp_id != 16) {\n\t\tmemset(utf_o, 0, sizeof(struct ustr));\n\t\tpr_err(\"unknown compression code (%d) stri=%s\\n\",\n\t\t       cmp_id, ocu_i->u_name);\n\t\treturn 0;\n\t}\n\n\tocu = ocu_i->u_name;\n\tutf_o->u_len = 0;\n\tfor (i = 0; (i < ocu_len) && (utf_o->u_len <= (UDF_NAME_LEN - 3));) {\n\n\t\t/* Expand OSTA compressed Unicode to Unicode */\n\t\tuint32_t c = ocu[i++];\n\t\tif (cmp_id == 16)\n\t\t\tc = (c << 8) | ocu[i++];\n\n\t\t/* Compress Unicode to UTF-8 */\n\t\tif (c < 0x80U)\n\t\t\tutf_o->u_name[utf_o->u_len++] = (uint8_t)c;\n\t\telse if (c < 0x800U) {\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0xc0 | (c >> 6));\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0x80 | (c & 0x3f));\n\t\t} else {\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0xe0 | (c >> 12));\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0x80 |\n\t\t\t\t\t\t\t  ((c >> 6) & 0x3f));\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0x80 | (c & 0x3f));\n\t\t}\n\t}\n\tutf_o->u_cmpID = 8;\n\n\treturn utf_o->u_len;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>\t/* for memset */",
            "#include <linux/kernel.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include <linux/slab.h>\n#include <linux/crc-itu-t.h>\n#include <linux/nls.h>\n#include <linux/string.h>\t/* for memset */\n#include <linux/kernel.h>\n#include \"udfdecl.h\"\n\nstatic int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);\n\nint udf_CS0toUTF8(struct ustr *utf_o, const struct ustr *ocu_i)\n{\n\tconst uint8_t *ocu;\n\tuint8_t cmp_id, ocu_len;\n\tint i;\n\n\tocu_len = ocu_i->u_len;\n\tif (ocu_len == 0) {\n\t\tmemset(utf_o, 0, sizeof(struct ustr));\n\t\treturn 0;\n\t}\n\n\tcmp_id = ocu_i->u_cmpID;\n\tif (cmp_id != 8 && cmp_id != 16) {\n\t\tmemset(utf_o, 0, sizeof(struct ustr));\n\t\tpr_err(\"unknown compression code (%d) stri=%s\\n\",\n\t\t       cmp_id, ocu_i->u_name);\n\t\treturn 0;\n\t}\n\n\tocu = ocu_i->u_name;\n\tutf_o->u_len = 0;\n\tfor (i = 0; (i < ocu_len) && (utf_o->u_len <= (UDF_NAME_LEN - 3));) {\n\n\t\t/* Expand OSTA compressed Unicode to Unicode */\n\t\tuint32_t c = ocu[i++];\n\t\tif (cmp_id == 16)\n\t\t\tc = (c << 8) | ocu[i++];\n\n\t\t/* Compress Unicode to UTF-8 */\n\t\tif (c < 0x80U)\n\t\t\tutf_o->u_name[utf_o->u_len++] = (uint8_t)c;\n\t\telse if (c < 0x800U) {\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0xc0 | (c >> 6));\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0x80 | (c & 0x3f));\n\t\t} else {\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0xe0 | (c >> 12));\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0x80 |\n\t\t\t\t\t\t\t  ((c >> 6) & 0x3f));\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0x80 | (c & 0x3f));\n\t\t}\n\t}\n\tutf_o->u_cmpID = 8;\n\n\treturn utf_o->u_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_build_ustr_exact",
          "args": [
            "unifilename",
            "sname",
            "slen"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "udf_build_ustr_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/unicode.c",
          "lines": "71-82",
          "snippet": "static int udf_build_ustr_exact(struct ustr *dest, dstring *ptr, int exactsize)\n{\n\tif ((!dest) || (!ptr) || (!exactsize))\n\t\treturn -1;\n\n\tmemset(dest, 0, sizeof(struct ustr));\n\tdest->u_cmpID = ptr[0];\n\tdest->u_len = exactsize - 1;\n\tmemcpy(dest->u_name, ptr + 1, exactsize - 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>\t/* for memset */",
            "#include <linux/kernel.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include <linux/slab.h>\n#include <linux/crc-itu-t.h>\n#include <linux/nls.h>\n#include <linux/string.h>\t/* for memset */\n#include <linux/kernel.h>\n#include \"udfdecl.h\"\n\nstatic int udf_build_ustr_exact(struct ustr *dest, dstring *ptr, int exactsize)\n{\n\tif ((!dest) || (!ptr) || (!exactsize))\n\t\treturn -1;\n\n\tmemset(dest, 0, sizeof(struct ustr));\n\tdest->u_cmpID = ptr[0];\n\tdest->u_len = exactsize - 1;\n\tmemcpy(dest->u_name, ptr + 1, exactsize - 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct ustr)",
            "GFP_NOFS"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include <linux/slab.h>\n#include <linux/crc-itu-t.h>\n#include <linux/nls.h>\n#include <linux/string.h>\t/* for memset */\n#include <linux/kernel.h>\n#include \"udfdecl.h\"\n\nstatic int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);\n\nint udf_get_filename(struct super_block *sb, uint8_t *sname, int slen,\n\t\t     uint8_t *dname, int dlen)\n{\n\tstruct ustr *filename, *unifilename;\n\tint len = 0;\n\n\tfilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!filename)\n\t\treturn 0;\n\n\tunifilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!unifilename)\n\t\tgoto out1;\n\n\tif (udf_build_ustr_exact(unifilename, sname, slen))\n\t\tgoto out2;\n\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n\t\tif (!udf_CS0toUTF8(filename, unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {\n\t\tif (!udf_CS0toNLS(UDF_SB(sb)->s_nls_map, filename,\n\t\t\t\t  unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else\n\t\tgoto out2;\n\n\tlen = udf_translate_to_linux(dname, dlen,\n\t\t\t\t     filename->u_name, filename->u_len,\n\t\t\t\t     unifilename->u_name, unifilename->u_len);\nout2:\n\tkfree(unifilename);\nout1:\n\tkfree(filename);\n\treturn len;\n}"
  },
  {
    "function_name": "udf_NLStoCS0",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/unicode.c",
    "lines": "297-335",
    "snippet": "static int udf_NLStoCS0(struct nls_table *nls, dstring *ocu, struct ustr *uni,\n\t\t\tint length)\n{\n\tint len;\n\tunsigned i, max_val;\n\tuint16_t uni_char;\n\tint u_len;\n\n\tmemset(ocu, 0, sizeof(dstring) * length);\n\tocu[0] = 8;\n\tmax_val = 0xffU;\n\ntry_again:\n\tu_len = 0U;\n\tfor (i = 0U; i < uni->u_len; i++) {\n\t\tlen = nls->char2uni(&uni->u_name[i], uni->u_len - i, &uni_char);\n\t\tif (!len)\n\t\t\tcontinue;\n\t\t/* Invalid character, deal with it */\n\t\tif (len < 0) {\n\t\t\tlen = 1;\n\t\t\tuni_char = '?';\n\t\t}\n\n\t\tif (uni_char > max_val) {\n\t\t\tmax_val = 0xffffU;\n\t\t\tocu[0] = (uint8_t)0x10U;\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tif (max_val == 0xffffU)\n\t\t\tocu[++u_len] = (uint8_t)(uni_char >> 8);\n\t\tocu[++u_len] = (uint8_t)(uni_char & 0xffU);\n\t\ti += len - 1;\n\t}\n\n\tocu[length - 1] = (uint8_t)u_len + 1;\n\treturn u_len + 1;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include <linux/slab.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/nls.h>",
      "#include <linux/string.h>\t/* for memset */",
      "#include <linux/kernel.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nls->char2uni",
          "args": [
            "&uni->u_name[i]",
            "uni->u_len - i",
            "&uni_char"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "char2uni",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_cp932.c",
          "lines": "7877-7908",
          "snippet": "static int char2uni(const unsigned char *rawstring, int boundlen,\n\t\t    wchar_t *uni)\n{\n\tunsigned char ch, cl;\n\tconst wchar_t *charset2uni;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (rawstring[0] <= 0x7F) {\n\t\t*uni = rawstring[0];\n\t\treturn 1;\n\t}\n\tif (0xA1 <= rawstring[0] && rawstring[0] <= 0xDF) {\n\t\t*uni = 0xFF00 | (rawstring[0] - 0x40);\n\t\treturn 1;\n\t}\n\n\tif (boundlen < 2)\n\t\treturn -ENAMETOOLONG;\n\tch = rawstring[0];\n\tcl = rawstring[1];\n\tcharset2uni = page_charset2uni[ch];\n\tif (charset2uni && cl) {\n\t\t*uni = charset2uni[cl];\n\t\tif (*uni == 0x0000)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t}\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const wchar_t *page_charset2uni[256] = {\n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   c2u_81, c2u_82, c2u_83, c2u_84, NULL,   NULL,   c2u_87, \n\tc2u_88, c2u_89, c2u_8A, c2u_8B, c2u_8C, c2u_8D, c2u_8E, c2u_8F, \n\tc2u_90, c2u_91, c2u_92, c2u_93, c2u_94, c2u_95, c2u_96, c2u_97, \n\tc2u_98, c2u_99, c2u_9A, c2u_9B, c2u_9C, c2u_9D, c2u_9E, c2u_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tc2u_E0, c2u_E1, c2u_E2, c2u_E3, c2u_E4, c2u_E5, c2u_E6, c2u_E7, \n\tc2u_E8, c2u_E9, c2u_EA, NULL,   NULL,   c2u_ED, c2u_EE, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   c2u_FA, c2u_FB, c2u_FC, NULL,   NULL,   NULL,   \n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic const wchar_t *page_charset2uni[256] = {\n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   c2u_81, c2u_82, c2u_83, c2u_84, NULL,   NULL,   c2u_87, \n\tc2u_88, c2u_89, c2u_8A, c2u_8B, c2u_8C, c2u_8D, c2u_8E, c2u_8F, \n\tc2u_90, c2u_91, c2u_92, c2u_93, c2u_94, c2u_95, c2u_96, c2u_97, \n\tc2u_98, c2u_99, c2u_9A, c2u_9B, c2u_9C, c2u_9D, c2u_9E, c2u_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tc2u_E0, c2u_E1, c2u_E2, c2u_E3, c2u_E4, c2u_E5, c2u_E6, c2u_E7, \n\tc2u_E8, c2u_E9, c2u_EA, NULL,   NULL,   c2u_ED, c2u_EE, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   c2u_FA, c2u_FB, c2u_FC, NULL,   NULL,   NULL,   \n};\n\nstatic int char2uni(const unsigned char *rawstring, int boundlen,\n\t\t    wchar_t *uni)\n{\n\tunsigned char ch, cl;\n\tconst wchar_t *charset2uni;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (rawstring[0] <= 0x7F) {\n\t\t*uni = rawstring[0];\n\t\treturn 1;\n\t}\n\tif (0xA1 <= rawstring[0] && rawstring[0] <= 0xDF) {\n\t\t*uni = 0xFF00 | (rawstring[0] - 0x40);\n\t\treturn 1;\n\t}\n\n\tif (boundlen < 2)\n\t\treturn -ENAMETOOLONG;\n\tch = rawstring[0];\n\tcl = rawstring[1];\n\tcharset2uni = page_charset2uni[ch];\n\tif (charset2uni && cl) {\n\t\t*uni = charset2uni[cl];\n\t\tif (*uni == 0x0000)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t}\n\telse\n\t\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ocu",
            "0",
            "sizeof(dstring) * length"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include <linux/slab.h>\n#include <linux/crc-itu-t.h>\n#include <linux/nls.h>\n#include <linux/string.h>\t/* for memset */\n#include <linux/kernel.h>\n#include \"udfdecl.h\"\n\nstatic int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);\n\nstatic int udf_NLStoCS0(struct nls_table *nls, dstring *ocu, struct ustr *uni,\n\t\t\tint length)\n{\n\tint len;\n\tunsigned i, max_val;\n\tuint16_t uni_char;\n\tint u_len;\n\n\tmemset(ocu, 0, sizeof(dstring) * length);\n\tocu[0] = 8;\n\tmax_val = 0xffU;\n\ntry_again:\n\tu_len = 0U;\n\tfor (i = 0U; i < uni->u_len; i++) {\n\t\tlen = nls->char2uni(&uni->u_name[i], uni->u_len - i, &uni_char);\n\t\tif (!len)\n\t\t\tcontinue;\n\t\t/* Invalid character, deal with it */\n\t\tif (len < 0) {\n\t\t\tlen = 1;\n\t\t\tuni_char = '?';\n\t\t}\n\n\t\tif (uni_char > max_val) {\n\t\t\tmax_val = 0xffffU;\n\t\t\tocu[0] = (uint8_t)0x10U;\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tif (max_val == 0xffffU)\n\t\t\tocu[++u_len] = (uint8_t)(uni_char >> 8);\n\t\tocu[++u_len] = (uint8_t)(uni_char & 0xffU);\n\t\ti += len - 1;\n\t}\n\n\tocu[length - 1] = (uint8_t)u_len + 1;\n\treturn u_len + 1;\n}"
  },
  {
    "function_name": "udf_CS0toNLS",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/unicode.c",
    "lines": "254-295",
    "snippet": "static int udf_CS0toNLS(struct nls_table *nls, struct ustr *utf_o,\n\t\t\tconst struct ustr *ocu_i)\n{\n\tconst uint8_t *ocu;\n\tuint8_t cmp_id, ocu_len;\n\tint i, len;\n\n\n\tocu_len = ocu_i->u_len;\n\tif (ocu_len == 0) {\n\t\tmemset(utf_o, 0, sizeof(struct ustr));\n\t\treturn 0;\n\t}\n\n\tcmp_id = ocu_i->u_cmpID;\n\tif (cmp_id != 8 && cmp_id != 16) {\n\t\tmemset(utf_o, 0, sizeof(struct ustr));\n\t\tpr_err(\"unknown compression code (%d) stri=%s\\n\",\n\t\t       cmp_id, ocu_i->u_name);\n\t\treturn 0;\n\t}\n\n\tocu = ocu_i->u_name;\n\tutf_o->u_len = 0;\n\tfor (i = 0; (i < ocu_len) && (utf_o->u_len <= (UDF_NAME_LEN - 3));) {\n\t\t/* Expand OSTA compressed Unicode to Unicode */\n\t\tuint32_t c = ocu[i++];\n\t\tif (cmp_id == 16)\n\t\t\tc = (c << 8) | ocu[i++];\n\n\t\tlen = nls->uni2char(c, &utf_o->u_name[utf_o->u_len],\n\t\t\t\t    UDF_NAME_LEN - utf_o->u_len);\n\t\t/* Valid character? */\n\t\tif (len >= 0)\n\t\t\tutf_o->u_len += len;\n\t\telse\n\t\t\tutf_o->u_name[utf_o->u_len++] = '?';\n\t}\n\tutf_o->u_cmpID = 8;\n\n\treturn utf_o->u_len;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include <linux/slab.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/nls.h>",
      "#include <linux/string.h>\t/* for memset */",
      "#include <linux/kernel.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nls->uni2char",
          "args": [
            "c",
            "&utf_o->u_name[utf_o->u_len]",
            "UDF_NAME_LEN - utf_o->u_len"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "uni2char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_cp932.c",
          "lines": "7837-7875",
          "snippet": "static int uni2char(const wchar_t uni,\n\t\t    unsigned char *out, int boundlen)\n{\n\tconst unsigned char *uni2charset;\n\tunsigned char cl = uni&0xFF;\n\tunsigned char ch = (uni>>8)&0xFF;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (ch == 0xFF && 0x61 <= cl && cl <= 0x9F) {\n\t\tout[0] = cl + 0x40;\n\t\treturn 1;\n\t}\n\tuni2charset = page_uni2charset[ch];\n\tif (uni2charset) {\n\t\tif (boundlen < 2)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\tout[0] = uni2charset[cl*2];\n\t\tout[1] = uni2charset[cl*2+1];\n\t\tif (out[0] == 0x00 && out[1] == 0x00)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t} else if (ch == 0) {\n\t\tif (cl <= 0x7F) {\n\t\t\tout[0] = cl;\n\t\t\treturn 1;\n\t\t} else if (0xA0 <= cl) {\n\t\t\tout[0] = u2c_00hi[cl - 0xA0][0];\n\t\t\tout[1] = u2c_00hi[cl - 0xA0][1];\n\t\t\tif (out[0] && out[1])\n\t\t\t\treturn 2;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char u2c_00hi[256 - 0xA0][2] = {\n\t{0x00, 0x00}, {0x00, 0x00}, {0x81, 0x91}, {0x81, 0x92},/* 0xA0-0xA3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x98},/* 0xA4-0xA7 */\n\t{0x81, 0x4E}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xA8-0xAB */\n\t{0x81, 0xCA}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xAC-0xAF */\n\t{0x81, 0x8B}, {0x81, 0x7D}, {0x00, 0x00}, {0x00, 0x00},/* 0xB0-0xB3 */\n\t{0x81, 0x4C}, {0x00, 0x00}, {0x81, 0xF7}, {0x00, 0x00},/* 0xB4-0xB7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xB8-0xBB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xBC-0xBF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC0-0xC3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC4-0xC7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC8-0xCB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xCC-0xCF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD0-0xD3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x7E},/* 0xD4-0xD7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD8-0xDB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xDC-0xDF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE0-0xE3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE4-0xE7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE8-0xEB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xEC-0xEF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF0-0xF3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x80},/* 0xF4-0xF7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF8-0xFB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xFC-0xFF */\n};",
            "static const unsigned char *const page_uni2charset[256] = {\n\tNULL,   NULL,   NULL,   u2c_03, u2c_04, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_20, u2c_21, u2c_22, u2c_23, u2c_24, u2c_25, u2c_26, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_30, NULL,   u2c_32, u2c_33, NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   u2c_4E, u2c_4F, \n\tu2c_50, u2c_51, u2c_52, u2c_53, u2c_54, u2c_55, u2c_56, u2c_57, \n\tu2c_58, u2c_59, u2c_5A, u2c_5B, u2c_5C, u2c_5D, u2c_5E, u2c_5F, \n\tu2c_60, u2c_61, u2c_62, u2c_63, u2c_64, u2c_65, u2c_66, u2c_67, \n\tu2c_68, u2c_69, u2c_6A, u2c_6B, u2c_6C, u2c_6D, u2c_6E, u2c_6F, \n\tu2c_70, u2c_71, u2c_72, u2c_73, u2c_74, u2c_75, u2c_76, u2c_77, \n\tu2c_78, u2c_79, u2c_7A, u2c_7B, u2c_7C, u2c_7D, u2c_7E, u2c_7F, \n\tu2c_80, u2c_81, u2c_82, u2c_83, u2c_84, u2c_85, u2c_86, u2c_87, \n\tu2c_88, u2c_89, u2c_8A, u2c_8B, u2c_8C, u2c_8D, u2c_8E, u2c_8F, \n\tu2c_90, u2c_91, u2c_92, u2c_93, u2c_94, u2c_95, u2c_96, u2c_97, \n\tu2c_98, u2c_99, u2c_9A, u2c_9B, u2c_9C, u2c_9D, u2c_9E, u2c_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   u2c_DC, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   u2c_F9, u2c_FA, NULL,   NULL,   NULL,   NULL,   u2c_FF, };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic const unsigned char u2c_00hi[256 - 0xA0][2] = {\n\t{0x00, 0x00}, {0x00, 0x00}, {0x81, 0x91}, {0x81, 0x92},/* 0xA0-0xA3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x98},/* 0xA4-0xA7 */\n\t{0x81, 0x4E}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xA8-0xAB */\n\t{0x81, 0xCA}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xAC-0xAF */\n\t{0x81, 0x8B}, {0x81, 0x7D}, {0x00, 0x00}, {0x00, 0x00},/* 0xB0-0xB3 */\n\t{0x81, 0x4C}, {0x00, 0x00}, {0x81, 0xF7}, {0x00, 0x00},/* 0xB4-0xB7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xB8-0xBB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xBC-0xBF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC0-0xC3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC4-0xC7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xC8-0xCB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xCC-0xCF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD0-0xD3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x7E},/* 0xD4-0xD7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xD8-0xDB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xDC-0xDF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE0-0xE3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE4-0xE7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xE8-0xEB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xEC-0xEF */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF0-0xF3 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x81, 0x80},/* 0xF4-0xF7 */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xF8-0xFB */\n\t{0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00}, {0x00, 0x00},/* 0xFC-0xFF */\n};\nstatic const unsigned char *const page_uni2charset[256] = {\n\tNULL,   NULL,   NULL,   u2c_03, u2c_04, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_20, u2c_21, u2c_22, u2c_23, u2c_24, u2c_25, u2c_26, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tu2c_30, NULL,   u2c_32, u2c_33, NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   u2c_4E, u2c_4F, \n\tu2c_50, u2c_51, u2c_52, u2c_53, u2c_54, u2c_55, u2c_56, u2c_57, \n\tu2c_58, u2c_59, u2c_5A, u2c_5B, u2c_5C, u2c_5D, u2c_5E, u2c_5F, \n\tu2c_60, u2c_61, u2c_62, u2c_63, u2c_64, u2c_65, u2c_66, u2c_67, \n\tu2c_68, u2c_69, u2c_6A, u2c_6B, u2c_6C, u2c_6D, u2c_6E, u2c_6F, \n\tu2c_70, u2c_71, u2c_72, u2c_73, u2c_74, u2c_75, u2c_76, u2c_77, \n\tu2c_78, u2c_79, u2c_7A, u2c_7B, u2c_7C, u2c_7D, u2c_7E, u2c_7F, \n\tu2c_80, u2c_81, u2c_82, u2c_83, u2c_84, u2c_85, u2c_86, u2c_87, \n\tu2c_88, u2c_89, u2c_8A, u2c_8B, u2c_8C, u2c_8D, u2c_8E, u2c_8F, \n\tu2c_90, u2c_91, u2c_92, u2c_93, u2c_94, u2c_95, u2c_96, u2c_97, \n\tu2c_98, u2c_99, u2c_9A, u2c_9B, u2c_9C, u2c_9D, u2c_9E, u2c_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   u2c_DC, NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   u2c_F9, u2c_FA, NULL,   NULL,   NULL,   NULL,   u2c_FF, };\n\nstatic int uni2char(const wchar_t uni,\n\t\t    unsigned char *out, int boundlen)\n{\n\tconst unsigned char *uni2charset;\n\tunsigned char cl = uni&0xFF;\n\tunsigned char ch = (uni>>8)&0xFF;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (ch == 0xFF && 0x61 <= cl && cl <= 0x9F) {\n\t\tout[0] = cl + 0x40;\n\t\treturn 1;\n\t}\n\tuni2charset = page_uni2charset[ch];\n\tif (uni2charset) {\n\t\tif (boundlen < 2)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\tout[0] = uni2charset[cl*2];\n\t\tout[1] = uni2charset[cl*2+1];\n\t\tif (out[0] == 0x00 && out[1] == 0x00)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t} else if (ch == 0) {\n\t\tif (cl <= 0x7F) {\n\t\t\tout[0] = cl;\n\t\t\treturn 1;\n\t\t} else if (0xA0 <= cl) {\n\t\t\tout[0] = u2c_00hi[cl - 0xA0][0];\n\t\t\tout[1] = u2c_00hi[cl - 0xA0][1];\n\t\t\tif (out[0] && out[1])\n\t\t\t\treturn 2;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\telse\n\t\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unknown compression code (%d) stri=%s\\n\"",
            "cmp_id",
            "ocu_i->u_name"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "utf_o",
            "0",
            "sizeof(struct ustr)"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "utf_o",
            "0",
            "sizeof(struct ustr)"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include <linux/slab.h>\n#include <linux/crc-itu-t.h>\n#include <linux/nls.h>\n#include <linux/string.h>\t/* for memset */\n#include <linux/kernel.h>\n#include \"udfdecl.h\"\n\nstatic int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);\n\nstatic int udf_CS0toNLS(struct nls_table *nls, struct ustr *utf_o,\n\t\t\tconst struct ustr *ocu_i)\n{\n\tconst uint8_t *ocu;\n\tuint8_t cmp_id, ocu_len;\n\tint i, len;\n\n\n\tocu_len = ocu_i->u_len;\n\tif (ocu_len == 0) {\n\t\tmemset(utf_o, 0, sizeof(struct ustr));\n\t\treturn 0;\n\t}\n\n\tcmp_id = ocu_i->u_cmpID;\n\tif (cmp_id != 8 && cmp_id != 16) {\n\t\tmemset(utf_o, 0, sizeof(struct ustr));\n\t\tpr_err(\"unknown compression code (%d) stri=%s\\n\",\n\t\t       cmp_id, ocu_i->u_name);\n\t\treturn 0;\n\t}\n\n\tocu = ocu_i->u_name;\n\tutf_o->u_len = 0;\n\tfor (i = 0; (i < ocu_len) && (utf_o->u_len <= (UDF_NAME_LEN - 3));) {\n\t\t/* Expand OSTA compressed Unicode to Unicode */\n\t\tuint32_t c = ocu[i++];\n\t\tif (cmp_id == 16)\n\t\t\tc = (c << 8) | ocu[i++];\n\n\t\tlen = nls->uni2char(c, &utf_o->u_name[utf_o->u_len],\n\t\t\t\t    UDF_NAME_LEN - utf_o->u_len);\n\t\t/* Valid character? */\n\t\tif (len >= 0)\n\t\t\tutf_o->u_len += len;\n\t\telse\n\t\t\tutf_o->u_name[utf_o->u_len++] = '?';\n\t}\n\tutf_o->u_cmpID = 8;\n\n\treturn utf_o->u_len;\n}"
  },
  {
    "function_name": "udf_UTF8toCS0",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/unicode.c",
    "lines": "178-252",
    "snippet": "static int udf_UTF8toCS0(dstring *ocu, struct ustr *utf, int length)\n{\n\tunsigned c, i, max_val, utf_char;\n\tint utf_cnt, u_len;\n\n\tmemset(ocu, 0, sizeof(dstring) * length);\n\tocu[0] = 8;\n\tmax_val = 0xffU;\n\ntry_again:\n\tu_len = 0U;\n\tutf_char = 0U;\n\tutf_cnt = 0U;\n\tfor (i = 0U; i < utf->u_len; i++) {\n\t\tc = (uint8_t)utf->u_name[i];\n\n\t\t/* Complete a multi-byte UTF-8 character */\n\t\tif (utf_cnt) {\n\t\t\tutf_char = (utf_char << 6) | (c & 0x3fU);\n\t\t\tif (--utf_cnt)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\t/* Check for a multi-byte UTF-8 character */\n\t\t\tif (c & 0x80U) {\n\t\t\t\t/* Start a multi-byte UTF-8 character */\n\t\t\t\tif ((c & 0xe0U) == 0xc0U) {\n\t\t\t\t\tutf_char = c & 0x1fU;\n\t\t\t\t\tutf_cnt = 1;\n\t\t\t\t} else if ((c & 0xf0U) == 0xe0U) {\n\t\t\t\t\tutf_char = c & 0x0fU;\n\t\t\t\t\tutf_cnt = 2;\n\t\t\t\t} else if ((c & 0xf8U) == 0xf0U) {\n\t\t\t\t\tutf_char = c & 0x07U;\n\t\t\t\t\tutf_cnt = 3;\n\t\t\t\t} else if ((c & 0xfcU) == 0xf8U) {\n\t\t\t\t\tutf_char = c & 0x03U;\n\t\t\t\t\tutf_cnt = 4;\n\t\t\t\t} else if ((c & 0xfeU) == 0xfcU) {\n\t\t\t\t\tutf_char = c & 0x01U;\n\t\t\t\t\tutf_cnt = 5;\n\t\t\t\t} else {\n\t\t\t\t\tgoto error_out;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t/* Single byte UTF-8 character (most common) */\n\t\t\t\tutf_char = c;\n\t\t\t}\n\t\t}\n\n\t\t/* Choose no compression if necessary */\n\t\tif (utf_char > max_val) {\n\t\t\tif (max_val == 0xffU) {\n\t\t\t\tmax_val = 0xffffU;\n\t\t\t\tocu[0] = (uint8_t)0x10U;\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tif (max_val == 0xffffU)\n\t\t\tocu[++u_len] = (uint8_t)(utf_char >> 8);\n\t\tocu[++u_len] = (uint8_t)(utf_char & 0xffU);\n\t}\n\n\tif (utf_cnt) {\nerror_out:\n\t\tocu[++u_len] = '?';\n\t\tprintk(KERN_DEBUG pr_fmt(\"bad UTF-8 character\\n\"));\n\t}\n\n\tocu[length - 1] = (uint8_t)u_len + 1;\n\n\treturn u_len + 1;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include <linux/slab.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/nls.h>",
      "#include <linux/string.h>\t/* for memset */",
      "#include <linux/kernel.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ocu",
            "0",
            "sizeof(dstring) * length"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include <linux/slab.h>\n#include <linux/crc-itu-t.h>\n#include <linux/nls.h>\n#include <linux/string.h>\t/* for memset */\n#include <linux/kernel.h>\n#include \"udfdecl.h\"\n\nstatic int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);\n\nstatic int udf_UTF8toCS0(dstring *ocu, struct ustr *utf, int length)\n{\n\tunsigned c, i, max_val, utf_char;\n\tint utf_cnt, u_len;\n\n\tmemset(ocu, 0, sizeof(dstring) * length);\n\tocu[0] = 8;\n\tmax_val = 0xffU;\n\ntry_again:\n\tu_len = 0U;\n\tutf_char = 0U;\n\tutf_cnt = 0U;\n\tfor (i = 0U; i < utf->u_len; i++) {\n\t\tc = (uint8_t)utf->u_name[i];\n\n\t\t/* Complete a multi-byte UTF-8 character */\n\t\tif (utf_cnt) {\n\t\t\tutf_char = (utf_char << 6) | (c & 0x3fU);\n\t\t\tif (--utf_cnt)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\t/* Check for a multi-byte UTF-8 character */\n\t\t\tif (c & 0x80U) {\n\t\t\t\t/* Start a multi-byte UTF-8 character */\n\t\t\t\tif ((c & 0xe0U) == 0xc0U) {\n\t\t\t\t\tutf_char = c & 0x1fU;\n\t\t\t\t\tutf_cnt = 1;\n\t\t\t\t} else if ((c & 0xf0U) == 0xe0U) {\n\t\t\t\t\tutf_char = c & 0x0fU;\n\t\t\t\t\tutf_cnt = 2;\n\t\t\t\t} else if ((c & 0xf8U) == 0xf0U) {\n\t\t\t\t\tutf_char = c & 0x07U;\n\t\t\t\t\tutf_cnt = 3;\n\t\t\t\t} else if ((c & 0xfcU) == 0xf8U) {\n\t\t\t\t\tutf_char = c & 0x03U;\n\t\t\t\t\tutf_cnt = 4;\n\t\t\t\t} else if ((c & 0xfeU) == 0xfcU) {\n\t\t\t\t\tutf_char = c & 0x01U;\n\t\t\t\t\tutf_cnt = 5;\n\t\t\t\t} else {\n\t\t\t\t\tgoto error_out;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t/* Single byte UTF-8 character (most common) */\n\t\t\t\tutf_char = c;\n\t\t\t}\n\t\t}\n\n\t\t/* Choose no compression if necessary */\n\t\tif (utf_char > max_val) {\n\t\t\tif (max_val == 0xffU) {\n\t\t\t\tmax_val = 0xffffU;\n\t\t\t\tocu[0] = (uint8_t)0x10U;\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tif (max_val == 0xffffU)\n\t\t\tocu[++u_len] = (uint8_t)(utf_char >> 8);\n\t\tocu[++u_len] = (uint8_t)(utf_char & 0xffU);\n\t}\n\n\tif (utf_cnt) {\nerror_out:\n\t\tocu[++u_len] = '?';\n\t\tprintk(KERN_DEBUG pr_fmt(\"bad UTF-8 character\\n\"));\n\t}\n\n\tocu[length - 1] = (uint8_t)u_len + 1;\n\n\treturn u_len + 1;\n}"
  },
  {
    "function_name": "udf_CS0toUTF8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/unicode.c",
    "lines": "103-153",
    "snippet": "int udf_CS0toUTF8(struct ustr *utf_o, const struct ustr *ocu_i)\n{\n\tconst uint8_t *ocu;\n\tuint8_t cmp_id, ocu_len;\n\tint i;\n\n\tocu_len = ocu_i->u_len;\n\tif (ocu_len == 0) {\n\t\tmemset(utf_o, 0, sizeof(struct ustr));\n\t\treturn 0;\n\t}\n\n\tcmp_id = ocu_i->u_cmpID;\n\tif (cmp_id != 8 && cmp_id != 16) {\n\t\tmemset(utf_o, 0, sizeof(struct ustr));\n\t\tpr_err(\"unknown compression code (%d) stri=%s\\n\",\n\t\t       cmp_id, ocu_i->u_name);\n\t\treturn 0;\n\t}\n\n\tocu = ocu_i->u_name;\n\tutf_o->u_len = 0;\n\tfor (i = 0; (i < ocu_len) && (utf_o->u_len <= (UDF_NAME_LEN - 3));) {\n\n\t\t/* Expand OSTA compressed Unicode to Unicode */\n\t\tuint32_t c = ocu[i++];\n\t\tif (cmp_id == 16)\n\t\t\tc = (c << 8) | ocu[i++];\n\n\t\t/* Compress Unicode to UTF-8 */\n\t\tif (c < 0x80U)\n\t\t\tutf_o->u_name[utf_o->u_len++] = (uint8_t)c;\n\t\telse if (c < 0x800U) {\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0xc0 | (c >> 6));\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0x80 | (c & 0x3f));\n\t\t} else {\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0xe0 | (c >> 12));\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0x80 |\n\t\t\t\t\t\t\t  ((c >> 6) & 0x3f));\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0x80 | (c & 0x3f));\n\t\t}\n\t}\n\tutf_o->u_cmpID = 8;\n\n\treturn utf_o->u_len;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include <linux/slab.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/nls.h>",
      "#include <linux/string.h>\t/* for memset */",
      "#include <linux/kernel.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unknown compression code (%d) stri=%s\\n\"",
            "cmp_id",
            "ocu_i->u_name"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "utf_o",
            "0",
            "sizeof(struct ustr)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "utf_o",
            "0",
            "sizeof(struct ustr)"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include <linux/slab.h>\n#include <linux/crc-itu-t.h>\n#include <linux/nls.h>\n#include <linux/string.h>\t/* for memset */\n#include <linux/kernel.h>\n#include \"udfdecl.h\"\n\nstatic int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);\n\nint udf_CS0toUTF8(struct ustr *utf_o, const struct ustr *ocu_i)\n{\n\tconst uint8_t *ocu;\n\tuint8_t cmp_id, ocu_len;\n\tint i;\n\n\tocu_len = ocu_i->u_len;\n\tif (ocu_len == 0) {\n\t\tmemset(utf_o, 0, sizeof(struct ustr));\n\t\treturn 0;\n\t}\n\n\tcmp_id = ocu_i->u_cmpID;\n\tif (cmp_id != 8 && cmp_id != 16) {\n\t\tmemset(utf_o, 0, sizeof(struct ustr));\n\t\tpr_err(\"unknown compression code (%d) stri=%s\\n\",\n\t\t       cmp_id, ocu_i->u_name);\n\t\treturn 0;\n\t}\n\n\tocu = ocu_i->u_name;\n\tutf_o->u_len = 0;\n\tfor (i = 0; (i < ocu_len) && (utf_o->u_len <= (UDF_NAME_LEN - 3));) {\n\n\t\t/* Expand OSTA compressed Unicode to Unicode */\n\t\tuint32_t c = ocu[i++];\n\t\tif (cmp_id == 16)\n\t\t\tc = (c << 8) | ocu[i++];\n\n\t\t/* Compress Unicode to UTF-8 */\n\t\tif (c < 0x80U)\n\t\t\tutf_o->u_name[utf_o->u_len++] = (uint8_t)c;\n\t\telse if (c < 0x800U) {\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0xc0 | (c >> 6));\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0x80 | (c & 0x3f));\n\t\t} else {\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0xe0 | (c >> 12));\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0x80 |\n\t\t\t\t\t\t\t  ((c >> 6) & 0x3f));\n\t\t\tutf_o->u_name[utf_o->u_len++] =\n\t\t\t\t\t\t(uint8_t)(0x80 | (c & 0x3f));\n\t\t}\n\t}\n\tutf_o->u_cmpID = 8;\n\n\treturn utf_o->u_len;\n}"
  },
  {
    "function_name": "udf_build_ustr_exact",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/unicode.c",
    "lines": "71-82",
    "snippet": "static int udf_build_ustr_exact(struct ustr *dest, dstring *ptr, int exactsize)\n{\n\tif ((!dest) || (!ptr) || (!exactsize))\n\t\treturn -1;\n\n\tmemset(dest, 0, sizeof(struct ustr));\n\tdest->u_cmpID = ptr[0];\n\tdest->u_len = exactsize - 1;\n\tmemcpy(dest->u_name, ptr + 1, exactsize - 1);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include <linux/slab.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/nls.h>",
      "#include <linux/string.h>\t/* for memset */",
      "#include <linux/kernel.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest->u_name",
            "ptr + 1",
            "exactsize - 1"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dest",
            "0",
            "sizeof(struct ustr)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include <linux/slab.h>\n#include <linux/crc-itu-t.h>\n#include <linux/nls.h>\n#include <linux/string.h>\t/* for memset */\n#include <linux/kernel.h>\n#include \"udfdecl.h\"\n\nstatic int udf_build_ustr_exact(struct ustr *dest, dstring *ptr, int exactsize)\n{\n\tif ((!dest) || (!ptr) || (!exactsize))\n\t\treturn -1;\n\n\tmemset(dest, 0, sizeof(struct ustr));\n\tdest->u_cmpID = ptr[0];\n\tdest->u_len = exactsize - 1;\n\tmemcpy(dest->u_name, ptr + 1, exactsize - 1);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "udf_build_ustr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/unicode.c",
    "lines": "50-66",
    "snippet": "int udf_build_ustr(struct ustr *dest, dstring *ptr, int size)\n{\n\tint usesize;\n\n\tif (!dest || !ptr || !size)\n\t\treturn -1;\n\tBUG_ON(size < 2);\n\n\tusesize = min_t(size_t, ptr[size - 1], sizeof(dest->u_name));\n\tusesize = min(usesize, size - 2);\n\tdest->u_cmpID = ptr[0];\n\tdest->u_len = usesize;\n\tmemcpy(dest->u_name, ptr + 1, usesize);\n\tmemset(dest->u_name + usesize, 0, sizeof(dest->u_name) - usesize);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include <linux/slab.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/nls.h>",
      "#include <linux/string.h>\t/* for memset */",
      "#include <linux/kernel.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dest->u_name + usesize",
            "0",
            "sizeof(dest->u_name) - usesize"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest->u_name",
            "ptr + 1",
            "usesize"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "usesize",
            "size - 2"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "ptr[size - 1]",
            "sizeof(dest->u_name)"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "size < 2"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include <linux/slab.h>\n#include <linux/crc-itu-t.h>\n#include <linux/nls.h>\n#include <linux/string.h>\t/* for memset */\n#include <linux/kernel.h>\n#include \"udfdecl.h\"\n\nint udf_build_ustr(struct ustr *dest, dstring *ptr, int size)\n{\n\tint usesize;\n\n\tif (!dest || !ptr || !size)\n\t\treturn -1;\n\tBUG_ON(size < 2);\n\n\tusesize = min_t(size_t, ptr[size - 1], sizeof(dest->u_name));\n\tusesize = min(usesize, size - 2);\n\tdest->u_cmpID = ptr[0];\n\tdest->u_len = usesize;\n\tmemcpy(dest->u_name, ptr + 1, usesize);\n\tmemset(dest->u_name + usesize, 0, sizeof(dest->u_name) - usesize);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "udf_char_to_ustr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/unicode.c",
    "lines": "34-45",
    "snippet": "static int udf_char_to_ustr(struct ustr *dest, const uint8_t *src, int strlen)\n{\n\tif ((!dest) || (!src) || (!strlen) || (strlen > UDF_NAME_LEN - 2))\n\t\treturn 0;\n\n\tmemset(dest, 0, sizeof(struct ustr));\n\tmemcpy(dest->u_name, src, strlen);\n\tdest->u_cmpID = 0x08;\n\tdest->u_len = strlen;\n\n\treturn strlen;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include <linux/slab.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/nls.h>",
      "#include <linux/string.h>\t/* for memset */",
      "#include <linux/kernel.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest->u_name",
            "src",
            "strlen"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dest",
            "0",
            "sizeof(struct ustr)"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include <linux/slab.h>\n#include <linux/crc-itu-t.h>\n#include <linux/nls.h>\n#include <linux/string.h>\t/* for memset */\n#include <linux/kernel.h>\n#include \"udfdecl.h\"\n\nstatic int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);\n\nstatic int udf_char_to_ustr(struct ustr *dest, const uint8_t *src, int strlen)\n{\n\tif ((!dest) || (!src) || (!strlen) || (strlen > UDF_NAME_LEN - 2))\n\t\treturn 0;\n\n\tmemset(dest, 0, sizeof(struct ustr));\n\tmemcpy(dest->u_name, src, strlen);\n\tdest->u_cmpID = 0x08;\n\tdest->u_len = strlen;\n\n\treturn strlen;\n}"
  }
]