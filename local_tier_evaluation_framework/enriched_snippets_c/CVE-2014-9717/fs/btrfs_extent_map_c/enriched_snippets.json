[
  {
    "function_name": "replace_extent_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
    "lines": "442-455",
    "snippet": "void replace_extent_mapping(struct extent_map_tree *tree,\n\t\t\t    struct extent_map *cur,\n\t\t\t    struct extent_map *new,\n\t\t\t    int modified)\n{\n\tWARN_ON(test_bit(EXTENT_FLAG_PINNED, &cur->flags));\n\tASSERT(extent_map_in_tree(cur));\n\tif (!test_bit(EXTENT_FLAG_LOGGING, &cur->flags))\n\t\tlist_del_init(&cur->list);\n\trb_replace_node(&cur->rb_node, &new->rb_node, &tree->map);\n\tRB_CLEAR_NODE(&cur->rb_node);\n\n\tsetup_extent_mapping(tree, new, modified);\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setup_extent_mapping",
          "args": [
            "tree",
            "new",
            "modified"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "setup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "321-333",
          "snippet": "static inline void setup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\tstruct extent_map *em,\n\t\t\t\t\tint modified)\n{\n\tatomic_inc(&em->refs);\n\tem->mod_start = em->start;\n\tem->mod_len = em->len;\n\n\tif (modified)\n\t\tlist_move(&em->list, &tree->modified_extents);\n\telse\n\t\ttry_merge_map(tree, em);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic inline void setup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\tstruct extent_map *em,\n\t\t\t\t\tint modified)\n{\n\tatomic_inc(&em->refs);\n\tem->mod_start = em->start;\n\tem->mod_len = em->len;\n\n\tif (modified)\n\t\tlist_move(&em->list, &tree->modified_extents);\n\telse\n\t\ttry_merge_map(tree, em);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&cur->rb_node"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_replace_node",
          "args": [
            "&cur->rb_node",
            "&new->rb_node",
            "&tree->map"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cur->list"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_FLAG_LOGGING",
            "&cur->flags"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "extent_map_in_tree(cur)"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_map_in_tree",
          "args": [
            "cur"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "extent_map_in_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.h",
          "lines": "47-50",
          "snippet": "static inline int extent_map_in_tree(const struct extent_map *em)\n{\n\treturn !RB_EMPTY_NODE(&em->rb_node);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline int extent_map_in_tree(const struct extent_map *em)\n{\n\treturn !RB_EMPTY_NODE(&em->rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "test_bit(EXTENT_FLAG_PINNED, &cur->flags)"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nvoid replace_extent_mapping(struct extent_map_tree *tree,\n\t\t\t    struct extent_map *cur,\n\t\t\t    struct extent_map *new,\n\t\t\t    int modified)\n{\n\tWARN_ON(test_bit(EXTENT_FLAG_PINNED, &cur->flags));\n\tASSERT(extent_map_in_tree(cur));\n\tif (!test_bit(EXTENT_FLAG_LOGGING, &cur->flags))\n\t\tlist_del_init(&cur->list);\n\trb_replace_node(&cur->rb_node, &new->rb_node, &tree->map);\n\tRB_CLEAR_NODE(&cur->rb_node);\n\n\tsetup_extent_mapping(tree, new, modified);\n}"
  },
  {
    "function_name": "remove_extent_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
    "lines": "430-440",
    "snippet": "int remove_extent_mapping(struct extent_map_tree *tree, struct extent_map *em)\n{\n\tint ret = 0;\n\n\tWARN_ON(test_bit(EXTENT_FLAG_PINNED, &em->flags));\n\trb_erase(&em->rb_node, &tree->map);\n\tif (!test_bit(EXTENT_FLAG_LOGGING, &em->flags))\n\t\tlist_del_init(&em->list);\n\tRB_CLEAR_NODE(&em->rb_node);\n\treturn ret;\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&em->rb_node"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&em->list"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_FLAG_LOGGING",
            "&em->flags"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&em->rb_node",
            "&tree->map"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "test_bit(EXTENT_FLAG_PINNED, &em->flags)"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nint remove_extent_mapping(struct extent_map_tree *tree, struct extent_map *em)\n{\n\tint ret = 0;\n\n\tWARN_ON(test_bit(EXTENT_FLAG_PINNED, &em->flags));\n\trb_erase(&em->rb_node, &tree->map);\n\tif (!test_bit(EXTENT_FLAG_LOGGING, &em->flags))\n\t\tlist_del_init(&em->list);\n\tRB_CLEAR_NODE(&em->rb_node);\n\treturn ret;\n}"
  },
  {
    "function_name": "search_extent_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
    "lines": "416-420",
    "snippet": "struct extent_map *search_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 0);\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__lookup_extent_mapping",
          "args": [
            "tree",
            "start",
            "len",
            "0"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "359-386",
          "snippet": "static struct extent_map *\n__lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\tu64 start, u64 len, int strict)\n{\n\tstruct extent_map *em;\n\tstruct rb_node *rb_node;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *next = NULL;\n\tu64 end = range_end(start, len);\n\n\trb_node = __tree_search(&tree->map, start, &prev, &next);\n\tif (!rb_node) {\n\t\tif (prev)\n\t\t\trb_node = prev;\n\t\telse if (next)\n\t\t\trb_node = next;\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\tem = rb_entry(rb_node, struct extent_map, rb_node);\n\n\tif (strict && !(end > em->start && start < extent_map_end(em)))\n\t\treturn NULL;\n\n\tatomic_inc(&em->refs);\n\treturn em;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct extent_map *\n__lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\tu64 start, u64 len, int strict)\n{\n\tstruct extent_map *em;\n\tstruct rb_node *rb_node;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *next = NULL;\n\tu64 end = range_end(start, len);\n\n\trb_node = __tree_search(&tree->map, start, &prev, &next);\n\tif (!rb_node) {\n\t\tif (prev)\n\t\t\trb_node = prev;\n\t\telse if (next)\n\t\t\trb_node = next;\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\tem = rb_entry(rb_node, struct extent_map, rb_node);\n\n\tif (strict && !(end > em->start && start < extent_map_end(em)))\n\t\treturn NULL;\n\n\tatomic_inc(&em->refs);\n\treturn em;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstruct extent_map *search_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 0);\n}"
  },
  {
    "function_name": "lookup_extent_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
    "lines": "399-403",
    "snippet": "struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__lookup_extent_mapping",
          "args": [
            "tree",
            "start",
            "len",
            "1"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "359-386",
          "snippet": "static struct extent_map *\n__lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\tu64 start, u64 len, int strict)\n{\n\tstruct extent_map *em;\n\tstruct rb_node *rb_node;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *next = NULL;\n\tu64 end = range_end(start, len);\n\n\trb_node = __tree_search(&tree->map, start, &prev, &next);\n\tif (!rb_node) {\n\t\tif (prev)\n\t\t\trb_node = prev;\n\t\telse if (next)\n\t\t\trb_node = next;\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\tem = rb_entry(rb_node, struct extent_map, rb_node);\n\n\tif (strict && !(end > em->start && start < extent_map_end(em)))\n\t\treturn NULL;\n\n\tatomic_inc(&em->refs);\n\treturn em;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct extent_map *\n__lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\tu64 start, u64 len, int strict)\n{\n\tstruct extent_map *em;\n\tstruct rb_node *rb_node;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *next = NULL;\n\tu64 end = range_end(start, len);\n\n\trb_node = __tree_search(&tree->map, start, &prev, &next);\n\tif (!rb_node) {\n\t\tif (prev)\n\t\t\trb_node = prev;\n\t\telse if (next)\n\t\t\trb_node = next;\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\tem = rb_entry(rb_node, struct extent_map, rb_node);\n\n\tif (strict && !(end > em->start && start < extent_map_end(em)))\n\t\treturn NULL;\n\n\tatomic_inc(&em->refs);\n\treturn em;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstruct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}"
  },
  {
    "function_name": "__lookup_extent_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
    "lines": "359-386",
    "snippet": "static struct extent_map *\n__lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\tu64 start, u64 len, int strict)\n{\n\tstruct extent_map *em;\n\tstruct rb_node *rb_node;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *next = NULL;\n\tu64 end = range_end(start, len);\n\n\trb_node = __tree_search(&tree->map, start, &prev, &next);\n\tif (!rb_node) {\n\t\tif (prev)\n\t\t\trb_node = prev;\n\t\telse if (next)\n\t\t\trb_node = next;\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\tem = rb_entry(rb_node, struct extent_map, rb_node);\n\n\tif (strict && !(end > em->start && start < extent_map_end(em)))\n\t\treturn NULL;\n\n\tatomic_inc(&em->refs);\n\treturn em;\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&em->refs"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_map_end",
          "args": [
            "em"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "extent_map_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.h",
          "lines": "52-57",
          "snippet": "static inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_node",
            "structextent_map",
            "rb_node"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__tree_search",
          "args": [
            "&tree->map",
            "start",
            "&prev",
            "&next"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "__tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "140-182",
          "snippet": "static struct rb_node *__tree_search(struct rb_root *root, u64 offset,\n\t\t\t\t     struct rb_node **prev_ret,\n\t\t\t\t     struct rb_node **next_ret)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *orig_prev = NULL;\n\tstruct extent_map *entry;\n\tstruct extent_map *prev_entry = NULL;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct extent_map, rb_node);\n\t\tprev = n;\n\t\tprev_entry = entry;\n\n\t\tif (offset < entry->start)\n\t\t\tn = n->rb_left;\n\t\telse if (offset >= extent_map_end(entry))\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn n;\n\t}\n\n\tif (prev_ret) {\n\t\torig_prev = prev;\n\t\twhile (prev && offset >= extent_map_end(prev_entry)) {\n\t\t\tprev = rb_next(prev);\n\t\t\tprev_entry = rb_entry(prev, struct extent_map, rb_node);\n\t\t}\n\t\t*prev_ret = prev;\n\t\tprev = orig_prev;\n\t}\n\n\tif (next_ret) {\n\t\tprev_entry = rb_entry(prev, struct extent_map, rb_node);\n\t\twhile (prev && offset < prev_entry->start) {\n\t\t\tprev = rb_prev(prev);\n\t\t\tprev_entry = rb_entry(prev, struct extent_map, rb_node);\n\t\t}\n\t\t*next_ret = prev;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct rb_node *__tree_search(struct rb_root *root, u64 offset,\n\t\t\t\t     struct rb_node **prev_ret,\n\t\t\t\t     struct rb_node **next_ret)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *orig_prev = NULL;\n\tstruct extent_map *entry;\n\tstruct extent_map *prev_entry = NULL;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct extent_map, rb_node);\n\t\tprev = n;\n\t\tprev_entry = entry;\n\n\t\tif (offset < entry->start)\n\t\t\tn = n->rb_left;\n\t\telse if (offset >= extent_map_end(entry))\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn n;\n\t}\n\n\tif (prev_ret) {\n\t\torig_prev = prev;\n\t\twhile (prev && offset >= extent_map_end(prev_entry)) {\n\t\t\tprev = rb_next(prev);\n\t\t\tprev_entry = rb_entry(prev, struct extent_map, rb_node);\n\t\t}\n\t\t*prev_ret = prev;\n\t\tprev = orig_prev;\n\t}\n\n\tif (next_ret) {\n\t\tprev_entry = rb_entry(prev, struct extent_map, rb_node);\n\t\twhile (prev && offset < prev_entry->start) {\n\t\t\tprev = rb_prev(prev);\n\t\t\tprev_entry = rb_entry(prev, struct extent_map, rb_node);\n\t\t}\n\t\t*next_ret = prev;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_end",
          "args": [
            "start",
            "len"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "range_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "85-90",
          "snippet": "static u64 range_end(u64 start, u64 len)\n{\n\tif (start + len < start)\n\t\treturn (u64)-1;\n\treturn start + len;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic u64 range_end(u64 start, u64 len)\n{\n\tif (start + len < start)\n\t\treturn (u64)-1;\n\treturn start + len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct extent_map *\n__lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\tu64 start, u64 len, int strict)\n{\n\tstruct extent_map *em;\n\tstruct rb_node *rb_node;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *next = NULL;\n\tu64 end = range_end(start, len);\n\n\trb_node = __tree_search(&tree->map, start, &prev, &next);\n\tif (!rb_node) {\n\t\tif (prev)\n\t\t\trb_node = prev;\n\t\telse if (next)\n\t\t\trb_node = next;\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\tem = rb_entry(rb_node, struct extent_map, rb_node);\n\n\tif (strict && !(end > em->start && start < extent_map_end(em)))\n\t\treturn NULL;\n\n\tatomic_inc(&em->refs);\n\treturn em;\n}"
  },
  {
    "function_name": "add_extent_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
    "lines": "345-357",
    "snippet": "int add_extent_mapping(struct extent_map_tree *tree,\n\t\t       struct extent_map *em, int modified)\n{\n\tint ret = 0;\n\n\tret = tree_insert(&tree->map, em);\n\tif (ret)\n\t\tgoto out;\n\n\tsetup_extent_mapping(tree, em, modified);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setup_extent_mapping",
          "args": [
            "tree",
            "em",
            "modified"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "setup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "321-333",
          "snippet": "static inline void setup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\tstruct extent_map *em,\n\t\t\t\t\tint modified)\n{\n\tatomic_inc(&em->refs);\n\tem->mod_start = em->start;\n\tem->mod_len = em->len;\n\n\tif (modified)\n\t\tlist_move(&em->list, &tree->modified_extents);\n\telse\n\t\ttry_merge_map(tree, em);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic inline void setup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\tstruct extent_map *em,\n\t\t\t\t\tint modified)\n{\n\tatomic_inc(&em->refs);\n\tem->mod_start = em->start;\n\tem->mod_len = em->len;\n\n\tif (modified)\n\t\tlist_move(&em->list, &tree->modified_extents);\n\telse\n\t\ttry_merge_map(tree, em);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_insert",
          "args": [
            "&tree->map",
            "em"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "92-134",
          "snippet": "static int tree_insert(struct rb_root *root, struct extent_map *em)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct extent_map *entry = NULL;\n\tstruct rb_node *orig_parent = NULL;\n\tu64 end = range_end(em->start, em->len);\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct extent_map, rb_node);\n\n\t\tif (em->start < entry->start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (em->start >= extent_map_end(entry))\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\torig_parent = parent;\n\twhile (parent && em->start >= extent_map_end(entry)) {\n\t\tparent = rb_next(parent);\n\t\tentry = rb_entry(parent, struct extent_map, rb_node);\n\t}\n\tif (parent)\n\t\tif (end > entry->start && em->start < extent_map_end(entry))\n\t\t\treturn -EEXIST;\n\n\tparent = orig_parent;\n\tentry = rb_entry(parent, struct extent_map, rb_node);\n\twhile (parent && em->start < entry->start) {\n\t\tparent = rb_prev(parent);\n\t\tentry = rb_entry(parent, struct extent_map, rb_node);\n\t}\n\tif (parent)\n\t\tif (end > entry->start && em->start < extent_map_end(entry))\n\t\t\treturn -EEXIST;\n\n\trb_link_node(&em->rb_node, orig_parent, p);\n\trb_insert_color(&em->rb_node, root);\n\treturn 0;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic int tree_insert(struct rb_root *root, struct extent_map *em)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct extent_map *entry = NULL;\n\tstruct rb_node *orig_parent = NULL;\n\tu64 end = range_end(em->start, em->len);\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct extent_map, rb_node);\n\n\t\tif (em->start < entry->start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (em->start >= extent_map_end(entry))\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\torig_parent = parent;\n\twhile (parent && em->start >= extent_map_end(entry)) {\n\t\tparent = rb_next(parent);\n\t\tentry = rb_entry(parent, struct extent_map, rb_node);\n\t}\n\tif (parent)\n\t\tif (end > entry->start && em->start < extent_map_end(entry))\n\t\t\treturn -EEXIST;\n\n\tparent = orig_parent;\n\tentry = rb_entry(parent, struct extent_map, rb_node);\n\twhile (parent && em->start < entry->start) {\n\t\tparent = rb_prev(parent);\n\t\tentry = rb_entry(parent, struct extent_map, rb_node);\n\t}\n\tif (parent)\n\t\tif (end > entry->start && em->start < extent_map_end(entry))\n\t\t\treturn -EEXIST;\n\n\trb_link_node(&em->rb_node, orig_parent, p);\n\trb_insert_color(&em->rb_node, root);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nint add_extent_mapping(struct extent_map_tree *tree,\n\t\t       struct extent_map *em, int modified)\n{\n\tint ret = 0;\n\n\tret = tree_insert(&tree->map, em);\n\tif (ret)\n\t\tgoto out;\n\n\tsetup_extent_mapping(tree, em, modified);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "setup_extent_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
    "lines": "321-333",
    "snippet": "static inline void setup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\tstruct extent_map *em,\n\t\t\t\t\tint modified)\n{\n\tatomic_inc(&em->refs);\n\tem->mod_start = em->start;\n\tem->mod_len = em->len;\n\n\tif (modified)\n\t\tlist_move(&em->list, &tree->modified_extents);\n\telse\n\t\ttry_merge_map(tree, em);\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_merge_map",
          "args": [
            "tree",
            "em"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "try_merge_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "225-262",
          "snippet": "static void try_merge_map(struct extent_map_tree *tree, struct extent_map *em)\n{\n\tstruct extent_map *merge = NULL;\n\tstruct rb_node *rb;\n\n\tif (em->start != 0) {\n\t\trb = rb_prev(&em->rb_node);\n\t\tif (rb)\n\t\t\tmerge = rb_entry(rb, struct extent_map, rb_node);\n\t\tif (rb && mergable_maps(merge, em)) {\n\t\t\tem->start = merge->start;\n\t\t\tem->orig_start = merge->orig_start;\n\t\t\tem->len += merge->len;\n\t\t\tem->block_len += merge->block_len;\n\t\t\tem->block_start = merge->block_start;\n\t\t\tem->mod_len = (em->mod_len + em->mod_start) - merge->mod_start;\n\t\t\tem->mod_start = merge->mod_start;\n\t\t\tem->generation = max(em->generation, merge->generation);\n\n\t\t\trb_erase(&merge->rb_node, &tree->map);\n\t\t\tRB_CLEAR_NODE(&merge->rb_node);\n\t\t\tfree_extent_map(merge);\n\t\t}\n\t}\n\n\trb = rb_next(&em->rb_node);\n\tif (rb)\n\t\tmerge = rb_entry(rb, struct extent_map, rb_node);\n\tif (rb && mergable_maps(em, merge)) {\n\t\tem->len += merge->len;\n\t\tem->block_len += merge->block_len;\n\t\trb_erase(&merge->rb_node, &tree->map);\n\t\tRB_CLEAR_NODE(&merge->rb_node);\n\t\tem->mod_len = (merge->mod_start + merge->mod_len) - em->mod_start;\n\t\tem->generation = max(em->generation, merge->generation);\n\t\tfree_extent_map(merge);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic void try_merge_map(struct extent_map_tree *tree, struct extent_map *em)\n{\n\tstruct extent_map *merge = NULL;\n\tstruct rb_node *rb;\n\n\tif (em->start != 0) {\n\t\trb = rb_prev(&em->rb_node);\n\t\tif (rb)\n\t\t\tmerge = rb_entry(rb, struct extent_map, rb_node);\n\t\tif (rb && mergable_maps(merge, em)) {\n\t\t\tem->start = merge->start;\n\t\t\tem->orig_start = merge->orig_start;\n\t\t\tem->len += merge->len;\n\t\t\tem->block_len += merge->block_len;\n\t\t\tem->block_start = merge->block_start;\n\t\t\tem->mod_len = (em->mod_len + em->mod_start) - merge->mod_start;\n\t\t\tem->mod_start = merge->mod_start;\n\t\t\tem->generation = max(em->generation, merge->generation);\n\n\t\t\trb_erase(&merge->rb_node, &tree->map);\n\t\t\tRB_CLEAR_NODE(&merge->rb_node);\n\t\t\tfree_extent_map(merge);\n\t\t}\n\t}\n\n\trb = rb_next(&em->rb_node);\n\tif (rb)\n\t\tmerge = rb_entry(rb, struct extent_map, rb_node);\n\tif (rb && mergable_maps(em, merge)) {\n\t\tem->len += merge->len;\n\t\tem->block_len += merge->block_len;\n\t\trb_erase(&merge->rb_node, &tree->map);\n\t\tRB_CLEAR_NODE(&merge->rb_node);\n\t\tem->mod_len = (merge->mod_start + merge->mod_len) - em->mod_start;\n\t\tem->generation = max(em->generation, merge->generation);\n\t\tfree_extent_map(merge);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&em->list",
            "&tree->modified_extents"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&em->refs"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic inline void setup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\tstruct extent_map *em,\n\t\t\t\t\tint modified)\n{\n\tatomic_inc(&em->refs);\n\tem->mod_start = em->start;\n\tem->mod_len = em->len;\n\n\tif (modified)\n\t\tlist_move(&em->list, &tree->modified_extents);\n\telse\n\t\ttry_merge_map(tree, em);\n}"
  },
  {
    "function_name": "clear_em_logging",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
    "lines": "314-319",
    "snippet": "void clear_em_logging(struct extent_map_tree *tree, struct extent_map *em)\n{\n\tclear_bit(EXTENT_FLAG_LOGGING, &em->flags);\n\tif (extent_map_in_tree(em))\n\t\ttry_merge_map(tree, em);\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_merge_map",
          "args": [
            "tree",
            "em"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "try_merge_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "225-262",
          "snippet": "static void try_merge_map(struct extent_map_tree *tree, struct extent_map *em)\n{\n\tstruct extent_map *merge = NULL;\n\tstruct rb_node *rb;\n\n\tif (em->start != 0) {\n\t\trb = rb_prev(&em->rb_node);\n\t\tif (rb)\n\t\t\tmerge = rb_entry(rb, struct extent_map, rb_node);\n\t\tif (rb && mergable_maps(merge, em)) {\n\t\t\tem->start = merge->start;\n\t\t\tem->orig_start = merge->orig_start;\n\t\t\tem->len += merge->len;\n\t\t\tem->block_len += merge->block_len;\n\t\t\tem->block_start = merge->block_start;\n\t\t\tem->mod_len = (em->mod_len + em->mod_start) - merge->mod_start;\n\t\t\tem->mod_start = merge->mod_start;\n\t\t\tem->generation = max(em->generation, merge->generation);\n\n\t\t\trb_erase(&merge->rb_node, &tree->map);\n\t\t\tRB_CLEAR_NODE(&merge->rb_node);\n\t\t\tfree_extent_map(merge);\n\t\t}\n\t}\n\n\trb = rb_next(&em->rb_node);\n\tif (rb)\n\t\tmerge = rb_entry(rb, struct extent_map, rb_node);\n\tif (rb && mergable_maps(em, merge)) {\n\t\tem->len += merge->len;\n\t\tem->block_len += merge->block_len;\n\t\trb_erase(&merge->rb_node, &tree->map);\n\t\tRB_CLEAR_NODE(&merge->rb_node);\n\t\tem->mod_len = (merge->mod_start + merge->mod_len) - em->mod_start;\n\t\tem->generation = max(em->generation, merge->generation);\n\t\tfree_extent_map(merge);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic void try_merge_map(struct extent_map_tree *tree, struct extent_map *em)\n{\n\tstruct extent_map *merge = NULL;\n\tstruct rb_node *rb;\n\n\tif (em->start != 0) {\n\t\trb = rb_prev(&em->rb_node);\n\t\tif (rb)\n\t\t\tmerge = rb_entry(rb, struct extent_map, rb_node);\n\t\tif (rb && mergable_maps(merge, em)) {\n\t\t\tem->start = merge->start;\n\t\t\tem->orig_start = merge->orig_start;\n\t\t\tem->len += merge->len;\n\t\t\tem->block_len += merge->block_len;\n\t\t\tem->block_start = merge->block_start;\n\t\t\tem->mod_len = (em->mod_len + em->mod_start) - merge->mod_start;\n\t\t\tem->mod_start = merge->mod_start;\n\t\t\tem->generation = max(em->generation, merge->generation);\n\n\t\t\trb_erase(&merge->rb_node, &tree->map);\n\t\t\tRB_CLEAR_NODE(&merge->rb_node);\n\t\t\tfree_extent_map(merge);\n\t\t}\n\t}\n\n\trb = rb_next(&em->rb_node);\n\tif (rb)\n\t\tmerge = rb_entry(rb, struct extent_map, rb_node);\n\tif (rb && mergable_maps(em, merge)) {\n\t\tem->len += merge->len;\n\t\tem->block_len += merge->block_len;\n\t\trb_erase(&merge->rb_node, &tree->map);\n\t\tRB_CLEAR_NODE(&merge->rb_node);\n\t\tem->mod_len = (merge->mod_start + merge->mod_len) - em->mod_start;\n\t\tem->generation = max(em->generation, merge->generation);\n\t\tfree_extent_map(merge);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_map_in_tree",
          "args": [
            "em"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "extent_map_in_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.h",
          "lines": "47-50",
          "snippet": "static inline int extent_map_in_tree(const struct extent_map *em)\n{\n\treturn !RB_EMPTY_NODE(&em->rb_node);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline int extent_map_in_tree(const struct extent_map *em)\n{\n\treturn !RB_EMPTY_NODE(&em->rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EXTENT_FLAG_LOGGING",
            "&em->flags"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nvoid clear_em_logging(struct extent_map_tree *tree, struct extent_map *em)\n{\n\tclear_bit(EXTENT_FLAG_LOGGING, &em->flags);\n\tif (extent_map_in_tree(em))\n\t\ttry_merge_map(tree, em);\n}"
  },
  {
    "function_name": "unpin_extent_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
    "lines": "275-312",
    "snippet": "int unpin_extent_cache(struct extent_map_tree *tree, u64 start, u64 len,\n\t\t       u64 gen)\n{\n\tint ret = 0;\n\tstruct extent_map *em;\n\tbool prealloc = false;\n\n\twrite_lock(&tree->lock);\n\tem = lookup_extent_mapping(tree, start, len);\n\n\tWARN_ON(!em || em->start != start);\n\n\tif (!em)\n\t\tgoto out;\n\n\tem->generation = gen;\n\tclear_bit(EXTENT_FLAG_PINNED, &em->flags);\n\tem->mod_start = em->start;\n\tem->mod_len = em->len;\n\n\tif (test_bit(EXTENT_FLAG_FILLING, &em->flags)) {\n\t\tprealloc = true;\n\t\tclear_bit(EXTENT_FLAG_FILLING, &em->flags);\n\t}\n\n\ttry_merge_map(tree, em);\n\n\tif (prealloc) {\n\t\tem->mod_start = em->start;\n\t\tem->mod_len = em->len;\n\t}\n\n\tfree_extent_map(em);\nout:\n\twrite_unlock(&tree->lock);\n\treturn ret;\n\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&tree->lock"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_merge_map",
          "args": [
            "tree",
            "em"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "try_merge_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "225-262",
          "snippet": "static void try_merge_map(struct extent_map_tree *tree, struct extent_map *em)\n{\n\tstruct extent_map *merge = NULL;\n\tstruct rb_node *rb;\n\n\tif (em->start != 0) {\n\t\trb = rb_prev(&em->rb_node);\n\t\tif (rb)\n\t\t\tmerge = rb_entry(rb, struct extent_map, rb_node);\n\t\tif (rb && mergable_maps(merge, em)) {\n\t\t\tem->start = merge->start;\n\t\t\tem->orig_start = merge->orig_start;\n\t\t\tem->len += merge->len;\n\t\t\tem->block_len += merge->block_len;\n\t\t\tem->block_start = merge->block_start;\n\t\t\tem->mod_len = (em->mod_len + em->mod_start) - merge->mod_start;\n\t\t\tem->mod_start = merge->mod_start;\n\t\t\tem->generation = max(em->generation, merge->generation);\n\n\t\t\trb_erase(&merge->rb_node, &tree->map);\n\t\t\tRB_CLEAR_NODE(&merge->rb_node);\n\t\t\tfree_extent_map(merge);\n\t\t}\n\t}\n\n\trb = rb_next(&em->rb_node);\n\tif (rb)\n\t\tmerge = rb_entry(rb, struct extent_map, rb_node);\n\tif (rb && mergable_maps(em, merge)) {\n\t\tem->len += merge->len;\n\t\tem->block_len += merge->block_len;\n\t\trb_erase(&merge->rb_node, &tree->map);\n\t\tRB_CLEAR_NODE(&merge->rb_node);\n\t\tem->mod_len = (merge->mod_start + merge->mod_len) - em->mod_start;\n\t\tem->generation = max(em->generation, merge->generation);\n\t\tfree_extent_map(merge);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic void try_merge_map(struct extent_map_tree *tree, struct extent_map *em)\n{\n\tstruct extent_map *merge = NULL;\n\tstruct rb_node *rb;\n\n\tif (em->start != 0) {\n\t\trb = rb_prev(&em->rb_node);\n\t\tif (rb)\n\t\t\tmerge = rb_entry(rb, struct extent_map, rb_node);\n\t\tif (rb && mergable_maps(merge, em)) {\n\t\t\tem->start = merge->start;\n\t\t\tem->orig_start = merge->orig_start;\n\t\t\tem->len += merge->len;\n\t\t\tem->block_len += merge->block_len;\n\t\t\tem->block_start = merge->block_start;\n\t\t\tem->mod_len = (em->mod_len + em->mod_start) - merge->mod_start;\n\t\t\tem->mod_start = merge->mod_start;\n\t\t\tem->generation = max(em->generation, merge->generation);\n\n\t\t\trb_erase(&merge->rb_node, &tree->map);\n\t\t\tRB_CLEAR_NODE(&merge->rb_node);\n\t\t\tfree_extent_map(merge);\n\t\t}\n\t}\n\n\trb = rb_next(&em->rb_node);\n\tif (rb)\n\t\tmerge = rb_entry(rb, struct extent_map, rb_node);\n\tif (rb && mergable_maps(em, merge)) {\n\t\tem->len += merge->len;\n\t\tem->block_len += merge->block_len;\n\t\trb_erase(&merge->rb_node, &tree->map);\n\t\tRB_CLEAR_NODE(&merge->rb_node);\n\t\tem->mod_len = (merge->mod_start + merge->mod_len) - em->mod_start;\n\t\tem->generation = max(em->generation, merge->generation);\n\t\tfree_extent_map(merge);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EXTENT_FLAG_FILLING",
            "&em->flags"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_FLAG_FILLING",
            "&em->flags"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!em || em->start != start"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_extent_mapping",
          "args": [
            "tree",
            "start",
            "len"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "399-403",
          "snippet": "struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstruct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&tree->lock"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "345-348",
          "snippet": "static inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nint unpin_extent_cache(struct extent_map_tree *tree, u64 start, u64 len,\n\t\t       u64 gen)\n{\n\tint ret = 0;\n\tstruct extent_map *em;\n\tbool prealloc = false;\n\n\twrite_lock(&tree->lock);\n\tem = lookup_extent_mapping(tree, start, len);\n\n\tWARN_ON(!em || em->start != start);\n\n\tif (!em)\n\t\tgoto out;\n\n\tem->generation = gen;\n\tclear_bit(EXTENT_FLAG_PINNED, &em->flags);\n\tem->mod_start = em->start;\n\tem->mod_len = em->len;\n\n\tif (test_bit(EXTENT_FLAG_FILLING, &em->flags)) {\n\t\tprealloc = true;\n\t\tclear_bit(EXTENT_FLAG_FILLING, &em->flags);\n\t}\n\n\ttry_merge_map(tree, em);\n\n\tif (prealloc) {\n\t\tem->mod_start = em->start;\n\t\tem->mod_len = em->len;\n\t}\n\n\tfree_extent_map(em);\nout:\n\twrite_unlock(&tree->lock);\n\treturn ret;\n\n}"
  },
  {
    "function_name": "try_merge_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
    "lines": "225-262",
    "snippet": "static void try_merge_map(struct extent_map_tree *tree, struct extent_map *em)\n{\n\tstruct extent_map *merge = NULL;\n\tstruct rb_node *rb;\n\n\tif (em->start != 0) {\n\t\trb = rb_prev(&em->rb_node);\n\t\tif (rb)\n\t\t\tmerge = rb_entry(rb, struct extent_map, rb_node);\n\t\tif (rb && mergable_maps(merge, em)) {\n\t\t\tem->start = merge->start;\n\t\t\tem->orig_start = merge->orig_start;\n\t\t\tem->len += merge->len;\n\t\t\tem->block_len += merge->block_len;\n\t\t\tem->block_start = merge->block_start;\n\t\t\tem->mod_len = (em->mod_len + em->mod_start) - merge->mod_start;\n\t\t\tem->mod_start = merge->mod_start;\n\t\t\tem->generation = max(em->generation, merge->generation);\n\n\t\t\trb_erase(&merge->rb_node, &tree->map);\n\t\t\tRB_CLEAR_NODE(&merge->rb_node);\n\t\t\tfree_extent_map(merge);\n\t\t}\n\t}\n\n\trb = rb_next(&em->rb_node);\n\tif (rb)\n\t\tmerge = rb_entry(rb, struct extent_map, rb_node);\n\tif (rb && mergable_maps(em, merge)) {\n\t\tem->len += merge->len;\n\t\tem->block_len += merge->block_len;\n\t\trb_erase(&merge->rb_node, &tree->map);\n\t\tRB_CLEAR_NODE(&merge->rb_node);\n\t\tem->mod_len = (merge->mod_start + merge->mod_len) - em->mod_start;\n\t\tem->generation = max(em->generation, merge->generation);\n\t\tfree_extent_map(merge);\n\t}\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "merge"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "em->generation",
            "merge->generation"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_workqueue_set_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "353-360",
          "snippet": "void btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&merge->rb_node"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&merge->rb_node",
            "&tree->map"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mergable_maps",
          "args": [
            "em",
            "merge"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "mergable_maps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "185-223",
          "snippet": "static int mergable_maps(struct extent_map *prev, struct extent_map *next)\n{\n\tif (test_bit(EXTENT_FLAG_PINNED, &prev->flags))\n\t\treturn 0;\n\n\t/*\n\t * don't merge compressed extents, we need to know their\n\t * actual size\n\t */\n\tif (test_bit(EXTENT_FLAG_COMPRESSED, &prev->flags))\n\t\treturn 0;\n\n\tif (test_bit(EXTENT_FLAG_LOGGING, &prev->flags) ||\n\t    test_bit(EXTENT_FLAG_LOGGING, &next->flags))\n\t\treturn 0;\n\n\t/*\n\t * We don't want to merge stuff that hasn't been written to the log yet\n\t * since it may not reflect exactly what is on disk, and that would be\n\t * bad.\n\t */\n\tif (!list_empty(&prev->list) || !list_empty(&next->list))\n\t\treturn 0;\n\n\tif (extent_map_end(prev) == next->start &&\n\t    prev->flags == next->flags &&\n\t    prev->bdev == next->bdev &&\n\t    ((next->block_start == EXTENT_MAP_HOLE &&\n\t      prev->block_start == EXTENT_MAP_HOLE) ||\n\t     (next->block_start == EXTENT_MAP_INLINE &&\n\t      prev->block_start == EXTENT_MAP_INLINE) ||\n\t     (next->block_start == EXTENT_MAP_DELALLOC &&\n\t      prev->block_start == EXTENT_MAP_DELALLOC) ||\n\t     (next->block_start < EXTENT_MAP_LAST_BYTE - 1 &&\n\t      next->block_start == extent_map_block_end(prev)))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic int mergable_maps(struct extent_map *prev, struct extent_map *next)\n{\n\tif (test_bit(EXTENT_FLAG_PINNED, &prev->flags))\n\t\treturn 0;\n\n\t/*\n\t * don't merge compressed extents, we need to know their\n\t * actual size\n\t */\n\tif (test_bit(EXTENT_FLAG_COMPRESSED, &prev->flags))\n\t\treturn 0;\n\n\tif (test_bit(EXTENT_FLAG_LOGGING, &prev->flags) ||\n\t    test_bit(EXTENT_FLAG_LOGGING, &next->flags))\n\t\treturn 0;\n\n\t/*\n\t * We don't want to merge stuff that hasn't been written to the log yet\n\t * since it may not reflect exactly what is on disk, and that would be\n\t * bad.\n\t */\n\tif (!list_empty(&prev->list) || !list_empty(&next->list))\n\t\treturn 0;\n\n\tif (extent_map_end(prev) == next->start &&\n\t    prev->flags == next->flags &&\n\t    prev->bdev == next->bdev &&\n\t    ((next->block_start == EXTENT_MAP_HOLE &&\n\t      prev->block_start == EXTENT_MAP_HOLE) ||\n\t     (next->block_start == EXTENT_MAP_INLINE &&\n\t      prev->block_start == EXTENT_MAP_INLINE) ||\n\t     (next->block_start == EXTENT_MAP_DELALLOC &&\n\t      prev->block_start == EXTENT_MAP_DELALLOC) ||\n\t     (next->block_start < EXTENT_MAP_LAST_BYTE - 1 &&\n\t      next->block_start == extent_map_block_end(prev)))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb",
            "structextent_map",
            "rb_node"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&em->rb_node"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&merge->rb_node"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&merge->rb_node",
            "&tree->map"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb",
            "structextent_map",
            "rb_node"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "&em->rb_node"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic void try_merge_map(struct extent_map_tree *tree, struct extent_map *em)\n{\n\tstruct extent_map *merge = NULL;\n\tstruct rb_node *rb;\n\n\tif (em->start != 0) {\n\t\trb = rb_prev(&em->rb_node);\n\t\tif (rb)\n\t\t\tmerge = rb_entry(rb, struct extent_map, rb_node);\n\t\tif (rb && mergable_maps(merge, em)) {\n\t\t\tem->start = merge->start;\n\t\t\tem->orig_start = merge->orig_start;\n\t\t\tem->len += merge->len;\n\t\t\tem->block_len += merge->block_len;\n\t\t\tem->block_start = merge->block_start;\n\t\t\tem->mod_len = (em->mod_len + em->mod_start) - merge->mod_start;\n\t\t\tem->mod_start = merge->mod_start;\n\t\t\tem->generation = max(em->generation, merge->generation);\n\n\t\t\trb_erase(&merge->rb_node, &tree->map);\n\t\t\tRB_CLEAR_NODE(&merge->rb_node);\n\t\t\tfree_extent_map(merge);\n\t\t}\n\t}\n\n\trb = rb_next(&em->rb_node);\n\tif (rb)\n\t\tmerge = rb_entry(rb, struct extent_map, rb_node);\n\tif (rb && mergable_maps(em, merge)) {\n\t\tem->len += merge->len;\n\t\tem->block_len += merge->block_len;\n\t\trb_erase(&merge->rb_node, &tree->map);\n\t\tRB_CLEAR_NODE(&merge->rb_node);\n\t\tem->mod_len = (merge->mod_start + merge->mod_len) - em->mod_start;\n\t\tem->generation = max(em->generation, merge->generation);\n\t\tfree_extent_map(merge);\n\t}\n}"
  },
  {
    "function_name": "mergable_maps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
    "lines": "185-223",
    "snippet": "static int mergable_maps(struct extent_map *prev, struct extent_map *next)\n{\n\tif (test_bit(EXTENT_FLAG_PINNED, &prev->flags))\n\t\treturn 0;\n\n\t/*\n\t * don't merge compressed extents, we need to know their\n\t * actual size\n\t */\n\tif (test_bit(EXTENT_FLAG_COMPRESSED, &prev->flags))\n\t\treturn 0;\n\n\tif (test_bit(EXTENT_FLAG_LOGGING, &prev->flags) ||\n\t    test_bit(EXTENT_FLAG_LOGGING, &next->flags))\n\t\treturn 0;\n\n\t/*\n\t * We don't want to merge stuff that hasn't been written to the log yet\n\t * since it may not reflect exactly what is on disk, and that would be\n\t * bad.\n\t */\n\tif (!list_empty(&prev->list) || !list_empty(&next->list))\n\t\treturn 0;\n\n\tif (extent_map_end(prev) == next->start &&\n\t    prev->flags == next->flags &&\n\t    prev->bdev == next->bdev &&\n\t    ((next->block_start == EXTENT_MAP_HOLE &&\n\t      prev->block_start == EXTENT_MAP_HOLE) ||\n\t     (next->block_start == EXTENT_MAP_INLINE &&\n\t      prev->block_start == EXTENT_MAP_INLINE) ||\n\t     (next->block_start == EXTENT_MAP_DELALLOC &&\n\t      prev->block_start == EXTENT_MAP_DELALLOC) ||\n\t     (next->block_start < EXTENT_MAP_LAST_BYTE - 1 &&\n\t      next->block_start == extent_map_block_end(prev)))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "extent_map_block_end",
          "args": [
            "prev"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "extent_map_block_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.h",
          "lines": "59-64",
          "snippet": "static inline u64 extent_map_block_end(struct extent_map *em)\n{\n\tif (em->block_start + em->block_len < em->block_start)\n\t\treturn (u64)-1;\n\treturn em->block_start + em->block_len;\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline u64 extent_map_block_end(struct extent_map *em)\n{\n\tif (em->block_start + em->block_len < em->block_start)\n\t\treturn (u64)-1;\n\treturn em->block_start + em->block_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_map_end",
          "args": [
            "prev"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "extent_map_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.h",
          "lines": "52-57",
          "snippet": "static inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&next->list"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_FLAG_LOGGING",
            "&next->flags"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic int mergable_maps(struct extent_map *prev, struct extent_map *next)\n{\n\tif (test_bit(EXTENT_FLAG_PINNED, &prev->flags))\n\t\treturn 0;\n\n\t/*\n\t * don't merge compressed extents, we need to know their\n\t * actual size\n\t */\n\tif (test_bit(EXTENT_FLAG_COMPRESSED, &prev->flags))\n\t\treturn 0;\n\n\tif (test_bit(EXTENT_FLAG_LOGGING, &prev->flags) ||\n\t    test_bit(EXTENT_FLAG_LOGGING, &next->flags))\n\t\treturn 0;\n\n\t/*\n\t * We don't want to merge stuff that hasn't been written to the log yet\n\t * since it may not reflect exactly what is on disk, and that would be\n\t * bad.\n\t */\n\tif (!list_empty(&prev->list) || !list_empty(&next->list))\n\t\treturn 0;\n\n\tif (extent_map_end(prev) == next->start &&\n\t    prev->flags == next->flags &&\n\t    prev->bdev == next->bdev &&\n\t    ((next->block_start == EXTENT_MAP_HOLE &&\n\t      prev->block_start == EXTENT_MAP_HOLE) ||\n\t     (next->block_start == EXTENT_MAP_INLINE &&\n\t      prev->block_start == EXTENT_MAP_INLINE) ||\n\t     (next->block_start == EXTENT_MAP_DELALLOC &&\n\t      prev->block_start == EXTENT_MAP_DELALLOC) ||\n\t     (next->block_start < EXTENT_MAP_LAST_BYTE - 1 &&\n\t      next->block_start == extent_map_block_end(prev)))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "__tree_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
    "lines": "140-182",
    "snippet": "static struct rb_node *__tree_search(struct rb_root *root, u64 offset,\n\t\t\t\t     struct rb_node **prev_ret,\n\t\t\t\t     struct rb_node **next_ret)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *orig_prev = NULL;\n\tstruct extent_map *entry;\n\tstruct extent_map *prev_entry = NULL;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct extent_map, rb_node);\n\t\tprev = n;\n\t\tprev_entry = entry;\n\n\t\tif (offset < entry->start)\n\t\t\tn = n->rb_left;\n\t\telse if (offset >= extent_map_end(entry))\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn n;\n\t}\n\n\tif (prev_ret) {\n\t\torig_prev = prev;\n\t\twhile (prev && offset >= extent_map_end(prev_entry)) {\n\t\t\tprev = rb_next(prev);\n\t\t\tprev_entry = rb_entry(prev, struct extent_map, rb_node);\n\t\t}\n\t\t*prev_ret = prev;\n\t\tprev = orig_prev;\n\t}\n\n\tif (next_ret) {\n\t\tprev_entry = rb_entry(prev, struct extent_map, rb_node);\n\t\twhile (prev && offset < prev_entry->start) {\n\t\t\tprev = rb_prev(prev);\n\t\t\tprev_entry = rb_entry(prev, struct extent_map, rb_node);\n\t\t}\n\t\t*next_ret = prev;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "prev",
            "structextent_map",
            "rb_node"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "prev"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "prev",
            "structextent_map",
            "rb_node"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "prev",
            "structextent_map",
            "rb_node"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "prev"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_map_end",
          "args": [
            "prev_entry"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "extent_map_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.h",
          "lines": "52-57",
          "snippet": "static inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structextent_map",
            "rb_node"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct rb_node *__tree_search(struct rb_root *root, u64 offset,\n\t\t\t\t     struct rb_node **prev_ret,\n\t\t\t\t     struct rb_node **next_ret)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *orig_prev = NULL;\n\tstruct extent_map *entry;\n\tstruct extent_map *prev_entry = NULL;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct extent_map, rb_node);\n\t\tprev = n;\n\t\tprev_entry = entry;\n\n\t\tif (offset < entry->start)\n\t\t\tn = n->rb_left;\n\t\telse if (offset >= extent_map_end(entry))\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn n;\n\t}\n\n\tif (prev_ret) {\n\t\torig_prev = prev;\n\t\twhile (prev && offset >= extent_map_end(prev_entry)) {\n\t\t\tprev = rb_next(prev);\n\t\t\tprev_entry = rb_entry(prev, struct extent_map, rb_node);\n\t\t}\n\t\t*prev_ret = prev;\n\t\tprev = orig_prev;\n\t}\n\n\tif (next_ret) {\n\t\tprev_entry = rb_entry(prev, struct extent_map, rb_node);\n\t\twhile (prev && offset < prev_entry->start) {\n\t\t\tprev = rb_prev(prev);\n\t\t\tprev_entry = rb_entry(prev, struct extent_map, rb_node);\n\t\t}\n\t\t*next_ret = prev;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "tree_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
    "lines": "92-134",
    "snippet": "static int tree_insert(struct rb_root *root, struct extent_map *em)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct extent_map *entry = NULL;\n\tstruct rb_node *orig_parent = NULL;\n\tu64 end = range_end(em->start, em->len);\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct extent_map, rb_node);\n\n\t\tif (em->start < entry->start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (em->start >= extent_map_end(entry))\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\torig_parent = parent;\n\twhile (parent && em->start >= extent_map_end(entry)) {\n\t\tparent = rb_next(parent);\n\t\tentry = rb_entry(parent, struct extent_map, rb_node);\n\t}\n\tif (parent)\n\t\tif (end > entry->start && em->start < extent_map_end(entry))\n\t\t\treturn -EEXIST;\n\n\tparent = orig_parent;\n\tentry = rb_entry(parent, struct extent_map, rb_node);\n\twhile (parent && em->start < entry->start) {\n\t\tparent = rb_prev(parent);\n\t\tentry = rb_entry(parent, struct extent_map, rb_node);\n\t}\n\tif (parent)\n\t\tif (end > entry->start && em->start < extent_map_end(entry))\n\t\t\treturn -EEXIST;\n\n\trb_link_node(&em->rb_node, orig_parent, p);\n\trb_insert_color(&em->rb_node, root);\n\treturn 0;\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&em->rb_node",
            "root"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&em->rb_node",
            "orig_parent",
            "p"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_map_end",
          "args": [
            "entry"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "extent_map_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.h",
          "lines": "52-57",
          "snippet": "static inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structextent_map",
            "rb_node"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "parent"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structextent_map",
            "rb_node"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structextent_map",
            "rb_node"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "parent"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structextent_map",
            "rb_node"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_end",
          "args": [
            "em->start",
            "em->len"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "range_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "85-90",
          "snippet": "static u64 range_end(u64 start, u64 len)\n{\n\tif (start + len < start)\n\t\treturn (u64)-1;\n\treturn start + len;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic u64 range_end(u64 start, u64 len)\n{\n\tif (start + len < start)\n\t\treturn (u64)-1;\n\treturn start + len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic int tree_insert(struct rb_root *root, struct extent_map *em)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct extent_map *entry = NULL;\n\tstruct rb_node *orig_parent = NULL;\n\tu64 end = range_end(em->start, em->len);\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct extent_map, rb_node);\n\n\t\tif (em->start < entry->start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (em->start >= extent_map_end(entry))\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\torig_parent = parent;\n\twhile (parent && em->start >= extent_map_end(entry)) {\n\t\tparent = rb_next(parent);\n\t\tentry = rb_entry(parent, struct extent_map, rb_node);\n\t}\n\tif (parent)\n\t\tif (end > entry->start && em->start < extent_map_end(entry))\n\t\t\treturn -EEXIST;\n\n\tparent = orig_parent;\n\tentry = rb_entry(parent, struct extent_map, rb_node);\n\twhile (parent && em->start < entry->start) {\n\t\tparent = rb_prev(parent);\n\t\tentry = rb_entry(parent, struct extent_map, rb_node);\n\t}\n\tif (parent)\n\t\tif (end > entry->start && em->start < extent_map_end(entry))\n\t\t\treturn -EEXIST;\n\n\trb_link_node(&em->rb_node, orig_parent, p);\n\trb_insert_color(&em->rb_node, root);\n\treturn 0;\n}"
  },
  {
    "function_name": "range_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
    "lines": "85-90",
    "snippet": "static u64 range_end(u64 start, u64 len)\n{\n\tif (start + len < start)\n\t\treturn (u64)-1;\n\treturn start + len;\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic u64 range_end(u64 start, u64 len)\n{\n\tif (start + len < start)\n\t\treturn (u64)-1;\n\treturn start + len;\n}"
  },
  {
    "function_name": "free_extent_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
    "lines": "70-82",
    "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *extent_map_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "extent_map_cache",
            "em"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "em->bdev"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_FLAG_FS_MAPPING",
            "&em->flags"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&em->list)"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&em->list"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "extent_map_in_tree(em)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_map_in_tree",
          "args": [
            "em"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "extent_map_in_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.h",
          "lines": "47-50",
          "snippet": "static inline int extent_map_in_tree(const struct extent_map *em)\n{\n\treturn !RB_EMPTY_NODE(&em->rb_node);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline int extent_map_in_tree(const struct extent_map *em)\n{\n\treturn !RB_EMPTY_NODE(&em->rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&em->refs"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_read(&em->refs) == 0"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&em->refs"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
  },
  {
    "function_name": "alloc_extent_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
    "lines": "48-61",
    "snippet": "struct extent_map *alloc_extent_map(void)\n{\n\tstruct extent_map *em;\n\tem = kmem_cache_zalloc(extent_map_cache, GFP_NOFS);\n\tif (!em)\n\t\treturn NULL;\n\tRB_CLEAR_NODE(&em->rb_node);\n\tem->flags = 0;\n\tem->compress_type = BTRFS_COMPRESS_NONE;\n\tem->generation = 0;\n\tatomic_set(&em->refs, 1);\n\tINIT_LIST_HEAD(&em->list);\n\treturn em;\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *extent_map_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&em->list"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&em->refs",
            "1"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&em->rb_node"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "extent_map_cache",
            "GFP_NOFS"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nstruct extent_map *alloc_extent_map(void)\n{\n\tstruct extent_map *em;\n\tem = kmem_cache_zalloc(extent_map_cache, GFP_NOFS);\n\tif (!em)\n\t\treturn NULL;\n\tRB_CLEAR_NODE(&em->rb_node);\n\tem->flags = 0;\n\tem->compress_type = BTRFS_COMPRESS_NONE;\n\tem->generation = 0;\n\tatomic_set(&em->refs, 1);\n\tINIT_LIST_HEAD(&em->list);\n\treturn em;\n}"
  },
  {
    "function_name": "extent_map_tree_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
    "lines": "34-39",
    "snippet": "void extent_map_tree_init(struct extent_map_tree *tree)\n{\n\ttree->map = RB_ROOT;\n\tINIT_LIST_HEAD(&tree->modified_extents);\n\trwlock_init(&tree->lock);\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rwlock_init",
          "args": [
            "&tree->lock"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tree->modified_extents"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nvoid extent_map_tree_init(struct extent_map_tree *tree)\n{\n\ttree->map = RB_ROOT;\n\tINIT_LIST_HEAD(&tree->modified_extents);\n\trwlock_init(&tree->lock);\n}"
  },
  {
    "function_name": "extent_map_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
    "lines": "21-25",
    "snippet": "void extent_map_exit(void)\n{\n\tif (extent_map_cache)\n\t\tkmem_cache_destroy(extent_map_cache);\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *extent_map_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "extent_map_cache"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid extent_map_exit(void)\n{\n\tif (extent_map_cache)\n\t\tkmem_cache_destroy(extent_map_cache);\n}"
  },
  {
    "function_name": "extent_map_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
    "lines": "11-19",
    "snippet": "int __init extent_map_init(void)\n{\n\textent_map_cache = kmem_cache_create(\"btrfs_extent_map\",\n\t\t\tsizeof(struct extent_map), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!extent_map_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"ctree.h\"",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *extent_map_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"btrfs_extent_map\"",
            "sizeof(struct extent_map)",
            "0",
            "SLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD",
            "NULL"
          ],
          "line": 13
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nint __init extent_map_init(void)\n{\n\textent_map_cache = kmem_cache_create(\"btrfs_extent_map\",\n\t\t\tsizeof(struct extent_map), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!extent_map_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  }
]