[
  {
    "function_name": "xfs_btree_change_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "4024-4067",
    "snippet": "int\nxfs_btree_change_owner(\n\tstruct xfs_btree_cur\t*cur,\n\t__uint64_t\t\tnew_owner,\n\tstruct list_head\t*buffer_list)\n{\n\tunion xfs_btree_ptr     lptr;\n\tint\t\t\tlevel;\n\tstruct xfs_btree_block\t*block = NULL;\n\tint\t\t\terror = 0;\n\n\tcur->bc_ops->init_ptr_from_cur(cur, &lptr);\n\n\t/* for each level */\n\tfor (level = cur->bc_nlevels - 1; level >= 0; level--) {\n\t\t/* grab the left hand block */\n\t\terror = xfs_btree_lookup_get_block(cur, level, &lptr, &block);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/* readahead the left most block for the next level down */\n\t\tif (level > 0) {\n\t\t\tunion xfs_btree_ptr     *ptr;\n\n\t\t\tptr = xfs_btree_ptr_addr(cur, 1, block);\n\t\t\txfs_btree_readahead_ptr(cur, ptr, 1);\n\n\t\t\t/* save for the next iteration of the loop */\n\t\t\tlptr = *ptr;\n\t\t}\n\n\t\t/* for each buffer in the level */\n\t\tdo {\n\t\t\terror = xfs_btree_block_change_owner(cur, level,\n\t\t\t\t\t\t\t     new_owner,\n\t\t\t\t\t\t\t     buffer_list);\n\t\t} while (!error);\n\n\t\tif (error != -ENOENT)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_block_change_owner",
          "args": [
            "cur",
            "level",
            "new_owner",
            "buffer_list"
          ],
          "line": 4057
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_block_change_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "3976-4022",
          "snippet": "static int\nxfs_btree_block_change_owner(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\t__uint64_t\t\tnew_owner,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_buf\t\t*bp;\n\tunion xfs_btree_ptr     rptr;\n\n\t/* do right sibling readahead */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* modify the owner */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\tblock->bb_u.l.bb_owner = cpu_to_be64(new_owner);\n\telse\n\t\tblock->bb_u.s.bb_owner = cpu_to_be32(new_owner);\n\n\t/*\n\t * If the block is a root block hosted in an inode, we might not have a\n\t * buffer pointer here and we shouldn't attempt to log the change as the\n\t * information is already held in the inode and discarded when the root\n\t * block is formatted into the on-disk inode fork. We still change it,\n\t * though, so everything is consistent in memory.\n\t */\n\tif (bp) {\n\t\tif (cur->bc_tp) {\n\t\t\txfs_trans_ordered_buf(cur->bc_tp, bp);\n\t\t\txfs_btree_log_block(cur, bp, XFS_BB_OWNER);\n\t\t} else {\n\t\t\txfs_buf_delwri_queue(bp, buffer_list);\n\t\t}\n\t} else {\n\t\tASSERT(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE);\n\t\tASSERT(level == cur->bc_nlevels - 1);\n\t}\n\n\t/* now read rh sibling block for next iteration */\n\txfs_btree_get_sibling(cur, block, &rptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &rptr))\n\t\treturn -ENOENT;\n\n\treturn xfs_btree_lookup_get_block(cur, level, &rptr, &block);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nstatic int\nxfs_btree_block_change_owner(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\t__uint64_t\t\tnew_owner,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_buf\t\t*bp;\n\tunion xfs_btree_ptr     rptr;\n\n\t/* do right sibling readahead */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* modify the owner */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\tblock->bb_u.l.bb_owner = cpu_to_be64(new_owner);\n\telse\n\t\tblock->bb_u.s.bb_owner = cpu_to_be32(new_owner);\n\n\t/*\n\t * If the block is a root block hosted in an inode, we might not have a\n\t * buffer pointer here and we shouldn't attempt to log the change as the\n\t * information is already held in the inode and discarded when the root\n\t * block is formatted into the on-disk inode fork. We still change it,\n\t * though, so everything is consistent in memory.\n\t */\n\tif (bp) {\n\t\tif (cur->bc_tp) {\n\t\t\txfs_trans_ordered_buf(cur->bc_tp, bp);\n\t\t\txfs_btree_log_block(cur, bp, XFS_BB_OWNER);\n\t\t} else {\n\t\t\txfs_buf_delwri_queue(bp, buffer_list);\n\t\t}\n\t} else {\n\t\tASSERT(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE);\n\t\tASSERT(level == cur->bc_nlevels - 1);\n\t}\n\n\t/* now read rh sibling block for next iteration */\n\txfs_btree_get_sibling(cur, block, &rptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &rptr))\n\t\treturn -ENOENT;\n\n\treturn xfs_btree_lookup_get_block(cur, level, &rptr, &block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_readahead_ptr",
          "args": [
            "cur",
            "ptr",
            "1"
          ],
          "line": 4049
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_readahead_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "871-880",
          "snippet": "STATIC void\nxfs_btree_readahead_ptr(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\txfs_extlen_t\t\tcount)\n{\n\txfs_buf_readahead(cur->bc_mp->m_ddev_targp,\n\t\t\t  xfs_btree_ptr_to_daddr(cur, ptr),\n\t\t\t  cur->bc_mp->m_bsize * count, cur->bc_ops->buf_ops);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_readahead_ptr(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\txfs_extlen_t\t\tcount)\n{\n\txfs_buf_readahead(cur->bc_mp->m_ddev_targp,\n\t\t\t  xfs_btree_ptr_to_daddr(cur, ptr),\n\t\t\t  cur->bc_mp->m_bsize * count, cur->bc_ops->buf_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_addr",
          "args": [
            "cur",
            "1",
            "block"
          ],
          "line": 4048
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "494-506",
          "snippet": "xfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_lookup_get_block",
          "args": [
            "cur",
            "level",
            "&lptr",
            "&block"
          ],
          "line": 4040
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_lookup_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1633-1668",
          "snippet": "STATIC int\nxfs_btree_lookup_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in the btree */\n\tunion xfs_btree_ptr\t*pp,\t/* ptr to btree block */\n\tstruct xfs_btree_block\t**blkp) /* return btree block */\n{\n\tstruct xfs_buf\t\t*bp;\t/* buffer pointer for btree block */\n\tint\t\t\terror = 0;\n\n\t/* special case the root block if in an inode */\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*blkp = xfs_btree_get_iroot(cur);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the old buffer at this level for the disk address we are\n\t * looking for re-use it.\n\t *\n\t * Otherwise throw it away and get a new one.\n\t */\n\tbp = cur->bc_bufs[level];\n\tif (bp && XFS_BUF_ADDR(bp) == xfs_btree_ptr_to_daddr(cur, pp)) {\n\t\t*blkp = XFS_BUF_TO_BLOCK(bp);\n\t\treturn 0;\n\t}\n\n\terror = xfs_btree_read_buf_block(cur, pp, 0, blkp, &bp);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_setbuf(cur, level, bp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_lookup_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in the btree */\n\tunion xfs_btree_ptr\t*pp,\t/* ptr to btree block */\n\tstruct xfs_btree_block\t**blkp) /* return btree block */\n{\n\tstruct xfs_buf\t\t*bp;\t/* buffer pointer for btree block */\n\tint\t\t\terror = 0;\n\n\t/* special case the root block if in an inode */\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*blkp = xfs_btree_get_iroot(cur);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the old buffer at this level for the disk address we are\n\t * looking for re-use it.\n\t *\n\t * Otherwise throw it away and get a new one.\n\t */\n\tbp = cur->bc_bufs[level];\n\tif (bp && XFS_BUF_ADDR(bp) == xfs_btree_ptr_to_daddr(cur, pp)) {\n\t\t*blkp = XFS_BUF_TO_BLOCK(bp);\n\t\treturn 0;\n\t}\n\n\terror = xfs_btree_read_buf_block(cur, pp, 0, blkp, &bp);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_setbuf(cur, level, bp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->init_ptr_from_cur",
          "args": [
            "cur",
            "&lptr"
          ],
          "line": 4035
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\nxfs_btree_change_owner(\n\tstruct xfs_btree_cur\t*cur,\n\t__uint64_t\t\tnew_owner,\n\tstruct list_head\t*buffer_list)\n{\n\tunion xfs_btree_ptr     lptr;\n\tint\t\t\tlevel;\n\tstruct xfs_btree_block\t*block = NULL;\n\tint\t\t\terror = 0;\n\n\tcur->bc_ops->init_ptr_from_cur(cur, &lptr);\n\n\t/* for each level */\n\tfor (level = cur->bc_nlevels - 1; level >= 0; level--) {\n\t\t/* grab the left hand block */\n\t\terror = xfs_btree_lookup_get_block(cur, level, &lptr, &block);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/* readahead the left most block for the next level down */\n\t\tif (level > 0) {\n\t\t\tunion xfs_btree_ptr     *ptr;\n\n\t\t\tptr = xfs_btree_ptr_addr(cur, 1, block);\n\t\t\txfs_btree_readahead_ptr(cur, ptr, 1);\n\n\t\t\t/* save for the next iteration of the loop */\n\t\t\tlptr = *ptr;\n\t\t}\n\n\t\t/* for each buffer in the level */\n\t\tdo {\n\t\t\terror = xfs_btree_block_change_owner(cur, level,\n\t\t\t\t\t\t\t     new_owner,\n\t\t\t\t\t\t\t     buffer_list);\n\t\t} while (!error);\n\n\t\tif (error != -ENOENT)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_btree_block_change_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "3976-4022",
    "snippet": "static int\nxfs_btree_block_change_owner(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\t__uint64_t\t\tnew_owner,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_buf\t\t*bp;\n\tunion xfs_btree_ptr     rptr;\n\n\t/* do right sibling readahead */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* modify the owner */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\tblock->bb_u.l.bb_owner = cpu_to_be64(new_owner);\n\telse\n\t\tblock->bb_u.s.bb_owner = cpu_to_be32(new_owner);\n\n\t/*\n\t * If the block is a root block hosted in an inode, we might not have a\n\t * buffer pointer here and we shouldn't attempt to log the change as the\n\t * information is already held in the inode and discarded when the root\n\t * block is formatted into the on-disk inode fork. We still change it,\n\t * though, so everything is consistent in memory.\n\t */\n\tif (bp) {\n\t\tif (cur->bc_tp) {\n\t\t\txfs_trans_ordered_buf(cur->bc_tp, bp);\n\t\t\txfs_btree_log_block(cur, bp, XFS_BB_OWNER);\n\t\t} else {\n\t\t\txfs_buf_delwri_queue(bp, buffer_list);\n\t\t}\n\t} else {\n\t\tASSERT(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE);\n\t\tASSERT(level == cur->bc_nlevels - 1);\n\t}\n\n\t/* now read rh sibling block for next iteration */\n\txfs_btree_get_sibling(cur, block, &rptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &rptr))\n\t\treturn -ENOENT;\n\n\treturn xfs_btree_lookup_get_block(cur, level, &rptr, &block);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_lookup_get_block",
          "args": [
            "cur",
            "level",
            "&rptr",
            "&block"
          ],
          "line": 4021
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_lookup_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1633-1668",
          "snippet": "STATIC int\nxfs_btree_lookup_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in the btree */\n\tunion xfs_btree_ptr\t*pp,\t/* ptr to btree block */\n\tstruct xfs_btree_block\t**blkp) /* return btree block */\n{\n\tstruct xfs_buf\t\t*bp;\t/* buffer pointer for btree block */\n\tint\t\t\terror = 0;\n\n\t/* special case the root block if in an inode */\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*blkp = xfs_btree_get_iroot(cur);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the old buffer at this level for the disk address we are\n\t * looking for re-use it.\n\t *\n\t * Otherwise throw it away and get a new one.\n\t */\n\tbp = cur->bc_bufs[level];\n\tif (bp && XFS_BUF_ADDR(bp) == xfs_btree_ptr_to_daddr(cur, pp)) {\n\t\t*blkp = XFS_BUF_TO_BLOCK(bp);\n\t\treturn 0;\n\t}\n\n\terror = xfs_btree_read_buf_block(cur, pp, 0, blkp, &bp);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_setbuf(cur, level, bp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_lookup_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in the btree */\n\tunion xfs_btree_ptr\t*pp,\t/* ptr to btree block */\n\tstruct xfs_btree_block\t**blkp) /* return btree block */\n{\n\tstruct xfs_buf\t\t*bp;\t/* buffer pointer for btree block */\n\tint\t\t\terror = 0;\n\n\t/* special case the root block if in an inode */\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*blkp = xfs_btree_get_iroot(cur);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the old buffer at this level for the disk address we are\n\t * looking for re-use it.\n\t *\n\t * Otherwise throw it away and get a new one.\n\t */\n\tbp = cur->bc_bufs[level];\n\tif (bp && XFS_BUF_ADDR(bp) == xfs_btree_ptr_to_daddr(cur, pp)) {\n\t\t*blkp = XFS_BUF_TO_BLOCK(bp);\n\t\treturn 0;\n\t}\n\n\terror = xfs_btree_read_buf_block(cur, pp, 0, blkp, &bp);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_setbuf(cur, level, bp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_is_null",
          "args": [
            "cur",
            "&rptr"
          ],
          "line": 4018
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_is_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "913-922",
          "snippet": "STATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_sibling",
          "args": [
            "cur",
            "block",
            "&rptr",
            "XFS_BB_RIGHTSIB"
          ],
          "line": 4017
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_sibling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "938-958",
          "snippet": "STATIC void\nxfs_btree_get_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->l = block->bb_u.l.bb_rightsib;\n\t\telse\n\t\t\tptr->l = block->bb_u.l.bb_leftsib;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->s = block->bb_u.s.bb_rightsib;\n\t\telse\n\t\t\tptr->s = block->bb_u.s.bb_leftsib;\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_get_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->l = block->bb_u.l.bb_rightsib;\n\t\telse\n\t\t\tptr->l = block->bb_u.l.bb_leftsib;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->s = block->bb_u.s.bb_rightsib;\n\t\telse\n\t\t\tptr->s = block->bb_u.s.bb_leftsib;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "level == cur->bc_nlevels - 1"
          ],
          "line": 4013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cur->bc_flags & XFS_BTREE_ROOT_IN_INODE"
          ],
          "line": 4012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_delwri_queue",
          "args": [
            "bp",
            "buffer_list"
          ],
          "line": 4009
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_delwri_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1709-1744",
          "snippet": "bool\nxfs_buf_delwri_queue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct list_head\t*list)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\tASSERT(!(bp->b_flags & XBF_READ));\n\n\t/*\n\t * If the buffer is already marked delwri it already is queued up\n\t * by someone else for imediate writeout.  Just ignore it in that\n\t * case.\n\t */\n\tif (bp->b_flags & _XBF_DELWRI_Q) {\n\t\ttrace_xfs_buf_delwri_queued(bp, _RET_IP_);\n\t\treturn false;\n\t}\n\n\ttrace_xfs_buf_delwri_queue(bp, _RET_IP_);\n\n\t/*\n\t * If a buffer gets written out synchronously or marked stale while it\n\t * is on a delwri list we lazily remove it. To do this, the other party\n\t * clears the  _XBF_DELWRI_Q flag but otherwise leaves the buffer alone.\n\t * It remains referenced and on the list.  In a rare corner case it\n\t * might get readded to a delwri list after the synchronous writeout, in\n\t * which case we need just need to re-add the flag here.\n\t */\n\tbp->b_flags |= _XBF_DELWRI_Q;\n\tif (list_empty(&bp->b_list)) {\n\t\tatomic_inc(&bp->b_hold);\n\t\tlist_add_tail(&bp->b_list, list);\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nbool\nxfs_buf_delwri_queue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct list_head\t*list)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\tASSERT(!(bp->b_flags & XBF_READ));\n\n\t/*\n\t * If the buffer is already marked delwri it already is queued up\n\t * by someone else for imediate writeout.  Just ignore it in that\n\t * case.\n\t */\n\tif (bp->b_flags & _XBF_DELWRI_Q) {\n\t\ttrace_xfs_buf_delwri_queued(bp, _RET_IP_);\n\t\treturn false;\n\t}\n\n\ttrace_xfs_buf_delwri_queue(bp, _RET_IP_);\n\n\t/*\n\t * If a buffer gets written out synchronously or marked stale while it\n\t * is on a delwri list we lazily remove it. To do this, the other party\n\t * clears the  _XBF_DELWRI_Q flag but otherwise leaves the buffer alone.\n\t * It remains referenced and on the list.  In a rare corner case it\n\t * might get readded to a delwri list after the synchronous writeout, in\n\t * which case we need just need to re-add the flag here.\n\t */\n\tbp->b_flags |= _XBF_DELWRI_Q;\n\tif (list_empty(&bp->b_list)) {\n\t\tatomic_inc(&bp->b_hold);\n\t\tlist_add_tail(&bp->b_list, list);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_block",
          "args": [
            "cur",
            "bp",
            "XFS_BB_OWNER"
          ],
          "line": 4007
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1357-1425",
          "snippet": "void\nxfs_btree_log_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfields)\t/* mask of fields: XFS_BB_... */\n{\n\tint\t\t\tfirst;\t/* first byte offset logged */\n\tint\t\t\tlast;\t/* last byte offset logged */\n\tstatic const short\tsoffsets[] = {\t/* table of offsets (short) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_crc),\n\t\tXFS_BTREE_SBLOCK_CRC_LEN\n\t};\n\tstatic const short\tloffsets[] = {\t/* table of offsets (long) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_crc),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_pad),\n\t\tXFS_BTREE_LBLOCK_CRC_LEN\n\t};\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBI(cur, bp, fields);\n\n\tif (bp) {\n\t\tint nbits;\n\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\t/*\n\t\t\t * We don't log the CRC when updating a btree\n\t\t\t * block but instead recreate it during log\n\t\t\t * recovery.  As the log buffers have checksums\n\t\t\t * of their own this is safe and avoids logging a crc\n\t\t\t * update in a lot of places.\n\t\t\t */\n\t\t\tif (fields == XFS_BB_ALL_BITS)\n\t\t\t\tfields = XFS_BB_ALL_BITS_CRC;\n\t\t\tnbits = XFS_BB_NUM_BITS_CRC;\n\t\t} else {\n\t\t\tnbits = XFS_BB_NUM_BITS;\n\t\t}\n\t\txfs_btree_offsets(fields,\n\t\t\t\t  (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\t\t\t\tloffsets : soffsets,\n\t\t\t\t  nbits, &first, &last);\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp, first, last);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_log_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfields)\t/* mask of fields: XFS_BB_... */\n{\n\tint\t\t\tfirst;\t/* first byte offset logged */\n\tint\t\t\tlast;\t/* last byte offset logged */\n\tstatic const short\tsoffsets[] = {\t/* table of offsets (short) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_crc),\n\t\tXFS_BTREE_SBLOCK_CRC_LEN\n\t};\n\tstatic const short\tloffsets[] = {\t/* table of offsets (long) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_crc),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_pad),\n\t\tXFS_BTREE_LBLOCK_CRC_LEN\n\t};\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBI(cur, bp, fields);\n\n\tif (bp) {\n\t\tint nbits;\n\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\t/*\n\t\t\t * We don't log the CRC when updating a btree\n\t\t\t * block but instead recreate it during log\n\t\t\t * recovery.  As the log buffers have checksums\n\t\t\t * of their own this is safe and avoids logging a crc\n\t\t\t * update in a lot of places.\n\t\t\t */\n\t\t\tif (fields == XFS_BB_ALL_BITS)\n\t\t\t\tfields = XFS_BB_ALL_BITS_CRC;\n\t\t\tnbits = XFS_BB_NUM_BITS_CRC;\n\t\t} else {\n\t\t\tnbits = XFS_BB_NUM_BITS;\n\t\t}\n\t\txfs_btree_offsets(fields,\n\t\t\t\t  (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\t\t\t\tloffsets : soffsets,\n\t\t\t\t  nbits, &first, &last);\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp, first, last);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ordered_buf",
          "args": [
            "cur->bc_tp",
            "bp"
          ],
          "line": 4006
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ordered_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "711-724",
          "snippet": "void\nxfs_trans_ordered_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\tbip->bli_flags |= XFS_BLI_ORDERED;\n\ttrace_xfs_buf_item_ordered(bip);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_ordered_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\tbip->bli_flags |= XFS_BLI_ORDERED;\n\ttrace_xfs_buf_item_ordered(bip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "new_owner"
          ],
          "line": 3995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "new_owner"
          ],
          "line": 3993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_block",
          "args": [
            "cur",
            "level",
            "&bp"
          ],
          "line": 3991
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "528-542",
          "snippet": "xfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_readahead",
          "args": [
            "cur",
            "level",
            "XFS_BTCUR_RIGHTRA"
          ],
          "line": 3988
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_readahead_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "871-880",
          "snippet": "STATIC void\nxfs_btree_readahead_ptr(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\txfs_extlen_t\t\tcount)\n{\n\txfs_buf_readahead(cur->bc_mp->m_ddev_targp,\n\t\t\t  xfs_btree_ptr_to_daddr(cur, ptr),\n\t\t\t  cur->bc_mp->m_bsize * count, cur->bc_ops->buf_ops);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_readahead_ptr(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\txfs_extlen_t\t\tcount)\n{\n\txfs_buf_readahead(cur->bc_mp->m_ddev_targp,\n\t\t\t  xfs_btree_ptr_to_daddr(cur, ptr),\n\t\t\t  cur->bc_mp->m_bsize * count, cur->bc_ops->buf_ops);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nstatic int\nxfs_btree_block_change_owner(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\t__uint64_t\t\tnew_owner,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_buf\t\t*bp;\n\tunion xfs_btree_ptr     rptr;\n\n\t/* do right sibling readahead */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* modify the owner */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\tblock->bb_u.l.bb_owner = cpu_to_be64(new_owner);\n\telse\n\t\tblock->bb_u.s.bb_owner = cpu_to_be32(new_owner);\n\n\t/*\n\t * If the block is a root block hosted in an inode, we might not have a\n\t * buffer pointer here and we shouldn't attempt to log the change as the\n\t * information is already held in the inode and discarded when the root\n\t * block is formatted into the on-disk inode fork. We still change it,\n\t * though, so everything is consistent in memory.\n\t */\n\tif (bp) {\n\t\tif (cur->bc_tp) {\n\t\t\txfs_trans_ordered_buf(cur->bc_tp, bp);\n\t\t\txfs_btree_log_block(cur, bp, XFS_BB_OWNER);\n\t\t} else {\n\t\t\txfs_buf_delwri_queue(bp, buffer_list);\n\t\t}\n\t} else {\n\t\tASSERT(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE);\n\t\tASSERT(level == cur->bc_nlevels - 1);\n\t}\n\n\t/* now read rh sibling block for next iteration */\n\txfs_btree_get_sibling(cur, block, &rptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &rptr))\n\t\treturn -ENOENT;\n\n\treturn xfs_btree_lookup_get_block(cur, level, &rptr, &block);\n}"
  },
  {
    "function_name": "xfs_btree_get_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "3914-3950",
    "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tunion xfs_btree_rec\t**recp,\t/* output: btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* btree block */\n\tstruct xfs_buf\t\t*bp;\t/* buffer pointer */\n\tint\t\t\tptr;\t/* record number */\n#ifdef DEBUG\n\tint\t\t\terror;\t/* error return value */\n#endif\n\n\tptr = cur->bc_ptrs[0];\n\tblock = xfs_btree_get_block(cur, 0, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, 0, bp);\n\tif (error)\n\t\treturn error;\n#endif\n\n\t/*\n\t * Off the right end or left end, return failure.\n\t */\n\tif (ptr > xfs_btree_get_numrecs(block) || ptr <= 0) {\n\t\t*stat = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Point to the record and extract its data.\n\t */\n\t*recp = xfs_btree_rec_addr(cur, ptr, block);\n\t*stat = 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_rec_addr",
          "args": [
            "cur",
            "ptr",
            "block"
          ],
          "line": 3947
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_rec_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "468-476",
          "snippet": "xfs_btree_rec *\nxfs_btree_rec_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_rec *)\n\t\t((char *)block + xfs_btree_rec_offset(cur, n));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_rec *\nxfs_btree_rec_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_rec *)\n\t\t((char *)block + xfs_btree_rec_offset(cur, n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_numrecs",
          "args": [
            "block"
          ],
          "line": 3939
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_numrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "416-419",
          "snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_check_block",
          "args": [
            "cur",
            "block",
            "0",
            "bp"
          ],
          "line": 3931
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "149-160",
          "snippet": "int\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_block",
          "args": [
            "cur",
            "0",
            "&bp"
          ],
          "line": 3928
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "528-542",
          "snippet": "xfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t/* error */\nxfs_btree_get_rec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tunion xfs_btree_rec\t**recp,\t/* output: btree record */\n\tint\t\t\t*stat)\t/* output: success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* btree block */\n\tstruct xfs_buf\t\t*bp;\t/* buffer pointer */\n\tint\t\t\tptr;\t/* record number */\n#ifdef DEBUG\n\tint\t\t\terror;\t/* error return value */\n#endif\n\n\tptr = cur->bc_ptrs[0];\n\tblock = xfs_btree_get_block(cur, 0, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, 0, bp);\n\tif (error)\n\t\treturn error;\n#endif\n\n\t/*\n\t * Off the right end or left end, return failure.\n\t */\n\tif (ptr > xfs_btree_get_numrecs(block) || ptr <= 0) {\n\t\t*stat = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Point to the record and extract its data.\n\t */\n\t*recp = xfs_btree_rec_addr(cur, ptr, block);\n\t*stat = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_btree_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "3869-3909",
    "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_delete(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tlevel;\n\tint\t\t\ti;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\t/*\n\t * Go up the tree, starting at leaf level.\n\t *\n\t * If 2 is returned then a join was done; go to the next level.\n\t * Otherwise we are done.\n\t */\n\tfor (level = 0, i = 2; i == 2; level++) {\n\t\terror = xfs_btree_delrec(cur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (i == 0) {\n\t\tfor (level = 1; level < cur->bc_nlevels; level++) {\n\t\t\tif (cur->bc_ptrs[level] == 0) {\n\t\t\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ERROR"
          ],
          "line": 3907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 3903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_decrement",
          "args": [
            "cur",
            "level",
            "&i"
          ],
          "line": 3895
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_decrement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1539-1631",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_delrec",
          "args": [
            "cur",
            "level",
            "&i"
          ],
          "line": 3887
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_delrec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "3347-3862",
          "snippet": "STATIC int\t\t\t\t\t/* error */\nxfs_btree_delrec(\n\tstruct xfs_btree_cur\t*cur,\t\t/* btree cursor */\n\tint\t\t\tlevel,\t\t/* level removing record from */\n\tint\t\t\t*stat)\t\t/* fail/done/go-on */\n{\n\tstruct xfs_btree_block\t*block;\t\t/* btree block */\n\tunion xfs_btree_ptr\tcptr;\t\t/* current block ptr */\n\tstruct xfs_buf\t\t*bp;\t\t/* buffer for block */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* loop counter */\n\tunion xfs_btree_key\tkey;\t\t/* storage for keyp */\n\tunion xfs_btree_key\t*keyp = &key;\t/* passed to the next level */\n\tunion xfs_btree_ptr\tlptr;\t\t/* left sibling block ptr */\n\tstruct xfs_buf\t\t*lbp;\t\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t\t/* left btree block */\n\tint\t\t\tlrecs = 0;\t/* left record count */\n\tint\t\t\tptr;\t\t/* key/record index */\n\tunion xfs_btree_ptr\trptr;\t\t/* right sibling block ptr */\n\tstruct xfs_buf\t\t*rbp;\t\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t\t/* right btree block */\n\tstruct xfs_btree_block\t*rrblock;\t/* right-right btree block */\n\tstruct xfs_buf\t\t*rrbp;\t\t/* right-right buffer pointer */\n\tint\t\t\trrecs = 0;\t/* right record count */\n\tstruct xfs_btree_cur\t*tcur;\t\t/* temporary btree cursor */\n\tint\t\t\tnumrecs;\t/* temporary numrec count */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\ttcur = NULL;\n\n\t/* Get the index of the entry being deleted, check for nothing there. */\n\tptr = cur->bc_ptrs[level];\n\tif (ptr == 0) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t*stat = 0;\n\t\treturn 0;\n\t}\n\n\t/* Get the buffer & block containing the record or key/ptr. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\tnumrecs = xfs_btree_get_numrecs(block);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we're off the end of the block. */\n\tif (ptr > numrecs) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t*stat = 0;\n\t\treturn 0;\n\t}\n\n\tXFS_BTREE_STATS_INC(cur, delrec);\n\tXFS_BTREE_STATS_ADD(cur, moves, numrecs - ptr);\n\n\t/* Excise the entries being deleted. */\n\tif (level > 0) {\n\t\t/* It's a nonleaf. operate on keys and ptrs */\n\t\tunion xfs_btree_key\t*lkp;\n\t\tunion xfs_btree_ptr\t*lpp;\n\n\t\tlkp = xfs_btree_key_addr(cur, ptr + 1, block);\n\t\tlpp = xfs_btree_ptr_addr(cur, ptr + 1, block);\n\n#ifdef DEBUG\n\t\tfor (i = 0; i < numrecs - ptr; i++) {\n\t\t\terror = xfs_btree_check_ptr(cur, lpp, i, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\n\t\tif (ptr < numrecs) {\n\t\t\txfs_btree_shift_keys(cur, lkp, -1, numrecs - ptr);\n\t\t\txfs_btree_shift_ptrs(cur, lpp, -1, numrecs - ptr);\n\t\t\txfs_btree_log_keys(cur, bp, ptr, numrecs - 1);\n\t\t\txfs_btree_log_ptrs(cur, bp, ptr, numrecs - 1);\n\t\t}\n\n\t\t/*\n\t\t * If it's the first record in the block, we'll need to pass a\n\t\t * key up to the next level (updkey).\n\t\t */\n\t\tif (ptr == 1)\n\t\t\tkeyp = xfs_btree_key_addr(cur, 1, block);\n\t} else {\n\t\t/* It's a leaf. operate on records */\n\t\tif (ptr < numrecs) {\n\t\t\txfs_btree_shift_recs(cur,\n\t\t\t\txfs_btree_rec_addr(cur, ptr + 1, block),\n\t\t\t\t-1, numrecs - ptr);\n\t\t\txfs_btree_log_recs(cur, bp, ptr, numrecs - 1);\n\t\t}\n\n\t\t/*\n\t\t * If it's the first record in the block, we'll need a key\n\t\t * structure to pass up to the next level (updkey).\n\t\t */\n\t\tif (ptr == 1) {\n\t\t\tcur->bc_ops->init_key_from_rec(&key,\n\t\t\t\t\txfs_btree_rec_addr(cur, 1, block));\n\t\t\tkeyp = &key;\n\t\t}\n\t}\n\n\t/*\n\t * Decrement and log the number of entries in the block.\n\t */\n\txfs_btree_set_numrecs(block, --numrecs);\n\txfs_btree_log_block(cur, bp, XFS_BB_NUMRECS);\n\n\t/*\n\t * If we are tracking the last record in the tree and\n\t * we are at the far right edge of the tree, update it.\n\t */\n\tif (xfs_btree_is_lastrec(cur, block, level)) {\n\t\tcur->bc_ops->update_lastrec(cur, block, NULL,\n\t\t\t\t\t    ptr, LASTREC_DELREC);\n\t}\n\n\t/*\n\t * We're at the root level.  First, shrink the root block in-memory.\n\t * Try to get rid of the next level down.  If we can't then there's\n\t * nothing left to do.\n\t */\n\tif (level == cur->bc_nlevels - 1) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) {\n\t\t\txfs_iroot_realloc(cur->bc_private.b.ip, -1,\n\t\t\t\t\t  cur->bc_private.b.whichfork);\n\n\t\t\terror = xfs_btree_kill_iroot(cur);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\n\t\t\terror = xfs_btree_dec_cursor(cur, level, stat);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\t*stat = 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * If this is the root level, and there's only one entry left,\n\t\t * and it's NOT the leaf level, then we can get rid of this\n\t\t * level.\n\t\t */\n\t\tif (numrecs == 1 && level > 0) {\n\t\t\tunion xfs_btree_ptr\t*pp;\n\t\t\t/*\n\t\t\t * pp is still set to the first pointer in the block.\n\t\t\t * Make it the new root of the btree.\n\t\t\t */\n\t\t\tpp = xfs_btree_ptr_addr(cur, 1, block);\n\t\t\terror = xfs_btree_kill_root(cur, bp, level, pp);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t} else if (level > 0) {\n\t\t\terror = xfs_btree_dec_cursor(cur, level, stat);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n\t\t*stat = 1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we deleted the leftmost entry in the block, update the\n\t * key values above us in the tree.\n\t */\n\tif (ptr == 1) {\n\t\terror = xfs_btree_updkey(cur, keyp, level + 1);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\t/*\n\t * If the number of records remaining in the block is at least\n\t * the minimum, we're done.\n\t */\n\tif (numrecs >= cur->bc_ops->get_minrecs(cur, level)) {\n\t\terror = xfs_btree_dec_cursor(cur, level, stat);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Otherwise, we have to move some records around to keep the\n\t * tree balanced.  Look at the left and right sibling blocks to\n\t * see if we can re-balance by moving only one record.\n\t */\n\txfs_btree_get_sibling(cur, block, &rptr, XFS_BB_RIGHTSIB);\n\txfs_btree_get_sibling(cur, block, &lptr, XFS_BB_LEFTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) {\n\t\t/*\n\t\t * One child of root, need to get a chance to copy its contents\n\t\t * into the root and delete it. Can't go up to next level,\n\t\t * there's nothing to delete there.\n\t\t */\n\t\tif (xfs_btree_ptr_is_null(cur, &rptr) &&\n\t\t    xfs_btree_ptr_is_null(cur, &lptr) &&\n\t\t    level == cur->bc_nlevels - 2) {\n\t\t\terror = xfs_btree_kill_iroot(cur);\n\t\t\tif (!error)\n\t\t\t\terror = xfs_btree_dec_cursor(cur, level, stat);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tASSERT(!xfs_btree_ptr_is_null(cur, &rptr) ||\n\t       !xfs_btree_ptr_is_null(cur, &lptr));\n\n\t/*\n\t * Duplicate the cursor so our btree manipulations here won't\n\t * disrupt the next level up.\n\t */\n\terror = xfs_btree_dup_cursor(cur, &tcur);\n\tif (error)\n\t\tgoto error0;\n\n\t/*\n\t * If there's a right sibling, see if it's ok to shift an entry\n\t * out of it.\n\t */\n\tif (!xfs_btree_ptr_is_null(cur, &rptr)) {\n\t\t/*\n\t\t * Move the temp cursor to the last entry in the next block.\n\t\t * Actually any entry but the first would suffice.\n\t\t */\n\t\ti = xfs_btree_lastrec(tcur, level);\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\terror = xfs_btree_increment(tcur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\ti = xfs_btree_lastrec(tcur, level);\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\t/* Grab a pointer to the block. */\n\t\tright = xfs_btree_get_block(tcur, level, &rbp);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(tcur, right, level, rbp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\t\t/* Grab the current block number, for future use. */\n\t\txfs_btree_get_sibling(tcur, right, &cptr, XFS_BB_LEFTSIB);\n\n\t\t/*\n\t\t * If right block is full enough so that removing one entry\n\t\t * won't make it too empty, and left-shifting an entry out\n\t\t * of right to us works, we're done.\n\t\t */\n\t\tif (xfs_btree_get_numrecs(right) - 1 >=\n\t\t    cur->bc_ops->get_minrecs(tcur, level)) {\n\t\t\terror = xfs_btree_lshift(tcur, level, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (i) {\n\t\t\t\tASSERT(xfs_btree_get_numrecs(block) >=\n\t\t\t\t       cur->bc_ops->get_minrecs(tcur, level));\n\n\t\t\t\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\t\t\t\ttcur = NULL;\n\n\t\t\t\terror = xfs_btree_dec_cursor(cur, level, stat);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, grab the number of records in right for\n\t\t * future reference, and fix up the temp cursor to point\n\t\t * to our block again (last record).\n\t\t */\n\t\trrecs = xfs_btree_get_numrecs(right);\n\t\tif (!xfs_btree_ptr_is_null(cur, &lptr)) {\n\t\t\ti = xfs_btree_firstrec(tcur, level);\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\t\terror = xfs_btree_decrement(tcur, level, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t}\n\t}\n\n\t/*\n\t * If there's a left sibling, see if it's ok to shift an entry\n\t * out of it.\n\t */\n\tif (!xfs_btree_ptr_is_null(cur, &lptr)) {\n\t\t/*\n\t\t * Move the temp cursor to the first entry in the\n\t\t * previous block.\n\t\t */\n\t\ti = xfs_btree_firstrec(tcur, level);\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\terror = xfs_btree_decrement(tcur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\ti = xfs_btree_firstrec(tcur, level);\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\t/* Grab a pointer to the block. */\n\t\tleft = xfs_btree_get_block(tcur, level, &lbp);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, left, level, lbp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\t\t/* Grab the current block number, for future use. */\n\t\txfs_btree_get_sibling(tcur, left, &cptr, XFS_BB_RIGHTSIB);\n\n\t\t/*\n\t\t * If left block is full enough so that removing one entry\n\t\t * won't make it too empty, and right-shifting an entry out\n\t\t * of left to us works, we're done.\n\t\t */\n\t\tif (xfs_btree_get_numrecs(left) - 1 >=\n\t\t    cur->bc_ops->get_minrecs(tcur, level)) {\n\t\t\terror = xfs_btree_rshift(tcur, level, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (i) {\n\t\t\t\tASSERT(xfs_btree_get_numrecs(block) >=\n\t\t\t\t       cur->bc_ops->get_minrecs(tcur, level));\n\t\t\t\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\t\t\t\ttcur = NULL;\n\t\t\t\tif (level == 0)\n\t\t\t\t\tcur->bc_ptrs[0]++;\n\t\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t\t*stat = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, grab the number of records in right for\n\t\t * future reference.\n\t\t */\n\t\tlrecs = xfs_btree_get_numrecs(left);\n\t}\n\n\t/* Delete the temp cursor, we're done with it. */\n\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\ttcur = NULL;\n\n\t/* If here, we need to do a join to keep the tree balanced. */\n\tASSERT(!xfs_btree_ptr_is_null(cur, &cptr));\n\n\tif (!xfs_btree_ptr_is_null(cur, &lptr) &&\n\t    lrecs + xfs_btree_get_numrecs(block) <=\n\t\t\tcur->bc_ops->get_maxrecs(cur, level)) {\n\t\t/*\n\t\t * Set \"right\" to be the starting block,\n\t\t * \"left\" to be the left neighbor.\n\t\t */\n\t\trptr = cptr;\n\t\tright = block;\n\t\trbp = bp;\n\t\terror = xfs_btree_read_buf_block(cur, &lptr, 0, &left, &lbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t/*\n\t * If that won't work, see if we can join with the right neighbor block.\n\t */\n\t} else if (!xfs_btree_ptr_is_null(cur, &rptr) &&\n\t\t   rrecs + xfs_btree_get_numrecs(block) <=\n\t\t\tcur->bc_ops->get_maxrecs(cur, level)) {\n\t\t/*\n\t\t * Set \"left\" to be the starting block,\n\t\t * \"right\" to be the right neighbor.\n\t\t */\n\t\tlptr = cptr;\n\t\tleft = block;\n\t\tlbp = bp;\n\t\terror = xfs_btree_read_buf_block(cur, &rptr, 0, &right, &rbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t/*\n\t * Otherwise, we can't fix the imbalance.\n\t * Just return.  This is probably a logic error, but it's not fatal.\n\t */\n\t} else {\n\t\terror = xfs_btree_dec_cursor(cur, level, stat);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\treturn 0;\n\t}\n\n\trrecs = xfs_btree_get_numrecs(right);\n\tlrecs = xfs_btree_get_numrecs(left);\n\n\t/*\n\t * We're now going to join \"left\" and \"right\" by moving all the stuff\n\t * in \"right\" to \"left\" and deleting \"right\".\n\t */\n\tXFS_BTREE_STATS_ADD(cur, moves, rrecs);\n\tif (level > 0) {\n\t\t/* It's a non-leaf.  Move keys and pointers. */\n\t\tunion xfs_btree_key\t*lkp;\t/* left btree key */\n\t\tunion xfs_btree_ptr\t*lpp;\t/* left address pointer */\n\t\tunion xfs_btree_key\t*rkp;\t/* right btree key */\n\t\tunion xfs_btree_ptr\t*rpp;\t/* right address pointer */\n\n\t\tlkp = xfs_btree_key_addr(cur, lrecs + 1, left);\n\t\tlpp = xfs_btree_ptr_addr(cur, lrecs + 1, left);\n\t\trkp = xfs_btree_key_addr(cur, 1, right);\n\t\trpp = xfs_btree_ptr_addr(cur, 1, right);\n#ifdef DEBUG\n\t\tfor (i = 1; i < rrecs; i++) {\n\t\t\terror = xfs_btree_check_ptr(cur, rpp, i, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\t\txfs_btree_copy_keys(cur, lkp, rkp, rrecs);\n\t\txfs_btree_copy_ptrs(cur, lpp, rpp, rrecs);\n\n\t\txfs_btree_log_keys(cur, lbp, lrecs + 1, lrecs + rrecs);\n\t\txfs_btree_log_ptrs(cur, lbp, lrecs + 1, lrecs + rrecs);\n\t} else {\n\t\t/* It's a leaf.  Move records.  */\n\t\tunion xfs_btree_rec\t*lrp;\t/* left record pointer */\n\t\tunion xfs_btree_rec\t*rrp;\t/* right record pointer */\n\n\t\tlrp = xfs_btree_rec_addr(cur, lrecs + 1, left);\n\t\trrp = xfs_btree_rec_addr(cur, 1, right);\n\n\t\txfs_btree_copy_recs(cur, lrp, rrp, rrecs);\n\t\txfs_btree_log_recs(cur, lbp, lrecs + 1, lrecs + rrecs);\n\t}\n\n\tXFS_BTREE_STATS_INC(cur, join);\n\n\t/*\n\t * Fix up the number of records and right block pointer in the\n\t * surviving block, and log it.\n\t */\n\txfs_btree_set_numrecs(left, lrecs + rrecs);\n\txfs_btree_get_sibling(cur, right, &cptr, XFS_BB_RIGHTSIB),\n\txfs_btree_set_sibling(cur, left, &cptr, XFS_BB_RIGHTSIB);\n\txfs_btree_log_block(cur, lbp, XFS_BB_NUMRECS | XFS_BB_RIGHTSIB);\n\n\t/* If there is a right sibling, point it to the remaining block. */\n\txfs_btree_get_sibling(cur, left, &cptr, XFS_BB_RIGHTSIB);\n\tif (!xfs_btree_ptr_is_null(cur, &cptr)) {\n\t\terror = xfs_btree_read_buf_block(cur, &cptr, 0, &rrblock, &rrbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_set_sibling(cur, rrblock, &lptr, XFS_BB_LEFTSIB);\n\t\txfs_btree_log_block(cur, rrbp, XFS_BB_LEFTSIB);\n\t}\n\n\t/* Free the deleted block. */\n\terror = cur->bc_ops->free_block(cur, rbp);\n\tif (error)\n\t\tgoto error0;\n\tXFS_BTREE_STATS_INC(cur, free);\n\n\t/*\n\t * If we joined with the left neighbor, set the buffer in the\n\t * cursor to the left block, and fix up the index.\n\t */\n\tif (bp != lbp) {\n\t\tcur->bc_bufs[level] = lbp;\n\t\tcur->bc_ptrs[level] += lrecs;\n\t\tcur->bc_ra[level] = 0;\n\t}\n\t/*\n\t * If we joined with the right neighbor and there's a level above\n\t * us, increment the cursor at that level.\n\t */\n\telse if ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) ||\n\t\t   (level + 1 < cur->bc_nlevels)) {\n\t\terror = xfs_btree_increment(cur, level + 1, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\t/*\n\t * Readjust the ptr at this level if it's not a leaf, since it's\n\t * still pointing at the deletion point, which makes the cursor\n\t * inconsistent.  If this makes the ptr 0, the caller fixes it up.\n\t * We can't use decrement because it would change the next level up.\n\t */\n\tif (level > 0)\n\t\tcur->bc_ptrs[level]--;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t/* Return value means the next level up has something to do. */\n\t*stat = 2;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\tif (tcur)\n\t\txfs_btree_del_cursor(tcur, XFS_BTREE_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\t\t\t\t\t/* error */\nxfs_btree_delrec(\n\tstruct xfs_btree_cur\t*cur,\t\t/* btree cursor */\n\tint\t\t\tlevel,\t\t/* level removing record from */\n\tint\t\t\t*stat)\t\t/* fail/done/go-on */\n{\n\tstruct xfs_btree_block\t*block;\t\t/* btree block */\n\tunion xfs_btree_ptr\tcptr;\t\t/* current block ptr */\n\tstruct xfs_buf\t\t*bp;\t\t/* buffer for block */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* loop counter */\n\tunion xfs_btree_key\tkey;\t\t/* storage for keyp */\n\tunion xfs_btree_key\t*keyp = &key;\t/* passed to the next level */\n\tunion xfs_btree_ptr\tlptr;\t\t/* left sibling block ptr */\n\tstruct xfs_buf\t\t*lbp;\t\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t\t/* left btree block */\n\tint\t\t\tlrecs = 0;\t/* left record count */\n\tint\t\t\tptr;\t\t/* key/record index */\n\tunion xfs_btree_ptr\trptr;\t\t/* right sibling block ptr */\n\tstruct xfs_buf\t\t*rbp;\t\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t\t/* right btree block */\n\tstruct xfs_btree_block\t*rrblock;\t/* right-right btree block */\n\tstruct xfs_buf\t\t*rrbp;\t\t/* right-right buffer pointer */\n\tint\t\t\trrecs = 0;\t/* right record count */\n\tstruct xfs_btree_cur\t*tcur;\t\t/* temporary btree cursor */\n\tint\t\t\tnumrecs;\t/* temporary numrec count */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\ttcur = NULL;\n\n\t/* Get the index of the entry being deleted, check for nothing there. */\n\tptr = cur->bc_ptrs[level];\n\tif (ptr == 0) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t*stat = 0;\n\t\treturn 0;\n\t}\n\n\t/* Get the buffer & block containing the record or key/ptr. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\tnumrecs = xfs_btree_get_numrecs(block);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we're off the end of the block. */\n\tif (ptr > numrecs) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t*stat = 0;\n\t\treturn 0;\n\t}\n\n\tXFS_BTREE_STATS_INC(cur, delrec);\n\tXFS_BTREE_STATS_ADD(cur, moves, numrecs - ptr);\n\n\t/* Excise the entries being deleted. */\n\tif (level > 0) {\n\t\t/* It's a nonleaf. operate on keys and ptrs */\n\t\tunion xfs_btree_key\t*lkp;\n\t\tunion xfs_btree_ptr\t*lpp;\n\n\t\tlkp = xfs_btree_key_addr(cur, ptr + 1, block);\n\t\tlpp = xfs_btree_ptr_addr(cur, ptr + 1, block);\n\n#ifdef DEBUG\n\t\tfor (i = 0; i < numrecs - ptr; i++) {\n\t\t\terror = xfs_btree_check_ptr(cur, lpp, i, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\n\t\tif (ptr < numrecs) {\n\t\t\txfs_btree_shift_keys(cur, lkp, -1, numrecs - ptr);\n\t\t\txfs_btree_shift_ptrs(cur, lpp, -1, numrecs - ptr);\n\t\t\txfs_btree_log_keys(cur, bp, ptr, numrecs - 1);\n\t\t\txfs_btree_log_ptrs(cur, bp, ptr, numrecs - 1);\n\t\t}\n\n\t\t/*\n\t\t * If it's the first record in the block, we'll need to pass a\n\t\t * key up to the next level (updkey).\n\t\t */\n\t\tif (ptr == 1)\n\t\t\tkeyp = xfs_btree_key_addr(cur, 1, block);\n\t} else {\n\t\t/* It's a leaf. operate on records */\n\t\tif (ptr < numrecs) {\n\t\t\txfs_btree_shift_recs(cur,\n\t\t\t\txfs_btree_rec_addr(cur, ptr + 1, block),\n\t\t\t\t-1, numrecs - ptr);\n\t\t\txfs_btree_log_recs(cur, bp, ptr, numrecs - 1);\n\t\t}\n\n\t\t/*\n\t\t * If it's the first record in the block, we'll need a key\n\t\t * structure to pass up to the next level (updkey).\n\t\t */\n\t\tif (ptr == 1) {\n\t\t\tcur->bc_ops->init_key_from_rec(&key,\n\t\t\t\t\txfs_btree_rec_addr(cur, 1, block));\n\t\t\tkeyp = &key;\n\t\t}\n\t}\n\n\t/*\n\t * Decrement and log the number of entries in the block.\n\t */\n\txfs_btree_set_numrecs(block, --numrecs);\n\txfs_btree_log_block(cur, bp, XFS_BB_NUMRECS);\n\n\t/*\n\t * If we are tracking the last record in the tree and\n\t * we are at the far right edge of the tree, update it.\n\t */\n\tif (xfs_btree_is_lastrec(cur, block, level)) {\n\t\tcur->bc_ops->update_lastrec(cur, block, NULL,\n\t\t\t\t\t    ptr, LASTREC_DELREC);\n\t}\n\n\t/*\n\t * We're at the root level.  First, shrink the root block in-memory.\n\t * Try to get rid of the next level down.  If we can't then there's\n\t * nothing left to do.\n\t */\n\tif (level == cur->bc_nlevels - 1) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) {\n\t\t\txfs_iroot_realloc(cur->bc_private.b.ip, -1,\n\t\t\t\t\t  cur->bc_private.b.whichfork);\n\n\t\t\terror = xfs_btree_kill_iroot(cur);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\n\t\t\terror = xfs_btree_dec_cursor(cur, level, stat);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\t*stat = 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * If this is the root level, and there's only one entry left,\n\t\t * and it's NOT the leaf level, then we can get rid of this\n\t\t * level.\n\t\t */\n\t\tif (numrecs == 1 && level > 0) {\n\t\t\tunion xfs_btree_ptr\t*pp;\n\t\t\t/*\n\t\t\t * pp is still set to the first pointer in the block.\n\t\t\t * Make it the new root of the btree.\n\t\t\t */\n\t\t\tpp = xfs_btree_ptr_addr(cur, 1, block);\n\t\t\terror = xfs_btree_kill_root(cur, bp, level, pp);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t} else if (level > 0) {\n\t\t\terror = xfs_btree_dec_cursor(cur, level, stat);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n\t\t*stat = 1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we deleted the leftmost entry in the block, update the\n\t * key values above us in the tree.\n\t */\n\tif (ptr == 1) {\n\t\terror = xfs_btree_updkey(cur, keyp, level + 1);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\t/*\n\t * If the number of records remaining in the block is at least\n\t * the minimum, we're done.\n\t */\n\tif (numrecs >= cur->bc_ops->get_minrecs(cur, level)) {\n\t\terror = xfs_btree_dec_cursor(cur, level, stat);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Otherwise, we have to move some records around to keep the\n\t * tree balanced.  Look at the left and right sibling blocks to\n\t * see if we can re-balance by moving only one record.\n\t */\n\txfs_btree_get_sibling(cur, block, &rptr, XFS_BB_RIGHTSIB);\n\txfs_btree_get_sibling(cur, block, &lptr, XFS_BB_LEFTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) {\n\t\t/*\n\t\t * One child of root, need to get a chance to copy its contents\n\t\t * into the root and delete it. Can't go up to next level,\n\t\t * there's nothing to delete there.\n\t\t */\n\t\tif (xfs_btree_ptr_is_null(cur, &rptr) &&\n\t\t    xfs_btree_ptr_is_null(cur, &lptr) &&\n\t\t    level == cur->bc_nlevels - 2) {\n\t\t\terror = xfs_btree_kill_iroot(cur);\n\t\t\tif (!error)\n\t\t\t\terror = xfs_btree_dec_cursor(cur, level, stat);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tASSERT(!xfs_btree_ptr_is_null(cur, &rptr) ||\n\t       !xfs_btree_ptr_is_null(cur, &lptr));\n\n\t/*\n\t * Duplicate the cursor so our btree manipulations here won't\n\t * disrupt the next level up.\n\t */\n\terror = xfs_btree_dup_cursor(cur, &tcur);\n\tif (error)\n\t\tgoto error0;\n\n\t/*\n\t * If there's a right sibling, see if it's ok to shift an entry\n\t * out of it.\n\t */\n\tif (!xfs_btree_ptr_is_null(cur, &rptr)) {\n\t\t/*\n\t\t * Move the temp cursor to the last entry in the next block.\n\t\t * Actually any entry but the first would suffice.\n\t\t */\n\t\ti = xfs_btree_lastrec(tcur, level);\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\terror = xfs_btree_increment(tcur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\ti = xfs_btree_lastrec(tcur, level);\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\t/* Grab a pointer to the block. */\n\t\tright = xfs_btree_get_block(tcur, level, &rbp);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(tcur, right, level, rbp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\t\t/* Grab the current block number, for future use. */\n\t\txfs_btree_get_sibling(tcur, right, &cptr, XFS_BB_LEFTSIB);\n\n\t\t/*\n\t\t * If right block is full enough so that removing one entry\n\t\t * won't make it too empty, and left-shifting an entry out\n\t\t * of right to us works, we're done.\n\t\t */\n\t\tif (xfs_btree_get_numrecs(right) - 1 >=\n\t\t    cur->bc_ops->get_minrecs(tcur, level)) {\n\t\t\terror = xfs_btree_lshift(tcur, level, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (i) {\n\t\t\t\tASSERT(xfs_btree_get_numrecs(block) >=\n\t\t\t\t       cur->bc_ops->get_minrecs(tcur, level));\n\n\t\t\t\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\t\t\t\ttcur = NULL;\n\n\t\t\t\terror = xfs_btree_dec_cursor(cur, level, stat);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, grab the number of records in right for\n\t\t * future reference, and fix up the temp cursor to point\n\t\t * to our block again (last record).\n\t\t */\n\t\trrecs = xfs_btree_get_numrecs(right);\n\t\tif (!xfs_btree_ptr_is_null(cur, &lptr)) {\n\t\t\ti = xfs_btree_firstrec(tcur, level);\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\t\terror = xfs_btree_decrement(tcur, level, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t}\n\t}\n\n\t/*\n\t * If there's a left sibling, see if it's ok to shift an entry\n\t * out of it.\n\t */\n\tif (!xfs_btree_ptr_is_null(cur, &lptr)) {\n\t\t/*\n\t\t * Move the temp cursor to the first entry in the\n\t\t * previous block.\n\t\t */\n\t\ti = xfs_btree_firstrec(tcur, level);\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\terror = xfs_btree_decrement(tcur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\ti = xfs_btree_firstrec(tcur, level);\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\t/* Grab a pointer to the block. */\n\t\tleft = xfs_btree_get_block(tcur, level, &lbp);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, left, level, lbp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\t\t/* Grab the current block number, for future use. */\n\t\txfs_btree_get_sibling(tcur, left, &cptr, XFS_BB_RIGHTSIB);\n\n\t\t/*\n\t\t * If left block is full enough so that removing one entry\n\t\t * won't make it too empty, and right-shifting an entry out\n\t\t * of left to us works, we're done.\n\t\t */\n\t\tif (xfs_btree_get_numrecs(left) - 1 >=\n\t\t    cur->bc_ops->get_minrecs(tcur, level)) {\n\t\t\terror = xfs_btree_rshift(tcur, level, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (i) {\n\t\t\t\tASSERT(xfs_btree_get_numrecs(block) >=\n\t\t\t\t       cur->bc_ops->get_minrecs(tcur, level));\n\t\t\t\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\t\t\t\ttcur = NULL;\n\t\t\t\tif (level == 0)\n\t\t\t\t\tcur->bc_ptrs[0]++;\n\t\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t\t*stat = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, grab the number of records in right for\n\t\t * future reference.\n\t\t */\n\t\tlrecs = xfs_btree_get_numrecs(left);\n\t}\n\n\t/* Delete the temp cursor, we're done with it. */\n\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\ttcur = NULL;\n\n\t/* If here, we need to do a join to keep the tree balanced. */\n\tASSERT(!xfs_btree_ptr_is_null(cur, &cptr));\n\n\tif (!xfs_btree_ptr_is_null(cur, &lptr) &&\n\t    lrecs + xfs_btree_get_numrecs(block) <=\n\t\t\tcur->bc_ops->get_maxrecs(cur, level)) {\n\t\t/*\n\t\t * Set \"right\" to be the starting block,\n\t\t * \"left\" to be the left neighbor.\n\t\t */\n\t\trptr = cptr;\n\t\tright = block;\n\t\trbp = bp;\n\t\terror = xfs_btree_read_buf_block(cur, &lptr, 0, &left, &lbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t/*\n\t * If that won't work, see if we can join with the right neighbor block.\n\t */\n\t} else if (!xfs_btree_ptr_is_null(cur, &rptr) &&\n\t\t   rrecs + xfs_btree_get_numrecs(block) <=\n\t\t\tcur->bc_ops->get_maxrecs(cur, level)) {\n\t\t/*\n\t\t * Set \"left\" to be the starting block,\n\t\t * \"right\" to be the right neighbor.\n\t\t */\n\t\tlptr = cptr;\n\t\tleft = block;\n\t\tlbp = bp;\n\t\terror = xfs_btree_read_buf_block(cur, &rptr, 0, &right, &rbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t/*\n\t * Otherwise, we can't fix the imbalance.\n\t * Just return.  This is probably a logic error, but it's not fatal.\n\t */\n\t} else {\n\t\terror = xfs_btree_dec_cursor(cur, level, stat);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\treturn 0;\n\t}\n\n\trrecs = xfs_btree_get_numrecs(right);\n\tlrecs = xfs_btree_get_numrecs(left);\n\n\t/*\n\t * We're now going to join \"left\" and \"right\" by moving all the stuff\n\t * in \"right\" to \"left\" and deleting \"right\".\n\t */\n\tXFS_BTREE_STATS_ADD(cur, moves, rrecs);\n\tif (level > 0) {\n\t\t/* It's a non-leaf.  Move keys and pointers. */\n\t\tunion xfs_btree_key\t*lkp;\t/* left btree key */\n\t\tunion xfs_btree_ptr\t*lpp;\t/* left address pointer */\n\t\tunion xfs_btree_key\t*rkp;\t/* right btree key */\n\t\tunion xfs_btree_ptr\t*rpp;\t/* right address pointer */\n\n\t\tlkp = xfs_btree_key_addr(cur, lrecs + 1, left);\n\t\tlpp = xfs_btree_ptr_addr(cur, lrecs + 1, left);\n\t\trkp = xfs_btree_key_addr(cur, 1, right);\n\t\trpp = xfs_btree_ptr_addr(cur, 1, right);\n#ifdef DEBUG\n\t\tfor (i = 1; i < rrecs; i++) {\n\t\t\terror = xfs_btree_check_ptr(cur, rpp, i, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\t\txfs_btree_copy_keys(cur, lkp, rkp, rrecs);\n\t\txfs_btree_copy_ptrs(cur, lpp, rpp, rrecs);\n\n\t\txfs_btree_log_keys(cur, lbp, lrecs + 1, lrecs + rrecs);\n\t\txfs_btree_log_ptrs(cur, lbp, lrecs + 1, lrecs + rrecs);\n\t} else {\n\t\t/* It's a leaf.  Move records.  */\n\t\tunion xfs_btree_rec\t*lrp;\t/* left record pointer */\n\t\tunion xfs_btree_rec\t*rrp;\t/* right record pointer */\n\n\t\tlrp = xfs_btree_rec_addr(cur, lrecs + 1, left);\n\t\trrp = xfs_btree_rec_addr(cur, 1, right);\n\n\t\txfs_btree_copy_recs(cur, lrp, rrp, rrecs);\n\t\txfs_btree_log_recs(cur, lbp, lrecs + 1, lrecs + rrecs);\n\t}\n\n\tXFS_BTREE_STATS_INC(cur, join);\n\n\t/*\n\t * Fix up the number of records and right block pointer in the\n\t * surviving block, and log it.\n\t */\n\txfs_btree_set_numrecs(left, lrecs + rrecs);\n\txfs_btree_get_sibling(cur, right, &cptr, XFS_BB_RIGHTSIB),\n\txfs_btree_set_sibling(cur, left, &cptr, XFS_BB_RIGHTSIB);\n\txfs_btree_log_block(cur, lbp, XFS_BB_NUMRECS | XFS_BB_RIGHTSIB);\n\n\t/* If there is a right sibling, point it to the remaining block. */\n\txfs_btree_get_sibling(cur, left, &cptr, XFS_BB_RIGHTSIB);\n\tif (!xfs_btree_ptr_is_null(cur, &cptr)) {\n\t\terror = xfs_btree_read_buf_block(cur, &cptr, 0, &rrblock, &rrbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_set_sibling(cur, rrblock, &lptr, XFS_BB_LEFTSIB);\n\t\txfs_btree_log_block(cur, rrbp, XFS_BB_LEFTSIB);\n\t}\n\n\t/* Free the deleted block. */\n\terror = cur->bc_ops->free_block(cur, rbp);\n\tif (error)\n\t\tgoto error0;\n\tXFS_BTREE_STATS_INC(cur, free);\n\n\t/*\n\t * If we joined with the left neighbor, set the buffer in the\n\t * cursor to the left block, and fix up the index.\n\t */\n\tif (bp != lbp) {\n\t\tcur->bc_bufs[level] = lbp;\n\t\tcur->bc_ptrs[level] += lrecs;\n\t\tcur->bc_ra[level] = 0;\n\t}\n\t/*\n\t * If we joined with the right neighbor and there's a level above\n\t * us, increment the cursor at that level.\n\t */\n\telse if ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) ||\n\t\t   (level + 1 < cur->bc_nlevels)) {\n\t\terror = xfs_btree_increment(cur, level + 1, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\t/*\n\t * Readjust the ptr at this level if it's not a leaf, since it's\n\t * still pointing at the deletion point, which makes the cursor\n\t * inconsistent.  If this makes the ptr 0, the caller fixes it up.\n\t * We can't use decrement because it would change the next level up.\n\t */\n\tif (level > 0)\n\t\tcur->bc_ptrs[level]--;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t/* Return value means the next level up has something to do. */\n\t*stat = 2;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\tif (tcur)\n\t\txfs_btree_del_cursor(tcur, XFS_BTREE_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ENTRY"
          ],
          "line": 3878
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\t\t\t\t\t/* error */\nxfs_btree_delete(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tlevel;\n\tint\t\t\ti;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\t/*\n\t * Go up the tree, starting at leaf level.\n\t *\n\t * If 2 is returned then a join was done; go to the next level.\n\t * Otherwise we are done.\n\t */\n\tfor (level = 0, i = 2; i == 2; level++) {\n\t\terror = xfs_btree_delrec(cur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (i == 0) {\n\t\tfor (level = 1; level < cur->bc_nlevels; level++) {\n\t\t\tif (cur->bc_ptrs[level] == 0) {\n\t\t\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_btree_delrec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "3347-3862",
    "snippet": "STATIC int\t\t\t\t\t/* error */\nxfs_btree_delrec(\n\tstruct xfs_btree_cur\t*cur,\t\t/* btree cursor */\n\tint\t\t\tlevel,\t\t/* level removing record from */\n\tint\t\t\t*stat)\t\t/* fail/done/go-on */\n{\n\tstruct xfs_btree_block\t*block;\t\t/* btree block */\n\tunion xfs_btree_ptr\tcptr;\t\t/* current block ptr */\n\tstruct xfs_buf\t\t*bp;\t\t/* buffer for block */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* loop counter */\n\tunion xfs_btree_key\tkey;\t\t/* storage for keyp */\n\tunion xfs_btree_key\t*keyp = &key;\t/* passed to the next level */\n\tunion xfs_btree_ptr\tlptr;\t\t/* left sibling block ptr */\n\tstruct xfs_buf\t\t*lbp;\t\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t\t/* left btree block */\n\tint\t\t\tlrecs = 0;\t/* left record count */\n\tint\t\t\tptr;\t\t/* key/record index */\n\tunion xfs_btree_ptr\trptr;\t\t/* right sibling block ptr */\n\tstruct xfs_buf\t\t*rbp;\t\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t\t/* right btree block */\n\tstruct xfs_btree_block\t*rrblock;\t/* right-right btree block */\n\tstruct xfs_buf\t\t*rrbp;\t\t/* right-right buffer pointer */\n\tint\t\t\trrecs = 0;\t/* right record count */\n\tstruct xfs_btree_cur\t*tcur;\t\t/* temporary btree cursor */\n\tint\t\t\tnumrecs;\t/* temporary numrec count */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\ttcur = NULL;\n\n\t/* Get the index of the entry being deleted, check for nothing there. */\n\tptr = cur->bc_ptrs[level];\n\tif (ptr == 0) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t*stat = 0;\n\t\treturn 0;\n\t}\n\n\t/* Get the buffer & block containing the record or key/ptr. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\tnumrecs = xfs_btree_get_numrecs(block);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we're off the end of the block. */\n\tif (ptr > numrecs) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t*stat = 0;\n\t\treturn 0;\n\t}\n\n\tXFS_BTREE_STATS_INC(cur, delrec);\n\tXFS_BTREE_STATS_ADD(cur, moves, numrecs - ptr);\n\n\t/* Excise the entries being deleted. */\n\tif (level > 0) {\n\t\t/* It's a nonleaf. operate on keys and ptrs */\n\t\tunion xfs_btree_key\t*lkp;\n\t\tunion xfs_btree_ptr\t*lpp;\n\n\t\tlkp = xfs_btree_key_addr(cur, ptr + 1, block);\n\t\tlpp = xfs_btree_ptr_addr(cur, ptr + 1, block);\n\n#ifdef DEBUG\n\t\tfor (i = 0; i < numrecs - ptr; i++) {\n\t\t\terror = xfs_btree_check_ptr(cur, lpp, i, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\n\t\tif (ptr < numrecs) {\n\t\t\txfs_btree_shift_keys(cur, lkp, -1, numrecs - ptr);\n\t\t\txfs_btree_shift_ptrs(cur, lpp, -1, numrecs - ptr);\n\t\t\txfs_btree_log_keys(cur, bp, ptr, numrecs - 1);\n\t\t\txfs_btree_log_ptrs(cur, bp, ptr, numrecs - 1);\n\t\t}\n\n\t\t/*\n\t\t * If it's the first record in the block, we'll need to pass a\n\t\t * key up to the next level (updkey).\n\t\t */\n\t\tif (ptr == 1)\n\t\t\tkeyp = xfs_btree_key_addr(cur, 1, block);\n\t} else {\n\t\t/* It's a leaf. operate on records */\n\t\tif (ptr < numrecs) {\n\t\t\txfs_btree_shift_recs(cur,\n\t\t\t\txfs_btree_rec_addr(cur, ptr + 1, block),\n\t\t\t\t-1, numrecs - ptr);\n\t\t\txfs_btree_log_recs(cur, bp, ptr, numrecs - 1);\n\t\t}\n\n\t\t/*\n\t\t * If it's the first record in the block, we'll need a key\n\t\t * structure to pass up to the next level (updkey).\n\t\t */\n\t\tif (ptr == 1) {\n\t\t\tcur->bc_ops->init_key_from_rec(&key,\n\t\t\t\t\txfs_btree_rec_addr(cur, 1, block));\n\t\t\tkeyp = &key;\n\t\t}\n\t}\n\n\t/*\n\t * Decrement and log the number of entries in the block.\n\t */\n\txfs_btree_set_numrecs(block, --numrecs);\n\txfs_btree_log_block(cur, bp, XFS_BB_NUMRECS);\n\n\t/*\n\t * If we are tracking the last record in the tree and\n\t * we are at the far right edge of the tree, update it.\n\t */\n\tif (xfs_btree_is_lastrec(cur, block, level)) {\n\t\tcur->bc_ops->update_lastrec(cur, block, NULL,\n\t\t\t\t\t    ptr, LASTREC_DELREC);\n\t}\n\n\t/*\n\t * We're at the root level.  First, shrink the root block in-memory.\n\t * Try to get rid of the next level down.  If we can't then there's\n\t * nothing left to do.\n\t */\n\tif (level == cur->bc_nlevels - 1) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) {\n\t\t\txfs_iroot_realloc(cur->bc_private.b.ip, -1,\n\t\t\t\t\t  cur->bc_private.b.whichfork);\n\n\t\t\terror = xfs_btree_kill_iroot(cur);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\n\t\t\terror = xfs_btree_dec_cursor(cur, level, stat);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\t*stat = 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * If this is the root level, and there's only one entry left,\n\t\t * and it's NOT the leaf level, then we can get rid of this\n\t\t * level.\n\t\t */\n\t\tif (numrecs == 1 && level > 0) {\n\t\t\tunion xfs_btree_ptr\t*pp;\n\t\t\t/*\n\t\t\t * pp is still set to the first pointer in the block.\n\t\t\t * Make it the new root of the btree.\n\t\t\t */\n\t\t\tpp = xfs_btree_ptr_addr(cur, 1, block);\n\t\t\terror = xfs_btree_kill_root(cur, bp, level, pp);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t} else if (level > 0) {\n\t\t\terror = xfs_btree_dec_cursor(cur, level, stat);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n\t\t*stat = 1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we deleted the leftmost entry in the block, update the\n\t * key values above us in the tree.\n\t */\n\tif (ptr == 1) {\n\t\terror = xfs_btree_updkey(cur, keyp, level + 1);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\t/*\n\t * If the number of records remaining in the block is at least\n\t * the minimum, we're done.\n\t */\n\tif (numrecs >= cur->bc_ops->get_minrecs(cur, level)) {\n\t\terror = xfs_btree_dec_cursor(cur, level, stat);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Otherwise, we have to move some records around to keep the\n\t * tree balanced.  Look at the left and right sibling blocks to\n\t * see if we can re-balance by moving only one record.\n\t */\n\txfs_btree_get_sibling(cur, block, &rptr, XFS_BB_RIGHTSIB);\n\txfs_btree_get_sibling(cur, block, &lptr, XFS_BB_LEFTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) {\n\t\t/*\n\t\t * One child of root, need to get a chance to copy its contents\n\t\t * into the root and delete it. Can't go up to next level,\n\t\t * there's nothing to delete there.\n\t\t */\n\t\tif (xfs_btree_ptr_is_null(cur, &rptr) &&\n\t\t    xfs_btree_ptr_is_null(cur, &lptr) &&\n\t\t    level == cur->bc_nlevels - 2) {\n\t\t\terror = xfs_btree_kill_iroot(cur);\n\t\t\tif (!error)\n\t\t\t\terror = xfs_btree_dec_cursor(cur, level, stat);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tASSERT(!xfs_btree_ptr_is_null(cur, &rptr) ||\n\t       !xfs_btree_ptr_is_null(cur, &lptr));\n\n\t/*\n\t * Duplicate the cursor so our btree manipulations here won't\n\t * disrupt the next level up.\n\t */\n\terror = xfs_btree_dup_cursor(cur, &tcur);\n\tif (error)\n\t\tgoto error0;\n\n\t/*\n\t * If there's a right sibling, see if it's ok to shift an entry\n\t * out of it.\n\t */\n\tif (!xfs_btree_ptr_is_null(cur, &rptr)) {\n\t\t/*\n\t\t * Move the temp cursor to the last entry in the next block.\n\t\t * Actually any entry but the first would suffice.\n\t\t */\n\t\ti = xfs_btree_lastrec(tcur, level);\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\terror = xfs_btree_increment(tcur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\ti = xfs_btree_lastrec(tcur, level);\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\t/* Grab a pointer to the block. */\n\t\tright = xfs_btree_get_block(tcur, level, &rbp);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(tcur, right, level, rbp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\t\t/* Grab the current block number, for future use. */\n\t\txfs_btree_get_sibling(tcur, right, &cptr, XFS_BB_LEFTSIB);\n\n\t\t/*\n\t\t * If right block is full enough so that removing one entry\n\t\t * won't make it too empty, and left-shifting an entry out\n\t\t * of right to us works, we're done.\n\t\t */\n\t\tif (xfs_btree_get_numrecs(right) - 1 >=\n\t\t    cur->bc_ops->get_minrecs(tcur, level)) {\n\t\t\terror = xfs_btree_lshift(tcur, level, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (i) {\n\t\t\t\tASSERT(xfs_btree_get_numrecs(block) >=\n\t\t\t\t       cur->bc_ops->get_minrecs(tcur, level));\n\n\t\t\t\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\t\t\t\ttcur = NULL;\n\n\t\t\t\terror = xfs_btree_dec_cursor(cur, level, stat);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, grab the number of records in right for\n\t\t * future reference, and fix up the temp cursor to point\n\t\t * to our block again (last record).\n\t\t */\n\t\trrecs = xfs_btree_get_numrecs(right);\n\t\tif (!xfs_btree_ptr_is_null(cur, &lptr)) {\n\t\t\ti = xfs_btree_firstrec(tcur, level);\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\t\terror = xfs_btree_decrement(tcur, level, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t}\n\t}\n\n\t/*\n\t * If there's a left sibling, see if it's ok to shift an entry\n\t * out of it.\n\t */\n\tif (!xfs_btree_ptr_is_null(cur, &lptr)) {\n\t\t/*\n\t\t * Move the temp cursor to the first entry in the\n\t\t * previous block.\n\t\t */\n\t\ti = xfs_btree_firstrec(tcur, level);\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\terror = xfs_btree_decrement(tcur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\ti = xfs_btree_firstrec(tcur, level);\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\t/* Grab a pointer to the block. */\n\t\tleft = xfs_btree_get_block(tcur, level, &lbp);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, left, level, lbp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\t\t/* Grab the current block number, for future use. */\n\t\txfs_btree_get_sibling(tcur, left, &cptr, XFS_BB_RIGHTSIB);\n\n\t\t/*\n\t\t * If left block is full enough so that removing one entry\n\t\t * won't make it too empty, and right-shifting an entry out\n\t\t * of left to us works, we're done.\n\t\t */\n\t\tif (xfs_btree_get_numrecs(left) - 1 >=\n\t\t    cur->bc_ops->get_minrecs(tcur, level)) {\n\t\t\terror = xfs_btree_rshift(tcur, level, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (i) {\n\t\t\t\tASSERT(xfs_btree_get_numrecs(block) >=\n\t\t\t\t       cur->bc_ops->get_minrecs(tcur, level));\n\t\t\t\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\t\t\t\ttcur = NULL;\n\t\t\t\tif (level == 0)\n\t\t\t\t\tcur->bc_ptrs[0]++;\n\t\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t\t*stat = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, grab the number of records in right for\n\t\t * future reference.\n\t\t */\n\t\tlrecs = xfs_btree_get_numrecs(left);\n\t}\n\n\t/* Delete the temp cursor, we're done with it. */\n\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\ttcur = NULL;\n\n\t/* If here, we need to do a join to keep the tree balanced. */\n\tASSERT(!xfs_btree_ptr_is_null(cur, &cptr));\n\n\tif (!xfs_btree_ptr_is_null(cur, &lptr) &&\n\t    lrecs + xfs_btree_get_numrecs(block) <=\n\t\t\tcur->bc_ops->get_maxrecs(cur, level)) {\n\t\t/*\n\t\t * Set \"right\" to be the starting block,\n\t\t * \"left\" to be the left neighbor.\n\t\t */\n\t\trptr = cptr;\n\t\tright = block;\n\t\trbp = bp;\n\t\terror = xfs_btree_read_buf_block(cur, &lptr, 0, &left, &lbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t/*\n\t * If that won't work, see if we can join with the right neighbor block.\n\t */\n\t} else if (!xfs_btree_ptr_is_null(cur, &rptr) &&\n\t\t   rrecs + xfs_btree_get_numrecs(block) <=\n\t\t\tcur->bc_ops->get_maxrecs(cur, level)) {\n\t\t/*\n\t\t * Set \"left\" to be the starting block,\n\t\t * \"right\" to be the right neighbor.\n\t\t */\n\t\tlptr = cptr;\n\t\tleft = block;\n\t\tlbp = bp;\n\t\terror = xfs_btree_read_buf_block(cur, &rptr, 0, &right, &rbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t/*\n\t * Otherwise, we can't fix the imbalance.\n\t * Just return.  This is probably a logic error, but it's not fatal.\n\t */\n\t} else {\n\t\terror = xfs_btree_dec_cursor(cur, level, stat);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\treturn 0;\n\t}\n\n\trrecs = xfs_btree_get_numrecs(right);\n\tlrecs = xfs_btree_get_numrecs(left);\n\n\t/*\n\t * We're now going to join \"left\" and \"right\" by moving all the stuff\n\t * in \"right\" to \"left\" and deleting \"right\".\n\t */\n\tXFS_BTREE_STATS_ADD(cur, moves, rrecs);\n\tif (level > 0) {\n\t\t/* It's a non-leaf.  Move keys and pointers. */\n\t\tunion xfs_btree_key\t*lkp;\t/* left btree key */\n\t\tunion xfs_btree_ptr\t*lpp;\t/* left address pointer */\n\t\tunion xfs_btree_key\t*rkp;\t/* right btree key */\n\t\tunion xfs_btree_ptr\t*rpp;\t/* right address pointer */\n\n\t\tlkp = xfs_btree_key_addr(cur, lrecs + 1, left);\n\t\tlpp = xfs_btree_ptr_addr(cur, lrecs + 1, left);\n\t\trkp = xfs_btree_key_addr(cur, 1, right);\n\t\trpp = xfs_btree_ptr_addr(cur, 1, right);\n#ifdef DEBUG\n\t\tfor (i = 1; i < rrecs; i++) {\n\t\t\terror = xfs_btree_check_ptr(cur, rpp, i, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\t\txfs_btree_copy_keys(cur, lkp, rkp, rrecs);\n\t\txfs_btree_copy_ptrs(cur, lpp, rpp, rrecs);\n\n\t\txfs_btree_log_keys(cur, lbp, lrecs + 1, lrecs + rrecs);\n\t\txfs_btree_log_ptrs(cur, lbp, lrecs + 1, lrecs + rrecs);\n\t} else {\n\t\t/* It's a leaf.  Move records.  */\n\t\tunion xfs_btree_rec\t*lrp;\t/* left record pointer */\n\t\tunion xfs_btree_rec\t*rrp;\t/* right record pointer */\n\n\t\tlrp = xfs_btree_rec_addr(cur, lrecs + 1, left);\n\t\trrp = xfs_btree_rec_addr(cur, 1, right);\n\n\t\txfs_btree_copy_recs(cur, lrp, rrp, rrecs);\n\t\txfs_btree_log_recs(cur, lbp, lrecs + 1, lrecs + rrecs);\n\t}\n\n\tXFS_BTREE_STATS_INC(cur, join);\n\n\t/*\n\t * Fix up the number of records and right block pointer in the\n\t * surviving block, and log it.\n\t */\n\txfs_btree_set_numrecs(left, lrecs + rrecs);\n\txfs_btree_get_sibling(cur, right, &cptr, XFS_BB_RIGHTSIB),\n\txfs_btree_set_sibling(cur, left, &cptr, XFS_BB_RIGHTSIB);\n\txfs_btree_log_block(cur, lbp, XFS_BB_NUMRECS | XFS_BB_RIGHTSIB);\n\n\t/* If there is a right sibling, point it to the remaining block. */\n\txfs_btree_get_sibling(cur, left, &cptr, XFS_BB_RIGHTSIB);\n\tif (!xfs_btree_ptr_is_null(cur, &cptr)) {\n\t\terror = xfs_btree_read_buf_block(cur, &cptr, 0, &rrblock, &rrbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_set_sibling(cur, rrblock, &lptr, XFS_BB_LEFTSIB);\n\t\txfs_btree_log_block(cur, rrbp, XFS_BB_LEFTSIB);\n\t}\n\n\t/* Free the deleted block. */\n\terror = cur->bc_ops->free_block(cur, rbp);\n\tif (error)\n\t\tgoto error0;\n\tXFS_BTREE_STATS_INC(cur, free);\n\n\t/*\n\t * If we joined with the left neighbor, set the buffer in the\n\t * cursor to the left block, and fix up the index.\n\t */\n\tif (bp != lbp) {\n\t\tcur->bc_bufs[level] = lbp;\n\t\tcur->bc_ptrs[level] += lrecs;\n\t\tcur->bc_ra[level] = 0;\n\t}\n\t/*\n\t * If we joined with the right neighbor and there's a level above\n\t * us, increment the cursor at that level.\n\t */\n\telse if ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) ||\n\t\t   (level + 1 < cur->bc_nlevels)) {\n\t\terror = xfs_btree_increment(cur, level + 1, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\t/*\n\t * Readjust the ptr at this level if it's not a leaf, since it's\n\t * still pointing at the deletion point, which makes the cursor\n\t * inconsistent.  If this makes the ptr 0, the caller fixes it up.\n\t * We can't use decrement because it would change the next level up.\n\t */\n\tif (level > 0)\n\t\tcur->bc_ptrs[level]--;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t/* Return value means the next level up has something to do. */\n\t*stat = 2;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\tif (tcur)\n\t\txfs_btree_del_cursor(tcur, XFS_BTREE_ERROR);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "tcur",
            "XFS_BTREE_ERROR"
          ],
          "line": 3860
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ERROR"
          ],
          "line": 3858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 3852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_increment",
          "args": [
            "cur",
            "level + 1",
            "&i"
          ],
          "line": 3838
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1431-1533",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_INC",
          "args": [
            "cur",
            "free"
          ],
          "line": 3821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->free_block",
          "args": [
            "cur",
            "rbp"
          ],
          "line": 3818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_block",
          "args": [
            "cur",
            "rrbp",
            "XFS_BB_LEFTSIB"
          ],
          "line": 3814
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1357-1425",
          "snippet": "void\nxfs_btree_log_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfields)\t/* mask of fields: XFS_BB_... */\n{\n\tint\t\t\tfirst;\t/* first byte offset logged */\n\tint\t\t\tlast;\t/* last byte offset logged */\n\tstatic const short\tsoffsets[] = {\t/* table of offsets (short) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_crc),\n\t\tXFS_BTREE_SBLOCK_CRC_LEN\n\t};\n\tstatic const short\tloffsets[] = {\t/* table of offsets (long) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_crc),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_pad),\n\t\tXFS_BTREE_LBLOCK_CRC_LEN\n\t};\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBI(cur, bp, fields);\n\n\tif (bp) {\n\t\tint nbits;\n\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\t/*\n\t\t\t * We don't log the CRC when updating a btree\n\t\t\t * block but instead recreate it during log\n\t\t\t * recovery.  As the log buffers have checksums\n\t\t\t * of their own this is safe and avoids logging a crc\n\t\t\t * update in a lot of places.\n\t\t\t */\n\t\t\tif (fields == XFS_BB_ALL_BITS)\n\t\t\t\tfields = XFS_BB_ALL_BITS_CRC;\n\t\t\tnbits = XFS_BB_NUM_BITS_CRC;\n\t\t} else {\n\t\t\tnbits = XFS_BB_NUM_BITS;\n\t\t}\n\t\txfs_btree_offsets(fields,\n\t\t\t\t  (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\t\t\t\tloffsets : soffsets,\n\t\t\t\t  nbits, &first, &last);\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp, first, last);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_log_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfields)\t/* mask of fields: XFS_BB_... */\n{\n\tint\t\t\tfirst;\t/* first byte offset logged */\n\tint\t\t\tlast;\t/* last byte offset logged */\n\tstatic const short\tsoffsets[] = {\t/* table of offsets (short) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_crc),\n\t\tXFS_BTREE_SBLOCK_CRC_LEN\n\t};\n\tstatic const short\tloffsets[] = {\t/* table of offsets (long) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_crc),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_pad),\n\t\tXFS_BTREE_LBLOCK_CRC_LEN\n\t};\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBI(cur, bp, fields);\n\n\tif (bp) {\n\t\tint nbits;\n\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\t/*\n\t\t\t * We don't log the CRC when updating a btree\n\t\t\t * block but instead recreate it during log\n\t\t\t * recovery.  As the log buffers have checksums\n\t\t\t * of their own this is safe and avoids logging a crc\n\t\t\t * update in a lot of places.\n\t\t\t */\n\t\t\tif (fields == XFS_BB_ALL_BITS)\n\t\t\t\tfields = XFS_BB_ALL_BITS_CRC;\n\t\t\tnbits = XFS_BB_NUM_BITS_CRC;\n\t\t} else {\n\t\t\tnbits = XFS_BB_NUM_BITS;\n\t\t}\n\t\txfs_btree_offsets(fields,\n\t\t\t\t  (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\t\t\t\tloffsets : soffsets,\n\t\t\t\t  nbits, &first, &last);\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp, first, last);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_set_sibling",
          "args": [
            "cur",
            "rrblock",
            "&lptr",
            "XFS_BB_LEFTSIB"
          ],
          "line": 3813
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_set_sibling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "960-980",
          "snippet": "STATIC void\nxfs_btree_set_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tblock->bb_u.l.bb_rightsib = ptr->l;\n\t\telse\n\t\t\tblock->bb_u.l.bb_leftsib = ptr->l;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tblock->bb_u.s.bb_rightsib = ptr->s;\n\t\telse\n\t\t\tblock->bb_u.s.bb_leftsib = ptr->s;\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_set_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tblock->bb_u.l.bb_rightsib = ptr->l;\n\t\telse\n\t\t\tblock->bb_u.l.bb_leftsib = ptr->l;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tblock->bb_u.s.bb_rightsib = ptr->s;\n\t\telse\n\t\t\tblock->bb_u.s.bb_leftsib = ptr->s;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_read_buf_block",
          "args": [
            "cur",
            "&cptr",
            "0",
            "&rrblock",
            "&rrbp"
          ],
          "line": 3810
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_read_buf_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1152-1177",
          "snippet": "STATIC int\nxfs_btree_read_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\tint\t\t\terror;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\terror = xfs_trans_read_buf(mp, cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, flags, bpp,\n\t\t\t\t   cur->bc_ops->buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_set_refs(cur, *bpp);\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_read_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\tint\t\t\terror;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\terror = xfs_trans_read_buf(mp, cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, flags, bpp,\n\t\t\t\t   cur->bc_ops->buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_set_refs(cur, *bpp);\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_is_null",
          "args": [
            "cur",
            "&cptr"
          ],
          "line": 3809
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_is_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "913-922",
          "snippet": "STATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_sibling",
          "args": [
            "cur",
            "left",
            "&cptr",
            "XFS_BB_RIGHTSIB"
          ],
          "line": 3808
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_sibling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "938-958",
          "snippet": "STATIC void\nxfs_btree_get_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->l = block->bb_u.l.bb_rightsib;\n\t\telse\n\t\t\tptr->l = block->bb_u.l.bb_leftsib;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->s = block->bb_u.s.bb_rightsib;\n\t\telse\n\t\t\tptr->s = block->bb_u.s.bb_leftsib;\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_get_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->l = block->bb_u.l.bb_rightsib;\n\t\telse\n\t\t\tptr->l = block->bb_u.l.bb_leftsib;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->s = block->bb_u.s.bb_rightsib;\n\t\telse\n\t\t\tptr->s = block->bb_u.s.bb_leftsib;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_set_numrecs",
          "args": [
            "left",
            "lrecs + rrecs"
          ],
          "line": 3802
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_set_numrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "421-425",
          "snippet": "static inline void xfs_btree_set_numrecs(struct xfs_btree_block *block,\n\t\t__uint16_t numrecs)\n{\n\tblock->bb_numrecs = cpu_to_be16(numrecs);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_btree_set_numrecs(struct xfs_btree_block *block,\n\t\t__uint16_t numrecs)\n{\n\tblock->bb_numrecs = cpu_to_be16(numrecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_INC",
          "args": [
            "cur",
            "join"
          ],
          "line": 3796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_recs",
          "args": [
            "cur",
            "lbp",
            "lrecs + 1",
            "lrecs + rrecs"
          ],
          "line": 3793
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_recs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1307-1323",
          "snippet": "void\nxfs_btree_log_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t  xfs_btree_rec_offset(cur, first),\n\t\t\t  xfs_btree_rec_offset(cur, last + 1) - 1);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_log_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t  xfs_btree_rec_offset(cur, first),\n\t\t\t  xfs_btree_rec_offset(cur, last + 1) - 1);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_copy_recs",
          "args": [
            "cur",
            "lrp",
            "rrp",
            "rrecs"
          ],
          "line": 3792
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_copy_recs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1196-1205",
          "snippet": "STATIC void\nxfs_btree_copy_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*dst_rec,\n\tunion xfs_btree_rec\t*src_rec,\n\tint\t\t\tnumrecs)\n{\n\tASSERT(numrecs >= 0);\n\tmemcpy(dst_rec, src_rec, numrecs * cur->bc_ops->rec_len);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*dst_rec,\n\tunion xfs_btree_rec\t*src_rec,\n\tint\t\t\tnumrecs)\n{\n\tASSERT(numrecs >= 0);\n\tmemcpy(dst_rec, src_rec, numrecs * cur->bc_ops->rec_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_rec_addr",
          "args": [
            "cur",
            "1",
            "right"
          ],
          "line": 3790
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_rec_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "468-476",
          "snippet": "xfs_btree_rec *\nxfs_btree_rec_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_rec *)\n\t\t((char *)block + xfs_btree_rec_offset(cur, n));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_rec *\nxfs_btree_rec_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_rec *)\n\t\t((char *)block + xfs_btree_rec_offset(cur, n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_ptrs",
          "args": [
            "cur",
            "lbp",
            "lrecs + 1",
            "lrecs + rrecs"
          ],
          "line": 3783
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_ptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1328-1352",
          "snippet": "STATIC void\nxfs_btree_log_ptrs(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfirst,\t/* index of first pointer to log */\n\tint\t\t\tlast)\t/* index of last pointer to log */\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\t\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\txfs_btree_ptr_offset(cur, first, level),\n\t\t\t\txfs_btree_ptr_offset(cur, last + 1, level) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_log_ptrs(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfirst,\t/* index of first pointer to log */\n\tint\t\t\tlast)\t/* index of last pointer to log */\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\t\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\txfs_btree_ptr_offset(cur, first, level),\n\t\t\t\txfs_btree_ptr_offset(cur, last + 1, level) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_keys",
          "args": [
            "cur",
            "lbp",
            "lrecs + 1",
            "lrecs + rrecs"
          ],
          "line": 3782
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1281-1302",
          "snippet": "STATIC void\nxfs_btree_log_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\t  xfs_btree_key_offset(cur, first),\n\t\t\t\t  xfs_btree_key_offset(cur, last + 1) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_log_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\t  xfs_btree_key_offset(cur, first),\n\t\t\t\t  xfs_btree_key_offset(cur, last + 1) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_copy_ptrs",
          "args": [
            "cur",
            "lpp",
            "rpp",
            "rrecs"
          ],
          "line": 3780
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_copy_ptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1210-1219",
          "snippet": "STATIC void\nxfs_btree_copy_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*dst_ptr,\n\tunion xfs_btree_ptr\t*src_ptr,\n\tint\t\t\tnumptrs)\n{\n\tASSERT(numptrs >= 0);\n\tmemcpy(dst_ptr, src_ptr, numptrs * xfs_btree_ptr_len(cur));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*dst_ptr,\n\tunion xfs_btree_ptr\t*src_ptr,\n\tint\t\t\tnumptrs)\n{\n\tASSERT(numptrs >= 0);\n\tmemcpy(dst_ptr, src_ptr, numptrs * xfs_btree_ptr_len(cur));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_copy_keys",
          "args": [
            "cur",
            "lkp",
            "rkp",
            "rrecs"
          ],
          "line": 3779
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_copy_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1182-1191",
          "snippet": "STATIC void\nxfs_btree_copy_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*dst_key,\n\tunion xfs_btree_key\t*src_key,\n\tint\t\t\tnumkeys)\n{\n\tASSERT(numkeys >= 0);\n\tmemcpy(dst_key, src_key, numkeys * cur->bc_ops->key_len);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*dst_key,\n\tunion xfs_btree_key\t*src_key,\n\tint\t\t\tnumkeys)\n{\n\tASSERT(numkeys >= 0);\n\tmemcpy(dst_key, src_key, numkeys * cur->bc_ops->key_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_check_ptr",
          "args": [
            "cur",
            "rpp",
            "i",
            "level"
          ],
          "line": 3774
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "201-215",
          "snippet": "STATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_ptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tunion xfs_btree_ptr\t*ptr,\t/* btree block disk address */\n\tint\t\t\tindex,\t/* offset from ptr to check */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\treturn xfs_btree_check_lptr(cur,\n\t\t\t\tbe64_to_cpu((&ptr->l)[index]), level);\n\t} else {\n\t\treturn xfs_btree_check_sptr(cur,\n\t\t\t\tbe32_to_cpu((&ptr->s)[index]), level);\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_ptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tunion xfs_btree_ptr\t*ptr,\t/* btree block disk address */\n\tint\t\t\tindex,\t/* offset from ptr to check */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\treturn xfs_btree_check_lptr(cur,\n\t\t\t\tbe64_to_cpu((&ptr->l)[index]), level);\n\t} else {\n\t\treturn xfs_btree_check_sptr(cur,\n\t\t\t\tbe32_to_cpu((&ptr->s)[index]), level);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_addr",
          "args": [
            "cur",
            "1",
            "right"
          ],
          "line": 3771
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "494-506",
          "snippet": "xfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_key_addr",
          "args": [
            "cur",
            "1",
            "right"
          ],
          "line": 3770
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_key_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "481-489",
          "snippet": "xfs_btree_key *\nxfs_btree_key_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_key *)\n\t\t((char *)block + xfs_btree_key_offset(cur, n));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_key *\nxfs_btree_key_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_key *)\n\t\t((char *)block + xfs_btree_key_offset(cur, n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_ADD",
          "args": [
            "cur",
            "moves",
            "rrecs"
          ],
          "line": 3760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_numrecs",
          "args": [
            "left"
          ],
          "line": 3754
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_numrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "416-419",
          "snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_dec_cursor",
          "args": [
            "cur",
            "level",
            "stat"
          ],
          "line": 3747
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_dec_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "3321-3339",
          "snippet": "STATIC int\nxfs_btree_dec_cursor(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\n{\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\tif (level > 0) {\n\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_btree_dec_cursor(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\n{\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\tif (level > 0) {\n\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->get_maxrecs",
          "args": [
            "cur",
            "level"
          ],
          "line": 3730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->get_maxrecs",
          "args": [
            "cur",
            "level"
          ],
          "line": 3713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!xfs_btree_ptr_is_null(cur, &cptr)"
          ],
          "line": 3709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 3691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_btree_get_numrecs(block) >=\n\t\t\t\t       cur->bc_ops->get_minrecs(tcur, level)"
          ],
          "line": 3685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->get_minrecs",
          "args": [
            "tcur",
            "level"
          ],
          "line": 3686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_rshift",
          "args": [
            "tcur",
            "level",
            "&i"
          ],
          "line": 3681
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_rshift",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "2148-2317",
          "snippet": "STATIC int\t\t\t\t\t/* error */\nxfs_btree_rshift(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tunion xfs_btree_key\tkey;\t\t/* btree key */\n\tstruct xfs_buf\t\t*lbp;\t\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t\t/* left btree block */\n\tstruct xfs_buf\t\t*rbp;\t\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t\t/* right btree block */\n\tstruct xfs_btree_cur\t*tcur;\t\t/* temporary btree cursor */\n\tunion xfs_btree_ptr\trptr;\t\t/* right block pointer */\n\tunion xfs_btree_key\t*rkp;\t\t/* right btree key */\n\tint\t\t\trrecs;\t\t/* right record count */\n\tint\t\t\tlrecs;\t\t/* left record count */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* loop counter */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1))\n\t\tgoto out0;\n\n\t/* Set up variables for this block as \"left\". */\n\tleft = xfs_btree_get_block(cur, level, &lbp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, left, level, lbp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* If we've got no right sibling then we can't shift an entry right. */\n\txfs_btree_get_sibling(cur, left, &rptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &rptr))\n\t\tgoto out0;\n\n\t/*\n\t * If the cursor entry is the one that would be moved, don't\n\t * do it... it's too complicated.\n\t */\n\tlrecs = xfs_btree_get_numrecs(left);\n\tif (cur->bc_ptrs[level] >= lrecs)\n\t\tgoto out0;\n\n\t/* Set up the right neighbor as \"right\". */\n\terror = xfs_btree_read_buf_block(cur, &rptr, 0, &right, &rbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* If it's full, it can't take another entry. */\n\trrecs = xfs_btree_get_numrecs(right);\n\tif (rrecs == cur->bc_ops->get_maxrecs(cur, level))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, rshift);\n\tXFS_BTREE_STATS_ADD(cur, moves, rrecs);\n\n\t/*\n\t * Make a hole at the start of the right neighbor block, then\n\t * copy the last left block entry to the hole.\n\t */\n\tif (level > 0) {\n\t\t/* It's a nonleaf. make a hole in the keys and ptrs */\n\t\tunion xfs_btree_key\t*lkp;\n\t\tunion xfs_btree_ptr\t*lpp;\n\t\tunion xfs_btree_ptr\t*rpp;\n\n\t\tlkp = xfs_btree_key_addr(cur, lrecs, left);\n\t\tlpp = xfs_btree_ptr_addr(cur, lrecs, left);\n\t\trkp = xfs_btree_key_addr(cur, 1, right);\n\t\trpp = xfs_btree_ptr_addr(cur, 1, right);\n\n#ifdef DEBUG\n\t\tfor (i = rrecs - 1; i >= 0; i--) {\n\t\t\terror = xfs_btree_check_ptr(cur, rpp, i, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\n\t\txfs_btree_shift_keys(cur, rkp, 1, rrecs);\n\t\txfs_btree_shift_ptrs(cur, rpp, 1, rrecs);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_ptr(cur, lpp, 0, level);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\t/* Now put the new data in, and log it. */\n\t\txfs_btree_copy_keys(cur, rkp, lkp, 1);\n\t\txfs_btree_copy_ptrs(cur, rpp, lpp, 1);\n\n\t\txfs_btree_log_keys(cur, rbp, 1, rrecs + 1);\n\t\txfs_btree_log_ptrs(cur, rbp, 1, rrecs + 1);\n\n\t\tASSERT(cur->bc_ops->keys_inorder(cur, rkp,\n\t\t\txfs_btree_key_addr(cur, 2, right)));\n\t} else {\n\t\t/* It's a leaf. make a hole in the records */\n\t\tunion xfs_btree_rec\t*lrp;\n\t\tunion xfs_btree_rec\t*rrp;\n\n\t\tlrp = xfs_btree_rec_addr(cur, lrecs, left);\n\t\trrp = xfs_btree_rec_addr(cur, 1, right);\n\n\t\txfs_btree_shift_recs(cur, rrp, 1, rrecs);\n\n\t\t/* Now put the new data in, and log it. */\n\t\txfs_btree_copy_recs(cur, rrp, lrp, 1);\n\t\txfs_btree_log_recs(cur, rbp, 1, rrecs + 1);\n\n\t\tcur->bc_ops->init_key_from_rec(&key, rrp);\n\t\trkp = &key;\n\n\t\tASSERT(cur->bc_ops->recs_inorder(cur, rrp,\n\t\t\txfs_btree_rec_addr(cur, 2, right)));\n\t}\n\n\t/*\n\t * Decrement and log left's numrecs, bump and log right's numrecs.\n\t */\n\txfs_btree_set_numrecs(left, --lrecs);\n\txfs_btree_log_block(cur, lbp, XFS_BB_NUMRECS);\n\n\txfs_btree_set_numrecs(right, ++rrecs);\n\txfs_btree_log_block(cur, rbp, XFS_BB_NUMRECS);\n\n\t/*\n\t * Using a temporary cursor, update the parent key values of the\n\t * block on the right.\n\t */\n\terror = xfs_btree_dup_cursor(cur, &tcur);\n\tif (error)\n\t\tgoto error0;\n\ti = xfs_btree_lastrec(tcur, level);\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\terror = xfs_btree_increment(tcur, level, &i);\n\tif (error)\n\t\tgoto error1;\n\n\terror = xfs_btree_updkey(tcur, rkp, level + 1);\n\tif (error)\n\t\tgoto error1;\n\n\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n\nerror1:\n\tXFS_BTREE_TRACE_CURSOR(tcur, XBT_ERROR);\n\txfs_btree_del_cursor(tcur, XFS_BTREE_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\t\t\t\t\t/* error */\nxfs_btree_rshift(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tunion xfs_btree_key\tkey;\t\t/* btree key */\n\tstruct xfs_buf\t\t*lbp;\t\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t\t/* left btree block */\n\tstruct xfs_buf\t\t*rbp;\t\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t\t/* right btree block */\n\tstruct xfs_btree_cur\t*tcur;\t\t/* temporary btree cursor */\n\tunion xfs_btree_ptr\trptr;\t\t/* right block pointer */\n\tunion xfs_btree_key\t*rkp;\t\t/* right btree key */\n\tint\t\t\trrecs;\t\t/* right record count */\n\tint\t\t\tlrecs;\t\t/* left record count */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* loop counter */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1))\n\t\tgoto out0;\n\n\t/* Set up variables for this block as \"left\". */\n\tleft = xfs_btree_get_block(cur, level, &lbp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, left, level, lbp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* If we've got no right sibling then we can't shift an entry right. */\n\txfs_btree_get_sibling(cur, left, &rptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &rptr))\n\t\tgoto out0;\n\n\t/*\n\t * If the cursor entry is the one that would be moved, don't\n\t * do it... it's too complicated.\n\t */\n\tlrecs = xfs_btree_get_numrecs(left);\n\tif (cur->bc_ptrs[level] >= lrecs)\n\t\tgoto out0;\n\n\t/* Set up the right neighbor as \"right\". */\n\terror = xfs_btree_read_buf_block(cur, &rptr, 0, &right, &rbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* If it's full, it can't take another entry. */\n\trrecs = xfs_btree_get_numrecs(right);\n\tif (rrecs == cur->bc_ops->get_maxrecs(cur, level))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, rshift);\n\tXFS_BTREE_STATS_ADD(cur, moves, rrecs);\n\n\t/*\n\t * Make a hole at the start of the right neighbor block, then\n\t * copy the last left block entry to the hole.\n\t */\n\tif (level > 0) {\n\t\t/* It's a nonleaf. make a hole in the keys and ptrs */\n\t\tunion xfs_btree_key\t*lkp;\n\t\tunion xfs_btree_ptr\t*lpp;\n\t\tunion xfs_btree_ptr\t*rpp;\n\n\t\tlkp = xfs_btree_key_addr(cur, lrecs, left);\n\t\tlpp = xfs_btree_ptr_addr(cur, lrecs, left);\n\t\trkp = xfs_btree_key_addr(cur, 1, right);\n\t\trpp = xfs_btree_ptr_addr(cur, 1, right);\n\n#ifdef DEBUG\n\t\tfor (i = rrecs - 1; i >= 0; i--) {\n\t\t\terror = xfs_btree_check_ptr(cur, rpp, i, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\n\t\txfs_btree_shift_keys(cur, rkp, 1, rrecs);\n\t\txfs_btree_shift_ptrs(cur, rpp, 1, rrecs);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_ptr(cur, lpp, 0, level);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\t/* Now put the new data in, and log it. */\n\t\txfs_btree_copy_keys(cur, rkp, lkp, 1);\n\t\txfs_btree_copy_ptrs(cur, rpp, lpp, 1);\n\n\t\txfs_btree_log_keys(cur, rbp, 1, rrecs + 1);\n\t\txfs_btree_log_ptrs(cur, rbp, 1, rrecs + 1);\n\n\t\tASSERT(cur->bc_ops->keys_inorder(cur, rkp,\n\t\t\txfs_btree_key_addr(cur, 2, right)));\n\t} else {\n\t\t/* It's a leaf. make a hole in the records */\n\t\tunion xfs_btree_rec\t*lrp;\n\t\tunion xfs_btree_rec\t*rrp;\n\n\t\tlrp = xfs_btree_rec_addr(cur, lrecs, left);\n\t\trrp = xfs_btree_rec_addr(cur, 1, right);\n\n\t\txfs_btree_shift_recs(cur, rrp, 1, rrecs);\n\n\t\t/* Now put the new data in, and log it. */\n\t\txfs_btree_copy_recs(cur, rrp, lrp, 1);\n\t\txfs_btree_log_recs(cur, rbp, 1, rrecs + 1);\n\n\t\tcur->bc_ops->init_key_from_rec(&key, rrp);\n\t\trkp = &key;\n\n\t\tASSERT(cur->bc_ops->recs_inorder(cur, rrp,\n\t\t\txfs_btree_rec_addr(cur, 2, right)));\n\t}\n\n\t/*\n\t * Decrement and log left's numrecs, bump and log right's numrecs.\n\t */\n\txfs_btree_set_numrecs(left, --lrecs);\n\txfs_btree_log_block(cur, lbp, XFS_BB_NUMRECS);\n\n\txfs_btree_set_numrecs(right, ++rrecs);\n\txfs_btree_log_block(cur, rbp, XFS_BB_NUMRECS);\n\n\t/*\n\t * Using a temporary cursor, update the parent key values of the\n\t * block on the right.\n\t */\n\terror = xfs_btree_dup_cursor(cur, &tcur);\n\tif (error)\n\t\tgoto error0;\n\ti = xfs_btree_lastrec(tcur, level);\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\terror = xfs_btree_increment(tcur, level, &i);\n\tif (error)\n\t\tgoto error1;\n\n\terror = xfs_btree_updkey(tcur, rkp, level + 1);\n\tif (error)\n\t\tgoto error1;\n\n\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n\nerror1:\n\tXFS_BTREE_TRACE_CURSOR(tcur, XBT_ERROR);\n\txfs_btree_del_cursor(tcur, XFS_BTREE_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->get_minrecs",
          "args": [
            "tcur",
            "level"
          ],
          "line": 3680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_check_block",
          "args": [
            "cur",
            "left",
            "level",
            "lbp"
          ],
          "line": 3667
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "149-160",
          "snippet": "int\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_block",
          "args": [
            "tcur",
            "level",
            "&lbp"
          ],
          "line": 3665
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "528-542",
          "snippet": "xfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 3662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_firstrec",
          "args": [
            "tcur",
            "level"
          ],
          "line": 3661
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_firstrec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "605-628",
          "snippet": "STATIC int\t\t\t\t/* success=1, failure=0 */\nxfs_btree_firstrec(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel)\t/* level to change */\n{\n\tstruct xfs_btree_block\t*block;\t/* generic btree block pointer */\n\txfs_buf_t\t\t*bp;\t/* buffer containing block */\n\n\t/*\n\t * Get the block pointer for this level.\n\t */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\txfs_btree_check_block(cur, block, level, bp);\n\t/*\n\t * It's empty, there is no such record.\n\t */\n\tif (!block->bb_numrecs)\n\t\treturn 0;\n\t/*\n\t * Set the ptr value to 1, that's the first record/key.\n\t */\n\tcur->bc_ptrs[level] = 1;\n\treturn 1;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\t\t\t\t/* success=1, failure=0 */\nxfs_btree_firstrec(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel)\t/* level to change */\n{\n\tstruct xfs_btree_block\t*block;\t/* generic btree block pointer */\n\txfs_buf_t\t\t*bp;\t/* buffer containing block */\n\n\t/*\n\t * Get the block pointer for this level.\n\t */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\txfs_btree_check_block(cur, block, level, bp);\n\t/*\n\t * It's empty, there is no such record.\n\t */\n\tif (!block->bb_numrecs)\n\t\treturn 0;\n\t/*\n\t * Set the ptr value to 1, that's the first record/key.\n\t */\n\tcur->bc_ptrs[level] = 1;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_decrement",
          "args": [
            "tcur",
            "level",
            "&i"
          ],
          "line": 3658
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_decrement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1539-1631",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 3656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 3642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 3637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_btree_get_numrecs(block) >=\n\t\t\t\t       cur->bc_ops->get_minrecs(tcur, level)"
          ],
          "line": 3616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->get_minrecs",
          "args": [
            "tcur",
            "level"
          ],
          "line": 3617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_lshift",
          "args": [
            "tcur",
            "level",
            "&i"
          ],
          "line": 3612
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_lshift",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1965-2142",
          "snippet": "STATIC int\t\t\t\t\t/* error */\nxfs_btree_lshift(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tunion xfs_btree_key\tkey;\t\t/* btree key */\n\tstruct xfs_buf\t\t*lbp;\t\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t\t/* left btree block */\n\tint\t\t\tlrecs;\t\t/* left record count */\n\tstruct xfs_buf\t\t*rbp;\t\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t\t/* right btree block */\n\tint\t\t\trrecs;\t\t/* right record count */\n\tunion xfs_btree_ptr\tlptr;\t\t/* left btree pointer */\n\tunion xfs_btree_key\t*rkp = NULL;\t/* right btree key */\n\tunion xfs_btree_ptr\t*rpp = NULL;\t/* right address pointer */\n\tunion xfs_btree_rec\t*rrp = NULL;\t/* right record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    level == cur->bc_nlevels - 1)\n\t\tgoto out0;\n\n\t/* Set up variables for this block as \"right\". */\n\tright = xfs_btree_get_block(cur, level, &rbp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, right, level, rbp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* If we've got no left sibling then we can't shift an entry left. */\n\txfs_btree_get_sibling(cur, right, &lptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &lptr))\n\t\tgoto out0;\n\n\t/*\n\t * If the cursor entry is the one that would be moved, don't\n\t * do it... it's too complicated.\n\t */\n\tif (cur->bc_ptrs[level] <= 1)\n\t\tgoto out0;\n\n\t/* Set up the left neighbor as \"left\". */\n\terror = xfs_btree_read_buf_block(cur, &lptr, 0, &left, &lbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* If it's full, it can't take another entry. */\n\tlrecs = xfs_btree_get_numrecs(left);\n\tif (lrecs == cur->bc_ops->get_maxrecs(cur, level))\n\t\tgoto out0;\n\n\trrecs = xfs_btree_get_numrecs(right);\n\n\t/*\n\t * We add one entry to the left side and remove one for the right side.\n\t * Account for it here, the changes will be updated on disk and logged\n\t * later.\n\t */\n\tlrecs++;\n\trrecs--;\n\n\tXFS_BTREE_STATS_INC(cur, lshift);\n\tXFS_BTREE_STATS_ADD(cur, moves, 1);\n\n\t/*\n\t * If non-leaf, copy a key and a ptr to the left block.\n\t * Log the changes to the left block.\n\t */\n\tif (level > 0) {\n\t\t/* It's a non-leaf.  Move keys and pointers. */\n\t\tunion xfs_btree_key\t*lkp;\t/* left btree key */\n\t\tunion xfs_btree_ptr\t*lpp;\t/* left address pointer */\n\n\t\tlkp = xfs_btree_key_addr(cur, lrecs, left);\n\t\trkp = xfs_btree_key_addr(cur, 1, right);\n\n\t\tlpp = xfs_btree_ptr_addr(cur, lrecs, left);\n\t\trpp = xfs_btree_ptr_addr(cur, 1, right);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_ptr(cur, rpp, 0, level);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\t\txfs_btree_copy_keys(cur, lkp, rkp, 1);\n\t\txfs_btree_copy_ptrs(cur, lpp, rpp, 1);\n\n\t\txfs_btree_log_keys(cur, lbp, lrecs, lrecs);\n\t\txfs_btree_log_ptrs(cur, lbp, lrecs, lrecs);\n\n\t\tASSERT(cur->bc_ops->keys_inorder(cur,\n\t\t\txfs_btree_key_addr(cur, lrecs - 1, left), lkp));\n\t} else {\n\t\t/* It's a leaf.  Move records.  */\n\t\tunion xfs_btree_rec\t*lrp;\t/* left record pointer */\n\n\t\tlrp = xfs_btree_rec_addr(cur, lrecs, left);\n\t\trrp = xfs_btree_rec_addr(cur, 1, right);\n\n\t\txfs_btree_copy_recs(cur, lrp, rrp, 1);\n\t\txfs_btree_log_recs(cur, lbp, lrecs, lrecs);\n\n\t\tASSERT(cur->bc_ops->recs_inorder(cur,\n\t\t\txfs_btree_rec_addr(cur, lrecs - 1, left), lrp));\n\t}\n\n\txfs_btree_set_numrecs(left, lrecs);\n\txfs_btree_log_block(cur, lbp, XFS_BB_NUMRECS);\n\n\txfs_btree_set_numrecs(right, rrecs);\n\txfs_btree_log_block(cur, rbp, XFS_BB_NUMRECS);\n\n\t/*\n\t * Slide the contents of right down one entry.\n\t */\n\tXFS_BTREE_STATS_ADD(cur, moves, rrecs - 1);\n\tif (level > 0) {\n\t\t/* It's a nonleaf. operate on keys and ptrs */\n#ifdef DEBUG\n\t\tint\t\t\ti;\t\t/* loop index */\n\n\t\tfor (i = 0; i < rrecs; i++) {\n\t\t\terror = xfs_btree_check_ptr(cur, rpp, i + 1, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\t\txfs_btree_shift_keys(cur,\n\t\t\t\txfs_btree_key_addr(cur, 2, right),\n\t\t\t\t-1, rrecs);\n\t\txfs_btree_shift_ptrs(cur,\n\t\t\t\txfs_btree_ptr_addr(cur, 2, right),\n\t\t\t\t-1, rrecs);\n\n\t\txfs_btree_log_keys(cur, rbp, 1, rrecs);\n\t\txfs_btree_log_ptrs(cur, rbp, 1, rrecs);\n\t} else {\n\t\t/* It's a leaf. operate on records */\n\t\txfs_btree_shift_recs(cur,\n\t\t\txfs_btree_rec_addr(cur, 2, right),\n\t\t\t-1, rrecs);\n\t\txfs_btree_log_recs(cur, rbp, 1, rrecs);\n\n\t\t/*\n\t\t * If it's the first record in the block, we'll need a key\n\t\t * structure to pass up to the next level (updkey).\n\t\t */\n\t\tcur->bc_ops->init_key_from_rec(&key,\n\t\t\txfs_btree_rec_addr(cur, 1, right));\n\t\trkp = &key;\n\t}\n\n\t/* Update the parent key values of right. */\n\terror = xfs_btree_updkey(cur, rkp, level + 1);\n\tif (error)\n\t\tgoto error0;\n\n\t/* Slide the cursor value left one. */\n\tcur->bc_ptrs[level]--;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\t\t\t\t\t/* error */\nxfs_btree_lshift(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tunion xfs_btree_key\tkey;\t\t/* btree key */\n\tstruct xfs_buf\t\t*lbp;\t\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t\t/* left btree block */\n\tint\t\t\tlrecs;\t\t/* left record count */\n\tstruct xfs_buf\t\t*rbp;\t\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t\t/* right btree block */\n\tint\t\t\trrecs;\t\t/* right record count */\n\tunion xfs_btree_ptr\tlptr;\t\t/* left btree pointer */\n\tunion xfs_btree_key\t*rkp = NULL;\t/* right btree key */\n\tunion xfs_btree_ptr\t*rpp = NULL;\t/* right address pointer */\n\tunion xfs_btree_rec\t*rrp = NULL;\t/* right record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    level == cur->bc_nlevels - 1)\n\t\tgoto out0;\n\n\t/* Set up variables for this block as \"right\". */\n\tright = xfs_btree_get_block(cur, level, &rbp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, right, level, rbp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* If we've got no left sibling then we can't shift an entry left. */\n\txfs_btree_get_sibling(cur, right, &lptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &lptr))\n\t\tgoto out0;\n\n\t/*\n\t * If the cursor entry is the one that would be moved, don't\n\t * do it... it's too complicated.\n\t */\n\tif (cur->bc_ptrs[level] <= 1)\n\t\tgoto out0;\n\n\t/* Set up the left neighbor as \"left\". */\n\terror = xfs_btree_read_buf_block(cur, &lptr, 0, &left, &lbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* If it's full, it can't take another entry. */\n\tlrecs = xfs_btree_get_numrecs(left);\n\tif (lrecs == cur->bc_ops->get_maxrecs(cur, level))\n\t\tgoto out0;\n\n\trrecs = xfs_btree_get_numrecs(right);\n\n\t/*\n\t * We add one entry to the left side and remove one for the right side.\n\t * Account for it here, the changes will be updated on disk and logged\n\t * later.\n\t */\n\tlrecs++;\n\trrecs--;\n\n\tXFS_BTREE_STATS_INC(cur, lshift);\n\tXFS_BTREE_STATS_ADD(cur, moves, 1);\n\n\t/*\n\t * If non-leaf, copy a key and a ptr to the left block.\n\t * Log the changes to the left block.\n\t */\n\tif (level > 0) {\n\t\t/* It's a non-leaf.  Move keys and pointers. */\n\t\tunion xfs_btree_key\t*lkp;\t/* left btree key */\n\t\tunion xfs_btree_ptr\t*lpp;\t/* left address pointer */\n\n\t\tlkp = xfs_btree_key_addr(cur, lrecs, left);\n\t\trkp = xfs_btree_key_addr(cur, 1, right);\n\n\t\tlpp = xfs_btree_ptr_addr(cur, lrecs, left);\n\t\trpp = xfs_btree_ptr_addr(cur, 1, right);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_ptr(cur, rpp, 0, level);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\t\txfs_btree_copy_keys(cur, lkp, rkp, 1);\n\t\txfs_btree_copy_ptrs(cur, lpp, rpp, 1);\n\n\t\txfs_btree_log_keys(cur, lbp, lrecs, lrecs);\n\t\txfs_btree_log_ptrs(cur, lbp, lrecs, lrecs);\n\n\t\tASSERT(cur->bc_ops->keys_inorder(cur,\n\t\t\txfs_btree_key_addr(cur, lrecs - 1, left), lkp));\n\t} else {\n\t\t/* It's a leaf.  Move records.  */\n\t\tunion xfs_btree_rec\t*lrp;\t/* left record pointer */\n\n\t\tlrp = xfs_btree_rec_addr(cur, lrecs, left);\n\t\trrp = xfs_btree_rec_addr(cur, 1, right);\n\n\t\txfs_btree_copy_recs(cur, lrp, rrp, 1);\n\t\txfs_btree_log_recs(cur, lbp, lrecs, lrecs);\n\n\t\tASSERT(cur->bc_ops->recs_inorder(cur,\n\t\t\txfs_btree_rec_addr(cur, lrecs - 1, left), lrp));\n\t}\n\n\txfs_btree_set_numrecs(left, lrecs);\n\txfs_btree_log_block(cur, lbp, XFS_BB_NUMRECS);\n\n\txfs_btree_set_numrecs(right, rrecs);\n\txfs_btree_log_block(cur, rbp, XFS_BB_NUMRECS);\n\n\t/*\n\t * Slide the contents of right down one entry.\n\t */\n\tXFS_BTREE_STATS_ADD(cur, moves, rrecs - 1);\n\tif (level > 0) {\n\t\t/* It's a nonleaf. operate on keys and ptrs */\n#ifdef DEBUG\n\t\tint\t\t\ti;\t\t/* loop index */\n\n\t\tfor (i = 0; i < rrecs; i++) {\n\t\t\terror = xfs_btree_check_ptr(cur, rpp, i + 1, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\t\txfs_btree_shift_keys(cur,\n\t\t\t\txfs_btree_key_addr(cur, 2, right),\n\t\t\t\t-1, rrecs);\n\t\txfs_btree_shift_ptrs(cur,\n\t\t\t\txfs_btree_ptr_addr(cur, 2, right),\n\t\t\t\t-1, rrecs);\n\n\t\txfs_btree_log_keys(cur, rbp, 1, rrecs);\n\t\txfs_btree_log_ptrs(cur, rbp, 1, rrecs);\n\t} else {\n\t\t/* It's a leaf. operate on records */\n\t\txfs_btree_shift_recs(cur,\n\t\t\txfs_btree_rec_addr(cur, 2, right),\n\t\t\t-1, rrecs);\n\t\txfs_btree_log_recs(cur, rbp, 1, rrecs);\n\n\t\t/*\n\t\t * If it's the first record in the block, we'll need a key\n\t\t * structure to pass up to the next level (updkey).\n\t\t */\n\t\tcur->bc_ops->init_key_from_rec(&key,\n\t\t\txfs_btree_rec_addr(cur, 1, right));\n\t\trkp = &key;\n\t}\n\n\t/* Update the parent key values of right. */\n\terror = xfs_btree_updkey(cur, rkp, level + 1);\n\tif (error)\n\t\tgoto error0;\n\n\t/* Slide the cursor value left one. */\n\tcur->bc_ptrs[level]--;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->get_minrecs",
          "args": [
            "tcur",
            "level"
          ],
          "line": 3611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 3593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_lastrec",
          "args": [
            "tcur",
            "level"
          ],
          "line": 3592
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_lastrec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "634-657",
          "snippet": "STATIC int\t\t\t\t/* success=1, failure=0 */\nxfs_btree_lastrec(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel)\t/* level to change */\n{\n\tstruct xfs_btree_block\t*block;\t/* generic btree block pointer */\n\txfs_buf_t\t\t*bp;\t/* buffer containing block */\n\n\t/*\n\t * Get the block pointer for this level.\n\t */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\txfs_btree_check_block(cur, block, level, bp);\n\t/*\n\t * It's empty, there is no such record.\n\t */\n\tif (!block->bb_numrecs)\n\t\treturn 0;\n\t/*\n\t * Set the ptr value to numrecs, that's the last record/key.\n\t */\n\tcur->bc_ptrs[level] = be16_to_cpu(block->bb_numrecs);\n\treturn 1;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\t\t\t\t/* success=1, failure=0 */\nxfs_btree_lastrec(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel)\t/* level to change */\n{\n\tstruct xfs_btree_block\t*block;\t/* generic btree block pointer */\n\txfs_buf_t\t\t*bp;\t/* buffer containing block */\n\n\t/*\n\t * Get the block pointer for this level.\n\t */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\txfs_btree_check_block(cur, block, level, bp);\n\t/*\n\t * It's empty, there is no such record.\n\t */\n\tif (!block->bb_numrecs)\n\t\treturn 0;\n\t/*\n\t * Set the ptr value to numrecs, that's the last record/key.\n\t */\n\tcur->bc_ptrs[level] = be16_to_cpu(block->bb_numrecs);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 3590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 3585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_dup_cursor",
          "args": [
            "cur",
            "&tcur"
          ],
          "line": 3571
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_dup_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "324-371",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_dup_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* input cursor */\n\txfs_btree_cur_t\t**ncur)\t\t/* output cursor */\n{\n\txfs_buf_t\t*bp;\t\t/* btree block's buffer pointer */\n\tint\t\terror;\t\t/* error return value */\n\tint\t\ti;\t\t/* level number of btree block */\n\txfs_mount_t\t*mp;\t\t/* mount structure for filesystem */\n\txfs_btree_cur_t\t*new;\t\t/* new cursor value */\n\txfs_trans_t\t*tp;\t\t/* transaction pointer, can be NULL */\n\n\ttp = cur->bc_tp;\n\tmp = cur->bc_mp;\n\n\t/*\n\t * Allocate a new cursor like the old one.\n\t */\n\tnew = cur->bc_ops->dup_cursor(cur);\n\n\t/*\n\t * Copy the record currently in the cursor.\n\t */\n\tnew->bc_rec = cur->bc_rec;\n\n\t/*\n\t * For each level current, re-get the buffer and copy the ptr value.\n\t */\n\tfor (i = 0; i < new->bc_nlevels; i++) {\n\t\tnew->bc_ptrs[i] = cur->bc_ptrs[i];\n\t\tnew->bc_ra[i] = cur->bc_ra[i];\n\t\tbp = cur->bc_bufs[i];\n\t\tif (bp) {\n\t\t\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t\t\t   XFS_BUF_ADDR(bp), mp->m_bsize,\n\t\t\t\t\t\t   0, &bp,\n\t\t\t\t\t\t   cur->bc_ops->buf_ops);\n\t\t\tif (error) {\n\t\t\t\txfs_btree_del_cursor(new, error);\n\t\t\t\t*ncur = NULL;\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tnew->bc_bufs[i] = bp;\n\t}\n\t*ncur = new;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_btree_dup_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* input cursor */\n\txfs_btree_cur_t\t**ncur)\t\t/* output cursor */\n{\n\txfs_buf_t\t*bp;\t\t/* btree block's buffer pointer */\n\tint\t\terror;\t\t/* error return value */\n\tint\t\ti;\t\t/* level number of btree block */\n\txfs_mount_t\t*mp;\t\t/* mount structure for filesystem */\n\txfs_btree_cur_t\t*new;\t\t/* new cursor value */\n\txfs_trans_t\t*tp;\t\t/* transaction pointer, can be NULL */\n\n\ttp = cur->bc_tp;\n\tmp = cur->bc_mp;\n\n\t/*\n\t * Allocate a new cursor like the old one.\n\t */\n\tnew = cur->bc_ops->dup_cursor(cur);\n\n\t/*\n\t * Copy the record currently in the cursor.\n\t */\n\tnew->bc_rec = cur->bc_rec;\n\n\t/*\n\t * For each level current, re-get the buffer and copy the ptr value.\n\t */\n\tfor (i = 0; i < new->bc_nlevels; i++) {\n\t\tnew->bc_ptrs[i] = cur->bc_ptrs[i];\n\t\tnew->bc_ra[i] = cur->bc_ra[i];\n\t\tbp = cur->bc_bufs[i];\n\t\tif (bp) {\n\t\t\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t\t\t   XFS_BUF_ADDR(bp), mp->m_bsize,\n\t\t\t\t\t\t   0, &bp,\n\t\t\t\t\t\t   cur->bc_ops->buf_ops);\n\t\t\tif (error) {\n\t\t\t\txfs_btree_del_cursor(new, error);\n\t\t\t\t*ncur = NULL;\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tnew->bc_bufs[i] = bp;\n\t}\n\t*ncur = new;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!xfs_btree_ptr_is_null(cur, &rptr) ||\n\t       !xfs_btree_ptr_is_null(cur, &lptr)"
          ],
          "line": 3564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_kill_iroot",
          "args": [
            "cur"
          ],
          "line": 3555
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_kill_iroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "3180-3282",
          "snippet": "STATIC int\nxfs_btree_kill_iroot(\n\tstruct xfs_btree_cur\t*cur)\n{\n\tint\t\t\twhichfork = cur->bc_private.b.whichfork;\n\tstruct xfs_inode\t*ip = cur->bc_private.b.ip;\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_btree_block\t*cblock;\n\tunion xfs_btree_key\t*kp;\n\tunion xfs_btree_key\t*ckp;\n\tunion xfs_btree_ptr\t*pp;\n\tunion xfs_btree_ptr\t*cpp;\n\tstruct xfs_buf\t\t*cbp;\n\tint\t\t\tlevel;\n\tint\t\t\tindex;\n\tint\t\t\tnumrecs;\n#ifdef DEBUG\n\tunion xfs_btree_ptr\tptr;\n\tint\t\t\ti;\n#endif\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\tASSERT(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE);\n\tASSERT(cur->bc_nlevels > 1);\n\n\t/*\n\t * Don't deal with the root block needs to be a leaf case.\n\t * We're just going to turn the thing back into extents anyway.\n\t */\n\tlevel = cur->bc_nlevels - 1;\n\tif (level == 1)\n\t\tgoto out0;\n\n\t/*\n\t * Give up if the root has multiple children.\n\t */\n\tblock = xfs_btree_get_iroot(cur);\n\tif (xfs_btree_get_numrecs(block) != 1)\n\t\tgoto out0;\n\n\tcblock = xfs_btree_get_block(cur, level - 1, &cbp);\n\tnumrecs = xfs_btree_get_numrecs(cblock);\n\n\t/*\n\t * Only do this if the next level will fit.\n\t * Then the data must be copied up to the inode,\n\t * instead of freeing the root you free the next level.\n\t */\n\tif (numrecs > cur->bc_ops->get_dmaxrecs(cur, level))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, killroot);\n\n#ifdef DEBUG\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tASSERT(xfs_btree_ptr_is_null(cur, &ptr));\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tASSERT(xfs_btree_ptr_is_null(cur, &ptr));\n#endif\n\n\tindex = numrecs - cur->bc_ops->get_maxrecs(cur, level);\n\tif (index) {\n\t\txfs_iroot_realloc(cur->bc_private.b.ip, index,\n\t\t\t\t  cur->bc_private.b.whichfork);\n\t\tblock = ifp->if_broot;\n\t}\n\n\tbe16_add_cpu(&block->bb_numrecs, index);\n\tASSERT(block->bb_numrecs == cblock->bb_numrecs);\n\n\tkp = xfs_btree_key_addr(cur, 1, block);\n\tckp = xfs_btree_key_addr(cur, 1, cblock);\n\txfs_btree_copy_keys(cur, kp, ckp, numrecs);\n\n\tpp = xfs_btree_ptr_addr(cur, 1, block);\n\tcpp = xfs_btree_ptr_addr(cur, 1, cblock);\n#ifdef DEBUG\n\tfor (i = 0; i < numrecs; i++) {\n\t\tint\t\terror;\n\n\t\terror = xfs_btree_check_ptr(cur, cpp, i, level - 1);\n\t\tif (error) {\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\txfs_btree_copy_ptrs(cur, pp, cpp, numrecs);\n\n\tcur->bc_ops->free_block(cur, cbp);\n\tXFS_BTREE_STATS_INC(cur, free);\n\n\tcur->bc_bufs[level - 1] = NULL;\n\tbe16_add_cpu(&block->bb_level, -1);\n\txfs_trans_log_inode(cur->bc_tp, ip,\n\t\tXFS_ILOG_CORE | xfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\tcur->bc_nlevels--;\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_kill_iroot(\n\tstruct xfs_btree_cur\t*cur)\n{\n\tint\t\t\twhichfork = cur->bc_private.b.whichfork;\n\tstruct xfs_inode\t*ip = cur->bc_private.b.ip;\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_btree_block\t*cblock;\n\tunion xfs_btree_key\t*kp;\n\tunion xfs_btree_key\t*ckp;\n\tunion xfs_btree_ptr\t*pp;\n\tunion xfs_btree_ptr\t*cpp;\n\tstruct xfs_buf\t\t*cbp;\n\tint\t\t\tlevel;\n\tint\t\t\tindex;\n\tint\t\t\tnumrecs;\n#ifdef DEBUG\n\tunion xfs_btree_ptr\tptr;\n\tint\t\t\ti;\n#endif\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\tASSERT(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE);\n\tASSERT(cur->bc_nlevels > 1);\n\n\t/*\n\t * Don't deal with the root block needs to be a leaf case.\n\t * We're just going to turn the thing back into extents anyway.\n\t */\n\tlevel = cur->bc_nlevels - 1;\n\tif (level == 1)\n\t\tgoto out0;\n\n\t/*\n\t * Give up if the root has multiple children.\n\t */\n\tblock = xfs_btree_get_iroot(cur);\n\tif (xfs_btree_get_numrecs(block) != 1)\n\t\tgoto out0;\n\n\tcblock = xfs_btree_get_block(cur, level - 1, &cbp);\n\tnumrecs = xfs_btree_get_numrecs(cblock);\n\n\t/*\n\t * Only do this if the next level will fit.\n\t * Then the data must be copied up to the inode,\n\t * instead of freeing the root you free the next level.\n\t */\n\tif (numrecs > cur->bc_ops->get_dmaxrecs(cur, level))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, killroot);\n\n#ifdef DEBUG\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tASSERT(xfs_btree_ptr_is_null(cur, &ptr));\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tASSERT(xfs_btree_ptr_is_null(cur, &ptr));\n#endif\n\n\tindex = numrecs - cur->bc_ops->get_maxrecs(cur, level);\n\tif (index) {\n\t\txfs_iroot_realloc(cur->bc_private.b.ip, index,\n\t\t\t\t  cur->bc_private.b.whichfork);\n\t\tblock = ifp->if_broot;\n\t}\n\n\tbe16_add_cpu(&block->bb_numrecs, index);\n\tASSERT(block->bb_numrecs == cblock->bb_numrecs);\n\n\tkp = xfs_btree_key_addr(cur, 1, block);\n\tckp = xfs_btree_key_addr(cur, 1, cblock);\n\txfs_btree_copy_keys(cur, kp, ckp, numrecs);\n\n\tpp = xfs_btree_ptr_addr(cur, 1, block);\n\tcpp = xfs_btree_ptr_addr(cur, 1, cblock);\n#ifdef DEBUG\n\tfor (i = 0; i < numrecs; i++) {\n\t\tint\t\terror;\n\n\t\terror = xfs_btree_check_ptr(cur, cpp, i, level - 1);\n\t\tif (error) {\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\txfs_btree_copy_ptrs(cur, pp, cpp, numrecs);\n\n\tcur->bc_ops->free_block(cur, cbp);\n\tXFS_BTREE_STATS_INC(cur, free);\n\n\tcur->bc_bufs[level - 1] = NULL;\n\tbe16_add_cpu(&block->bb_level, -1);\n\txfs_trans_log_inode(cur->bc_tp, ip,\n\t\tXFS_ILOG_CORE | xfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\tcur->bc_nlevels--;\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->get_minrecs",
          "args": [
            "cur",
            "level"
          ],
          "line": 3531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_updkey",
          "args": [
            "cur",
            "keyp",
            "level + 1"
          ],
          "line": 3522
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_updkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1855-1897",
          "snippet": "STATIC int\nxfs_btree_updkey(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*keyp,\n\tint\t\t\tlevel)\n{\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_buf\t\t*bp;\n\tunion xfs_btree_key\t*kp;\n\tint\t\t\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGIK(cur, level, keyp);\n\n\tASSERT(!(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) || level >= 1);\n\n\t/*\n\t * Go up the tree from this level toward the root.\n\t * At each level, update the key value to the value input.\n\t * Stop when we reach a level where the cursor isn't pointing\n\t * at the first entry in the block.\n\t */\n\tfor (ptr = 1; ptr == 1 && level < cur->bc_nlevels; level++) {\n#ifdef DEBUG\n\t\tint\t\terror;\n#endif\n\t\tblock = xfs_btree_get_block(cur, level, &bp);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, level, bp);\n\t\tif (error) {\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\t\t\treturn error;\n\t\t}\n#endif\n\t\tptr = cur->bc_ptrs[level];\n\t\tkp = xfs_btree_key_addr(cur, ptr, block);\n\t\txfs_btree_copy_keys(cur, kp, keyp, 1);\n\t\txfs_btree_log_keys(cur, bp, ptr, ptr);\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_updkey(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*keyp,\n\tint\t\t\tlevel)\n{\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_buf\t\t*bp;\n\tunion xfs_btree_key\t*kp;\n\tint\t\t\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGIK(cur, level, keyp);\n\n\tASSERT(!(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) || level >= 1);\n\n\t/*\n\t * Go up the tree from this level toward the root.\n\t * At each level, update the key value to the value input.\n\t * Stop when we reach a level where the cursor isn't pointing\n\t * at the first entry in the block.\n\t */\n\tfor (ptr = 1; ptr == 1 && level < cur->bc_nlevels; level++) {\n#ifdef DEBUG\n\t\tint\t\terror;\n#endif\n\t\tblock = xfs_btree_get_block(cur, level, &bp);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, level, bp);\n\t\tif (error) {\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\t\t\treturn error;\n\t\t}\n#endif\n\t\tptr = cur->bc_ptrs[level];\n\t\tkp = xfs_btree_key_addr(cur, ptr, block);\n\t\txfs_btree_copy_keys(cur, kp, keyp, 1);\n\t\txfs_btree_log_keys(cur, bp, ptr, ptr);\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_kill_root",
          "args": [
            "cur",
            "bp",
            "level",
            "pp"
          ],
          "line": 3505
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_kill_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "3287-3319",
          "snippet": "STATIC int\nxfs_btree_kill_root(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tlevel,\n\tunion xfs_btree_ptr\t*newroot)\n{\n\tint\t\t\terror;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_STATS_INC(cur, killroot);\n\n\t/*\n\t * Update the root pointer, decreasing the level by 1 and then\n\t * free the old root.\n\t */\n\tcur->bc_ops->set_root(cur, newroot, -1);\n\n\terror = cur->bc_ops->free_block(cur, bp);\n\tif (error) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\t\treturn error;\n\t}\n\n\tXFS_BTREE_STATS_INC(cur, free);\n\n\tcur->bc_bufs[level] = NULL;\n\tcur->bc_ra[level] = 0;\n\tcur->bc_nlevels--;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_kill_root(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tlevel,\n\tunion xfs_btree_ptr\t*newroot)\n{\n\tint\t\t\terror;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_STATS_INC(cur, killroot);\n\n\t/*\n\t * Update the root pointer, decreasing the level by 1 and then\n\t * free the old root.\n\t */\n\tcur->bc_ops->set_root(cur, newroot, -1);\n\n\terror = cur->bc_ops->free_block(cur, bp);\n\tif (error) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\t\treturn error;\n\t}\n\n\tXFS_BTREE_STATS_INC(cur, free);\n\n\tcur->bc_bufs[level] = NULL;\n\tcur->bc_ra[level] = 0;\n\tcur->bc_nlevels--;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iroot_realloc",
          "args": [
            "cur->bc_private.b.ip",
            "-1",
            "cur->bc_private.b.whichfork"
          ],
          "line": 3479
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iroot_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "473-583",
          "snippet": "void\nxfs_iroot_realloc(\n\txfs_inode_t\t\t*ip,\n\tint\t\t\trec_diff,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tcur_max;\n\txfs_ifork_t\t\t*ifp;\n\tstruct xfs_btree_block\t*new_broot;\n\tint\t\t\tnew_max;\n\tsize_t\t\t\tnew_size;\n\tchar\t\t\t*np;\n\tchar\t\t\t*op;\n\n\t/*\n\t * Handle the degenerate case quietly.\n\t */\n\tif (rec_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (rec_diff > 0) {\n\t\t/*\n\t\t * If there wasn't any memory allocated before, just\n\t\t * allocate it now and get out.\n\t\t */\n\t\tif (ifp->if_broot_bytes == 0) {\n\t\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, rec_diff);\n\t\t\tifp->if_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t\tifp->if_broot_bytes = (int)new_size;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If there is already an existing if_broot, then we need\n\t\t * to realloc() it and shift the pointers to their new\n\t\t * location.  The records don't change location because\n\t\t * they are kept butted up against the btree block header.\n\t\t */\n\t\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\t\tnew_max = cur_max + rec_diff;\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\t\tifp->if_broot = kmem_realloc(ifp->if_broot, new_size,\n\t\t\t\tXFS_BMAP_BROOT_SPACE_CALC(mp, cur_max),\n\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tifp->if_broot_bytes = (int)new_size;\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\t\tmemmove(np, op, cur_max * (uint)sizeof(xfs_fsblock_t));\n\t\treturn;\n\t}\n\n\t/*\n\t * rec_diff is less than 0.  In this case, we are shrinking the\n\t * if_broot buffer.  It must already exist.  If we go to zero\n\t * records, just get rid of the root and clear the status bit.\n\t */\n\tASSERT((ifp->if_broot != NULL) && (ifp->if_broot_bytes > 0));\n\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\tnew_max = cur_max + rec_diff;\n\tASSERT(new_max >= 0);\n\tif (new_max > 0)\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\telse\n\t\tnew_size = 0;\n\tif (new_size > 0) {\n\t\tnew_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t/*\n\t\t * First copy over the btree block header.\n\t\t */\n\t\tmemcpy(new_broot, ifp->if_broot,\n\t\t\tXFS_BMBT_BLOCK_LEN(ip->i_mount));\n\t} else {\n\t\tnew_broot = NULL;\n\t\tifp->if_flags &= ~XFS_IFBROOT;\n\t}\n\n\t/*\n\t * Only copy the records and pointers if there are any.\n\t */\n\tif (new_max > 0) {\n\t\t/*\n\t\t * First copy the records.\n\t\t */\n\t\top = (char *)XFS_BMBT_REC_ADDR(mp, ifp->if_broot, 1);\n\t\tnp = (char *)XFS_BMBT_REC_ADDR(mp, new_broot, 1);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_bmbt_rec_t));\n\n\t\t/*\n\t\t * Then copy the pointers.\n\t\t */\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, new_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_fsblock_t));\n\t}\n\tkmem_free(ifp->if_broot);\n\tifp->if_broot = new_broot;\n\tifp->if_broot_bytes = (int)new_size;\n\tif (ifp->if_broot)\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\treturn;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iroot_realloc(\n\txfs_inode_t\t\t*ip,\n\tint\t\t\trec_diff,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tcur_max;\n\txfs_ifork_t\t\t*ifp;\n\tstruct xfs_btree_block\t*new_broot;\n\tint\t\t\tnew_max;\n\tsize_t\t\t\tnew_size;\n\tchar\t\t\t*np;\n\tchar\t\t\t*op;\n\n\t/*\n\t * Handle the degenerate case quietly.\n\t */\n\tif (rec_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (rec_diff > 0) {\n\t\t/*\n\t\t * If there wasn't any memory allocated before, just\n\t\t * allocate it now and get out.\n\t\t */\n\t\tif (ifp->if_broot_bytes == 0) {\n\t\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, rec_diff);\n\t\t\tifp->if_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t\tifp->if_broot_bytes = (int)new_size;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If there is already an existing if_broot, then we need\n\t\t * to realloc() it and shift the pointers to their new\n\t\t * location.  The records don't change location because\n\t\t * they are kept butted up against the btree block header.\n\t\t */\n\t\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\t\tnew_max = cur_max + rec_diff;\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\t\tifp->if_broot = kmem_realloc(ifp->if_broot, new_size,\n\t\t\t\tXFS_BMAP_BROOT_SPACE_CALC(mp, cur_max),\n\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tifp->if_broot_bytes = (int)new_size;\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\t\tmemmove(np, op, cur_max * (uint)sizeof(xfs_fsblock_t));\n\t\treturn;\n\t}\n\n\t/*\n\t * rec_diff is less than 0.  In this case, we are shrinking the\n\t * if_broot buffer.  It must already exist.  If we go to zero\n\t * records, just get rid of the root and clear the status bit.\n\t */\n\tASSERT((ifp->if_broot != NULL) && (ifp->if_broot_bytes > 0));\n\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\tnew_max = cur_max + rec_diff;\n\tASSERT(new_max >= 0);\n\tif (new_max > 0)\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\telse\n\t\tnew_size = 0;\n\tif (new_size > 0) {\n\t\tnew_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t/*\n\t\t * First copy over the btree block header.\n\t\t */\n\t\tmemcpy(new_broot, ifp->if_broot,\n\t\t\tXFS_BMBT_BLOCK_LEN(ip->i_mount));\n\t} else {\n\t\tnew_broot = NULL;\n\t\tifp->if_flags &= ~XFS_IFBROOT;\n\t}\n\n\t/*\n\t * Only copy the records and pointers if there are any.\n\t */\n\tif (new_max > 0) {\n\t\t/*\n\t\t * First copy the records.\n\t\t */\n\t\top = (char *)XFS_BMBT_REC_ADDR(mp, ifp->if_broot, 1);\n\t\tnp = (char *)XFS_BMBT_REC_ADDR(mp, new_broot, 1);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_bmbt_rec_t));\n\n\t\t/*\n\t\t * Then copy the pointers.\n\t\t */\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, new_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_fsblock_t));\n\t}\n\tkmem_free(ifp->if_broot);\n\tifp->if_broot = new_broot;\n\tifp->if_broot_bytes = (int)new_size;\n\tif (ifp->if_broot)\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->update_lastrec",
          "args": [
            "cur",
            "block",
            "NULL",
            "ptr",
            "LASTREC_DELREC"
          ],
          "line": 3468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_is_lastrec",
          "args": [
            "cur",
            "block",
            "level"
          ],
          "line": 3467
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_is_lastrec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1066-1083",
          "snippet": "STATIC int\nxfs_btree_is_lastrec(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tint\t\t\tlevel)\n{\n\tunion xfs_btree_ptr\tptr;\n\n\tif (level > 0)\n\t\treturn 0;\n\tif (!(cur->bc_flags & XFS_BTREE_LASTREC_UPDATE))\n\t\treturn 0;\n\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (!xfs_btree_ptr_is_null(cur, &ptr))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_is_lastrec(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tint\t\t\tlevel)\n{\n\tunion xfs_btree_ptr\tptr;\n\n\tif (level > 0)\n\t\treturn 0;\n\tif (!(cur->bc_flags & XFS_BTREE_LASTREC_UPDATE))\n\t\treturn 0;\n\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (!xfs_btree_ptr_is_null(cur, &ptr))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->init_key_from_rec",
          "args": [
            "&key",
            "xfs_btree_rec_addr(cur, 1, block)"
          ],
          "line": 3451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_shift_recs",
          "args": [
            "cur",
            "xfs_btree_rec_addr(cur, ptr + 1, block)",
            "-1",
            "numrecs - ptr"
          ],
          "line": 3440
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_shift_recs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1243-1257",
          "snippet": "STATIC void\nxfs_btree_shift_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*rec,\n\tint\t\t\tdir,\n\tint\t\t\tnumrecs)\n{\n\tchar\t\t\t*dst_rec;\n\n\tASSERT(numrecs >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_rec = (char *)rec + (dir * cur->bc_ops->rec_len);\n\tmemmove(dst_rec, rec, numrecs * cur->bc_ops->rec_len);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_shift_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*rec,\n\tint\t\t\tdir,\n\tint\t\t\tnumrecs)\n{\n\tchar\t\t\t*dst_rec;\n\n\tASSERT(numrecs >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_rec = (char *)rec + (dir * cur->bc_ops->rec_len);\n\tmemmove(dst_rec, rec, numrecs * cur->bc_ops->rec_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_shift_ptrs",
          "args": [
            "cur",
            "lpp",
            "-1",
            "numrecs - ptr"
          ],
          "line": 3426
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_shift_ptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1262-1276",
          "snippet": "STATIC void\nxfs_btree_shift_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tdir,\n\tint\t\t\tnumptrs)\n{\n\tchar\t\t\t*dst_ptr;\n\n\tASSERT(numptrs >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_ptr = (char *)ptr + (dir * xfs_btree_ptr_len(cur));\n\tmemmove(dst_ptr, ptr, numptrs * xfs_btree_ptr_len(cur));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_shift_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tdir,\n\tint\t\t\tnumptrs)\n{\n\tchar\t\t\t*dst_ptr;\n\n\tASSERT(numptrs >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_ptr = (char *)ptr + (dir * xfs_btree_ptr_len(cur));\n\tmemmove(dst_ptr, ptr, numptrs * xfs_btree_ptr_len(cur));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_shift_keys",
          "args": [
            "cur",
            "lkp",
            "-1",
            "numrecs - ptr"
          ],
          "line": 3425
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_shift_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1224-1238",
          "snippet": "STATIC void\nxfs_btree_shift_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*key,\n\tint\t\t\tdir,\n\tint\t\t\tnumkeys)\n{\n\tchar\t\t\t*dst_key;\n\n\tASSERT(numkeys >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_key = (char *)key + (dir * cur->bc_ops->key_len);\n\tmemmove(dst_key, key, numkeys * cur->bc_ops->key_len);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_shift_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*key,\n\tint\t\t\tdir,\n\tint\t\t\tnumkeys)\n{\n\tchar\t\t\t*dst_key;\n\n\tASSERT(numkeys >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_key = (char *)key + (dir * cur->bc_ops->key_len);\n\tmemmove(dst_key, key, numkeys * cur->bc_ops->key_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_ADD",
          "args": [
            "cur",
            "moves",
            "numrecs - ptr"
          ],
          "line": 3405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_INC",
          "args": [
            "cur",
            "delrec"
          ],
          "line": 3404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 3399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 3382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_ARGI",
          "args": [
            "cur",
            "level"
          ],
          "line": 3375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ENTRY"
          ],
          "line": 3374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\t\t\t\t\t/* error */\nxfs_btree_delrec(\n\tstruct xfs_btree_cur\t*cur,\t\t/* btree cursor */\n\tint\t\t\tlevel,\t\t/* level removing record from */\n\tint\t\t\t*stat)\t\t/* fail/done/go-on */\n{\n\tstruct xfs_btree_block\t*block;\t\t/* btree block */\n\tunion xfs_btree_ptr\tcptr;\t\t/* current block ptr */\n\tstruct xfs_buf\t\t*bp;\t\t/* buffer for block */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* loop counter */\n\tunion xfs_btree_key\tkey;\t\t/* storage for keyp */\n\tunion xfs_btree_key\t*keyp = &key;\t/* passed to the next level */\n\tunion xfs_btree_ptr\tlptr;\t\t/* left sibling block ptr */\n\tstruct xfs_buf\t\t*lbp;\t\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t\t/* left btree block */\n\tint\t\t\tlrecs = 0;\t/* left record count */\n\tint\t\t\tptr;\t\t/* key/record index */\n\tunion xfs_btree_ptr\trptr;\t\t/* right sibling block ptr */\n\tstruct xfs_buf\t\t*rbp;\t\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t\t/* right btree block */\n\tstruct xfs_btree_block\t*rrblock;\t/* right-right btree block */\n\tstruct xfs_buf\t\t*rrbp;\t\t/* right-right buffer pointer */\n\tint\t\t\trrecs = 0;\t/* right record count */\n\tstruct xfs_btree_cur\t*tcur;\t\t/* temporary btree cursor */\n\tint\t\t\tnumrecs;\t/* temporary numrec count */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\ttcur = NULL;\n\n\t/* Get the index of the entry being deleted, check for nothing there. */\n\tptr = cur->bc_ptrs[level];\n\tif (ptr == 0) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t*stat = 0;\n\t\treturn 0;\n\t}\n\n\t/* Get the buffer & block containing the record or key/ptr. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\tnumrecs = xfs_btree_get_numrecs(block);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we're off the end of the block. */\n\tif (ptr > numrecs) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t*stat = 0;\n\t\treturn 0;\n\t}\n\n\tXFS_BTREE_STATS_INC(cur, delrec);\n\tXFS_BTREE_STATS_ADD(cur, moves, numrecs - ptr);\n\n\t/* Excise the entries being deleted. */\n\tif (level > 0) {\n\t\t/* It's a nonleaf. operate on keys and ptrs */\n\t\tunion xfs_btree_key\t*lkp;\n\t\tunion xfs_btree_ptr\t*lpp;\n\n\t\tlkp = xfs_btree_key_addr(cur, ptr + 1, block);\n\t\tlpp = xfs_btree_ptr_addr(cur, ptr + 1, block);\n\n#ifdef DEBUG\n\t\tfor (i = 0; i < numrecs - ptr; i++) {\n\t\t\terror = xfs_btree_check_ptr(cur, lpp, i, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\n\t\tif (ptr < numrecs) {\n\t\t\txfs_btree_shift_keys(cur, lkp, -1, numrecs - ptr);\n\t\t\txfs_btree_shift_ptrs(cur, lpp, -1, numrecs - ptr);\n\t\t\txfs_btree_log_keys(cur, bp, ptr, numrecs - 1);\n\t\t\txfs_btree_log_ptrs(cur, bp, ptr, numrecs - 1);\n\t\t}\n\n\t\t/*\n\t\t * If it's the first record in the block, we'll need to pass a\n\t\t * key up to the next level (updkey).\n\t\t */\n\t\tif (ptr == 1)\n\t\t\tkeyp = xfs_btree_key_addr(cur, 1, block);\n\t} else {\n\t\t/* It's a leaf. operate on records */\n\t\tif (ptr < numrecs) {\n\t\t\txfs_btree_shift_recs(cur,\n\t\t\t\txfs_btree_rec_addr(cur, ptr + 1, block),\n\t\t\t\t-1, numrecs - ptr);\n\t\t\txfs_btree_log_recs(cur, bp, ptr, numrecs - 1);\n\t\t}\n\n\t\t/*\n\t\t * If it's the first record in the block, we'll need a key\n\t\t * structure to pass up to the next level (updkey).\n\t\t */\n\t\tif (ptr == 1) {\n\t\t\tcur->bc_ops->init_key_from_rec(&key,\n\t\t\t\t\txfs_btree_rec_addr(cur, 1, block));\n\t\t\tkeyp = &key;\n\t\t}\n\t}\n\n\t/*\n\t * Decrement and log the number of entries in the block.\n\t */\n\txfs_btree_set_numrecs(block, --numrecs);\n\txfs_btree_log_block(cur, bp, XFS_BB_NUMRECS);\n\n\t/*\n\t * If we are tracking the last record in the tree and\n\t * we are at the far right edge of the tree, update it.\n\t */\n\tif (xfs_btree_is_lastrec(cur, block, level)) {\n\t\tcur->bc_ops->update_lastrec(cur, block, NULL,\n\t\t\t\t\t    ptr, LASTREC_DELREC);\n\t}\n\n\t/*\n\t * We're at the root level.  First, shrink the root block in-memory.\n\t * Try to get rid of the next level down.  If we can't then there's\n\t * nothing left to do.\n\t */\n\tif (level == cur->bc_nlevels - 1) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) {\n\t\t\txfs_iroot_realloc(cur->bc_private.b.ip, -1,\n\t\t\t\t\t  cur->bc_private.b.whichfork);\n\n\t\t\terror = xfs_btree_kill_iroot(cur);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\n\t\t\terror = xfs_btree_dec_cursor(cur, level, stat);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\t*stat = 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * If this is the root level, and there's only one entry left,\n\t\t * and it's NOT the leaf level, then we can get rid of this\n\t\t * level.\n\t\t */\n\t\tif (numrecs == 1 && level > 0) {\n\t\t\tunion xfs_btree_ptr\t*pp;\n\t\t\t/*\n\t\t\t * pp is still set to the first pointer in the block.\n\t\t\t * Make it the new root of the btree.\n\t\t\t */\n\t\t\tpp = xfs_btree_ptr_addr(cur, 1, block);\n\t\t\terror = xfs_btree_kill_root(cur, bp, level, pp);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t} else if (level > 0) {\n\t\t\terror = xfs_btree_dec_cursor(cur, level, stat);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n\t\t*stat = 1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we deleted the leftmost entry in the block, update the\n\t * key values above us in the tree.\n\t */\n\tif (ptr == 1) {\n\t\terror = xfs_btree_updkey(cur, keyp, level + 1);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\t/*\n\t * If the number of records remaining in the block is at least\n\t * the minimum, we're done.\n\t */\n\tif (numrecs >= cur->bc_ops->get_minrecs(cur, level)) {\n\t\terror = xfs_btree_dec_cursor(cur, level, stat);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Otherwise, we have to move some records around to keep the\n\t * tree balanced.  Look at the left and right sibling blocks to\n\t * see if we can re-balance by moving only one record.\n\t */\n\txfs_btree_get_sibling(cur, block, &rptr, XFS_BB_RIGHTSIB);\n\txfs_btree_get_sibling(cur, block, &lptr, XFS_BB_LEFTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) {\n\t\t/*\n\t\t * One child of root, need to get a chance to copy its contents\n\t\t * into the root and delete it. Can't go up to next level,\n\t\t * there's nothing to delete there.\n\t\t */\n\t\tif (xfs_btree_ptr_is_null(cur, &rptr) &&\n\t\t    xfs_btree_ptr_is_null(cur, &lptr) &&\n\t\t    level == cur->bc_nlevels - 2) {\n\t\t\terror = xfs_btree_kill_iroot(cur);\n\t\t\tif (!error)\n\t\t\t\terror = xfs_btree_dec_cursor(cur, level, stat);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tASSERT(!xfs_btree_ptr_is_null(cur, &rptr) ||\n\t       !xfs_btree_ptr_is_null(cur, &lptr));\n\n\t/*\n\t * Duplicate the cursor so our btree manipulations here won't\n\t * disrupt the next level up.\n\t */\n\terror = xfs_btree_dup_cursor(cur, &tcur);\n\tif (error)\n\t\tgoto error0;\n\n\t/*\n\t * If there's a right sibling, see if it's ok to shift an entry\n\t * out of it.\n\t */\n\tif (!xfs_btree_ptr_is_null(cur, &rptr)) {\n\t\t/*\n\t\t * Move the temp cursor to the last entry in the next block.\n\t\t * Actually any entry but the first would suffice.\n\t\t */\n\t\ti = xfs_btree_lastrec(tcur, level);\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\terror = xfs_btree_increment(tcur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\ti = xfs_btree_lastrec(tcur, level);\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\t/* Grab a pointer to the block. */\n\t\tright = xfs_btree_get_block(tcur, level, &rbp);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(tcur, right, level, rbp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\t\t/* Grab the current block number, for future use. */\n\t\txfs_btree_get_sibling(tcur, right, &cptr, XFS_BB_LEFTSIB);\n\n\t\t/*\n\t\t * If right block is full enough so that removing one entry\n\t\t * won't make it too empty, and left-shifting an entry out\n\t\t * of right to us works, we're done.\n\t\t */\n\t\tif (xfs_btree_get_numrecs(right) - 1 >=\n\t\t    cur->bc_ops->get_minrecs(tcur, level)) {\n\t\t\terror = xfs_btree_lshift(tcur, level, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (i) {\n\t\t\t\tASSERT(xfs_btree_get_numrecs(block) >=\n\t\t\t\t       cur->bc_ops->get_minrecs(tcur, level));\n\n\t\t\t\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\t\t\t\ttcur = NULL;\n\n\t\t\t\terror = xfs_btree_dec_cursor(cur, level, stat);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, grab the number of records in right for\n\t\t * future reference, and fix up the temp cursor to point\n\t\t * to our block again (last record).\n\t\t */\n\t\trrecs = xfs_btree_get_numrecs(right);\n\t\tif (!xfs_btree_ptr_is_null(cur, &lptr)) {\n\t\t\ti = xfs_btree_firstrec(tcur, level);\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\t\terror = xfs_btree_decrement(tcur, level, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\t}\n\t}\n\n\t/*\n\t * If there's a left sibling, see if it's ok to shift an entry\n\t * out of it.\n\t */\n\tif (!xfs_btree_ptr_is_null(cur, &lptr)) {\n\t\t/*\n\t\t * Move the temp cursor to the first entry in the\n\t\t * previous block.\n\t\t */\n\t\ti = xfs_btree_firstrec(tcur, level);\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\terror = xfs_btree_decrement(tcur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\ti = xfs_btree_firstrec(tcur, level);\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\t\t/* Grab a pointer to the block. */\n\t\tleft = xfs_btree_get_block(tcur, level, &lbp);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, left, level, lbp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\t\t/* Grab the current block number, for future use. */\n\t\txfs_btree_get_sibling(tcur, left, &cptr, XFS_BB_RIGHTSIB);\n\n\t\t/*\n\t\t * If left block is full enough so that removing one entry\n\t\t * won't make it too empty, and right-shifting an entry out\n\t\t * of left to us works, we're done.\n\t\t */\n\t\tif (xfs_btree_get_numrecs(left) - 1 >=\n\t\t    cur->bc_ops->get_minrecs(tcur, level)) {\n\t\t\terror = xfs_btree_rshift(tcur, level, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (i) {\n\t\t\t\tASSERT(xfs_btree_get_numrecs(block) >=\n\t\t\t\t       cur->bc_ops->get_minrecs(tcur, level));\n\t\t\t\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\t\t\t\ttcur = NULL;\n\t\t\t\tif (level == 0)\n\t\t\t\t\tcur->bc_ptrs[0]++;\n\t\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t\t*stat = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, grab the number of records in right for\n\t\t * future reference.\n\t\t */\n\t\tlrecs = xfs_btree_get_numrecs(left);\n\t}\n\n\t/* Delete the temp cursor, we're done with it. */\n\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\ttcur = NULL;\n\n\t/* If here, we need to do a join to keep the tree balanced. */\n\tASSERT(!xfs_btree_ptr_is_null(cur, &cptr));\n\n\tif (!xfs_btree_ptr_is_null(cur, &lptr) &&\n\t    lrecs + xfs_btree_get_numrecs(block) <=\n\t\t\tcur->bc_ops->get_maxrecs(cur, level)) {\n\t\t/*\n\t\t * Set \"right\" to be the starting block,\n\t\t * \"left\" to be the left neighbor.\n\t\t */\n\t\trptr = cptr;\n\t\tright = block;\n\t\trbp = bp;\n\t\terror = xfs_btree_read_buf_block(cur, &lptr, 0, &left, &lbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t/*\n\t * If that won't work, see if we can join with the right neighbor block.\n\t */\n\t} else if (!xfs_btree_ptr_is_null(cur, &rptr) &&\n\t\t   rrecs + xfs_btree_get_numrecs(block) <=\n\t\t\tcur->bc_ops->get_maxrecs(cur, level)) {\n\t\t/*\n\t\t * Set \"left\" to be the starting block,\n\t\t * \"right\" to be the right neighbor.\n\t\t */\n\t\tlptr = cptr;\n\t\tleft = block;\n\t\tlbp = bp;\n\t\terror = xfs_btree_read_buf_block(cur, &rptr, 0, &right, &rbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t/*\n\t * Otherwise, we can't fix the imbalance.\n\t * Just return.  This is probably a logic error, but it's not fatal.\n\t */\n\t} else {\n\t\terror = xfs_btree_dec_cursor(cur, level, stat);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\treturn 0;\n\t}\n\n\trrecs = xfs_btree_get_numrecs(right);\n\tlrecs = xfs_btree_get_numrecs(left);\n\n\t/*\n\t * We're now going to join \"left\" and \"right\" by moving all the stuff\n\t * in \"right\" to \"left\" and deleting \"right\".\n\t */\n\tXFS_BTREE_STATS_ADD(cur, moves, rrecs);\n\tif (level > 0) {\n\t\t/* It's a non-leaf.  Move keys and pointers. */\n\t\tunion xfs_btree_key\t*lkp;\t/* left btree key */\n\t\tunion xfs_btree_ptr\t*lpp;\t/* left address pointer */\n\t\tunion xfs_btree_key\t*rkp;\t/* right btree key */\n\t\tunion xfs_btree_ptr\t*rpp;\t/* right address pointer */\n\n\t\tlkp = xfs_btree_key_addr(cur, lrecs + 1, left);\n\t\tlpp = xfs_btree_ptr_addr(cur, lrecs + 1, left);\n\t\trkp = xfs_btree_key_addr(cur, 1, right);\n\t\trpp = xfs_btree_ptr_addr(cur, 1, right);\n#ifdef DEBUG\n\t\tfor (i = 1; i < rrecs; i++) {\n\t\t\terror = xfs_btree_check_ptr(cur, rpp, i, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\t\txfs_btree_copy_keys(cur, lkp, rkp, rrecs);\n\t\txfs_btree_copy_ptrs(cur, lpp, rpp, rrecs);\n\n\t\txfs_btree_log_keys(cur, lbp, lrecs + 1, lrecs + rrecs);\n\t\txfs_btree_log_ptrs(cur, lbp, lrecs + 1, lrecs + rrecs);\n\t} else {\n\t\t/* It's a leaf.  Move records.  */\n\t\tunion xfs_btree_rec\t*lrp;\t/* left record pointer */\n\t\tunion xfs_btree_rec\t*rrp;\t/* right record pointer */\n\n\t\tlrp = xfs_btree_rec_addr(cur, lrecs + 1, left);\n\t\trrp = xfs_btree_rec_addr(cur, 1, right);\n\n\t\txfs_btree_copy_recs(cur, lrp, rrp, rrecs);\n\t\txfs_btree_log_recs(cur, lbp, lrecs + 1, lrecs + rrecs);\n\t}\n\n\tXFS_BTREE_STATS_INC(cur, join);\n\n\t/*\n\t * Fix up the number of records and right block pointer in the\n\t * surviving block, and log it.\n\t */\n\txfs_btree_set_numrecs(left, lrecs + rrecs);\n\txfs_btree_get_sibling(cur, right, &cptr, XFS_BB_RIGHTSIB),\n\txfs_btree_set_sibling(cur, left, &cptr, XFS_BB_RIGHTSIB);\n\txfs_btree_log_block(cur, lbp, XFS_BB_NUMRECS | XFS_BB_RIGHTSIB);\n\n\t/* If there is a right sibling, point it to the remaining block. */\n\txfs_btree_get_sibling(cur, left, &cptr, XFS_BB_RIGHTSIB);\n\tif (!xfs_btree_ptr_is_null(cur, &cptr)) {\n\t\terror = xfs_btree_read_buf_block(cur, &cptr, 0, &rrblock, &rrbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_set_sibling(cur, rrblock, &lptr, XFS_BB_LEFTSIB);\n\t\txfs_btree_log_block(cur, rrbp, XFS_BB_LEFTSIB);\n\t}\n\n\t/* Free the deleted block. */\n\terror = cur->bc_ops->free_block(cur, rbp);\n\tif (error)\n\t\tgoto error0;\n\tXFS_BTREE_STATS_INC(cur, free);\n\n\t/*\n\t * If we joined with the left neighbor, set the buffer in the\n\t * cursor to the left block, and fix up the index.\n\t */\n\tif (bp != lbp) {\n\t\tcur->bc_bufs[level] = lbp;\n\t\tcur->bc_ptrs[level] += lrecs;\n\t\tcur->bc_ra[level] = 0;\n\t}\n\t/*\n\t * If we joined with the right neighbor and there's a level above\n\t * us, increment the cursor at that level.\n\t */\n\telse if ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) ||\n\t\t   (level + 1 < cur->bc_nlevels)) {\n\t\terror = xfs_btree_increment(cur, level + 1, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\t/*\n\t * Readjust the ptr at this level if it's not a leaf, since it's\n\t * still pointing at the deletion point, which makes the cursor\n\t * inconsistent.  If this makes the ptr 0, the caller fixes it up.\n\t * We can't use decrement because it would change the next level up.\n\t */\n\tif (level > 0)\n\t\tcur->bc_ptrs[level]--;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t/* Return value means the next level up has something to do. */\n\t*stat = 2;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\tif (tcur)\n\t\txfs_btree_del_cursor(tcur, XFS_BTREE_ERROR);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_btree_dec_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "3321-3339",
    "snippet": "STATIC int\nxfs_btree_dec_cursor(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\n{\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\tif (level > 0) {\n\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 3336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_decrement",
          "args": [
            "cur",
            "level",
            "&i"
          ],
          "line": 3331
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_decrement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1539-1631",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_btree_dec_cursor(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\n{\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\tif (level > 0) {\n\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_btree_kill_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "3287-3319",
    "snippet": "STATIC int\nxfs_btree_kill_root(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tlevel,\n\tunion xfs_btree_ptr\t*newroot)\n{\n\tint\t\t\terror;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_STATS_INC(cur, killroot);\n\n\t/*\n\t * Update the root pointer, decreasing the level by 1 and then\n\t * free the old root.\n\t */\n\tcur->bc_ops->set_root(cur, newroot, -1);\n\n\terror = cur->bc_ops->free_block(cur, bp);\n\tif (error) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\t\treturn error;\n\t}\n\n\tXFS_BTREE_STATS_INC(cur, free);\n\n\tcur->bc_bufs[level] = NULL;\n\tcur->bc_ra[level] = 0;\n\tcur->bc_nlevels--;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 3317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_INC",
          "args": [
            "cur",
            "free"
          ],
          "line": 3311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ERROR"
          ],
          "line": 3307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->free_block",
          "args": [
            "cur",
            "bp"
          ],
          "line": 3305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->set_root",
          "args": [
            "cur",
            "newroot",
            "-1"
          ],
          "line": 3303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_INC",
          "args": [
            "cur",
            "killroot"
          ],
          "line": 3297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ENTRY"
          ],
          "line": 3296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_kill_root(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tlevel,\n\tunion xfs_btree_ptr\t*newroot)\n{\n\tint\t\t\terror;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_STATS_INC(cur, killroot);\n\n\t/*\n\t * Update the root pointer, decreasing the level by 1 and then\n\t * free the old root.\n\t */\n\tcur->bc_ops->set_root(cur, newroot, -1);\n\n\terror = cur->bc_ops->free_block(cur, bp);\n\tif (error) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\t\treturn error;\n\t}\n\n\tXFS_BTREE_STATS_INC(cur, free);\n\n\tcur->bc_bufs[level] = NULL;\n\tcur->bc_ra[level] = 0;\n\tcur->bc_nlevels--;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_btree_kill_iroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "3180-3282",
    "snippet": "STATIC int\nxfs_btree_kill_iroot(\n\tstruct xfs_btree_cur\t*cur)\n{\n\tint\t\t\twhichfork = cur->bc_private.b.whichfork;\n\tstruct xfs_inode\t*ip = cur->bc_private.b.ip;\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_btree_block\t*cblock;\n\tunion xfs_btree_key\t*kp;\n\tunion xfs_btree_key\t*ckp;\n\tunion xfs_btree_ptr\t*pp;\n\tunion xfs_btree_ptr\t*cpp;\n\tstruct xfs_buf\t\t*cbp;\n\tint\t\t\tlevel;\n\tint\t\t\tindex;\n\tint\t\t\tnumrecs;\n#ifdef DEBUG\n\tunion xfs_btree_ptr\tptr;\n\tint\t\t\ti;\n#endif\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\tASSERT(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE);\n\tASSERT(cur->bc_nlevels > 1);\n\n\t/*\n\t * Don't deal with the root block needs to be a leaf case.\n\t * We're just going to turn the thing back into extents anyway.\n\t */\n\tlevel = cur->bc_nlevels - 1;\n\tif (level == 1)\n\t\tgoto out0;\n\n\t/*\n\t * Give up if the root has multiple children.\n\t */\n\tblock = xfs_btree_get_iroot(cur);\n\tif (xfs_btree_get_numrecs(block) != 1)\n\t\tgoto out0;\n\n\tcblock = xfs_btree_get_block(cur, level - 1, &cbp);\n\tnumrecs = xfs_btree_get_numrecs(cblock);\n\n\t/*\n\t * Only do this if the next level will fit.\n\t * Then the data must be copied up to the inode,\n\t * instead of freeing the root you free the next level.\n\t */\n\tif (numrecs > cur->bc_ops->get_dmaxrecs(cur, level))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, killroot);\n\n#ifdef DEBUG\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tASSERT(xfs_btree_ptr_is_null(cur, &ptr));\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tASSERT(xfs_btree_ptr_is_null(cur, &ptr));\n#endif\n\n\tindex = numrecs - cur->bc_ops->get_maxrecs(cur, level);\n\tif (index) {\n\t\txfs_iroot_realloc(cur->bc_private.b.ip, index,\n\t\t\t\t  cur->bc_private.b.whichfork);\n\t\tblock = ifp->if_broot;\n\t}\n\n\tbe16_add_cpu(&block->bb_numrecs, index);\n\tASSERT(block->bb_numrecs == cblock->bb_numrecs);\n\n\tkp = xfs_btree_key_addr(cur, 1, block);\n\tckp = xfs_btree_key_addr(cur, 1, cblock);\n\txfs_btree_copy_keys(cur, kp, ckp, numrecs);\n\n\tpp = xfs_btree_ptr_addr(cur, 1, block);\n\tcpp = xfs_btree_ptr_addr(cur, 1, cblock);\n#ifdef DEBUG\n\tfor (i = 0; i < numrecs; i++) {\n\t\tint\t\terror;\n\n\t\terror = xfs_btree_check_ptr(cur, cpp, i, level - 1);\n\t\tif (error) {\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\txfs_btree_copy_ptrs(cur, pp, cpp, numrecs);\n\n\tcur->bc_ops->free_block(cur, cbp);\n\tXFS_BTREE_STATS_INC(cur, free);\n\n\tcur->bc_bufs[level - 1] = NULL;\n\tbe16_add_cpu(&block->bb_level, -1);\n\txfs_trans_log_inode(cur->bc_tp, ip,\n\t\tXFS_ILOG_CORE | xfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\tcur->bc_nlevels--;\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 3280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "cur->bc_tp",
            "ip",
            "XFS_ILOG_CORE | xfs_ilog_fbroot(cur->bc_private.b.whichfork)"
          ],
          "line": 3276
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilog_fbroot",
          "args": [
            "cur->bc_private.b.whichfork"
          ],
          "line": 3277
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilog_fbroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "336-339",
          "snippet": "static inline int xfs_ilog_fbroot(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DBROOT : XFS_ILOG_ABROOT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_ILOG_ABROOT\t0x100\t/* log i_af.i_broot */",
            "#define\tXFS_ILOG_DBROOT\t0x008\t/* log i_df.i_broot */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_ILOG_ABROOT\t0x100\t/* log i_af.i_broot */\n#define\tXFS_ILOG_DBROOT\t0x008\t/* log i_df.i_broot */\n\nstatic inline int xfs_ilog_fbroot(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DBROOT : XFS_ILOG_ABROOT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_add_cpu",
          "args": [
            "&block->bb_level",
            "-1"
          ],
          "line": 3275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_INC",
          "args": [
            "cur",
            "free"
          ],
          "line": 3272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->free_block",
          "args": [
            "cur",
            "cbp"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_copy_ptrs",
          "args": [
            "cur",
            "pp",
            "cpp",
            "numrecs"
          ],
          "line": 3269
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_copy_ptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1210-1219",
          "snippet": "STATIC void\nxfs_btree_copy_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*dst_ptr,\n\tunion xfs_btree_ptr\t*src_ptr,\n\tint\t\t\tnumptrs)\n{\n\tASSERT(numptrs >= 0);\n\tmemcpy(dst_ptr, src_ptr, numptrs * xfs_btree_ptr_len(cur));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*dst_ptr,\n\tunion xfs_btree_ptr\t*src_ptr,\n\tint\t\t\tnumptrs)\n{\n\tASSERT(numptrs >= 0);\n\tmemcpy(dst_ptr, src_ptr, numptrs * xfs_btree_ptr_len(cur));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ERROR"
          ],
          "line": 3264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_check_ptr",
          "args": [
            "cur",
            "cpp",
            "i",
            "level - 1"
          ],
          "line": 3262
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "201-215",
          "snippet": "STATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_ptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tunion xfs_btree_ptr\t*ptr,\t/* btree block disk address */\n\tint\t\t\tindex,\t/* offset from ptr to check */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\treturn xfs_btree_check_lptr(cur,\n\t\t\t\tbe64_to_cpu((&ptr->l)[index]), level);\n\t} else {\n\t\treturn xfs_btree_check_sptr(cur,\n\t\t\t\tbe32_to_cpu((&ptr->s)[index]), level);\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_ptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tunion xfs_btree_ptr\t*ptr,\t/* btree block disk address */\n\tint\t\t\tindex,\t/* offset from ptr to check */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\treturn xfs_btree_check_lptr(cur,\n\t\t\t\tbe64_to_cpu((&ptr->l)[index]), level);\n\t} else {\n\t\treturn xfs_btree_check_sptr(cur,\n\t\t\t\tbe32_to_cpu((&ptr->s)[index]), level);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_addr",
          "args": [
            "cur",
            "1",
            "cblock"
          ],
          "line": 3257
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "494-506",
          "snippet": "xfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_copy_keys",
          "args": [
            "cur",
            "kp",
            "ckp",
            "numrecs"
          ],
          "line": 3254
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_copy_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1182-1191",
          "snippet": "STATIC void\nxfs_btree_copy_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*dst_key,\n\tunion xfs_btree_key\t*src_key,\n\tint\t\t\tnumkeys)\n{\n\tASSERT(numkeys >= 0);\n\tmemcpy(dst_key, src_key, numkeys * cur->bc_ops->key_len);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*dst_key,\n\tunion xfs_btree_key\t*src_key,\n\tint\t\t\tnumkeys)\n{\n\tASSERT(numkeys >= 0);\n\tmemcpy(dst_key, src_key, numkeys * cur->bc_ops->key_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_key_addr",
          "args": [
            "cur",
            "1",
            "cblock"
          ],
          "line": 3253
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_key_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "481-489",
          "snippet": "xfs_btree_key *\nxfs_btree_key_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_key *)\n\t\t((char *)block + xfs_btree_key_offset(cur, n));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_key *\nxfs_btree_key_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_key *)\n\t\t((char *)block + xfs_btree_key_offset(cur, n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "block->bb_numrecs == cblock->bb_numrecs"
          ],
          "line": 3250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_add_cpu",
          "args": [
            "&block->bb_numrecs",
            "index"
          ],
          "line": 3249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iroot_realloc",
          "args": [
            "cur->bc_private.b.ip",
            "index",
            "cur->bc_private.b.whichfork"
          ],
          "line": 3244
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iroot_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "473-583",
          "snippet": "void\nxfs_iroot_realloc(\n\txfs_inode_t\t\t*ip,\n\tint\t\t\trec_diff,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tcur_max;\n\txfs_ifork_t\t\t*ifp;\n\tstruct xfs_btree_block\t*new_broot;\n\tint\t\t\tnew_max;\n\tsize_t\t\t\tnew_size;\n\tchar\t\t\t*np;\n\tchar\t\t\t*op;\n\n\t/*\n\t * Handle the degenerate case quietly.\n\t */\n\tif (rec_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (rec_diff > 0) {\n\t\t/*\n\t\t * If there wasn't any memory allocated before, just\n\t\t * allocate it now and get out.\n\t\t */\n\t\tif (ifp->if_broot_bytes == 0) {\n\t\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, rec_diff);\n\t\t\tifp->if_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t\tifp->if_broot_bytes = (int)new_size;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If there is already an existing if_broot, then we need\n\t\t * to realloc() it and shift the pointers to their new\n\t\t * location.  The records don't change location because\n\t\t * they are kept butted up against the btree block header.\n\t\t */\n\t\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\t\tnew_max = cur_max + rec_diff;\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\t\tifp->if_broot = kmem_realloc(ifp->if_broot, new_size,\n\t\t\t\tXFS_BMAP_BROOT_SPACE_CALC(mp, cur_max),\n\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tifp->if_broot_bytes = (int)new_size;\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\t\tmemmove(np, op, cur_max * (uint)sizeof(xfs_fsblock_t));\n\t\treturn;\n\t}\n\n\t/*\n\t * rec_diff is less than 0.  In this case, we are shrinking the\n\t * if_broot buffer.  It must already exist.  If we go to zero\n\t * records, just get rid of the root and clear the status bit.\n\t */\n\tASSERT((ifp->if_broot != NULL) && (ifp->if_broot_bytes > 0));\n\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\tnew_max = cur_max + rec_diff;\n\tASSERT(new_max >= 0);\n\tif (new_max > 0)\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\telse\n\t\tnew_size = 0;\n\tif (new_size > 0) {\n\t\tnew_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t/*\n\t\t * First copy over the btree block header.\n\t\t */\n\t\tmemcpy(new_broot, ifp->if_broot,\n\t\t\tXFS_BMBT_BLOCK_LEN(ip->i_mount));\n\t} else {\n\t\tnew_broot = NULL;\n\t\tifp->if_flags &= ~XFS_IFBROOT;\n\t}\n\n\t/*\n\t * Only copy the records and pointers if there are any.\n\t */\n\tif (new_max > 0) {\n\t\t/*\n\t\t * First copy the records.\n\t\t */\n\t\top = (char *)XFS_BMBT_REC_ADDR(mp, ifp->if_broot, 1);\n\t\tnp = (char *)XFS_BMBT_REC_ADDR(mp, new_broot, 1);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_bmbt_rec_t));\n\n\t\t/*\n\t\t * Then copy the pointers.\n\t\t */\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, new_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_fsblock_t));\n\t}\n\tkmem_free(ifp->if_broot);\n\tifp->if_broot = new_broot;\n\tifp->if_broot_bytes = (int)new_size;\n\tif (ifp->if_broot)\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\treturn;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iroot_realloc(\n\txfs_inode_t\t\t*ip,\n\tint\t\t\trec_diff,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tcur_max;\n\txfs_ifork_t\t\t*ifp;\n\tstruct xfs_btree_block\t*new_broot;\n\tint\t\t\tnew_max;\n\tsize_t\t\t\tnew_size;\n\tchar\t\t\t*np;\n\tchar\t\t\t*op;\n\n\t/*\n\t * Handle the degenerate case quietly.\n\t */\n\tif (rec_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (rec_diff > 0) {\n\t\t/*\n\t\t * If there wasn't any memory allocated before, just\n\t\t * allocate it now and get out.\n\t\t */\n\t\tif (ifp->if_broot_bytes == 0) {\n\t\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, rec_diff);\n\t\t\tifp->if_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t\tifp->if_broot_bytes = (int)new_size;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If there is already an existing if_broot, then we need\n\t\t * to realloc() it and shift the pointers to their new\n\t\t * location.  The records don't change location because\n\t\t * they are kept butted up against the btree block header.\n\t\t */\n\t\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\t\tnew_max = cur_max + rec_diff;\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\t\tifp->if_broot = kmem_realloc(ifp->if_broot, new_size,\n\t\t\t\tXFS_BMAP_BROOT_SPACE_CALC(mp, cur_max),\n\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tifp->if_broot_bytes = (int)new_size;\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\t\tmemmove(np, op, cur_max * (uint)sizeof(xfs_fsblock_t));\n\t\treturn;\n\t}\n\n\t/*\n\t * rec_diff is less than 0.  In this case, we are shrinking the\n\t * if_broot buffer.  It must already exist.  If we go to zero\n\t * records, just get rid of the root and clear the status bit.\n\t */\n\tASSERT((ifp->if_broot != NULL) && (ifp->if_broot_bytes > 0));\n\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\tnew_max = cur_max + rec_diff;\n\tASSERT(new_max >= 0);\n\tif (new_max > 0)\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\telse\n\t\tnew_size = 0;\n\tif (new_size > 0) {\n\t\tnew_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t/*\n\t\t * First copy over the btree block header.\n\t\t */\n\t\tmemcpy(new_broot, ifp->if_broot,\n\t\t\tXFS_BMBT_BLOCK_LEN(ip->i_mount));\n\t} else {\n\t\tnew_broot = NULL;\n\t\tifp->if_flags &= ~XFS_IFBROOT;\n\t}\n\n\t/*\n\t * Only copy the records and pointers if there are any.\n\t */\n\tif (new_max > 0) {\n\t\t/*\n\t\t * First copy the records.\n\t\t */\n\t\top = (char *)XFS_BMBT_REC_ADDR(mp, ifp->if_broot, 1);\n\t\tnp = (char *)XFS_BMBT_REC_ADDR(mp, new_broot, 1);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_bmbt_rec_t));\n\n\t\t/*\n\t\t * Then copy the pointers.\n\t\t */\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, new_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_fsblock_t));\n\t}\n\tkmem_free(ifp->if_broot);\n\tifp->if_broot = new_broot;\n\tifp->if_broot_bytes = (int)new_size;\n\tif (ifp->if_broot)\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->get_maxrecs",
          "args": [
            "cur",
            "level"
          ],
          "line": 3242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_btree_ptr_is_null(cur, &ptr)"
          ],
          "line": 3239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_is_null",
          "args": [
            "cur",
            "&ptr"
          ],
          "line": 3239
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_is_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "913-922",
          "snippet": "STATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_sibling",
          "args": [
            "cur",
            "block",
            "&ptr",
            "XFS_BB_RIGHTSIB"
          ],
          "line": 3238
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_sibling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "938-958",
          "snippet": "STATIC void\nxfs_btree_get_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->l = block->bb_u.l.bb_rightsib;\n\t\telse\n\t\t\tptr->l = block->bb_u.l.bb_leftsib;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->s = block->bb_u.s.bb_rightsib;\n\t\telse\n\t\t\tptr->s = block->bb_u.s.bb_leftsib;\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_get_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->l = block->bb_u.l.bb_rightsib;\n\t\telse\n\t\t\tptr->l = block->bb_u.l.bb_leftsib;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->s = block->bb_u.s.bb_rightsib;\n\t\telse\n\t\t\tptr->s = block->bb_u.s.bb_leftsib;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_btree_ptr_is_null(cur, &ptr)"
          ],
          "line": 3237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_INC",
          "args": [
            "cur",
            "killroot"
          ],
          "line": 3233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->get_dmaxrecs",
          "args": [
            "cur",
            "level"
          ],
          "line": 3230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_numrecs",
          "args": [
            "cblock"
          ],
          "line": 3223
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_numrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "416-419",
          "snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_block",
          "args": [
            "cur",
            "level - 1",
            "&cbp"
          ],
          "line": 3222
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "528-542",
          "snippet": "xfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_iroot",
          "args": [
            "cur"
          ],
          "line": 3218
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_iroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "514-522",
          "snippet": "xfs_btree_block *\nxfs_btree_get_iroot(\n       struct xfs_btree_cur    *cur)\n{\n       struct xfs_ifork        *ifp;\n\n       ifp = XFS_IFORK_PTR(cur->bc_private.b.ip, cur->bc_private.b.whichfork);\n       return (struct xfs_btree_block *)ifp->if_broot;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_btree_block *\nxfs_btree_get_iroot(\n       struct xfs_btree_cur    *cur)\n{\n       struct xfs_ifork        *ifp;\n\n       ifp = XFS_IFORK_PTR(cur->bc_private.b.ip, cur->bc_private.b.whichfork);\n       return (struct xfs_btree_block *)ifp->if_broot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cur->bc_nlevels > 1"
          ],
          "line": 3205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cur->bc_flags & XFS_BTREE_ROOT_IN_INODE"
          ],
          "line": 3204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ENTRY"
          ],
          "line": 3202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 3186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_kill_iroot(\n\tstruct xfs_btree_cur\t*cur)\n{\n\tint\t\t\twhichfork = cur->bc_private.b.whichfork;\n\tstruct xfs_inode\t*ip = cur->bc_private.b.ip;\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_btree_block\t*cblock;\n\tunion xfs_btree_key\t*kp;\n\tunion xfs_btree_key\t*ckp;\n\tunion xfs_btree_ptr\t*pp;\n\tunion xfs_btree_ptr\t*cpp;\n\tstruct xfs_buf\t\t*cbp;\n\tint\t\t\tlevel;\n\tint\t\t\tindex;\n\tint\t\t\tnumrecs;\n#ifdef DEBUG\n\tunion xfs_btree_ptr\tptr;\n\tint\t\t\ti;\n#endif\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\tASSERT(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE);\n\tASSERT(cur->bc_nlevels > 1);\n\n\t/*\n\t * Don't deal with the root block needs to be a leaf case.\n\t * We're just going to turn the thing back into extents anyway.\n\t */\n\tlevel = cur->bc_nlevels - 1;\n\tif (level == 1)\n\t\tgoto out0;\n\n\t/*\n\t * Give up if the root has multiple children.\n\t */\n\tblock = xfs_btree_get_iroot(cur);\n\tif (xfs_btree_get_numrecs(block) != 1)\n\t\tgoto out0;\n\n\tcblock = xfs_btree_get_block(cur, level - 1, &cbp);\n\tnumrecs = xfs_btree_get_numrecs(cblock);\n\n\t/*\n\t * Only do this if the next level will fit.\n\t * Then the data must be copied up to the inode,\n\t * instead of freeing the root you free the next level.\n\t */\n\tif (numrecs > cur->bc_ops->get_dmaxrecs(cur, level))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, killroot);\n\n#ifdef DEBUG\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tASSERT(xfs_btree_ptr_is_null(cur, &ptr));\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tASSERT(xfs_btree_ptr_is_null(cur, &ptr));\n#endif\n\n\tindex = numrecs - cur->bc_ops->get_maxrecs(cur, level);\n\tif (index) {\n\t\txfs_iroot_realloc(cur->bc_private.b.ip, index,\n\t\t\t\t  cur->bc_private.b.whichfork);\n\t\tblock = ifp->if_broot;\n\t}\n\n\tbe16_add_cpu(&block->bb_numrecs, index);\n\tASSERT(block->bb_numrecs == cblock->bb_numrecs);\n\n\tkp = xfs_btree_key_addr(cur, 1, block);\n\tckp = xfs_btree_key_addr(cur, 1, cblock);\n\txfs_btree_copy_keys(cur, kp, ckp, numrecs);\n\n\tpp = xfs_btree_ptr_addr(cur, 1, block);\n\tcpp = xfs_btree_ptr_addr(cur, 1, cblock);\n#ifdef DEBUG\n\tfor (i = 0; i < numrecs; i++) {\n\t\tint\t\terror;\n\n\t\terror = xfs_btree_check_ptr(cur, cpp, i, level - 1);\n\t\tif (error) {\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\txfs_btree_copy_ptrs(cur, pp, cpp, numrecs);\n\n\tcur->bc_ops->free_block(cur, cbp);\n\tXFS_BTREE_STATS_INC(cur, free);\n\n\tcur->bc_bufs[level - 1] = NULL;\n\tbe16_add_cpu(&block->bb_level, -1);\n\txfs_trans_log_inode(cur->bc_tp, ip,\n\t\tXFS_ILOG_CORE | xfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\tcur->bc_nlevels--;\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_btree_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "3104-3170",
    "snippet": "int\nxfs_btree_insert(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* result value, 0 for failure */\n\tint\t\t\tlevel;\t/* current level number in btree */\n\tunion xfs_btree_ptr\tnptr;\t/* new block number (split result) */\n\tstruct xfs_btree_cur\t*ncur;\t/* new cursor (split result) */\n\tstruct xfs_btree_cur\t*pcur;\t/* previous level's cursor */\n\tunion xfs_btree_rec\trec;\t/* record to insert */\n\n\tlevel = 0;\n\tncur = NULL;\n\tpcur = cur;\n\n\txfs_btree_set_ptr_null(cur, &nptr);\n\tcur->bc_ops->init_rec_from_cur(cur, &rec);\n\n\t/*\n\t * Loop going up the tree, starting at the leaf level.\n\t * Stop when we don't get a split block, that must mean that\n\t * the insert is finished with this level.\n\t */\n\tdo {\n\t\t/*\n\t\t * Insert nrec/nptr into this level of the tree.\n\t\t * Note if we fail, nptr will be null.\n\t\t */\n\t\terror = xfs_btree_insrec(pcur, level, &nptr, &rec, &ncur, &i);\n\t\tif (error) {\n\t\t\tif (pcur != cur)\n\t\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_ERROR);\n\t\t\tgoto error0;\n\t\t}\n\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tlevel++;\n\n\t\t/*\n\t\t * See if the cursor we just used is trash.\n\t\t * Can't trash the caller's cursor, but otherwise we should\n\t\t * if ncur is a new cursor or we're about to be done.\n\t\t */\n\t\tif (pcur != cur &&\n\t\t    (ncur || xfs_btree_ptr_is_null(cur, &nptr))) {\n\t\t\t/* Save the state from the cursor before we trash it */\n\t\t\tif (cur->bc_ops->update_cursor)\n\t\t\t\tcur->bc_ops->update_cursor(pcur, cur);\n\t\t\tcur->bc_nlevels = pcur->bc_nlevels;\n\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_NOERROR);\n\t\t}\n\t\t/* If we got a new cursor, switch to it. */\n\t\tif (ncur) {\n\t\t\tpcur = ncur;\n\t\t\tncur = NULL;\n\t\t}\n\t} while (!xfs_btree_ptr_is_null(cur, &nptr));\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ERROR"
          ],
          "line": 3168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 3164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_is_null",
          "args": [
            "cur",
            "&nptr"
          ],
          "line": 3162
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_is_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "913-922",
          "snippet": "STATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "pcur",
            "XFS_BTREE_NOERROR"
          ],
          "line": 3155
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->update_cursor",
          "args": [
            "pcur",
            "cur"
          ],
          "line": 3153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 3141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_insrec",
          "args": [
            "pcur",
            "level",
            "&nptr",
            "&rec",
            "&ncur",
            "&i"
          ],
          "line": 3134
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_insrec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "2893-3095",
          "snippet": "STATIC int\nxfs_btree_insrec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level to insert record at */\n\tunion xfs_btree_ptr\t*ptrp,\t/* i/o: block number inserted */\n\tunion xfs_btree_rec\t*recp,\t/* i/o: record data inserted */\n\tstruct xfs_btree_cur\t**curp,\t/* output: new cursor replacing cur */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* btree block */\n\tstruct xfs_buf\t\t*bp;\t/* buffer for block */\n\tunion xfs_btree_key\tkey;\t/* btree key */\n\tunion xfs_btree_ptr\tnptr;\t/* new block ptr */\n\tstruct xfs_btree_cur\t*ncur;\t/* new btree cursor */\n\tunion xfs_btree_rec\tnrec;\t/* new record count */\n\tint\t\t\toptr;\t/* old key/record index */\n\tint\t\t\tptr;\t/* key/record index */\n\tint\t\t\tnumrecs;/* number of records */\n\tint\t\t\terror;\t/* error return value */\n#ifdef DEBUG\n\tint\t\t\ti;\n#endif\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGIPR(cur, level, *ptrp, recp);\n\n\tncur = NULL;\n\n\t/*\n\t * If we have an external root pointer, and we've made it to the\n\t * root level, allocate a new root block and we're done.\n\t */\n\tif (!(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level >= cur->bc_nlevels)) {\n\t\terror = xfs_btree_new_root(cur, stat);\n\t\txfs_btree_set_ptr_null(cur, ptrp);\n\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\treturn error;\n\t}\n\n\t/* If we're off the left edge, return failure. */\n\tptr = cur->bc_ptrs[level];\n\tif (ptr == 0) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t*stat = 0;\n\t\treturn 0;\n\t}\n\n\t/* Make a key out of the record data to be inserted, and save it. */\n\tcur->bc_ops->init_key_from_rec(&key, recp);\n\n\toptr = ptr;\n\n\tXFS_BTREE_STATS_INC(cur, insrec);\n\n\t/* Get pointers to the btree buffer and block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\tnumrecs = xfs_btree_get_numrecs(block);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* Check that the new entry is being inserted in the right place. */\n\tif (ptr <= numrecs) {\n\t\tif (level == 0) {\n\t\t\tASSERT(cur->bc_ops->recs_inorder(cur, recp,\n\t\t\t\txfs_btree_rec_addr(cur, ptr, block)));\n\t\t} else {\n\t\t\tASSERT(cur->bc_ops->keys_inorder(cur, &key,\n\t\t\t\txfs_btree_key_addr(cur, ptr, block)));\n\t\t}\n\t}\n#endif\n\n\t/*\n\t * If the block is full, we can't insert the new entry until we\n\t * make the block un-full.\n\t */\n\txfs_btree_set_ptr_null(cur, &nptr);\n\tif (numrecs == cur->bc_ops->get_maxrecs(cur, level)) {\n\t\terror = xfs_btree_make_block_unfull(cur, level, numrecs,\n\t\t\t\t\t&optr, &ptr, &nptr, &ncur, &nrec, stat);\n\t\tif (error || *stat == 0)\n\t\t\tgoto error0;\n\t}\n\n\t/*\n\t * The current block may have changed if the block was\n\t * previously full and we have just made space in it.\n\t */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\tnumrecs = xfs_btree_get_numrecs(block);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\treturn error;\n#endif\n\n\t/*\n\t * At this point we know there's room for our new entry in the block\n\t * we're pointing at.\n\t */\n\tXFS_BTREE_STATS_ADD(cur, moves, numrecs - ptr + 1);\n\n\tif (level > 0) {\n\t\t/* It's a nonleaf. make a hole in the keys and ptrs */\n\t\tunion xfs_btree_key\t*kp;\n\t\tunion xfs_btree_ptr\t*pp;\n\n\t\tkp = xfs_btree_key_addr(cur, ptr, block);\n\t\tpp = xfs_btree_ptr_addr(cur, ptr, block);\n\n#ifdef DEBUG\n\t\tfor (i = numrecs - ptr; i >= 0; i--) {\n\t\t\terror = xfs_btree_check_ptr(cur, pp, i, level);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n#endif\n\n\t\txfs_btree_shift_keys(cur, kp, 1, numrecs - ptr + 1);\n\t\txfs_btree_shift_ptrs(cur, pp, 1, numrecs - ptr + 1);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_ptr(cur, ptrp, 0, level);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\t/* Now put the new data in, bump numrecs and log it. */\n\t\txfs_btree_copy_keys(cur, kp, &key, 1);\n\t\txfs_btree_copy_ptrs(cur, pp, ptrp, 1);\n\t\tnumrecs++;\n\t\txfs_btree_set_numrecs(block, numrecs);\n\t\txfs_btree_log_ptrs(cur, bp, ptr, numrecs);\n\t\txfs_btree_log_keys(cur, bp, ptr, numrecs);\n#ifdef DEBUG\n\t\tif (ptr < numrecs) {\n\t\t\tASSERT(cur->bc_ops->keys_inorder(cur, kp,\n\t\t\t\txfs_btree_key_addr(cur, ptr + 1, block)));\n\t\t}\n#endif\n\t} else {\n\t\t/* It's a leaf. make a hole in the records */\n\t\tunion xfs_btree_rec             *rp;\n\n\t\trp = xfs_btree_rec_addr(cur, ptr, block);\n\n\t\txfs_btree_shift_recs(cur, rp, 1, numrecs - ptr + 1);\n\n\t\t/* Now put the new data in, bump numrecs and log it. */\n\t\txfs_btree_copy_recs(cur, rp, recp, 1);\n\t\txfs_btree_set_numrecs(block, ++numrecs);\n\t\txfs_btree_log_recs(cur, bp, ptr, numrecs);\n#ifdef DEBUG\n\t\tif (ptr < numrecs) {\n\t\t\tASSERT(cur->bc_ops->recs_inorder(cur, rp,\n\t\t\t\txfs_btree_rec_addr(cur, ptr + 1, block)));\n\t\t}\n#endif\n\t}\n\n\t/* Log the new number of records in the btree header. */\n\txfs_btree_log_block(cur, bp, XFS_BB_NUMRECS);\n\n\t/* If we inserted at the start of a block, update the parents' keys. */\n\tif (optr == 1) {\n\t\terror = xfs_btree_updkey(cur, &key, level + 1);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\t/*\n\t * If we are tracking the last record in the tree and\n\t * we are at the far right edge of the tree, update it.\n\t */\n\tif (xfs_btree_is_lastrec(cur, block, level)) {\n\t\tcur->bc_ops->update_lastrec(cur, block, recp,\n\t\t\t\t\t    ptr, LASTREC_INSREC);\n\t}\n\n\t/*\n\t * Return the new block number, if any.\n\t * If there is one, give back a record value and a cursor too.\n\t */\n\t*ptrp = nptr;\n\tif (!xfs_btree_ptr_is_null(cur, &nptr)) {\n\t\t*recp = nrec;\n\t\t*curp = ncur;\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_insrec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level to insert record at */\n\tunion xfs_btree_ptr\t*ptrp,\t/* i/o: block number inserted */\n\tunion xfs_btree_rec\t*recp,\t/* i/o: record data inserted */\n\tstruct xfs_btree_cur\t**curp,\t/* output: new cursor replacing cur */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* btree block */\n\tstruct xfs_buf\t\t*bp;\t/* buffer for block */\n\tunion xfs_btree_key\tkey;\t/* btree key */\n\tunion xfs_btree_ptr\tnptr;\t/* new block ptr */\n\tstruct xfs_btree_cur\t*ncur;\t/* new btree cursor */\n\tunion xfs_btree_rec\tnrec;\t/* new record count */\n\tint\t\t\toptr;\t/* old key/record index */\n\tint\t\t\tptr;\t/* key/record index */\n\tint\t\t\tnumrecs;/* number of records */\n\tint\t\t\terror;\t/* error return value */\n#ifdef DEBUG\n\tint\t\t\ti;\n#endif\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGIPR(cur, level, *ptrp, recp);\n\n\tncur = NULL;\n\n\t/*\n\t * If we have an external root pointer, and we've made it to the\n\t * root level, allocate a new root block and we're done.\n\t */\n\tif (!(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level >= cur->bc_nlevels)) {\n\t\terror = xfs_btree_new_root(cur, stat);\n\t\txfs_btree_set_ptr_null(cur, ptrp);\n\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\treturn error;\n\t}\n\n\t/* If we're off the left edge, return failure. */\n\tptr = cur->bc_ptrs[level];\n\tif (ptr == 0) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t*stat = 0;\n\t\treturn 0;\n\t}\n\n\t/* Make a key out of the record data to be inserted, and save it. */\n\tcur->bc_ops->init_key_from_rec(&key, recp);\n\n\toptr = ptr;\n\n\tXFS_BTREE_STATS_INC(cur, insrec);\n\n\t/* Get pointers to the btree buffer and block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\tnumrecs = xfs_btree_get_numrecs(block);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* Check that the new entry is being inserted in the right place. */\n\tif (ptr <= numrecs) {\n\t\tif (level == 0) {\n\t\t\tASSERT(cur->bc_ops->recs_inorder(cur, recp,\n\t\t\t\txfs_btree_rec_addr(cur, ptr, block)));\n\t\t} else {\n\t\t\tASSERT(cur->bc_ops->keys_inorder(cur, &key,\n\t\t\t\txfs_btree_key_addr(cur, ptr, block)));\n\t\t}\n\t}\n#endif\n\n\t/*\n\t * If the block is full, we can't insert the new entry until we\n\t * make the block un-full.\n\t */\n\txfs_btree_set_ptr_null(cur, &nptr);\n\tif (numrecs == cur->bc_ops->get_maxrecs(cur, level)) {\n\t\terror = xfs_btree_make_block_unfull(cur, level, numrecs,\n\t\t\t\t\t&optr, &ptr, &nptr, &ncur, &nrec, stat);\n\t\tif (error || *stat == 0)\n\t\t\tgoto error0;\n\t}\n\n\t/*\n\t * The current block may have changed if the block was\n\t * previously full and we have just made space in it.\n\t */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\tnumrecs = xfs_btree_get_numrecs(block);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\treturn error;\n#endif\n\n\t/*\n\t * At this point we know there's room for our new entry in the block\n\t * we're pointing at.\n\t */\n\tXFS_BTREE_STATS_ADD(cur, moves, numrecs - ptr + 1);\n\n\tif (level > 0) {\n\t\t/* It's a nonleaf. make a hole in the keys and ptrs */\n\t\tunion xfs_btree_key\t*kp;\n\t\tunion xfs_btree_ptr\t*pp;\n\n\t\tkp = xfs_btree_key_addr(cur, ptr, block);\n\t\tpp = xfs_btree_ptr_addr(cur, ptr, block);\n\n#ifdef DEBUG\n\t\tfor (i = numrecs - ptr; i >= 0; i--) {\n\t\t\terror = xfs_btree_check_ptr(cur, pp, i, level);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n#endif\n\n\t\txfs_btree_shift_keys(cur, kp, 1, numrecs - ptr + 1);\n\t\txfs_btree_shift_ptrs(cur, pp, 1, numrecs - ptr + 1);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_ptr(cur, ptrp, 0, level);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\t/* Now put the new data in, bump numrecs and log it. */\n\t\txfs_btree_copy_keys(cur, kp, &key, 1);\n\t\txfs_btree_copy_ptrs(cur, pp, ptrp, 1);\n\t\tnumrecs++;\n\t\txfs_btree_set_numrecs(block, numrecs);\n\t\txfs_btree_log_ptrs(cur, bp, ptr, numrecs);\n\t\txfs_btree_log_keys(cur, bp, ptr, numrecs);\n#ifdef DEBUG\n\t\tif (ptr < numrecs) {\n\t\t\tASSERT(cur->bc_ops->keys_inorder(cur, kp,\n\t\t\t\txfs_btree_key_addr(cur, ptr + 1, block)));\n\t\t}\n#endif\n\t} else {\n\t\t/* It's a leaf. make a hole in the records */\n\t\tunion xfs_btree_rec             *rp;\n\n\t\trp = xfs_btree_rec_addr(cur, ptr, block);\n\n\t\txfs_btree_shift_recs(cur, rp, 1, numrecs - ptr + 1);\n\n\t\t/* Now put the new data in, bump numrecs and log it. */\n\t\txfs_btree_copy_recs(cur, rp, recp, 1);\n\t\txfs_btree_set_numrecs(block, ++numrecs);\n\t\txfs_btree_log_recs(cur, bp, ptr, numrecs);\n#ifdef DEBUG\n\t\tif (ptr < numrecs) {\n\t\t\tASSERT(cur->bc_ops->recs_inorder(cur, rp,\n\t\t\t\txfs_btree_rec_addr(cur, ptr + 1, block)));\n\t\t}\n#endif\n\t}\n\n\t/* Log the new number of records in the btree header. */\n\txfs_btree_log_block(cur, bp, XFS_BB_NUMRECS);\n\n\t/* If we inserted at the start of a block, update the parents' keys. */\n\tif (optr == 1) {\n\t\terror = xfs_btree_updkey(cur, &key, level + 1);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\t/*\n\t * If we are tracking the last record in the tree and\n\t * we are at the far right edge of the tree, update it.\n\t */\n\tif (xfs_btree_is_lastrec(cur, block, level)) {\n\t\tcur->bc_ops->update_lastrec(cur, block, recp,\n\t\t\t\t\t    ptr, LASTREC_INSREC);\n\t}\n\n\t/*\n\t * Return the new block number, if any.\n\t * If there is one, give back a record value and a cursor too.\n\t */\n\t*ptrp = nptr;\n\tif (!xfs_btree_ptr_is_null(cur, &nptr)) {\n\t\t*recp = nrec;\n\t\t*curp = ncur;\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->init_rec_from_cur",
          "args": [
            "cur",
            "&rec"
          ],
          "line": 3122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_set_ptr_null",
          "args": [
            "cur",
            "&nptr"
          ],
          "line": 3121
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_set_ptr_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "924-933",
          "snippet": "STATIC void\nxfs_btree_set_ptr_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\tptr->l = cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\tptr->s = cpu_to_be32(NULLAGBLOCK);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_set_ptr_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\tptr->l = cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\tptr->s = cpu_to_be32(NULLAGBLOCK);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\nxfs_btree_insert(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* result value, 0 for failure */\n\tint\t\t\tlevel;\t/* current level number in btree */\n\tunion xfs_btree_ptr\tnptr;\t/* new block number (split result) */\n\tstruct xfs_btree_cur\t*ncur;\t/* new cursor (split result) */\n\tstruct xfs_btree_cur\t*pcur;\t/* previous level's cursor */\n\tunion xfs_btree_rec\trec;\t/* record to insert */\n\n\tlevel = 0;\n\tncur = NULL;\n\tpcur = cur;\n\n\txfs_btree_set_ptr_null(cur, &nptr);\n\tcur->bc_ops->init_rec_from_cur(cur, &rec);\n\n\t/*\n\t * Loop going up the tree, starting at the leaf level.\n\t * Stop when we don't get a split block, that must mean that\n\t * the insert is finished with this level.\n\t */\n\tdo {\n\t\t/*\n\t\t * Insert nrec/nptr into this level of the tree.\n\t\t * Note if we fail, nptr will be null.\n\t\t */\n\t\terror = xfs_btree_insrec(pcur, level, &nptr, &rec, &ncur, &i);\n\t\tif (error) {\n\t\t\tif (pcur != cur)\n\t\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_ERROR);\n\t\t\tgoto error0;\n\t\t}\n\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tlevel++;\n\n\t\t/*\n\t\t * See if the cursor we just used is trash.\n\t\t * Can't trash the caller's cursor, but otherwise we should\n\t\t * if ncur is a new cursor or we're about to be done.\n\t\t */\n\t\tif (pcur != cur &&\n\t\t    (ncur || xfs_btree_ptr_is_null(cur, &nptr))) {\n\t\t\t/* Save the state from the cursor before we trash it */\n\t\t\tif (cur->bc_ops->update_cursor)\n\t\t\t\tcur->bc_ops->update_cursor(pcur, cur);\n\t\t\tcur->bc_nlevels = pcur->bc_nlevels;\n\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_NOERROR);\n\t\t}\n\t\t/* If we got a new cursor, switch to it. */\n\t\tif (ncur) {\n\t\t\tpcur = ncur;\n\t\t\tncur = NULL;\n\t\t}\n\t} while (!xfs_btree_ptr_is_null(cur, &nptr));\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_btree_insrec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "2893-3095",
    "snippet": "STATIC int\nxfs_btree_insrec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level to insert record at */\n\tunion xfs_btree_ptr\t*ptrp,\t/* i/o: block number inserted */\n\tunion xfs_btree_rec\t*recp,\t/* i/o: record data inserted */\n\tstruct xfs_btree_cur\t**curp,\t/* output: new cursor replacing cur */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* btree block */\n\tstruct xfs_buf\t\t*bp;\t/* buffer for block */\n\tunion xfs_btree_key\tkey;\t/* btree key */\n\tunion xfs_btree_ptr\tnptr;\t/* new block ptr */\n\tstruct xfs_btree_cur\t*ncur;\t/* new btree cursor */\n\tunion xfs_btree_rec\tnrec;\t/* new record count */\n\tint\t\t\toptr;\t/* old key/record index */\n\tint\t\t\tptr;\t/* key/record index */\n\tint\t\t\tnumrecs;/* number of records */\n\tint\t\t\terror;\t/* error return value */\n#ifdef DEBUG\n\tint\t\t\ti;\n#endif\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGIPR(cur, level, *ptrp, recp);\n\n\tncur = NULL;\n\n\t/*\n\t * If we have an external root pointer, and we've made it to the\n\t * root level, allocate a new root block and we're done.\n\t */\n\tif (!(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level >= cur->bc_nlevels)) {\n\t\terror = xfs_btree_new_root(cur, stat);\n\t\txfs_btree_set_ptr_null(cur, ptrp);\n\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\treturn error;\n\t}\n\n\t/* If we're off the left edge, return failure. */\n\tptr = cur->bc_ptrs[level];\n\tif (ptr == 0) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t*stat = 0;\n\t\treturn 0;\n\t}\n\n\t/* Make a key out of the record data to be inserted, and save it. */\n\tcur->bc_ops->init_key_from_rec(&key, recp);\n\n\toptr = ptr;\n\n\tXFS_BTREE_STATS_INC(cur, insrec);\n\n\t/* Get pointers to the btree buffer and block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\tnumrecs = xfs_btree_get_numrecs(block);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* Check that the new entry is being inserted in the right place. */\n\tif (ptr <= numrecs) {\n\t\tif (level == 0) {\n\t\t\tASSERT(cur->bc_ops->recs_inorder(cur, recp,\n\t\t\t\txfs_btree_rec_addr(cur, ptr, block)));\n\t\t} else {\n\t\t\tASSERT(cur->bc_ops->keys_inorder(cur, &key,\n\t\t\t\txfs_btree_key_addr(cur, ptr, block)));\n\t\t}\n\t}\n#endif\n\n\t/*\n\t * If the block is full, we can't insert the new entry until we\n\t * make the block un-full.\n\t */\n\txfs_btree_set_ptr_null(cur, &nptr);\n\tif (numrecs == cur->bc_ops->get_maxrecs(cur, level)) {\n\t\terror = xfs_btree_make_block_unfull(cur, level, numrecs,\n\t\t\t\t\t&optr, &ptr, &nptr, &ncur, &nrec, stat);\n\t\tif (error || *stat == 0)\n\t\t\tgoto error0;\n\t}\n\n\t/*\n\t * The current block may have changed if the block was\n\t * previously full and we have just made space in it.\n\t */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\tnumrecs = xfs_btree_get_numrecs(block);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\treturn error;\n#endif\n\n\t/*\n\t * At this point we know there's room for our new entry in the block\n\t * we're pointing at.\n\t */\n\tXFS_BTREE_STATS_ADD(cur, moves, numrecs - ptr + 1);\n\n\tif (level > 0) {\n\t\t/* It's a nonleaf. make a hole in the keys and ptrs */\n\t\tunion xfs_btree_key\t*kp;\n\t\tunion xfs_btree_ptr\t*pp;\n\n\t\tkp = xfs_btree_key_addr(cur, ptr, block);\n\t\tpp = xfs_btree_ptr_addr(cur, ptr, block);\n\n#ifdef DEBUG\n\t\tfor (i = numrecs - ptr; i >= 0; i--) {\n\t\t\terror = xfs_btree_check_ptr(cur, pp, i, level);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n#endif\n\n\t\txfs_btree_shift_keys(cur, kp, 1, numrecs - ptr + 1);\n\t\txfs_btree_shift_ptrs(cur, pp, 1, numrecs - ptr + 1);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_ptr(cur, ptrp, 0, level);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\t/* Now put the new data in, bump numrecs and log it. */\n\t\txfs_btree_copy_keys(cur, kp, &key, 1);\n\t\txfs_btree_copy_ptrs(cur, pp, ptrp, 1);\n\t\tnumrecs++;\n\t\txfs_btree_set_numrecs(block, numrecs);\n\t\txfs_btree_log_ptrs(cur, bp, ptr, numrecs);\n\t\txfs_btree_log_keys(cur, bp, ptr, numrecs);\n#ifdef DEBUG\n\t\tif (ptr < numrecs) {\n\t\t\tASSERT(cur->bc_ops->keys_inorder(cur, kp,\n\t\t\t\txfs_btree_key_addr(cur, ptr + 1, block)));\n\t\t}\n#endif\n\t} else {\n\t\t/* It's a leaf. make a hole in the records */\n\t\tunion xfs_btree_rec             *rp;\n\n\t\trp = xfs_btree_rec_addr(cur, ptr, block);\n\n\t\txfs_btree_shift_recs(cur, rp, 1, numrecs - ptr + 1);\n\n\t\t/* Now put the new data in, bump numrecs and log it. */\n\t\txfs_btree_copy_recs(cur, rp, recp, 1);\n\t\txfs_btree_set_numrecs(block, ++numrecs);\n\t\txfs_btree_log_recs(cur, bp, ptr, numrecs);\n#ifdef DEBUG\n\t\tif (ptr < numrecs) {\n\t\t\tASSERT(cur->bc_ops->recs_inorder(cur, rp,\n\t\t\t\txfs_btree_rec_addr(cur, ptr + 1, block)));\n\t\t}\n#endif\n\t}\n\n\t/* Log the new number of records in the btree header. */\n\txfs_btree_log_block(cur, bp, XFS_BB_NUMRECS);\n\n\t/* If we inserted at the start of a block, update the parents' keys. */\n\tif (optr == 1) {\n\t\terror = xfs_btree_updkey(cur, &key, level + 1);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\t/*\n\t * If we are tracking the last record in the tree and\n\t * we are at the far right edge of the tree, update it.\n\t */\n\tif (xfs_btree_is_lastrec(cur, block, level)) {\n\t\tcur->bc_ops->update_lastrec(cur, block, recp,\n\t\t\t\t\t    ptr, LASTREC_INSREC);\n\t}\n\n\t/*\n\t * Return the new block number, if any.\n\t * If there is one, give back a record value and a cursor too.\n\t */\n\t*ptrp = nptr;\n\tif (!xfs_btree_ptr_is_null(cur, &nptr)) {\n\t\t*recp = nrec;\n\t\t*curp = ncur;\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ERROR"
          ],
          "line": 3093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 3088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_is_null",
          "args": [
            "cur",
            "&nptr"
          ],
          "line": 3083
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_is_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "913-922",
          "snippet": "STATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->update_lastrec",
          "args": [
            "cur",
            "block",
            "recp",
            "ptr",
            "LASTREC_INSREC"
          ],
          "line": 3074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_is_lastrec",
          "args": [
            "cur",
            "block",
            "level"
          ],
          "line": 3073
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_is_lastrec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1066-1083",
          "snippet": "STATIC int\nxfs_btree_is_lastrec(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tint\t\t\tlevel)\n{\n\tunion xfs_btree_ptr\tptr;\n\n\tif (level > 0)\n\t\treturn 0;\n\tif (!(cur->bc_flags & XFS_BTREE_LASTREC_UPDATE))\n\t\treturn 0;\n\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (!xfs_btree_ptr_is_null(cur, &ptr))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_is_lastrec(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tint\t\t\tlevel)\n{\n\tunion xfs_btree_ptr\tptr;\n\n\tif (level > 0)\n\t\treturn 0;\n\tif (!(cur->bc_flags & XFS_BTREE_LASTREC_UPDATE))\n\t\treturn 0;\n\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (!xfs_btree_ptr_is_null(cur, &ptr))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_updkey",
          "args": [
            "cur",
            "&key",
            "level + 1"
          ],
          "line": 3064
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_updkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1855-1897",
          "snippet": "STATIC int\nxfs_btree_updkey(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*keyp,\n\tint\t\t\tlevel)\n{\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_buf\t\t*bp;\n\tunion xfs_btree_key\t*kp;\n\tint\t\t\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGIK(cur, level, keyp);\n\n\tASSERT(!(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) || level >= 1);\n\n\t/*\n\t * Go up the tree from this level toward the root.\n\t * At each level, update the key value to the value input.\n\t * Stop when we reach a level where the cursor isn't pointing\n\t * at the first entry in the block.\n\t */\n\tfor (ptr = 1; ptr == 1 && level < cur->bc_nlevels; level++) {\n#ifdef DEBUG\n\t\tint\t\terror;\n#endif\n\t\tblock = xfs_btree_get_block(cur, level, &bp);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, level, bp);\n\t\tif (error) {\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\t\t\treturn error;\n\t\t}\n#endif\n\t\tptr = cur->bc_ptrs[level];\n\t\tkp = xfs_btree_key_addr(cur, ptr, block);\n\t\txfs_btree_copy_keys(cur, kp, keyp, 1);\n\t\txfs_btree_log_keys(cur, bp, ptr, ptr);\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_updkey(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*keyp,\n\tint\t\t\tlevel)\n{\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_buf\t\t*bp;\n\tunion xfs_btree_key\t*kp;\n\tint\t\t\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGIK(cur, level, keyp);\n\n\tASSERT(!(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) || level >= 1);\n\n\t/*\n\t * Go up the tree from this level toward the root.\n\t * At each level, update the key value to the value input.\n\t * Stop when we reach a level where the cursor isn't pointing\n\t * at the first entry in the block.\n\t */\n\tfor (ptr = 1; ptr == 1 && level < cur->bc_nlevels; level++) {\n#ifdef DEBUG\n\t\tint\t\terror;\n#endif\n\t\tblock = xfs_btree_get_block(cur, level, &bp);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, level, bp);\n\t\tif (error) {\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\t\t\treturn error;\n\t\t}\n#endif\n\t\tptr = cur->bc_ptrs[level];\n\t\tkp = xfs_btree_key_addr(cur, ptr, block);\n\t\txfs_btree_copy_keys(cur, kp, keyp, 1);\n\t\txfs_btree_log_keys(cur, bp, ptr, ptr);\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_block",
          "args": [
            "cur",
            "bp",
            "XFS_BB_NUMRECS"
          ],
          "line": 3060
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1357-1425",
          "snippet": "void\nxfs_btree_log_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfields)\t/* mask of fields: XFS_BB_... */\n{\n\tint\t\t\tfirst;\t/* first byte offset logged */\n\tint\t\t\tlast;\t/* last byte offset logged */\n\tstatic const short\tsoffsets[] = {\t/* table of offsets (short) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_crc),\n\t\tXFS_BTREE_SBLOCK_CRC_LEN\n\t};\n\tstatic const short\tloffsets[] = {\t/* table of offsets (long) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_crc),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_pad),\n\t\tXFS_BTREE_LBLOCK_CRC_LEN\n\t};\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBI(cur, bp, fields);\n\n\tif (bp) {\n\t\tint nbits;\n\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\t/*\n\t\t\t * We don't log the CRC when updating a btree\n\t\t\t * block but instead recreate it during log\n\t\t\t * recovery.  As the log buffers have checksums\n\t\t\t * of their own this is safe and avoids logging a crc\n\t\t\t * update in a lot of places.\n\t\t\t */\n\t\t\tif (fields == XFS_BB_ALL_BITS)\n\t\t\t\tfields = XFS_BB_ALL_BITS_CRC;\n\t\t\tnbits = XFS_BB_NUM_BITS_CRC;\n\t\t} else {\n\t\t\tnbits = XFS_BB_NUM_BITS;\n\t\t}\n\t\txfs_btree_offsets(fields,\n\t\t\t\t  (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\t\t\t\tloffsets : soffsets,\n\t\t\t\t  nbits, &first, &last);\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp, first, last);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_log_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfields)\t/* mask of fields: XFS_BB_... */\n{\n\tint\t\t\tfirst;\t/* first byte offset logged */\n\tint\t\t\tlast;\t/* last byte offset logged */\n\tstatic const short\tsoffsets[] = {\t/* table of offsets (short) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_crc),\n\t\tXFS_BTREE_SBLOCK_CRC_LEN\n\t};\n\tstatic const short\tloffsets[] = {\t/* table of offsets (long) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_crc),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_pad),\n\t\tXFS_BTREE_LBLOCK_CRC_LEN\n\t};\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBI(cur, bp, fields);\n\n\tif (bp) {\n\t\tint nbits;\n\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\t/*\n\t\t\t * We don't log the CRC when updating a btree\n\t\t\t * block but instead recreate it during log\n\t\t\t * recovery.  As the log buffers have checksums\n\t\t\t * of their own this is safe and avoids logging a crc\n\t\t\t * update in a lot of places.\n\t\t\t */\n\t\t\tif (fields == XFS_BB_ALL_BITS)\n\t\t\t\tfields = XFS_BB_ALL_BITS_CRC;\n\t\t\tnbits = XFS_BB_NUM_BITS_CRC;\n\t\t} else {\n\t\t\tnbits = XFS_BB_NUM_BITS;\n\t\t}\n\t\txfs_btree_offsets(fields,\n\t\t\t\t  (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\t\t\t\tloffsets : soffsets,\n\t\t\t\t  nbits, &first, &last);\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp, first, last);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cur->bc_ops->recs_inorder(cur, rp,\n\t\t\t\txfs_btree_rec_addr(cur, ptr + 1, block))"
          ],
          "line": 3053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->recs_inorder",
          "args": [
            "cur",
            "rp",
            "xfs_btree_rec_addr(cur, ptr + 1, block)"
          ],
          "line": 3053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_rec_addr",
          "args": [
            "cur",
            "ptr + 1",
            "block"
          ],
          "line": 3054
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_rec_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "468-476",
          "snippet": "xfs_btree_rec *\nxfs_btree_rec_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_rec *)\n\t\t((char *)block + xfs_btree_rec_offset(cur, n));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_rec *\nxfs_btree_rec_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_rec *)\n\t\t((char *)block + xfs_btree_rec_offset(cur, n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_recs",
          "args": [
            "cur",
            "bp",
            "ptr",
            "numrecs"
          ],
          "line": 3050
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_recs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1307-1323",
          "snippet": "void\nxfs_btree_log_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t  xfs_btree_rec_offset(cur, first),\n\t\t\t  xfs_btree_rec_offset(cur, last + 1) - 1);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_log_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t  xfs_btree_rec_offset(cur, first),\n\t\t\t  xfs_btree_rec_offset(cur, last + 1) - 1);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_set_numrecs",
          "args": [
            "block",
            "++numrecs"
          ],
          "line": 3049
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_set_numrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "421-425",
          "snippet": "static inline void xfs_btree_set_numrecs(struct xfs_btree_block *block,\n\t\t__uint16_t numrecs)\n{\n\tblock->bb_numrecs = cpu_to_be16(numrecs);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_btree_set_numrecs(struct xfs_btree_block *block,\n\t\t__uint16_t numrecs)\n{\n\tblock->bb_numrecs = cpu_to_be16(numrecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_copy_recs",
          "args": [
            "cur",
            "rp",
            "recp",
            "1"
          ],
          "line": 3048
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_copy_recs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1196-1205",
          "snippet": "STATIC void\nxfs_btree_copy_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*dst_rec,\n\tunion xfs_btree_rec\t*src_rec,\n\tint\t\t\tnumrecs)\n{\n\tASSERT(numrecs >= 0);\n\tmemcpy(dst_rec, src_rec, numrecs * cur->bc_ops->rec_len);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*dst_rec,\n\tunion xfs_btree_rec\t*src_rec,\n\tint\t\t\tnumrecs)\n{\n\tASSERT(numrecs >= 0);\n\tmemcpy(dst_rec, src_rec, numrecs * cur->bc_ops->rec_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_shift_recs",
          "args": [
            "cur",
            "rp",
            "1",
            "numrecs - ptr + 1"
          ],
          "line": 3045
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_shift_recs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1243-1257",
          "snippet": "STATIC void\nxfs_btree_shift_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*rec,\n\tint\t\t\tdir,\n\tint\t\t\tnumrecs)\n{\n\tchar\t\t\t*dst_rec;\n\n\tASSERT(numrecs >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_rec = (char *)rec + (dir * cur->bc_ops->rec_len);\n\tmemmove(dst_rec, rec, numrecs * cur->bc_ops->rec_len);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_shift_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*rec,\n\tint\t\t\tdir,\n\tint\t\t\tnumrecs)\n{\n\tchar\t\t\t*dst_rec;\n\n\tASSERT(numrecs >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_rec = (char *)rec + (dir * cur->bc_ops->rec_len);\n\tmemmove(dst_rec, rec, numrecs * cur->bc_ops->rec_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cur->bc_ops->keys_inorder(cur, kp,\n\t\t\t\txfs_btree_key_addr(cur, ptr + 1, block))"
          ],
          "line": 3035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->keys_inorder",
          "args": [
            "cur",
            "kp",
            "xfs_btree_key_addr(cur, ptr + 1, block)"
          ],
          "line": 3035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_key_addr",
          "args": [
            "cur",
            "ptr + 1",
            "block"
          ],
          "line": 3036
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_key_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "481-489",
          "snippet": "xfs_btree_key *\nxfs_btree_key_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_key *)\n\t\t((char *)block + xfs_btree_key_offset(cur, n));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_key *\nxfs_btree_key_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_key *)\n\t\t((char *)block + xfs_btree_key_offset(cur, n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_keys",
          "args": [
            "cur",
            "bp",
            "ptr",
            "numrecs"
          ],
          "line": 3032
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1281-1302",
          "snippet": "STATIC void\nxfs_btree_log_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\t  xfs_btree_key_offset(cur, first),\n\t\t\t\t  xfs_btree_key_offset(cur, last + 1) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_log_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\t  xfs_btree_key_offset(cur, first),\n\t\t\t\t  xfs_btree_key_offset(cur, last + 1) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_ptrs",
          "args": [
            "cur",
            "bp",
            "ptr",
            "numrecs"
          ],
          "line": 3031
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_ptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1328-1352",
          "snippet": "STATIC void\nxfs_btree_log_ptrs(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfirst,\t/* index of first pointer to log */\n\tint\t\t\tlast)\t/* index of last pointer to log */\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\t\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\txfs_btree_ptr_offset(cur, first, level),\n\t\t\t\txfs_btree_ptr_offset(cur, last + 1, level) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_log_ptrs(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfirst,\t/* index of first pointer to log */\n\tint\t\t\tlast)\t/* index of last pointer to log */\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\t\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\txfs_btree_ptr_offset(cur, first, level),\n\t\t\t\txfs_btree_ptr_offset(cur, last + 1, level) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_copy_ptrs",
          "args": [
            "cur",
            "pp",
            "ptrp",
            "1"
          ],
          "line": 3028
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_copy_ptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1210-1219",
          "snippet": "STATIC void\nxfs_btree_copy_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*dst_ptr,\n\tunion xfs_btree_ptr\t*src_ptr,\n\tint\t\t\tnumptrs)\n{\n\tASSERT(numptrs >= 0);\n\tmemcpy(dst_ptr, src_ptr, numptrs * xfs_btree_ptr_len(cur));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*dst_ptr,\n\tunion xfs_btree_ptr\t*src_ptr,\n\tint\t\t\tnumptrs)\n{\n\tASSERT(numptrs >= 0);\n\tmemcpy(dst_ptr, src_ptr, numptrs * xfs_btree_ptr_len(cur));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_copy_keys",
          "args": [
            "cur",
            "kp",
            "&key",
            "1"
          ],
          "line": 3027
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_copy_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1182-1191",
          "snippet": "STATIC void\nxfs_btree_copy_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*dst_key,\n\tunion xfs_btree_key\t*src_key,\n\tint\t\t\tnumkeys)\n{\n\tASSERT(numkeys >= 0);\n\tmemcpy(dst_key, src_key, numkeys * cur->bc_ops->key_len);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*dst_key,\n\tunion xfs_btree_key\t*src_key,\n\tint\t\t\tnumkeys)\n{\n\tASSERT(numkeys >= 0);\n\tmemcpy(dst_key, src_key, numkeys * cur->bc_ops->key_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_check_ptr",
          "args": [
            "cur",
            "ptrp",
            "0",
            "level"
          ],
          "line": 3021
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "201-215",
          "snippet": "STATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_ptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tunion xfs_btree_ptr\t*ptr,\t/* btree block disk address */\n\tint\t\t\tindex,\t/* offset from ptr to check */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\treturn xfs_btree_check_lptr(cur,\n\t\t\t\tbe64_to_cpu((&ptr->l)[index]), level);\n\t} else {\n\t\treturn xfs_btree_check_sptr(cur,\n\t\t\t\tbe32_to_cpu((&ptr->s)[index]), level);\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_ptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tunion xfs_btree_ptr\t*ptr,\t/* btree block disk address */\n\tint\t\t\tindex,\t/* offset from ptr to check */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\treturn xfs_btree_check_lptr(cur,\n\t\t\t\tbe64_to_cpu((&ptr->l)[index]), level);\n\t} else {\n\t\treturn xfs_btree_check_sptr(cur,\n\t\t\t\tbe32_to_cpu((&ptr->s)[index]), level);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_shift_ptrs",
          "args": [
            "cur",
            "pp",
            "1",
            "numrecs - ptr + 1"
          ],
          "line": 3018
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_shift_ptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1262-1276",
          "snippet": "STATIC void\nxfs_btree_shift_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tdir,\n\tint\t\t\tnumptrs)\n{\n\tchar\t\t\t*dst_ptr;\n\n\tASSERT(numptrs >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_ptr = (char *)ptr + (dir * xfs_btree_ptr_len(cur));\n\tmemmove(dst_ptr, ptr, numptrs * xfs_btree_ptr_len(cur));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_shift_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tdir,\n\tint\t\t\tnumptrs)\n{\n\tchar\t\t\t*dst_ptr;\n\n\tASSERT(numptrs >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_ptr = (char *)ptr + (dir * xfs_btree_ptr_len(cur));\n\tmemmove(dst_ptr, ptr, numptrs * xfs_btree_ptr_len(cur));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_shift_keys",
          "args": [
            "cur",
            "kp",
            "1",
            "numrecs - ptr + 1"
          ],
          "line": 3017
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_shift_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1224-1238",
          "snippet": "STATIC void\nxfs_btree_shift_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*key,\n\tint\t\t\tdir,\n\tint\t\t\tnumkeys)\n{\n\tchar\t\t\t*dst_key;\n\n\tASSERT(numkeys >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_key = (char *)key + (dir * cur->bc_ops->key_len);\n\tmemmove(dst_key, key, numkeys * cur->bc_ops->key_len);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_shift_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*key,\n\tint\t\t\tdir,\n\tint\t\t\tnumkeys)\n{\n\tchar\t\t\t*dst_key;\n\n\tASSERT(numkeys >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_key = (char *)key + (dir * cur->bc_ops->key_len);\n\tmemmove(dst_key, key, numkeys * cur->bc_ops->key_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_addr",
          "args": [
            "cur",
            "ptr",
            "block"
          ],
          "line": 3007
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "494-506",
          "snippet": "xfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_ADD",
          "args": [
            "cur",
            "moves",
            "numrecs - ptr + 1"
          ],
          "line": 2999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_check_block",
          "args": [
            "cur",
            "block",
            "level",
            "bp"
          ],
          "line": 2990
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "149-160",
          "snippet": "int\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_numrecs",
          "args": [
            "block"
          ],
          "line": 2987
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_numrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "416-419",
          "snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_block",
          "args": [
            "cur",
            "level",
            "&bp"
          ],
          "line": 2986
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "528-542",
          "snippet": "xfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_make_block_unfull",
          "args": [
            "cur",
            "level",
            "numrecs",
            "&optr",
            "&ptr",
            "&nptr",
            "&ncur",
            "&nrec",
            "stat"
          ],
          "line": 2976
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_make_block_unfull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "2822-2887",
          "snippet": "STATIC int\nxfs_btree_make_block_unfull(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* btree level */\n\tint\t\t\tnumrecs,/* # of recs in block */\n\tint\t\t\t*oindex,/* old tree index */\n\tint\t\t\t*index,\t/* new tree index */\n\tunion xfs_btree_ptr\t*nptr,\t/* new btree ptr */\n\tstruct xfs_btree_cur\t**ncur,\t/* new btree cursor */\n\tunion xfs_btree_rec\t*nrec,\t/* new record */\n\tint\t\t\t*stat)\n{\n\tunion xfs_btree_key\tkey;\t/* new btree key value */\n\tint\t\t\terror = 0;\n\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    level == cur->bc_nlevels - 1) {\n\t    \tstruct xfs_inode *ip = cur->bc_private.b.ip;\n\n\t\tif (numrecs < cur->bc_ops->get_dmaxrecs(cur, level)) {\n\t\t\t/* A root block that can be made bigger. */\n\t\t\txfs_iroot_realloc(ip, 1, cur->bc_private.b.whichfork);\n\t\t} else {\n\t\t\t/* A root block that needs replacing */\n\t\t\tint\tlogflags = 0;\n\n\t\t\terror = xfs_btree_new_iroot(cur, &logflags, stat);\n\t\t\tif (error || *stat == 0)\n\t\t\t\treturn error;\n\n\t\t\txfs_trans_log_inode(cur->bc_tp, ip, logflags);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/* First, try shifting an entry to the right neighbor. */\n\terror = xfs_btree_rshift(cur, level, stat);\n\tif (error || *stat)\n\t\treturn error;\n\n\t/* Next, try shifting an entry to the left neighbor. */\n\terror = xfs_btree_lshift(cur, level, stat);\n\tif (error)\n\t\treturn error;\n\n\tif (*stat) {\n\t\t*oindex = *index = cur->bc_ptrs[level];\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Next, try splitting the current block in half.\n\t *\n\t * If this works we have to re-set our variables because we\n\t * could be in a different block now.\n\t */\n\terror = xfs_btree_split(cur, level, nptr, &key, ncur, stat);\n\tif (error || *stat == 0)\n\t\treturn error;\n\n\n\t*index = cur->bc_ptrs[level];\n\tcur->bc_ops->init_rec_from_key(&key, nrec);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_make_block_unfull(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* btree level */\n\tint\t\t\tnumrecs,/* # of recs in block */\n\tint\t\t\t*oindex,/* old tree index */\n\tint\t\t\t*index,\t/* new tree index */\n\tunion xfs_btree_ptr\t*nptr,\t/* new btree ptr */\n\tstruct xfs_btree_cur\t**ncur,\t/* new btree cursor */\n\tunion xfs_btree_rec\t*nrec,\t/* new record */\n\tint\t\t\t*stat)\n{\n\tunion xfs_btree_key\tkey;\t/* new btree key value */\n\tint\t\t\terror = 0;\n\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    level == cur->bc_nlevels - 1) {\n\t    \tstruct xfs_inode *ip = cur->bc_private.b.ip;\n\n\t\tif (numrecs < cur->bc_ops->get_dmaxrecs(cur, level)) {\n\t\t\t/* A root block that can be made bigger. */\n\t\t\txfs_iroot_realloc(ip, 1, cur->bc_private.b.whichfork);\n\t\t} else {\n\t\t\t/* A root block that needs replacing */\n\t\t\tint\tlogflags = 0;\n\n\t\t\terror = xfs_btree_new_iroot(cur, &logflags, stat);\n\t\t\tif (error || *stat == 0)\n\t\t\t\treturn error;\n\n\t\t\txfs_trans_log_inode(cur->bc_tp, ip, logflags);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/* First, try shifting an entry to the right neighbor. */\n\terror = xfs_btree_rshift(cur, level, stat);\n\tif (error || *stat)\n\t\treturn error;\n\n\t/* Next, try shifting an entry to the left neighbor. */\n\terror = xfs_btree_lshift(cur, level, stat);\n\tif (error)\n\t\treturn error;\n\n\tif (*stat) {\n\t\t*oindex = *index = cur->bc_ptrs[level];\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Next, try splitting the current block in half.\n\t *\n\t * If this works we have to re-set our variables because we\n\t * could be in a different block now.\n\t */\n\terror = xfs_btree_split(cur, level, nptr, &key, ncur, stat);\n\tif (error || *stat == 0)\n\t\treturn error;\n\n\n\t*index = cur->bc_ptrs[level];\n\tcur->bc_ops->init_rec_from_key(&key, nrec);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->get_maxrecs",
          "args": [
            "cur",
            "level"
          ],
          "line": 2975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_set_ptr_null",
          "args": [
            "cur",
            "&nptr"
          ],
          "line": 2974
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_set_ptr_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "924-933",
          "snippet": "STATIC void\nxfs_btree_set_ptr_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\tptr->l = cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\tptr->s = cpu_to_be32(NULLAGBLOCK);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_set_ptr_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\tptr->l = cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\tptr->s = cpu_to_be32(NULLAGBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cur->bc_ops->keys_inorder(cur, &key,\n\t\t\t\txfs_btree_key_addr(cur, ptr, block))"
          ],
          "line": 2964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->keys_inorder",
          "args": [
            "cur",
            "&key",
            "xfs_btree_key_addr(cur, ptr, block)"
          ],
          "line": 2964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cur->bc_ops->recs_inorder(cur, recp,\n\t\t\t\txfs_btree_rec_addr(cur, ptr, block))"
          ],
          "line": 2961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->recs_inorder",
          "args": [
            "cur",
            "recp",
            "xfs_btree_rec_addr(cur, ptr, block)"
          ],
          "line": 2961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_INC",
          "args": [
            "cur",
            "insrec"
          ],
          "line": 2947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->init_key_from_rec",
          "args": [
            "&key",
            "recp"
          ],
          "line": 2943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 2937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 2930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_new_root",
          "args": [
            "cur",
            "stat"
          ],
          "line": 2927
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_new_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "2698-2820",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_btree_new_root(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* one half of the old root block */\n\tstruct xfs_buf\t\t*bp;\t/* buffer containing block */\n\tint\t\t\terror;\t/* error return value */\n\tstruct xfs_buf\t\t*lbp;\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t/* left btree block */\n\tstruct xfs_buf\t\t*nbp;\t/* new (root) buffer */\n\tstruct xfs_btree_block\t*new;\t/* new (root) btree block */\n\tint\t\t\tnptr;\t/* new value for key index, 1 or 2 */\n\tstruct xfs_buf\t\t*rbp;\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t/* right btree block */\n\tunion xfs_btree_ptr\trptr;\n\tunion xfs_btree_ptr\tlptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_STATS_INC(cur, newroot);\n\n\t/* initialise our start point from the cursor */\n\tcur->bc_ops->init_ptr_from_cur(cur, &rptr);\n\n\t/* Allocate the new block. If we can't do it, we're toast. Give up. */\n\terror = cur->bc_ops->alloc_block(cur, &rptr, &lptr, stat);\n\tif (error)\n\t\tgoto error0;\n\tif (*stat == 0)\n\t\tgoto out0;\n\tXFS_BTREE_STATS_INC(cur, alloc);\n\n\t/* Set up the new block. */\n\terror = xfs_btree_get_buf_block(cur, &lptr, 0, &new, &nbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* Set the root in the holding structure  increasing the level by 1. */\n\tcur->bc_ops->set_root(cur, &lptr, 1);\n\n\t/*\n\t * At the previous root level there are now two blocks: the old root,\n\t * and the new block generated when it was split.  We don't know which\n\t * one the cursor is pointing at, so we set up variables \"left\" and\n\t * \"right\" for each case.\n\t */\n\tblock = xfs_btree_get_block(cur, cur->bc_nlevels - 1, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, cur->bc_nlevels - 1, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\txfs_btree_get_sibling(cur, block, &rptr, XFS_BB_RIGHTSIB);\n\tif (!xfs_btree_ptr_is_null(cur, &rptr)) {\n\t\t/* Our block is left, pick up the right block. */\n\t\tlbp = bp;\n\t\txfs_btree_buf_to_ptr(cur, lbp, &lptr);\n\t\tleft = block;\n\t\terror = xfs_btree_read_buf_block(cur, &rptr, 0, &right, &rbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tbp = rbp;\n\t\tnptr = 1;\n\t} else {\n\t\t/* Our block is right, pick up the left block. */\n\t\trbp = bp;\n\t\txfs_btree_buf_to_ptr(cur, rbp, &rptr);\n\t\tright = block;\n\t\txfs_btree_get_sibling(cur, right, &lptr, XFS_BB_LEFTSIB);\n\t\terror = xfs_btree_read_buf_block(cur, &lptr, 0, &left, &lbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tbp = lbp;\n\t\tnptr = 2;\n\t}\n\t/* Fill in the new block's btree header and log it. */\n\txfs_btree_init_block_cur(cur, nbp, cur->bc_nlevels, 2);\n\txfs_btree_log_block(cur, nbp, XFS_BB_ALL_BITS);\n\tASSERT(!xfs_btree_ptr_is_null(cur, &lptr) &&\n\t\t\t!xfs_btree_ptr_is_null(cur, &rptr));\n\n\t/* Fill in the key data in the new root. */\n\tif (xfs_btree_get_level(left) > 0) {\n\t\txfs_btree_copy_keys(cur,\n\t\t\t\txfs_btree_key_addr(cur, 1, new),\n\t\t\t\txfs_btree_key_addr(cur, 1, left), 1);\n\t\txfs_btree_copy_keys(cur,\n\t\t\t\txfs_btree_key_addr(cur, 2, new),\n\t\t\t\txfs_btree_key_addr(cur, 1, right), 1);\n\t} else {\n\t\tcur->bc_ops->init_key_from_rec(\n\t\t\t\txfs_btree_key_addr(cur, 1, new),\n\t\t\t\txfs_btree_rec_addr(cur, 1, left));\n\t\tcur->bc_ops->init_key_from_rec(\n\t\t\t\txfs_btree_key_addr(cur, 2, new),\n\t\t\t\txfs_btree_rec_addr(cur, 1, right));\n\t}\n\txfs_btree_log_keys(cur, nbp, 1, 2);\n\n\t/* Fill in the pointer data in the new root. */\n\txfs_btree_copy_ptrs(cur,\n\t\txfs_btree_ptr_addr(cur, 1, new), &lptr, 1);\n\txfs_btree_copy_ptrs(cur,\n\t\txfs_btree_ptr_addr(cur, 2, new), &rptr, 1);\n\txfs_btree_log_ptrs(cur, nbp, 1, 2);\n\n\t/* Fix up the cursor. */\n\txfs_btree_setbuf(cur, cur->bc_nlevels, nbp);\n\tcur->bc_ptrs[cur->bc_nlevels] = nptr;\n\tcur->bc_nlevels++;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\t\t\t\t/* error */\nxfs_btree_new_root(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* one half of the old root block */\n\tstruct xfs_buf\t\t*bp;\t/* buffer containing block */\n\tint\t\t\terror;\t/* error return value */\n\tstruct xfs_buf\t\t*lbp;\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t/* left btree block */\n\tstruct xfs_buf\t\t*nbp;\t/* new (root) buffer */\n\tstruct xfs_btree_block\t*new;\t/* new (root) btree block */\n\tint\t\t\tnptr;\t/* new value for key index, 1 or 2 */\n\tstruct xfs_buf\t\t*rbp;\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t/* right btree block */\n\tunion xfs_btree_ptr\trptr;\n\tunion xfs_btree_ptr\tlptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_STATS_INC(cur, newroot);\n\n\t/* initialise our start point from the cursor */\n\tcur->bc_ops->init_ptr_from_cur(cur, &rptr);\n\n\t/* Allocate the new block. If we can't do it, we're toast. Give up. */\n\terror = cur->bc_ops->alloc_block(cur, &rptr, &lptr, stat);\n\tif (error)\n\t\tgoto error0;\n\tif (*stat == 0)\n\t\tgoto out0;\n\tXFS_BTREE_STATS_INC(cur, alloc);\n\n\t/* Set up the new block. */\n\terror = xfs_btree_get_buf_block(cur, &lptr, 0, &new, &nbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* Set the root in the holding structure  increasing the level by 1. */\n\tcur->bc_ops->set_root(cur, &lptr, 1);\n\n\t/*\n\t * At the previous root level there are now two blocks: the old root,\n\t * and the new block generated when it was split.  We don't know which\n\t * one the cursor is pointing at, so we set up variables \"left\" and\n\t * \"right\" for each case.\n\t */\n\tblock = xfs_btree_get_block(cur, cur->bc_nlevels - 1, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, cur->bc_nlevels - 1, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\txfs_btree_get_sibling(cur, block, &rptr, XFS_BB_RIGHTSIB);\n\tif (!xfs_btree_ptr_is_null(cur, &rptr)) {\n\t\t/* Our block is left, pick up the right block. */\n\t\tlbp = bp;\n\t\txfs_btree_buf_to_ptr(cur, lbp, &lptr);\n\t\tleft = block;\n\t\terror = xfs_btree_read_buf_block(cur, &rptr, 0, &right, &rbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tbp = rbp;\n\t\tnptr = 1;\n\t} else {\n\t\t/* Our block is right, pick up the left block. */\n\t\trbp = bp;\n\t\txfs_btree_buf_to_ptr(cur, rbp, &rptr);\n\t\tright = block;\n\t\txfs_btree_get_sibling(cur, right, &lptr, XFS_BB_LEFTSIB);\n\t\terror = xfs_btree_read_buf_block(cur, &lptr, 0, &left, &lbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tbp = lbp;\n\t\tnptr = 2;\n\t}\n\t/* Fill in the new block's btree header and log it. */\n\txfs_btree_init_block_cur(cur, nbp, cur->bc_nlevels, 2);\n\txfs_btree_log_block(cur, nbp, XFS_BB_ALL_BITS);\n\tASSERT(!xfs_btree_ptr_is_null(cur, &lptr) &&\n\t\t\t!xfs_btree_ptr_is_null(cur, &rptr));\n\n\t/* Fill in the key data in the new root. */\n\tif (xfs_btree_get_level(left) > 0) {\n\t\txfs_btree_copy_keys(cur,\n\t\t\t\txfs_btree_key_addr(cur, 1, new),\n\t\t\t\txfs_btree_key_addr(cur, 1, left), 1);\n\t\txfs_btree_copy_keys(cur,\n\t\t\t\txfs_btree_key_addr(cur, 2, new),\n\t\t\t\txfs_btree_key_addr(cur, 1, right), 1);\n\t} else {\n\t\tcur->bc_ops->init_key_from_rec(\n\t\t\t\txfs_btree_key_addr(cur, 1, new),\n\t\t\t\txfs_btree_rec_addr(cur, 1, left));\n\t\tcur->bc_ops->init_key_from_rec(\n\t\t\t\txfs_btree_key_addr(cur, 2, new),\n\t\t\t\txfs_btree_rec_addr(cur, 1, right));\n\t}\n\txfs_btree_log_keys(cur, nbp, 1, 2);\n\n\t/* Fill in the pointer data in the new root. */\n\txfs_btree_copy_ptrs(cur,\n\t\txfs_btree_ptr_addr(cur, 1, new), &lptr, 1);\n\txfs_btree_copy_ptrs(cur,\n\t\txfs_btree_ptr_addr(cur, 2, new), &rptr, 1);\n\txfs_btree_log_ptrs(cur, nbp, 1, 2);\n\n\t/* Fix up the cursor. */\n\txfs_btree_setbuf(cur, cur->bc_nlevels, nbp);\n\tcur->bc_ptrs[cur->bc_nlevels] = nptr;\n\tcur->bc_nlevels++;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_ARGIPR",
          "args": [
            "cur",
            "level",
            "*ptrp",
            "recp"
          ],
          "line": 2917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ENTRY"
          ],
          "line": 2916
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_insrec(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level to insert record at */\n\tunion xfs_btree_ptr\t*ptrp,\t/* i/o: block number inserted */\n\tunion xfs_btree_rec\t*recp,\t/* i/o: record data inserted */\n\tstruct xfs_btree_cur\t**curp,\t/* output: new cursor replacing cur */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* btree block */\n\tstruct xfs_buf\t\t*bp;\t/* buffer for block */\n\tunion xfs_btree_key\tkey;\t/* btree key */\n\tunion xfs_btree_ptr\tnptr;\t/* new block ptr */\n\tstruct xfs_btree_cur\t*ncur;\t/* new btree cursor */\n\tunion xfs_btree_rec\tnrec;\t/* new record count */\n\tint\t\t\toptr;\t/* old key/record index */\n\tint\t\t\tptr;\t/* key/record index */\n\tint\t\t\tnumrecs;/* number of records */\n\tint\t\t\terror;\t/* error return value */\n#ifdef DEBUG\n\tint\t\t\ti;\n#endif\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGIPR(cur, level, *ptrp, recp);\n\n\tncur = NULL;\n\n\t/*\n\t * If we have an external root pointer, and we've made it to the\n\t * root level, allocate a new root block and we're done.\n\t */\n\tif (!(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level >= cur->bc_nlevels)) {\n\t\terror = xfs_btree_new_root(cur, stat);\n\t\txfs_btree_set_ptr_null(cur, ptrp);\n\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\treturn error;\n\t}\n\n\t/* If we're off the left edge, return failure. */\n\tptr = cur->bc_ptrs[level];\n\tif (ptr == 0) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t*stat = 0;\n\t\treturn 0;\n\t}\n\n\t/* Make a key out of the record data to be inserted, and save it. */\n\tcur->bc_ops->init_key_from_rec(&key, recp);\n\n\toptr = ptr;\n\n\tXFS_BTREE_STATS_INC(cur, insrec);\n\n\t/* Get pointers to the btree buffer and block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\tnumrecs = xfs_btree_get_numrecs(block);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* Check that the new entry is being inserted in the right place. */\n\tif (ptr <= numrecs) {\n\t\tif (level == 0) {\n\t\t\tASSERT(cur->bc_ops->recs_inorder(cur, recp,\n\t\t\t\txfs_btree_rec_addr(cur, ptr, block)));\n\t\t} else {\n\t\t\tASSERT(cur->bc_ops->keys_inorder(cur, &key,\n\t\t\t\txfs_btree_key_addr(cur, ptr, block)));\n\t\t}\n\t}\n#endif\n\n\t/*\n\t * If the block is full, we can't insert the new entry until we\n\t * make the block un-full.\n\t */\n\txfs_btree_set_ptr_null(cur, &nptr);\n\tif (numrecs == cur->bc_ops->get_maxrecs(cur, level)) {\n\t\terror = xfs_btree_make_block_unfull(cur, level, numrecs,\n\t\t\t\t\t&optr, &ptr, &nptr, &ncur, &nrec, stat);\n\t\tif (error || *stat == 0)\n\t\t\tgoto error0;\n\t}\n\n\t/*\n\t * The current block may have changed if the block was\n\t * previously full and we have just made space in it.\n\t */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\tnumrecs = xfs_btree_get_numrecs(block);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\treturn error;\n#endif\n\n\t/*\n\t * At this point we know there's room for our new entry in the block\n\t * we're pointing at.\n\t */\n\tXFS_BTREE_STATS_ADD(cur, moves, numrecs - ptr + 1);\n\n\tif (level > 0) {\n\t\t/* It's a nonleaf. make a hole in the keys and ptrs */\n\t\tunion xfs_btree_key\t*kp;\n\t\tunion xfs_btree_ptr\t*pp;\n\n\t\tkp = xfs_btree_key_addr(cur, ptr, block);\n\t\tpp = xfs_btree_ptr_addr(cur, ptr, block);\n\n#ifdef DEBUG\n\t\tfor (i = numrecs - ptr; i >= 0; i--) {\n\t\t\terror = xfs_btree_check_ptr(cur, pp, i, level);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n#endif\n\n\t\txfs_btree_shift_keys(cur, kp, 1, numrecs - ptr + 1);\n\t\txfs_btree_shift_ptrs(cur, pp, 1, numrecs - ptr + 1);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_ptr(cur, ptrp, 0, level);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\t/* Now put the new data in, bump numrecs and log it. */\n\t\txfs_btree_copy_keys(cur, kp, &key, 1);\n\t\txfs_btree_copy_ptrs(cur, pp, ptrp, 1);\n\t\tnumrecs++;\n\t\txfs_btree_set_numrecs(block, numrecs);\n\t\txfs_btree_log_ptrs(cur, bp, ptr, numrecs);\n\t\txfs_btree_log_keys(cur, bp, ptr, numrecs);\n#ifdef DEBUG\n\t\tif (ptr < numrecs) {\n\t\t\tASSERT(cur->bc_ops->keys_inorder(cur, kp,\n\t\t\t\txfs_btree_key_addr(cur, ptr + 1, block)));\n\t\t}\n#endif\n\t} else {\n\t\t/* It's a leaf. make a hole in the records */\n\t\tunion xfs_btree_rec             *rp;\n\n\t\trp = xfs_btree_rec_addr(cur, ptr, block);\n\n\t\txfs_btree_shift_recs(cur, rp, 1, numrecs - ptr + 1);\n\n\t\t/* Now put the new data in, bump numrecs and log it. */\n\t\txfs_btree_copy_recs(cur, rp, recp, 1);\n\t\txfs_btree_set_numrecs(block, ++numrecs);\n\t\txfs_btree_log_recs(cur, bp, ptr, numrecs);\n#ifdef DEBUG\n\t\tif (ptr < numrecs) {\n\t\t\tASSERT(cur->bc_ops->recs_inorder(cur, rp,\n\t\t\t\txfs_btree_rec_addr(cur, ptr + 1, block)));\n\t\t}\n#endif\n\t}\n\n\t/* Log the new number of records in the btree header. */\n\txfs_btree_log_block(cur, bp, XFS_BB_NUMRECS);\n\n\t/* If we inserted at the start of a block, update the parents' keys. */\n\tif (optr == 1) {\n\t\terror = xfs_btree_updkey(cur, &key, level + 1);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\t/*\n\t * If we are tracking the last record in the tree and\n\t * we are at the far right edge of the tree, update it.\n\t */\n\tif (xfs_btree_is_lastrec(cur, block, level)) {\n\t\tcur->bc_ops->update_lastrec(cur, block, recp,\n\t\t\t\t\t    ptr, LASTREC_INSREC);\n\t}\n\n\t/*\n\t * Return the new block number, if any.\n\t * If there is one, give back a record value and a cursor too.\n\t */\n\t*ptrp = nptr;\n\tif (!xfs_btree_ptr_is_null(cur, &nptr)) {\n\t\t*recp = nrec;\n\t\t*curp = ncur;\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_btree_make_block_unfull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "2822-2887",
    "snippet": "STATIC int\nxfs_btree_make_block_unfull(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* btree level */\n\tint\t\t\tnumrecs,/* # of recs in block */\n\tint\t\t\t*oindex,/* old tree index */\n\tint\t\t\t*index,\t/* new tree index */\n\tunion xfs_btree_ptr\t*nptr,\t/* new btree ptr */\n\tstruct xfs_btree_cur\t**ncur,\t/* new btree cursor */\n\tunion xfs_btree_rec\t*nrec,\t/* new record */\n\tint\t\t\t*stat)\n{\n\tunion xfs_btree_key\tkey;\t/* new btree key value */\n\tint\t\t\terror = 0;\n\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    level == cur->bc_nlevels - 1) {\n\t    \tstruct xfs_inode *ip = cur->bc_private.b.ip;\n\n\t\tif (numrecs < cur->bc_ops->get_dmaxrecs(cur, level)) {\n\t\t\t/* A root block that can be made bigger. */\n\t\t\txfs_iroot_realloc(ip, 1, cur->bc_private.b.whichfork);\n\t\t} else {\n\t\t\t/* A root block that needs replacing */\n\t\t\tint\tlogflags = 0;\n\n\t\t\terror = xfs_btree_new_iroot(cur, &logflags, stat);\n\t\t\tif (error || *stat == 0)\n\t\t\t\treturn error;\n\n\t\t\txfs_trans_log_inode(cur->bc_tp, ip, logflags);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/* First, try shifting an entry to the right neighbor. */\n\terror = xfs_btree_rshift(cur, level, stat);\n\tif (error || *stat)\n\t\treturn error;\n\n\t/* Next, try shifting an entry to the left neighbor. */\n\terror = xfs_btree_lshift(cur, level, stat);\n\tif (error)\n\t\treturn error;\n\n\tif (*stat) {\n\t\t*oindex = *index = cur->bc_ptrs[level];\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Next, try splitting the current block in half.\n\t *\n\t * If this works we have to re-set our variables because we\n\t * could be in a different block now.\n\t */\n\terror = xfs_btree_split(cur, level, nptr, &key, ncur, stat);\n\tif (error || *stat == 0)\n\t\treturn error;\n\n\n\t*index = cur->bc_ptrs[level];\n\tcur->bc_ops->init_rec_from_key(&key, nrec);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cur->bc_ops->init_rec_from_key",
          "args": [
            "&key",
            "nrec"
          ],
          "line": 2885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_split",
          "args": [
            "cur",
            "level",
            "nptr",
            "&key",
            "ncur",
            "stat"
          ],
          "line": 2879
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "2553-2581",
          "snippet": "STATIC int\t\t\t\t\t/* error */\nxfs_btree_split(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tunion xfs_btree_ptr\t*ptrp,\n\tunion xfs_btree_key\t*key,\n\tstruct xfs_btree_cur\t**curp,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_split_args\targs;\n\tDECLARE_COMPLETION_ONSTACK(done);\n\n\tif (cur->bc_btnum != XFS_BTNUM_BMAP)\n\t\treturn __xfs_btree_split(cur, level, ptrp, key, curp, stat);\n\n\targs.cur = cur;\n\targs.level = level;\n\targs.ptrp = ptrp;\n\targs.key = key;\n\targs.curp = curp;\n\targs.stat = stat;\n\targs.done = &done;\n\targs.kswapd = current_is_kswapd();\n\tINIT_WORK_ONSTACK(&args.work, xfs_btree_split_worker);\n\tqueue_work(xfs_alloc_wq, &args.work);\n\twait_for_completion(&done);\n\tdestroy_work_on_stack(&args.work);\n\treturn args.result;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\t\t\t\t\t/* error */\nxfs_btree_split(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tunion xfs_btree_ptr\t*ptrp,\n\tunion xfs_btree_key\t*key,\n\tstruct xfs_btree_cur\t**curp,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_split_args\targs;\n\tDECLARE_COMPLETION_ONSTACK(done);\n\n\tif (cur->bc_btnum != XFS_BTNUM_BMAP)\n\t\treturn __xfs_btree_split(cur, level, ptrp, key, curp, stat);\n\n\targs.cur = cur;\n\targs.level = level;\n\targs.ptrp = ptrp;\n\targs.key = key;\n\targs.curp = curp;\n\targs.stat = stat;\n\targs.done = &done;\n\targs.kswapd = current_is_kswapd();\n\tINIT_WORK_ONSTACK(&args.work, xfs_btree_split_worker);\n\tqueue_work(xfs_alloc_wq, &args.work);\n\twait_for_completion(&done);\n\tdestroy_work_on_stack(&args.work);\n\treturn args.result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_lshift",
          "args": [
            "cur",
            "level",
            "stat"
          ],
          "line": 2864
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_lshift",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1965-2142",
          "snippet": "STATIC int\t\t\t\t\t/* error */\nxfs_btree_lshift(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tunion xfs_btree_key\tkey;\t\t/* btree key */\n\tstruct xfs_buf\t\t*lbp;\t\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t\t/* left btree block */\n\tint\t\t\tlrecs;\t\t/* left record count */\n\tstruct xfs_buf\t\t*rbp;\t\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t\t/* right btree block */\n\tint\t\t\trrecs;\t\t/* right record count */\n\tunion xfs_btree_ptr\tlptr;\t\t/* left btree pointer */\n\tunion xfs_btree_key\t*rkp = NULL;\t/* right btree key */\n\tunion xfs_btree_ptr\t*rpp = NULL;\t/* right address pointer */\n\tunion xfs_btree_rec\t*rrp = NULL;\t/* right record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    level == cur->bc_nlevels - 1)\n\t\tgoto out0;\n\n\t/* Set up variables for this block as \"right\". */\n\tright = xfs_btree_get_block(cur, level, &rbp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, right, level, rbp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* If we've got no left sibling then we can't shift an entry left. */\n\txfs_btree_get_sibling(cur, right, &lptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &lptr))\n\t\tgoto out0;\n\n\t/*\n\t * If the cursor entry is the one that would be moved, don't\n\t * do it... it's too complicated.\n\t */\n\tif (cur->bc_ptrs[level] <= 1)\n\t\tgoto out0;\n\n\t/* Set up the left neighbor as \"left\". */\n\terror = xfs_btree_read_buf_block(cur, &lptr, 0, &left, &lbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* If it's full, it can't take another entry. */\n\tlrecs = xfs_btree_get_numrecs(left);\n\tif (lrecs == cur->bc_ops->get_maxrecs(cur, level))\n\t\tgoto out0;\n\n\trrecs = xfs_btree_get_numrecs(right);\n\n\t/*\n\t * We add one entry to the left side and remove one for the right side.\n\t * Account for it here, the changes will be updated on disk and logged\n\t * later.\n\t */\n\tlrecs++;\n\trrecs--;\n\n\tXFS_BTREE_STATS_INC(cur, lshift);\n\tXFS_BTREE_STATS_ADD(cur, moves, 1);\n\n\t/*\n\t * If non-leaf, copy a key and a ptr to the left block.\n\t * Log the changes to the left block.\n\t */\n\tif (level > 0) {\n\t\t/* It's a non-leaf.  Move keys and pointers. */\n\t\tunion xfs_btree_key\t*lkp;\t/* left btree key */\n\t\tunion xfs_btree_ptr\t*lpp;\t/* left address pointer */\n\n\t\tlkp = xfs_btree_key_addr(cur, lrecs, left);\n\t\trkp = xfs_btree_key_addr(cur, 1, right);\n\n\t\tlpp = xfs_btree_ptr_addr(cur, lrecs, left);\n\t\trpp = xfs_btree_ptr_addr(cur, 1, right);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_ptr(cur, rpp, 0, level);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\t\txfs_btree_copy_keys(cur, lkp, rkp, 1);\n\t\txfs_btree_copy_ptrs(cur, lpp, rpp, 1);\n\n\t\txfs_btree_log_keys(cur, lbp, lrecs, lrecs);\n\t\txfs_btree_log_ptrs(cur, lbp, lrecs, lrecs);\n\n\t\tASSERT(cur->bc_ops->keys_inorder(cur,\n\t\t\txfs_btree_key_addr(cur, lrecs - 1, left), lkp));\n\t} else {\n\t\t/* It's a leaf.  Move records.  */\n\t\tunion xfs_btree_rec\t*lrp;\t/* left record pointer */\n\n\t\tlrp = xfs_btree_rec_addr(cur, lrecs, left);\n\t\trrp = xfs_btree_rec_addr(cur, 1, right);\n\n\t\txfs_btree_copy_recs(cur, lrp, rrp, 1);\n\t\txfs_btree_log_recs(cur, lbp, lrecs, lrecs);\n\n\t\tASSERT(cur->bc_ops->recs_inorder(cur,\n\t\t\txfs_btree_rec_addr(cur, lrecs - 1, left), lrp));\n\t}\n\n\txfs_btree_set_numrecs(left, lrecs);\n\txfs_btree_log_block(cur, lbp, XFS_BB_NUMRECS);\n\n\txfs_btree_set_numrecs(right, rrecs);\n\txfs_btree_log_block(cur, rbp, XFS_BB_NUMRECS);\n\n\t/*\n\t * Slide the contents of right down one entry.\n\t */\n\tXFS_BTREE_STATS_ADD(cur, moves, rrecs - 1);\n\tif (level > 0) {\n\t\t/* It's a nonleaf. operate on keys and ptrs */\n#ifdef DEBUG\n\t\tint\t\t\ti;\t\t/* loop index */\n\n\t\tfor (i = 0; i < rrecs; i++) {\n\t\t\terror = xfs_btree_check_ptr(cur, rpp, i + 1, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\t\txfs_btree_shift_keys(cur,\n\t\t\t\txfs_btree_key_addr(cur, 2, right),\n\t\t\t\t-1, rrecs);\n\t\txfs_btree_shift_ptrs(cur,\n\t\t\t\txfs_btree_ptr_addr(cur, 2, right),\n\t\t\t\t-1, rrecs);\n\n\t\txfs_btree_log_keys(cur, rbp, 1, rrecs);\n\t\txfs_btree_log_ptrs(cur, rbp, 1, rrecs);\n\t} else {\n\t\t/* It's a leaf. operate on records */\n\t\txfs_btree_shift_recs(cur,\n\t\t\txfs_btree_rec_addr(cur, 2, right),\n\t\t\t-1, rrecs);\n\t\txfs_btree_log_recs(cur, rbp, 1, rrecs);\n\n\t\t/*\n\t\t * If it's the first record in the block, we'll need a key\n\t\t * structure to pass up to the next level (updkey).\n\t\t */\n\t\tcur->bc_ops->init_key_from_rec(&key,\n\t\t\txfs_btree_rec_addr(cur, 1, right));\n\t\trkp = &key;\n\t}\n\n\t/* Update the parent key values of right. */\n\terror = xfs_btree_updkey(cur, rkp, level + 1);\n\tif (error)\n\t\tgoto error0;\n\n\t/* Slide the cursor value left one. */\n\tcur->bc_ptrs[level]--;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\t\t\t\t\t/* error */\nxfs_btree_lshift(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tunion xfs_btree_key\tkey;\t\t/* btree key */\n\tstruct xfs_buf\t\t*lbp;\t\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t\t/* left btree block */\n\tint\t\t\tlrecs;\t\t/* left record count */\n\tstruct xfs_buf\t\t*rbp;\t\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t\t/* right btree block */\n\tint\t\t\trrecs;\t\t/* right record count */\n\tunion xfs_btree_ptr\tlptr;\t\t/* left btree pointer */\n\tunion xfs_btree_key\t*rkp = NULL;\t/* right btree key */\n\tunion xfs_btree_ptr\t*rpp = NULL;\t/* right address pointer */\n\tunion xfs_btree_rec\t*rrp = NULL;\t/* right record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    level == cur->bc_nlevels - 1)\n\t\tgoto out0;\n\n\t/* Set up variables for this block as \"right\". */\n\tright = xfs_btree_get_block(cur, level, &rbp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, right, level, rbp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* If we've got no left sibling then we can't shift an entry left. */\n\txfs_btree_get_sibling(cur, right, &lptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &lptr))\n\t\tgoto out0;\n\n\t/*\n\t * If the cursor entry is the one that would be moved, don't\n\t * do it... it's too complicated.\n\t */\n\tif (cur->bc_ptrs[level] <= 1)\n\t\tgoto out0;\n\n\t/* Set up the left neighbor as \"left\". */\n\terror = xfs_btree_read_buf_block(cur, &lptr, 0, &left, &lbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* If it's full, it can't take another entry. */\n\tlrecs = xfs_btree_get_numrecs(left);\n\tif (lrecs == cur->bc_ops->get_maxrecs(cur, level))\n\t\tgoto out0;\n\n\trrecs = xfs_btree_get_numrecs(right);\n\n\t/*\n\t * We add one entry to the left side and remove one for the right side.\n\t * Account for it here, the changes will be updated on disk and logged\n\t * later.\n\t */\n\tlrecs++;\n\trrecs--;\n\n\tXFS_BTREE_STATS_INC(cur, lshift);\n\tXFS_BTREE_STATS_ADD(cur, moves, 1);\n\n\t/*\n\t * If non-leaf, copy a key and a ptr to the left block.\n\t * Log the changes to the left block.\n\t */\n\tif (level > 0) {\n\t\t/* It's a non-leaf.  Move keys and pointers. */\n\t\tunion xfs_btree_key\t*lkp;\t/* left btree key */\n\t\tunion xfs_btree_ptr\t*lpp;\t/* left address pointer */\n\n\t\tlkp = xfs_btree_key_addr(cur, lrecs, left);\n\t\trkp = xfs_btree_key_addr(cur, 1, right);\n\n\t\tlpp = xfs_btree_ptr_addr(cur, lrecs, left);\n\t\trpp = xfs_btree_ptr_addr(cur, 1, right);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_ptr(cur, rpp, 0, level);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\t\txfs_btree_copy_keys(cur, lkp, rkp, 1);\n\t\txfs_btree_copy_ptrs(cur, lpp, rpp, 1);\n\n\t\txfs_btree_log_keys(cur, lbp, lrecs, lrecs);\n\t\txfs_btree_log_ptrs(cur, lbp, lrecs, lrecs);\n\n\t\tASSERT(cur->bc_ops->keys_inorder(cur,\n\t\t\txfs_btree_key_addr(cur, lrecs - 1, left), lkp));\n\t} else {\n\t\t/* It's a leaf.  Move records.  */\n\t\tunion xfs_btree_rec\t*lrp;\t/* left record pointer */\n\n\t\tlrp = xfs_btree_rec_addr(cur, lrecs, left);\n\t\trrp = xfs_btree_rec_addr(cur, 1, right);\n\n\t\txfs_btree_copy_recs(cur, lrp, rrp, 1);\n\t\txfs_btree_log_recs(cur, lbp, lrecs, lrecs);\n\n\t\tASSERT(cur->bc_ops->recs_inorder(cur,\n\t\t\txfs_btree_rec_addr(cur, lrecs - 1, left), lrp));\n\t}\n\n\txfs_btree_set_numrecs(left, lrecs);\n\txfs_btree_log_block(cur, lbp, XFS_BB_NUMRECS);\n\n\txfs_btree_set_numrecs(right, rrecs);\n\txfs_btree_log_block(cur, rbp, XFS_BB_NUMRECS);\n\n\t/*\n\t * Slide the contents of right down one entry.\n\t */\n\tXFS_BTREE_STATS_ADD(cur, moves, rrecs - 1);\n\tif (level > 0) {\n\t\t/* It's a nonleaf. operate on keys and ptrs */\n#ifdef DEBUG\n\t\tint\t\t\ti;\t\t/* loop index */\n\n\t\tfor (i = 0; i < rrecs; i++) {\n\t\t\terror = xfs_btree_check_ptr(cur, rpp, i + 1, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\t\txfs_btree_shift_keys(cur,\n\t\t\t\txfs_btree_key_addr(cur, 2, right),\n\t\t\t\t-1, rrecs);\n\t\txfs_btree_shift_ptrs(cur,\n\t\t\t\txfs_btree_ptr_addr(cur, 2, right),\n\t\t\t\t-1, rrecs);\n\n\t\txfs_btree_log_keys(cur, rbp, 1, rrecs);\n\t\txfs_btree_log_ptrs(cur, rbp, 1, rrecs);\n\t} else {\n\t\t/* It's a leaf. operate on records */\n\t\txfs_btree_shift_recs(cur,\n\t\t\txfs_btree_rec_addr(cur, 2, right),\n\t\t\t-1, rrecs);\n\t\txfs_btree_log_recs(cur, rbp, 1, rrecs);\n\n\t\t/*\n\t\t * If it's the first record in the block, we'll need a key\n\t\t * structure to pass up to the next level (updkey).\n\t\t */\n\t\tcur->bc_ops->init_key_from_rec(&key,\n\t\t\txfs_btree_rec_addr(cur, 1, right));\n\t\trkp = &key;\n\t}\n\n\t/* Update the parent key values of right. */\n\terror = xfs_btree_updkey(cur, rkp, level + 1);\n\tif (error)\n\t\tgoto error0;\n\n\t/* Slide the cursor value left one. */\n\tcur->bc_ptrs[level]--;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_rshift",
          "args": [
            "cur",
            "level",
            "stat"
          ],
          "line": 2859
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_rshift",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "2148-2317",
          "snippet": "STATIC int\t\t\t\t\t/* error */\nxfs_btree_rshift(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tunion xfs_btree_key\tkey;\t\t/* btree key */\n\tstruct xfs_buf\t\t*lbp;\t\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t\t/* left btree block */\n\tstruct xfs_buf\t\t*rbp;\t\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t\t/* right btree block */\n\tstruct xfs_btree_cur\t*tcur;\t\t/* temporary btree cursor */\n\tunion xfs_btree_ptr\trptr;\t\t/* right block pointer */\n\tunion xfs_btree_key\t*rkp;\t\t/* right btree key */\n\tint\t\t\trrecs;\t\t/* right record count */\n\tint\t\t\tlrecs;\t\t/* left record count */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* loop counter */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1))\n\t\tgoto out0;\n\n\t/* Set up variables for this block as \"left\". */\n\tleft = xfs_btree_get_block(cur, level, &lbp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, left, level, lbp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* If we've got no right sibling then we can't shift an entry right. */\n\txfs_btree_get_sibling(cur, left, &rptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &rptr))\n\t\tgoto out0;\n\n\t/*\n\t * If the cursor entry is the one that would be moved, don't\n\t * do it... it's too complicated.\n\t */\n\tlrecs = xfs_btree_get_numrecs(left);\n\tif (cur->bc_ptrs[level] >= lrecs)\n\t\tgoto out0;\n\n\t/* Set up the right neighbor as \"right\". */\n\terror = xfs_btree_read_buf_block(cur, &rptr, 0, &right, &rbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* If it's full, it can't take another entry. */\n\trrecs = xfs_btree_get_numrecs(right);\n\tif (rrecs == cur->bc_ops->get_maxrecs(cur, level))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, rshift);\n\tXFS_BTREE_STATS_ADD(cur, moves, rrecs);\n\n\t/*\n\t * Make a hole at the start of the right neighbor block, then\n\t * copy the last left block entry to the hole.\n\t */\n\tif (level > 0) {\n\t\t/* It's a nonleaf. make a hole in the keys and ptrs */\n\t\tunion xfs_btree_key\t*lkp;\n\t\tunion xfs_btree_ptr\t*lpp;\n\t\tunion xfs_btree_ptr\t*rpp;\n\n\t\tlkp = xfs_btree_key_addr(cur, lrecs, left);\n\t\tlpp = xfs_btree_ptr_addr(cur, lrecs, left);\n\t\trkp = xfs_btree_key_addr(cur, 1, right);\n\t\trpp = xfs_btree_ptr_addr(cur, 1, right);\n\n#ifdef DEBUG\n\t\tfor (i = rrecs - 1; i >= 0; i--) {\n\t\t\terror = xfs_btree_check_ptr(cur, rpp, i, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\n\t\txfs_btree_shift_keys(cur, rkp, 1, rrecs);\n\t\txfs_btree_shift_ptrs(cur, rpp, 1, rrecs);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_ptr(cur, lpp, 0, level);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\t/* Now put the new data in, and log it. */\n\t\txfs_btree_copy_keys(cur, rkp, lkp, 1);\n\t\txfs_btree_copy_ptrs(cur, rpp, lpp, 1);\n\n\t\txfs_btree_log_keys(cur, rbp, 1, rrecs + 1);\n\t\txfs_btree_log_ptrs(cur, rbp, 1, rrecs + 1);\n\n\t\tASSERT(cur->bc_ops->keys_inorder(cur, rkp,\n\t\t\txfs_btree_key_addr(cur, 2, right)));\n\t} else {\n\t\t/* It's a leaf. make a hole in the records */\n\t\tunion xfs_btree_rec\t*lrp;\n\t\tunion xfs_btree_rec\t*rrp;\n\n\t\tlrp = xfs_btree_rec_addr(cur, lrecs, left);\n\t\trrp = xfs_btree_rec_addr(cur, 1, right);\n\n\t\txfs_btree_shift_recs(cur, rrp, 1, rrecs);\n\n\t\t/* Now put the new data in, and log it. */\n\t\txfs_btree_copy_recs(cur, rrp, lrp, 1);\n\t\txfs_btree_log_recs(cur, rbp, 1, rrecs + 1);\n\n\t\tcur->bc_ops->init_key_from_rec(&key, rrp);\n\t\trkp = &key;\n\n\t\tASSERT(cur->bc_ops->recs_inorder(cur, rrp,\n\t\t\txfs_btree_rec_addr(cur, 2, right)));\n\t}\n\n\t/*\n\t * Decrement and log left's numrecs, bump and log right's numrecs.\n\t */\n\txfs_btree_set_numrecs(left, --lrecs);\n\txfs_btree_log_block(cur, lbp, XFS_BB_NUMRECS);\n\n\txfs_btree_set_numrecs(right, ++rrecs);\n\txfs_btree_log_block(cur, rbp, XFS_BB_NUMRECS);\n\n\t/*\n\t * Using a temporary cursor, update the parent key values of the\n\t * block on the right.\n\t */\n\terror = xfs_btree_dup_cursor(cur, &tcur);\n\tif (error)\n\t\tgoto error0;\n\ti = xfs_btree_lastrec(tcur, level);\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\terror = xfs_btree_increment(tcur, level, &i);\n\tif (error)\n\t\tgoto error1;\n\n\terror = xfs_btree_updkey(tcur, rkp, level + 1);\n\tif (error)\n\t\tgoto error1;\n\n\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n\nerror1:\n\tXFS_BTREE_TRACE_CURSOR(tcur, XBT_ERROR);\n\txfs_btree_del_cursor(tcur, XFS_BTREE_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\t\t\t\t\t/* error */\nxfs_btree_rshift(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tunion xfs_btree_key\tkey;\t\t/* btree key */\n\tstruct xfs_buf\t\t*lbp;\t\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t\t/* left btree block */\n\tstruct xfs_buf\t\t*rbp;\t\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t\t/* right btree block */\n\tstruct xfs_btree_cur\t*tcur;\t\t/* temporary btree cursor */\n\tunion xfs_btree_ptr\trptr;\t\t/* right block pointer */\n\tunion xfs_btree_key\t*rkp;\t\t/* right btree key */\n\tint\t\t\trrecs;\t\t/* right record count */\n\tint\t\t\tlrecs;\t\t/* left record count */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* loop counter */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1))\n\t\tgoto out0;\n\n\t/* Set up variables for this block as \"left\". */\n\tleft = xfs_btree_get_block(cur, level, &lbp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, left, level, lbp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* If we've got no right sibling then we can't shift an entry right. */\n\txfs_btree_get_sibling(cur, left, &rptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &rptr))\n\t\tgoto out0;\n\n\t/*\n\t * If the cursor entry is the one that would be moved, don't\n\t * do it... it's too complicated.\n\t */\n\tlrecs = xfs_btree_get_numrecs(left);\n\tif (cur->bc_ptrs[level] >= lrecs)\n\t\tgoto out0;\n\n\t/* Set up the right neighbor as \"right\". */\n\terror = xfs_btree_read_buf_block(cur, &rptr, 0, &right, &rbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* If it's full, it can't take another entry. */\n\trrecs = xfs_btree_get_numrecs(right);\n\tif (rrecs == cur->bc_ops->get_maxrecs(cur, level))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, rshift);\n\tXFS_BTREE_STATS_ADD(cur, moves, rrecs);\n\n\t/*\n\t * Make a hole at the start of the right neighbor block, then\n\t * copy the last left block entry to the hole.\n\t */\n\tif (level > 0) {\n\t\t/* It's a nonleaf. make a hole in the keys and ptrs */\n\t\tunion xfs_btree_key\t*lkp;\n\t\tunion xfs_btree_ptr\t*lpp;\n\t\tunion xfs_btree_ptr\t*rpp;\n\n\t\tlkp = xfs_btree_key_addr(cur, lrecs, left);\n\t\tlpp = xfs_btree_ptr_addr(cur, lrecs, left);\n\t\trkp = xfs_btree_key_addr(cur, 1, right);\n\t\trpp = xfs_btree_ptr_addr(cur, 1, right);\n\n#ifdef DEBUG\n\t\tfor (i = rrecs - 1; i >= 0; i--) {\n\t\t\terror = xfs_btree_check_ptr(cur, rpp, i, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\n\t\txfs_btree_shift_keys(cur, rkp, 1, rrecs);\n\t\txfs_btree_shift_ptrs(cur, rpp, 1, rrecs);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_ptr(cur, lpp, 0, level);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\t/* Now put the new data in, and log it. */\n\t\txfs_btree_copy_keys(cur, rkp, lkp, 1);\n\t\txfs_btree_copy_ptrs(cur, rpp, lpp, 1);\n\n\t\txfs_btree_log_keys(cur, rbp, 1, rrecs + 1);\n\t\txfs_btree_log_ptrs(cur, rbp, 1, rrecs + 1);\n\n\t\tASSERT(cur->bc_ops->keys_inorder(cur, rkp,\n\t\t\txfs_btree_key_addr(cur, 2, right)));\n\t} else {\n\t\t/* It's a leaf. make a hole in the records */\n\t\tunion xfs_btree_rec\t*lrp;\n\t\tunion xfs_btree_rec\t*rrp;\n\n\t\tlrp = xfs_btree_rec_addr(cur, lrecs, left);\n\t\trrp = xfs_btree_rec_addr(cur, 1, right);\n\n\t\txfs_btree_shift_recs(cur, rrp, 1, rrecs);\n\n\t\t/* Now put the new data in, and log it. */\n\t\txfs_btree_copy_recs(cur, rrp, lrp, 1);\n\t\txfs_btree_log_recs(cur, rbp, 1, rrecs + 1);\n\n\t\tcur->bc_ops->init_key_from_rec(&key, rrp);\n\t\trkp = &key;\n\n\t\tASSERT(cur->bc_ops->recs_inorder(cur, rrp,\n\t\t\txfs_btree_rec_addr(cur, 2, right)));\n\t}\n\n\t/*\n\t * Decrement and log left's numrecs, bump and log right's numrecs.\n\t */\n\txfs_btree_set_numrecs(left, --lrecs);\n\txfs_btree_log_block(cur, lbp, XFS_BB_NUMRECS);\n\n\txfs_btree_set_numrecs(right, ++rrecs);\n\txfs_btree_log_block(cur, rbp, XFS_BB_NUMRECS);\n\n\t/*\n\t * Using a temporary cursor, update the parent key values of the\n\t * block on the right.\n\t */\n\terror = xfs_btree_dup_cursor(cur, &tcur);\n\tif (error)\n\t\tgoto error0;\n\ti = xfs_btree_lastrec(tcur, level);\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\terror = xfs_btree_increment(tcur, level, &i);\n\tif (error)\n\t\tgoto error1;\n\n\terror = xfs_btree_updkey(tcur, rkp, level + 1);\n\tif (error)\n\t\tgoto error1;\n\n\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n\nerror1:\n\tXFS_BTREE_TRACE_CURSOR(tcur, XBT_ERROR);\n\txfs_btree_del_cursor(tcur, XFS_BTREE_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "cur->bc_tp",
            "ip",
            "logflags"
          ],
          "line": 2852
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_new_iroot",
          "args": [
            "cur",
            "&logflags",
            "stat"
          ],
          "line": 2848
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_new_iroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "2588-2693",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_new_iroot(\n\tstruct xfs_btree_cur\t*cur,\t\t/* btree cursor */\n\tint\t\t\t*logflags,\t/* logging flags for inode */\n\tint\t\t\t*stat)\t\t/* return status - 0 fail */\n{\n\tstruct xfs_buf\t\t*cbp;\t\t/* buffer for cblock */\n\tstruct xfs_btree_block\t*block;\t\t/* btree block */\n\tstruct xfs_btree_block\t*cblock;\t/* child btree block */\n\tunion xfs_btree_key\t*ckp;\t\t/* child key pointer */\n\tunion xfs_btree_ptr\t*cpp;\t\t/* child ptr pointer */\n\tunion xfs_btree_key\t*kp;\t\t/* pointer to btree key */\n\tunion xfs_btree_ptr\t*pp;\t\t/* pointer to block addr */\n\tunion xfs_btree_ptr\tnptr;\t\t/* new block addr */\n\tint\t\t\tlevel;\t\t/* btree level */\n\tint\t\t\terror;\t\t/* error return code */\n#ifdef DEBUG\n\tint\t\t\ti;\t\t/* loop counter */\n#endif\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_STATS_INC(cur, newroot);\n\n\tASSERT(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE);\n\n\tlevel = cur->bc_nlevels - 1;\n\n\tblock = xfs_btree_get_iroot(cur);\n\tpp = xfs_btree_ptr_addr(cur, 1, block);\n\n\t/* Allocate the new block. If we can't do it, we're toast. Give up. */\n\terror = cur->bc_ops->alloc_block(cur, pp, &nptr, stat);\n\tif (error)\n\t\tgoto error0;\n\tif (*stat == 0) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\treturn 0;\n\t}\n\tXFS_BTREE_STATS_INC(cur, alloc);\n\n\t/* Copy the root into a real block. */\n\terror = xfs_btree_get_buf_block(cur, &nptr, 0, &cblock, &cbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/*\n\t * we can't just memcpy() the root in for CRC enabled btree blocks.\n\t * In that case have to also ensure the blkno remains correct\n\t */\n\tmemcpy(cblock, block, xfs_btree_block_len(cur));\n\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\t\tcblock->bb_u.l.bb_blkno = cpu_to_be64(cbp->b_bn);\n\t\telse\n\t\t\tcblock->bb_u.s.bb_blkno = cpu_to_be64(cbp->b_bn);\n\t}\n\n\tbe16_add_cpu(&block->bb_level, 1);\n\txfs_btree_set_numrecs(block, 1);\n\tcur->bc_nlevels++;\n\tcur->bc_ptrs[level + 1] = 1;\n\n\tkp = xfs_btree_key_addr(cur, 1, block);\n\tckp = xfs_btree_key_addr(cur, 1, cblock);\n\txfs_btree_copy_keys(cur, ckp, kp, xfs_btree_get_numrecs(cblock));\n\n\tcpp = xfs_btree_ptr_addr(cur, 1, cblock);\n#ifdef DEBUG\n\tfor (i = 0; i < be16_to_cpu(cblock->bb_numrecs); i++) {\n\t\terror = xfs_btree_check_ptr(cur, pp, i, level);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n#endif\n\txfs_btree_copy_ptrs(cur, cpp, pp, xfs_btree_get_numrecs(cblock));\n\n#ifdef DEBUG\n\terror = xfs_btree_check_ptr(cur, &nptr, 0, level);\n\tif (error)\n\t\tgoto error0;\n#endif\n\txfs_btree_copy_ptrs(cur, pp, &nptr, 1);\n\n\txfs_iroot_realloc(cur->bc_private.b.ip,\n\t\t\t  1 - xfs_btree_get_numrecs(cblock),\n\t\t\t  cur->bc_private.b.whichfork);\n\n\txfs_btree_setbuf(cur, level, cbp);\n\n\t/*\n\t * Do all this logging at the end so that\n\t * the root is at the right level.\n\t */\n\txfs_btree_log_block(cur, cbp, XFS_BB_ALL_BITS);\n\txfs_btree_log_keys(cur, cbp, 1, be16_to_cpu(cblock->bb_numrecs));\n\txfs_btree_log_ptrs(cur, cbp, 1, be16_to_cpu(cblock->bb_numrecs));\n\n\t*logflags |=\n\t\tXFS_ILOG_CORE | xfs_ilog_fbroot(cur->bc_private.b.whichfork);\n\t*stat = 1;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_new_iroot(\n\tstruct xfs_btree_cur\t*cur,\t\t/* btree cursor */\n\tint\t\t\t*logflags,\t/* logging flags for inode */\n\tint\t\t\t*stat)\t\t/* return status - 0 fail */\n{\n\tstruct xfs_buf\t\t*cbp;\t\t/* buffer for cblock */\n\tstruct xfs_btree_block\t*block;\t\t/* btree block */\n\tstruct xfs_btree_block\t*cblock;\t/* child btree block */\n\tunion xfs_btree_key\t*ckp;\t\t/* child key pointer */\n\tunion xfs_btree_ptr\t*cpp;\t\t/* child ptr pointer */\n\tunion xfs_btree_key\t*kp;\t\t/* pointer to btree key */\n\tunion xfs_btree_ptr\t*pp;\t\t/* pointer to block addr */\n\tunion xfs_btree_ptr\tnptr;\t\t/* new block addr */\n\tint\t\t\tlevel;\t\t/* btree level */\n\tint\t\t\terror;\t\t/* error return code */\n#ifdef DEBUG\n\tint\t\t\ti;\t\t/* loop counter */\n#endif\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_STATS_INC(cur, newroot);\n\n\tASSERT(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE);\n\n\tlevel = cur->bc_nlevels - 1;\n\n\tblock = xfs_btree_get_iroot(cur);\n\tpp = xfs_btree_ptr_addr(cur, 1, block);\n\n\t/* Allocate the new block. If we can't do it, we're toast. Give up. */\n\terror = cur->bc_ops->alloc_block(cur, pp, &nptr, stat);\n\tif (error)\n\t\tgoto error0;\n\tif (*stat == 0) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\treturn 0;\n\t}\n\tXFS_BTREE_STATS_INC(cur, alloc);\n\n\t/* Copy the root into a real block. */\n\terror = xfs_btree_get_buf_block(cur, &nptr, 0, &cblock, &cbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/*\n\t * we can't just memcpy() the root in for CRC enabled btree blocks.\n\t * In that case have to also ensure the blkno remains correct\n\t */\n\tmemcpy(cblock, block, xfs_btree_block_len(cur));\n\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\t\tcblock->bb_u.l.bb_blkno = cpu_to_be64(cbp->b_bn);\n\t\telse\n\t\t\tcblock->bb_u.s.bb_blkno = cpu_to_be64(cbp->b_bn);\n\t}\n\n\tbe16_add_cpu(&block->bb_level, 1);\n\txfs_btree_set_numrecs(block, 1);\n\tcur->bc_nlevels++;\n\tcur->bc_ptrs[level + 1] = 1;\n\n\tkp = xfs_btree_key_addr(cur, 1, block);\n\tckp = xfs_btree_key_addr(cur, 1, cblock);\n\txfs_btree_copy_keys(cur, ckp, kp, xfs_btree_get_numrecs(cblock));\n\n\tcpp = xfs_btree_ptr_addr(cur, 1, cblock);\n#ifdef DEBUG\n\tfor (i = 0; i < be16_to_cpu(cblock->bb_numrecs); i++) {\n\t\terror = xfs_btree_check_ptr(cur, pp, i, level);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n#endif\n\txfs_btree_copy_ptrs(cur, cpp, pp, xfs_btree_get_numrecs(cblock));\n\n#ifdef DEBUG\n\terror = xfs_btree_check_ptr(cur, &nptr, 0, level);\n\tif (error)\n\t\tgoto error0;\n#endif\n\txfs_btree_copy_ptrs(cur, pp, &nptr, 1);\n\n\txfs_iroot_realloc(cur->bc_private.b.ip,\n\t\t\t  1 - xfs_btree_get_numrecs(cblock),\n\t\t\t  cur->bc_private.b.whichfork);\n\n\txfs_btree_setbuf(cur, level, cbp);\n\n\t/*\n\t * Do all this logging at the end so that\n\t * the root is at the right level.\n\t */\n\txfs_btree_log_block(cur, cbp, XFS_BB_ALL_BITS);\n\txfs_btree_log_keys(cur, cbp, 1, be16_to_cpu(cblock->bb_numrecs));\n\txfs_btree_log_ptrs(cur, cbp, 1, be16_to_cpu(cblock->bb_numrecs));\n\n\t*logflags |=\n\t\tXFS_ILOG_CORE | xfs_ilog_fbroot(cur->bc_private.b.whichfork);\n\t*stat = 1;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iroot_realloc",
          "args": [
            "ip",
            "1",
            "cur->bc_private.b.whichfork"
          ],
          "line": 2843
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iroot_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "473-583",
          "snippet": "void\nxfs_iroot_realloc(\n\txfs_inode_t\t\t*ip,\n\tint\t\t\trec_diff,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tcur_max;\n\txfs_ifork_t\t\t*ifp;\n\tstruct xfs_btree_block\t*new_broot;\n\tint\t\t\tnew_max;\n\tsize_t\t\t\tnew_size;\n\tchar\t\t\t*np;\n\tchar\t\t\t*op;\n\n\t/*\n\t * Handle the degenerate case quietly.\n\t */\n\tif (rec_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (rec_diff > 0) {\n\t\t/*\n\t\t * If there wasn't any memory allocated before, just\n\t\t * allocate it now and get out.\n\t\t */\n\t\tif (ifp->if_broot_bytes == 0) {\n\t\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, rec_diff);\n\t\t\tifp->if_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t\tifp->if_broot_bytes = (int)new_size;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If there is already an existing if_broot, then we need\n\t\t * to realloc() it and shift the pointers to their new\n\t\t * location.  The records don't change location because\n\t\t * they are kept butted up against the btree block header.\n\t\t */\n\t\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\t\tnew_max = cur_max + rec_diff;\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\t\tifp->if_broot = kmem_realloc(ifp->if_broot, new_size,\n\t\t\t\tXFS_BMAP_BROOT_SPACE_CALC(mp, cur_max),\n\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tifp->if_broot_bytes = (int)new_size;\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\t\tmemmove(np, op, cur_max * (uint)sizeof(xfs_fsblock_t));\n\t\treturn;\n\t}\n\n\t/*\n\t * rec_diff is less than 0.  In this case, we are shrinking the\n\t * if_broot buffer.  It must already exist.  If we go to zero\n\t * records, just get rid of the root and clear the status bit.\n\t */\n\tASSERT((ifp->if_broot != NULL) && (ifp->if_broot_bytes > 0));\n\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\tnew_max = cur_max + rec_diff;\n\tASSERT(new_max >= 0);\n\tif (new_max > 0)\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\telse\n\t\tnew_size = 0;\n\tif (new_size > 0) {\n\t\tnew_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t/*\n\t\t * First copy over the btree block header.\n\t\t */\n\t\tmemcpy(new_broot, ifp->if_broot,\n\t\t\tXFS_BMBT_BLOCK_LEN(ip->i_mount));\n\t} else {\n\t\tnew_broot = NULL;\n\t\tifp->if_flags &= ~XFS_IFBROOT;\n\t}\n\n\t/*\n\t * Only copy the records and pointers if there are any.\n\t */\n\tif (new_max > 0) {\n\t\t/*\n\t\t * First copy the records.\n\t\t */\n\t\top = (char *)XFS_BMBT_REC_ADDR(mp, ifp->if_broot, 1);\n\t\tnp = (char *)XFS_BMBT_REC_ADDR(mp, new_broot, 1);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_bmbt_rec_t));\n\n\t\t/*\n\t\t * Then copy the pointers.\n\t\t */\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, new_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_fsblock_t));\n\t}\n\tkmem_free(ifp->if_broot);\n\tifp->if_broot = new_broot;\n\tifp->if_broot_bytes = (int)new_size;\n\tif (ifp->if_broot)\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\treturn;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iroot_realloc(\n\txfs_inode_t\t\t*ip,\n\tint\t\t\trec_diff,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tcur_max;\n\txfs_ifork_t\t\t*ifp;\n\tstruct xfs_btree_block\t*new_broot;\n\tint\t\t\tnew_max;\n\tsize_t\t\t\tnew_size;\n\tchar\t\t\t*np;\n\tchar\t\t\t*op;\n\n\t/*\n\t * Handle the degenerate case quietly.\n\t */\n\tif (rec_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (rec_diff > 0) {\n\t\t/*\n\t\t * If there wasn't any memory allocated before, just\n\t\t * allocate it now and get out.\n\t\t */\n\t\tif (ifp->if_broot_bytes == 0) {\n\t\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, rec_diff);\n\t\t\tifp->if_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t\tifp->if_broot_bytes = (int)new_size;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If there is already an existing if_broot, then we need\n\t\t * to realloc() it and shift the pointers to their new\n\t\t * location.  The records don't change location because\n\t\t * they are kept butted up against the btree block header.\n\t\t */\n\t\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\t\tnew_max = cur_max + rec_diff;\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\t\tifp->if_broot = kmem_realloc(ifp->if_broot, new_size,\n\t\t\t\tXFS_BMAP_BROOT_SPACE_CALC(mp, cur_max),\n\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tifp->if_broot_bytes = (int)new_size;\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\t\tmemmove(np, op, cur_max * (uint)sizeof(xfs_fsblock_t));\n\t\treturn;\n\t}\n\n\t/*\n\t * rec_diff is less than 0.  In this case, we are shrinking the\n\t * if_broot buffer.  It must already exist.  If we go to zero\n\t * records, just get rid of the root and clear the status bit.\n\t */\n\tASSERT((ifp->if_broot != NULL) && (ifp->if_broot_bytes > 0));\n\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\tnew_max = cur_max + rec_diff;\n\tASSERT(new_max >= 0);\n\tif (new_max > 0)\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\telse\n\t\tnew_size = 0;\n\tif (new_size > 0) {\n\t\tnew_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t/*\n\t\t * First copy over the btree block header.\n\t\t */\n\t\tmemcpy(new_broot, ifp->if_broot,\n\t\t\tXFS_BMBT_BLOCK_LEN(ip->i_mount));\n\t} else {\n\t\tnew_broot = NULL;\n\t\tifp->if_flags &= ~XFS_IFBROOT;\n\t}\n\n\t/*\n\t * Only copy the records and pointers if there are any.\n\t */\n\tif (new_max > 0) {\n\t\t/*\n\t\t * First copy the records.\n\t\t */\n\t\top = (char *)XFS_BMBT_REC_ADDR(mp, ifp->if_broot, 1);\n\t\tnp = (char *)XFS_BMBT_REC_ADDR(mp, new_broot, 1);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_bmbt_rec_t));\n\n\t\t/*\n\t\t * Then copy the pointers.\n\t\t */\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, new_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_fsblock_t));\n\t}\n\tkmem_free(ifp->if_broot);\n\tifp->if_broot = new_broot;\n\tifp->if_broot_bytes = (int)new_size;\n\tif (ifp->if_broot)\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->get_dmaxrecs",
          "args": [
            "cur",
            "level"
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_make_block_unfull(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* btree level */\n\tint\t\t\tnumrecs,/* # of recs in block */\n\tint\t\t\t*oindex,/* old tree index */\n\tint\t\t\t*index,\t/* new tree index */\n\tunion xfs_btree_ptr\t*nptr,\t/* new btree ptr */\n\tstruct xfs_btree_cur\t**ncur,\t/* new btree cursor */\n\tunion xfs_btree_rec\t*nrec,\t/* new record */\n\tint\t\t\t*stat)\n{\n\tunion xfs_btree_key\tkey;\t/* new btree key value */\n\tint\t\t\terror = 0;\n\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    level == cur->bc_nlevels - 1) {\n\t    \tstruct xfs_inode *ip = cur->bc_private.b.ip;\n\n\t\tif (numrecs < cur->bc_ops->get_dmaxrecs(cur, level)) {\n\t\t\t/* A root block that can be made bigger. */\n\t\t\txfs_iroot_realloc(ip, 1, cur->bc_private.b.whichfork);\n\t\t} else {\n\t\t\t/* A root block that needs replacing */\n\t\t\tint\tlogflags = 0;\n\n\t\t\terror = xfs_btree_new_iroot(cur, &logflags, stat);\n\t\t\tif (error || *stat == 0)\n\t\t\t\treturn error;\n\n\t\t\txfs_trans_log_inode(cur->bc_tp, ip, logflags);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/* First, try shifting an entry to the right neighbor. */\n\terror = xfs_btree_rshift(cur, level, stat);\n\tif (error || *stat)\n\t\treturn error;\n\n\t/* Next, try shifting an entry to the left neighbor. */\n\terror = xfs_btree_lshift(cur, level, stat);\n\tif (error)\n\t\treturn error;\n\n\tif (*stat) {\n\t\t*oindex = *index = cur->bc_ptrs[level];\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Next, try splitting the current block in half.\n\t *\n\t * If this works we have to re-set our variables because we\n\t * could be in a different block now.\n\t */\n\terror = xfs_btree_split(cur, level, nptr, &key, ncur, stat);\n\tif (error || *stat == 0)\n\t\treturn error;\n\n\n\t*index = cur->bc_ptrs[level];\n\tcur->bc_ops->init_rec_from_key(&key, nrec);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_btree_new_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "2698-2820",
    "snippet": "STATIC int\t\t\t\t/* error */\nxfs_btree_new_root(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* one half of the old root block */\n\tstruct xfs_buf\t\t*bp;\t/* buffer containing block */\n\tint\t\t\terror;\t/* error return value */\n\tstruct xfs_buf\t\t*lbp;\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t/* left btree block */\n\tstruct xfs_buf\t\t*nbp;\t/* new (root) buffer */\n\tstruct xfs_btree_block\t*new;\t/* new (root) btree block */\n\tint\t\t\tnptr;\t/* new value for key index, 1 or 2 */\n\tstruct xfs_buf\t\t*rbp;\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t/* right btree block */\n\tunion xfs_btree_ptr\trptr;\n\tunion xfs_btree_ptr\tlptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_STATS_INC(cur, newroot);\n\n\t/* initialise our start point from the cursor */\n\tcur->bc_ops->init_ptr_from_cur(cur, &rptr);\n\n\t/* Allocate the new block. If we can't do it, we're toast. Give up. */\n\terror = cur->bc_ops->alloc_block(cur, &rptr, &lptr, stat);\n\tif (error)\n\t\tgoto error0;\n\tif (*stat == 0)\n\t\tgoto out0;\n\tXFS_BTREE_STATS_INC(cur, alloc);\n\n\t/* Set up the new block. */\n\terror = xfs_btree_get_buf_block(cur, &lptr, 0, &new, &nbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* Set the root in the holding structure  increasing the level by 1. */\n\tcur->bc_ops->set_root(cur, &lptr, 1);\n\n\t/*\n\t * At the previous root level there are now two blocks: the old root,\n\t * and the new block generated when it was split.  We don't know which\n\t * one the cursor is pointing at, so we set up variables \"left\" and\n\t * \"right\" for each case.\n\t */\n\tblock = xfs_btree_get_block(cur, cur->bc_nlevels - 1, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, cur->bc_nlevels - 1, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\txfs_btree_get_sibling(cur, block, &rptr, XFS_BB_RIGHTSIB);\n\tif (!xfs_btree_ptr_is_null(cur, &rptr)) {\n\t\t/* Our block is left, pick up the right block. */\n\t\tlbp = bp;\n\t\txfs_btree_buf_to_ptr(cur, lbp, &lptr);\n\t\tleft = block;\n\t\terror = xfs_btree_read_buf_block(cur, &rptr, 0, &right, &rbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tbp = rbp;\n\t\tnptr = 1;\n\t} else {\n\t\t/* Our block is right, pick up the left block. */\n\t\trbp = bp;\n\t\txfs_btree_buf_to_ptr(cur, rbp, &rptr);\n\t\tright = block;\n\t\txfs_btree_get_sibling(cur, right, &lptr, XFS_BB_LEFTSIB);\n\t\terror = xfs_btree_read_buf_block(cur, &lptr, 0, &left, &lbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tbp = lbp;\n\t\tnptr = 2;\n\t}\n\t/* Fill in the new block's btree header and log it. */\n\txfs_btree_init_block_cur(cur, nbp, cur->bc_nlevels, 2);\n\txfs_btree_log_block(cur, nbp, XFS_BB_ALL_BITS);\n\tASSERT(!xfs_btree_ptr_is_null(cur, &lptr) &&\n\t\t\t!xfs_btree_ptr_is_null(cur, &rptr));\n\n\t/* Fill in the key data in the new root. */\n\tif (xfs_btree_get_level(left) > 0) {\n\t\txfs_btree_copy_keys(cur,\n\t\t\t\txfs_btree_key_addr(cur, 1, new),\n\t\t\t\txfs_btree_key_addr(cur, 1, left), 1);\n\t\txfs_btree_copy_keys(cur,\n\t\t\t\txfs_btree_key_addr(cur, 2, new),\n\t\t\t\txfs_btree_key_addr(cur, 1, right), 1);\n\t} else {\n\t\tcur->bc_ops->init_key_from_rec(\n\t\t\t\txfs_btree_key_addr(cur, 1, new),\n\t\t\t\txfs_btree_rec_addr(cur, 1, left));\n\t\tcur->bc_ops->init_key_from_rec(\n\t\t\t\txfs_btree_key_addr(cur, 2, new),\n\t\t\t\txfs_btree_rec_addr(cur, 1, right));\n\t}\n\txfs_btree_log_keys(cur, nbp, 1, 2);\n\n\t/* Fill in the pointer data in the new root. */\n\txfs_btree_copy_ptrs(cur,\n\t\txfs_btree_ptr_addr(cur, 1, new), &lptr, 1);\n\txfs_btree_copy_ptrs(cur,\n\t\txfs_btree_ptr_addr(cur, 2, new), &rptr, 1);\n\txfs_btree_log_ptrs(cur, nbp, 1, 2);\n\n\t/* Fix up the cursor. */\n\txfs_btree_setbuf(cur, cur->bc_nlevels, nbp);\n\tcur->bc_ptrs[cur->bc_nlevels] = nptr;\n\tcur->bc_nlevels++;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ERROR"
          ],
          "line": 2814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 2810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_setbuf",
          "args": [
            "cur",
            "cur->bc_nlevels",
            "nbp"
          ],
          "line": 2807
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_setbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "886-911",
          "snippet": "STATIC void\nxfs_btree_setbuf(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlev,\t/* level in btree */\n\txfs_buf_t\t\t*bp)\t/* new buffer to set */\n{\n\tstruct xfs_btree_block\t*b;\t/* btree block */\n\n\tif (cur->bc_bufs[lev])\n\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[lev]);\n\tcur->bc_bufs[lev] = bp;\n\tcur->bc_ra[lev] = 0;\n\n\tb = XFS_BUF_TO_BLOCK(bp);\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (b->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t} else {\n\t\tif (b->bb_u.s.bb_leftsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.s.bb_rightsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_setbuf(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlev,\t/* level in btree */\n\txfs_buf_t\t\t*bp)\t/* new buffer to set */\n{\n\tstruct xfs_btree_block\t*b;\t/* btree block */\n\n\tif (cur->bc_bufs[lev])\n\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[lev]);\n\tcur->bc_bufs[lev] = bp;\n\tcur->bc_ra[lev] = 0;\n\n\tb = XFS_BUF_TO_BLOCK(bp);\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (b->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t} else {\n\t\tif (b->bb_u.s.bb_leftsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.s.bb_rightsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_ptrs",
          "args": [
            "cur",
            "nbp",
            "1",
            "2"
          ],
          "line": 2804
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_ptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1328-1352",
          "snippet": "STATIC void\nxfs_btree_log_ptrs(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfirst,\t/* index of first pointer to log */\n\tint\t\t\tlast)\t/* index of last pointer to log */\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\t\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\txfs_btree_ptr_offset(cur, first, level),\n\t\t\t\txfs_btree_ptr_offset(cur, last + 1, level) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_log_ptrs(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfirst,\t/* index of first pointer to log */\n\tint\t\t\tlast)\t/* index of last pointer to log */\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\t\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\txfs_btree_ptr_offset(cur, first, level),\n\t\t\t\txfs_btree_ptr_offset(cur, last + 1, level) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_copy_ptrs",
          "args": [
            "cur",
            "xfs_btree_ptr_addr(cur, 2, new)",
            "&rptr",
            "1"
          ],
          "line": 2802
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_copy_ptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1210-1219",
          "snippet": "STATIC void\nxfs_btree_copy_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*dst_ptr,\n\tunion xfs_btree_ptr\t*src_ptr,\n\tint\t\t\tnumptrs)\n{\n\tASSERT(numptrs >= 0);\n\tmemcpy(dst_ptr, src_ptr, numptrs * xfs_btree_ptr_len(cur));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*dst_ptr,\n\tunion xfs_btree_ptr\t*src_ptr,\n\tint\t\t\tnumptrs)\n{\n\tASSERT(numptrs >= 0);\n\tmemcpy(dst_ptr, src_ptr, numptrs * xfs_btree_ptr_len(cur));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_addr",
          "args": [
            "cur",
            "2",
            "new"
          ],
          "line": 2803
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "494-506",
          "snippet": "xfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_keys",
          "args": [
            "cur",
            "nbp",
            "1",
            "2"
          ],
          "line": 2797
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1281-1302",
          "snippet": "STATIC void\nxfs_btree_log_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\t  xfs_btree_key_offset(cur, first),\n\t\t\t\t  xfs_btree_key_offset(cur, last + 1) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_log_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\t  xfs_btree_key_offset(cur, first),\n\t\t\t\t  xfs_btree_key_offset(cur, last + 1) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->init_key_from_rec",
          "args": [
            "xfs_btree_key_addr(cur, 2, new)",
            "xfs_btree_rec_addr(cur, 1, right)"
          ],
          "line": 2793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_rec_addr",
          "args": [
            "cur",
            "1",
            "right"
          ],
          "line": 2795
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_rec_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "468-476",
          "snippet": "xfs_btree_rec *\nxfs_btree_rec_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_rec *)\n\t\t((char *)block + xfs_btree_rec_offset(cur, n));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_rec *\nxfs_btree_rec_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_rec *)\n\t\t((char *)block + xfs_btree_rec_offset(cur, n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_key_addr",
          "args": [
            "cur",
            "2",
            "new"
          ],
          "line": 2794
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_key_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "481-489",
          "snippet": "xfs_btree_key *\nxfs_btree_key_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_key *)\n\t\t((char *)block + xfs_btree_key_offset(cur, n));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_key *\nxfs_btree_key_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_key *)\n\t\t((char *)block + xfs_btree_key_offset(cur, n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->init_key_from_rec",
          "args": [
            "xfs_btree_key_addr(cur, 1, new)",
            "xfs_btree_rec_addr(cur, 1, left)"
          ],
          "line": 2790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_copy_keys",
          "args": [
            "cur",
            "xfs_btree_key_addr(cur, 2, new)",
            "xfs_btree_key_addr(cur, 1, right)",
            "1"
          ],
          "line": 2786
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_copy_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1182-1191",
          "snippet": "STATIC void\nxfs_btree_copy_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*dst_key,\n\tunion xfs_btree_key\t*src_key,\n\tint\t\t\tnumkeys)\n{\n\tASSERT(numkeys >= 0);\n\tmemcpy(dst_key, src_key, numkeys * cur->bc_ops->key_len);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*dst_key,\n\tunion xfs_btree_key\t*src_key,\n\tint\t\t\tnumkeys)\n{\n\tASSERT(numkeys >= 0);\n\tmemcpy(dst_key, src_key, numkeys * cur->bc_ops->key_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_level",
          "args": [
            "left"
          ],
          "line": 2782
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "427-430",
          "snippet": "static inline int xfs_btree_get_level(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_level);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_btree_get_level(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!xfs_btree_ptr_is_null(cur, &lptr) &&\n\t\t\t!xfs_btree_ptr_is_null(cur, &rptr)"
          ],
          "line": 2778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_is_null",
          "args": [
            "cur",
            "&rptr"
          ],
          "line": 2779
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_is_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "913-922",
          "snippet": "STATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_block",
          "args": [
            "cur",
            "nbp",
            "XFS_BB_ALL_BITS"
          ],
          "line": 2777
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1357-1425",
          "snippet": "void\nxfs_btree_log_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfields)\t/* mask of fields: XFS_BB_... */\n{\n\tint\t\t\tfirst;\t/* first byte offset logged */\n\tint\t\t\tlast;\t/* last byte offset logged */\n\tstatic const short\tsoffsets[] = {\t/* table of offsets (short) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_crc),\n\t\tXFS_BTREE_SBLOCK_CRC_LEN\n\t};\n\tstatic const short\tloffsets[] = {\t/* table of offsets (long) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_crc),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_pad),\n\t\tXFS_BTREE_LBLOCK_CRC_LEN\n\t};\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBI(cur, bp, fields);\n\n\tif (bp) {\n\t\tint nbits;\n\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\t/*\n\t\t\t * We don't log the CRC when updating a btree\n\t\t\t * block but instead recreate it during log\n\t\t\t * recovery.  As the log buffers have checksums\n\t\t\t * of their own this is safe and avoids logging a crc\n\t\t\t * update in a lot of places.\n\t\t\t */\n\t\t\tif (fields == XFS_BB_ALL_BITS)\n\t\t\t\tfields = XFS_BB_ALL_BITS_CRC;\n\t\t\tnbits = XFS_BB_NUM_BITS_CRC;\n\t\t} else {\n\t\t\tnbits = XFS_BB_NUM_BITS;\n\t\t}\n\t\txfs_btree_offsets(fields,\n\t\t\t\t  (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\t\t\t\tloffsets : soffsets,\n\t\t\t\t  nbits, &first, &last);\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp, first, last);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_log_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfields)\t/* mask of fields: XFS_BB_... */\n{\n\tint\t\t\tfirst;\t/* first byte offset logged */\n\tint\t\t\tlast;\t/* last byte offset logged */\n\tstatic const short\tsoffsets[] = {\t/* table of offsets (short) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_crc),\n\t\tXFS_BTREE_SBLOCK_CRC_LEN\n\t};\n\tstatic const short\tloffsets[] = {\t/* table of offsets (long) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_crc),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_pad),\n\t\tXFS_BTREE_LBLOCK_CRC_LEN\n\t};\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBI(cur, bp, fields);\n\n\tif (bp) {\n\t\tint nbits;\n\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\t/*\n\t\t\t * We don't log the CRC when updating a btree\n\t\t\t * block but instead recreate it during log\n\t\t\t * recovery.  As the log buffers have checksums\n\t\t\t * of their own this is safe and avoids logging a crc\n\t\t\t * update in a lot of places.\n\t\t\t */\n\t\t\tif (fields == XFS_BB_ALL_BITS)\n\t\t\t\tfields = XFS_BB_ALL_BITS_CRC;\n\t\t\tnbits = XFS_BB_NUM_BITS_CRC;\n\t\t} else {\n\t\t\tnbits = XFS_BB_NUM_BITS;\n\t\t}\n\t\txfs_btree_offsets(fields,\n\t\t\t\t  (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\t\t\t\tloffsets : soffsets,\n\t\t\t\t  nbits, &first, &last);\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp, first, last);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_init_block_cur",
          "args": [
            "cur",
            "nbp",
            "cur->bc_nlevels",
            "2"
          ],
          "line": 2776
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_init_block_cur",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1036-1059",
          "snippet": "STATIC void\nxfs_btree_init_block_cur(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tlevel,\n\tint\t\t\tnumrecs)\n{\n\t__u64 owner;\n\n\t/*\n\t * we can pull the owner from the cursor right now as the different\n\t * owners align directly with the pointer size of the btree. This may\n\t * change in future, but is safe for current users of the generic btree\n\t * code.\n\t */\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\towner = cur->bc_private.b.ip->i_ino;\n\telse\n\t\towner = cur->bc_private.a.agno;\n\n\txfs_btree_init_block_int(cur->bc_mp, XFS_BUF_TO_BLOCK(bp), bp->b_bn,\n\t\t\t\t xfs_btree_magic(cur), level, numrecs,\n\t\t\t\t owner, cur->bc_flags);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_init_block_cur(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tlevel,\n\tint\t\t\tnumrecs)\n{\n\t__u64 owner;\n\n\t/*\n\t * we can pull the owner from the cursor right now as the different\n\t * owners align directly with the pointer size of the btree. This may\n\t * change in future, but is safe for current users of the generic btree\n\t * code.\n\t */\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\towner = cur->bc_private.b.ip->i_ino;\n\telse\n\t\towner = cur->bc_private.a.agno;\n\n\txfs_btree_init_block_int(cur->bc_mp, XFS_BUF_TO_BLOCK(bp), bp->b_bn,\n\t\t\t\t xfs_btree_magic(cur), level, numrecs,\n\t\t\t\t owner, cur->bc_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_read_buf_block",
          "args": [
            "cur",
            "&lptr",
            "0",
            "&left",
            "&lbp"
          ],
          "line": 2769
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_read_buf_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1152-1177",
          "snippet": "STATIC int\nxfs_btree_read_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\tint\t\t\terror;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\terror = xfs_trans_read_buf(mp, cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, flags, bpp,\n\t\t\t\t   cur->bc_ops->buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_set_refs(cur, *bpp);\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_read_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\tint\t\t\terror;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\terror = xfs_trans_read_buf(mp, cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, flags, bpp,\n\t\t\t\t   cur->bc_ops->buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_set_refs(cur, *bpp);\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_sibling",
          "args": [
            "cur",
            "right",
            "&lptr",
            "XFS_BB_LEFTSIB"
          ],
          "line": 2768
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_sibling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "938-958",
          "snippet": "STATIC void\nxfs_btree_get_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->l = block->bb_u.l.bb_rightsib;\n\t\telse\n\t\t\tptr->l = block->bb_u.l.bb_leftsib;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->s = block->bb_u.s.bb_rightsib;\n\t\telse\n\t\t\tptr->s = block->bb_u.s.bb_leftsib;\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_get_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->l = block->bb_u.l.bb_rightsib;\n\t\telse\n\t\t\tptr->l = block->bb_u.l.bb_leftsib;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->s = block->bb_u.s.bb_rightsib;\n\t\telse\n\t\t\tptr->s = block->bb_u.s.bb_leftsib;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_buf_to_ptr",
          "args": [
            "cur",
            "rbp",
            "&rptr"
          ],
          "line": 2766
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_buf_to_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1085-1098",
          "snippet": "STATIC void\nxfs_btree_buf_to_ptr(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\tptr->l = cpu_to_be64(XFS_DADDR_TO_FSB(cur->bc_mp,\n\t\t\t\t\tXFS_BUF_ADDR(bp)));\n\telse {\n\t\tptr->s = cpu_to_be32(xfs_daddr_to_agbno(cur->bc_mp,\n\t\t\t\t\tXFS_BUF_ADDR(bp)));\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_buf_to_ptr(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\tptr->l = cpu_to_be64(XFS_DADDR_TO_FSB(cur->bc_mp,\n\t\t\t\t\tXFS_BUF_ADDR(bp)));\n\telse {\n\t\tptr->s = cpu_to_be32(xfs_daddr_to_agbno(cur->bc_mp,\n\t\t\t\t\tXFS_BUF_ADDR(bp)));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_check_block",
          "args": [
            "cur",
            "block",
            "cur->bc_nlevels - 1",
            "bp"
          ],
          "line": 2747
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "149-160",
          "snippet": "int\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_block",
          "args": [
            "cur",
            "cur->bc_nlevels - 1",
            "&bp"
          ],
          "line": 2744
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "528-542",
          "snippet": "xfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->set_root",
          "args": [
            "cur",
            "&lptr",
            "1"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_buf_block",
          "args": [
            "cur",
            "&lptr",
            "0",
            "&new",
            "&nbp"
          ],
          "line": 2731
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_buf_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1122-1146",
          "snippet": "STATIC int\nxfs_btree_get_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\t*bpp = xfs_trans_get_buf(cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t mp->m_bsize, flags);\n\n\tif (!*bpp)\n\t\treturn -ENOMEM;\n\n\t(*bpp)->b_ops = cur->bc_ops->buf_ops;\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_get_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\t*bpp = xfs_trans_get_buf(cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t mp->m_bsize, flags);\n\n\tif (!*bpp)\n\t\treturn -ENOMEM;\n\n\t(*bpp)->b_ops = cur->bc_ops->buf_ops;\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_INC",
          "args": [
            "cur",
            "alloc"
          ],
          "line": 2728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->alloc_block",
          "args": [
            "cur",
            "&rptr",
            "&lptr",
            "stat"
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->init_ptr_from_cur",
          "args": [
            "cur",
            "&rptr"
          ],
          "line": 2720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_INC",
          "args": [
            "cur",
            "newroot"
          ],
          "line": 2717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ENTRY"
          ],
          "line": 2716
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\t\t\t\t/* error */\nxfs_btree_new_root(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* one half of the old root block */\n\tstruct xfs_buf\t\t*bp;\t/* buffer containing block */\n\tint\t\t\terror;\t/* error return value */\n\tstruct xfs_buf\t\t*lbp;\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t/* left btree block */\n\tstruct xfs_buf\t\t*nbp;\t/* new (root) buffer */\n\tstruct xfs_btree_block\t*new;\t/* new (root) btree block */\n\tint\t\t\tnptr;\t/* new value for key index, 1 or 2 */\n\tstruct xfs_buf\t\t*rbp;\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t/* right btree block */\n\tunion xfs_btree_ptr\trptr;\n\tunion xfs_btree_ptr\tlptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_STATS_INC(cur, newroot);\n\n\t/* initialise our start point from the cursor */\n\tcur->bc_ops->init_ptr_from_cur(cur, &rptr);\n\n\t/* Allocate the new block. If we can't do it, we're toast. Give up. */\n\terror = cur->bc_ops->alloc_block(cur, &rptr, &lptr, stat);\n\tif (error)\n\t\tgoto error0;\n\tif (*stat == 0)\n\t\tgoto out0;\n\tXFS_BTREE_STATS_INC(cur, alloc);\n\n\t/* Set up the new block. */\n\terror = xfs_btree_get_buf_block(cur, &lptr, 0, &new, &nbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* Set the root in the holding structure  increasing the level by 1. */\n\tcur->bc_ops->set_root(cur, &lptr, 1);\n\n\t/*\n\t * At the previous root level there are now two blocks: the old root,\n\t * and the new block generated when it was split.  We don't know which\n\t * one the cursor is pointing at, so we set up variables \"left\" and\n\t * \"right\" for each case.\n\t */\n\tblock = xfs_btree_get_block(cur, cur->bc_nlevels - 1, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, cur->bc_nlevels - 1, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\txfs_btree_get_sibling(cur, block, &rptr, XFS_BB_RIGHTSIB);\n\tif (!xfs_btree_ptr_is_null(cur, &rptr)) {\n\t\t/* Our block is left, pick up the right block. */\n\t\tlbp = bp;\n\t\txfs_btree_buf_to_ptr(cur, lbp, &lptr);\n\t\tleft = block;\n\t\terror = xfs_btree_read_buf_block(cur, &rptr, 0, &right, &rbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tbp = rbp;\n\t\tnptr = 1;\n\t} else {\n\t\t/* Our block is right, pick up the left block. */\n\t\trbp = bp;\n\t\txfs_btree_buf_to_ptr(cur, rbp, &rptr);\n\t\tright = block;\n\t\txfs_btree_get_sibling(cur, right, &lptr, XFS_BB_LEFTSIB);\n\t\terror = xfs_btree_read_buf_block(cur, &lptr, 0, &left, &lbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tbp = lbp;\n\t\tnptr = 2;\n\t}\n\t/* Fill in the new block's btree header and log it. */\n\txfs_btree_init_block_cur(cur, nbp, cur->bc_nlevels, 2);\n\txfs_btree_log_block(cur, nbp, XFS_BB_ALL_BITS);\n\tASSERT(!xfs_btree_ptr_is_null(cur, &lptr) &&\n\t\t\t!xfs_btree_ptr_is_null(cur, &rptr));\n\n\t/* Fill in the key data in the new root. */\n\tif (xfs_btree_get_level(left) > 0) {\n\t\txfs_btree_copy_keys(cur,\n\t\t\t\txfs_btree_key_addr(cur, 1, new),\n\t\t\t\txfs_btree_key_addr(cur, 1, left), 1);\n\t\txfs_btree_copy_keys(cur,\n\t\t\t\txfs_btree_key_addr(cur, 2, new),\n\t\t\t\txfs_btree_key_addr(cur, 1, right), 1);\n\t} else {\n\t\tcur->bc_ops->init_key_from_rec(\n\t\t\t\txfs_btree_key_addr(cur, 1, new),\n\t\t\t\txfs_btree_rec_addr(cur, 1, left));\n\t\tcur->bc_ops->init_key_from_rec(\n\t\t\t\txfs_btree_key_addr(cur, 2, new),\n\t\t\t\txfs_btree_rec_addr(cur, 1, right));\n\t}\n\txfs_btree_log_keys(cur, nbp, 1, 2);\n\n\t/* Fill in the pointer data in the new root. */\n\txfs_btree_copy_ptrs(cur,\n\t\txfs_btree_ptr_addr(cur, 1, new), &lptr, 1);\n\txfs_btree_copy_ptrs(cur,\n\t\txfs_btree_ptr_addr(cur, 2, new), &rptr, 1);\n\txfs_btree_log_ptrs(cur, nbp, 1, 2);\n\n\t/* Fix up the cursor. */\n\txfs_btree_setbuf(cur, cur->bc_nlevels, nbp);\n\tcur->bc_ptrs[cur->bc_nlevels] = nptr;\n\tcur->bc_nlevels++;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_btree_new_iroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "2588-2693",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_new_iroot(\n\tstruct xfs_btree_cur\t*cur,\t\t/* btree cursor */\n\tint\t\t\t*logflags,\t/* logging flags for inode */\n\tint\t\t\t*stat)\t\t/* return status - 0 fail */\n{\n\tstruct xfs_buf\t\t*cbp;\t\t/* buffer for cblock */\n\tstruct xfs_btree_block\t*block;\t\t/* btree block */\n\tstruct xfs_btree_block\t*cblock;\t/* child btree block */\n\tunion xfs_btree_key\t*ckp;\t\t/* child key pointer */\n\tunion xfs_btree_ptr\t*cpp;\t\t/* child ptr pointer */\n\tunion xfs_btree_key\t*kp;\t\t/* pointer to btree key */\n\tunion xfs_btree_ptr\t*pp;\t\t/* pointer to block addr */\n\tunion xfs_btree_ptr\tnptr;\t\t/* new block addr */\n\tint\t\t\tlevel;\t\t/* btree level */\n\tint\t\t\terror;\t\t/* error return code */\n#ifdef DEBUG\n\tint\t\t\ti;\t\t/* loop counter */\n#endif\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_STATS_INC(cur, newroot);\n\n\tASSERT(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE);\n\n\tlevel = cur->bc_nlevels - 1;\n\n\tblock = xfs_btree_get_iroot(cur);\n\tpp = xfs_btree_ptr_addr(cur, 1, block);\n\n\t/* Allocate the new block. If we can't do it, we're toast. Give up. */\n\terror = cur->bc_ops->alloc_block(cur, pp, &nptr, stat);\n\tif (error)\n\t\tgoto error0;\n\tif (*stat == 0) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\treturn 0;\n\t}\n\tXFS_BTREE_STATS_INC(cur, alloc);\n\n\t/* Copy the root into a real block. */\n\terror = xfs_btree_get_buf_block(cur, &nptr, 0, &cblock, &cbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/*\n\t * we can't just memcpy() the root in for CRC enabled btree blocks.\n\t * In that case have to also ensure the blkno remains correct\n\t */\n\tmemcpy(cblock, block, xfs_btree_block_len(cur));\n\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\t\tcblock->bb_u.l.bb_blkno = cpu_to_be64(cbp->b_bn);\n\t\telse\n\t\t\tcblock->bb_u.s.bb_blkno = cpu_to_be64(cbp->b_bn);\n\t}\n\n\tbe16_add_cpu(&block->bb_level, 1);\n\txfs_btree_set_numrecs(block, 1);\n\tcur->bc_nlevels++;\n\tcur->bc_ptrs[level + 1] = 1;\n\n\tkp = xfs_btree_key_addr(cur, 1, block);\n\tckp = xfs_btree_key_addr(cur, 1, cblock);\n\txfs_btree_copy_keys(cur, ckp, kp, xfs_btree_get_numrecs(cblock));\n\n\tcpp = xfs_btree_ptr_addr(cur, 1, cblock);\n#ifdef DEBUG\n\tfor (i = 0; i < be16_to_cpu(cblock->bb_numrecs); i++) {\n\t\terror = xfs_btree_check_ptr(cur, pp, i, level);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n#endif\n\txfs_btree_copy_ptrs(cur, cpp, pp, xfs_btree_get_numrecs(cblock));\n\n#ifdef DEBUG\n\terror = xfs_btree_check_ptr(cur, &nptr, 0, level);\n\tif (error)\n\t\tgoto error0;\n#endif\n\txfs_btree_copy_ptrs(cur, pp, &nptr, 1);\n\n\txfs_iroot_realloc(cur->bc_private.b.ip,\n\t\t\t  1 - xfs_btree_get_numrecs(cblock),\n\t\t\t  cur->bc_private.b.whichfork);\n\n\txfs_btree_setbuf(cur, level, cbp);\n\n\t/*\n\t * Do all this logging at the end so that\n\t * the root is at the right level.\n\t */\n\txfs_btree_log_block(cur, cbp, XFS_BB_ALL_BITS);\n\txfs_btree_log_keys(cur, cbp, 1, be16_to_cpu(cblock->bb_numrecs));\n\txfs_btree_log_ptrs(cur, cbp, 1, be16_to_cpu(cblock->bb_numrecs));\n\n\t*logflags |=\n\t\tXFS_ILOG_CORE | xfs_ilog_fbroot(cur->bc_private.b.whichfork);\n\t*stat = 1;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ERROR"
          ],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ilog_fbroot",
          "args": [
            "cur->bc_private.b.whichfork"
          ],
          "line": 2686
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilog_fbroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "336-339",
          "snippet": "static inline int xfs_ilog_fbroot(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DBROOT : XFS_ILOG_ABROOT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_ILOG_ABROOT\t0x100\t/* log i_af.i_broot */",
            "#define\tXFS_ILOG_DBROOT\t0x008\t/* log i_df.i_broot */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_ILOG_ABROOT\t0x100\t/* log i_af.i_broot */\n#define\tXFS_ILOG_DBROOT\t0x008\t/* log i_df.i_broot */\n\nstatic inline int xfs_ilog_fbroot(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DBROOT : XFS_ILOG_ABROOT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_ptrs",
          "args": [
            "cur",
            "cbp",
            "1",
            "be16_to_cpu(cblock->bb_numrecs)"
          ],
          "line": 2683
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_ptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1328-1352",
          "snippet": "STATIC void\nxfs_btree_log_ptrs(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfirst,\t/* index of first pointer to log */\n\tint\t\t\tlast)\t/* index of last pointer to log */\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\t\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\txfs_btree_ptr_offset(cur, first, level),\n\t\t\t\txfs_btree_ptr_offset(cur, last + 1, level) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_log_ptrs(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfirst,\t/* index of first pointer to log */\n\tint\t\t\tlast)\t/* index of last pointer to log */\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\t\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\txfs_btree_ptr_offset(cur, first, level),\n\t\t\t\txfs_btree_ptr_offset(cur, last + 1, level) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "cblock->bb_numrecs"
          ],
          "line": 2683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_keys",
          "args": [
            "cur",
            "cbp",
            "1",
            "be16_to_cpu(cblock->bb_numrecs)"
          ],
          "line": 2682
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1281-1302",
          "snippet": "STATIC void\nxfs_btree_log_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\t  xfs_btree_key_offset(cur, first),\n\t\t\t\t  xfs_btree_key_offset(cur, last + 1) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_log_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\t  xfs_btree_key_offset(cur, first),\n\t\t\t\t  xfs_btree_key_offset(cur, last + 1) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "cblock->bb_numrecs"
          ],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_block",
          "args": [
            "cur",
            "cbp",
            "XFS_BB_ALL_BITS"
          ],
          "line": 2681
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1357-1425",
          "snippet": "void\nxfs_btree_log_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfields)\t/* mask of fields: XFS_BB_... */\n{\n\tint\t\t\tfirst;\t/* first byte offset logged */\n\tint\t\t\tlast;\t/* last byte offset logged */\n\tstatic const short\tsoffsets[] = {\t/* table of offsets (short) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_crc),\n\t\tXFS_BTREE_SBLOCK_CRC_LEN\n\t};\n\tstatic const short\tloffsets[] = {\t/* table of offsets (long) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_crc),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_pad),\n\t\tXFS_BTREE_LBLOCK_CRC_LEN\n\t};\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBI(cur, bp, fields);\n\n\tif (bp) {\n\t\tint nbits;\n\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\t/*\n\t\t\t * We don't log the CRC when updating a btree\n\t\t\t * block but instead recreate it during log\n\t\t\t * recovery.  As the log buffers have checksums\n\t\t\t * of their own this is safe and avoids logging a crc\n\t\t\t * update in a lot of places.\n\t\t\t */\n\t\t\tif (fields == XFS_BB_ALL_BITS)\n\t\t\t\tfields = XFS_BB_ALL_BITS_CRC;\n\t\t\tnbits = XFS_BB_NUM_BITS_CRC;\n\t\t} else {\n\t\t\tnbits = XFS_BB_NUM_BITS;\n\t\t}\n\t\txfs_btree_offsets(fields,\n\t\t\t\t  (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\t\t\t\tloffsets : soffsets,\n\t\t\t\t  nbits, &first, &last);\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp, first, last);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_log_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfields)\t/* mask of fields: XFS_BB_... */\n{\n\tint\t\t\tfirst;\t/* first byte offset logged */\n\tint\t\t\tlast;\t/* last byte offset logged */\n\tstatic const short\tsoffsets[] = {\t/* table of offsets (short) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_crc),\n\t\tXFS_BTREE_SBLOCK_CRC_LEN\n\t};\n\tstatic const short\tloffsets[] = {\t/* table of offsets (long) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_crc),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_pad),\n\t\tXFS_BTREE_LBLOCK_CRC_LEN\n\t};\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBI(cur, bp, fields);\n\n\tif (bp) {\n\t\tint nbits;\n\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\t/*\n\t\t\t * We don't log the CRC when updating a btree\n\t\t\t * block but instead recreate it during log\n\t\t\t * recovery.  As the log buffers have checksums\n\t\t\t * of their own this is safe and avoids logging a crc\n\t\t\t * update in a lot of places.\n\t\t\t */\n\t\t\tif (fields == XFS_BB_ALL_BITS)\n\t\t\t\tfields = XFS_BB_ALL_BITS_CRC;\n\t\t\tnbits = XFS_BB_NUM_BITS_CRC;\n\t\t} else {\n\t\t\tnbits = XFS_BB_NUM_BITS;\n\t\t}\n\t\txfs_btree_offsets(fields,\n\t\t\t\t  (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\t\t\t\tloffsets : soffsets,\n\t\t\t\t  nbits, &first, &last);\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp, first, last);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_setbuf",
          "args": [
            "cur",
            "level",
            "cbp"
          ],
          "line": 2675
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_setbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "886-911",
          "snippet": "STATIC void\nxfs_btree_setbuf(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlev,\t/* level in btree */\n\txfs_buf_t\t\t*bp)\t/* new buffer to set */\n{\n\tstruct xfs_btree_block\t*b;\t/* btree block */\n\n\tif (cur->bc_bufs[lev])\n\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[lev]);\n\tcur->bc_bufs[lev] = bp;\n\tcur->bc_ra[lev] = 0;\n\n\tb = XFS_BUF_TO_BLOCK(bp);\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (b->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t} else {\n\t\tif (b->bb_u.s.bb_leftsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.s.bb_rightsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_setbuf(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlev,\t/* level in btree */\n\txfs_buf_t\t\t*bp)\t/* new buffer to set */\n{\n\tstruct xfs_btree_block\t*b;\t/* btree block */\n\n\tif (cur->bc_bufs[lev])\n\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[lev]);\n\tcur->bc_bufs[lev] = bp;\n\tcur->bc_ra[lev] = 0;\n\n\tb = XFS_BUF_TO_BLOCK(bp);\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (b->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t} else {\n\t\tif (b->bb_u.s.bb_leftsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.s.bb_rightsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iroot_realloc",
          "args": [
            "cur->bc_private.b.ip",
            "1 - xfs_btree_get_numrecs(cblock)",
            "cur->bc_private.b.whichfork"
          ],
          "line": 2671
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iroot_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "473-583",
          "snippet": "void\nxfs_iroot_realloc(\n\txfs_inode_t\t\t*ip,\n\tint\t\t\trec_diff,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tcur_max;\n\txfs_ifork_t\t\t*ifp;\n\tstruct xfs_btree_block\t*new_broot;\n\tint\t\t\tnew_max;\n\tsize_t\t\t\tnew_size;\n\tchar\t\t\t*np;\n\tchar\t\t\t*op;\n\n\t/*\n\t * Handle the degenerate case quietly.\n\t */\n\tif (rec_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (rec_diff > 0) {\n\t\t/*\n\t\t * If there wasn't any memory allocated before, just\n\t\t * allocate it now and get out.\n\t\t */\n\t\tif (ifp->if_broot_bytes == 0) {\n\t\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, rec_diff);\n\t\t\tifp->if_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t\tifp->if_broot_bytes = (int)new_size;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If there is already an existing if_broot, then we need\n\t\t * to realloc() it and shift the pointers to their new\n\t\t * location.  The records don't change location because\n\t\t * they are kept butted up against the btree block header.\n\t\t */\n\t\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\t\tnew_max = cur_max + rec_diff;\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\t\tifp->if_broot = kmem_realloc(ifp->if_broot, new_size,\n\t\t\t\tXFS_BMAP_BROOT_SPACE_CALC(mp, cur_max),\n\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tifp->if_broot_bytes = (int)new_size;\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\t\tmemmove(np, op, cur_max * (uint)sizeof(xfs_fsblock_t));\n\t\treturn;\n\t}\n\n\t/*\n\t * rec_diff is less than 0.  In this case, we are shrinking the\n\t * if_broot buffer.  It must already exist.  If we go to zero\n\t * records, just get rid of the root and clear the status bit.\n\t */\n\tASSERT((ifp->if_broot != NULL) && (ifp->if_broot_bytes > 0));\n\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\tnew_max = cur_max + rec_diff;\n\tASSERT(new_max >= 0);\n\tif (new_max > 0)\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\telse\n\t\tnew_size = 0;\n\tif (new_size > 0) {\n\t\tnew_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t/*\n\t\t * First copy over the btree block header.\n\t\t */\n\t\tmemcpy(new_broot, ifp->if_broot,\n\t\t\tXFS_BMBT_BLOCK_LEN(ip->i_mount));\n\t} else {\n\t\tnew_broot = NULL;\n\t\tifp->if_flags &= ~XFS_IFBROOT;\n\t}\n\n\t/*\n\t * Only copy the records and pointers if there are any.\n\t */\n\tif (new_max > 0) {\n\t\t/*\n\t\t * First copy the records.\n\t\t */\n\t\top = (char *)XFS_BMBT_REC_ADDR(mp, ifp->if_broot, 1);\n\t\tnp = (char *)XFS_BMBT_REC_ADDR(mp, new_broot, 1);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_bmbt_rec_t));\n\n\t\t/*\n\t\t * Then copy the pointers.\n\t\t */\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, new_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_fsblock_t));\n\t}\n\tkmem_free(ifp->if_broot);\n\tifp->if_broot = new_broot;\n\tifp->if_broot_bytes = (int)new_size;\n\tif (ifp->if_broot)\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\treturn;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iroot_realloc(\n\txfs_inode_t\t\t*ip,\n\tint\t\t\trec_diff,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tcur_max;\n\txfs_ifork_t\t\t*ifp;\n\tstruct xfs_btree_block\t*new_broot;\n\tint\t\t\tnew_max;\n\tsize_t\t\t\tnew_size;\n\tchar\t\t\t*np;\n\tchar\t\t\t*op;\n\n\t/*\n\t * Handle the degenerate case quietly.\n\t */\n\tif (rec_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (rec_diff > 0) {\n\t\t/*\n\t\t * If there wasn't any memory allocated before, just\n\t\t * allocate it now and get out.\n\t\t */\n\t\tif (ifp->if_broot_bytes == 0) {\n\t\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, rec_diff);\n\t\t\tifp->if_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t\tifp->if_broot_bytes = (int)new_size;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If there is already an existing if_broot, then we need\n\t\t * to realloc() it and shift the pointers to their new\n\t\t * location.  The records don't change location because\n\t\t * they are kept butted up against the btree block header.\n\t\t */\n\t\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\t\tnew_max = cur_max + rec_diff;\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\t\tifp->if_broot = kmem_realloc(ifp->if_broot, new_size,\n\t\t\t\tXFS_BMAP_BROOT_SPACE_CALC(mp, cur_max),\n\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tifp->if_broot_bytes = (int)new_size;\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\t\tmemmove(np, op, cur_max * (uint)sizeof(xfs_fsblock_t));\n\t\treturn;\n\t}\n\n\t/*\n\t * rec_diff is less than 0.  In this case, we are shrinking the\n\t * if_broot buffer.  It must already exist.  If we go to zero\n\t * records, just get rid of the root and clear the status bit.\n\t */\n\tASSERT((ifp->if_broot != NULL) && (ifp->if_broot_bytes > 0));\n\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\tnew_max = cur_max + rec_diff;\n\tASSERT(new_max >= 0);\n\tif (new_max > 0)\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\telse\n\t\tnew_size = 0;\n\tif (new_size > 0) {\n\t\tnew_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t/*\n\t\t * First copy over the btree block header.\n\t\t */\n\t\tmemcpy(new_broot, ifp->if_broot,\n\t\t\tXFS_BMBT_BLOCK_LEN(ip->i_mount));\n\t} else {\n\t\tnew_broot = NULL;\n\t\tifp->if_flags &= ~XFS_IFBROOT;\n\t}\n\n\t/*\n\t * Only copy the records and pointers if there are any.\n\t */\n\tif (new_max > 0) {\n\t\t/*\n\t\t * First copy the records.\n\t\t */\n\t\top = (char *)XFS_BMBT_REC_ADDR(mp, ifp->if_broot, 1);\n\t\tnp = (char *)XFS_BMBT_REC_ADDR(mp, new_broot, 1);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_bmbt_rec_t));\n\n\t\t/*\n\t\t * Then copy the pointers.\n\t\t */\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, new_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_fsblock_t));\n\t}\n\tkmem_free(ifp->if_broot);\n\tifp->if_broot = new_broot;\n\tifp->if_broot_bytes = (int)new_size;\n\tif (ifp->if_broot)\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_numrecs",
          "args": [
            "cblock"
          ],
          "line": 2672
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_numrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "416-419",
          "snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_copy_ptrs",
          "args": [
            "cur",
            "pp",
            "&nptr",
            "1"
          ],
          "line": 2669
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_copy_ptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1210-1219",
          "snippet": "STATIC void\nxfs_btree_copy_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*dst_ptr,\n\tunion xfs_btree_ptr\t*src_ptr,\n\tint\t\t\tnumptrs)\n{\n\tASSERT(numptrs >= 0);\n\tmemcpy(dst_ptr, src_ptr, numptrs * xfs_btree_ptr_len(cur));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*dst_ptr,\n\tunion xfs_btree_ptr\t*src_ptr,\n\tint\t\t\tnumptrs)\n{\n\tASSERT(numptrs >= 0);\n\tmemcpy(dst_ptr, src_ptr, numptrs * xfs_btree_ptr_len(cur));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_check_ptr",
          "args": [
            "cur",
            "&nptr",
            "0",
            "level"
          ],
          "line": 2665
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "201-215",
          "snippet": "STATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_ptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tunion xfs_btree_ptr\t*ptr,\t/* btree block disk address */\n\tint\t\t\tindex,\t/* offset from ptr to check */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\treturn xfs_btree_check_lptr(cur,\n\t\t\t\tbe64_to_cpu((&ptr->l)[index]), level);\n\t} else {\n\t\treturn xfs_btree_check_sptr(cur,\n\t\t\t\tbe32_to_cpu((&ptr->s)[index]), level);\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_ptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tunion xfs_btree_ptr\t*ptr,\t/* btree block disk address */\n\tint\t\t\tindex,\t/* offset from ptr to check */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\treturn xfs_btree_check_lptr(cur,\n\t\t\t\tbe64_to_cpu((&ptr->l)[index]), level);\n\t} else {\n\t\treturn xfs_btree_check_sptr(cur,\n\t\t\t\tbe32_to_cpu((&ptr->s)[index]), level);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "cblock->bb_numrecs"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_addr",
          "args": [
            "cur",
            "1",
            "cblock"
          ],
          "line": 2654
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "494-506",
          "snippet": "xfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_copy_keys",
          "args": [
            "cur",
            "ckp",
            "kp",
            "xfs_btree_get_numrecs(cblock)"
          ],
          "line": 2652
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_copy_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1182-1191",
          "snippet": "STATIC void\nxfs_btree_copy_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*dst_key,\n\tunion xfs_btree_key\t*src_key,\n\tint\t\t\tnumkeys)\n{\n\tASSERT(numkeys >= 0);\n\tmemcpy(dst_key, src_key, numkeys * cur->bc_ops->key_len);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*dst_key,\n\tunion xfs_btree_key\t*src_key,\n\tint\t\t\tnumkeys)\n{\n\tASSERT(numkeys >= 0);\n\tmemcpy(dst_key, src_key, numkeys * cur->bc_ops->key_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_key_addr",
          "args": [
            "cur",
            "1",
            "cblock"
          ],
          "line": 2651
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_key_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "481-489",
          "snippet": "xfs_btree_key *\nxfs_btree_key_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_key *)\n\t\t((char *)block + xfs_btree_key_offset(cur, n));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_key *\nxfs_btree_key_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_key *)\n\t\t((char *)block + xfs_btree_key_offset(cur, n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_set_numrecs",
          "args": [
            "block",
            "1"
          ],
          "line": 2646
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_set_numrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "421-425",
          "snippet": "static inline void xfs_btree_set_numrecs(struct xfs_btree_block *block,\n\t\t__uint16_t numrecs)\n{\n\tblock->bb_numrecs = cpu_to_be16(numrecs);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_btree_set_numrecs(struct xfs_btree_block *block,\n\t\t__uint16_t numrecs)\n{\n\tblock->bb_numrecs = cpu_to_be16(numrecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_add_cpu",
          "args": [
            "&block->bb_level",
            "1"
          ],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "cbp->b_bn"
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "cbp->b_bn"
          ],
          "line": 2640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cblock",
            "block",
            "xfs_btree_block_len(cur)"
          ],
          "line": 2637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_block_len",
          "args": [
            "cur"
          ],
          "line": 2637
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_block_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "406-416",
          "snippet": "static inline size_t xfs_btree_block_len(struct xfs_btree_cur *cur)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS)\n\t\t\treturn XFS_BTREE_LBLOCK_CRC_LEN;\n\t\treturn XFS_BTREE_LBLOCK_LEN;\n\t}\n\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS)\n\t\treturn XFS_BTREE_SBLOCK_CRC_LEN;\n\treturn XFS_BTREE_SBLOCK_LEN;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic inline size_t xfs_btree_block_len(struct xfs_btree_cur *cur)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS)\n\t\t\treturn XFS_BTREE_LBLOCK_CRC_LEN;\n\t\treturn XFS_BTREE_LBLOCK_LEN;\n\t}\n\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS)\n\t\treturn XFS_BTREE_SBLOCK_CRC_LEN;\n\treturn XFS_BTREE_SBLOCK_LEN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_buf_block",
          "args": [
            "cur",
            "&nptr",
            "0",
            "&cblock",
            "&cbp"
          ],
          "line": 2629
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_buf_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1122-1146",
          "snippet": "STATIC int\nxfs_btree_get_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\t*bpp = xfs_trans_get_buf(cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t mp->m_bsize, flags);\n\n\tif (!*bpp)\n\t\treturn -ENOMEM;\n\n\t(*bpp)->b_ops = cur->bc_ops->buf_ops;\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_get_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\t*bpp = xfs_trans_get_buf(cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t mp->m_bsize, flags);\n\n\tif (!*bpp)\n\t\treturn -ENOMEM;\n\n\t(*bpp)->b_ops = cur->bc_ops->buf_ops;\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_INC",
          "args": [
            "cur",
            "alloc"
          ],
          "line": 2626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 2623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->alloc_block",
          "args": [
            "cur",
            "pp",
            "&nptr",
            "stat"
          ],
          "line": 2619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_iroot",
          "args": [
            "cur"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_iroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "514-522",
          "snippet": "xfs_btree_block *\nxfs_btree_get_iroot(\n       struct xfs_btree_cur    *cur)\n{\n       struct xfs_ifork        *ifp;\n\n       ifp = XFS_IFORK_PTR(cur->bc_private.b.ip, cur->bc_private.b.whichfork);\n       return (struct xfs_btree_block *)ifp->if_broot;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_btree_block *\nxfs_btree_get_iroot(\n       struct xfs_btree_cur    *cur)\n{\n       struct xfs_ifork        *ifp;\n\n       ifp = XFS_IFORK_PTR(cur->bc_private.b.ip, cur->bc_private.b.whichfork);\n       return (struct xfs_btree_block *)ifp->if_broot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cur->bc_flags & XFS_BTREE_ROOT_IN_INODE"
          ],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_INC",
          "args": [
            "cur",
            "newroot"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ENTRY"
          ],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_new_iroot(\n\tstruct xfs_btree_cur\t*cur,\t\t/* btree cursor */\n\tint\t\t\t*logflags,\t/* logging flags for inode */\n\tint\t\t\t*stat)\t\t/* return status - 0 fail */\n{\n\tstruct xfs_buf\t\t*cbp;\t\t/* buffer for cblock */\n\tstruct xfs_btree_block\t*block;\t\t/* btree block */\n\tstruct xfs_btree_block\t*cblock;\t/* child btree block */\n\tunion xfs_btree_key\t*ckp;\t\t/* child key pointer */\n\tunion xfs_btree_ptr\t*cpp;\t\t/* child ptr pointer */\n\tunion xfs_btree_key\t*kp;\t\t/* pointer to btree key */\n\tunion xfs_btree_ptr\t*pp;\t\t/* pointer to block addr */\n\tunion xfs_btree_ptr\tnptr;\t\t/* new block addr */\n\tint\t\t\tlevel;\t\t/* btree level */\n\tint\t\t\terror;\t\t/* error return code */\n#ifdef DEBUG\n\tint\t\t\ti;\t\t/* loop counter */\n#endif\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_STATS_INC(cur, newroot);\n\n\tASSERT(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE);\n\n\tlevel = cur->bc_nlevels - 1;\n\n\tblock = xfs_btree_get_iroot(cur);\n\tpp = xfs_btree_ptr_addr(cur, 1, block);\n\n\t/* Allocate the new block. If we can't do it, we're toast. Give up. */\n\terror = cur->bc_ops->alloc_block(cur, pp, &nptr, stat);\n\tif (error)\n\t\tgoto error0;\n\tif (*stat == 0) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\treturn 0;\n\t}\n\tXFS_BTREE_STATS_INC(cur, alloc);\n\n\t/* Copy the root into a real block. */\n\terror = xfs_btree_get_buf_block(cur, &nptr, 0, &cblock, &cbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/*\n\t * we can't just memcpy() the root in for CRC enabled btree blocks.\n\t * In that case have to also ensure the blkno remains correct\n\t */\n\tmemcpy(cblock, block, xfs_btree_block_len(cur));\n\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\t\tcblock->bb_u.l.bb_blkno = cpu_to_be64(cbp->b_bn);\n\t\telse\n\t\t\tcblock->bb_u.s.bb_blkno = cpu_to_be64(cbp->b_bn);\n\t}\n\n\tbe16_add_cpu(&block->bb_level, 1);\n\txfs_btree_set_numrecs(block, 1);\n\tcur->bc_nlevels++;\n\tcur->bc_ptrs[level + 1] = 1;\n\n\tkp = xfs_btree_key_addr(cur, 1, block);\n\tckp = xfs_btree_key_addr(cur, 1, cblock);\n\txfs_btree_copy_keys(cur, ckp, kp, xfs_btree_get_numrecs(cblock));\n\n\tcpp = xfs_btree_ptr_addr(cur, 1, cblock);\n#ifdef DEBUG\n\tfor (i = 0; i < be16_to_cpu(cblock->bb_numrecs); i++) {\n\t\terror = xfs_btree_check_ptr(cur, pp, i, level);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n#endif\n\txfs_btree_copy_ptrs(cur, cpp, pp, xfs_btree_get_numrecs(cblock));\n\n#ifdef DEBUG\n\terror = xfs_btree_check_ptr(cur, &nptr, 0, level);\n\tif (error)\n\t\tgoto error0;\n#endif\n\txfs_btree_copy_ptrs(cur, pp, &nptr, 1);\n\n\txfs_iroot_realloc(cur->bc_private.b.ip,\n\t\t\t  1 - xfs_btree_get_numrecs(cblock),\n\t\t\t  cur->bc_private.b.whichfork);\n\n\txfs_btree_setbuf(cur, level, cbp);\n\n\t/*\n\t * Do all this logging at the end so that\n\t * the root is at the right level.\n\t */\n\txfs_btree_log_block(cur, cbp, XFS_BB_ALL_BITS);\n\txfs_btree_log_keys(cur, cbp, 1, be16_to_cpu(cblock->bb_numrecs));\n\txfs_btree_log_ptrs(cur, cbp, 1, be16_to_cpu(cblock->bb_numrecs));\n\n\t*logflags |=\n\t\tXFS_ILOG_CORE | xfs_ilog_fbroot(cur->bc_private.b.whichfork);\n\t*stat = 1;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_btree_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "2553-2581",
    "snippet": "STATIC int\t\t\t\t\t/* error */\nxfs_btree_split(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tunion xfs_btree_ptr\t*ptrp,\n\tunion xfs_btree_key\t*key,\n\tstruct xfs_btree_cur\t**curp,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_split_args\targs;\n\tDECLARE_COMPLETION_ONSTACK(done);\n\n\tif (cur->bc_btnum != XFS_BTNUM_BMAP)\n\t\treturn __xfs_btree_split(cur, level, ptrp, key, curp, stat);\n\n\targs.cur = cur;\n\targs.level = level;\n\targs.ptrp = ptrp;\n\targs.key = key;\n\targs.curp = curp;\n\targs.stat = stat;\n\targs.done = &done;\n\targs.kswapd = current_is_kswapd();\n\tINIT_WORK_ONSTACK(&args.work, xfs_btree_split_worker);\n\tqueue_work(xfs_alloc_wq, &args.work);\n\twait_for_completion(&done);\n\tdestroy_work_on_stack(&args.work);\n\treturn args.result;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_work_on_stack",
          "args": [
            "&args.work"
          ],
          "line": 2579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&done"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_for_completion_rpc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "1116-1122",
          "snippet": "static int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "xfs_alloc_wq",
            "&args.work"
          ],
          "line": 2577
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK_ONSTACK",
          "args": [
            "&args.work",
            "xfs_btree_split_worker"
          ],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_is_kswapd",
          "args": [],
          "line": 2575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__xfs_btree_split",
          "args": [
            "cur",
            "level",
            "ptrp",
            "key",
            "curp",
            "stat"
          ],
          "line": 2566
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_btree_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "2324-2503",
          "snippet": "STATIC int\t\t\t\t\t/* error */\n__xfs_btree_split(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tunion xfs_btree_ptr\t*ptrp,\n\tunion xfs_btree_key\t*key,\n\tstruct xfs_btree_cur\t**curp,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tunion xfs_btree_ptr\tlptr;\t\t/* left sibling block ptr */\n\tstruct xfs_buf\t\t*lbp;\t\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t\t/* left btree block */\n\tunion xfs_btree_ptr\trptr;\t\t/* right sibling block ptr */\n\tstruct xfs_buf\t\t*rbp;\t\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t\t/* right btree block */\n\tunion xfs_btree_ptr\trrptr;\t\t/* right-right sibling ptr */\n\tstruct xfs_buf\t\t*rrbp;\t\t/* right-right buffer pointer */\n\tstruct xfs_btree_block\t*rrblock;\t/* right-right btree block */\n\tint\t\t\tlrecs;\n\tint\t\t\trrecs;\n\tint\t\t\tsrc_index;\n\tint\t\t\terror;\t\t/* error return value */\n#ifdef DEBUG\n\tint\t\t\ti;\n#endif\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGIPK(cur, level, *ptrp, key);\n\n\tXFS_BTREE_STATS_INC(cur, split);\n\n\t/* Set up left block (current one). */\n\tleft = xfs_btree_get_block(cur, level, &lbp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, left, level, lbp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\txfs_btree_buf_to_ptr(cur, lbp, &lptr);\n\n\t/* Allocate the new block. If we can't do it, we're toast. Give up. */\n\terror = cur->bc_ops->alloc_block(cur, &lptr, &rptr, stat);\n\tif (error)\n\t\tgoto error0;\n\tif (*stat == 0)\n\t\tgoto out0;\n\tXFS_BTREE_STATS_INC(cur, alloc);\n\n\t/* Set up the new block as \"right\". */\n\terror = xfs_btree_get_buf_block(cur, &rptr, 0, &right, &rbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* Fill in the btree header for the new right block. */\n\txfs_btree_init_block_cur(cur, rbp, xfs_btree_get_level(left), 0);\n\n\t/*\n\t * Split the entries between the old and the new block evenly.\n\t * Make sure that if there's an odd number of entries now, that\n\t * each new block will have the same number of entries.\n\t */\n\tlrecs = xfs_btree_get_numrecs(left);\n\trrecs = lrecs / 2;\n\tif ((lrecs & 1) && cur->bc_ptrs[level] <= rrecs + 1)\n\t\trrecs++;\n\tsrc_index = (lrecs - rrecs + 1);\n\n\tXFS_BTREE_STATS_ADD(cur, moves, rrecs);\n\n\t/*\n\t * Copy btree block entries from the left block over to the\n\t * new block, the right. Update the right block and log the\n\t * changes.\n\t */\n\tif (level > 0) {\n\t\t/* It's a non-leaf.  Move keys and pointers. */\n\t\tunion xfs_btree_key\t*lkp;\t/* left btree key */\n\t\tunion xfs_btree_ptr\t*lpp;\t/* left address pointer */\n\t\tunion xfs_btree_key\t*rkp;\t/* right btree key */\n\t\tunion xfs_btree_ptr\t*rpp;\t/* right address pointer */\n\n\t\tlkp = xfs_btree_key_addr(cur, src_index, left);\n\t\tlpp = xfs_btree_ptr_addr(cur, src_index, left);\n\t\trkp = xfs_btree_key_addr(cur, 1, right);\n\t\trpp = xfs_btree_ptr_addr(cur, 1, right);\n\n#ifdef DEBUG\n\t\tfor (i = src_index; i < rrecs; i++) {\n\t\t\terror = xfs_btree_check_ptr(cur, lpp, i, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\n\t\txfs_btree_copy_keys(cur, rkp, lkp, rrecs);\n\t\txfs_btree_copy_ptrs(cur, rpp, lpp, rrecs);\n\n\t\txfs_btree_log_keys(cur, rbp, 1, rrecs);\n\t\txfs_btree_log_ptrs(cur, rbp, 1, rrecs);\n\n\t\t/* Grab the keys to the entries moved to the right block */\n\t\txfs_btree_copy_keys(cur, key, rkp, 1);\n\t} else {\n\t\t/* It's a leaf.  Move records.  */\n\t\tunion xfs_btree_rec\t*lrp;\t/* left record pointer */\n\t\tunion xfs_btree_rec\t*rrp;\t/* right record pointer */\n\n\t\tlrp = xfs_btree_rec_addr(cur, src_index, left);\n\t\trrp = xfs_btree_rec_addr(cur, 1, right);\n\n\t\txfs_btree_copy_recs(cur, rrp, lrp, rrecs);\n\t\txfs_btree_log_recs(cur, rbp, 1, rrecs);\n\n\t\tcur->bc_ops->init_key_from_rec(key,\n\t\t\txfs_btree_rec_addr(cur, 1, right));\n\t}\n\n\n\t/*\n\t * Find the left block number by looking in the buffer.\n\t * Adjust numrecs, sibling pointers.\n\t */\n\txfs_btree_get_sibling(cur, left, &rrptr, XFS_BB_RIGHTSIB);\n\txfs_btree_set_sibling(cur, right, &rrptr, XFS_BB_RIGHTSIB);\n\txfs_btree_set_sibling(cur, right, &lptr, XFS_BB_LEFTSIB);\n\txfs_btree_set_sibling(cur, left, &rptr, XFS_BB_RIGHTSIB);\n\n\tlrecs -= rrecs;\n\txfs_btree_set_numrecs(left, lrecs);\n\txfs_btree_set_numrecs(right, xfs_btree_get_numrecs(right) + rrecs);\n\n\txfs_btree_log_block(cur, rbp, XFS_BB_ALL_BITS);\n\txfs_btree_log_block(cur, lbp, XFS_BB_NUMRECS | XFS_BB_RIGHTSIB);\n\n\t/*\n\t * If there's a block to the new block's right, make that block\n\t * point back to right instead of to left.\n\t */\n\tif (!xfs_btree_ptr_is_null(cur, &rrptr)) {\n\t\terror = xfs_btree_read_buf_block(cur, &rrptr,\n\t\t\t\t\t\t\t0, &rrblock, &rrbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_set_sibling(cur, rrblock, &rptr, XFS_BB_LEFTSIB);\n\t\txfs_btree_log_block(cur, rrbp, XFS_BB_LEFTSIB);\n\t}\n\t/*\n\t * If the cursor is really in the right block, move it there.\n\t * If it's just pointing past the last entry in left, then we'll\n\t * insert there, so don't change anything in that case.\n\t */\n\tif (cur->bc_ptrs[level] > lrecs + 1) {\n\t\txfs_btree_setbuf(cur, level, rbp);\n\t\tcur->bc_ptrs[level] -= lrecs;\n\t}\n\t/*\n\t * If there are more levels, we'll need another cursor which refers\n\t * the right block, no matter where this cursor was.\n\t */\n\tif (level + 1 < cur->bc_nlevels) {\n\t\terror = xfs_btree_dup_cursor(cur, curp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\t(*curp)->bc_ptrs[level + 1]++;\n\t}\n\t*ptrp = rptr;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\t\t\t\t\t/* error */\n__xfs_btree_split(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tunion xfs_btree_ptr\t*ptrp,\n\tunion xfs_btree_key\t*key,\n\tstruct xfs_btree_cur\t**curp,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tunion xfs_btree_ptr\tlptr;\t\t/* left sibling block ptr */\n\tstruct xfs_buf\t\t*lbp;\t\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t\t/* left btree block */\n\tunion xfs_btree_ptr\trptr;\t\t/* right sibling block ptr */\n\tstruct xfs_buf\t\t*rbp;\t\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t\t/* right btree block */\n\tunion xfs_btree_ptr\trrptr;\t\t/* right-right sibling ptr */\n\tstruct xfs_buf\t\t*rrbp;\t\t/* right-right buffer pointer */\n\tstruct xfs_btree_block\t*rrblock;\t/* right-right btree block */\n\tint\t\t\tlrecs;\n\tint\t\t\trrecs;\n\tint\t\t\tsrc_index;\n\tint\t\t\terror;\t\t/* error return value */\n#ifdef DEBUG\n\tint\t\t\ti;\n#endif\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGIPK(cur, level, *ptrp, key);\n\n\tXFS_BTREE_STATS_INC(cur, split);\n\n\t/* Set up left block (current one). */\n\tleft = xfs_btree_get_block(cur, level, &lbp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, left, level, lbp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\txfs_btree_buf_to_ptr(cur, lbp, &lptr);\n\n\t/* Allocate the new block. If we can't do it, we're toast. Give up. */\n\terror = cur->bc_ops->alloc_block(cur, &lptr, &rptr, stat);\n\tif (error)\n\t\tgoto error0;\n\tif (*stat == 0)\n\t\tgoto out0;\n\tXFS_BTREE_STATS_INC(cur, alloc);\n\n\t/* Set up the new block as \"right\". */\n\terror = xfs_btree_get_buf_block(cur, &rptr, 0, &right, &rbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* Fill in the btree header for the new right block. */\n\txfs_btree_init_block_cur(cur, rbp, xfs_btree_get_level(left), 0);\n\n\t/*\n\t * Split the entries between the old and the new block evenly.\n\t * Make sure that if there's an odd number of entries now, that\n\t * each new block will have the same number of entries.\n\t */\n\tlrecs = xfs_btree_get_numrecs(left);\n\trrecs = lrecs / 2;\n\tif ((lrecs & 1) && cur->bc_ptrs[level] <= rrecs + 1)\n\t\trrecs++;\n\tsrc_index = (lrecs - rrecs + 1);\n\n\tXFS_BTREE_STATS_ADD(cur, moves, rrecs);\n\n\t/*\n\t * Copy btree block entries from the left block over to the\n\t * new block, the right. Update the right block and log the\n\t * changes.\n\t */\n\tif (level > 0) {\n\t\t/* It's a non-leaf.  Move keys and pointers. */\n\t\tunion xfs_btree_key\t*lkp;\t/* left btree key */\n\t\tunion xfs_btree_ptr\t*lpp;\t/* left address pointer */\n\t\tunion xfs_btree_key\t*rkp;\t/* right btree key */\n\t\tunion xfs_btree_ptr\t*rpp;\t/* right address pointer */\n\n\t\tlkp = xfs_btree_key_addr(cur, src_index, left);\n\t\tlpp = xfs_btree_ptr_addr(cur, src_index, left);\n\t\trkp = xfs_btree_key_addr(cur, 1, right);\n\t\trpp = xfs_btree_ptr_addr(cur, 1, right);\n\n#ifdef DEBUG\n\t\tfor (i = src_index; i < rrecs; i++) {\n\t\t\terror = xfs_btree_check_ptr(cur, lpp, i, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\n\t\txfs_btree_copy_keys(cur, rkp, lkp, rrecs);\n\t\txfs_btree_copy_ptrs(cur, rpp, lpp, rrecs);\n\n\t\txfs_btree_log_keys(cur, rbp, 1, rrecs);\n\t\txfs_btree_log_ptrs(cur, rbp, 1, rrecs);\n\n\t\t/* Grab the keys to the entries moved to the right block */\n\t\txfs_btree_copy_keys(cur, key, rkp, 1);\n\t} else {\n\t\t/* It's a leaf.  Move records.  */\n\t\tunion xfs_btree_rec\t*lrp;\t/* left record pointer */\n\t\tunion xfs_btree_rec\t*rrp;\t/* right record pointer */\n\n\t\tlrp = xfs_btree_rec_addr(cur, src_index, left);\n\t\trrp = xfs_btree_rec_addr(cur, 1, right);\n\n\t\txfs_btree_copy_recs(cur, rrp, lrp, rrecs);\n\t\txfs_btree_log_recs(cur, rbp, 1, rrecs);\n\n\t\tcur->bc_ops->init_key_from_rec(key,\n\t\t\txfs_btree_rec_addr(cur, 1, right));\n\t}\n\n\n\t/*\n\t * Find the left block number by looking in the buffer.\n\t * Adjust numrecs, sibling pointers.\n\t */\n\txfs_btree_get_sibling(cur, left, &rrptr, XFS_BB_RIGHTSIB);\n\txfs_btree_set_sibling(cur, right, &rrptr, XFS_BB_RIGHTSIB);\n\txfs_btree_set_sibling(cur, right, &lptr, XFS_BB_LEFTSIB);\n\txfs_btree_set_sibling(cur, left, &rptr, XFS_BB_RIGHTSIB);\n\n\tlrecs -= rrecs;\n\txfs_btree_set_numrecs(left, lrecs);\n\txfs_btree_set_numrecs(right, xfs_btree_get_numrecs(right) + rrecs);\n\n\txfs_btree_log_block(cur, rbp, XFS_BB_ALL_BITS);\n\txfs_btree_log_block(cur, lbp, XFS_BB_NUMRECS | XFS_BB_RIGHTSIB);\n\n\t/*\n\t * If there's a block to the new block's right, make that block\n\t * point back to right instead of to left.\n\t */\n\tif (!xfs_btree_ptr_is_null(cur, &rrptr)) {\n\t\terror = xfs_btree_read_buf_block(cur, &rrptr,\n\t\t\t\t\t\t\t0, &rrblock, &rrbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_set_sibling(cur, rrblock, &rptr, XFS_BB_LEFTSIB);\n\t\txfs_btree_log_block(cur, rrbp, XFS_BB_LEFTSIB);\n\t}\n\t/*\n\t * If the cursor is really in the right block, move it there.\n\t * If it's just pointing past the last entry in left, then we'll\n\t * insert there, so don't change anything in that case.\n\t */\n\tif (cur->bc_ptrs[level] > lrecs + 1) {\n\t\txfs_btree_setbuf(cur, level, rbp);\n\t\tcur->bc_ptrs[level] -= lrecs;\n\t}\n\t/*\n\t * If there are more levels, we'll need another cursor which refers\n\t * the right block, no matter where this cursor was.\n\t */\n\tif (level + 1 < cur->bc_nlevels) {\n\t\terror = xfs_btree_dup_cursor(cur, curp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\t(*curp)->bc_ptrs[level + 1]++;\n\t}\n\t*ptrp = rptr;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DECLARE_COMPLETION_ONSTACK",
          "args": [
            "done"
          ],
          "line": 2563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\t\t\t\t\t/* error */\nxfs_btree_split(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tunion xfs_btree_ptr\t*ptrp,\n\tunion xfs_btree_key\t*key,\n\tstruct xfs_btree_cur\t**curp,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_split_args\targs;\n\tDECLARE_COMPLETION_ONSTACK(done);\n\n\tif (cur->bc_btnum != XFS_BTNUM_BMAP)\n\t\treturn __xfs_btree_split(cur, level, ptrp, key, curp, stat);\n\n\targs.cur = cur;\n\targs.level = level;\n\targs.ptrp = ptrp;\n\targs.key = key;\n\targs.curp = curp;\n\targs.stat = stat;\n\targs.done = &done;\n\targs.kswapd = current_is_kswapd();\n\tINIT_WORK_ONSTACK(&args.work, xfs_btree_split_worker);\n\tqueue_work(xfs_alloc_wq, &args.work);\n\twait_for_completion(&done);\n\tdestroy_work_on_stack(&args.work);\n\treturn args.result;\n}"
  },
  {
    "function_name": "xfs_btree_split_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "2521-2546",
    "snippet": "static void\nxfs_btree_split_worker(\n\tstruct work_struct\t*work)\n{\n\tstruct xfs_btree_split_args\t*args = container_of(work,\n\t\t\t\t\t\tstruct xfs_btree_split_args, work);\n\tunsigned long\t\tpflags;\n\tunsigned long\t\tnew_pflags = PF_FSTRANS;\n\n\t/*\n\t * we are in a transaction context here, but may also be doing work\n\t * in kswapd context, and hence we may need to inherit that state\n\t * temporarily to ensure that we don't block waiting for memory reclaim\n\t * in any way.\n\t */\n\tif (args->kswapd)\n\t\tnew_pflags |= PF_MEMALLOC | PF_SWAPWRITE | PF_KSWAPD;\n\n\tcurrent_set_flags_nested(&pflags, new_pflags);\n\n\targs->result = __xfs_btree_split(args->cur, args->level, args->ptrp,\n\t\t\t\t\t args->key, args->curp, args->stat);\n\tcomplete(args->done);\n\n\tcurrent_restore_flags_nested(&pflags, new_pflags);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_restore_flags_nested",
          "args": [
            "&pflags",
            "new_pflags"
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "args->done"
          ],
          "line": 2543
        },
        "resolved": true,
        "details": {
          "function_name": "dio_aio_complete_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/direct-io.c",
          "lines": "275-280",
          "snippet": "static void dio_aio_complete_work(struct work_struct *work)\n{\n\tstruct dio *dio = container_of(work, struct dio, complete_work);\n\n\tdio_complete(dio, dio->iocb->ki_pos, 0, true);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uio.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/err.h>",
            "#include <linux/wait.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/prefetch.h>\n#include <linux/atomic.h>\n#include <linux/uio.h>\n#include <linux/rwsem.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/err.h>\n#include <linux/wait.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void dio_aio_complete_work(struct work_struct *work)\n{\n\tstruct dio *dio = container_of(work, struct dio, complete_work);\n\n\tdio_complete(dio, dio->iocb->ki_pos, 0, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__xfs_btree_split",
          "args": [
            "args->cur",
            "args->level",
            "args->ptrp",
            "args->key",
            "args->curp",
            "args->stat"
          ],
          "line": 2541
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_btree_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "2324-2503",
          "snippet": "STATIC int\t\t\t\t\t/* error */\n__xfs_btree_split(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tunion xfs_btree_ptr\t*ptrp,\n\tunion xfs_btree_key\t*key,\n\tstruct xfs_btree_cur\t**curp,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tunion xfs_btree_ptr\tlptr;\t\t/* left sibling block ptr */\n\tstruct xfs_buf\t\t*lbp;\t\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t\t/* left btree block */\n\tunion xfs_btree_ptr\trptr;\t\t/* right sibling block ptr */\n\tstruct xfs_buf\t\t*rbp;\t\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t\t/* right btree block */\n\tunion xfs_btree_ptr\trrptr;\t\t/* right-right sibling ptr */\n\tstruct xfs_buf\t\t*rrbp;\t\t/* right-right buffer pointer */\n\tstruct xfs_btree_block\t*rrblock;\t/* right-right btree block */\n\tint\t\t\tlrecs;\n\tint\t\t\trrecs;\n\tint\t\t\tsrc_index;\n\tint\t\t\terror;\t\t/* error return value */\n#ifdef DEBUG\n\tint\t\t\ti;\n#endif\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGIPK(cur, level, *ptrp, key);\n\n\tXFS_BTREE_STATS_INC(cur, split);\n\n\t/* Set up left block (current one). */\n\tleft = xfs_btree_get_block(cur, level, &lbp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, left, level, lbp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\txfs_btree_buf_to_ptr(cur, lbp, &lptr);\n\n\t/* Allocate the new block. If we can't do it, we're toast. Give up. */\n\terror = cur->bc_ops->alloc_block(cur, &lptr, &rptr, stat);\n\tif (error)\n\t\tgoto error0;\n\tif (*stat == 0)\n\t\tgoto out0;\n\tXFS_BTREE_STATS_INC(cur, alloc);\n\n\t/* Set up the new block as \"right\". */\n\terror = xfs_btree_get_buf_block(cur, &rptr, 0, &right, &rbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* Fill in the btree header for the new right block. */\n\txfs_btree_init_block_cur(cur, rbp, xfs_btree_get_level(left), 0);\n\n\t/*\n\t * Split the entries between the old and the new block evenly.\n\t * Make sure that if there's an odd number of entries now, that\n\t * each new block will have the same number of entries.\n\t */\n\tlrecs = xfs_btree_get_numrecs(left);\n\trrecs = lrecs / 2;\n\tif ((lrecs & 1) && cur->bc_ptrs[level] <= rrecs + 1)\n\t\trrecs++;\n\tsrc_index = (lrecs - rrecs + 1);\n\n\tXFS_BTREE_STATS_ADD(cur, moves, rrecs);\n\n\t/*\n\t * Copy btree block entries from the left block over to the\n\t * new block, the right. Update the right block and log the\n\t * changes.\n\t */\n\tif (level > 0) {\n\t\t/* It's a non-leaf.  Move keys and pointers. */\n\t\tunion xfs_btree_key\t*lkp;\t/* left btree key */\n\t\tunion xfs_btree_ptr\t*lpp;\t/* left address pointer */\n\t\tunion xfs_btree_key\t*rkp;\t/* right btree key */\n\t\tunion xfs_btree_ptr\t*rpp;\t/* right address pointer */\n\n\t\tlkp = xfs_btree_key_addr(cur, src_index, left);\n\t\tlpp = xfs_btree_ptr_addr(cur, src_index, left);\n\t\trkp = xfs_btree_key_addr(cur, 1, right);\n\t\trpp = xfs_btree_ptr_addr(cur, 1, right);\n\n#ifdef DEBUG\n\t\tfor (i = src_index; i < rrecs; i++) {\n\t\t\terror = xfs_btree_check_ptr(cur, lpp, i, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\n\t\txfs_btree_copy_keys(cur, rkp, lkp, rrecs);\n\t\txfs_btree_copy_ptrs(cur, rpp, lpp, rrecs);\n\n\t\txfs_btree_log_keys(cur, rbp, 1, rrecs);\n\t\txfs_btree_log_ptrs(cur, rbp, 1, rrecs);\n\n\t\t/* Grab the keys to the entries moved to the right block */\n\t\txfs_btree_copy_keys(cur, key, rkp, 1);\n\t} else {\n\t\t/* It's a leaf.  Move records.  */\n\t\tunion xfs_btree_rec\t*lrp;\t/* left record pointer */\n\t\tunion xfs_btree_rec\t*rrp;\t/* right record pointer */\n\n\t\tlrp = xfs_btree_rec_addr(cur, src_index, left);\n\t\trrp = xfs_btree_rec_addr(cur, 1, right);\n\n\t\txfs_btree_copy_recs(cur, rrp, lrp, rrecs);\n\t\txfs_btree_log_recs(cur, rbp, 1, rrecs);\n\n\t\tcur->bc_ops->init_key_from_rec(key,\n\t\t\txfs_btree_rec_addr(cur, 1, right));\n\t}\n\n\n\t/*\n\t * Find the left block number by looking in the buffer.\n\t * Adjust numrecs, sibling pointers.\n\t */\n\txfs_btree_get_sibling(cur, left, &rrptr, XFS_BB_RIGHTSIB);\n\txfs_btree_set_sibling(cur, right, &rrptr, XFS_BB_RIGHTSIB);\n\txfs_btree_set_sibling(cur, right, &lptr, XFS_BB_LEFTSIB);\n\txfs_btree_set_sibling(cur, left, &rptr, XFS_BB_RIGHTSIB);\n\n\tlrecs -= rrecs;\n\txfs_btree_set_numrecs(left, lrecs);\n\txfs_btree_set_numrecs(right, xfs_btree_get_numrecs(right) + rrecs);\n\n\txfs_btree_log_block(cur, rbp, XFS_BB_ALL_BITS);\n\txfs_btree_log_block(cur, lbp, XFS_BB_NUMRECS | XFS_BB_RIGHTSIB);\n\n\t/*\n\t * If there's a block to the new block's right, make that block\n\t * point back to right instead of to left.\n\t */\n\tif (!xfs_btree_ptr_is_null(cur, &rrptr)) {\n\t\terror = xfs_btree_read_buf_block(cur, &rrptr,\n\t\t\t\t\t\t\t0, &rrblock, &rrbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_set_sibling(cur, rrblock, &rptr, XFS_BB_LEFTSIB);\n\t\txfs_btree_log_block(cur, rrbp, XFS_BB_LEFTSIB);\n\t}\n\t/*\n\t * If the cursor is really in the right block, move it there.\n\t * If it's just pointing past the last entry in left, then we'll\n\t * insert there, so don't change anything in that case.\n\t */\n\tif (cur->bc_ptrs[level] > lrecs + 1) {\n\t\txfs_btree_setbuf(cur, level, rbp);\n\t\tcur->bc_ptrs[level] -= lrecs;\n\t}\n\t/*\n\t * If there are more levels, we'll need another cursor which refers\n\t * the right block, no matter where this cursor was.\n\t */\n\tif (level + 1 < cur->bc_nlevels) {\n\t\terror = xfs_btree_dup_cursor(cur, curp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\t(*curp)->bc_ptrs[level + 1]++;\n\t}\n\t*ptrp = rptr;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\t\t\t\t\t/* error */\n__xfs_btree_split(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tunion xfs_btree_ptr\t*ptrp,\n\tunion xfs_btree_key\t*key,\n\tstruct xfs_btree_cur\t**curp,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tunion xfs_btree_ptr\tlptr;\t\t/* left sibling block ptr */\n\tstruct xfs_buf\t\t*lbp;\t\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t\t/* left btree block */\n\tunion xfs_btree_ptr\trptr;\t\t/* right sibling block ptr */\n\tstruct xfs_buf\t\t*rbp;\t\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t\t/* right btree block */\n\tunion xfs_btree_ptr\trrptr;\t\t/* right-right sibling ptr */\n\tstruct xfs_buf\t\t*rrbp;\t\t/* right-right buffer pointer */\n\tstruct xfs_btree_block\t*rrblock;\t/* right-right btree block */\n\tint\t\t\tlrecs;\n\tint\t\t\trrecs;\n\tint\t\t\tsrc_index;\n\tint\t\t\terror;\t\t/* error return value */\n#ifdef DEBUG\n\tint\t\t\ti;\n#endif\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGIPK(cur, level, *ptrp, key);\n\n\tXFS_BTREE_STATS_INC(cur, split);\n\n\t/* Set up left block (current one). */\n\tleft = xfs_btree_get_block(cur, level, &lbp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, left, level, lbp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\txfs_btree_buf_to_ptr(cur, lbp, &lptr);\n\n\t/* Allocate the new block. If we can't do it, we're toast. Give up. */\n\terror = cur->bc_ops->alloc_block(cur, &lptr, &rptr, stat);\n\tif (error)\n\t\tgoto error0;\n\tif (*stat == 0)\n\t\tgoto out0;\n\tXFS_BTREE_STATS_INC(cur, alloc);\n\n\t/* Set up the new block as \"right\". */\n\terror = xfs_btree_get_buf_block(cur, &rptr, 0, &right, &rbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* Fill in the btree header for the new right block. */\n\txfs_btree_init_block_cur(cur, rbp, xfs_btree_get_level(left), 0);\n\n\t/*\n\t * Split the entries between the old and the new block evenly.\n\t * Make sure that if there's an odd number of entries now, that\n\t * each new block will have the same number of entries.\n\t */\n\tlrecs = xfs_btree_get_numrecs(left);\n\trrecs = lrecs / 2;\n\tif ((lrecs & 1) && cur->bc_ptrs[level] <= rrecs + 1)\n\t\trrecs++;\n\tsrc_index = (lrecs - rrecs + 1);\n\n\tXFS_BTREE_STATS_ADD(cur, moves, rrecs);\n\n\t/*\n\t * Copy btree block entries from the left block over to the\n\t * new block, the right. Update the right block and log the\n\t * changes.\n\t */\n\tif (level > 0) {\n\t\t/* It's a non-leaf.  Move keys and pointers. */\n\t\tunion xfs_btree_key\t*lkp;\t/* left btree key */\n\t\tunion xfs_btree_ptr\t*lpp;\t/* left address pointer */\n\t\tunion xfs_btree_key\t*rkp;\t/* right btree key */\n\t\tunion xfs_btree_ptr\t*rpp;\t/* right address pointer */\n\n\t\tlkp = xfs_btree_key_addr(cur, src_index, left);\n\t\tlpp = xfs_btree_ptr_addr(cur, src_index, left);\n\t\trkp = xfs_btree_key_addr(cur, 1, right);\n\t\trpp = xfs_btree_ptr_addr(cur, 1, right);\n\n#ifdef DEBUG\n\t\tfor (i = src_index; i < rrecs; i++) {\n\t\t\terror = xfs_btree_check_ptr(cur, lpp, i, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\n\t\txfs_btree_copy_keys(cur, rkp, lkp, rrecs);\n\t\txfs_btree_copy_ptrs(cur, rpp, lpp, rrecs);\n\n\t\txfs_btree_log_keys(cur, rbp, 1, rrecs);\n\t\txfs_btree_log_ptrs(cur, rbp, 1, rrecs);\n\n\t\t/* Grab the keys to the entries moved to the right block */\n\t\txfs_btree_copy_keys(cur, key, rkp, 1);\n\t} else {\n\t\t/* It's a leaf.  Move records.  */\n\t\tunion xfs_btree_rec\t*lrp;\t/* left record pointer */\n\t\tunion xfs_btree_rec\t*rrp;\t/* right record pointer */\n\n\t\tlrp = xfs_btree_rec_addr(cur, src_index, left);\n\t\trrp = xfs_btree_rec_addr(cur, 1, right);\n\n\t\txfs_btree_copy_recs(cur, rrp, lrp, rrecs);\n\t\txfs_btree_log_recs(cur, rbp, 1, rrecs);\n\n\t\tcur->bc_ops->init_key_from_rec(key,\n\t\t\txfs_btree_rec_addr(cur, 1, right));\n\t}\n\n\n\t/*\n\t * Find the left block number by looking in the buffer.\n\t * Adjust numrecs, sibling pointers.\n\t */\n\txfs_btree_get_sibling(cur, left, &rrptr, XFS_BB_RIGHTSIB);\n\txfs_btree_set_sibling(cur, right, &rrptr, XFS_BB_RIGHTSIB);\n\txfs_btree_set_sibling(cur, right, &lptr, XFS_BB_LEFTSIB);\n\txfs_btree_set_sibling(cur, left, &rptr, XFS_BB_RIGHTSIB);\n\n\tlrecs -= rrecs;\n\txfs_btree_set_numrecs(left, lrecs);\n\txfs_btree_set_numrecs(right, xfs_btree_get_numrecs(right) + rrecs);\n\n\txfs_btree_log_block(cur, rbp, XFS_BB_ALL_BITS);\n\txfs_btree_log_block(cur, lbp, XFS_BB_NUMRECS | XFS_BB_RIGHTSIB);\n\n\t/*\n\t * If there's a block to the new block's right, make that block\n\t * point back to right instead of to left.\n\t */\n\tif (!xfs_btree_ptr_is_null(cur, &rrptr)) {\n\t\terror = xfs_btree_read_buf_block(cur, &rrptr,\n\t\t\t\t\t\t\t0, &rrblock, &rrbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_set_sibling(cur, rrblock, &rptr, XFS_BB_LEFTSIB);\n\t\txfs_btree_log_block(cur, rrbp, XFS_BB_LEFTSIB);\n\t}\n\t/*\n\t * If the cursor is really in the right block, move it there.\n\t * If it's just pointing past the last entry in left, then we'll\n\t * insert there, so don't change anything in that case.\n\t */\n\tif (cur->bc_ptrs[level] > lrecs + 1) {\n\t\txfs_btree_setbuf(cur, level, rbp);\n\t\tcur->bc_ptrs[level] -= lrecs;\n\t}\n\t/*\n\t * If there are more levels, we'll need another cursor which refers\n\t * the right block, no matter where this cursor was.\n\t */\n\tif (level + 1 < cur->bc_nlevels) {\n\t\terror = xfs_btree_dup_cursor(cur, curp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\t(*curp)->bc_ptrs[level + 1]++;\n\t}\n\t*ptrp = rptr;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_set_flags_nested",
          "args": [
            "&pflags",
            "new_pflags"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structxfs_btree_split_args",
            "work"
          ],
          "line": 2525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic void\nxfs_btree_split_worker(\n\tstruct work_struct\t*work)\n{\n\tstruct xfs_btree_split_args\t*args = container_of(work,\n\t\t\t\t\t\tstruct xfs_btree_split_args, work);\n\tunsigned long\t\tpflags;\n\tunsigned long\t\tnew_pflags = PF_FSTRANS;\n\n\t/*\n\t * we are in a transaction context here, but may also be doing work\n\t * in kswapd context, and hence we may need to inherit that state\n\t * temporarily to ensure that we don't block waiting for memory reclaim\n\t * in any way.\n\t */\n\tif (args->kswapd)\n\t\tnew_pflags |= PF_MEMALLOC | PF_SWAPWRITE | PF_KSWAPD;\n\n\tcurrent_set_flags_nested(&pflags, new_pflags);\n\n\targs->result = __xfs_btree_split(args->cur, args->level, args->ptrp,\n\t\t\t\t\t args->key, args->curp, args->stat);\n\tcomplete(args->done);\n\n\tcurrent_restore_flags_nested(&pflags, new_pflags);\n}"
  },
  {
    "function_name": "__xfs_btree_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "2324-2503",
    "snippet": "STATIC int\t\t\t\t\t/* error */\n__xfs_btree_split(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tunion xfs_btree_ptr\t*ptrp,\n\tunion xfs_btree_key\t*key,\n\tstruct xfs_btree_cur\t**curp,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tunion xfs_btree_ptr\tlptr;\t\t/* left sibling block ptr */\n\tstruct xfs_buf\t\t*lbp;\t\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t\t/* left btree block */\n\tunion xfs_btree_ptr\trptr;\t\t/* right sibling block ptr */\n\tstruct xfs_buf\t\t*rbp;\t\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t\t/* right btree block */\n\tunion xfs_btree_ptr\trrptr;\t\t/* right-right sibling ptr */\n\tstruct xfs_buf\t\t*rrbp;\t\t/* right-right buffer pointer */\n\tstruct xfs_btree_block\t*rrblock;\t/* right-right btree block */\n\tint\t\t\tlrecs;\n\tint\t\t\trrecs;\n\tint\t\t\tsrc_index;\n\tint\t\t\terror;\t\t/* error return value */\n#ifdef DEBUG\n\tint\t\t\ti;\n#endif\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGIPK(cur, level, *ptrp, key);\n\n\tXFS_BTREE_STATS_INC(cur, split);\n\n\t/* Set up left block (current one). */\n\tleft = xfs_btree_get_block(cur, level, &lbp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, left, level, lbp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\txfs_btree_buf_to_ptr(cur, lbp, &lptr);\n\n\t/* Allocate the new block. If we can't do it, we're toast. Give up. */\n\terror = cur->bc_ops->alloc_block(cur, &lptr, &rptr, stat);\n\tif (error)\n\t\tgoto error0;\n\tif (*stat == 0)\n\t\tgoto out0;\n\tXFS_BTREE_STATS_INC(cur, alloc);\n\n\t/* Set up the new block as \"right\". */\n\terror = xfs_btree_get_buf_block(cur, &rptr, 0, &right, &rbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* Fill in the btree header for the new right block. */\n\txfs_btree_init_block_cur(cur, rbp, xfs_btree_get_level(left), 0);\n\n\t/*\n\t * Split the entries between the old and the new block evenly.\n\t * Make sure that if there's an odd number of entries now, that\n\t * each new block will have the same number of entries.\n\t */\n\tlrecs = xfs_btree_get_numrecs(left);\n\trrecs = lrecs / 2;\n\tif ((lrecs & 1) && cur->bc_ptrs[level] <= rrecs + 1)\n\t\trrecs++;\n\tsrc_index = (lrecs - rrecs + 1);\n\n\tXFS_BTREE_STATS_ADD(cur, moves, rrecs);\n\n\t/*\n\t * Copy btree block entries from the left block over to the\n\t * new block, the right. Update the right block and log the\n\t * changes.\n\t */\n\tif (level > 0) {\n\t\t/* It's a non-leaf.  Move keys and pointers. */\n\t\tunion xfs_btree_key\t*lkp;\t/* left btree key */\n\t\tunion xfs_btree_ptr\t*lpp;\t/* left address pointer */\n\t\tunion xfs_btree_key\t*rkp;\t/* right btree key */\n\t\tunion xfs_btree_ptr\t*rpp;\t/* right address pointer */\n\n\t\tlkp = xfs_btree_key_addr(cur, src_index, left);\n\t\tlpp = xfs_btree_ptr_addr(cur, src_index, left);\n\t\trkp = xfs_btree_key_addr(cur, 1, right);\n\t\trpp = xfs_btree_ptr_addr(cur, 1, right);\n\n#ifdef DEBUG\n\t\tfor (i = src_index; i < rrecs; i++) {\n\t\t\terror = xfs_btree_check_ptr(cur, lpp, i, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\n\t\txfs_btree_copy_keys(cur, rkp, lkp, rrecs);\n\t\txfs_btree_copy_ptrs(cur, rpp, lpp, rrecs);\n\n\t\txfs_btree_log_keys(cur, rbp, 1, rrecs);\n\t\txfs_btree_log_ptrs(cur, rbp, 1, rrecs);\n\n\t\t/* Grab the keys to the entries moved to the right block */\n\t\txfs_btree_copy_keys(cur, key, rkp, 1);\n\t} else {\n\t\t/* It's a leaf.  Move records.  */\n\t\tunion xfs_btree_rec\t*lrp;\t/* left record pointer */\n\t\tunion xfs_btree_rec\t*rrp;\t/* right record pointer */\n\n\t\tlrp = xfs_btree_rec_addr(cur, src_index, left);\n\t\trrp = xfs_btree_rec_addr(cur, 1, right);\n\n\t\txfs_btree_copy_recs(cur, rrp, lrp, rrecs);\n\t\txfs_btree_log_recs(cur, rbp, 1, rrecs);\n\n\t\tcur->bc_ops->init_key_from_rec(key,\n\t\t\txfs_btree_rec_addr(cur, 1, right));\n\t}\n\n\n\t/*\n\t * Find the left block number by looking in the buffer.\n\t * Adjust numrecs, sibling pointers.\n\t */\n\txfs_btree_get_sibling(cur, left, &rrptr, XFS_BB_RIGHTSIB);\n\txfs_btree_set_sibling(cur, right, &rrptr, XFS_BB_RIGHTSIB);\n\txfs_btree_set_sibling(cur, right, &lptr, XFS_BB_LEFTSIB);\n\txfs_btree_set_sibling(cur, left, &rptr, XFS_BB_RIGHTSIB);\n\n\tlrecs -= rrecs;\n\txfs_btree_set_numrecs(left, lrecs);\n\txfs_btree_set_numrecs(right, xfs_btree_get_numrecs(right) + rrecs);\n\n\txfs_btree_log_block(cur, rbp, XFS_BB_ALL_BITS);\n\txfs_btree_log_block(cur, lbp, XFS_BB_NUMRECS | XFS_BB_RIGHTSIB);\n\n\t/*\n\t * If there's a block to the new block's right, make that block\n\t * point back to right instead of to left.\n\t */\n\tif (!xfs_btree_ptr_is_null(cur, &rrptr)) {\n\t\terror = xfs_btree_read_buf_block(cur, &rrptr,\n\t\t\t\t\t\t\t0, &rrblock, &rrbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_set_sibling(cur, rrblock, &rptr, XFS_BB_LEFTSIB);\n\t\txfs_btree_log_block(cur, rrbp, XFS_BB_LEFTSIB);\n\t}\n\t/*\n\t * If the cursor is really in the right block, move it there.\n\t * If it's just pointing past the last entry in left, then we'll\n\t * insert there, so don't change anything in that case.\n\t */\n\tif (cur->bc_ptrs[level] > lrecs + 1) {\n\t\txfs_btree_setbuf(cur, level, rbp);\n\t\tcur->bc_ptrs[level] -= lrecs;\n\t}\n\t/*\n\t * If there are more levels, we'll need another cursor which refers\n\t * the right block, no matter where this cursor was.\n\t */\n\tif (level + 1 < cur->bc_nlevels) {\n\t\terror = xfs_btree_dup_cursor(cur, curp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\t(*curp)->bc_ptrs[level + 1]++;\n\t}\n\t*ptrp = rptr;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ERROR"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 2496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_dup_cursor",
          "args": [
            "cur",
            "curp"
          ],
          "line": 2486
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_dup_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "324-371",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_dup_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* input cursor */\n\txfs_btree_cur_t\t**ncur)\t\t/* output cursor */\n{\n\txfs_buf_t\t*bp;\t\t/* btree block's buffer pointer */\n\tint\t\terror;\t\t/* error return value */\n\tint\t\ti;\t\t/* level number of btree block */\n\txfs_mount_t\t*mp;\t\t/* mount structure for filesystem */\n\txfs_btree_cur_t\t*new;\t\t/* new cursor value */\n\txfs_trans_t\t*tp;\t\t/* transaction pointer, can be NULL */\n\n\ttp = cur->bc_tp;\n\tmp = cur->bc_mp;\n\n\t/*\n\t * Allocate a new cursor like the old one.\n\t */\n\tnew = cur->bc_ops->dup_cursor(cur);\n\n\t/*\n\t * Copy the record currently in the cursor.\n\t */\n\tnew->bc_rec = cur->bc_rec;\n\n\t/*\n\t * For each level current, re-get the buffer and copy the ptr value.\n\t */\n\tfor (i = 0; i < new->bc_nlevels; i++) {\n\t\tnew->bc_ptrs[i] = cur->bc_ptrs[i];\n\t\tnew->bc_ra[i] = cur->bc_ra[i];\n\t\tbp = cur->bc_bufs[i];\n\t\tif (bp) {\n\t\t\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t\t\t   XFS_BUF_ADDR(bp), mp->m_bsize,\n\t\t\t\t\t\t   0, &bp,\n\t\t\t\t\t\t   cur->bc_ops->buf_ops);\n\t\t\tif (error) {\n\t\t\t\txfs_btree_del_cursor(new, error);\n\t\t\t\t*ncur = NULL;\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tnew->bc_bufs[i] = bp;\n\t}\n\t*ncur = new;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_btree_dup_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* input cursor */\n\txfs_btree_cur_t\t**ncur)\t\t/* output cursor */\n{\n\txfs_buf_t\t*bp;\t\t/* btree block's buffer pointer */\n\tint\t\terror;\t\t/* error return value */\n\tint\t\ti;\t\t/* level number of btree block */\n\txfs_mount_t\t*mp;\t\t/* mount structure for filesystem */\n\txfs_btree_cur_t\t*new;\t\t/* new cursor value */\n\txfs_trans_t\t*tp;\t\t/* transaction pointer, can be NULL */\n\n\ttp = cur->bc_tp;\n\tmp = cur->bc_mp;\n\n\t/*\n\t * Allocate a new cursor like the old one.\n\t */\n\tnew = cur->bc_ops->dup_cursor(cur);\n\n\t/*\n\t * Copy the record currently in the cursor.\n\t */\n\tnew->bc_rec = cur->bc_rec;\n\n\t/*\n\t * For each level current, re-get the buffer and copy the ptr value.\n\t */\n\tfor (i = 0; i < new->bc_nlevels; i++) {\n\t\tnew->bc_ptrs[i] = cur->bc_ptrs[i];\n\t\tnew->bc_ra[i] = cur->bc_ra[i];\n\t\tbp = cur->bc_bufs[i];\n\t\tif (bp) {\n\t\t\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t\t\t   XFS_BUF_ADDR(bp), mp->m_bsize,\n\t\t\t\t\t\t   0, &bp,\n\t\t\t\t\t\t   cur->bc_ops->buf_ops);\n\t\t\tif (error) {\n\t\t\t\txfs_btree_del_cursor(new, error);\n\t\t\t\t*ncur = NULL;\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tnew->bc_bufs[i] = bp;\n\t}\n\t*ncur = new;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_setbuf",
          "args": [
            "cur",
            "level",
            "rbp"
          ],
          "line": 2478
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_setbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "886-911",
          "snippet": "STATIC void\nxfs_btree_setbuf(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlev,\t/* level in btree */\n\txfs_buf_t\t\t*bp)\t/* new buffer to set */\n{\n\tstruct xfs_btree_block\t*b;\t/* btree block */\n\n\tif (cur->bc_bufs[lev])\n\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[lev]);\n\tcur->bc_bufs[lev] = bp;\n\tcur->bc_ra[lev] = 0;\n\n\tb = XFS_BUF_TO_BLOCK(bp);\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (b->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t} else {\n\t\tif (b->bb_u.s.bb_leftsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.s.bb_rightsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_setbuf(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlev,\t/* level in btree */\n\txfs_buf_t\t\t*bp)\t/* new buffer to set */\n{\n\tstruct xfs_btree_block\t*b;\t/* btree block */\n\n\tif (cur->bc_bufs[lev])\n\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[lev]);\n\tcur->bc_bufs[lev] = bp;\n\tcur->bc_ra[lev] = 0;\n\n\tb = XFS_BUF_TO_BLOCK(bp);\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (b->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t} else {\n\t\tif (b->bb_u.s.bb_leftsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.s.bb_rightsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_block",
          "args": [
            "cur",
            "rrbp",
            "XFS_BB_LEFTSIB"
          ],
          "line": 2470
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1357-1425",
          "snippet": "void\nxfs_btree_log_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfields)\t/* mask of fields: XFS_BB_... */\n{\n\tint\t\t\tfirst;\t/* first byte offset logged */\n\tint\t\t\tlast;\t/* last byte offset logged */\n\tstatic const short\tsoffsets[] = {\t/* table of offsets (short) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_crc),\n\t\tXFS_BTREE_SBLOCK_CRC_LEN\n\t};\n\tstatic const short\tloffsets[] = {\t/* table of offsets (long) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_crc),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_pad),\n\t\tXFS_BTREE_LBLOCK_CRC_LEN\n\t};\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBI(cur, bp, fields);\n\n\tif (bp) {\n\t\tint nbits;\n\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\t/*\n\t\t\t * We don't log the CRC when updating a btree\n\t\t\t * block but instead recreate it during log\n\t\t\t * recovery.  As the log buffers have checksums\n\t\t\t * of their own this is safe and avoids logging a crc\n\t\t\t * update in a lot of places.\n\t\t\t */\n\t\t\tif (fields == XFS_BB_ALL_BITS)\n\t\t\t\tfields = XFS_BB_ALL_BITS_CRC;\n\t\t\tnbits = XFS_BB_NUM_BITS_CRC;\n\t\t} else {\n\t\t\tnbits = XFS_BB_NUM_BITS;\n\t\t}\n\t\txfs_btree_offsets(fields,\n\t\t\t\t  (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\t\t\t\tloffsets : soffsets,\n\t\t\t\t  nbits, &first, &last);\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp, first, last);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_log_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfields)\t/* mask of fields: XFS_BB_... */\n{\n\tint\t\t\tfirst;\t/* first byte offset logged */\n\tint\t\t\tlast;\t/* last byte offset logged */\n\tstatic const short\tsoffsets[] = {\t/* table of offsets (short) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_crc),\n\t\tXFS_BTREE_SBLOCK_CRC_LEN\n\t};\n\tstatic const short\tloffsets[] = {\t/* table of offsets (long) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_crc),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_pad),\n\t\tXFS_BTREE_LBLOCK_CRC_LEN\n\t};\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBI(cur, bp, fields);\n\n\tif (bp) {\n\t\tint nbits;\n\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\t/*\n\t\t\t * We don't log the CRC when updating a btree\n\t\t\t * block but instead recreate it during log\n\t\t\t * recovery.  As the log buffers have checksums\n\t\t\t * of their own this is safe and avoids logging a crc\n\t\t\t * update in a lot of places.\n\t\t\t */\n\t\t\tif (fields == XFS_BB_ALL_BITS)\n\t\t\t\tfields = XFS_BB_ALL_BITS_CRC;\n\t\t\tnbits = XFS_BB_NUM_BITS_CRC;\n\t\t} else {\n\t\t\tnbits = XFS_BB_NUM_BITS;\n\t\t}\n\t\txfs_btree_offsets(fields,\n\t\t\t\t  (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\t\t\t\tloffsets : soffsets,\n\t\t\t\t  nbits, &first, &last);\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp, first, last);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_set_sibling",
          "args": [
            "cur",
            "rrblock",
            "&rptr",
            "XFS_BB_LEFTSIB"
          ],
          "line": 2469
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_set_sibling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "960-980",
          "snippet": "STATIC void\nxfs_btree_set_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tblock->bb_u.l.bb_rightsib = ptr->l;\n\t\telse\n\t\t\tblock->bb_u.l.bb_leftsib = ptr->l;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tblock->bb_u.s.bb_rightsib = ptr->s;\n\t\telse\n\t\t\tblock->bb_u.s.bb_leftsib = ptr->s;\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_set_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tblock->bb_u.l.bb_rightsib = ptr->l;\n\t\telse\n\t\t\tblock->bb_u.l.bb_leftsib = ptr->l;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tblock->bb_u.s.bb_rightsib = ptr->s;\n\t\telse\n\t\t\tblock->bb_u.s.bb_leftsib = ptr->s;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_read_buf_block",
          "args": [
            "cur",
            "&rrptr",
            "0",
            "&rrblock",
            "&rrbp"
          ],
          "line": 2465
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_read_buf_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1152-1177",
          "snippet": "STATIC int\nxfs_btree_read_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\tint\t\t\terror;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\terror = xfs_trans_read_buf(mp, cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, flags, bpp,\n\t\t\t\t   cur->bc_ops->buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_set_refs(cur, *bpp);\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_read_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\tint\t\t\terror;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\terror = xfs_trans_read_buf(mp, cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, flags, bpp,\n\t\t\t\t   cur->bc_ops->buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_set_refs(cur, *bpp);\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_is_null",
          "args": [
            "cur",
            "&rrptr"
          ],
          "line": 2464
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_is_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "913-922",
          "snippet": "STATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_set_numrecs",
          "args": [
            "right",
            "xfs_btree_get_numrecs(right) + rrecs"
          ],
          "line": 2455
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_set_numrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "421-425",
          "snippet": "static inline void xfs_btree_set_numrecs(struct xfs_btree_block *block,\n\t\t__uint16_t numrecs)\n{\n\tblock->bb_numrecs = cpu_to_be16(numrecs);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_btree_set_numrecs(struct xfs_btree_block *block,\n\t\t__uint16_t numrecs)\n{\n\tblock->bb_numrecs = cpu_to_be16(numrecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_numrecs",
          "args": [
            "right"
          ],
          "line": 2455
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_numrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "416-419",
          "snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_sibling",
          "args": [
            "cur",
            "left",
            "&rrptr",
            "XFS_BB_RIGHTSIB"
          ],
          "line": 2448
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_sibling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "938-958",
          "snippet": "STATIC void\nxfs_btree_get_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->l = block->bb_u.l.bb_rightsib;\n\t\telse\n\t\t\tptr->l = block->bb_u.l.bb_leftsib;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->s = block->bb_u.s.bb_rightsib;\n\t\telse\n\t\t\tptr->s = block->bb_u.s.bb_leftsib;\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_get_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->l = block->bb_u.l.bb_rightsib;\n\t\telse\n\t\t\tptr->l = block->bb_u.l.bb_leftsib;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->s = block->bb_u.s.bb_rightsib;\n\t\telse\n\t\t\tptr->s = block->bb_u.s.bb_leftsib;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->init_key_from_rec",
          "args": [
            "key",
            "xfs_btree_rec_addr(cur, 1, right)"
          ],
          "line": 2439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_rec_addr",
          "args": [
            "cur",
            "1",
            "right"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_rec_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "468-476",
          "snippet": "xfs_btree_rec *\nxfs_btree_rec_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_rec *)\n\t\t((char *)block + xfs_btree_rec_offset(cur, n));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_rec *\nxfs_btree_rec_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_rec *)\n\t\t((char *)block + xfs_btree_rec_offset(cur, n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_recs",
          "args": [
            "cur",
            "rbp",
            "1",
            "rrecs"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_recs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1307-1323",
          "snippet": "void\nxfs_btree_log_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t  xfs_btree_rec_offset(cur, first),\n\t\t\t  xfs_btree_rec_offset(cur, last + 1) - 1);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_log_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t  xfs_btree_rec_offset(cur, first),\n\t\t\t  xfs_btree_rec_offset(cur, last + 1) - 1);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_copy_recs",
          "args": [
            "cur",
            "rrp",
            "lrp",
            "rrecs"
          ],
          "line": 2436
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_copy_recs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1196-1205",
          "snippet": "STATIC void\nxfs_btree_copy_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*dst_rec,\n\tunion xfs_btree_rec\t*src_rec,\n\tint\t\t\tnumrecs)\n{\n\tASSERT(numrecs >= 0);\n\tmemcpy(dst_rec, src_rec, numrecs * cur->bc_ops->rec_len);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*dst_rec,\n\tunion xfs_btree_rec\t*src_rec,\n\tint\t\t\tnumrecs)\n{\n\tASSERT(numrecs >= 0);\n\tmemcpy(dst_rec, src_rec, numrecs * cur->bc_ops->rec_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_copy_keys",
          "args": [
            "cur",
            "key",
            "rkp",
            "1"
          ],
          "line": 2427
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_copy_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1182-1191",
          "snippet": "STATIC void\nxfs_btree_copy_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*dst_key,\n\tunion xfs_btree_key\t*src_key,\n\tint\t\t\tnumkeys)\n{\n\tASSERT(numkeys >= 0);\n\tmemcpy(dst_key, src_key, numkeys * cur->bc_ops->key_len);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*dst_key,\n\tunion xfs_btree_key\t*src_key,\n\tint\t\t\tnumkeys)\n{\n\tASSERT(numkeys >= 0);\n\tmemcpy(dst_key, src_key, numkeys * cur->bc_ops->key_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_ptrs",
          "args": [
            "cur",
            "rbp",
            "1",
            "rrecs"
          ],
          "line": 2424
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_ptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1328-1352",
          "snippet": "STATIC void\nxfs_btree_log_ptrs(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfirst,\t/* index of first pointer to log */\n\tint\t\t\tlast)\t/* index of last pointer to log */\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\t\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\txfs_btree_ptr_offset(cur, first, level),\n\t\t\t\txfs_btree_ptr_offset(cur, last + 1, level) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_log_ptrs(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfirst,\t/* index of first pointer to log */\n\tint\t\t\tlast)\t/* index of last pointer to log */\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\t\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\txfs_btree_ptr_offset(cur, first, level),\n\t\t\t\txfs_btree_ptr_offset(cur, last + 1, level) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_keys",
          "args": [
            "cur",
            "rbp",
            "1",
            "rrecs"
          ],
          "line": 2423
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1281-1302",
          "snippet": "STATIC void\nxfs_btree_log_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\t  xfs_btree_key_offset(cur, first),\n\t\t\t\t  xfs_btree_key_offset(cur, last + 1) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_log_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\t  xfs_btree_key_offset(cur, first),\n\t\t\t\t  xfs_btree_key_offset(cur, last + 1) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_copy_ptrs",
          "args": [
            "cur",
            "rpp",
            "lpp",
            "rrecs"
          ],
          "line": 2421
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_copy_ptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1210-1219",
          "snippet": "STATIC void\nxfs_btree_copy_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*dst_ptr,\n\tunion xfs_btree_ptr\t*src_ptr,\n\tint\t\t\tnumptrs)\n{\n\tASSERT(numptrs >= 0);\n\tmemcpy(dst_ptr, src_ptr, numptrs * xfs_btree_ptr_len(cur));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*dst_ptr,\n\tunion xfs_btree_ptr\t*src_ptr,\n\tint\t\t\tnumptrs)\n{\n\tASSERT(numptrs >= 0);\n\tmemcpy(dst_ptr, src_ptr, numptrs * xfs_btree_ptr_len(cur));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_check_ptr",
          "args": [
            "cur",
            "lpp",
            "i",
            "level"
          ],
          "line": 2414
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "201-215",
          "snippet": "STATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_ptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tunion xfs_btree_ptr\t*ptr,\t/* btree block disk address */\n\tint\t\t\tindex,\t/* offset from ptr to check */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\treturn xfs_btree_check_lptr(cur,\n\t\t\t\tbe64_to_cpu((&ptr->l)[index]), level);\n\t} else {\n\t\treturn xfs_btree_check_sptr(cur,\n\t\t\t\tbe32_to_cpu((&ptr->s)[index]), level);\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_ptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tunion xfs_btree_ptr\t*ptr,\t/* btree block disk address */\n\tint\t\t\tindex,\t/* offset from ptr to check */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\treturn xfs_btree_check_lptr(cur,\n\t\t\t\tbe64_to_cpu((&ptr->l)[index]), level);\n\t} else {\n\t\treturn xfs_btree_check_sptr(cur,\n\t\t\t\tbe32_to_cpu((&ptr->s)[index]), level);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_addr",
          "args": [
            "cur",
            "1",
            "right"
          ],
          "line": 2410
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "494-506",
          "snippet": "xfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_key_addr",
          "args": [
            "cur",
            "1",
            "right"
          ],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_key_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "481-489",
          "snippet": "xfs_btree_key *\nxfs_btree_key_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_key *)\n\t\t((char *)block + xfs_btree_key_offset(cur, n));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_key *\nxfs_btree_key_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_key *)\n\t\t((char *)block + xfs_btree_key_offset(cur, n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_ADD",
          "args": [
            "cur",
            "moves",
            "rrecs"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_init_block_cur",
          "args": [
            "cur",
            "rbp",
            "xfs_btree_get_level(left)",
            "0"
          ],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_init_block_cur",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1036-1059",
          "snippet": "STATIC void\nxfs_btree_init_block_cur(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tlevel,\n\tint\t\t\tnumrecs)\n{\n\t__u64 owner;\n\n\t/*\n\t * we can pull the owner from the cursor right now as the different\n\t * owners align directly with the pointer size of the btree. This may\n\t * change in future, but is safe for current users of the generic btree\n\t * code.\n\t */\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\towner = cur->bc_private.b.ip->i_ino;\n\telse\n\t\towner = cur->bc_private.a.agno;\n\n\txfs_btree_init_block_int(cur->bc_mp, XFS_BUF_TO_BLOCK(bp), bp->b_bn,\n\t\t\t\t xfs_btree_magic(cur), level, numrecs,\n\t\t\t\t owner, cur->bc_flags);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_init_block_cur(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tlevel,\n\tint\t\t\tnumrecs)\n{\n\t__u64 owner;\n\n\t/*\n\t * we can pull the owner from the cursor right now as the different\n\t * owners align directly with the pointer size of the btree. This may\n\t * change in future, but is safe for current users of the generic btree\n\t * code.\n\t */\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\towner = cur->bc_private.b.ip->i_ino;\n\telse\n\t\towner = cur->bc_private.a.agno;\n\n\txfs_btree_init_block_int(cur->bc_mp, XFS_BUF_TO_BLOCK(bp), bp->b_bn,\n\t\t\t\t xfs_btree_magic(cur), level, numrecs,\n\t\t\t\t owner, cur->bc_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_level",
          "args": [
            "left"
          ],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "427-430",
          "snippet": "static inline int xfs_btree_get_level(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_level);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_btree_get_level(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_buf_block",
          "args": [
            "cur",
            "&rptr",
            "0",
            "&right",
            "&rbp"
          ],
          "line": 2375
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_buf_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1122-1146",
          "snippet": "STATIC int\nxfs_btree_get_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\t*bpp = xfs_trans_get_buf(cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t mp->m_bsize, flags);\n\n\tif (!*bpp)\n\t\treturn -ENOMEM;\n\n\t(*bpp)->b_ops = cur->bc_ops->buf_ops;\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_get_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\t*bpp = xfs_trans_get_buf(cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t mp->m_bsize, flags);\n\n\tif (!*bpp)\n\t\treturn -ENOMEM;\n\n\t(*bpp)->b_ops = cur->bc_ops->buf_ops;\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_INC",
          "args": [
            "cur",
            "alloc"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->alloc_block",
          "args": [
            "cur",
            "&lptr",
            "&rptr",
            "stat"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_buf_to_ptr",
          "args": [
            "cur",
            "lbp",
            "&lptr"
          ],
          "line": 2364
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_buf_to_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1085-1098",
          "snippet": "STATIC void\nxfs_btree_buf_to_ptr(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\tptr->l = cpu_to_be64(XFS_DADDR_TO_FSB(cur->bc_mp,\n\t\t\t\t\tXFS_BUF_ADDR(bp)));\n\telse {\n\t\tptr->s = cpu_to_be32(xfs_daddr_to_agbno(cur->bc_mp,\n\t\t\t\t\tXFS_BUF_ADDR(bp)));\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_buf_to_ptr(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\tptr->l = cpu_to_be64(XFS_DADDR_TO_FSB(cur->bc_mp,\n\t\t\t\t\tXFS_BUF_ADDR(bp)));\n\telse {\n\t\tptr->s = cpu_to_be32(xfs_daddr_to_agbno(cur->bc_mp,\n\t\t\t\t\tXFS_BUF_ADDR(bp)));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_check_block",
          "args": [
            "cur",
            "left",
            "level",
            "lbp"
          ],
          "line": 2359
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "149-160",
          "snippet": "int\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_block",
          "args": [
            "cur",
            "level",
            "&lbp"
          ],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "528-542",
          "snippet": "xfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_INC",
          "args": [
            "cur",
            "split"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_ARGIPK",
          "args": [
            "cur",
            "level",
            "*ptrp",
            "key"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ENTRY"
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\t\t\t\t\t/* error */\n__xfs_btree_split(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tunion xfs_btree_ptr\t*ptrp,\n\tunion xfs_btree_key\t*key,\n\tstruct xfs_btree_cur\t**curp,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tunion xfs_btree_ptr\tlptr;\t\t/* left sibling block ptr */\n\tstruct xfs_buf\t\t*lbp;\t\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t\t/* left btree block */\n\tunion xfs_btree_ptr\trptr;\t\t/* right sibling block ptr */\n\tstruct xfs_buf\t\t*rbp;\t\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t\t/* right btree block */\n\tunion xfs_btree_ptr\trrptr;\t\t/* right-right sibling ptr */\n\tstruct xfs_buf\t\t*rrbp;\t\t/* right-right buffer pointer */\n\tstruct xfs_btree_block\t*rrblock;\t/* right-right btree block */\n\tint\t\t\tlrecs;\n\tint\t\t\trrecs;\n\tint\t\t\tsrc_index;\n\tint\t\t\terror;\t\t/* error return value */\n#ifdef DEBUG\n\tint\t\t\ti;\n#endif\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGIPK(cur, level, *ptrp, key);\n\n\tXFS_BTREE_STATS_INC(cur, split);\n\n\t/* Set up left block (current one). */\n\tleft = xfs_btree_get_block(cur, level, &lbp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, left, level, lbp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\txfs_btree_buf_to_ptr(cur, lbp, &lptr);\n\n\t/* Allocate the new block. If we can't do it, we're toast. Give up. */\n\terror = cur->bc_ops->alloc_block(cur, &lptr, &rptr, stat);\n\tif (error)\n\t\tgoto error0;\n\tif (*stat == 0)\n\t\tgoto out0;\n\tXFS_BTREE_STATS_INC(cur, alloc);\n\n\t/* Set up the new block as \"right\". */\n\terror = xfs_btree_get_buf_block(cur, &rptr, 0, &right, &rbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* Fill in the btree header for the new right block. */\n\txfs_btree_init_block_cur(cur, rbp, xfs_btree_get_level(left), 0);\n\n\t/*\n\t * Split the entries between the old and the new block evenly.\n\t * Make sure that if there's an odd number of entries now, that\n\t * each new block will have the same number of entries.\n\t */\n\tlrecs = xfs_btree_get_numrecs(left);\n\trrecs = lrecs / 2;\n\tif ((lrecs & 1) && cur->bc_ptrs[level] <= rrecs + 1)\n\t\trrecs++;\n\tsrc_index = (lrecs - rrecs + 1);\n\n\tXFS_BTREE_STATS_ADD(cur, moves, rrecs);\n\n\t/*\n\t * Copy btree block entries from the left block over to the\n\t * new block, the right. Update the right block and log the\n\t * changes.\n\t */\n\tif (level > 0) {\n\t\t/* It's a non-leaf.  Move keys and pointers. */\n\t\tunion xfs_btree_key\t*lkp;\t/* left btree key */\n\t\tunion xfs_btree_ptr\t*lpp;\t/* left address pointer */\n\t\tunion xfs_btree_key\t*rkp;\t/* right btree key */\n\t\tunion xfs_btree_ptr\t*rpp;\t/* right address pointer */\n\n\t\tlkp = xfs_btree_key_addr(cur, src_index, left);\n\t\tlpp = xfs_btree_ptr_addr(cur, src_index, left);\n\t\trkp = xfs_btree_key_addr(cur, 1, right);\n\t\trpp = xfs_btree_ptr_addr(cur, 1, right);\n\n#ifdef DEBUG\n\t\tfor (i = src_index; i < rrecs; i++) {\n\t\t\terror = xfs_btree_check_ptr(cur, lpp, i, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\n\t\txfs_btree_copy_keys(cur, rkp, lkp, rrecs);\n\t\txfs_btree_copy_ptrs(cur, rpp, lpp, rrecs);\n\n\t\txfs_btree_log_keys(cur, rbp, 1, rrecs);\n\t\txfs_btree_log_ptrs(cur, rbp, 1, rrecs);\n\n\t\t/* Grab the keys to the entries moved to the right block */\n\t\txfs_btree_copy_keys(cur, key, rkp, 1);\n\t} else {\n\t\t/* It's a leaf.  Move records.  */\n\t\tunion xfs_btree_rec\t*lrp;\t/* left record pointer */\n\t\tunion xfs_btree_rec\t*rrp;\t/* right record pointer */\n\n\t\tlrp = xfs_btree_rec_addr(cur, src_index, left);\n\t\trrp = xfs_btree_rec_addr(cur, 1, right);\n\n\t\txfs_btree_copy_recs(cur, rrp, lrp, rrecs);\n\t\txfs_btree_log_recs(cur, rbp, 1, rrecs);\n\n\t\tcur->bc_ops->init_key_from_rec(key,\n\t\t\txfs_btree_rec_addr(cur, 1, right));\n\t}\n\n\n\t/*\n\t * Find the left block number by looking in the buffer.\n\t * Adjust numrecs, sibling pointers.\n\t */\n\txfs_btree_get_sibling(cur, left, &rrptr, XFS_BB_RIGHTSIB);\n\txfs_btree_set_sibling(cur, right, &rrptr, XFS_BB_RIGHTSIB);\n\txfs_btree_set_sibling(cur, right, &lptr, XFS_BB_LEFTSIB);\n\txfs_btree_set_sibling(cur, left, &rptr, XFS_BB_RIGHTSIB);\n\n\tlrecs -= rrecs;\n\txfs_btree_set_numrecs(left, lrecs);\n\txfs_btree_set_numrecs(right, xfs_btree_get_numrecs(right) + rrecs);\n\n\txfs_btree_log_block(cur, rbp, XFS_BB_ALL_BITS);\n\txfs_btree_log_block(cur, lbp, XFS_BB_NUMRECS | XFS_BB_RIGHTSIB);\n\n\t/*\n\t * If there's a block to the new block's right, make that block\n\t * point back to right instead of to left.\n\t */\n\tif (!xfs_btree_ptr_is_null(cur, &rrptr)) {\n\t\terror = xfs_btree_read_buf_block(cur, &rrptr,\n\t\t\t\t\t\t\t0, &rrblock, &rrbp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_set_sibling(cur, rrblock, &rptr, XFS_BB_LEFTSIB);\n\t\txfs_btree_log_block(cur, rrbp, XFS_BB_LEFTSIB);\n\t}\n\t/*\n\t * If the cursor is really in the right block, move it there.\n\t * If it's just pointing past the last entry in left, then we'll\n\t * insert there, so don't change anything in that case.\n\t */\n\tif (cur->bc_ptrs[level] > lrecs + 1) {\n\t\txfs_btree_setbuf(cur, level, rbp);\n\t\tcur->bc_ptrs[level] -= lrecs;\n\t}\n\t/*\n\t * If there are more levels, we'll need another cursor which refers\n\t * the right block, no matter where this cursor was.\n\t */\n\tif (level + 1 < cur->bc_nlevels) {\n\t\terror = xfs_btree_dup_cursor(cur, curp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\t(*curp)->bc_ptrs[level + 1]++;\n\t}\n\t*ptrp = rptr;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_btree_rshift",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "2148-2317",
    "snippet": "STATIC int\t\t\t\t\t/* error */\nxfs_btree_rshift(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tunion xfs_btree_key\tkey;\t\t/* btree key */\n\tstruct xfs_buf\t\t*lbp;\t\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t\t/* left btree block */\n\tstruct xfs_buf\t\t*rbp;\t\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t\t/* right btree block */\n\tstruct xfs_btree_cur\t*tcur;\t\t/* temporary btree cursor */\n\tunion xfs_btree_ptr\trptr;\t\t/* right block pointer */\n\tunion xfs_btree_key\t*rkp;\t\t/* right btree key */\n\tint\t\t\trrecs;\t\t/* right record count */\n\tint\t\t\tlrecs;\t\t/* left record count */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* loop counter */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1))\n\t\tgoto out0;\n\n\t/* Set up variables for this block as \"left\". */\n\tleft = xfs_btree_get_block(cur, level, &lbp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, left, level, lbp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* If we've got no right sibling then we can't shift an entry right. */\n\txfs_btree_get_sibling(cur, left, &rptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &rptr))\n\t\tgoto out0;\n\n\t/*\n\t * If the cursor entry is the one that would be moved, don't\n\t * do it... it's too complicated.\n\t */\n\tlrecs = xfs_btree_get_numrecs(left);\n\tif (cur->bc_ptrs[level] >= lrecs)\n\t\tgoto out0;\n\n\t/* Set up the right neighbor as \"right\". */\n\terror = xfs_btree_read_buf_block(cur, &rptr, 0, &right, &rbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* If it's full, it can't take another entry. */\n\trrecs = xfs_btree_get_numrecs(right);\n\tif (rrecs == cur->bc_ops->get_maxrecs(cur, level))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, rshift);\n\tXFS_BTREE_STATS_ADD(cur, moves, rrecs);\n\n\t/*\n\t * Make a hole at the start of the right neighbor block, then\n\t * copy the last left block entry to the hole.\n\t */\n\tif (level > 0) {\n\t\t/* It's a nonleaf. make a hole in the keys and ptrs */\n\t\tunion xfs_btree_key\t*lkp;\n\t\tunion xfs_btree_ptr\t*lpp;\n\t\tunion xfs_btree_ptr\t*rpp;\n\n\t\tlkp = xfs_btree_key_addr(cur, lrecs, left);\n\t\tlpp = xfs_btree_ptr_addr(cur, lrecs, left);\n\t\trkp = xfs_btree_key_addr(cur, 1, right);\n\t\trpp = xfs_btree_ptr_addr(cur, 1, right);\n\n#ifdef DEBUG\n\t\tfor (i = rrecs - 1; i >= 0; i--) {\n\t\t\terror = xfs_btree_check_ptr(cur, rpp, i, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\n\t\txfs_btree_shift_keys(cur, rkp, 1, rrecs);\n\t\txfs_btree_shift_ptrs(cur, rpp, 1, rrecs);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_ptr(cur, lpp, 0, level);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\t/* Now put the new data in, and log it. */\n\t\txfs_btree_copy_keys(cur, rkp, lkp, 1);\n\t\txfs_btree_copy_ptrs(cur, rpp, lpp, 1);\n\n\t\txfs_btree_log_keys(cur, rbp, 1, rrecs + 1);\n\t\txfs_btree_log_ptrs(cur, rbp, 1, rrecs + 1);\n\n\t\tASSERT(cur->bc_ops->keys_inorder(cur, rkp,\n\t\t\txfs_btree_key_addr(cur, 2, right)));\n\t} else {\n\t\t/* It's a leaf. make a hole in the records */\n\t\tunion xfs_btree_rec\t*lrp;\n\t\tunion xfs_btree_rec\t*rrp;\n\n\t\tlrp = xfs_btree_rec_addr(cur, lrecs, left);\n\t\trrp = xfs_btree_rec_addr(cur, 1, right);\n\n\t\txfs_btree_shift_recs(cur, rrp, 1, rrecs);\n\n\t\t/* Now put the new data in, and log it. */\n\t\txfs_btree_copy_recs(cur, rrp, lrp, 1);\n\t\txfs_btree_log_recs(cur, rbp, 1, rrecs + 1);\n\n\t\tcur->bc_ops->init_key_from_rec(&key, rrp);\n\t\trkp = &key;\n\n\t\tASSERT(cur->bc_ops->recs_inorder(cur, rrp,\n\t\t\txfs_btree_rec_addr(cur, 2, right)));\n\t}\n\n\t/*\n\t * Decrement and log left's numrecs, bump and log right's numrecs.\n\t */\n\txfs_btree_set_numrecs(left, --lrecs);\n\txfs_btree_log_block(cur, lbp, XFS_BB_NUMRECS);\n\n\txfs_btree_set_numrecs(right, ++rrecs);\n\txfs_btree_log_block(cur, rbp, XFS_BB_NUMRECS);\n\n\t/*\n\t * Using a temporary cursor, update the parent key values of the\n\t * block on the right.\n\t */\n\terror = xfs_btree_dup_cursor(cur, &tcur);\n\tif (error)\n\t\tgoto error0;\n\ti = xfs_btree_lastrec(tcur, level);\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\terror = xfs_btree_increment(tcur, level, &i);\n\tif (error)\n\t\tgoto error1;\n\n\terror = xfs_btree_updkey(tcur, rkp, level + 1);\n\tif (error)\n\t\tgoto error1;\n\n\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n\nerror1:\n\tXFS_BTREE_TRACE_CURSOR(tcur, XBT_ERROR);\n\txfs_btree_del_cursor(tcur, XFS_BTREE_ERROR);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "tcur",
            "XFS_BTREE_ERROR"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "tcur",
            "XBT_ERROR"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ERROR"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_updkey",
          "args": [
            "tcur",
            "rkp",
            "level + 1"
          ],
          "line": 2294
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_updkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1855-1897",
          "snippet": "STATIC int\nxfs_btree_updkey(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*keyp,\n\tint\t\t\tlevel)\n{\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_buf\t\t*bp;\n\tunion xfs_btree_key\t*kp;\n\tint\t\t\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGIK(cur, level, keyp);\n\n\tASSERT(!(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) || level >= 1);\n\n\t/*\n\t * Go up the tree from this level toward the root.\n\t * At each level, update the key value to the value input.\n\t * Stop when we reach a level where the cursor isn't pointing\n\t * at the first entry in the block.\n\t */\n\tfor (ptr = 1; ptr == 1 && level < cur->bc_nlevels; level++) {\n#ifdef DEBUG\n\t\tint\t\terror;\n#endif\n\t\tblock = xfs_btree_get_block(cur, level, &bp);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, level, bp);\n\t\tif (error) {\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\t\t\treturn error;\n\t\t}\n#endif\n\t\tptr = cur->bc_ptrs[level];\n\t\tkp = xfs_btree_key_addr(cur, ptr, block);\n\t\txfs_btree_copy_keys(cur, kp, keyp, 1);\n\t\txfs_btree_log_keys(cur, bp, ptr, ptr);\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_updkey(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*keyp,\n\tint\t\t\tlevel)\n{\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_buf\t\t*bp;\n\tunion xfs_btree_key\t*kp;\n\tint\t\t\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGIK(cur, level, keyp);\n\n\tASSERT(!(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) || level >= 1);\n\n\t/*\n\t * Go up the tree from this level toward the root.\n\t * At each level, update the key value to the value input.\n\t * Stop when we reach a level where the cursor isn't pointing\n\t * at the first entry in the block.\n\t */\n\tfor (ptr = 1; ptr == 1 && level < cur->bc_nlevels; level++) {\n#ifdef DEBUG\n\t\tint\t\terror;\n#endif\n\t\tblock = xfs_btree_get_block(cur, level, &bp);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, level, bp);\n\t\tif (error) {\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\t\t\treturn error;\n\t\t}\n#endif\n\t\tptr = cur->bc_ptrs[level];\n\t\tkp = xfs_btree_key_addr(cur, ptr, block);\n\t\txfs_btree_copy_keys(cur, kp, keyp, 1);\n\t\txfs_btree_log_keys(cur, bp, ptr, ptr);\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_increment",
          "args": [
            "tcur",
            "level",
            "&i"
          ],
          "line": 2290
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1431-1533",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "error0"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_lastrec",
          "args": [
            "tcur",
            "level"
          ],
          "line": 2287
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_lastrec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "634-657",
          "snippet": "STATIC int\t\t\t\t/* success=1, failure=0 */\nxfs_btree_lastrec(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel)\t/* level to change */\n{\n\tstruct xfs_btree_block\t*block;\t/* generic btree block pointer */\n\txfs_buf_t\t\t*bp;\t/* buffer containing block */\n\n\t/*\n\t * Get the block pointer for this level.\n\t */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\txfs_btree_check_block(cur, block, level, bp);\n\t/*\n\t * It's empty, there is no such record.\n\t */\n\tif (!block->bb_numrecs)\n\t\treturn 0;\n\t/*\n\t * Set the ptr value to numrecs, that's the last record/key.\n\t */\n\tcur->bc_ptrs[level] = be16_to_cpu(block->bb_numrecs);\n\treturn 1;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\t\t\t\t/* success=1, failure=0 */\nxfs_btree_lastrec(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel)\t/* level to change */\n{\n\tstruct xfs_btree_block\t*block;\t/* generic btree block pointer */\n\txfs_buf_t\t\t*bp;\t/* buffer containing block */\n\n\t/*\n\t * Get the block pointer for this level.\n\t */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\txfs_btree_check_block(cur, block, level, bp);\n\t/*\n\t * It's empty, there is no such record.\n\t */\n\tif (!block->bb_numrecs)\n\t\treturn 0;\n\t/*\n\t * Set the ptr value to numrecs, that's the last record/key.\n\t */\n\tcur->bc_ptrs[level] = be16_to_cpu(block->bb_numrecs);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_dup_cursor",
          "args": [
            "cur",
            "&tcur"
          ],
          "line": 2284
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_dup_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "324-371",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_dup_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* input cursor */\n\txfs_btree_cur_t\t**ncur)\t\t/* output cursor */\n{\n\txfs_buf_t\t*bp;\t\t/* btree block's buffer pointer */\n\tint\t\terror;\t\t/* error return value */\n\tint\t\ti;\t\t/* level number of btree block */\n\txfs_mount_t\t*mp;\t\t/* mount structure for filesystem */\n\txfs_btree_cur_t\t*new;\t\t/* new cursor value */\n\txfs_trans_t\t*tp;\t\t/* transaction pointer, can be NULL */\n\n\ttp = cur->bc_tp;\n\tmp = cur->bc_mp;\n\n\t/*\n\t * Allocate a new cursor like the old one.\n\t */\n\tnew = cur->bc_ops->dup_cursor(cur);\n\n\t/*\n\t * Copy the record currently in the cursor.\n\t */\n\tnew->bc_rec = cur->bc_rec;\n\n\t/*\n\t * For each level current, re-get the buffer and copy the ptr value.\n\t */\n\tfor (i = 0; i < new->bc_nlevels; i++) {\n\t\tnew->bc_ptrs[i] = cur->bc_ptrs[i];\n\t\tnew->bc_ra[i] = cur->bc_ra[i];\n\t\tbp = cur->bc_bufs[i];\n\t\tif (bp) {\n\t\t\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t\t\t   XFS_BUF_ADDR(bp), mp->m_bsize,\n\t\t\t\t\t\t   0, &bp,\n\t\t\t\t\t\t   cur->bc_ops->buf_ops);\n\t\t\tif (error) {\n\t\t\t\txfs_btree_del_cursor(new, error);\n\t\t\t\t*ncur = NULL;\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tnew->bc_bufs[i] = bp;\n\t}\n\t*ncur = new;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_btree_dup_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* input cursor */\n\txfs_btree_cur_t\t**ncur)\t\t/* output cursor */\n{\n\txfs_buf_t\t*bp;\t\t/* btree block's buffer pointer */\n\tint\t\terror;\t\t/* error return value */\n\tint\t\ti;\t\t/* level number of btree block */\n\txfs_mount_t\t*mp;\t\t/* mount structure for filesystem */\n\txfs_btree_cur_t\t*new;\t\t/* new cursor value */\n\txfs_trans_t\t*tp;\t\t/* transaction pointer, can be NULL */\n\n\ttp = cur->bc_tp;\n\tmp = cur->bc_mp;\n\n\t/*\n\t * Allocate a new cursor like the old one.\n\t */\n\tnew = cur->bc_ops->dup_cursor(cur);\n\n\t/*\n\t * Copy the record currently in the cursor.\n\t */\n\tnew->bc_rec = cur->bc_rec;\n\n\t/*\n\t * For each level current, re-get the buffer and copy the ptr value.\n\t */\n\tfor (i = 0; i < new->bc_nlevels; i++) {\n\t\tnew->bc_ptrs[i] = cur->bc_ptrs[i];\n\t\tnew->bc_ra[i] = cur->bc_ra[i];\n\t\tbp = cur->bc_bufs[i];\n\t\tif (bp) {\n\t\t\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t\t\t   XFS_BUF_ADDR(bp), mp->m_bsize,\n\t\t\t\t\t\t   0, &bp,\n\t\t\t\t\t\t   cur->bc_ops->buf_ops);\n\t\t\tif (error) {\n\t\t\t\txfs_btree_del_cursor(new, error);\n\t\t\t\t*ncur = NULL;\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tnew->bc_bufs[i] = bp;\n\t}\n\t*ncur = new;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_block",
          "args": [
            "cur",
            "rbp",
            "XFS_BB_NUMRECS"
          ],
          "line": 2278
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1357-1425",
          "snippet": "void\nxfs_btree_log_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfields)\t/* mask of fields: XFS_BB_... */\n{\n\tint\t\t\tfirst;\t/* first byte offset logged */\n\tint\t\t\tlast;\t/* last byte offset logged */\n\tstatic const short\tsoffsets[] = {\t/* table of offsets (short) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_crc),\n\t\tXFS_BTREE_SBLOCK_CRC_LEN\n\t};\n\tstatic const short\tloffsets[] = {\t/* table of offsets (long) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_crc),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_pad),\n\t\tXFS_BTREE_LBLOCK_CRC_LEN\n\t};\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBI(cur, bp, fields);\n\n\tif (bp) {\n\t\tint nbits;\n\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\t/*\n\t\t\t * We don't log the CRC when updating a btree\n\t\t\t * block but instead recreate it during log\n\t\t\t * recovery.  As the log buffers have checksums\n\t\t\t * of their own this is safe and avoids logging a crc\n\t\t\t * update in a lot of places.\n\t\t\t */\n\t\t\tif (fields == XFS_BB_ALL_BITS)\n\t\t\t\tfields = XFS_BB_ALL_BITS_CRC;\n\t\t\tnbits = XFS_BB_NUM_BITS_CRC;\n\t\t} else {\n\t\t\tnbits = XFS_BB_NUM_BITS;\n\t\t}\n\t\txfs_btree_offsets(fields,\n\t\t\t\t  (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\t\t\t\tloffsets : soffsets,\n\t\t\t\t  nbits, &first, &last);\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp, first, last);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_log_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfields)\t/* mask of fields: XFS_BB_... */\n{\n\tint\t\t\tfirst;\t/* first byte offset logged */\n\tint\t\t\tlast;\t/* last byte offset logged */\n\tstatic const short\tsoffsets[] = {\t/* table of offsets (short) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_crc),\n\t\tXFS_BTREE_SBLOCK_CRC_LEN\n\t};\n\tstatic const short\tloffsets[] = {\t/* table of offsets (long) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_crc),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_pad),\n\t\tXFS_BTREE_LBLOCK_CRC_LEN\n\t};\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBI(cur, bp, fields);\n\n\tif (bp) {\n\t\tint nbits;\n\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\t/*\n\t\t\t * We don't log the CRC when updating a btree\n\t\t\t * block but instead recreate it during log\n\t\t\t * recovery.  As the log buffers have checksums\n\t\t\t * of their own this is safe and avoids logging a crc\n\t\t\t * update in a lot of places.\n\t\t\t */\n\t\t\tif (fields == XFS_BB_ALL_BITS)\n\t\t\t\tfields = XFS_BB_ALL_BITS_CRC;\n\t\t\tnbits = XFS_BB_NUM_BITS_CRC;\n\t\t} else {\n\t\t\tnbits = XFS_BB_NUM_BITS;\n\t\t}\n\t\txfs_btree_offsets(fields,\n\t\t\t\t  (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\t\t\t\tloffsets : soffsets,\n\t\t\t\t  nbits, &first, &last);\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp, first, last);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_set_numrecs",
          "args": [
            "right",
            "++rrecs"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_set_numrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "421-425",
          "snippet": "static inline void xfs_btree_set_numrecs(struct xfs_btree_block *block,\n\t\t__uint16_t numrecs)\n{\n\tblock->bb_numrecs = cpu_to_be16(numrecs);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_btree_set_numrecs(struct xfs_btree_block *block,\n\t\t__uint16_t numrecs)\n{\n\tblock->bb_numrecs = cpu_to_be16(numrecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cur->bc_ops->recs_inorder(cur, rrp,\n\t\t\txfs_btree_rec_addr(cur, 2, right))"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->recs_inorder",
          "args": [
            "cur",
            "rrp",
            "xfs_btree_rec_addr(cur, 2, right)"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_rec_addr",
          "args": [
            "cur",
            "2",
            "right"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_rec_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "468-476",
          "snippet": "xfs_btree_rec *\nxfs_btree_rec_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_rec *)\n\t\t((char *)block + xfs_btree_rec_offset(cur, n));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_rec *\nxfs_btree_rec_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_rec *)\n\t\t((char *)block + xfs_btree_rec_offset(cur, n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->init_key_from_rec",
          "args": [
            "&key",
            "rrp"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_recs",
          "args": [
            "cur",
            "rbp",
            "1",
            "rrecs + 1"
          ],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_recs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1307-1323",
          "snippet": "void\nxfs_btree_log_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t  xfs_btree_rec_offset(cur, first),\n\t\t\t  xfs_btree_rec_offset(cur, last + 1) - 1);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_log_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t  xfs_btree_rec_offset(cur, first),\n\t\t\t  xfs_btree_rec_offset(cur, last + 1) - 1);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_copy_recs",
          "args": [
            "cur",
            "rrp",
            "lrp",
            "1"
          ],
          "line": 2261
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_copy_recs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1196-1205",
          "snippet": "STATIC void\nxfs_btree_copy_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*dst_rec,\n\tunion xfs_btree_rec\t*src_rec,\n\tint\t\t\tnumrecs)\n{\n\tASSERT(numrecs >= 0);\n\tmemcpy(dst_rec, src_rec, numrecs * cur->bc_ops->rec_len);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*dst_rec,\n\tunion xfs_btree_rec\t*src_rec,\n\tint\t\t\tnumrecs)\n{\n\tASSERT(numrecs >= 0);\n\tmemcpy(dst_rec, src_rec, numrecs * cur->bc_ops->rec_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_shift_recs",
          "args": [
            "cur",
            "rrp",
            "1",
            "rrecs"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_shift_recs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1243-1257",
          "snippet": "STATIC void\nxfs_btree_shift_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*rec,\n\tint\t\t\tdir,\n\tint\t\t\tnumrecs)\n{\n\tchar\t\t\t*dst_rec;\n\n\tASSERT(numrecs >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_rec = (char *)rec + (dir * cur->bc_ops->rec_len);\n\tmemmove(dst_rec, rec, numrecs * cur->bc_ops->rec_len);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_shift_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*rec,\n\tint\t\t\tdir,\n\tint\t\t\tnumrecs)\n{\n\tchar\t\t\t*dst_rec;\n\n\tASSERT(numrecs >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_rec = (char *)rec + (dir * cur->bc_ops->rec_len);\n\tmemmove(dst_rec, rec, numrecs * cur->bc_ops->rec_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cur->bc_ops->keys_inorder(cur, rkp,\n\t\t\txfs_btree_key_addr(cur, 2, right))"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->keys_inorder",
          "args": [
            "cur",
            "rkp",
            "xfs_btree_key_addr(cur, 2, right)"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_key_addr",
          "args": [
            "cur",
            "2",
            "right"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_key_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "481-489",
          "snippet": "xfs_btree_key *\nxfs_btree_key_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_key *)\n\t\t((char *)block + xfs_btree_key_offset(cur, n));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_key *\nxfs_btree_key_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_key *)\n\t\t((char *)block + xfs_btree_key_offset(cur, n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_ptrs",
          "args": [
            "cur",
            "rbp",
            "1",
            "rrecs + 1"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_ptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1328-1352",
          "snippet": "STATIC void\nxfs_btree_log_ptrs(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfirst,\t/* index of first pointer to log */\n\tint\t\t\tlast)\t/* index of last pointer to log */\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\t\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\txfs_btree_ptr_offset(cur, first, level),\n\t\t\t\txfs_btree_ptr_offset(cur, last + 1, level) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_log_ptrs(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfirst,\t/* index of first pointer to log */\n\tint\t\t\tlast)\t/* index of last pointer to log */\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\t\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\txfs_btree_ptr_offset(cur, first, level),\n\t\t\t\txfs_btree_ptr_offset(cur, last + 1, level) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_keys",
          "args": [
            "cur",
            "rbp",
            "1",
            "rrecs + 1"
          ],
          "line": 2245
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1281-1302",
          "snippet": "STATIC void\nxfs_btree_log_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\t  xfs_btree_key_offset(cur, first),\n\t\t\t\t  xfs_btree_key_offset(cur, last + 1) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_log_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\t  xfs_btree_key_offset(cur, first),\n\t\t\t\t  xfs_btree_key_offset(cur, last + 1) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_copy_ptrs",
          "args": [
            "cur",
            "rpp",
            "lpp",
            "1"
          ],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_copy_ptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1210-1219",
          "snippet": "STATIC void\nxfs_btree_copy_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*dst_ptr,\n\tunion xfs_btree_ptr\t*src_ptr,\n\tint\t\t\tnumptrs)\n{\n\tASSERT(numptrs >= 0);\n\tmemcpy(dst_ptr, src_ptr, numptrs * xfs_btree_ptr_len(cur));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*dst_ptr,\n\tunion xfs_btree_ptr\t*src_ptr,\n\tint\t\t\tnumptrs)\n{\n\tASSERT(numptrs >= 0);\n\tmemcpy(dst_ptr, src_ptr, numptrs * xfs_btree_ptr_len(cur));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_copy_keys",
          "args": [
            "cur",
            "rkp",
            "lkp",
            "1"
          ],
          "line": 2242
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_copy_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1182-1191",
          "snippet": "STATIC void\nxfs_btree_copy_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*dst_key,\n\tunion xfs_btree_key\t*src_key,\n\tint\t\t\tnumkeys)\n{\n\tASSERT(numkeys >= 0);\n\tmemcpy(dst_key, src_key, numkeys * cur->bc_ops->key_len);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*dst_key,\n\tunion xfs_btree_key\t*src_key,\n\tint\t\t\tnumkeys)\n{\n\tASSERT(numkeys >= 0);\n\tmemcpy(dst_key, src_key, numkeys * cur->bc_ops->key_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_check_ptr",
          "args": [
            "cur",
            "lpp",
            "0",
            "level"
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "201-215",
          "snippet": "STATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_ptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tunion xfs_btree_ptr\t*ptr,\t/* btree block disk address */\n\tint\t\t\tindex,\t/* offset from ptr to check */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\treturn xfs_btree_check_lptr(cur,\n\t\t\t\tbe64_to_cpu((&ptr->l)[index]), level);\n\t} else {\n\t\treturn xfs_btree_check_sptr(cur,\n\t\t\t\tbe32_to_cpu((&ptr->s)[index]), level);\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_ptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tunion xfs_btree_ptr\t*ptr,\t/* btree block disk address */\n\tint\t\t\tindex,\t/* offset from ptr to check */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\treturn xfs_btree_check_lptr(cur,\n\t\t\t\tbe64_to_cpu((&ptr->l)[index]), level);\n\t} else {\n\t\treturn xfs_btree_check_sptr(cur,\n\t\t\t\tbe32_to_cpu((&ptr->s)[index]), level);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_shift_ptrs",
          "args": [
            "cur",
            "rpp",
            "1",
            "rrecs"
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_shift_ptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1262-1276",
          "snippet": "STATIC void\nxfs_btree_shift_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tdir,\n\tint\t\t\tnumptrs)\n{\n\tchar\t\t\t*dst_ptr;\n\n\tASSERT(numptrs >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_ptr = (char *)ptr + (dir * xfs_btree_ptr_len(cur));\n\tmemmove(dst_ptr, ptr, numptrs * xfs_btree_ptr_len(cur));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_shift_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tdir,\n\tint\t\t\tnumptrs)\n{\n\tchar\t\t\t*dst_ptr;\n\n\tASSERT(numptrs >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_ptr = (char *)ptr + (dir * xfs_btree_ptr_len(cur));\n\tmemmove(dst_ptr, ptr, numptrs * xfs_btree_ptr_len(cur));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_shift_keys",
          "args": [
            "cur",
            "rkp",
            "1",
            "rrecs"
          ],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_shift_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1224-1238",
          "snippet": "STATIC void\nxfs_btree_shift_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*key,\n\tint\t\t\tdir,\n\tint\t\t\tnumkeys)\n{\n\tchar\t\t\t*dst_key;\n\n\tASSERT(numkeys >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_key = (char *)key + (dir * cur->bc_ops->key_len);\n\tmemmove(dst_key, key, numkeys * cur->bc_ops->key_len);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_shift_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*key,\n\tint\t\t\tdir,\n\tint\t\t\tnumkeys)\n{\n\tchar\t\t\t*dst_key;\n\n\tASSERT(numkeys >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_key = (char *)key + (dir * cur->bc_ops->key_len);\n\tmemmove(dst_key, key, numkeys * cur->bc_ops->key_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_addr",
          "args": [
            "cur",
            "1",
            "right"
          ],
          "line": 2222
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "494-506",
          "snippet": "xfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_ADD",
          "args": [
            "cur",
            "moves",
            "rrecs"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_INC",
          "args": [
            "cur",
            "rshift"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->get_maxrecs",
          "args": [
            "cur",
            "level"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_numrecs",
          "args": [
            "right"
          ],
          "line": 2202
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_numrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "416-419",
          "snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_read_buf_block",
          "args": [
            "cur",
            "&rptr",
            "0",
            "&right",
            "&rbp"
          ],
          "line": 2197
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_read_buf_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1152-1177",
          "snippet": "STATIC int\nxfs_btree_read_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\tint\t\t\terror;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\terror = xfs_trans_read_buf(mp, cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, flags, bpp,\n\t\t\t\t   cur->bc_ops->buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_set_refs(cur, *bpp);\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_read_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\tint\t\t\terror;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\terror = xfs_trans_read_buf(mp, cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, flags, bpp,\n\t\t\t\t   cur->bc_ops->buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_set_refs(cur, *bpp);\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_is_null",
          "args": [
            "cur",
            "&rptr"
          ],
          "line": 2185
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_is_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "913-922",
          "snippet": "STATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_sibling",
          "args": [
            "cur",
            "left",
            "&rptr",
            "XFS_BB_RIGHTSIB"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_sibling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "938-958",
          "snippet": "STATIC void\nxfs_btree_get_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->l = block->bb_u.l.bb_rightsib;\n\t\telse\n\t\t\tptr->l = block->bb_u.l.bb_leftsib;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->s = block->bb_u.s.bb_rightsib;\n\t\telse\n\t\t\tptr->s = block->bb_u.s.bb_leftsib;\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_get_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->l = block->bb_u.l.bb_rightsib;\n\t\telse\n\t\t\tptr->l = block->bb_u.l.bb_leftsib;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->s = block->bb_u.s.bb_rightsib;\n\t\telse\n\t\t\tptr->s = block->bb_u.s.bb_leftsib;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_check_block",
          "args": [
            "cur",
            "left",
            "level",
            "lbp"
          ],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "149-160",
          "snippet": "int\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_block",
          "args": [
            "cur",
            "level",
            "&lbp"
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "528-542",
          "snippet": "xfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_ARGI",
          "args": [
            "cur",
            "level"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ENTRY"
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\t\t\t\t\t/* error */\nxfs_btree_rshift(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tunion xfs_btree_key\tkey;\t\t/* btree key */\n\tstruct xfs_buf\t\t*lbp;\t\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t\t/* left btree block */\n\tstruct xfs_buf\t\t*rbp;\t\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t\t/* right btree block */\n\tstruct xfs_btree_cur\t*tcur;\t\t/* temporary btree cursor */\n\tunion xfs_btree_ptr\trptr;\t\t/* right block pointer */\n\tunion xfs_btree_key\t*rkp;\t\t/* right btree key */\n\tint\t\t\trrecs;\t\t/* right record count */\n\tint\t\t\tlrecs;\t\t/* left record count */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* loop counter */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1))\n\t\tgoto out0;\n\n\t/* Set up variables for this block as \"left\". */\n\tleft = xfs_btree_get_block(cur, level, &lbp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, left, level, lbp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* If we've got no right sibling then we can't shift an entry right. */\n\txfs_btree_get_sibling(cur, left, &rptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &rptr))\n\t\tgoto out0;\n\n\t/*\n\t * If the cursor entry is the one that would be moved, don't\n\t * do it... it's too complicated.\n\t */\n\tlrecs = xfs_btree_get_numrecs(left);\n\tif (cur->bc_ptrs[level] >= lrecs)\n\t\tgoto out0;\n\n\t/* Set up the right neighbor as \"right\". */\n\terror = xfs_btree_read_buf_block(cur, &rptr, 0, &right, &rbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* If it's full, it can't take another entry. */\n\trrecs = xfs_btree_get_numrecs(right);\n\tif (rrecs == cur->bc_ops->get_maxrecs(cur, level))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, rshift);\n\tXFS_BTREE_STATS_ADD(cur, moves, rrecs);\n\n\t/*\n\t * Make a hole at the start of the right neighbor block, then\n\t * copy the last left block entry to the hole.\n\t */\n\tif (level > 0) {\n\t\t/* It's a nonleaf. make a hole in the keys and ptrs */\n\t\tunion xfs_btree_key\t*lkp;\n\t\tunion xfs_btree_ptr\t*lpp;\n\t\tunion xfs_btree_ptr\t*rpp;\n\n\t\tlkp = xfs_btree_key_addr(cur, lrecs, left);\n\t\tlpp = xfs_btree_ptr_addr(cur, lrecs, left);\n\t\trkp = xfs_btree_key_addr(cur, 1, right);\n\t\trpp = xfs_btree_ptr_addr(cur, 1, right);\n\n#ifdef DEBUG\n\t\tfor (i = rrecs - 1; i >= 0; i--) {\n\t\t\terror = xfs_btree_check_ptr(cur, rpp, i, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\n\t\txfs_btree_shift_keys(cur, rkp, 1, rrecs);\n\t\txfs_btree_shift_ptrs(cur, rpp, 1, rrecs);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_ptr(cur, lpp, 0, level);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\t/* Now put the new data in, and log it. */\n\t\txfs_btree_copy_keys(cur, rkp, lkp, 1);\n\t\txfs_btree_copy_ptrs(cur, rpp, lpp, 1);\n\n\t\txfs_btree_log_keys(cur, rbp, 1, rrecs + 1);\n\t\txfs_btree_log_ptrs(cur, rbp, 1, rrecs + 1);\n\n\t\tASSERT(cur->bc_ops->keys_inorder(cur, rkp,\n\t\t\txfs_btree_key_addr(cur, 2, right)));\n\t} else {\n\t\t/* It's a leaf. make a hole in the records */\n\t\tunion xfs_btree_rec\t*lrp;\n\t\tunion xfs_btree_rec\t*rrp;\n\n\t\tlrp = xfs_btree_rec_addr(cur, lrecs, left);\n\t\trrp = xfs_btree_rec_addr(cur, 1, right);\n\n\t\txfs_btree_shift_recs(cur, rrp, 1, rrecs);\n\n\t\t/* Now put the new data in, and log it. */\n\t\txfs_btree_copy_recs(cur, rrp, lrp, 1);\n\t\txfs_btree_log_recs(cur, rbp, 1, rrecs + 1);\n\n\t\tcur->bc_ops->init_key_from_rec(&key, rrp);\n\t\trkp = &key;\n\n\t\tASSERT(cur->bc_ops->recs_inorder(cur, rrp,\n\t\t\txfs_btree_rec_addr(cur, 2, right)));\n\t}\n\n\t/*\n\t * Decrement and log left's numrecs, bump and log right's numrecs.\n\t */\n\txfs_btree_set_numrecs(left, --lrecs);\n\txfs_btree_log_block(cur, lbp, XFS_BB_NUMRECS);\n\n\txfs_btree_set_numrecs(right, ++rrecs);\n\txfs_btree_log_block(cur, rbp, XFS_BB_NUMRECS);\n\n\t/*\n\t * Using a temporary cursor, update the parent key values of the\n\t * block on the right.\n\t */\n\terror = xfs_btree_dup_cursor(cur, &tcur);\n\tif (error)\n\t\tgoto error0;\n\ti = xfs_btree_lastrec(tcur, level);\n\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\n\terror = xfs_btree_increment(tcur, level, &i);\n\tif (error)\n\t\tgoto error1;\n\n\terror = xfs_btree_updkey(tcur, rkp, level + 1);\n\tif (error)\n\t\tgoto error1;\n\n\txfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n\nerror1:\n\tXFS_BTREE_TRACE_CURSOR(tcur, XBT_ERROR);\n\txfs_btree_del_cursor(tcur, XFS_BTREE_ERROR);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_btree_lshift",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "1965-2142",
    "snippet": "STATIC int\t\t\t\t\t/* error */\nxfs_btree_lshift(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tunion xfs_btree_key\tkey;\t\t/* btree key */\n\tstruct xfs_buf\t\t*lbp;\t\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t\t/* left btree block */\n\tint\t\t\tlrecs;\t\t/* left record count */\n\tstruct xfs_buf\t\t*rbp;\t\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t\t/* right btree block */\n\tint\t\t\trrecs;\t\t/* right record count */\n\tunion xfs_btree_ptr\tlptr;\t\t/* left btree pointer */\n\tunion xfs_btree_key\t*rkp = NULL;\t/* right btree key */\n\tunion xfs_btree_ptr\t*rpp = NULL;\t/* right address pointer */\n\tunion xfs_btree_rec\t*rrp = NULL;\t/* right record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    level == cur->bc_nlevels - 1)\n\t\tgoto out0;\n\n\t/* Set up variables for this block as \"right\". */\n\tright = xfs_btree_get_block(cur, level, &rbp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, right, level, rbp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* If we've got no left sibling then we can't shift an entry left. */\n\txfs_btree_get_sibling(cur, right, &lptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &lptr))\n\t\tgoto out0;\n\n\t/*\n\t * If the cursor entry is the one that would be moved, don't\n\t * do it... it's too complicated.\n\t */\n\tif (cur->bc_ptrs[level] <= 1)\n\t\tgoto out0;\n\n\t/* Set up the left neighbor as \"left\". */\n\terror = xfs_btree_read_buf_block(cur, &lptr, 0, &left, &lbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* If it's full, it can't take another entry. */\n\tlrecs = xfs_btree_get_numrecs(left);\n\tif (lrecs == cur->bc_ops->get_maxrecs(cur, level))\n\t\tgoto out0;\n\n\trrecs = xfs_btree_get_numrecs(right);\n\n\t/*\n\t * We add one entry to the left side and remove one for the right side.\n\t * Account for it here, the changes will be updated on disk and logged\n\t * later.\n\t */\n\tlrecs++;\n\trrecs--;\n\n\tXFS_BTREE_STATS_INC(cur, lshift);\n\tXFS_BTREE_STATS_ADD(cur, moves, 1);\n\n\t/*\n\t * If non-leaf, copy a key and a ptr to the left block.\n\t * Log the changes to the left block.\n\t */\n\tif (level > 0) {\n\t\t/* It's a non-leaf.  Move keys and pointers. */\n\t\tunion xfs_btree_key\t*lkp;\t/* left btree key */\n\t\tunion xfs_btree_ptr\t*lpp;\t/* left address pointer */\n\n\t\tlkp = xfs_btree_key_addr(cur, lrecs, left);\n\t\trkp = xfs_btree_key_addr(cur, 1, right);\n\n\t\tlpp = xfs_btree_ptr_addr(cur, lrecs, left);\n\t\trpp = xfs_btree_ptr_addr(cur, 1, right);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_ptr(cur, rpp, 0, level);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\t\txfs_btree_copy_keys(cur, lkp, rkp, 1);\n\t\txfs_btree_copy_ptrs(cur, lpp, rpp, 1);\n\n\t\txfs_btree_log_keys(cur, lbp, lrecs, lrecs);\n\t\txfs_btree_log_ptrs(cur, lbp, lrecs, lrecs);\n\n\t\tASSERT(cur->bc_ops->keys_inorder(cur,\n\t\t\txfs_btree_key_addr(cur, lrecs - 1, left), lkp));\n\t} else {\n\t\t/* It's a leaf.  Move records.  */\n\t\tunion xfs_btree_rec\t*lrp;\t/* left record pointer */\n\n\t\tlrp = xfs_btree_rec_addr(cur, lrecs, left);\n\t\trrp = xfs_btree_rec_addr(cur, 1, right);\n\n\t\txfs_btree_copy_recs(cur, lrp, rrp, 1);\n\t\txfs_btree_log_recs(cur, lbp, lrecs, lrecs);\n\n\t\tASSERT(cur->bc_ops->recs_inorder(cur,\n\t\t\txfs_btree_rec_addr(cur, lrecs - 1, left), lrp));\n\t}\n\n\txfs_btree_set_numrecs(left, lrecs);\n\txfs_btree_log_block(cur, lbp, XFS_BB_NUMRECS);\n\n\txfs_btree_set_numrecs(right, rrecs);\n\txfs_btree_log_block(cur, rbp, XFS_BB_NUMRECS);\n\n\t/*\n\t * Slide the contents of right down one entry.\n\t */\n\tXFS_BTREE_STATS_ADD(cur, moves, rrecs - 1);\n\tif (level > 0) {\n\t\t/* It's a nonleaf. operate on keys and ptrs */\n#ifdef DEBUG\n\t\tint\t\t\ti;\t\t/* loop index */\n\n\t\tfor (i = 0; i < rrecs; i++) {\n\t\t\terror = xfs_btree_check_ptr(cur, rpp, i + 1, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\t\txfs_btree_shift_keys(cur,\n\t\t\t\txfs_btree_key_addr(cur, 2, right),\n\t\t\t\t-1, rrecs);\n\t\txfs_btree_shift_ptrs(cur,\n\t\t\t\txfs_btree_ptr_addr(cur, 2, right),\n\t\t\t\t-1, rrecs);\n\n\t\txfs_btree_log_keys(cur, rbp, 1, rrecs);\n\t\txfs_btree_log_ptrs(cur, rbp, 1, rrecs);\n\t} else {\n\t\t/* It's a leaf. operate on records */\n\t\txfs_btree_shift_recs(cur,\n\t\t\txfs_btree_rec_addr(cur, 2, right),\n\t\t\t-1, rrecs);\n\t\txfs_btree_log_recs(cur, rbp, 1, rrecs);\n\n\t\t/*\n\t\t * If it's the first record in the block, we'll need a key\n\t\t * structure to pass up to the next level (updkey).\n\t\t */\n\t\tcur->bc_ops->init_key_from_rec(&key,\n\t\t\txfs_btree_rec_addr(cur, 1, right));\n\t\trkp = &key;\n\t}\n\n\t/* Update the parent key values of right. */\n\terror = xfs_btree_updkey(cur, rkp, level + 1);\n\tif (error)\n\t\tgoto error0;\n\n\t/* Slide the cursor value left one. */\n\tcur->bc_ptrs[level]--;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ERROR"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_updkey",
          "args": [
            "cur",
            "rkp",
            "level + 1"
          ],
          "line": 2123
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_updkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1855-1897",
          "snippet": "STATIC int\nxfs_btree_updkey(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*keyp,\n\tint\t\t\tlevel)\n{\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_buf\t\t*bp;\n\tunion xfs_btree_key\t*kp;\n\tint\t\t\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGIK(cur, level, keyp);\n\n\tASSERT(!(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) || level >= 1);\n\n\t/*\n\t * Go up the tree from this level toward the root.\n\t * At each level, update the key value to the value input.\n\t * Stop when we reach a level where the cursor isn't pointing\n\t * at the first entry in the block.\n\t */\n\tfor (ptr = 1; ptr == 1 && level < cur->bc_nlevels; level++) {\n#ifdef DEBUG\n\t\tint\t\terror;\n#endif\n\t\tblock = xfs_btree_get_block(cur, level, &bp);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, level, bp);\n\t\tif (error) {\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\t\t\treturn error;\n\t\t}\n#endif\n\t\tptr = cur->bc_ptrs[level];\n\t\tkp = xfs_btree_key_addr(cur, ptr, block);\n\t\txfs_btree_copy_keys(cur, kp, keyp, 1);\n\t\txfs_btree_log_keys(cur, bp, ptr, ptr);\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_updkey(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*keyp,\n\tint\t\t\tlevel)\n{\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_buf\t\t*bp;\n\tunion xfs_btree_key\t*kp;\n\tint\t\t\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGIK(cur, level, keyp);\n\n\tASSERT(!(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) || level >= 1);\n\n\t/*\n\t * Go up the tree from this level toward the root.\n\t * At each level, update the key value to the value input.\n\t * Stop when we reach a level where the cursor isn't pointing\n\t * at the first entry in the block.\n\t */\n\tfor (ptr = 1; ptr == 1 && level < cur->bc_nlevels; level++) {\n#ifdef DEBUG\n\t\tint\t\terror;\n#endif\n\t\tblock = xfs_btree_get_block(cur, level, &bp);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, level, bp);\n\t\tif (error) {\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\t\t\treturn error;\n\t\t}\n#endif\n\t\tptr = cur->bc_ptrs[level];\n\t\tkp = xfs_btree_key_addr(cur, ptr, block);\n\t\txfs_btree_copy_keys(cur, kp, keyp, 1);\n\t\txfs_btree_log_keys(cur, bp, ptr, ptr);\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->init_key_from_rec",
          "args": [
            "&key",
            "xfs_btree_rec_addr(cur, 1, right)"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_rec_addr",
          "args": [
            "cur",
            "1",
            "right"
          ],
          "line": 2118
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_rec_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "468-476",
          "snippet": "xfs_btree_rec *\nxfs_btree_rec_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_rec *)\n\t\t((char *)block + xfs_btree_rec_offset(cur, n));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_rec *\nxfs_btree_rec_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_rec *)\n\t\t((char *)block + xfs_btree_rec_offset(cur, n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_recs",
          "args": [
            "cur",
            "rbp",
            "1",
            "rrecs"
          ],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_recs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1307-1323",
          "snippet": "void\nxfs_btree_log_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t  xfs_btree_rec_offset(cur, first),\n\t\t\t  xfs_btree_rec_offset(cur, last + 1) - 1);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_log_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t  xfs_btree_rec_offset(cur, first),\n\t\t\t  xfs_btree_rec_offset(cur, last + 1) - 1);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_shift_recs",
          "args": [
            "cur",
            "xfs_btree_rec_addr(cur, 2, right)",
            "-1",
            "rrecs"
          ],
          "line": 2108
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_shift_recs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1243-1257",
          "snippet": "STATIC void\nxfs_btree_shift_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*rec,\n\tint\t\t\tdir,\n\tint\t\t\tnumrecs)\n{\n\tchar\t\t\t*dst_rec;\n\n\tASSERT(numrecs >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_rec = (char *)rec + (dir * cur->bc_ops->rec_len);\n\tmemmove(dst_rec, rec, numrecs * cur->bc_ops->rec_len);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_shift_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*rec,\n\tint\t\t\tdir,\n\tint\t\t\tnumrecs)\n{\n\tchar\t\t\t*dst_rec;\n\n\tASSERT(numrecs >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_rec = (char *)rec + (dir * cur->bc_ops->rec_len);\n\tmemmove(dst_rec, rec, numrecs * cur->bc_ops->rec_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_ptrs",
          "args": [
            "cur",
            "rbp",
            "1",
            "rrecs"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_ptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1328-1352",
          "snippet": "STATIC void\nxfs_btree_log_ptrs(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfirst,\t/* index of first pointer to log */\n\tint\t\t\tlast)\t/* index of last pointer to log */\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\t\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\txfs_btree_ptr_offset(cur, first, level),\n\t\t\t\txfs_btree_ptr_offset(cur, last + 1, level) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_log_ptrs(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfirst,\t/* index of first pointer to log */\n\tint\t\t\tlast)\t/* index of last pointer to log */\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\t\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\txfs_btree_ptr_offset(cur, first, level),\n\t\t\t\txfs_btree_ptr_offset(cur, last + 1, level) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_keys",
          "args": [
            "cur",
            "rbp",
            "1",
            "rrecs"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1281-1302",
          "snippet": "STATIC void\nxfs_btree_log_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\t  xfs_btree_key_offset(cur, first),\n\t\t\t\t  xfs_btree_key_offset(cur, last + 1) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_log_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\t  xfs_btree_key_offset(cur, first),\n\t\t\t\t  xfs_btree_key_offset(cur, last + 1) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_shift_ptrs",
          "args": [
            "cur",
            "xfs_btree_ptr_addr(cur, 2, right)",
            "-1",
            "rrecs"
          ],
          "line": 2100
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_shift_ptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1262-1276",
          "snippet": "STATIC void\nxfs_btree_shift_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tdir,\n\tint\t\t\tnumptrs)\n{\n\tchar\t\t\t*dst_ptr;\n\n\tASSERT(numptrs >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_ptr = (char *)ptr + (dir * xfs_btree_ptr_len(cur));\n\tmemmove(dst_ptr, ptr, numptrs * xfs_btree_ptr_len(cur));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_shift_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tdir,\n\tint\t\t\tnumptrs)\n{\n\tchar\t\t\t*dst_ptr;\n\n\tASSERT(numptrs >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_ptr = (char *)ptr + (dir * xfs_btree_ptr_len(cur));\n\tmemmove(dst_ptr, ptr, numptrs * xfs_btree_ptr_len(cur));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_addr",
          "args": [
            "cur",
            "2",
            "right"
          ],
          "line": 2101
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "494-506",
          "snippet": "xfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_shift_keys",
          "args": [
            "cur",
            "xfs_btree_key_addr(cur, 2, right)",
            "-1",
            "rrecs"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_shift_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1224-1238",
          "snippet": "STATIC void\nxfs_btree_shift_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*key,\n\tint\t\t\tdir,\n\tint\t\t\tnumkeys)\n{\n\tchar\t\t\t*dst_key;\n\n\tASSERT(numkeys >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_key = (char *)key + (dir * cur->bc_ops->key_len);\n\tmemmove(dst_key, key, numkeys * cur->bc_ops->key_len);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_shift_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*key,\n\tint\t\t\tdir,\n\tint\t\t\tnumkeys)\n{\n\tchar\t\t\t*dst_key;\n\n\tASSERT(numkeys >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_key = (char *)key + (dir * cur->bc_ops->key_len);\n\tmemmove(dst_key, key, numkeys * cur->bc_ops->key_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_key_addr",
          "args": [
            "cur",
            "2",
            "right"
          ],
          "line": 2098
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_key_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "481-489",
          "snippet": "xfs_btree_key *\nxfs_btree_key_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_key *)\n\t\t((char *)block + xfs_btree_key_offset(cur, n));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_key *\nxfs_btree_key_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_key *)\n\t\t((char *)block + xfs_btree_key_offset(cur, n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_check_ptr",
          "args": [
            "cur",
            "rpp",
            "i + 1",
            "level"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "201-215",
          "snippet": "STATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_ptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tunion xfs_btree_ptr\t*ptr,\t/* btree block disk address */\n\tint\t\t\tindex,\t/* offset from ptr to check */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\treturn xfs_btree_check_lptr(cur,\n\t\t\t\tbe64_to_cpu((&ptr->l)[index]), level);\n\t} else {\n\t\treturn xfs_btree_check_sptr(cur,\n\t\t\t\tbe32_to_cpu((&ptr->s)[index]), level);\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_ptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tunion xfs_btree_ptr\t*ptr,\t/* btree block disk address */\n\tint\t\t\tindex,\t/* offset from ptr to check */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\treturn xfs_btree_check_lptr(cur,\n\t\t\t\tbe64_to_cpu((&ptr->l)[index]), level);\n\t} else {\n\t\treturn xfs_btree_check_sptr(cur,\n\t\t\t\tbe32_to_cpu((&ptr->s)[index]), level);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_ADD",
          "args": [
            "cur",
            "moves",
            "rrecs - 1"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_block",
          "args": [
            "cur",
            "rbp",
            "XFS_BB_NUMRECS"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1357-1425",
          "snippet": "void\nxfs_btree_log_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfields)\t/* mask of fields: XFS_BB_... */\n{\n\tint\t\t\tfirst;\t/* first byte offset logged */\n\tint\t\t\tlast;\t/* last byte offset logged */\n\tstatic const short\tsoffsets[] = {\t/* table of offsets (short) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_crc),\n\t\tXFS_BTREE_SBLOCK_CRC_LEN\n\t};\n\tstatic const short\tloffsets[] = {\t/* table of offsets (long) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_crc),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_pad),\n\t\tXFS_BTREE_LBLOCK_CRC_LEN\n\t};\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBI(cur, bp, fields);\n\n\tif (bp) {\n\t\tint nbits;\n\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\t/*\n\t\t\t * We don't log the CRC when updating a btree\n\t\t\t * block but instead recreate it during log\n\t\t\t * recovery.  As the log buffers have checksums\n\t\t\t * of their own this is safe and avoids logging a crc\n\t\t\t * update in a lot of places.\n\t\t\t */\n\t\t\tif (fields == XFS_BB_ALL_BITS)\n\t\t\t\tfields = XFS_BB_ALL_BITS_CRC;\n\t\t\tnbits = XFS_BB_NUM_BITS_CRC;\n\t\t} else {\n\t\t\tnbits = XFS_BB_NUM_BITS;\n\t\t}\n\t\txfs_btree_offsets(fields,\n\t\t\t\t  (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\t\t\t\tloffsets : soffsets,\n\t\t\t\t  nbits, &first, &last);\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp, first, last);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_log_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfields)\t/* mask of fields: XFS_BB_... */\n{\n\tint\t\t\tfirst;\t/* first byte offset logged */\n\tint\t\t\tlast;\t/* last byte offset logged */\n\tstatic const short\tsoffsets[] = {\t/* table of offsets (short) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_crc),\n\t\tXFS_BTREE_SBLOCK_CRC_LEN\n\t};\n\tstatic const short\tloffsets[] = {\t/* table of offsets (long) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_crc),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_pad),\n\t\tXFS_BTREE_LBLOCK_CRC_LEN\n\t};\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBI(cur, bp, fields);\n\n\tif (bp) {\n\t\tint nbits;\n\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\t/*\n\t\t\t * We don't log the CRC when updating a btree\n\t\t\t * block but instead recreate it during log\n\t\t\t * recovery.  As the log buffers have checksums\n\t\t\t * of their own this is safe and avoids logging a crc\n\t\t\t * update in a lot of places.\n\t\t\t */\n\t\t\tif (fields == XFS_BB_ALL_BITS)\n\t\t\t\tfields = XFS_BB_ALL_BITS_CRC;\n\t\t\tnbits = XFS_BB_NUM_BITS_CRC;\n\t\t} else {\n\t\t\tnbits = XFS_BB_NUM_BITS;\n\t\t}\n\t\txfs_btree_offsets(fields,\n\t\t\t\t  (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\t\t\t\tloffsets : soffsets,\n\t\t\t\t  nbits, &first, &last);\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp, first, last);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_set_numrecs",
          "args": [
            "right",
            "rrecs"
          ],
          "line": 2079
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_set_numrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "421-425",
          "snippet": "static inline void xfs_btree_set_numrecs(struct xfs_btree_block *block,\n\t\t__uint16_t numrecs)\n{\n\tblock->bb_numrecs = cpu_to_be16(numrecs);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_btree_set_numrecs(struct xfs_btree_block *block,\n\t\t__uint16_t numrecs)\n{\n\tblock->bb_numrecs = cpu_to_be16(numrecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cur->bc_ops->recs_inorder(cur,\n\t\t\txfs_btree_rec_addr(cur, lrecs - 1, left), lrp)"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->recs_inorder",
          "args": [
            "cur",
            "xfs_btree_rec_addr(cur, lrecs - 1, left)",
            "lrp"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_copy_recs",
          "args": [
            "cur",
            "lrp",
            "rrp",
            "1"
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_copy_recs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1196-1205",
          "snippet": "STATIC void\nxfs_btree_copy_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*dst_rec,\n\tunion xfs_btree_rec\t*src_rec,\n\tint\t\t\tnumrecs)\n{\n\tASSERT(numrecs >= 0);\n\tmemcpy(dst_rec, src_rec, numrecs * cur->bc_ops->rec_len);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*dst_rec,\n\tunion xfs_btree_rec\t*src_rec,\n\tint\t\t\tnumrecs)\n{\n\tASSERT(numrecs >= 0);\n\tmemcpy(dst_rec, src_rec, numrecs * cur->bc_ops->rec_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cur->bc_ops->keys_inorder(cur,\n\t\t\txfs_btree_key_addr(cur, lrecs - 1, left), lkp)"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->keys_inorder",
          "args": [
            "cur",
            "xfs_btree_key_addr(cur, lrecs - 1, left)",
            "lkp"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_copy_ptrs",
          "args": [
            "cur",
            "lpp",
            "rpp",
            "1"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_copy_ptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1210-1219",
          "snippet": "STATIC void\nxfs_btree_copy_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*dst_ptr,\n\tunion xfs_btree_ptr\t*src_ptr,\n\tint\t\t\tnumptrs)\n{\n\tASSERT(numptrs >= 0);\n\tmemcpy(dst_ptr, src_ptr, numptrs * xfs_btree_ptr_len(cur));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*dst_ptr,\n\tunion xfs_btree_ptr\t*src_ptr,\n\tint\t\t\tnumptrs)\n{\n\tASSERT(numptrs >= 0);\n\tmemcpy(dst_ptr, src_ptr, numptrs * xfs_btree_ptr_len(cur));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_copy_keys",
          "args": [
            "cur",
            "lkp",
            "rkp",
            "1"
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_copy_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1182-1191",
          "snippet": "STATIC void\nxfs_btree_copy_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*dst_key,\n\tunion xfs_btree_key\t*src_key,\n\tint\t\t\tnumkeys)\n{\n\tASSERT(numkeys >= 0);\n\tmemcpy(dst_key, src_key, numkeys * cur->bc_ops->key_len);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*dst_key,\n\tunion xfs_btree_key\t*src_key,\n\tint\t\t\tnumkeys)\n{\n\tASSERT(numkeys >= 0);\n\tmemcpy(dst_key, src_key, numkeys * cur->bc_ops->key_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_ADD",
          "args": [
            "cur",
            "moves",
            "1"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_INC",
          "args": [
            "cur",
            "lshift"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_numrecs",
          "args": [
            "right"
          ],
          "line": 2022
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_numrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "416-419",
          "snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->get_maxrecs",
          "args": [
            "cur",
            "level"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_read_buf_block",
          "args": [
            "cur",
            "&lptr",
            "0",
            "&left",
            "&lbp"
          ],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_read_buf_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1152-1177",
          "snippet": "STATIC int\nxfs_btree_read_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\tint\t\t\terror;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\terror = xfs_trans_read_buf(mp, cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, flags, bpp,\n\t\t\t\t   cur->bc_ops->buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_set_refs(cur, *bpp);\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_read_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\tint\t\t\terror;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\terror = xfs_trans_read_buf(mp, cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, flags, bpp,\n\t\t\t\t   cur->bc_ops->buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_set_refs(cur, *bpp);\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_is_null",
          "args": [
            "cur",
            "&lptr"
          ],
          "line": 2002
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_is_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "913-922",
          "snippet": "STATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_sibling",
          "args": [
            "cur",
            "right",
            "&lptr",
            "XFS_BB_LEFTSIB"
          ],
          "line": 2001
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_sibling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "938-958",
          "snippet": "STATIC void\nxfs_btree_get_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->l = block->bb_u.l.bb_rightsib;\n\t\telse\n\t\t\tptr->l = block->bb_u.l.bb_leftsib;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->s = block->bb_u.s.bb_rightsib;\n\t\telse\n\t\t\tptr->s = block->bb_u.s.bb_leftsib;\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_get_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->l = block->bb_u.l.bb_rightsib;\n\t\telse\n\t\t\tptr->l = block->bb_u.l.bb_leftsib;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->s = block->bb_u.s.bb_rightsib;\n\t\telse\n\t\t\tptr->s = block->bb_u.s.bb_leftsib;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_check_block",
          "args": [
            "cur",
            "right",
            "level",
            "rbp"
          ],
          "line": 1995
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "149-160",
          "snippet": "int\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_block",
          "args": [
            "cur",
            "level",
            "&rbp"
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "528-542",
          "snippet": "xfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_ARGI",
          "args": [
            "cur",
            "level"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ENTRY"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\t\t\t\t\t/* error */\nxfs_btree_lshift(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tunion xfs_btree_key\tkey;\t\t/* btree key */\n\tstruct xfs_buf\t\t*lbp;\t\t/* left buffer pointer */\n\tstruct xfs_btree_block\t*left;\t\t/* left btree block */\n\tint\t\t\tlrecs;\t\t/* left record count */\n\tstruct xfs_buf\t\t*rbp;\t\t/* right buffer pointer */\n\tstruct xfs_btree_block\t*right;\t\t/* right btree block */\n\tint\t\t\trrecs;\t\t/* right record count */\n\tunion xfs_btree_ptr\tlptr;\t\t/* left btree pointer */\n\tunion xfs_btree_key\t*rkp = NULL;\t/* right btree key */\n\tunion xfs_btree_ptr\t*rpp = NULL;\t/* right address pointer */\n\tunion xfs_btree_rec\t*rrp = NULL;\t/* right record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    level == cur->bc_nlevels - 1)\n\t\tgoto out0;\n\n\t/* Set up variables for this block as \"right\". */\n\tright = xfs_btree_get_block(cur, level, &rbp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, right, level, rbp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* If we've got no left sibling then we can't shift an entry left. */\n\txfs_btree_get_sibling(cur, right, &lptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &lptr))\n\t\tgoto out0;\n\n\t/*\n\t * If the cursor entry is the one that would be moved, don't\n\t * do it... it's too complicated.\n\t */\n\tif (cur->bc_ptrs[level] <= 1)\n\t\tgoto out0;\n\n\t/* Set up the left neighbor as \"left\". */\n\terror = xfs_btree_read_buf_block(cur, &lptr, 0, &left, &lbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/* If it's full, it can't take another entry. */\n\tlrecs = xfs_btree_get_numrecs(left);\n\tif (lrecs == cur->bc_ops->get_maxrecs(cur, level))\n\t\tgoto out0;\n\n\trrecs = xfs_btree_get_numrecs(right);\n\n\t/*\n\t * We add one entry to the left side and remove one for the right side.\n\t * Account for it here, the changes will be updated on disk and logged\n\t * later.\n\t */\n\tlrecs++;\n\trrecs--;\n\n\tXFS_BTREE_STATS_INC(cur, lshift);\n\tXFS_BTREE_STATS_ADD(cur, moves, 1);\n\n\t/*\n\t * If non-leaf, copy a key and a ptr to the left block.\n\t * Log the changes to the left block.\n\t */\n\tif (level > 0) {\n\t\t/* It's a non-leaf.  Move keys and pointers. */\n\t\tunion xfs_btree_key\t*lkp;\t/* left btree key */\n\t\tunion xfs_btree_ptr\t*lpp;\t/* left address pointer */\n\n\t\tlkp = xfs_btree_key_addr(cur, lrecs, left);\n\t\trkp = xfs_btree_key_addr(cur, 1, right);\n\n\t\tlpp = xfs_btree_ptr_addr(cur, lrecs, left);\n\t\trpp = xfs_btree_ptr_addr(cur, 1, right);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_ptr(cur, rpp, 0, level);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\t\txfs_btree_copy_keys(cur, lkp, rkp, 1);\n\t\txfs_btree_copy_ptrs(cur, lpp, rpp, 1);\n\n\t\txfs_btree_log_keys(cur, lbp, lrecs, lrecs);\n\t\txfs_btree_log_ptrs(cur, lbp, lrecs, lrecs);\n\n\t\tASSERT(cur->bc_ops->keys_inorder(cur,\n\t\t\txfs_btree_key_addr(cur, lrecs - 1, left), lkp));\n\t} else {\n\t\t/* It's a leaf.  Move records.  */\n\t\tunion xfs_btree_rec\t*lrp;\t/* left record pointer */\n\n\t\tlrp = xfs_btree_rec_addr(cur, lrecs, left);\n\t\trrp = xfs_btree_rec_addr(cur, 1, right);\n\n\t\txfs_btree_copy_recs(cur, lrp, rrp, 1);\n\t\txfs_btree_log_recs(cur, lbp, lrecs, lrecs);\n\n\t\tASSERT(cur->bc_ops->recs_inorder(cur,\n\t\t\txfs_btree_rec_addr(cur, lrecs - 1, left), lrp));\n\t}\n\n\txfs_btree_set_numrecs(left, lrecs);\n\txfs_btree_log_block(cur, lbp, XFS_BB_NUMRECS);\n\n\txfs_btree_set_numrecs(right, rrecs);\n\txfs_btree_log_block(cur, rbp, XFS_BB_NUMRECS);\n\n\t/*\n\t * Slide the contents of right down one entry.\n\t */\n\tXFS_BTREE_STATS_ADD(cur, moves, rrecs - 1);\n\tif (level > 0) {\n\t\t/* It's a nonleaf. operate on keys and ptrs */\n#ifdef DEBUG\n\t\tint\t\t\ti;\t\t/* loop index */\n\n\t\tfor (i = 0; i < rrecs; i++) {\n\t\t\terror = xfs_btree_check_ptr(cur, rpp, i + 1, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t}\n#endif\n\t\txfs_btree_shift_keys(cur,\n\t\t\t\txfs_btree_key_addr(cur, 2, right),\n\t\t\t\t-1, rrecs);\n\t\txfs_btree_shift_ptrs(cur,\n\t\t\t\txfs_btree_ptr_addr(cur, 2, right),\n\t\t\t\t-1, rrecs);\n\n\t\txfs_btree_log_keys(cur, rbp, 1, rrecs);\n\t\txfs_btree_log_ptrs(cur, rbp, 1, rrecs);\n\t} else {\n\t\t/* It's a leaf. operate on records */\n\t\txfs_btree_shift_recs(cur,\n\t\t\txfs_btree_rec_addr(cur, 2, right),\n\t\t\t-1, rrecs);\n\t\txfs_btree_log_recs(cur, rbp, 1, rrecs);\n\n\t\t/*\n\t\t * If it's the first record in the block, we'll need a key\n\t\t * structure to pass up to the next level (updkey).\n\t\t */\n\t\tcur->bc_ops->init_key_from_rec(&key,\n\t\t\txfs_btree_rec_addr(cur, 1, right));\n\t\trkp = &key;\n\t}\n\n\t/* Update the parent key values of right. */\n\terror = xfs_btree_updkey(cur, rkp, level + 1);\n\tif (error)\n\t\tgoto error0;\n\n\t/* Slide the cursor value left one. */\n\tcur->bc_ptrs[level]--;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_btree_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "1904-1959",
    "snippet": "int\nxfs_btree_update(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*rec)\n{\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tint\t\t\tptr;\n\tunion xfs_btree_rec\t*rp;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGR(cur, rec);\n\n\t/* Pick up the current block. */\n\tblock = xfs_btree_get_block(cur, 0, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, 0, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\t/* Get the address of the rec to be updated. */\n\tptr = cur->bc_ptrs[0];\n\trp = xfs_btree_rec_addr(cur, ptr, block);\n\n\t/* Fill in the new contents and log them. */\n\txfs_btree_copy_recs(cur, rp, rec, 1);\n\txfs_btree_log_recs(cur, bp, ptr, ptr);\n\n\t/*\n\t * If we are tracking the last record in the tree and\n\t * we are at the far right edge of the tree, update it.\n\t */\n\tif (xfs_btree_is_lastrec(cur, block, 0)) {\n\t\tcur->bc_ops->update_lastrec(cur, block, rec,\n\t\t\t\t\t    ptr, LASTREC_UPDATE);\n\t}\n\n\t/* Updating first rec in leaf. Pass new key value up to our parent. */\n\tif (ptr == 1) {\n\t\tunion xfs_btree_key\tkey;\n\n\t\tcur->bc_ops->init_key_from_rec(&key, rec);\n\t\terror = xfs_btree_updkey(cur, &key, 1);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ERROR"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_updkey",
          "args": [
            "cur",
            "&key",
            "1"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_updkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1855-1897",
          "snippet": "STATIC int\nxfs_btree_updkey(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*keyp,\n\tint\t\t\tlevel)\n{\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_buf\t\t*bp;\n\tunion xfs_btree_key\t*kp;\n\tint\t\t\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGIK(cur, level, keyp);\n\n\tASSERT(!(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) || level >= 1);\n\n\t/*\n\t * Go up the tree from this level toward the root.\n\t * At each level, update the key value to the value input.\n\t * Stop when we reach a level where the cursor isn't pointing\n\t * at the first entry in the block.\n\t */\n\tfor (ptr = 1; ptr == 1 && level < cur->bc_nlevels; level++) {\n#ifdef DEBUG\n\t\tint\t\terror;\n#endif\n\t\tblock = xfs_btree_get_block(cur, level, &bp);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, level, bp);\n\t\tif (error) {\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\t\t\treturn error;\n\t\t}\n#endif\n\t\tptr = cur->bc_ptrs[level];\n\t\tkp = xfs_btree_key_addr(cur, ptr, block);\n\t\txfs_btree_copy_keys(cur, kp, keyp, 1);\n\t\txfs_btree_log_keys(cur, bp, ptr, ptr);\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_updkey(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*keyp,\n\tint\t\t\tlevel)\n{\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_buf\t\t*bp;\n\tunion xfs_btree_key\t*kp;\n\tint\t\t\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGIK(cur, level, keyp);\n\n\tASSERT(!(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) || level >= 1);\n\n\t/*\n\t * Go up the tree from this level toward the root.\n\t * At each level, update the key value to the value input.\n\t * Stop when we reach a level where the cursor isn't pointing\n\t * at the first entry in the block.\n\t */\n\tfor (ptr = 1; ptr == 1 && level < cur->bc_nlevels; level++) {\n#ifdef DEBUG\n\t\tint\t\terror;\n#endif\n\t\tblock = xfs_btree_get_block(cur, level, &bp);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, level, bp);\n\t\tif (error) {\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\t\t\treturn error;\n\t\t}\n#endif\n\t\tptr = cur->bc_ptrs[level];\n\t\tkp = xfs_btree_key_addr(cur, ptr, block);\n\t\txfs_btree_copy_keys(cur, kp, keyp, 1);\n\t\txfs_btree_log_keys(cur, bp, ptr, ptr);\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->init_key_from_rec",
          "args": [
            "&key",
            "rec"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->update_lastrec",
          "args": [
            "cur",
            "block",
            "rec",
            "ptr",
            "LASTREC_UPDATE"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_is_lastrec",
          "args": [
            "cur",
            "block",
            "0"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_is_lastrec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1066-1083",
          "snippet": "STATIC int\nxfs_btree_is_lastrec(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tint\t\t\tlevel)\n{\n\tunion xfs_btree_ptr\tptr;\n\n\tif (level > 0)\n\t\treturn 0;\n\tif (!(cur->bc_flags & XFS_BTREE_LASTREC_UPDATE))\n\t\treturn 0;\n\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (!xfs_btree_ptr_is_null(cur, &ptr))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_is_lastrec(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tint\t\t\tlevel)\n{\n\tunion xfs_btree_ptr\tptr;\n\n\tif (level > 0)\n\t\treturn 0;\n\tif (!(cur->bc_flags & XFS_BTREE_LASTREC_UPDATE))\n\t\treturn 0;\n\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (!xfs_btree_ptr_is_null(cur, &ptr))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_recs",
          "args": [
            "cur",
            "bp",
            "ptr",
            "ptr"
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_recs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1307-1323",
          "snippet": "void\nxfs_btree_log_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t  xfs_btree_rec_offset(cur, first),\n\t\t\t  xfs_btree_rec_offset(cur, last + 1) - 1);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_log_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t  xfs_btree_rec_offset(cur, first),\n\t\t\t  xfs_btree_rec_offset(cur, last + 1) - 1);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_copy_recs",
          "args": [
            "cur",
            "rp",
            "rec",
            "1"
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_copy_recs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1196-1205",
          "snippet": "STATIC void\nxfs_btree_copy_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*dst_rec,\n\tunion xfs_btree_rec\t*src_rec,\n\tint\t\t\tnumrecs)\n{\n\tASSERT(numrecs >= 0);\n\tmemcpy(dst_rec, src_rec, numrecs * cur->bc_ops->rec_len);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*dst_rec,\n\tunion xfs_btree_rec\t*src_rec,\n\tint\t\t\tnumrecs)\n{\n\tASSERT(numrecs >= 0);\n\tmemcpy(dst_rec, src_rec, numrecs * cur->bc_ops->rec_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_rec_addr",
          "args": [
            "cur",
            "ptr",
            "block"
          ],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_rec_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "468-476",
          "snippet": "xfs_btree_rec *\nxfs_btree_rec_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_rec *)\n\t\t((char *)block + xfs_btree_rec_offset(cur, n));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_rec *\nxfs_btree_rec_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_rec *)\n\t\t((char *)block + xfs_btree_rec_offset(cur, n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_check_block",
          "args": [
            "cur",
            "block",
            "0",
            "bp"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "149-160",
          "snippet": "int\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_block",
          "args": [
            "cur",
            "0",
            "&bp"
          ],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "528-542",
          "snippet": "xfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_ARGR",
          "args": [
            "cur",
            "rec"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ENTRY"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\nxfs_btree_update(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*rec)\n{\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tint\t\t\tptr;\n\tunion xfs_btree_rec\t*rp;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGR(cur, rec);\n\n\t/* Pick up the current block. */\n\tblock = xfs_btree_get_block(cur, 0, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, 0, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\t/* Get the address of the rec to be updated. */\n\tptr = cur->bc_ptrs[0];\n\trp = xfs_btree_rec_addr(cur, ptr, block);\n\n\t/* Fill in the new contents and log them. */\n\txfs_btree_copy_recs(cur, rp, rec, 1);\n\txfs_btree_log_recs(cur, bp, ptr, ptr);\n\n\t/*\n\t * If we are tracking the last record in the tree and\n\t * we are at the far right edge of the tree, update it.\n\t */\n\tif (xfs_btree_is_lastrec(cur, block, 0)) {\n\t\tcur->bc_ops->update_lastrec(cur, block, rec,\n\t\t\t\t\t    ptr, LASTREC_UPDATE);\n\t}\n\n\t/* Updating first rec in leaf. Pass new key value up to our parent. */\n\tif (ptr == 1) {\n\t\tunion xfs_btree_key\tkey;\n\n\t\tcur->bc_ops->init_key_from_rec(&key, rec);\n\t\terror = xfs_btree_updkey(cur, &key, 1);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_btree_updkey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "1855-1897",
    "snippet": "STATIC int\nxfs_btree_updkey(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*keyp,\n\tint\t\t\tlevel)\n{\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_buf\t\t*bp;\n\tunion xfs_btree_key\t*kp;\n\tint\t\t\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGIK(cur, level, keyp);\n\n\tASSERT(!(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) || level >= 1);\n\n\t/*\n\t * Go up the tree from this level toward the root.\n\t * At each level, update the key value to the value input.\n\t * Stop when we reach a level where the cursor isn't pointing\n\t * at the first entry in the block.\n\t */\n\tfor (ptr = 1; ptr == 1 && level < cur->bc_nlevels; level++) {\n#ifdef DEBUG\n\t\tint\t\terror;\n#endif\n\t\tblock = xfs_btree_get_block(cur, level, &bp);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, level, bp);\n\t\tif (error) {\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\t\t\treturn error;\n\t\t}\n#endif\n\t\tptr = cur->bc_ptrs[level];\n\t\tkp = xfs_btree_key_addr(cur, ptr, block);\n\t\txfs_btree_copy_keys(cur, kp, keyp, 1);\n\t\txfs_btree_log_keys(cur, bp, ptr, ptr);\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_keys",
          "args": [
            "cur",
            "bp",
            "ptr",
            "ptr"
          ],
          "line": 1892
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1281-1302",
          "snippet": "STATIC void\nxfs_btree_log_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\t  xfs_btree_key_offset(cur, first),\n\t\t\t\t  xfs_btree_key_offset(cur, last + 1) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_log_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\t  xfs_btree_key_offset(cur, first),\n\t\t\t\t  xfs_btree_key_offset(cur, last + 1) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_copy_keys",
          "args": [
            "cur",
            "kp",
            "keyp",
            "1"
          ],
          "line": 1891
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_copy_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1182-1191",
          "snippet": "STATIC void\nxfs_btree_copy_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*dst_key,\n\tunion xfs_btree_key\t*src_key,\n\tint\t\t\tnumkeys)\n{\n\tASSERT(numkeys >= 0);\n\tmemcpy(dst_key, src_key, numkeys * cur->bc_ops->key_len);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*dst_key,\n\tunion xfs_btree_key\t*src_key,\n\tint\t\t\tnumkeys)\n{\n\tASSERT(numkeys >= 0);\n\tmemcpy(dst_key, src_key, numkeys * cur->bc_ops->key_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_key_addr",
          "args": [
            "cur",
            "ptr",
            "block"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_key_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "481-489",
          "snippet": "xfs_btree_key *\nxfs_btree_key_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_key *)\n\t\t((char *)block + xfs_btree_key_offset(cur, n));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_key *\nxfs_btree_key_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_key *)\n\t\t((char *)block + xfs_btree_key_offset(cur, n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ERROR"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_check_block",
          "args": [
            "cur",
            "block",
            "level",
            "bp"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "149-160",
          "snippet": "int\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_block",
          "args": [
            "cur",
            "level",
            "&bp"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "528-542",
          "snippet": "xfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) || level >= 1"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_ARGIK",
          "args": [
            "cur",
            "level",
            "keyp"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ENTRY"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_updkey(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*keyp,\n\tint\t\t\tlevel)\n{\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_buf\t\t*bp;\n\tunion xfs_btree_key\t*kp;\n\tint\t\t\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGIK(cur, level, keyp);\n\n\tASSERT(!(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) || level >= 1);\n\n\t/*\n\t * Go up the tree from this level toward the root.\n\t * At each level, update the key value to the value input.\n\t * Stop when we reach a level where the cursor isn't pointing\n\t * at the first entry in the block.\n\t */\n\tfor (ptr = 1; ptr == 1 && level < cur->bc_nlevels; level++) {\n#ifdef DEBUG\n\t\tint\t\terror;\n#endif\n\t\tblock = xfs_btree_get_block(cur, level, &bp);\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, level, bp);\n\t\tif (error) {\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\t\t\treturn error;\n\t\t}\n#endif\n\t\tptr = cur->bc_ptrs[level];\n\t\tkp = xfs_btree_key_addr(cur, ptr, block);\n\t\txfs_btree_copy_keys(cur, kp, keyp, 1);\n\t\txfs_btree_log_keys(cur, bp, ptr, ptr);\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_btree_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "1696-1850",
    "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_lookup_t\t\tdir,\t/* <=, ==, or >= */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\t__int64_t\t\tdiff;\t/* difference for the current key */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tkeyno;\t/* current key number */\n\tint\t\t\tlevel;\t/* level in the btree */\n\tunion xfs_btree_ptr\t*pp;\t/* ptr to btree block */\n\tunion xfs_btree_ptr\tptr;\t/* ptr to btree block */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, dir);\n\n\tXFS_BTREE_STATS_INC(cur, lookup);\n\n\tblock = NULL;\n\tkeyno = 0;\n\n\t/* initialise start pointer from cursor */\n\tcur->bc_ops->init_ptr_from_cur(cur, &ptr);\n\tpp = &ptr;\n\n\t/*\n\t * Iterate over each level in the btree, starting at the root.\n\t * For each level above the leaves, find the key we need, based\n\t * on the lookup record, then follow the corresponding block\n\t * pointer down to the next level.\n\t */\n\tfor (level = cur->bc_nlevels - 1, diff = 1; level >= 0; level--) {\n\t\t/* Get the block we need to do the lookup on. */\n\t\terror = xfs_btree_lookup_get_block(cur, level, pp, &block);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\tif (diff == 0) {\n\t\t\t/*\n\t\t\t * If we already had a key match at a higher level, we\n\t\t\t * know we need to use the first entry in this block.\n\t\t\t */\n\t\t\tkeyno = 1;\n\t\t} else {\n\t\t\t/* Otherwise search this block. Do a binary search. */\n\n\t\t\tint\thigh;\t/* high entry number */\n\t\t\tint\tlow;\t/* low entry number */\n\n\t\t\t/* Set low and high entry numbers, 1-based. */\n\t\t\tlow = 1;\n\t\t\thigh = xfs_btree_get_numrecs(block);\n\t\t\tif (!high) {\n\t\t\t\t/* Block is empty, must be an empty leaf. */\n\t\t\t\tASSERT(level == 0 && cur->bc_nlevels == 1);\n\n\t\t\t\tcur->bc_ptrs[0] = dir != XFS_LOOKUP_LE;\n\t\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t\t*stat = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Binary search the block. */\n\t\t\twhile (low <= high) {\n\t\t\t\tunion xfs_btree_key\tkey;\n\t\t\t\tunion xfs_btree_key\t*kp;\n\n\t\t\t\tXFS_BTREE_STATS_INC(cur, compare);\n\n\t\t\t\t/* keyno is average of low and high. */\n\t\t\t\tkeyno = (low + high) >> 1;\n\n\t\t\t\t/* Get current search key */\n\t\t\t\tkp = xfs_lookup_get_search_key(cur, level,\n\t\t\t\t\t\tkeyno, block, &key);\n\n\t\t\t\t/*\n\t\t\t\t * Compute difference to get next direction:\n\t\t\t\t *  - less than, move right\n\t\t\t\t *  - greater than, move left\n\t\t\t\t *  - equal, we're done\n\t\t\t\t */\n\t\t\t\tdiff = cur->bc_ops->key_diff(cur, kp);\n\t\t\t\tif (diff < 0)\n\t\t\t\t\tlow = keyno + 1;\n\t\t\t\telse if (diff > 0)\n\t\t\t\t\thigh = keyno - 1;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If there are more levels, set up for the next level\n\t\t * by getting the block number and filling in the cursor.\n\t\t */\n\t\tif (level > 0) {\n\t\t\t/*\n\t\t\t * If we moved left, need the previous key number,\n\t\t\t * unless there isn't one.\n\t\t\t */\n\t\t\tif (diff > 0 && --keyno < 1)\n\t\t\t\tkeyno = 1;\n\t\t\tpp = xfs_btree_ptr_addr(cur, keyno, block);\n\n#ifdef DEBUG\n\t\t\terror = xfs_btree_check_ptr(cur, pp, 0, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n#endif\n\t\t\tcur->bc_ptrs[level] = keyno;\n\t\t}\n\t}\n\n\t/* Done with the search. See if we need to adjust the results. */\n\tif (dir != XFS_LOOKUP_LE && diff < 0) {\n\t\tkeyno++;\n\t\t/*\n\t\t * If ge search and we went off the end of the block, but it's\n\t\t * not the last block, we're in the wrong block.\n\t\t */\n\t\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\t\tif (dir == XFS_LOOKUP_GE &&\n\t\t    keyno > xfs_btree_get_numrecs(block) &&\n\t\t    !xfs_btree_ptr_is_null(cur, &ptr)) {\n\t\t\tint\ti;\n\n\t\t\tcur->bc_ptrs[0] = keyno;\n\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t*stat = 1;\n\t\t\treturn 0;\n\t\t}\n\t} else if (dir == XFS_LOOKUP_LE && diff > 0)\n\t\tkeyno--;\n\tcur->bc_ptrs[0] = keyno;\n\n\t/* Return if we succeeded or not. */\n\tif (keyno == 0 || keyno > xfs_btree_get_numrecs(block))\n\t\t*stat = 0;\n\telse if (dir != XFS_LOOKUP_EQ || diff == 0)\n\t\t*stat = 1;\n\telse\n\t\t*stat = 0;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ERROR"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_numrecs",
          "args": [
            "block"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_numrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "416-419",
          "snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i == 1"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_increment",
          "args": [
            "cur",
            "0",
            "&i"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1431-1533",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_is_null",
          "args": [
            "cur",
            "&ptr"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_is_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "913-922",
          "snippet": "STATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_sibling",
          "args": [
            "cur",
            "block",
            "&ptr",
            "XFS_BB_RIGHTSIB"
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_sibling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "938-958",
          "snippet": "STATIC void\nxfs_btree_get_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->l = block->bb_u.l.bb_rightsib;\n\t\telse\n\t\t\tptr->l = block->bb_u.l.bb_leftsib;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->s = block->bb_u.s.bb_rightsib;\n\t\telse\n\t\t\tptr->s = block->bb_u.s.bb_leftsib;\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_get_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->l = block->bb_u.l.bb_rightsib;\n\t\telse\n\t\t\tptr->l = block->bb_u.l.bb_leftsib;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->s = block->bb_u.s.bb_rightsib;\n\t\telse\n\t\t\tptr->s = block->bb_u.s.bb_leftsib;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_check_ptr",
          "args": [
            "cur",
            "pp",
            "0",
            "level"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "201-215",
          "snippet": "STATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_ptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tunion xfs_btree_ptr\t*ptr,\t/* btree block disk address */\n\tint\t\t\tindex,\t/* offset from ptr to check */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\treturn xfs_btree_check_lptr(cur,\n\t\t\t\tbe64_to_cpu((&ptr->l)[index]), level);\n\t} else {\n\t\treturn xfs_btree_check_sptr(cur,\n\t\t\t\tbe32_to_cpu((&ptr->s)[index]), level);\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_ptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tunion xfs_btree_ptr\t*ptr,\t/* btree block disk address */\n\tint\t\t\tindex,\t/* offset from ptr to check */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\treturn xfs_btree_check_lptr(cur,\n\t\t\t\tbe64_to_cpu((&ptr->l)[index]), level);\n\t} else {\n\t\treturn xfs_btree_check_sptr(cur,\n\t\t\t\tbe32_to_cpu((&ptr->s)[index]), level);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_addr",
          "args": [
            "cur",
            "keyno",
            "block"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "494-506",
          "snippet": "xfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->key_diff",
          "args": [
            "cur",
            "kp"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_lookup_get_search_key",
          "args": [
            "cur",
            "level",
            "keyno",
            "block",
            "&key"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_lookup_get_search_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1675-1690",
          "snippet": "xfs_btree_key *\nxfs_lookup_get_search_key(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\tkeyno,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_key\t*kp)\n{\n\tif (level == 0) {\n\t\tcur->bc_ops->init_key_from_rec(kp,\n\t\t\t\txfs_btree_rec_addr(cur, keyno, block));\n\t\treturn kp;\n\t}\n\n\treturn xfs_btree_key_addr(cur, keyno, block);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_key *\nxfs_lookup_get_search_key(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\tkeyno,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_key\t*kp)\n{\n\tif (level == 0) {\n\t\tcur->bc_ops->init_key_from_rec(kp,\n\t\t\t\txfs_btree_rec_addr(cur, keyno, block));\n\t\treturn kp;\n\t}\n\n\treturn xfs_btree_key_addr(cur, keyno, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_INC",
          "args": [
            "cur",
            "compare"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "level == 0 && cur->bc_nlevels == 1"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_lookup_get_block",
          "args": [
            "cur",
            "level",
            "pp",
            "&block"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_lookup_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1633-1668",
          "snippet": "STATIC int\nxfs_btree_lookup_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in the btree */\n\tunion xfs_btree_ptr\t*pp,\t/* ptr to btree block */\n\tstruct xfs_btree_block\t**blkp) /* return btree block */\n{\n\tstruct xfs_buf\t\t*bp;\t/* buffer pointer for btree block */\n\tint\t\t\terror = 0;\n\n\t/* special case the root block if in an inode */\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*blkp = xfs_btree_get_iroot(cur);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the old buffer at this level for the disk address we are\n\t * looking for re-use it.\n\t *\n\t * Otherwise throw it away and get a new one.\n\t */\n\tbp = cur->bc_bufs[level];\n\tif (bp && XFS_BUF_ADDR(bp) == xfs_btree_ptr_to_daddr(cur, pp)) {\n\t\t*blkp = XFS_BUF_TO_BLOCK(bp);\n\t\treturn 0;\n\t}\n\n\terror = xfs_btree_read_buf_block(cur, pp, 0, blkp, &bp);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_setbuf(cur, level, bp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_lookup_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in the btree */\n\tunion xfs_btree_ptr\t*pp,\t/* ptr to btree block */\n\tstruct xfs_btree_block\t**blkp) /* return btree block */\n{\n\tstruct xfs_buf\t\t*bp;\t/* buffer pointer for btree block */\n\tint\t\t\terror = 0;\n\n\t/* special case the root block if in an inode */\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*blkp = xfs_btree_get_iroot(cur);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the old buffer at this level for the disk address we are\n\t * looking for re-use it.\n\t *\n\t * Otherwise throw it away and get a new one.\n\t */\n\tbp = cur->bc_bufs[level];\n\tif (bp && XFS_BUF_ADDR(bp) == xfs_btree_ptr_to_daddr(cur, pp)) {\n\t\t*blkp = XFS_BUF_TO_BLOCK(bp);\n\t\treturn 0;\n\t}\n\n\terror = xfs_btree_read_buf_block(cur, pp, 0, blkp, &bp);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_setbuf(cur, level, bp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->init_ptr_from_cur",
          "args": [
            "cur",
            "&ptr"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_INC",
          "args": [
            "cur",
            "lookup"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_ARGI",
          "args": [
            "cur",
            "dir"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ENTRY"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t/* error */\nxfs_btree_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_lookup_t\t\tdir,\t/* <=, ==, or >= */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\t__int64_t\t\tdiff;\t/* difference for the current key */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tkeyno;\t/* current key number */\n\tint\t\t\tlevel;\t/* level in the btree */\n\tunion xfs_btree_ptr\t*pp;\t/* ptr to btree block */\n\tunion xfs_btree_ptr\tptr;\t/* ptr to btree block */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, dir);\n\n\tXFS_BTREE_STATS_INC(cur, lookup);\n\n\tblock = NULL;\n\tkeyno = 0;\n\n\t/* initialise start pointer from cursor */\n\tcur->bc_ops->init_ptr_from_cur(cur, &ptr);\n\tpp = &ptr;\n\n\t/*\n\t * Iterate over each level in the btree, starting at the root.\n\t * For each level above the leaves, find the key we need, based\n\t * on the lookup record, then follow the corresponding block\n\t * pointer down to the next level.\n\t */\n\tfor (level = cur->bc_nlevels - 1, diff = 1; level >= 0; level--) {\n\t\t/* Get the block we need to do the lookup on. */\n\t\terror = xfs_btree_lookup_get_block(cur, level, pp, &block);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\tif (diff == 0) {\n\t\t\t/*\n\t\t\t * If we already had a key match at a higher level, we\n\t\t\t * know we need to use the first entry in this block.\n\t\t\t */\n\t\t\tkeyno = 1;\n\t\t} else {\n\t\t\t/* Otherwise search this block. Do a binary search. */\n\n\t\t\tint\thigh;\t/* high entry number */\n\t\t\tint\tlow;\t/* low entry number */\n\n\t\t\t/* Set low and high entry numbers, 1-based. */\n\t\t\tlow = 1;\n\t\t\thigh = xfs_btree_get_numrecs(block);\n\t\t\tif (!high) {\n\t\t\t\t/* Block is empty, must be an empty leaf. */\n\t\t\t\tASSERT(level == 0 && cur->bc_nlevels == 1);\n\n\t\t\t\tcur->bc_ptrs[0] = dir != XFS_LOOKUP_LE;\n\t\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t\t*stat = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Binary search the block. */\n\t\t\twhile (low <= high) {\n\t\t\t\tunion xfs_btree_key\tkey;\n\t\t\t\tunion xfs_btree_key\t*kp;\n\n\t\t\t\tXFS_BTREE_STATS_INC(cur, compare);\n\n\t\t\t\t/* keyno is average of low and high. */\n\t\t\t\tkeyno = (low + high) >> 1;\n\n\t\t\t\t/* Get current search key */\n\t\t\t\tkp = xfs_lookup_get_search_key(cur, level,\n\t\t\t\t\t\tkeyno, block, &key);\n\n\t\t\t\t/*\n\t\t\t\t * Compute difference to get next direction:\n\t\t\t\t *  - less than, move right\n\t\t\t\t *  - greater than, move left\n\t\t\t\t *  - equal, we're done\n\t\t\t\t */\n\t\t\t\tdiff = cur->bc_ops->key_diff(cur, kp);\n\t\t\t\tif (diff < 0)\n\t\t\t\t\tlow = keyno + 1;\n\t\t\t\telse if (diff > 0)\n\t\t\t\t\thigh = keyno - 1;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If there are more levels, set up for the next level\n\t\t * by getting the block number and filling in the cursor.\n\t\t */\n\t\tif (level > 0) {\n\t\t\t/*\n\t\t\t * If we moved left, need the previous key number,\n\t\t\t * unless there isn't one.\n\t\t\t */\n\t\t\tif (diff > 0 && --keyno < 1)\n\t\t\t\tkeyno = 1;\n\t\t\tpp = xfs_btree_ptr_addr(cur, keyno, block);\n\n#ifdef DEBUG\n\t\t\terror = xfs_btree_check_ptr(cur, pp, 0, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n#endif\n\t\t\tcur->bc_ptrs[level] = keyno;\n\t\t}\n\t}\n\n\t/* Done with the search. See if we need to adjust the results. */\n\tif (dir != XFS_LOOKUP_LE && diff < 0) {\n\t\tkeyno++;\n\t\t/*\n\t\t * If ge search and we went off the end of the block, but it's\n\t\t * not the last block, we're in the wrong block.\n\t\t */\n\t\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\t\tif (dir == XFS_LOOKUP_GE &&\n\t\t    keyno > xfs_btree_get_numrecs(block) &&\n\t\t    !xfs_btree_ptr_is_null(cur, &ptr)) {\n\t\t\tint\ti;\n\n\t\t\tcur->bc_ptrs[0] = keyno;\n\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t*stat = 1;\n\t\t\treturn 0;\n\t\t}\n\t} else if (dir == XFS_LOOKUP_LE && diff > 0)\n\t\tkeyno--;\n\tcur->bc_ptrs[0] = keyno;\n\n\t/* Return if we succeeded or not. */\n\tif (keyno == 0 || keyno > xfs_btree_get_numrecs(block))\n\t\t*stat = 0;\n\telse if (dir != XFS_LOOKUP_EQ || diff == 0)\n\t\t*stat = 1;\n\telse\n\t\t*stat = 0;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_lookup_get_search_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "1675-1690",
    "snippet": "xfs_btree_key *\nxfs_lookup_get_search_key(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\tkeyno,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_key\t*kp)\n{\n\tif (level == 0) {\n\t\tcur->bc_ops->init_key_from_rec(kp,\n\t\t\t\txfs_btree_rec_addr(cur, keyno, block));\n\t\treturn kp;\n\t}\n\n\treturn xfs_btree_key_addr(cur, keyno, block);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_key_addr",
          "args": [
            "cur",
            "keyno",
            "block"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_key_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "481-489",
          "snippet": "xfs_btree_key *\nxfs_btree_key_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_key *)\n\t\t((char *)block + xfs_btree_key_offset(cur, n));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_key *\nxfs_btree_key_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_key *)\n\t\t((char *)block + xfs_btree_key_offset(cur, n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->init_key_from_rec",
          "args": [
            "kp",
            "xfs_btree_rec_addr(cur, keyno, block)"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_rec_addr",
          "args": [
            "cur",
            "keyno",
            "block"
          ],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_rec_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "468-476",
          "snippet": "xfs_btree_rec *\nxfs_btree_rec_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_rec *)\n\t\t((char *)block + xfs_btree_rec_offset(cur, n));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_rec *\nxfs_btree_rec_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_rec *)\n\t\t((char *)block + xfs_btree_rec_offset(cur, n));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_key *\nxfs_lookup_get_search_key(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\tkeyno,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_key\t*kp)\n{\n\tif (level == 0) {\n\t\tcur->bc_ops->init_key_from_rec(kp,\n\t\t\t\txfs_btree_rec_addr(cur, keyno, block));\n\t\treturn kp;\n\t}\n\n\treturn xfs_btree_key_addr(cur, keyno, block);\n}"
  },
  {
    "function_name": "xfs_btree_lookup_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "1633-1668",
    "snippet": "STATIC int\nxfs_btree_lookup_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in the btree */\n\tunion xfs_btree_ptr\t*pp,\t/* ptr to btree block */\n\tstruct xfs_btree_block\t**blkp) /* return btree block */\n{\n\tstruct xfs_buf\t\t*bp;\t/* buffer pointer for btree block */\n\tint\t\t\terror = 0;\n\n\t/* special case the root block if in an inode */\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*blkp = xfs_btree_get_iroot(cur);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the old buffer at this level for the disk address we are\n\t * looking for re-use it.\n\t *\n\t * Otherwise throw it away and get a new one.\n\t */\n\tbp = cur->bc_bufs[level];\n\tif (bp && XFS_BUF_ADDR(bp) == xfs_btree_ptr_to_daddr(cur, pp)) {\n\t\t*blkp = XFS_BUF_TO_BLOCK(bp);\n\t\treturn 0;\n\t}\n\n\terror = xfs_btree_read_buf_block(cur, pp, 0, blkp, &bp);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_setbuf(cur, level, bp);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_setbuf",
          "args": [
            "cur",
            "level",
            "bp"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_setbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "886-911",
          "snippet": "STATIC void\nxfs_btree_setbuf(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlev,\t/* level in btree */\n\txfs_buf_t\t\t*bp)\t/* new buffer to set */\n{\n\tstruct xfs_btree_block\t*b;\t/* btree block */\n\n\tif (cur->bc_bufs[lev])\n\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[lev]);\n\tcur->bc_bufs[lev] = bp;\n\tcur->bc_ra[lev] = 0;\n\n\tb = XFS_BUF_TO_BLOCK(bp);\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (b->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t} else {\n\t\tif (b->bb_u.s.bb_leftsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.s.bb_rightsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_setbuf(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlev,\t/* level in btree */\n\txfs_buf_t\t\t*bp)\t/* new buffer to set */\n{\n\tstruct xfs_btree_block\t*b;\t/* btree block */\n\n\tif (cur->bc_bufs[lev])\n\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[lev]);\n\tcur->bc_bufs[lev] = bp;\n\tcur->bc_ra[lev] = 0;\n\n\tb = XFS_BUF_TO_BLOCK(bp);\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (b->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t} else {\n\t\tif (b->bb_u.s.bb_leftsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.s.bb_rightsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_read_buf_block",
          "args": [
            "cur",
            "pp",
            "0",
            "blkp",
            "&bp"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_read_buf_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1152-1177",
          "snippet": "STATIC int\nxfs_btree_read_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\tint\t\t\terror;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\terror = xfs_trans_read_buf(mp, cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, flags, bpp,\n\t\t\t\t   cur->bc_ops->buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_set_refs(cur, *bpp);\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_read_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\tint\t\t\terror;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\terror = xfs_trans_read_buf(mp, cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, flags, bpp,\n\t\t\t\t   cur->bc_ops->buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_set_refs(cur, *bpp);\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "bp"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_to_daddr",
          "args": [
            "cur",
            "pp"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_to_daddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "847-863",
          "snippet": "STATIC xfs_daddr_t\nxfs_btree_ptr_to_daddr(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tASSERT(ptr->l != cpu_to_be64(NULLFSBLOCK));\n\n\t\treturn XFS_FSB_TO_DADDR(cur->bc_mp, be64_to_cpu(ptr->l));\n\t} else {\n\t\tASSERT(cur->bc_private.a.agno != NULLAGNUMBER);\n\t\tASSERT(ptr->s != cpu_to_be32(NULLAGBLOCK));\n\n\t\treturn XFS_AGB_TO_DADDR(cur->bc_mp, cur->bc_private.a.agno,\n\t\t\t\t\tbe32_to_cpu(ptr->s));\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC xfs_daddr_t\nxfs_btree_ptr_to_daddr(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tASSERT(ptr->l != cpu_to_be64(NULLFSBLOCK));\n\n\t\treturn XFS_FSB_TO_DADDR(cur->bc_mp, be64_to_cpu(ptr->l));\n\t} else {\n\t\tASSERT(cur->bc_private.a.agno != NULLAGNUMBER);\n\t\tASSERT(ptr->s != cpu_to_be32(NULLAGBLOCK));\n\n\t\treturn XFS_AGB_TO_DADDR(cur->bc_mp, cur->bc_private.a.agno,\n\t\t\t\t\tbe32_to_cpu(ptr->s));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ADDR",
          "args": [
            "bp"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_iroot",
          "args": [
            "cur"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_iroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "514-522",
          "snippet": "xfs_btree_block *\nxfs_btree_get_iroot(\n       struct xfs_btree_cur    *cur)\n{\n       struct xfs_ifork        *ifp;\n\n       ifp = XFS_IFORK_PTR(cur->bc_private.b.ip, cur->bc_private.b.whichfork);\n       return (struct xfs_btree_block *)ifp->if_broot;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_btree_block *\nxfs_btree_get_iroot(\n       struct xfs_btree_cur    *cur)\n{\n       struct xfs_ifork        *ifp;\n\n       ifp = XFS_IFORK_PTR(cur->bc_private.b.ip, cur->bc_private.b.whichfork);\n       return (struct xfs_btree_block *)ifp->if_broot;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_lookup_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in the btree */\n\tunion xfs_btree_ptr\t*pp,\t/* ptr to btree block */\n\tstruct xfs_btree_block\t**blkp) /* return btree block */\n{\n\tstruct xfs_buf\t\t*bp;\t/* buffer pointer for btree block */\n\tint\t\t\terror = 0;\n\n\t/* special case the root block if in an inode */\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*blkp = xfs_btree_get_iroot(cur);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the old buffer at this level for the disk address we are\n\t * looking for re-use it.\n\t *\n\t * Otherwise throw it away and get a new one.\n\t */\n\tbp = cur->bc_bufs[level];\n\tif (bp && XFS_BUF_ADDR(bp) == xfs_btree_ptr_to_daddr(cur, pp)) {\n\t\t*blkp = XFS_BUF_TO_BLOCK(bp);\n\t\treturn 0;\n\t}\n\n\terror = xfs_btree_read_buf_block(cur, pp, 0, blkp, &bp);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_setbuf(cur, level, bp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_btree_decrement",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "1539-1631",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ERROR"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_numrecs",
          "args": [
            "block"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_numrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "416-419",
          "snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_setbuf",
          "args": [
            "cur",
            "lev",
            "bp"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_setbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "886-911",
          "snippet": "STATIC void\nxfs_btree_setbuf(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlev,\t/* level in btree */\n\txfs_buf_t\t\t*bp)\t/* new buffer to set */\n{\n\tstruct xfs_btree_block\t*b;\t/* btree block */\n\n\tif (cur->bc_bufs[lev])\n\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[lev]);\n\tcur->bc_bufs[lev] = bp;\n\tcur->bc_ra[lev] = 0;\n\n\tb = XFS_BUF_TO_BLOCK(bp);\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (b->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t} else {\n\t\tif (b->bb_u.s.bb_leftsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.s.bb_rightsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_setbuf(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlev,\t/* level in btree */\n\txfs_buf_t\t\t*bp)\t/* new buffer to set */\n{\n\tstruct xfs_btree_block\t*b;\t/* btree block */\n\n\tif (cur->bc_bufs[lev])\n\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[lev]);\n\tcur->bc_bufs[lev] = bp;\n\tcur->bc_ra[lev] = 0;\n\n\tb = XFS_BUF_TO_BLOCK(bp);\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (b->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t} else {\n\t\tif (b->bb_u.s.bb_leftsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.s.bb_rightsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_read_buf_block",
          "args": [
            "cur",
            "ptrp",
            "0",
            "&block",
            "&bp"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_read_buf_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1152-1177",
          "snippet": "STATIC int\nxfs_btree_read_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\tint\t\t\terror;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\terror = xfs_trans_read_buf(mp, cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, flags, bpp,\n\t\t\t\t   cur->bc_ops->buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_set_refs(cur, *bpp);\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_read_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\tint\t\t\terror;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\terror = xfs_trans_read_buf(mp, cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, flags, bpp,\n\t\t\t\t   cur->bc_ops->buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_set_refs(cur, *bpp);\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_addr",
          "args": [
            "cur",
            "cur->bc_ptrs[lev]",
            "block"
          ],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "494-506",
          "snippet": "xfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_block",
          "args": [
            "cur",
            "lev",
            "&bp"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "528-542",
          "snippet": "xfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "lev < cur->bc_nlevels"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_readahead",
          "args": [
            "cur",
            "lev",
            "XFS_BTCUR_LEFTRA"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_readahead_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "871-880",
          "snippet": "STATIC void\nxfs_btree_readahead_ptr(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\txfs_extlen_t\t\tcount)\n{\n\txfs_buf_readahead(cur->bc_mp->m_ddev_targp,\n\t\t\t  xfs_btree_ptr_to_daddr(cur, ptr),\n\t\t\t  cur->bc_mp->m_bsize * count, cur->bc_ops->buf_ops);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_readahead_ptr(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\txfs_extlen_t\t\tcount)\n{\n\txfs_buf_readahead(cur->bc_mp->m_ddev_targp,\n\t\t\t  xfs_btree_ptr_to_daddr(cur, ptr),\n\t\t\t  cur->bc_mp->m_bsize * count, cur->bc_ops->buf_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_INC",
          "args": [
            "cur",
            "decrement"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_is_null",
          "args": [
            "cur",
            "&ptr"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_is_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "913-922",
          "snippet": "STATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_sibling",
          "args": [
            "cur",
            "block",
            "&ptr",
            "XFS_BB_LEFTSIB"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_sibling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "938-958",
          "snippet": "STATIC void\nxfs_btree_get_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->l = block->bb_u.l.bb_rightsib;\n\t\telse\n\t\t\tptr->l = block->bb_u.l.bb_leftsib;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->s = block->bb_u.s.bb_rightsib;\n\t\telse\n\t\t\tptr->s = block->bb_u.s.bb_leftsib;\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_get_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->l = block->bb_u.l.bb_rightsib;\n\t\telse\n\t\t\tptr->l = block->bb_u.l.bb_leftsib;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->s = block->bb_u.s.bb_rightsib;\n\t\telse\n\t\t\tptr->s = block->bb_u.s.bb_leftsib;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_check_block",
          "args": [
            "cur",
            "block",
            "level",
            "bp"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "149-160",
          "snippet": "int\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "level < cur->bc_nlevels"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_ARGI",
          "args": [
            "cur",
            "level"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ENTRY"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_btree_increment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "1431-1533",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ERROR"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_setbuf",
          "args": [
            "cur",
            "lev",
            "bp"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_setbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "886-911",
          "snippet": "STATIC void\nxfs_btree_setbuf(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlev,\t/* level in btree */\n\txfs_buf_t\t\t*bp)\t/* new buffer to set */\n{\n\tstruct xfs_btree_block\t*b;\t/* btree block */\n\n\tif (cur->bc_bufs[lev])\n\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[lev]);\n\tcur->bc_bufs[lev] = bp;\n\tcur->bc_ra[lev] = 0;\n\n\tb = XFS_BUF_TO_BLOCK(bp);\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (b->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t} else {\n\t\tif (b->bb_u.s.bb_leftsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.s.bb_rightsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_setbuf(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlev,\t/* level in btree */\n\txfs_buf_t\t\t*bp)\t/* new buffer to set */\n{\n\tstruct xfs_btree_block\t*b;\t/* btree block */\n\n\tif (cur->bc_bufs[lev])\n\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[lev]);\n\tcur->bc_bufs[lev] = bp;\n\tcur->bc_ra[lev] = 0;\n\n\tb = XFS_BUF_TO_BLOCK(bp);\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (b->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t} else {\n\t\tif (b->bb_u.s.bb_leftsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.s.bb_rightsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_read_buf_block",
          "args": [
            "cur",
            "ptrp",
            "0",
            "&block",
            "&bp"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_read_buf_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1152-1177",
          "snippet": "STATIC int\nxfs_btree_read_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\tint\t\t\terror;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\terror = xfs_trans_read_buf(mp, cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, flags, bpp,\n\t\t\t\t   cur->bc_ops->buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_set_refs(cur, *bpp);\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_read_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\tint\t\t\terror;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\terror = xfs_trans_read_buf(mp, cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, flags, bpp,\n\t\t\t\t   cur->bc_ops->buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_set_refs(cur, *bpp);\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_addr",
          "args": [
            "cur",
            "cur->bc_ptrs[lev]",
            "block"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "494-506",
          "snippet": "xfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_block",
          "args": [
            "cur",
            "lev",
            "&bp"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "528-542",
          "snippet": "xfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "lev < cur->bc_nlevels"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_readahead",
          "args": [
            "cur",
            "lev",
            "XFS_BTCUR_RIGHTRA"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_readahead_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "871-880",
          "snippet": "STATIC void\nxfs_btree_readahead_ptr(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\txfs_extlen_t\t\tcount)\n{\n\txfs_buf_readahead(cur->bc_mp->m_ddev_targp,\n\t\t\t  xfs_btree_ptr_to_daddr(cur, ptr),\n\t\t\t  cur->bc_mp->m_bsize * count, cur->bc_ops->buf_ops);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_readahead_ptr(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\txfs_extlen_t\t\tcount)\n{\n\txfs_buf_readahead(cur->bc_mp->m_ddev_targp,\n\t\t\t  xfs_btree_ptr_to_daddr(cur, ptr),\n\t\t\t  cur->bc_mp->m_bsize * count, cur->bc_ops->buf_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_numrecs",
          "args": [
            "block"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_numrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "416-419",
          "snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_check_block",
          "args": [
            "cur",
            "block",
            "lev",
            "bp"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "149-160",
          "snippet": "int\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_STATS_INC",
          "args": [
            "cur",
            "increment"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_is_null",
          "args": [
            "cur",
            "&ptr"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_is_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "913-922",
          "snippet": "STATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_sibling",
          "args": [
            "cur",
            "block",
            "&ptr",
            "XFS_BB_RIGHTSIB"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_sibling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "938-958",
          "snippet": "STATIC void\nxfs_btree_get_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->l = block->bb_u.l.bb_rightsib;\n\t\telse\n\t\t\tptr->l = block->bb_u.l.bb_leftsib;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->s = block->bb_u.s.bb_rightsib;\n\t\telse\n\t\t\tptr->s = block->bb_u.s.bb_leftsib;\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_get_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->l = block->bb_u.l.bb_rightsib;\n\t\telse\n\t\t\tptr->l = block->bb_u.l.bb_leftsib;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->s = block->bb_u.s.bb_rightsib;\n\t\telse\n\t\t\tptr->s = block->bb_u.s.bb_leftsib;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "level < cur->bc_nlevels"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_ARGI",
          "args": [
            "cur",
            "level"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ENTRY"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_btree_log_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "1357-1425",
    "snippet": "void\nxfs_btree_log_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfields)\t/* mask of fields: XFS_BB_... */\n{\n\tint\t\t\tfirst;\t/* first byte offset logged */\n\tint\t\t\tlast;\t/* last byte offset logged */\n\tstatic const short\tsoffsets[] = {\t/* table of offsets (short) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_crc),\n\t\tXFS_BTREE_SBLOCK_CRC_LEN\n\t};\n\tstatic const short\tloffsets[] = {\t/* table of offsets (long) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_crc),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_pad),\n\t\tXFS_BTREE_LBLOCK_CRC_LEN\n\t};\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBI(cur, bp, fields);\n\n\tif (bp) {\n\t\tint nbits;\n\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\t/*\n\t\t\t * We don't log the CRC when updating a btree\n\t\t\t * block but instead recreate it during log\n\t\t\t * recovery.  As the log buffers have checksums\n\t\t\t * of their own this is safe and avoids logging a crc\n\t\t\t * update in a lot of places.\n\t\t\t */\n\t\t\tif (fields == XFS_BB_ALL_BITS)\n\t\t\t\tfields = XFS_BB_ALL_BITS_CRC;\n\t\t\tnbits = XFS_BB_NUM_BITS_CRC;\n\t\t} else {\n\t\t\tnbits = XFS_BB_NUM_BITS;\n\t\t}\n\t\txfs_btree_offsets(fields,\n\t\t\t\t  (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\t\t\t\tloffsets : soffsets,\n\t\t\t\t  nbits, &first, &last);\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp, first, last);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "cur->bc_tp",
            "cur->bc_private.b.ip",
            "xfs_ilog_fbroot(cur->bc_private.b.whichfork)"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilog_fbroot",
          "args": [
            "cur->bc_private.b.whichfork"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilog_fbroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "336-339",
          "snippet": "static inline int xfs_ilog_fbroot(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DBROOT : XFS_ILOG_ABROOT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_ILOG_ABROOT\t0x100\t/* log i_af.i_broot */",
            "#define\tXFS_ILOG_DBROOT\t0x008\t/* log i_df.i_broot */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_ILOG_ABROOT\t0x100\t/* log i_af.i_broot */\n#define\tXFS_ILOG_DBROOT\t0x008\t/* log i_df.i_broot */\n\nstatic inline int xfs_ilog_fbroot(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DBROOT : XFS_ILOG_ABROOT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "cur->bc_tp",
            "bp",
            "first",
            "last"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "cur->bc_tp",
            "bp",
            "XFS_BLFT_BTREE_BUF"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_offsets",
          "args": [
            "fields",
            "(cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\t\t\t\tloffsets : soffsets",
            "nbits",
            "&first",
            "&last"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_offsets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "663-693",
          "snippet": "void\nxfs_btree_offsets(\n\t__int64_t\tfields,\t\t/* bitmask of fields */\n\tconst short\t*offsets,\t/* table of field offsets */\n\tint\t\tnbits,\t\t/* number of bits to inspect */\n\tint\t\t*first,\t\t/* output: first byte offset */\n\tint\t\t*last)\t\t/* output: last byte offset */\n{\n\tint\t\ti;\t\t/* current bit number */\n\t__int64_t\timask;\t\t/* mask for current bit number */\n\n\tASSERT(fields != 0);\n\t/*\n\t * Find the lowest bit, so the first byte offset.\n\t */\n\tfor (i = 0, imask = 1LL; ; i++, imask <<= 1) {\n\t\tif (imask & fields) {\n\t\t\t*first = offsets[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * Find the highest bit, so the last byte offset.\n\t */\n\tfor (i = nbits - 1, imask = 1LL << i; ; i--, imask >>= 1) {\n\t\tif (imask & fields) {\n\t\t\t*last = offsets[i + 1] - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_btree_offsets(\n\t__int64_t\tfields,\t\t/* bitmask of fields */\n\tconst short\t*offsets,\t/* table of field offsets */\n\tint\t\tnbits,\t\t/* number of bits to inspect */\n\tint\t\t*first,\t\t/* output: first byte offset */\n\tint\t\t*last)\t\t/* output: last byte offset */\n{\n\tint\t\ti;\t\t/* current bit number */\n\t__int64_t\timask;\t\t/* mask for current bit number */\n\n\tASSERT(fields != 0);\n\t/*\n\t * Find the lowest bit, so the first byte offset.\n\t */\n\tfor (i = 0, imask = 1LL; ; i++, imask <<= 1) {\n\t\tif (imask & fields) {\n\t\t\t*first = offsets[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * Find the highest bit, so the last byte offset.\n\t */\n\tfor (i = nbits - 1, imask = 1LL << i; ; i--, imask >>= 1) {\n\t\tif (imask & fields) {\n\t\t\t*last = offsets[i + 1] - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_ARGBI",
          "args": [
            "cur",
            "bp",
            "fields"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ENTRY"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_log_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfields)\t/* mask of fields: XFS_BB_... */\n{\n\tint\t\t\tfirst;\t/* first byte offset logged */\n\tint\t\t\tlast;\t/* last byte offset logged */\n\tstatic const short\tsoffsets[] = {\t/* table of offsets (short) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_crc),\n\t\tXFS_BTREE_SBLOCK_CRC_LEN\n\t};\n\tstatic const short\tloffsets[] = {\t/* table of offsets (long) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_crc),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_pad),\n\t\tXFS_BTREE_LBLOCK_CRC_LEN\n\t};\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBI(cur, bp, fields);\n\n\tif (bp) {\n\t\tint nbits;\n\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\t/*\n\t\t\t * We don't log the CRC when updating a btree\n\t\t\t * block but instead recreate it during log\n\t\t\t * recovery.  As the log buffers have checksums\n\t\t\t * of their own this is safe and avoids logging a crc\n\t\t\t * update in a lot of places.\n\t\t\t */\n\t\t\tif (fields == XFS_BB_ALL_BITS)\n\t\t\t\tfields = XFS_BB_ALL_BITS_CRC;\n\t\t\tnbits = XFS_BB_NUM_BITS_CRC;\n\t\t} else {\n\t\t\tnbits = XFS_BB_NUM_BITS;\n\t\t}\n\t\txfs_btree_offsets(fields,\n\t\t\t\t  (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\t\t\t\tloffsets : soffsets,\n\t\t\t\t  nbits, &first, &last);\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp, first, last);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
  },
  {
    "function_name": "xfs_btree_log_ptrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "1328-1352",
    "snippet": "STATIC void\nxfs_btree_log_ptrs(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfirst,\t/* index of first pointer to log */\n\tint\t\t\tlast)\t/* index of last pointer to log */\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\t\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\txfs_btree_ptr_offset(cur, first, level),\n\t\t\t\txfs_btree_ptr_offset(cur, last + 1, level) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "cur->bc_tp",
            "cur->bc_private.b.ip",
            "xfs_ilog_fbroot(cur->bc_private.b.whichfork)"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilog_fbroot",
          "args": [
            "cur->bc_private.b.whichfork"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilog_fbroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "336-339",
          "snippet": "static inline int xfs_ilog_fbroot(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DBROOT : XFS_ILOG_ABROOT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_ILOG_ABROOT\t0x100\t/* log i_af.i_broot */",
            "#define\tXFS_ILOG_DBROOT\t0x008\t/* log i_df.i_broot */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_ILOG_ABROOT\t0x100\t/* log i_af.i_broot */\n#define\tXFS_ILOG_DBROOT\t0x008\t/* log i_df.i_broot */\n\nstatic inline int xfs_ilog_fbroot(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DBROOT : XFS_ILOG_ABROOT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "cur->bc_tp",
            "bp",
            "xfs_btree_ptr_offset(cur, first, level)",
            "xfs_btree_ptr_offset(cur, last + 1, level) - 1"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_offset",
          "args": [
            "cur",
            "last + 1",
            "level"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "454-463",
          "snippet": "STATIC size_t\nxfs_btree_ptr_offset(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tint\t\t\tlevel)\n{\n\treturn xfs_btree_block_len(cur) +\n\t\tcur->bc_ops->get_maxrecs(cur, level) * cur->bc_ops->key_len +\n\t\t(n - 1) * xfs_btree_ptr_len(cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC size_t\nxfs_btree_ptr_offset(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tint\t\t\tlevel)\n{\n\treturn xfs_btree_block_len(cur) +\n\t\tcur->bc_ops->get_maxrecs(cur, level) * cur->bc_ops->key_len +\n\t\t(n - 1) * xfs_btree_ptr_len(cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "cur->bc_tp",
            "bp",
            "XFS_BLFT_BTREE_BUF"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_level",
          "args": [
            "block"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "427-430",
          "snippet": "static inline int xfs_btree_get_level(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_level);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_btree_get_level(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "bp"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_ARGBII",
          "args": [
            "cur",
            "bp",
            "first",
            "last"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ENTRY"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_log_ptrs(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfirst,\t/* index of first pointer to log */\n\tint\t\t\tlast)\t/* index of last pointer to log */\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\t\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\txfs_btree_ptr_offset(cur, first, level),\n\t\t\t\txfs_btree_ptr_offset(cur, last + 1, level) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
  },
  {
    "function_name": "xfs_btree_log_recs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "1307-1323",
    "snippet": "void\nxfs_btree_log_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t  xfs_btree_rec_offset(cur, first),\n\t\t\t  xfs_btree_rec_offset(cur, last + 1) - 1);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "cur->bc_tp",
            "bp",
            "xfs_btree_rec_offset(cur, first)",
            "xfs_btree_rec_offset(cur, last + 1) - 1"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_rec_offset",
          "args": [
            "cur",
            "last + 1"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_rec_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "430-437",
          "snippet": "STATIC size_t\nxfs_btree_rec_offset(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn)\n{\n\treturn xfs_btree_block_len(cur) +\n\t\t(n - 1) * cur->bc_ops->rec_len;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC size_t\nxfs_btree_rec_offset(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn)\n{\n\treturn xfs_btree_block_len(cur) +\n\t\t(n - 1) * cur->bc_ops->rec_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "cur->bc_tp",
            "bp",
            "XFS_BLFT_BTREE_BUF"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_ARGBII",
          "args": [
            "cur",
            "bp",
            "first",
            "last"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ENTRY"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_log_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t  xfs_btree_rec_offset(cur, first),\n\t\t\t  xfs_btree_rec_offset(cur, last + 1) - 1);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
  },
  {
    "function_name": "xfs_btree_log_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "1281-1302",
    "snippet": "STATIC void\nxfs_btree_log_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\t  xfs_btree_key_offset(cur, first),\n\t\t\t\t  xfs_btree_key_offset(cur, last + 1) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "cur->bc_tp",
            "cur->bc_private.b.ip",
            "xfs_ilog_fbroot(cur->bc_private.b.whichfork)"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilog_fbroot",
          "args": [
            "cur->bc_private.b.whichfork"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilog_fbroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "336-339",
          "snippet": "static inline int xfs_ilog_fbroot(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DBROOT : XFS_ILOG_ABROOT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_ILOG_ABROOT\t0x100\t/* log i_af.i_broot */",
            "#define\tXFS_ILOG_DBROOT\t0x008\t/* log i_df.i_broot */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_ILOG_ABROOT\t0x100\t/* log i_af.i_broot */\n#define\tXFS_ILOG_DBROOT\t0x008\t/* log i_df.i_broot */\n\nstatic inline int xfs_ilog_fbroot(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DBROOT : XFS_ILOG_ABROOT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "cur->bc_tp",
            "bp",
            "xfs_btree_key_offset(cur, first)",
            "xfs_btree_key_offset(cur, last + 1) - 1"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_key_offset",
          "args": [
            "cur",
            "last + 1"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_key_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "442-449",
          "snippet": "STATIC size_t\nxfs_btree_key_offset(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn)\n{\n\treturn xfs_btree_block_len(cur) +\n\t\t(n - 1) * cur->bc_ops->key_len;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC size_t\nxfs_btree_key_offset(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn)\n{\n\treturn xfs_btree_block_len(cur) +\n\t\t(n - 1) * cur->bc_ops->key_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "cur->bc_tp",
            "bp",
            "XFS_BLFT_BTREE_BUF"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_ARGBII",
          "args": [
            "cur",
            "bp",
            "first",
            "last"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ENTRY"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_log_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\tif (bp) {\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t\t  xfs_btree_key_offset(cur, first),\n\t\t\t\t  xfs_btree_key_offset(cur, last + 1) - 1);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
  },
  {
    "function_name": "xfs_btree_shift_ptrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "1262-1276",
    "snippet": "STATIC void\nxfs_btree_shift_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tdir,\n\tint\t\t\tnumptrs)\n{\n\tchar\t\t\t*dst_ptr;\n\n\tASSERT(numptrs >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_ptr = (char *)ptr + (dir * xfs_btree_ptr_len(cur));\n\tmemmove(dst_ptr, ptr, numptrs * xfs_btree_ptr_len(cur));\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "dst_ptr",
            "ptr",
            "numptrs * xfs_btree_ptr_len(cur)"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_len",
          "args": [
            "cur"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "421-425",
          "snippet": "static inline size_t xfs_btree_ptr_len(struct xfs_btree_cur *cur)\n{\n\treturn (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\tsizeof(__be64) : sizeof(__be32);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic inline size_t xfs_btree_ptr_len(struct xfs_btree_cur *cur)\n{\n\treturn (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\tsizeof(__be64) : sizeof(__be32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dir == 1 || dir == -1"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "numptrs >= 0"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_shift_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tdir,\n\tint\t\t\tnumptrs)\n{\n\tchar\t\t\t*dst_ptr;\n\n\tASSERT(numptrs >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_ptr = (char *)ptr + (dir * xfs_btree_ptr_len(cur));\n\tmemmove(dst_ptr, ptr, numptrs * xfs_btree_ptr_len(cur));\n}"
  },
  {
    "function_name": "xfs_btree_shift_recs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "1243-1257",
    "snippet": "STATIC void\nxfs_btree_shift_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*rec,\n\tint\t\t\tdir,\n\tint\t\t\tnumrecs)\n{\n\tchar\t\t\t*dst_rec;\n\n\tASSERT(numrecs >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_rec = (char *)rec + (dir * cur->bc_ops->rec_len);\n\tmemmove(dst_rec, rec, numrecs * cur->bc_ops->rec_len);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "dst_rec",
            "rec",
            "numrecs * cur->bc_ops->rec_len"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dir == 1 || dir == -1"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "numrecs >= 0"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_shift_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*rec,\n\tint\t\t\tdir,\n\tint\t\t\tnumrecs)\n{\n\tchar\t\t\t*dst_rec;\n\n\tASSERT(numrecs >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_rec = (char *)rec + (dir * cur->bc_ops->rec_len);\n\tmemmove(dst_rec, rec, numrecs * cur->bc_ops->rec_len);\n}"
  },
  {
    "function_name": "xfs_btree_shift_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "1224-1238",
    "snippet": "STATIC void\nxfs_btree_shift_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*key,\n\tint\t\t\tdir,\n\tint\t\t\tnumkeys)\n{\n\tchar\t\t\t*dst_key;\n\n\tASSERT(numkeys >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_key = (char *)key + (dir * cur->bc_ops->key_len);\n\tmemmove(dst_key, key, numkeys * cur->bc_ops->key_len);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "dst_key",
            "key",
            "numkeys * cur->bc_ops->key_len"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dir == 1 || dir == -1"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "numkeys >= 0"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_shift_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*key,\n\tint\t\t\tdir,\n\tint\t\t\tnumkeys)\n{\n\tchar\t\t\t*dst_key;\n\n\tASSERT(numkeys >= 0);\n\tASSERT(dir == 1 || dir == -1);\n\n\tdst_key = (char *)key + (dir * cur->bc_ops->key_len);\n\tmemmove(dst_key, key, numkeys * cur->bc_ops->key_len);\n}"
  },
  {
    "function_name": "xfs_btree_copy_ptrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "1210-1219",
    "snippet": "STATIC void\nxfs_btree_copy_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*dst_ptr,\n\tunion xfs_btree_ptr\t*src_ptr,\n\tint\t\t\tnumptrs)\n{\n\tASSERT(numptrs >= 0);\n\tmemcpy(dst_ptr, src_ptr, numptrs * xfs_btree_ptr_len(cur));\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst_ptr",
            "src_ptr",
            "numptrs * xfs_btree_ptr_len(cur)"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_len",
          "args": [
            "cur"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "421-425",
          "snippet": "static inline size_t xfs_btree_ptr_len(struct xfs_btree_cur *cur)\n{\n\treturn (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\tsizeof(__be64) : sizeof(__be32);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic inline size_t xfs_btree_ptr_len(struct xfs_btree_cur *cur)\n{\n\treturn (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\tsizeof(__be64) : sizeof(__be32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "numptrs >= 0"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_ptrs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*dst_ptr,\n\tunion xfs_btree_ptr\t*src_ptr,\n\tint\t\t\tnumptrs)\n{\n\tASSERT(numptrs >= 0);\n\tmemcpy(dst_ptr, src_ptr, numptrs * xfs_btree_ptr_len(cur));\n}"
  },
  {
    "function_name": "xfs_btree_copy_recs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "1196-1205",
    "snippet": "STATIC void\nxfs_btree_copy_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*dst_rec,\n\tunion xfs_btree_rec\t*src_rec,\n\tint\t\t\tnumrecs)\n{\n\tASSERT(numrecs >= 0);\n\tmemcpy(dst_rec, src_rec, numrecs * cur->bc_ops->rec_len);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst_rec",
            "src_rec",
            "numrecs * cur->bc_ops->rec_len"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "numrecs >= 0"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*dst_rec,\n\tunion xfs_btree_rec\t*src_rec,\n\tint\t\t\tnumrecs)\n{\n\tASSERT(numrecs >= 0);\n\tmemcpy(dst_rec, src_rec, numrecs * cur->bc_ops->rec_len);\n}"
  },
  {
    "function_name": "xfs_btree_copy_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "1182-1191",
    "snippet": "STATIC void\nxfs_btree_copy_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*dst_key,\n\tunion xfs_btree_key\t*src_key,\n\tint\t\t\tnumkeys)\n{\n\tASSERT(numkeys >= 0);\n\tmemcpy(dst_key, src_key, numkeys * cur->bc_ops->key_len);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst_key",
            "src_key",
            "numkeys * cur->bc_ops->key_len"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "numkeys >= 0"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_copy_keys(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*dst_key,\n\tunion xfs_btree_key\t*src_key,\n\tint\t\t\tnumkeys)\n{\n\tASSERT(numkeys >= 0);\n\tmemcpy(dst_key, src_key, numkeys * cur->bc_ops->key_len);\n}"
  },
  {
    "function_name": "xfs_btree_read_buf_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "1152-1177",
    "snippet": "STATIC int\nxfs_btree_read_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\tint\t\t\terror;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\terror = xfs_trans_read_buf(mp, cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, flags, bpp,\n\t\t\t\t   cur->bc_ops->buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_set_refs(cur, *bpp);\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "*bpp"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_set_refs",
          "args": [
            "cur",
            "*bpp"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_set_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1100-1120",
          "snippet": "STATIC void\nxfs_btree_set_refs(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp)\n{\n\tswitch (cur->bc_btnum) {\n\tcase XFS_BTNUM_BNO:\n\tcase XFS_BTNUM_CNT:\n\t\txfs_buf_set_ref(bp, XFS_ALLOC_BTREE_REF);\n\t\tbreak;\n\tcase XFS_BTNUM_INO:\n\tcase XFS_BTNUM_FINO:\n\t\txfs_buf_set_ref(bp, XFS_INO_BTREE_REF);\n\t\tbreak;\n\tcase XFS_BTNUM_BMAP:\n\t\txfs_buf_set_ref(bp, XFS_BMAP_BTREE_REF);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_set_refs(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp)\n{\n\tswitch (cur->bc_btnum) {\n\tcase XFS_BTNUM_BNO:\n\tcase XFS_BTNUM_CNT:\n\t\txfs_buf_set_ref(bp, XFS_ALLOC_BTREE_REF);\n\t\tbreak;\n\tcase XFS_BTNUM_INO:\n\tcase XFS_BTNUM_FINO:\n\t\txfs_buf_set_ref(bp, XFS_INO_BTREE_REF);\n\t\tbreak;\n\tcase XFS_BTNUM_BMAP:\n\t\txfs_buf_set_ref(bp, XFS_BMAP_BTREE_REF);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_read_buf",
          "args": [
            "mp",
            "cur->bc_tp",
            "mp->m_ddev_targp",
            "d",
            "mp->m_bsize",
            "flags",
            "bpp",
            "cur->bc_ops->buf_ops"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "186-200",
          "snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_to_daddr",
          "args": [
            "cur",
            "ptr"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_to_daddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "847-863",
          "snippet": "STATIC xfs_daddr_t\nxfs_btree_ptr_to_daddr(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tASSERT(ptr->l != cpu_to_be64(NULLFSBLOCK));\n\n\t\treturn XFS_FSB_TO_DADDR(cur->bc_mp, be64_to_cpu(ptr->l));\n\t} else {\n\t\tASSERT(cur->bc_private.a.agno != NULLAGNUMBER);\n\t\tASSERT(ptr->s != cpu_to_be32(NULLAGBLOCK));\n\n\t\treturn XFS_AGB_TO_DADDR(cur->bc_mp, cur->bc_private.a.agno,\n\t\t\t\t\tbe32_to_cpu(ptr->s));\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC xfs_daddr_t\nxfs_btree_ptr_to_daddr(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tASSERT(ptr->l != cpu_to_be64(NULLFSBLOCK));\n\n\t\treturn XFS_FSB_TO_DADDR(cur->bc_mp, be64_to_cpu(ptr->l));\n\t} else {\n\t\tASSERT(cur->bc_private.a.agno != NULLAGNUMBER);\n\t\tASSERT(ptr->s != cpu_to_be32(NULLAGBLOCK));\n\n\t\treturn XFS_AGB_TO_DADDR(cur->bc_mp, cur->bc_private.a.agno,\n\t\t\t\t\tbe32_to_cpu(ptr->s));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(flags & XBF_TRYLOCK)"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_read_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\tint\t\t\terror;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\terror = xfs_trans_read_buf(mp, cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, flags, bpp,\n\t\t\t\t   cur->bc_ops->buf_ops);\n\tif (error)\n\t\treturn error;\n\n\txfs_btree_set_refs(cur, *bpp);\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_btree_get_buf_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "1122-1146",
    "snippet": "STATIC int\nxfs_btree_get_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\t*bpp = xfs_trans_get_buf(cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t mp->m_bsize, flags);\n\n\tif (!*bpp)\n\t\treturn -ENOMEM;\n\n\t(*bpp)->b_ops = cur->bc_ops->buf_ops;\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "*bpp"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_get_buf",
          "args": [
            "cur->bc_tp",
            "mp->m_ddev_targp",
            "d",
            "mp->m_bsize",
            "flags"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_get_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "166-176",
          "snippet": "static inline struct xfs_buf *\nxfs_trans_get_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\tuint\t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_get_buf_map(tp, target, &map, 1, flags);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_buf *\nxfs_trans_get_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\tuint\t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_get_buf_map(tp, target, &map, 1, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_to_daddr",
          "args": [
            "cur",
            "ptr"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_to_daddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "847-863",
          "snippet": "STATIC xfs_daddr_t\nxfs_btree_ptr_to_daddr(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tASSERT(ptr->l != cpu_to_be64(NULLFSBLOCK));\n\n\t\treturn XFS_FSB_TO_DADDR(cur->bc_mp, be64_to_cpu(ptr->l));\n\t} else {\n\t\tASSERT(cur->bc_private.a.agno != NULLAGNUMBER);\n\t\tASSERT(ptr->s != cpu_to_be32(NULLAGBLOCK));\n\n\t\treturn XFS_AGB_TO_DADDR(cur->bc_mp, cur->bc_private.a.agno,\n\t\t\t\t\tbe32_to_cpu(ptr->s));\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC xfs_daddr_t\nxfs_btree_ptr_to_daddr(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tASSERT(ptr->l != cpu_to_be64(NULLFSBLOCK));\n\n\t\treturn XFS_FSB_TO_DADDR(cur->bc_mp, be64_to_cpu(ptr->l));\n\t} else {\n\t\tASSERT(cur->bc_private.a.agno != NULLAGNUMBER);\n\t\tASSERT(ptr->s != cpu_to_be32(NULLAGBLOCK));\n\n\t\treturn XFS_AGB_TO_DADDR(cur->bc_mp, cur->bc_private.a.agno,\n\t\t\t\t\tbe32_to_cpu(ptr->s));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(flags & XBF_TRYLOCK)"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_get_buf_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tflags,\n\tstruct xfs_btree_block\t**block,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\txfs_daddr_t\t\td;\n\n\t/* need to sort out how callers deal with failures first */\n\tASSERT(!(flags & XBF_TRYLOCK));\n\n\td = xfs_btree_ptr_to_daddr(cur, ptr);\n\t*bpp = xfs_trans_get_buf(cur->bc_tp, mp->m_ddev_targp, d,\n\t\t\t\t mp->m_bsize, flags);\n\n\tif (!*bpp)\n\t\treturn -ENOMEM;\n\n\t(*bpp)->b_ops = cur->bc_ops->buf_ops;\n\t*block = XFS_BUF_TO_BLOCK(*bpp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_btree_set_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "1100-1120",
    "snippet": "STATIC void\nxfs_btree_set_refs(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp)\n{\n\tswitch (cur->bc_btnum) {\n\tcase XFS_BTNUM_BNO:\n\tcase XFS_BTNUM_CNT:\n\t\txfs_buf_set_ref(bp, XFS_ALLOC_BTREE_REF);\n\t\tbreak;\n\tcase XFS_BTNUM_INO:\n\tcase XFS_BTNUM_FINO:\n\t\txfs_buf_set_ref(bp, XFS_INO_BTREE_REF);\n\t\tbreak;\n\tcase XFS_BTNUM_BMAP:\n\t\txfs_buf_set_ref(bp, XFS_BMAP_BTREE_REF);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t}\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_set_ref",
          "args": [
            "bp",
            "XFS_BMAP_BTREE_REF"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_set_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "351-354",
          "snippet": "static inline void xfs_buf_set_ref(struct xfs_buf *bp, int lru_ref)\n{\n\tatomic_set(&bp->b_lru_ref, lru_ref);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_set_ref(struct xfs_buf *bp, int lru_ref)\n{\n\tatomic_set(&bp->b_lru_ref, lru_ref);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_set_refs(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp)\n{\n\tswitch (cur->bc_btnum) {\n\tcase XFS_BTNUM_BNO:\n\tcase XFS_BTNUM_CNT:\n\t\txfs_buf_set_ref(bp, XFS_ALLOC_BTREE_REF);\n\t\tbreak;\n\tcase XFS_BTNUM_INO:\n\tcase XFS_BTNUM_FINO:\n\t\txfs_buf_set_ref(bp, XFS_INO_BTREE_REF);\n\t\tbreak;\n\tcase XFS_BTNUM_BMAP:\n\t\txfs_buf_set_ref(bp, XFS_BMAP_BTREE_REF);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t}\n}"
  },
  {
    "function_name": "xfs_btree_buf_to_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "1085-1098",
    "snippet": "STATIC void\nxfs_btree_buf_to_ptr(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\tptr->l = cpu_to_be64(XFS_DADDR_TO_FSB(cur->bc_mp,\n\t\t\t\t\tXFS_BUF_ADDR(bp)));\n\telse {\n\t\tptr->s = cpu_to_be32(xfs_daddr_to_agbno(cur->bc_mp,\n\t\t\t\t\tXFS_BUF_ADDR(bp)));\n\t}\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "xfs_daddr_to_agbno(cur->bc_mp,\n\t\t\t\t\tXFS_BUF_ADDR(bp))"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_daddr_to_agbno",
          "args": [
            "cur->bc_mp",
            "XFS_BUF_ADDR(bp)"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_daddr_to_agbno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.h",
          "lines": "296-301",
          "snippet": "static inline xfs_agblock_t\nxfs_daddr_to_agbno(struct xfs_mount *mp, xfs_daddr_t d)\n{\n\txfs_daddr_t ld = XFS_BB_TO_FSBT(mp, d);\n\treturn (xfs_agblock_t) do_div(ld, mp->m_sb.sb_agblocks);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_agblock_t\nxfs_daddr_to_agbno(struct xfs_mount *mp, xfs_daddr_t d)\n{\n\txfs_daddr_t ld = XFS_BB_TO_FSBT(mp, d);\n\treturn (xfs_agblock_t) do_div(ld, mp->m_sb.sb_agblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ADDR",
          "args": [
            "bp"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "XFS_DADDR_TO_FSB(cur->bc_mp,\n\t\t\t\t\tXFS_BUF_ADDR(bp))"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DADDR_TO_FSB",
          "args": [
            "cur->bc_mp",
            "XFS_BUF_ADDR(bp)"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ADDR",
          "args": [
            "bp"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_buf_to_ptr(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\tptr->l = cpu_to_be64(XFS_DADDR_TO_FSB(cur->bc_mp,\n\t\t\t\t\tXFS_BUF_ADDR(bp)));\n\telse {\n\t\tptr->s = cpu_to_be32(xfs_daddr_to_agbno(cur->bc_mp,\n\t\t\t\t\tXFS_BUF_ADDR(bp)));\n\t}\n}"
  },
  {
    "function_name": "xfs_btree_is_lastrec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "1066-1083",
    "snippet": "STATIC int\nxfs_btree_is_lastrec(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tint\t\t\tlevel)\n{\n\tunion xfs_btree_ptr\tptr;\n\n\tif (level > 0)\n\t\treturn 0;\n\tif (!(cur->bc_flags & XFS_BTREE_LASTREC_UPDATE))\n\t\treturn 0;\n\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (!xfs_btree_ptr_is_null(cur, &ptr))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_ptr_is_null",
          "args": [
            "cur",
            "&ptr"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_is_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "913-922",
          "snippet": "STATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_sibling",
          "args": [
            "cur",
            "block",
            "&ptr",
            "XFS_BB_RIGHTSIB"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_sibling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "938-958",
          "snippet": "STATIC void\nxfs_btree_get_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->l = block->bb_u.l.bb_rightsib;\n\t\telse\n\t\t\tptr->l = block->bb_u.l.bb_leftsib;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->s = block->bb_u.s.bb_rightsib;\n\t\telse\n\t\t\tptr->s = block->bb_u.s.bb_leftsib;\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_get_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->l = block->bb_u.l.bb_rightsib;\n\t\telse\n\t\t\tptr->l = block->bb_u.l.bb_leftsib;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->s = block->bb_u.s.bb_rightsib;\n\t\telse\n\t\t\tptr->s = block->bb_u.s.bb_leftsib;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_is_lastrec(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tint\t\t\tlevel)\n{\n\tunion xfs_btree_ptr\tptr;\n\n\tif (level > 0)\n\t\treturn 0;\n\tif (!(cur->bc_flags & XFS_BTREE_LASTREC_UPDATE))\n\t\treturn 0;\n\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (!xfs_btree_ptr_is_null(cur, &ptr))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "xfs_btree_init_block_cur",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "1036-1059",
    "snippet": "STATIC void\nxfs_btree_init_block_cur(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tlevel,\n\tint\t\t\tnumrecs)\n{\n\t__u64 owner;\n\n\t/*\n\t * we can pull the owner from the cursor right now as the different\n\t * owners align directly with the pointer size of the btree. This may\n\t * change in future, but is safe for current users of the generic btree\n\t * code.\n\t */\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\towner = cur->bc_private.b.ip->i_ino;\n\telse\n\t\towner = cur->bc_private.a.agno;\n\n\txfs_btree_init_block_int(cur->bc_mp, XFS_BUF_TO_BLOCK(bp), bp->b_bn,\n\t\t\t\t xfs_btree_magic(cur), level, numrecs,\n\t\t\t\t owner, cur->bc_flags);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_init_block_int",
          "args": [
            "cur->bc_mp",
            "XFS_BUF_TO_BLOCK(bp)",
            "bp->b_bn",
            "xfs_btree_magic(cur)",
            "level",
            "numrecs",
            "owner",
            "cur->bc_flags"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_init_block_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "982-1020",
          "snippet": "void\nxfs_btree_init_block_int(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_btree_block\t*buf,\n\txfs_daddr_t\t\tblkno,\n\t__u32\t\t\tmagic,\n\t__u16\t\t\tlevel,\n\t__u16\t\t\tnumrecs,\n\t__u64\t\t\towner,\n\tunsigned int\t\tflags)\n{\n\tbuf->bb_magic = cpu_to_be32(magic);\n\tbuf->bb_level = cpu_to_be16(level);\n\tbuf->bb_numrecs = cpu_to_be16(numrecs);\n\n\tif (flags & XFS_BTREE_LONG_PTRS) {\n\t\tbuf->bb_u.l.bb_leftsib = cpu_to_be64(NULLFSBLOCK);\n\t\tbuf->bb_u.l.bb_rightsib = cpu_to_be64(NULLFSBLOCK);\n\t\tif (flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\tbuf->bb_u.l.bb_blkno = cpu_to_be64(blkno);\n\t\t\tbuf->bb_u.l.bb_owner = cpu_to_be64(owner);\n\t\t\tuuid_copy(&buf->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid);\n\t\t\tbuf->bb_u.l.bb_pad = 0;\n\t\t\tbuf->bb_u.l.bb_lsn = 0;\n\t\t}\n\t} else {\n\t\t/* owner is a 32 bit value on short blocks */\n\t\t__u32 __owner = (__u32)owner;\n\n\t\tbuf->bb_u.s.bb_leftsib = cpu_to_be32(NULLAGBLOCK);\n\t\tbuf->bb_u.s.bb_rightsib = cpu_to_be32(NULLAGBLOCK);\n\t\tif (flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\tbuf->bb_u.s.bb_blkno = cpu_to_be64(blkno);\n\t\t\tbuf->bb_u.s.bb_owner = cpu_to_be32(__owner);\n\t\t\tuuid_copy(&buf->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid);\n\t\t\tbuf->bb_u.s.bb_lsn = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_init_block_int(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_btree_block\t*buf,\n\txfs_daddr_t\t\tblkno,\n\t__u32\t\t\tmagic,\n\t__u16\t\t\tlevel,\n\t__u16\t\t\tnumrecs,\n\t__u64\t\t\towner,\n\tunsigned int\t\tflags)\n{\n\tbuf->bb_magic = cpu_to_be32(magic);\n\tbuf->bb_level = cpu_to_be16(level);\n\tbuf->bb_numrecs = cpu_to_be16(numrecs);\n\n\tif (flags & XFS_BTREE_LONG_PTRS) {\n\t\tbuf->bb_u.l.bb_leftsib = cpu_to_be64(NULLFSBLOCK);\n\t\tbuf->bb_u.l.bb_rightsib = cpu_to_be64(NULLFSBLOCK);\n\t\tif (flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\tbuf->bb_u.l.bb_blkno = cpu_to_be64(blkno);\n\t\t\tbuf->bb_u.l.bb_owner = cpu_to_be64(owner);\n\t\t\tuuid_copy(&buf->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid);\n\t\t\tbuf->bb_u.l.bb_pad = 0;\n\t\t\tbuf->bb_u.l.bb_lsn = 0;\n\t\t}\n\t} else {\n\t\t/* owner is a 32 bit value on short blocks */\n\t\t__u32 __owner = (__u32)owner;\n\n\t\tbuf->bb_u.s.bb_leftsib = cpu_to_be32(NULLAGBLOCK);\n\t\tbuf->bb_u.s.bb_rightsib = cpu_to_be32(NULLAGBLOCK);\n\t\tif (flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\tbuf->bb_u.s.bb_blkno = cpu_to_be64(blkno);\n\t\t\tbuf->bb_u.s.bb_owner = cpu_to_be32(__owner);\n\t\t\tuuid_copy(&buf->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid);\n\t\t\tbuf->bb_u.s.bb_lsn = 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_magic",
          "args": [
            "cur"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "bp"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_init_block_cur(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tlevel,\n\tint\t\t\tnumrecs)\n{\n\t__u64 owner;\n\n\t/*\n\t * we can pull the owner from the cursor right now as the different\n\t * owners align directly with the pointer size of the btree. This may\n\t * change in future, but is safe for current users of the generic btree\n\t * code.\n\t */\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\towner = cur->bc_private.b.ip->i_ino;\n\telse\n\t\towner = cur->bc_private.a.agno;\n\n\txfs_btree_init_block_int(cur->bc_mp, XFS_BUF_TO_BLOCK(bp), bp->b_bn,\n\t\t\t\t xfs_btree_magic(cur), level, numrecs,\n\t\t\t\t owner, cur->bc_flags);\n}"
  },
  {
    "function_name": "xfs_btree_init_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "1022-1034",
    "snippet": "void\nxfs_btree_init_block(\n\tstruct xfs_mount *mp,\n\tstruct xfs_buf\t*bp,\n\t__u32\t\tmagic,\n\t__u16\t\tlevel,\n\t__u16\t\tnumrecs,\n\t__u64\t\towner,\n\tunsigned int\tflags)\n{\n\txfs_btree_init_block_int(mp, XFS_BUF_TO_BLOCK(bp), bp->b_bn,\n\t\t\t\t magic, level, numrecs, owner, flags);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_init_block_int",
          "args": [
            "mp",
            "XFS_BUF_TO_BLOCK(bp)",
            "bp->b_bn",
            "magic",
            "level",
            "numrecs",
            "owner",
            "flags"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_init_block_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "982-1020",
          "snippet": "void\nxfs_btree_init_block_int(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_btree_block\t*buf,\n\txfs_daddr_t\t\tblkno,\n\t__u32\t\t\tmagic,\n\t__u16\t\t\tlevel,\n\t__u16\t\t\tnumrecs,\n\t__u64\t\t\towner,\n\tunsigned int\t\tflags)\n{\n\tbuf->bb_magic = cpu_to_be32(magic);\n\tbuf->bb_level = cpu_to_be16(level);\n\tbuf->bb_numrecs = cpu_to_be16(numrecs);\n\n\tif (flags & XFS_BTREE_LONG_PTRS) {\n\t\tbuf->bb_u.l.bb_leftsib = cpu_to_be64(NULLFSBLOCK);\n\t\tbuf->bb_u.l.bb_rightsib = cpu_to_be64(NULLFSBLOCK);\n\t\tif (flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\tbuf->bb_u.l.bb_blkno = cpu_to_be64(blkno);\n\t\t\tbuf->bb_u.l.bb_owner = cpu_to_be64(owner);\n\t\t\tuuid_copy(&buf->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid);\n\t\t\tbuf->bb_u.l.bb_pad = 0;\n\t\t\tbuf->bb_u.l.bb_lsn = 0;\n\t\t}\n\t} else {\n\t\t/* owner is a 32 bit value on short blocks */\n\t\t__u32 __owner = (__u32)owner;\n\n\t\tbuf->bb_u.s.bb_leftsib = cpu_to_be32(NULLAGBLOCK);\n\t\tbuf->bb_u.s.bb_rightsib = cpu_to_be32(NULLAGBLOCK);\n\t\tif (flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\tbuf->bb_u.s.bb_blkno = cpu_to_be64(blkno);\n\t\t\tbuf->bb_u.s.bb_owner = cpu_to_be32(__owner);\n\t\t\tuuid_copy(&buf->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid);\n\t\t\tbuf->bb_u.s.bb_lsn = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_init_block_int(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_btree_block\t*buf,\n\txfs_daddr_t\t\tblkno,\n\t__u32\t\t\tmagic,\n\t__u16\t\t\tlevel,\n\t__u16\t\t\tnumrecs,\n\t__u64\t\t\towner,\n\tunsigned int\t\tflags)\n{\n\tbuf->bb_magic = cpu_to_be32(magic);\n\tbuf->bb_level = cpu_to_be16(level);\n\tbuf->bb_numrecs = cpu_to_be16(numrecs);\n\n\tif (flags & XFS_BTREE_LONG_PTRS) {\n\t\tbuf->bb_u.l.bb_leftsib = cpu_to_be64(NULLFSBLOCK);\n\t\tbuf->bb_u.l.bb_rightsib = cpu_to_be64(NULLFSBLOCK);\n\t\tif (flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\tbuf->bb_u.l.bb_blkno = cpu_to_be64(blkno);\n\t\t\tbuf->bb_u.l.bb_owner = cpu_to_be64(owner);\n\t\t\tuuid_copy(&buf->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid);\n\t\t\tbuf->bb_u.l.bb_pad = 0;\n\t\t\tbuf->bb_u.l.bb_lsn = 0;\n\t\t}\n\t} else {\n\t\t/* owner is a 32 bit value on short blocks */\n\t\t__u32 __owner = (__u32)owner;\n\n\t\tbuf->bb_u.s.bb_leftsib = cpu_to_be32(NULLAGBLOCK);\n\t\tbuf->bb_u.s.bb_rightsib = cpu_to_be32(NULLAGBLOCK);\n\t\tif (flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\tbuf->bb_u.s.bb_blkno = cpu_to_be64(blkno);\n\t\t\tbuf->bb_u.s.bb_owner = cpu_to_be32(__owner);\n\t\t\tuuid_copy(&buf->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid);\n\t\t\tbuf->bb_u.s.bb_lsn = 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "bp"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_init_block(\n\tstruct xfs_mount *mp,\n\tstruct xfs_buf\t*bp,\n\t__u32\t\tmagic,\n\t__u16\t\tlevel,\n\t__u16\t\tnumrecs,\n\t__u64\t\towner,\n\tunsigned int\tflags)\n{\n\txfs_btree_init_block_int(mp, XFS_BUF_TO_BLOCK(bp), bp->b_bn,\n\t\t\t\t magic, level, numrecs, owner, flags);\n}"
  },
  {
    "function_name": "xfs_btree_init_block_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "982-1020",
    "snippet": "void\nxfs_btree_init_block_int(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_btree_block\t*buf,\n\txfs_daddr_t\t\tblkno,\n\t__u32\t\t\tmagic,\n\t__u16\t\t\tlevel,\n\t__u16\t\t\tnumrecs,\n\t__u64\t\t\towner,\n\tunsigned int\t\tflags)\n{\n\tbuf->bb_magic = cpu_to_be32(magic);\n\tbuf->bb_level = cpu_to_be16(level);\n\tbuf->bb_numrecs = cpu_to_be16(numrecs);\n\n\tif (flags & XFS_BTREE_LONG_PTRS) {\n\t\tbuf->bb_u.l.bb_leftsib = cpu_to_be64(NULLFSBLOCK);\n\t\tbuf->bb_u.l.bb_rightsib = cpu_to_be64(NULLFSBLOCK);\n\t\tif (flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\tbuf->bb_u.l.bb_blkno = cpu_to_be64(blkno);\n\t\t\tbuf->bb_u.l.bb_owner = cpu_to_be64(owner);\n\t\t\tuuid_copy(&buf->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid);\n\t\t\tbuf->bb_u.l.bb_pad = 0;\n\t\t\tbuf->bb_u.l.bb_lsn = 0;\n\t\t}\n\t} else {\n\t\t/* owner is a 32 bit value on short blocks */\n\t\t__u32 __owner = (__u32)owner;\n\n\t\tbuf->bb_u.s.bb_leftsib = cpu_to_be32(NULLAGBLOCK);\n\t\tbuf->bb_u.s.bb_rightsib = cpu_to_be32(NULLAGBLOCK);\n\t\tif (flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\tbuf->bb_u.s.bb_blkno = cpu_to_be64(blkno);\n\t\t\tbuf->bb_u.s.bb_owner = cpu_to_be32(__owner);\n\t\t\tuuid_copy(&buf->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid);\n\t\t\tbuf->bb_u.s.bb_lsn = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uuid_copy",
          "args": [
            "&buf->bb_u.s.bb_uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.h",
          "lines": "29-33",
          "snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "__owner"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "blkno"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGBLOCK"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGBLOCK"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "owner"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "blkno"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "NULLFSBLOCK"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "NULLFSBLOCK"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "numrecs"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "level"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "magic"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_init_block_int(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_btree_block\t*buf,\n\txfs_daddr_t\t\tblkno,\n\t__u32\t\t\tmagic,\n\t__u16\t\t\tlevel,\n\t__u16\t\t\tnumrecs,\n\t__u64\t\t\towner,\n\tunsigned int\t\tflags)\n{\n\tbuf->bb_magic = cpu_to_be32(magic);\n\tbuf->bb_level = cpu_to_be16(level);\n\tbuf->bb_numrecs = cpu_to_be16(numrecs);\n\n\tif (flags & XFS_BTREE_LONG_PTRS) {\n\t\tbuf->bb_u.l.bb_leftsib = cpu_to_be64(NULLFSBLOCK);\n\t\tbuf->bb_u.l.bb_rightsib = cpu_to_be64(NULLFSBLOCK);\n\t\tif (flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\tbuf->bb_u.l.bb_blkno = cpu_to_be64(blkno);\n\t\t\tbuf->bb_u.l.bb_owner = cpu_to_be64(owner);\n\t\t\tuuid_copy(&buf->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid);\n\t\t\tbuf->bb_u.l.bb_pad = 0;\n\t\t\tbuf->bb_u.l.bb_lsn = 0;\n\t\t}\n\t} else {\n\t\t/* owner is a 32 bit value on short blocks */\n\t\t__u32 __owner = (__u32)owner;\n\n\t\tbuf->bb_u.s.bb_leftsib = cpu_to_be32(NULLAGBLOCK);\n\t\tbuf->bb_u.s.bb_rightsib = cpu_to_be32(NULLAGBLOCK);\n\t\tif (flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\tbuf->bb_u.s.bb_blkno = cpu_to_be64(blkno);\n\t\t\tbuf->bb_u.s.bb_owner = cpu_to_be32(__owner);\n\t\t\tuuid_copy(&buf->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid);\n\t\t\tbuf->bb_u.s.bb_lsn = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "xfs_btree_set_sibling",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "960-980",
    "snippet": "STATIC void\nxfs_btree_set_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tblock->bb_u.l.bb_rightsib = ptr->l;\n\t\telse\n\t\t\tblock->bb_u.l.bb_leftsib = ptr->l;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tblock->bb_u.s.bb_rightsib = ptr->s;\n\t\telse\n\t\t\tblock->bb_u.s.bb_leftsib = ptr->s;\n\t}\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_set_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tblock->bb_u.l.bb_rightsib = ptr->l;\n\t\telse\n\t\t\tblock->bb_u.l.bb_leftsib = ptr->l;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tblock->bb_u.s.bb_rightsib = ptr->s;\n\t\telse\n\t\t\tblock->bb_u.s.bb_leftsib = ptr->s;\n\t}\n}"
  },
  {
    "function_name": "xfs_btree_get_sibling",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "938-958",
    "snippet": "STATIC void\nxfs_btree_get_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->l = block->bb_u.l.bb_rightsib;\n\t\telse\n\t\t\tptr->l = block->bb_u.l.bb_leftsib;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->s = block->bb_u.s.bb_rightsib;\n\t\telse\n\t\t\tptr->s = block->bb_u.s.bb_leftsib;\n\t}\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_get_sibling(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tunion xfs_btree_ptr\t*ptr,\n\tint\t\t\tlr)\n{\n\tASSERT(lr == XFS_BB_LEFTSIB || lr == XFS_BB_RIGHTSIB);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->l = block->bb_u.l.bb_rightsib;\n\t\telse\n\t\t\tptr->l = block->bb_u.l.bb_leftsib;\n\t} else {\n\t\tif (lr == XFS_BB_RIGHTSIB)\n\t\t\tptr->s = block->bb_u.s.bb_rightsib;\n\t\telse\n\t\t\tptr->s = block->bb_u.s.bb_leftsib;\n\t}\n}"
  },
  {
    "function_name": "xfs_btree_set_ptr_null",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "924-933",
    "snippet": "STATIC void\nxfs_btree_set_ptr_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\tptr->l = cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\tptr->s = cpu_to_be32(NULLAGBLOCK);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGBLOCK"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "NULLFSBLOCK"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_set_ptr_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\tptr->l = cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\tptr->s = cpu_to_be32(NULLAGBLOCK);\n}"
  },
  {
    "function_name": "xfs_btree_ptr_is_null",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "913-922",
    "snippet": "STATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGBLOCK"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "NULLFSBLOCK"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\nxfs_btree_ptr_is_null(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn ptr->l == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn ptr->s == cpu_to_be32(NULLAGBLOCK);\n}"
  },
  {
    "function_name": "xfs_btree_setbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "886-911",
    "snippet": "STATIC void\nxfs_btree_setbuf(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlev,\t/* level in btree */\n\txfs_buf_t\t\t*bp)\t/* new buffer to set */\n{\n\tstruct xfs_btree_block\t*b;\t/* btree block */\n\n\tif (cur->bc_bufs[lev])\n\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[lev]);\n\tcur->bc_bufs[lev] = bp;\n\tcur->bc_ra[lev] = 0;\n\n\tb = XFS_BUF_TO_BLOCK(bp);\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (b->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t} else {\n\t\tif (b->bb_u.s.bb_leftsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.s.bb_rightsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t}\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGBLOCK"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGBLOCK"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "NULLFSBLOCK"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "NULLFSBLOCK"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "bp"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "cur->bc_tp",
            "cur->bc_bufs[lev]"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_btree_setbuf(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlev,\t/* level in btree */\n\txfs_buf_t\t\t*bp)\t/* new buffer to set */\n{\n\tstruct xfs_btree_block\t*b;\t/* btree block */\n\n\tif (cur->bc_bufs[lev])\n\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[lev]);\n\tcur->bc_bufs[lev] = bp;\n\tcur->bc_ra[lev] = 0;\n\n\tb = XFS_BUF_TO_BLOCK(bp);\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (b->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t} else {\n\t\tif (b->bb_u.s.bb_leftsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_LEFTRA;\n\t\tif (b->bb_u.s.bb_rightsib == cpu_to_be32(NULLAGBLOCK))\n\t\t\tcur->bc_ra[lev] |= XFS_BTCUR_RIGHTRA;\n\t}\n}"
  },
  {
    "function_name": "xfs_btree_readahead_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "871-880",
    "snippet": "STATIC void\nxfs_btree_readahead_ptr(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\txfs_extlen_t\t\tcount)\n{\n\txfs_buf_readahead(cur->bc_mp->m_ddev_targp,\n\t\t\t  xfs_btree_ptr_to_daddr(cur, ptr),\n\t\t\t  cur->bc_mp->m_bsize * count, cur->bc_ops->buf_ops);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_readahead",
          "args": [
            "cur->bc_mp->m_ddev_targp",
            "xfs_btree_ptr_to_daddr(cur, ptr)",
            "cur->bc_mp->m_bsize * count",
            "cur->bc_ops->buf_ops"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "256-265",
          "snippet": "static inline void\nxfs_buf_readahead(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_readahead_map(target, &map, 1, ops);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void\nxfs_buf_readahead(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_readahead_map(target, &map, 1, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_ptr_to_daddr",
          "args": [
            "cur",
            "ptr"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_to_daddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "847-863",
          "snippet": "STATIC xfs_daddr_t\nxfs_btree_ptr_to_daddr(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tASSERT(ptr->l != cpu_to_be64(NULLFSBLOCK));\n\n\t\treturn XFS_FSB_TO_DADDR(cur->bc_mp, be64_to_cpu(ptr->l));\n\t} else {\n\t\tASSERT(cur->bc_private.a.agno != NULLAGNUMBER);\n\t\tASSERT(ptr->s != cpu_to_be32(NULLAGBLOCK));\n\n\t\treturn XFS_AGB_TO_DADDR(cur->bc_mp, cur->bc_private.a.agno,\n\t\t\t\t\tbe32_to_cpu(ptr->s));\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC xfs_daddr_t\nxfs_btree_ptr_to_daddr(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tASSERT(ptr->l != cpu_to_be64(NULLFSBLOCK));\n\n\t\treturn XFS_FSB_TO_DADDR(cur->bc_mp, be64_to_cpu(ptr->l));\n\t} else {\n\t\tASSERT(cur->bc_private.a.agno != NULLAGNUMBER);\n\t\tASSERT(ptr->s != cpu_to_be32(NULLAGBLOCK));\n\n\t\treturn XFS_AGB_TO_DADDR(cur->bc_mp, cur->bc_private.a.agno,\n\t\t\t\t\tbe32_to_cpu(ptr->s));\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC void\nxfs_btree_readahead_ptr(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr,\n\txfs_extlen_t\t\tcount)\n{\n\txfs_buf_readahead(cur->bc_mp->m_ddev_targp,\n\t\t\t  xfs_btree_ptr_to_daddr(cur, ptr),\n\t\t\t  cur->bc_mp->m_bsize * count, cur->bc_ops->buf_ops);\n}"
  },
  {
    "function_name": "xfs_btree_ptr_to_daddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "847-863",
    "snippet": "STATIC xfs_daddr_t\nxfs_btree_ptr_to_daddr(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tASSERT(ptr->l != cpu_to_be64(NULLFSBLOCK));\n\n\t\treturn XFS_FSB_TO_DADDR(cur->bc_mp, be64_to_cpu(ptr->l));\n\t} else {\n\t\tASSERT(cur->bc_private.a.agno != NULLAGNUMBER);\n\t\tASSERT(ptr->s != cpu_to_be32(NULLAGBLOCK));\n\n\t\treturn XFS_AGB_TO_DADDR(cur->bc_mp, cur->bc_private.a.agno,\n\t\t\t\t\tbe32_to_cpu(ptr->s));\n\t}\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_AGB_TO_DADDR",
          "args": [
            "cur->bc_mp",
            "cur->bc_private.a.agno",
            "be32_to_cpu(ptr->s)"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ptr->s"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ptr->s != cpu_to_be32(NULLAGBLOCK)"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGBLOCK"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cur->bc_private.a.agno != NULLAGNUMBER"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "cur->bc_mp",
            "be64_to_cpu(ptr->l)"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ptr->l"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ptr->l != cpu_to_be64(NULLFSBLOCK)"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "NULLFSBLOCK"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC xfs_daddr_t\nxfs_btree_ptr_to_daddr(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tASSERT(ptr->l != cpu_to_be64(NULLFSBLOCK));\n\n\t\treturn XFS_FSB_TO_DADDR(cur->bc_mp, be64_to_cpu(ptr->l));\n\t} else {\n\t\tASSERT(cur->bc_private.a.agno != NULLAGNUMBER);\n\t\tASSERT(ptr->s != cpu_to_be32(NULLAGBLOCK));\n\n\t\treturn XFS_AGB_TO_DADDR(cur->bc_mp, cur->bc_private.a.agno,\n\t\t\t\t\tbe32_to_cpu(ptr->s));\n\t}\n}"
  },
  {
    "function_name": "xfs_btree_readahead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "820-845",
    "snippet": "STATIC int\nxfs_btree_readahead(\n\tstruct xfs_btree_cur\t*cur,\t\t/* btree cursor */\n\tint\t\t\tlev,\t\t/* level in btree */\n\tint\t\t\tlr)\t\t/* left/right bits */\n{\n\tstruct xfs_btree_block\t*block;\n\n\t/*\n\t * No readahead needed if we are at the root level and the\n\t * btree root is stored in the inode.\n\t */\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (lev == cur->bc_nlevels - 1))\n\t\treturn 0;\n\n\tif ((cur->bc_ra[lev] | lr) == cur->bc_ra[lev])\n\t\treturn 0;\n\n\tcur->bc_ra[lev] |= lr;\n\tblock = XFS_BUF_TO_BLOCK(cur->bc_bufs[lev]);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_readahead_lblock(cur, lr, block);\n\treturn xfs_btree_readahead_sblock(cur, lr, block);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_readahead_sblock",
          "args": [
            "cur",
            "lr",
            "block"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_readahead_sblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "790-814",
          "snippet": "STATIC int\nxfs_btree_readahead_sblock(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlr,\n\tstruct xfs_btree_block *block)\n{\n\tint\t\t\trval = 0;\n\txfs_agblock_t\t\tleft = be32_to_cpu(block->bb_u.s.bb_leftsib);\n\txfs_agblock_t\t\tright = be32_to_cpu(block->bb_u.s.bb_rightsib);\n\n\n\tif ((lr & XFS_BTCUR_LEFTRA) && left != NULLAGBLOCK) {\n\t\txfs_btree_reada_bufs(cur->bc_mp, cur->bc_private.a.agno,\n\t\t\t\t     left, 1, cur->bc_ops->buf_ops);\n\t\trval++;\n\t}\n\n\tif ((lr & XFS_BTCUR_RIGHTRA) && right != NULLAGBLOCK) {\n\t\txfs_btree_reada_bufs(cur->bc_mp, cur->bc_private.a.agno,\n\t\t\t\t     right, 1, cur->bc_ops->buf_ops);\n\t\trval++;\n\t}\n\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_btree_readahead_sblock(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlr,\n\tstruct xfs_btree_block *block)\n{\n\tint\t\t\trval = 0;\n\txfs_agblock_t\t\tleft = be32_to_cpu(block->bb_u.s.bb_leftsib);\n\txfs_agblock_t\t\tright = be32_to_cpu(block->bb_u.s.bb_rightsib);\n\n\n\tif ((lr & XFS_BTCUR_LEFTRA) && left != NULLAGBLOCK) {\n\t\txfs_btree_reada_bufs(cur->bc_mp, cur->bc_private.a.agno,\n\t\t\t\t     left, 1, cur->bc_ops->buf_ops);\n\t\trval++;\n\t}\n\n\tif ((lr & XFS_BTCUR_RIGHTRA) && right != NULLAGBLOCK) {\n\t\txfs_btree_reada_bufs(cur->bc_mp, cur->bc_private.a.agno,\n\t\t\t\t     right, 1, cur->bc_ops->buf_ops);\n\t\trval++;\n\t}\n\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_readahead_lblock",
          "args": [
            "cur",
            "lr",
            "block"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_readahead_lblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "765-788",
          "snippet": "STATIC int\nxfs_btree_readahead_lblock(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlr,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\trval = 0;\n\txfs_fsblock_t\t\tleft = be64_to_cpu(block->bb_u.l.bb_leftsib);\n\txfs_fsblock_t\t\tright = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\n\tif ((lr & XFS_BTCUR_LEFTRA) && left != NULLFSBLOCK) {\n\t\txfs_btree_reada_bufl(cur->bc_mp, left, 1,\n\t\t\t\t     cur->bc_ops->buf_ops);\n\t\trval++;\n\t}\n\n\tif ((lr & XFS_BTCUR_RIGHTRA) && right != NULLFSBLOCK) {\n\t\txfs_btree_reada_bufl(cur->bc_mp, right, 1,\n\t\t\t\t     cur->bc_ops->buf_ops);\n\t\trval++;\n\t}\n\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_btree_readahead_lblock(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlr,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\trval = 0;\n\txfs_fsblock_t\t\tleft = be64_to_cpu(block->bb_u.l.bb_leftsib);\n\txfs_fsblock_t\t\tright = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\n\tif ((lr & XFS_BTCUR_LEFTRA) && left != NULLFSBLOCK) {\n\t\txfs_btree_reada_bufl(cur->bc_mp, left, 1,\n\t\t\t\t     cur->bc_ops->buf_ops);\n\t\trval++;\n\t}\n\n\tif ((lr & XFS_BTCUR_RIGHTRA) && right != NULLFSBLOCK) {\n\t\txfs_btree_reada_bufl(cur->bc_mp, right, 1,\n\t\t\t\t     cur->bc_ops->buf_ops);\n\t\trval++;\n\t}\n\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "cur->bc_bufs[lev]"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_btree_readahead(\n\tstruct xfs_btree_cur\t*cur,\t\t/* btree cursor */\n\tint\t\t\tlev,\t\t/* level in btree */\n\tint\t\t\tlr)\t\t/* left/right bits */\n{\n\tstruct xfs_btree_block\t*block;\n\n\t/*\n\t * No readahead needed if we are at the root level and the\n\t * btree root is stored in the inode.\n\t */\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (lev == cur->bc_nlevels - 1))\n\t\treturn 0;\n\n\tif ((cur->bc_ra[lev] | lr) == cur->bc_ra[lev])\n\t\treturn 0;\n\n\tcur->bc_ra[lev] |= lr;\n\tblock = XFS_BUF_TO_BLOCK(cur->bc_bufs[lev]);\n\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_readahead_lblock(cur, lr, block);\n\treturn xfs_btree_readahead_sblock(cur, lr, block);\n}"
  },
  {
    "function_name": "xfs_btree_readahead_sblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "790-814",
    "snippet": "STATIC int\nxfs_btree_readahead_sblock(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlr,\n\tstruct xfs_btree_block *block)\n{\n\tint\t\t\trval = 0;\n\txfs_agblock_t\t\tleft = be32_to_cpu(block->bb_u.s.bb_leftsib);\n\txfs_agblock_t\t\tright = be32_to_cpu(block->bb_u.s.bb_rightsib);\n\n\n\tif ((lr & XFS_BTCUR_LEFTRA) && left != NULLAGBLOCK) {\n\t\txfs_btree_reada_bufs(cur->bc_mp, cur->bc_private.a.agno,\n\t\t\t\t     left, 1, cur->bc_ops->buf_ops);\n\t\trval++;\n\t}\n\n\tif ((lr & XFS_BTCUR_RIGHTRA) && right != NULLAGBLOCK) {\n\t\txfs_btree_reada_bufs(cur->bc_mp, cur->bc_private.a.agno,\n\t\t\t\t     right, 1, cur->bc_ops->buf_ops);\n\t\trval++;\n\t}\n\n\treturn rval;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_reada_bufs",
          "args": [
            "cur->bc_mp",
            "cur->bc_private.a.agno",
            "right",
            "1",
            "cur->bc_ops->buf_ops"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_reada_bufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "749-763",
          "snippet": "void\nxfs_btree_reada_bufs(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_agblock_t\t\tagbno,\t\t/* allocation group block number */\n\txfs_extlen_t\t\tcount,\t\t/* count of filesystem blocks */\n\tconst struct xfs_buf_ops *ops)\n{\n\txfs_daddr_t\t\td;\n\n\tASSERT(agno != NULLAGNUMBER);\n\tASSERT(agbno != NULLAGBLOCK);\n\td = XFS_AGB_TO_DADDR(mp, agno, agbno);\n\txfs_buf_readahead(mp->m_ddev_targp, d, mp->m_bsize * count, ops);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_reada_bufs(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_agblock_t\t\tagbno,\t\t/* allocation group block number */\n\txfs_extlen_t\t\tcount,\t\t/* count of filesystem blocks */\n\tconst struct xfs_buf_ops *ops)\n{\n\txfs_daddr_t\t\td;\n\n\tASSERT(agno != NULLAGNUMBER);\n\tASSERT(agbno != NULLAGBLOCK);\n\td = XFS_AGB_TO_DADDR(mp, agno, agbno);\n\txfs_buf_readahead(mp->m_ddev_targp, d, mp->m_bsize * count, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "block->bb_u.s.bb_rightsib"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "block->bb_u.s.bb_leftsib"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_btree_readahead_sblock(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlr,\n\tstruct xfs_btree_block *block)\n{\n\tint\t\t\trval = 0;\n\txfs_agblock_t\t\tleft = be32_to_cpu(block->bb_u.s.bb_leftsib);\n\txfs_agblock_t\t\tright = be32_to_cpu(block->bb_u.s.bb_rightsib);\n\n\n\tif ((lr & XFS_BTCUR_LEFTRA) && left != NULLAGBLOCK) {\n\t\txfs_btree_reada_bufs(cur->bc_mp, cur->bc_private.a.agno,\n\t\t\t\t     left, 1, cur->bc_ops->buf_ops);\n\t\trval++;\n\t}\n\n\tif ((lr & XFS_BTCUR_RIGHTRA) && right != NULLAGBLOCK) {\n\t\txfs_btree_reada_bufs(cur->bc_mp, cur->bc_private.a.agno,\n\t\t\t\t     right, 1, cur->bc_ops->buf_ops);\n\t\trval++;\n\t}\n\n\treturn rval;\n}"
  },
  {
    "function_name": "xfs_btree_readahead_lblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "765-788",
    "snippet": "STATIC int\nxfs_btree_readahead_lblock(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlr,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\trval = 0;\n\txfs_fsblock_t\t\tleft = be64_to_cpu(block->bb_u.l.bb_leftsib);\n\txfs_fsblock_t\t\tright = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\n\tif ((lr & XFS_BTCUR_LEFTRA) && left != NULLFSBLOCK) {\n\t\txfs_btree_reada_bufl(cur->bc_mp, left, 1,\n\t\t\t\t     cur->bc_ops->buf_ops);\n\t\trval++;\n\t}\n\n\tif ((lr & XFS_BTCUR_RIGHTRA) && right != NULLFSBLOCK) {\n\t\txfs_btree_reada_bufl(cur->bc_mp, right, 1,\n\t\t\t\t     cur->bc_ops->buf_ops);\n\t\trval++;\n\t}\n\n\treturn rval;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_reada_bufl",
          "args": [
            "cur->bc_mp",
            "right",
            "1",
            "cur->bc_ops->buf_ops"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_reada_bufl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "730-742",
          "snippet": "void\nxfs_btree_reada_bufl(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\txfs_fsblock_t\t\tfsbno,\t\t/* file system block number */\n\txfs_extlen_t\t\tcount,\t\t/* count of filesystem blocks */\n\tconst struct xfs_buf_ops *ops)\n{\n\txfs_daddr_t\t\td;\n\n\tASSERT(fsbno != NULLFSBLOCK);\n\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\txfs_buf_readahead(mp->m_ddev_targp, d, mp->m_bsize * count, ops);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_reada_bufl(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\txfs_fsblock_t\t\tfsbno,\t\t/* file system block number */\n\txfs_extlen_t\t\tcount,\t\t/* count of filesystem blocks */\n\tconst struct xfs_buf_ops *ops)\n{\n\txfs_daddr_t\t\td;\n\n\tASSERT(fsbno != NULLFSBLOCK);\n\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\txfs_buf_readahead(mp->m_ddev_targp, d, mp->m_bsize * count, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "block->bb_u.l.bb_rightsib"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "block->bb_u.l.bb_leftsib"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_btree_readahead_lblock(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlr,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\trval = 0;\n\txfs_fsblock_t\t\tleft = be64_to_cpu(block->bb_u.l.bb_leftsib);\n\txfs_fsblock_t\t\tright = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\n\tif ((lr & XFS_BTCUR_LEFTRA) && left != NULLFSBLOCK) {\n\t\txfs_btree_reada_bufl(cur->bc_mp, left, 1,\n\t\t\t\t     cur->bc_ops->buf_ops);\n\t\trval++;\n\t}\n\n\tif ((lr & XFS_BTCUR_RIGHTRA) && right != NULLFSBLOCK) {\n\t\txfs_btree_reada_bufl(cur->bc_mp, right, 1,\n\t\t\t\t     cur->bc_ops->buf_ops);\n\t\trval++;\n\t}\n\n\treturn rval;\n}"
  },
  {
    "function_name": "xfs_btree_reada_bufs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "749-763",
    "snippet": "void\nxfs_btree_reada_bufs(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_agblock_t\t\tagbno,\t\t/* allocation group block number */\n\txfs_extlen_t\t\tcount,\t\t/* count of filesystem blocks */\n\tconst struct xfs_buf_ops *ops)\n{\n\txfs_daddr_t\t\td;\n\n\tASSERT(agno != NULLAGNUMBER);\n\tASSERT(agbno != NULLAGBLOCK);\n\td = XFS_AGB_TO_DADDR(mp, agno, agbno);\n\txfs_buf_readahead(mp->m_ddev_targp, d, mp->m_bsize * count, ops);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_readahead",
          "args": [
            "mp->m_ddev_targp",
            "d",
            "mp->m_bsize * count",
            "ops"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "256-265",
          "snippet": "static inline void\nxfs_buf_readahead(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_readahead_map(target, &map, 1, ops);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void\nxfs_buf_readahead(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_readahead_map(target, &map, 1, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_AGB_TO_DADDR",
          "args": [
            "mp",
            "agno",
            "agbno"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "agbno != NULLAGBLOCK"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "agno != NULLAGNUMBER"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_reada_bufs(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\txfs_agnumber_t\t\tagno,\t\t/* allocation group number */\n\txfs_agblock_t\t\tagbno,\t\t/* allocation group block number */\n\txfs_extlen_t\t\tcount,\t\t/* count of filesystem blocks */\n\tconst struct xfs_buf_ops *ops)\n{\n\txfs_daddr_t\t\td;\n\n\tASSERT(agno != NULLAGNUMBER);\n\tASSERT(agbno != NULLAGBLOCK);\n\td = XFS_AGB_TO_DADDR(mp, agno, agbno);\n\txfs_buf_readahead(mp->m_ddev_targp, d, mp->m_bsize * count, ops);\n}"
  },
  {
    "function_name": "xfs_btree_reada_bufl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "730-742",
    "snippet": "void\nxfs_btree_reada_bufl(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\txfs_fsblock_t\t\tfsbno,\t\t/* file system block number */\n\txfs_extlen_t\t\tcount,\t\t/* count of filesystem blocks */\n\tconst struct xfs_buf_ops *ops)\n{\n\txfs_daddr_t\t\td;\n\n\tASSERT(fsbno != NULLFSBLOCK);\n\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\txfs_buf_readahead(mp->m_ddev_targp, d, mp->m_bsize * count, ops);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_readahead",
          "args": [
            "mp->m_ddev_targp",
            "d",
            "mp->m_bsize * count",
            "ops"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "256-265",
          "snippet": "static inline void\nxfs_buf_readahead(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_readahead_map(target, &map, 1, ops);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void\nxfs_buf_readahead(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_readahead_map(target, &map, 1, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "mp",
            "fsbno"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "fsbno != NULLFSBLOCK"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_reada_bufl(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\txfs_fsblock_t\t\tfsbno,\t\t/* file system block number */\n\txfs_extlen_t\t\tcount,\t\t/* count of filesystem blocks */\n\tconst struct xfs_buf_ops *ops)\n{\n\txfs_daddr_t\t\td;\n\n\tASSERT(fsbno != NULLFSBLOCK);\n\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\txfs_buf_readahead(mp->m_ddev_targp, d, mp->m_bsize * count, ops);\n}"
  },
  {
    "function_name": "xfs_btree_read_bufl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "699-723",
    "snippet": "int\nxfs_btree_read_bufl(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\txfs_fsblock_t\t\tfsbno,\t\t/* file system block number */\n\tuint\t\t\tlock,\t\t/* lock flags for read_buf */\n\tstruct xfs_buf\t\t**bpp,\t\t/* buffer for fsbno */\n\tint\t\t\trefval,\t\t/* ref count value for buffer */\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\t\t/* return value */\n\txfs_daddr_t\t\td;\t\t/* real disk block address */\n\tint\t\t\terror;\n\n\tASSERT(fsbno != NULLFSBLOCK);\n\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, lock, &bp, ops);\n\tif (error)\n\t\treturn error;\n\tif (bp)\n\t\txfs_buf_set_ref(bp, refval);\n\t*bpp = bp;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_set_ref",
          "args": [
            "bp",
            "refval"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_set_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "351-354",
          "snippet": "static inline void xfs_buf_set_ref(struct xfs_buf *bp, int lru_ref)\n{\n\tatomic_set(&bp->b_lru_ref, lru_ref);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_set_ref(struct xfs_buf *bp, int lru_ref)\n{\n\tatomic_set(&bp->b_lru_ref, lru_ref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_read_buf",
          "args": [
            "mp",
            "tp",
            "mp->m_ddev_targp",
            "d",
            "mp->m_bsize",
            "lock",
            "&bp",
            "ops"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "186-200",
          "snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "mp",
            "fsbno"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "fsbno != NULLFSBLOCK"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_btree_read_bufl(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\txfs_fsblock_t\t\tfsbno,\t\t/* file system block number */\n\tuint\t\t\tlock,\t\t/* lock flags for read_buf */\n\tstruct xfs_buf\t\t**bpp,\t\t/* buffer for fsbno */\n\tint\t\t\trefval,\t\t/* ref count value for buffer */\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\t\t/* return value */\n\txfs_daddr_t\t\td;\t\t/* real disk block address */\n\tint\t\t\terror;\n\n\tASSERT(fsbno != NULLFSBLOCK);\n\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, lock, &bp, ops);\n\tif (error)\n\t\treturn error;\n\tif (bp)\n\t\txfs_buf_set_ref(bp, refval);\n\t*bpp = bp;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_btree_offsets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "663-693",
    "snippet": "void\nxfs_btree_offsets(\n\t__int64_t\tfields,\t\t/* bitmask of fields */\n\tconst short\t*offsets,\t/* table of field offsets */\n\tint\t\tnbits,\t\t/* number of bits to inspect */\n\tint\t\t*first,\t\t/* output: first byte offset */\n\tint\t\t*last)\t\t/* output: last byte offset */\n{\n\tint\t\ti;\t\t/* current bit number */\n\t__int64_t\timask;\t\t/* mask for current bit number */\n\n\tASSERT(fields != 0);\n\t/*\n\t * Find the lowest bit, so the first byte offset.\n\t */\n\tfor (i = 0, imask = 1LL; ; i++, imask <<= 1) {\n\t\tif (imask & fields) {\n\t\t\t*first = offsets[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * Find the highest bit, so the last byte offset.\n\t */\n\tfor (i = nbits - 1, imask = 1LL << i; ; i--, imask >>= 1) {\n\t\tif (imask & fields) {\n\t\t\t*last = offsets[i + 1] - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "fields != 0"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_btree_offsets(\n\t__int64_t\tfields,\t\t/* bitmask of fields */\n\tconst short\t*offsets,\t/* table of field offsets */\n\tint\t\tnbits,\t\t/* number of bits to inspect */\n\tint\t\t*first,\t\t/* output: first byte offset */\n\tint\t\t*last)\t\t/* output: last byte offset */\n{\n\tint\t\ti;\t\t/* current bit number */\n\t__int64_t\timask;\t\t/* mask for current bit number */\n\n\tASSERT(fields != 0);\n\t/*\n\t * Find the lowest bit, so the first byte offset.\n\t */\n\tfor (i = 0, imask = 1LL; ; i++, imask <<= 1) {\n\t\tif (imask & fields) {\n\t\t\t*first = offsets[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * Find the highest bit, so the last byte offset.\n\t */\n\tfor (i = nbits - 1, imask = 1LL << i; ; i--, imask >>= 1) {\n\t\tif (imask & fields) {\n\t\t\t*last = offsets[i + 1] - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "xfs_btree_lastrec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "634-657",
    "snippet": "STATIC int\t\t\t\t/* success=1, failure=0 */\nxfs_btree_lastrec(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel)\t/* level to change */\n{\n\tstruct xfs_btree_block\t*block;\t/* generic btree block pointer */\n\txfs_buf_t\t\t*bp;\t/* buffer containing block */\n\n\t/*\n\t * Get the block pointer for this level.\n\t */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\txfs_btree_check_block(cur, block, level, bp);\n\t/*\n\t * It's empty, there is no such record.\n\t */\n\tif (!block->bb_numrecs)\n\t\treturn 0;\n\t/*\n\t * Set the ptr value to numrecs, that's the last record/key.\n\t */\n\tcur->bc_ptrs[level] = be16_to_cpu(block->bb_numrecs);\n\treturn 1;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "block->bb_numrecs"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_check_block",
          "args": [
            "cur",
            "block",
            "level",
            "bp"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "149-160",
          "snippet": "int\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_block",
          "args": [
            "cur",
            "level",
            "&bp"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "528-542",
          "snippet": "xfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\t\t\t\t/* success=1, failure=0 */\nxfs_btree_lastrec(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel)\t/* level to change */\n{\n\tstruct xfs_btree_block\t*block;\t/* generic btree block pointer */\n\txfs_buf_t\t\t*bp;\t/* buffer containing block */\n\n\t/*\n\t * Get the block pointer for this level.\n\t */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\txfs_btree_check_block(cur, block, level, bp);\n\t/*\n\t * It's empty, there is no such record.\n\t */\n\tif (!block->bb_numrecs)\n\t\treturn 0;\n\t/*\n\t * Set the ptr value to numrecs, that's the last record/key.\n\t */\n\tcur->bc_ptrs[level] = be16_to_cpu(block->bb_numrecs);\n\treturn 1;\n}"
  },
  {
    "function_name": "xfs_btree_firstrec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "605-628",
    "snippet": "STATIC int\t\t\t\t/* success=1, failure=0 */\nxfs_btree_firstrec(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel)\t/* level to change */\n{\n\tstruct xfs_btree_block\t*block;\t/* generic btree block pointer */\n\txfs_buf_t\t\t*bp;\t/* buffer containing block */\n\n\t/*\n\t * Get the block pointer for this level.\n\t */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\txfs_btree_check_block(cur, block, level, bp);\n\t/*\n\t * It's empty, there is no such record.\n\t */\n\tif (!block->bb_numrecs)\n\t\treturn 0;\n\t/*\n\t * Set the ptr value to 1, that's the first record/key.\n\t */\n\tcur->bc_ptrs[level] = 1;\n\treturn 1;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_check_block",
          "args": [
            "cur",
            "block",
            "level",
            "bp"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "149-160",
          "snippet": "int\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_block",
          "args": [
            "cur",
            "level",
            "&bp"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "528-542",
          "snippet": "xfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\t\t\t\t/* success=1, failure=0 */\nxfs_btree_firstrec(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel)\t/* level to change */\n{\n\tstruct xfs_btree_block\t*block;\t/* generic btree block pointer */\n\txfs_buf_t\t\t*bp;\t/* buffer containing block */\n\n\t/*\n\t * Get the block pointer for this level.\n\t */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\txfs_btree_check_block(cur, block, level, bp);\n\t/*\n\t * It's empty, there is no such record.\n\t */\n\tif (!block->bb_numrecs)\n\t\treturn 0;\n\t/*\n\t * Set the ptr value to 1, that's the first record/key.\n\t */\n\tcur->bc_ptrs[level] = 1;\n\treturn 1;\n}"
  },
  {
    "function_name": "xfs_btree_islastblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "585-599",
    "snippet": "int\t\t\t\t\t/* 1=is last block, 0=not last block */\nxfs_btree_islastblock(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel)\t/* level to check */\n{\n\tstruct xfs_btree_block\t*block;\t/* generic btree block pointer */\n\txfs_buf_t\t\t*bp;\t/* buffer containing block */\n\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\txfs_btree_check_block(cur, block, level, bp);\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn block->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn block->bb_u.s.bb_rightsib == cpu_to_be32(NULLAGBLOCK);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGBLOCK"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "NULLFSBLOCK"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_check_block",
          "args": [
            "cur",
            "block",
            "level",
            "bp"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "149-160",
          "snippet": "int\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_block",
          "args": [
            "cur",
            "level",
            "&bp"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "528-542",
          "snippet": "xfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\t\t\t\t\t/* 1=is last block, 0=not last block */\nxfs_btree_islastblock(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel)\t/* level to check */\n{\n\tstruct xfs_btree_block\t*block;\t/* generic btree block pointer */\n\txfs_buf_t\t\t*bp;\t/* buffer containing block */\n\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\txfs_btree_check_block(cur, block, level, bp);\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn block->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK);\n\telse\n\t\treturn block->bb_u.s.bb_rightsib == cpu_to_be32(NULLAGBLOCK);\n}"
  },
  {
    "function_name": "xfs_btree_get_bufs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "566-580",
    "snippet": "xfs_buf_t *\t\t\t\t/* buffer for agno/agbno */\nxfs_btree_get_bufs(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_agnumber_t\tagno,\t\t/* allocation group number */\n\txfs_agblock_t\tagbno,\t\t/* allocation group block number */\n\tuint\t\tlock)\t\t/* lock flags for get_buf */\n{\n\txfs_daddr_t\t\td;\t\t/* real disk block address */\n\n\tASSERT(agno != NULLAGNUMBER);\n\tASSERT(agbno != NULLAGBLOCK);\n\td = XFS_AGB_TO_DADDR(mp, agno, agbno);\n\treturn xfs_trans_get_buf(tp, mp->m_ddev_targp, d, mp->m_bsize, lock);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_get_buf",
          "args": [
            "tp",
            "mp->m_ddev_targp",
            "d",
            "mp->m_bsize",
            "lock"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_get_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "166-176",
          "snippet": "static inline struct xfs_buf *\nxfs_trans_get_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\tuint\t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_get_buf_map(tp, target, &map, 1, flags);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_buf *\nxfs_trans_get_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\tuint\t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_get_buf_map(tp, target, &map, 1, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_AGB_TO_DADDR",
          "args": [
            "mp",
            "agno",
            "agbno"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "agbno != NULLAGBLOCK"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "agno != NULLAGNUMBER"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_buf_t *\t\t\t\t/* buffer for agno/agbno */\nxfs_btree_get_bufs(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_agnumber_t\tagno,\t\t/* allocation group number */\n\txfs_agblock_t\tagbno,\t\t/* allocation group block number */\n\tuint\t\tlock)\t\t/* lock flags for get_buf */\n{\n\txfs_daddr_t\t\td;\t\t/* real disk block address */\n\n\tASSERT(agno != NULLAGNUMBER);\n\tASSERT(agbno != NULLAGBLOCK);\n\td = XFS_AGB_TO_DADDR(mp, agno, agbno);\n\treturn xfs_trans_get_buf(tp, mp->m_ddev_targp, d, mp->m_bsize, lock);\n}"
  },
  {
    "function_name": "xfs_btree_get_bufl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "548-560",
    "snippet": "xfs_buf_t *\t\t\t\t/* buffer for fsbno */\nxfs_btree_get_bufl(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_fsblock_t\tfsbno,\t\t/* file system block number */\n\tuint\t\tlock)\t\t/* lock flags for get_buf */\n{\n\txfs_daddr_t\t\td;\t\t/* real disk block address */\n\n\tASSERT(fsbno != NULLFSBLOCK);\n\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\treturn xfs_trans_get_buf(tp, mp->m_ddev_targp, d, mp->m_bsize, lock);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_get_buf",
          "args": [
            "tp",
            "mp->m_ddev_targp",
            "d",
            "mp->m_bsize",
            "lock"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_get_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "166-176",
          "snippet": "static inline struct xfs_buf *\nxfs_trans_get_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\tuint\t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_get_buf_map(tp, target, &map, 1, flags);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_buf *\nxfs_trans_get_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\tuint\t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_get_buf_map(tp, target, &map, 1, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "mp",
            "fsbno"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "fsbno != NULLFSBLOCK"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_buf_t *\t\t\t\t/* buffer for fsbno */\nxfs_btree_get_bufl(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_fsblock_t\tfsbno,\t\t/* file system block number */\n\tuint\t\tlock)\t\t/* lock flags for get_buf */\n{\n\txfs_daddr_t\t\td;\t\t/* real disk block address */\n\n\tASSERT(fsbno != NULLFSBLOCK);\n\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\treturn xfs_trans_get_buf(tp, mp->m_ddev_targp, d, mp->m_bsize, lock);\n}"
  },
  {
    "function_name": "xfs_btree_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "528-542",
    "snippet": "xfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "*bpp"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_iroot",
          "args": [
            "cur"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_iroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "514-522",
          "snippet": "xfs_btree_block *\nxfs_btree_get_iroot(\n       struct xfs_btree_cur    *cur)\n{\n       struct xfs_ifork        *ifp;\n\n       ifp = XFS_IFORK_PTR(cur->bc_private.b.ip, cur->bc_private.b.whichfork);\n       return (struct xfs_btree_block *)ifp->if_broot;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_btree_block *\nxfs_btree_get_iroot(\n       struct xfs_btree_cur    *cur)\n{\n       struct xfs_ifork        *ifp;\n\n       ifp = XFS_IFORK_PTR(cur->bc_private.b.ip, cur->bc_private.b.whichfork);\n       return (struct xfs_btree_block *)ifp->if_broot;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_btree_block *\t\t/* generic btree block pointer */\nxfs_btree_get_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tint\t\t\tlevel,\t/* level in btree */\n\tstruct xfs_buf\t\t**bpp)\t/* buffer containing the block */\n{\n\tif ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&\n\t    (level == cur->bc_nlevels - 1)) {\n\t\t*bpp = NULL;\n\t\treturn xfs_btree_get_iroot(cur);\n\t}\n\n\t*bpp = cur->bc_bufs[level];\n\treturn XFS_BUF_TO_BLOCK(*bpp);\n}"
  },
  {
    "function_name": "xfs_btree_get_iroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "514-522",
    "snippet": "xfs_btree_block *\nxfs_btree_get_iroot(\n       struct xfs_btree_cur    *cur)\n{\n       struct xfs_ifork        *ifp;\n\n       ifp = XFS_IFORK_PTR(cur->bc_private.b.ip, cur->bc_private.b.whichfork);\n       return (struct xfs_btree_block *)ifp->if_broot;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "cur->bc_private.b.ip",
            "cur->bc_private.b.whichfork"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nxfs_btree_block *\nxfs_btree_get_iroot(\n       struct xfs_btree_cur    *cur)\n{\n       struct xfs_ifork        *ifp;\n\n       ifp = XFS_IFORK_PTR(cur->bc_private.b.ip, cur->bc_private.b.whichfork);\n       return (struct xfs_btree_block *)ifp->if_broot;\n}"
  },
  {
    "function_name": "xfs_btree_ptr_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "494-506",
    "snippet": "xfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_ptr_offset",
          "args": [
            "cur",
            "n",
            "level"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "454-463",
          "snippet": "STATIC size_t\nxfs_btree_ptr_offset(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tint\t\t\tlevel)\n{\n\treturn xfs_btree_block_len(cur) +\n\t\tcur->bc_ops->get_maxrecs(cur, level) * cur->bc_ops->key_len +\n\t\t(n - 1) * xfs_btree_ptr_len(cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC size_t\nxfs_btree_ptr_offset(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tint\t\t\tlevel)\n{\n\treturn xfs_btree_block_len(cur) +\n\t\tcur->bc_ops->get_maxrecs(cur, level) * cur->bc_ops->key_len +\n\t\t(n - 1) * xfs_btree_ptr_len(cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "block->bb_level != 0"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_level",
          "args": [
            "block"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "427-430",
          "snippet": "static inline int xfs_btree_get_level(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_level);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_btree_get_level(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_level);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_ptr *\nxfs_btree_ptr_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\tint\t\t\tlevel = xfs_btree_get_level(block);\n\n\tASSERT(block->bb_level != 0);\n\n\treturn (union xfs_btree_ptr *)\n\t\t((char *)block + xfs_btree_ptr_offset(cur, n, level));\n}"
  },
  {
    "function_name": "xfs_btree_key_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "481-489",
    "snippet": "xfs_btree_key *\nxfs_btree_key_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_key *)\n\t\t((char *)block + xfs_btree_key_offset(cur, n));\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_key_offset",
          "args": [
            "cur",
            "n"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_key_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "442-449",
          "snippet": "STATIC size_t\nxfs_btree_key_offset(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn)\n{\n\treturn xfs_btree_block_len(cur) +\n\t\t(n - 1) * cur->bc_ops->key_len;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC size_t\nxfs_btree_key_offset(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn)\n{\n\treturn xfs_btree_block_len(cur) +\n\t\t(n - 1) * cur->bc_ops->key_len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_key *\nxfs_btree_key_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_key *)\n\t\t((char *)block + xfs_btree_key_offset(cur, n));\n}"
  },
  {
    "function_name": "xfs_btree_rec_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "468-476",
    "snippet": "xfs_btree_rec *\nxfs_btree_rec_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_rec *)\n\t\t((char *)block + xfs_btree_rec_offset(cur, n));\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_rec_offset",
          "args": [
            "cur",
            "n"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_rec_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "430-437",
          "snippet": "STATIC size_t\nxfs_btree_rec_offset(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn)\n{\n\treturn xfs_btree_block_len(cur) +\n\t\t(n - 1) * cur->bc_ops->rec_len;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC size_t\nxfs_btree_rec_offset(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn)\n{\n\treturn xfs_btree_block_len(cur) +\n\t\t(n - 1) * cur->bc_ops->rec_len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nxfs_btree_rec *\nxfs_btree_rec_addr(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tstruct xfs_btree_block\t*block)\n{\n\treturn (union xfs_btree_rec *)\n\t\t((char *)block + xfs_btree_rec_offset(cur, n));\n}"
  },
  {
    "function_name": "xfs_btree_ptr_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "454-463",
    "snippet": "STATIC size_t\nxfs_btree_ptr_offset(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tint\t\t\tlevel)\n{\n\treturn xfs_btree_block_len(cur) +\n\t\tcur->bc_ops->get_maxrecs(cur, level) * cur->bc_ops->key_len +\n\t\t(n - 1) * xfs_btree_ptr_len(cur);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_ptr_len",
          "args": [
            "cur"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_ptr_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "421-425",
          "snippet": "static inline size_t xfs_btree_ptr_len(struct xfs_btree_cur *cur)\n{\n\treturn (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\tsizeof(__be64) : sizeof(__be32);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic inline size_t xfs_btree_ptr_len(struct xfs_btree_cur *cur)\n{\n\treturn (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\tsizeof(__be64) : sizeof(__be32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->get_maxrecs",
          "args": [
            "cur",
            "level"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_block_len",
          "args": [
            "cur"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_block_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "406-416",
          "snippet": "static inline size_t xfs_btree_block_len(struct xfs_btree_cur *cur)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS)\n\t\t\treturn XFS_BTREE_LBLOCK_CRC_LEN;\n\t\treturn XFS_BTREE_LBLOCK_LEN;\n\t}\n\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS)\n\t\treturn XFS_BTREE_SBLOCK_CRC_LEN;\n\treturn XFS_BTREE_SBLOCK_LEN;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic inline size_t xfs_btree_block_len(struct xfs_btree_cur *cur)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS)\n\t\t\treturn XFS_BTREE_LBLOCK_CRC_LEN;\n\t\treturn XFS_BTREE_LBLOCK_LEN;\n\t}\n\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS)\n\t\treturn XFS_BTREE_SBLOCK_CRC_LEN;\n\treturn XFS_BTREE_SBLOCK_LEN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC size_t\nxfs_btree_ptr_offset(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn,\n\tint\t\t\tlevel)\n{\n\treturn xfs_btree_block_len(cur) +\n\t\tcur->bc_ops->get_maxrecs(cur, level) * cur->bc_ops->key_len +\n\t\t(n - 1) * xfs_btree_ptr_len(cur);\n}"
  },
  {
    "function_name": "xfs_btree_key_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "442-449",
    "snippet": "STATIC size_t\nxfs_btree_key_offset(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn)\n{\n\treturn xfs_btree_block_len(cur) +\n\t\t(n - 1) * cur->bc_ops->key_len;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_block_len",
          "args": [
            "cur"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_block_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "406-416",
          "snippet": "static inline size_t xfs_btree_block_len(struct xfs_btree_cur *cur)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS)\n\t\t\treturn XFS_BTREE_LBLOCK_CRC_LEN;\n\t\treturn XFS_BTREE_LBLOCK_LEN;\n\t}\n\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS)\n\t\treturn XFS_BTREE_SBLOCK_CRC_LEN;\n\treturn XFS_BTREE_SBLOCK_LEN;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic inline size_t xfs_btree_block_len(struct xfs_btree_cur *cur)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS)\n\t\t\treturn XFS_BTREE_LBLOCK_CRC_LEN;\n\t\treturn XFS_BTREE_LBLOCK_LEN;\n\t}\n\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS)\n\t\treturn XFS_BTREE_SBLOCK_CRC_LEN;\n\treturn XFS_BTREE_SBLOCK_LEN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC size_t\nxfs_btree_key_offset(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn)\n{\n\treturn xfs_btree_block_len(cur) +\n\t\t(n - 1) * cur->bc_ops->key_len;\n}"
  },
  {
    "function_name": "xfs_btree_rec_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "430-437",
    "snippet": "STATIC size_t\nxfs_btree_rec_offset(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn)\n{\n\treturn xfs_btree_block_len(cur) +\n\t\t(n - 1) * cur->bc_ops->rec_len;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_block_len",
          "args": [
            "cur"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_block_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "406-416",
          "snippet": "static inline size_t xfs_btree_block_len(struct xfs_btree_cur *cur)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS)\n\t\t\treturn XFS_BTREE_LBLOCK_CRC_LEN;\n\t\treturn XFS_BTREE_LBLOCK_LEN;\n\t}\n\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS)\n\t\treturn XFS_BTREE_SBLOCK_CRC_LEN;\n\treturn XFS_BTREE_SBLOCK_LEN;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic inline size_t xfs_btree_block_len(struct xfs_btree_cur *cur)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS)\n\t\t\treturn XFS_BTREE_LBLOCK_CRC_LEN;\n\t\treturn XFS_BTREE_LBLOCK_LEN;\n\t}\n\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS)\n\t\treturn XFS_BTREE_SBLOCK_CRC_LEN;\n\treturn XFS_BTREE_SBLOCK_LEN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC size_t\nxfs_btree_rec_offset(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tn)\n{\n\treturn xfs_btree_block_len(cur) +\n\t\t(n - 1) * cur->bc_ops->rec_len;\n}"
  },
  {
    "function_name": "xfs_btree_ptr_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "421-425",
    "snippet": "static inline size_t xfs_btree_ptr_len(struct xfs_btree_cur *cur)\n{\n\treturn (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\tsizeof(__be64) : sizeof(__be32);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic inline size_t xfs_btree_ptr_len(struct xfs_btree_cur *cur)\n{\n\treturn (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\tsizeof(__be64) : sizeof(__be32);\n}"
  },
  {
    "function_name": "xfs_btree_block_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "406-416",
    "snippet": "static inline size_t xfs_btree_block_len(struct xfs_btree_cur *cur)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS)\n\t\t\treturn XFS_BTREE_LBLOCK_CRC_LEN;\n\t\treturn XFS_BTREE_LBLOCK_LEN;\n\t}\n\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS)\n\t\treturn XFS_BTREE_SBLOCK_CRC_LEN;\n\treturn XFS_BTREE_SBLOCK_LEN;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic inline size_t xfs_btree_block_len(struct xfs_btree_cur *cur)\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS)\n\t\t\treturn XFS_BTREE_LBLOCK_CRC_LEN;\n\t\treturn XFS_BTREE_LBLOCK_LEN;\n\t}\n\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS)\n\t\treturn XFS_BTREE_SBLOCK_CRC_LEN;\n\treturn XFS_BTREE_SBLOCK_LEN;\n}"
  },
  {
    "function_name": "xfs_btree_dup_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "324-371",
    "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_dup_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* input cursor */\n\txfs_btree_cur_t\t**ncur)\t\t/* output cursor */\n{\n\txfs_buf_t\t*bp;\t\t/* btree block's buffer pointer */\n\tint\t\terror;\t\t/* error return value */\n\tint\t\ti;\t\t/* level number of btree block */\n\txfs_mount_t\t*mp;\t\t/* mount structure for filesystem */\n\txfs_btree_cur_t\t*new;\t\t/* new cursor value */\n\txfs_trans_t\t*tp;\t\t/* transaction pointer, can be NULL */\n\n\ttp = cur->bc_tp;\n\tmp = cur->bc_mp;\n\n\t/*\n\t * Allocate a new cursor like the old one.\n\t */\n\tnew = cur->bc_ops->dup_cursor(cur);\n\n\t/*\n\t * Copy the record currently in the cursor.\n\t */\n\tnew->bc_rec = cur->bc_rec;\n\n\t/*\n\t * For each level current, re-get the buffer and copy the ptr value.\n\t */\n\tfor (i = 0; i < new->bc_nlevels; i++) {\n\t\tnew->bc_ptrs[i] = cur->bc_ptrs[i];\n\t\tnew->bc_ra[i] = cur->bc_ra[i];\n\t\tbp = cur->bc_bufs[i];\n\t\tif (bp) {\n\t\t\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t\t\t   XFS_BUF_ADDR(bp), mp->m_bsize,\n\t\t\t\t\t\t   0, &bp,\n\t\t\t\t\t\t   cur->bc_ops->buf_ops);\n\t\t\tif (error) {\n\t\t\t\txfs_btree_del_cursor(new, error);\n\t\t\t\t*ncur = NULL;\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tnew->bc_bufs[i] = bp;\n\t}\n\t*ncur = new;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "new",
            "error"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_read_buf",
          "args": [
            "mp",
            "tp",
            "mp->m_ddev_targp",
            "XFS_BUF_ADDR(bp)",
            "mp->m_bsize",
            "0",
            "&bp",
            "cur->bc_ops->buf_ops"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "186-200",
          "snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ADDR",
          "args": [
            "bp"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->dup_cursor",
          "args": [
            "cur"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_btree_dup_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* input cursor */\n\txfs_btree_cur_t\t**ncur)\t\t/* output cursor */\n{\n\txfs_buf_t\t*bp;\t\t/* btree block's buffer pointer */\n\tint\t\terror;\t\t/* error return value */\n\tint\t\ti;\t\t/* level number of btree block */\n\txfs_mount_t\t*mp;\t\t/* mount structure for filesystem */\n\txfs_btree_cur_t\t*new;\t\t/* new cursor value */\n\txfs_trans_t\t*tp;\t\t/* transaction pointer, can be NULL */\n\n\ttp = cur->bc_tp;\n\tmp = cur->bc_mp;\n\n\t/*\n\t * Allocate a new cursor like the old one.\n\t */\n\tnew = cur->bc_ops->dup_cursor(cur);\n\n\t/*\n\t * Copy the record currently in the cursor.\n\t */\n\tnew->bc_rec = cur->bc_rec;\n\n\t/*\n\t * For each level current, re-get the buffer and copy the ptr value.\n\t */\n\tfor (i = 0; i < new->bc_nlevels; i++) {\n\t\tnew->bc_ptrs[i] = cur->bc_ptrs[i];\n\t\tnew->bc_ra[i] = cur->bc_ra[i];\n\t\tbp = cur->bc_bufs[i];\n\t\tif (bp) {\n\t\t\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t\t\t   XFS_BUF_ADDR(bp), mp->m_bsize,\n\t\t\t\t\t\t   0, &bp,\n\t\t\t\t\t\t   cur->bc_ops->buf_ops);\n\t\t\tif (error) {\n\t\t\t\txfs_btree_del_cursor(new, error);\n\t\t\t\t*ncur = NULL;\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tnew->bc_bufs[i] = bp;\n\t}\n\t*ncur = new;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_btree_del_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "285-318",
    "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kmem_zone_t\t*xfs_btree_cur_zone;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_zone_free",
          "args": [
            "xfs_btree_cur_zone",
            "cur"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "104-108",
          "snippet": "static inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "cur->bc_tp",
            "cur->bc_bufs[i]"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
  },
  {
    "function_name": "xfs_btree_sblock_verify_crc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "272-280",
    "snippet": "bool\nxfs_btree_sblock_verify_crc(\n\tstruct xfs_buf\t\t*bp)\n{\n\tif (xfs_sb_version_hascrc(&bp->b_target->bt_mount->m_sb))\n\t\treturn xfs_buf_verify_cksum(bp, XFS_BTREE_SBLOCK_CRC_OFF);\n\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_verify_cksum",
          "args": [
            "bp",
            "XFS_BTREE_SBLOCK_CRC_OFF"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_verify_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "367-372",
          "snippet": "static inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&bp->b_target->bt_mount->m_sb"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nbool\nxfs_btree_sblock_verify_crc(\n\tstruct xfs_buf\t\t*bp)\n{\n\tif (xfs_sb_version_hascrc(&bp->b_target->bt_mount->m_sb))\n\t\treturn xfs_buf_verify_cksum(bp, XFS_BTREE_SBLOCK_CRC_OFF);\n\n\treturn true;\n}"
  },
  {
    "function_name": "xfs_btree_sblock_calc_crc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "258-270",
    "snippet": "void\nxfs_btree_sblock_calc_crc(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!xfs_sb_version_hascrc(&bp->b_target->bt_mount->m_sb))\n\t\treturn;\n\tif (bip)\n\t\tblock->bb_u.s.bb_lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\txfs_buf_update_cksum(bp, XFS_BTREE_SBLOCK_CRC_OFF);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_update_cksum",
          "args": [
            "bp",
            "XFS_BTREE_SBLOCK_CRC_OFF"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_update_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "374-379",
          "snippet": "static inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bip->bli_item.li_lsn"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&bp->b_target->bt_mount->m_sb"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "bp"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_sblock_calc_crc(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!xfs_sb_version_hascrc(&bp->b_target->bt_mount->m_sb))\n\t\treturn;\n\tif (bip)\n\t\tblock->bb_u.s.bb_lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\txfs_buf_update_cksum(bp, XFS_BTREE_SBLOCK_CRC_OFF);\n}"
  },
  {
    "function_name": "xfs_btree_lblock_verify_crc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "240-248",
    "snippet": "bool\nxfs_btree_lblock_verify_crc(\n\tstruct xfs_buf\t\t*bp)\n{\n\tif (xfs_sb_version_hascrc(&bp->b_target->bt_mount->m_sb))\n\t\treturn xfs_buf_verify_cksum(bp, XFS_BTREE_LBLOCK_CRC_OFF);\n\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_verify_cksum",
          "args": [
            "bp",
            "XFS_BTREE_LBLOCK_CRC_OFF"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_verify_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "367-372",
          "snippet": "static inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&bp->b_target->bt_mount->m_sb"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nbool\nxfs_btree_lblock_verify_crc(\n\tstruct xfs_buf\t\t*bp)\n{\n\tif (xfs_sb_version_hascrc(&bp->b_target->bt_mount->m_sb))\n\t\treturn xfs_buf_verify_cksum(bp, XFS_BTREE_LBLOCK_CRC_OFF);\n\n\treturn true;\n}"
  },
  {
    "function_name": "xfs_btree_lblock_calc_crc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "226-238",
    "snippet": "void\nxfs_btree_lblock_calc_crc(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!xfs_sb_version_hascrc(&bp->b_target->bt_mount->m_sb))\n\t\treturn;\n\tif (bip)\n\t\tblock->bb_u.l.bb_lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\txfs_buf_update_cksum(bp, XFS_BTREE_LBLOCK_CRC_OFF);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_update_cksum",
          "args": [
            "bp",
            "XFS_BTREE_LBLOCK_CRC_OFF"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_update_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "374-379",
          "snippet": "static inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bip->bli_item.li_lsn"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&bp->b_target->bt_mount->m_sb"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "bp"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_lblock_calc_crc(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!xfs_sb_version_hascrc(&bp->b_target->bt_mount->m_sb))\n\t\treturn;\n\tif (bip)\n\t\tblock->bb_u.l.bb_lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\txfs_buf_update_cksum(bp, XFS_BTREE_LBLOCK_CRC_OFF);\n}"
  },
  {
    "function_name": "xfs_btree_check_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "201-215",
    "snippet": "STATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_ptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tunion xfs_btree_ptr\t*ptr,\t/* btree block disk address */\n\tint\t\t\tindex,\t/* offset from ptr to check */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\treturn xfs_btree_check_lptr(cur,\n\t\t\t\tbe64_to_cpu((&ptr->l)[index]), level);\n\t} else {\n\t\treturn xfs_btree_check_sptr(cur,\n\t\t\t\tbe32_to_cpu((&ptr->s)[index]), level);\n\t}\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC union",
      "STATIC union",
      "STATIC union",
      "STATIC struct",
      "STATIC struct",
      "STATIC union"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_check_sptr",
          "args": [
            "cur",
            "be32_to_cpu((&ptr->s)[index])",
            "level"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_sptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "182-196",
          "snippet": "STATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_sptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* btree block disk address */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\txfs_agblock_t\t\tagblocks = cur->bc_mp->m_sb.sb_agblocks;\n\n\tXFS_WANT_CORRUPTED_RETURN(\n\t\tlevel > 0 &&\n\t\tbno != NULLAGBLOCK &&\n\t\tbno != 0 &&\n\t\tbno < agblocks);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_sptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* btree block disk address */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\txfs_agblock_t\t\tagblocks = cur->bc_mp->m_sb.sb_agblocks;\n\n\tXFS_WANT_CORRUPTED_RETURN(\n\t\tlevel > 0 &&\n\t\tbno != NULLAGBLOCK &&\n\t\tbno != 0 &&\n\t\tbno < agblocks);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "(&ptr->s)[index]"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_check_lptr",
          "args": [
            "cur",
            "be64_to_cpu((&ptr->l)[index])",
            "level"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_lptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "165-176",
          "snippet": "int\t\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_lptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_fsblock_t\t\tbno,\t/* btree block disk address */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\tXFS_WANT_CORRUPTED_RETURN(\n\t\tlevel > 0 &&\n\t\tbno != NULLFSBLOCK &&\n\t\tXFS_FSB_SANITY_CHECK(cur->bc_mp, bno));\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\t\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_lptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_fsblock_t\t\tbno,\t/* btree block disk address */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\tXFS_WANT_CORRUPTED_RETURN(\n\t\tlevel > 0 &&\n\t\tbno != NULLFSBLOCK &&\n\t\tXFS_FSB_SANITY_CHECK(cur->bc_mp, bno));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "(&ptr->l)[index]"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nSTATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_ptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tunion xfs_btree_ptr\t*ptr,\t/* btree block disk address */\n\tint\t\t\tindex,\t/* offset from ptr to check */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS) {\n\t\treturn xfs_btree_check_lptr(cur,\n\t\t\t\tbe64_to_cpu((&ptr->l)[index]), level);\n\t} else {\n\t\treturn xfs_btree_check_sptr(cur,\n\t\t\t\tbe32_to_cpu((&ptr->s)[index]), level);\n\t}\n}"
  },
  {
    "function_name": "xfs_btree_check_sptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "182-196",
    "snippet": "STATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_sptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* btree block disk address */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\txfs_agblock_t\t\tagblocks = cur->bc_mp->m_sb.sb_agblocks;\n\n\tXFS_WANT_CORRUPTED_RETURN(\n\t\tlevel > 0 &&\n\t\tbno != NULLAGBLOCK &&\n\t\tbno != 0 &&\n\t\tbno < agblocks);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "level > 0 &&\n\t\tbno != NULLAGBLOCK &&\n\t\tbno != 0 &&\n\t\tbno < agblocks"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_sptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_agblock_t\t\tbno,\t/* btree block disk address */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\txfs_agblock_t\t\tagblocks = cur->bc_mp->m_sb.sb_agblocks;\n\n\tXFS_WANT_CORRUPTED_RETURN(\n\t\tlevel > 0 &&\n\t\tbno != NULLAGBLOCK &&\n\t\tbno != 0 &&\n\t\tbno < agblocks);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_btree_check_lptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "165-176",
    "snippet": "int\t\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_lptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_fsblock_t\t\tbno,\t/* btree block disk address */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\tXFS_WANT_CORRUPTED_RETURN(\n\t\tlevel > 0 &&\n\t\tbno != NULLFSBLOCK &&\n\t\tXFS_FSB_SANITY_CHECK(cur->bc_mp, bno));\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "level > 0 &&\n\t\tbno != NULLFSBLOCK &&\n\t\tXFS_FSB_SANITY_CHECK(cur->bc_mp, bno)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_SANITY_CHECK",
          "args": [
            "cur->bc_mp",
            "bno"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\t\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_lptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_fsblock_t\t\tbno,\t/* btree block disk address */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\tXFS_WANT_CORRUPTED_RETURN(\n\t\tlevel > 0 &&\n\t\tbno != NULLFSBLOCK &&\n\t\tXFS_FSB_SANITY_CHECK(cur->bc_mp, bno));\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_btree_check_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "149-160",
    "snippet": "int\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_check_sblock",
          "args": [
            "cur",
            "block",
            "level",
            "bp"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_sblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "98-144",
          "snippet": "STATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_sblock(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* btree short form block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block */\n{\n\tstruct xfs_mount\t*mp;\t/* file system mount point */\n\tstruct xfs_buf\t\t*agbp;\t/* buffer for ag. freespace struct */\n\tstruct xfs_agf\t\t*agf;\t/* ag. freespace structure */\n\txfs_agblock_t\t\tagflen;\t/* native ag. freespace length */\n\tint\t\t\tsblock_ok = 1; /* block passes checks */\n\n\tmp = cur->bc_mp;\n\tagbp = cur->bc_private.a.agbp;\n\tagf = XFS_BUF_TO_AGF(agbp);\n\tagflen = be32_to_cpu(agf->agf_length);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tsblock_ok = sblock_ok &&\n\t\t\tuuid_equal(&block->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid) &&\n\t\t\tblock->bb_u.s.bb_blkno == cpu_to_be64(\n\t\t\t\tbp ? bp->b_bn : XFS_BUF_DADDR_NULL);\n\t}\n\n\tsblock_ok = sblock_ok &&\n\t\tbe32_to_cpu(block->bb_magic) == xfs_btree_magic(cur) &&\n\t\tbe16_to_cpu(block->bb_level) == level &&\n\t\tbe16_to_cpu(block->bb_numrecs) <=\n\t\t\tcur->bc_ops->get_maxrecs(cur, level) &&\n\t\t(block->bb_u.s.bb_leftsib == cpu_to_be32(NULLAGBLOCK) ||\n\t\t be32_to_cpu(block->bb_u.s.bb_leftsib) < agflen) &&\n\t\tblock->bb_u.s.bb_leftsib &&\n\t\t(block->bb_u.s.bb_rightsib == cpu_to_be32(NULLAGBLOCK) ||\n\t\t be32_to_cpu(block->bb_u.s.bb_rightsib) < agflen) &&\n\t\tblock->bb_u.s.bb_rightsib;\n\n\tif (unlikely(XFS_TEST_ERROR(!sblock_ok, mp,\n\t\t\tXFS_ERRTAG_BTREE_CHECK_SBLOCK,\n\t\t\tXFS_RANDOM_BTREE_CHECK_SBLOCK))) {\n\t\tif (bp)\n\t\t\ttrace_xfs_btree_corrupt(bp, _RET_IP_);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_sblock(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* btree short form block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block */\n{\n\tstruct xfs_mount\t*mp;\t/* file system mount point */\n\tstruct xfs_buf\t\t*agbp;\t/* buffer for ag. freespace struct */\n\tstruct xfs_agf\t\t*agf;\t/* ag. freespace structure */\n\txfs_agblock_t\t\tagflen;\t/* native ag. freespace length */\n\tint\t\t\tsblock_ok = 1; /* block passes checks */\n\n\tmp = cur->bc_mp;\n\tagbp = cur->bc_private.a.agbp;\n\tagf = XFS_BUF_TO_AGF(agbp);\n\tagflen = be32_to_cpu(agf->agf_length);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tsblock_ok = sblock_ok &&\n\t\t\tuuid_equal(&block->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid) &&\n\t\t\tblock->bb_u.s.bb_blkno == cpu_to_be64(\n\t\t\t\tbp ? bp->b_bn : XFS_BUF_DADDR_NULL);\n\t}\n\n\tsblock_ok = sblock_ok &&\n\t\tbe32_to_cpu(block->bb_magic) == xfs_btree_magic(cur) &&\n\t\tbe16_to_cpu(block->bb_level) == level &&\n\t\tbe16_to_cpu(block->bb_numrecs) <=\n\t\t\tcur->bc_ops->get_maxrecs(cur, level) &&\n\t\t(block->bb_u.s.bb_leftsib == cpu_to_be32(NULLAGBLOCK) ||\n\t\t be32_to_cpu(block->bb_u.s.bb_leftsib) < agflen) &&\n\t\tblock->bb_u.s.bb_leftsib &&\n\t\t(block->bb_u.s.bb_rightsib == cpu_to_be32(NULLAGBLOCK) ||\n\t\t be32_to_cpu(block->bb_u.s.bb_rightsib) < agflen) &&\n\t\tblock->bb_u.s.bb_rightsib;\n\n\tif (unlikely(XFS_TEST_ERROR(!sblock_ok, mp,\n\t\t\tXFS_ERRTAG_BTREE_CHECK_SBLOCK,\n\t\t\tXFS_RANDOM_BTREE_CHECK_SBLOCK))) {\n\t\tif (bp)\n\t\t\ttrace_xfs_btree_corrupt(bp, _RET_IP_);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_check_lblock",
          "args": [
            "cur",
            "block",
            "level",
            "bp"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_lblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "54-96",
          "snippet": "STATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_lblock(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* btree long form block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer for block, if any */\n{\n\tint\t\t\tlblock_ok = 1; /* block passes checks */\n\tstruct xfs_mount\t*mp;\t/* file system mount point */\n\n\tmp = cur->bc_mp;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tlblock_ok = lblock_ok &&\n\t\t\tuuid_equal(&block->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid) &&\n\t\t\tblock->bb_u.l.bb_blkno == cpu_to_be64(\n\t\t\t\tbp ? bp->b_bn : XFS_BUF_DADDR_NULL);\n\t}\n\n\tlblock_ok = lblock_ok &&\n\t\tbe32_to_cpu(block->bb_magic) == xfs_btree_magic(cur) &&\n\t\tbe16_to_cpu(block->bb_level) == level &&\n\t\tbe16_to_cpu(block->bb_numrecs) <=\n\t\t\tcur->bc_ops->get_maxrecs(cur, level) &&\n\t\tblock->bb_u.l.bb_leftsib &&\n\t\t(block->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK) ||\n\t\t XFS_FSB_SANITY_CHECK(mp,\n\t\t\tbe64_to_cpu(block->bb_u.l.bb_leftsib))) &&\n\t\tblock->bb_u.l.bb_rightsib &&\n\t\t(block->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK) ||\n\t\t XFS_FSB_SANITY_CHECK(mp,\n\t\t\tbe64_to_cpu(block->bb_u.l.bb_rightsib)));\n\n\tif (unlikely(XFS_TEST_ERROR(!lblock_ok, mp,\n\t\t\tXFS_ERRTAG_BTREE_CHECK_LBLOCK,\n\t\t\tXFS_RANDOM_BTREE_CHECK_LBLOCK))) {\n\t\tif (bp)\n\t\t\ttrace_xfs_btree_corrupt(bp, _RET_IP_);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_lblock(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* btree long form block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer for block, if any */\n{\n\tint\t\t\tlblock_ok = 1; /* block passes checks */\n\tstruct xfs_mount\t*mp;\t/* file system mount point */\n\n\tmp = cur->bc_mp;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tlblock_ok = lblock_ok &&\n\t\t\tuuid_equal(&block->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid) &&\n\t\t\tblock->bb_u.l.bb_blkno == cpu_to_be64(\n\t\t\t\tbp ? bp->b_bn : XFS_BUF_DADDR_NULL);\n\t}\n\n\tlblock_ok = lblock_ok &&\n\t\tbe32_to_cpu(block->bb_magic) == xfs_btree_magic(cur) &&\n\t\tbe16_to_cpu(block->bb_level) == level &&\n\t\tbe16_to_cpu(block->bb_numrecs) <=\n\t\t\tcur->bc_ops->get_maxrecs(cur, level) &&\n\t\tblock->bb_u.l.bb_leftsib &&\n\t\t(block->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK) ||\n\t\t XFS_FSB_SANITY_CHECK(mp,\n\t\t\tbe64_to_cpu(block->bb_u.l.bb_leftsib))) &&\n\t\tblock->bb_u.l.bb_rightsib &&\n\t\t(block->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK) ||\n\t\t XFS_FSB_SANITY_CHECK(mp,\n\t\t\tbe64_to_cpu(block->bb_u.l.bb_rightsib)));\n\n\tif (unlikely(XFS_TEST_ERROR(!lblock_ok, mp,\n\t\t\tXFS_ERRTAG_BTREE_CHECK_LBLOCK,\n\t\t\tXFS_RANDOM_BTREE_CHECK_LBLOCK))) {\n\t\tif (bp)\n\t\t\ttrace_xfs_btree_corrupt(bp, _RET_IP_);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}"
  },
  {
    "function_name": "xfs_btree_check_sblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "98-144",
    "snippet": "STATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_sblock(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* btree short form block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block */\n{\n\tstruct xfs_mount\t*mp;\t/* file system mount point */\n\tstruct xfs_buf\t\t*agbp;\t/* buffer for ag. freespace struct */\n\tstruct xfs_agf\t\t*agf;\t/* ag. freespace structure */\n\txfs_agblock_t\t\tagflen;\t/* native ag. freespace length */\n\tint\t\t\tsblock_ok = 1; /* block passes checks */\n\n\tmp = cur->bc_mp;\n\tagbp = cur->bc_private.a.agbp;\n\tagf = XFS_BUF_TO_AGF(agbp);\n\tagflen = be32_to_cpu(agf->agf_length);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tsblock_ok = sblock_ok &&\n\t\t\tuuid_equal(&block->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid) &&\n\t\t\tblock->bb_u.s.bb_blkno == cpu_to_be64(\n\t\t\t\tbp ? bp->b_bn : XFS_BUF_DADDR_NULL);\n\t}\n\n\tsblock_ok = sblock_ok &&\n\t\tbe32_to_cpu(block->bb_magic) == xfs_btree_magic(cur) &&\n\t\tbe16_to_cpu(block->bb_level) == level &&\n\t\tbe16_to_cpu(block->bb_numrecs) <=\n\t\t\tcur->bc_ops->get_maxrecs(cur, level) &&\n\t\t(block->bb_u.s.bb_leftsib == cpu_to_be32(NULLAGBLOCK) ||\n\t\t be32_to_cpu(block->bb_u.s.bb_leftsib) < agflen) &&\n\t\tblock->bb_u.s.bb_leftsib &&\n\t\t(block->bb_u.s.bb_rightsib == cpu_to_be32(NULLAGBLOCK) ||\n\t\t be32_to_cpu(block->bb_u.s.bb_rightsib) < agflen) &&\n\t\tblock->bb_u.s.bb_rightsib;\n\n\tif (unlikely(XFS_TEST_ERROR(!sblock_ok, mp,\n\t\t\tXFS_ERRTAG_BTREE_CHECK_SBLOCK,\n\t\t\tXFS_RANDOM_BTREE_CHECK_SBLOCK))) {\n\t\tif (bp)\n\t\t\ttrace_xfs_btree_corrupt(bp, _RET_IP_);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "__func__",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_btree_corrupt",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "XFS_TEST_ERROR(!sblock_ok, mp,\n\t\t\tXFS_ERRTAG_BTREE_CHECK_SBLOCK,\n\t\t\tXFS_RANDOM_BTREE_CHECK_SBLOCK)"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_TEST_ERROR",
          "args": [
            "!sblock_ok",
            "mp",
            "XFS_ERRTAG_BTREE_CHECK_SBLOCK",
            "XFS_RANDOM_BTREE_CHECK_SBLOCK"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "block->bb_u.s.bb_rightsib"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGBLOCK"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "block->bb_u.s.bb_leftsib"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NULLAGBLOCK"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->get_maxrecs",
          "args": [
            "cur",
            "level"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "block->bb_numrecs"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "block->bb_level"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_magic",
          "args": [
            "cur"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "block->bb_magic"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bp ? bp->b_bn : XFS_BUF_DADDR_NULL"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_equal",
          "args": [
            "&block->bb_u.s.bb_uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "agf->agf_length"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_AGF",
          "args": [
            "agbp"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_sblock(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* btree short form block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block */\n{\n\tstruct xfs_mount\t*mp;\t/* file system mount point */\n\tstruct xfs_buf\t\t*agbp;\t/* buffer for ag. freespace struct */\n\tstruct xfs_agf\t\t*agf;\t/* ag. freespace structure */\n\txfs_agblock_t\t\tagflen;\t/* native ag. freespace length */\n\tint\t\t\tsblock_ok = 1; /* block passes checks */\n\n\tmp = cur->bc_mp;\n\tagbp = cur->bc_private.a.agbp;\n\tagf = XFS_BUF_TO_AGF(agbp);\n\tagflen = be32_to_cpu(agf->agf_length);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tsblock_ok = sblock_ok &&\n\t\t\tuuid_equal(&block->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid) &&\n\t\t\tblock->bb_u.s.bb_blkno == cpu_to_be64(\n\t\t\t\tbp ? bp->b_bn : XFS_BUF_DADDR_NULL);\n\t}\n\n\tsblock_ok = sblock_ok &&\n\t\tbe32_to_cpu(block->bb_magic) == xfs_btree_magic(cur) &&\n\t\tbe16_to_cpu(block->bb_level) == level &&\n\t\tbe16_to_cpu(block->bb_numrecs) <=\n\t\t\tcur->bc_ops->get_maxrecs(cur, level) &&\n\t\t(block->bb_u.s.bb_leftsib == cpu_to_be32(NULLAGBLOCK) ||\n\t\t be32_to_cpu(block->bb_u.s.bb_leftsib) < agflen) &&\n\t\tblock->bb_u.s.bb_leftsib &&\n\t\t(block->bb_u.s.bb_rightsib == cpu_to_be32(NULLAGBLOCK) ||\n\t\t be32_to_cpu(block->bb_u.s.bb_rightsib) < agflen) &&\n\t\tblock->bb_u.s.bb_rightsib;\n\n\tif (unlikely(XFS_TEST_ERROR(!sblock_ok, mp,\n\t\t\tXFS_ERRTAG_BTREE_CHECK_SBLOCK,\n\t\t\tXFS_RANDOM_BTREE_CHECK_SBLOCK))) {\n\t\tif (bp)\n\t\t\ttrace_xfs_btree_corrupt(bp, _RET_IP_);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_btree_check_lblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
    "lines": "54-96",
    "snippet": "STATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_lblock(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* btree long form block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer for block, if any */\n{\n\tint\t\t\tlblock_ok = 1; /* block passes checks */\n\tstruct xfs_mount\t*mp;\t/* file system mount point */\n\n\tmp = cur->bc_mp;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tlblock_ok = lblock_ok &&\n\t\t\tuuid_equal(&block->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid) &&\n\t\t\tblock->bb_u.l.bb_blkno == cpu_to_be64(\n\t\t\t\tbp ? bp->b_bn : XFS_BUF_DADDR_NULL);\n\t}\n\n\tlblock_ok = lblock_ok &&\n\t\tbe32_to_cpu(block->bb_magic) == xfs_btree_magic(cur) &&\n\t\tbe16_to_cpu(block->bb_level) == level &&\n\t\tbe16_to_cpu(block->bb_numrecs) <=\n\t\t\tcur->bc_ops->get_maxrecs(cur, level) &&\n\t\tblock->bb_u.l.bb_leftsib &&\n\t\t(block->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK) ||\n\t\t XFS_FSB_SANITY_CHECK(mp,\n\t\t\tbe64_to_cpu(block->bb_u.l.bb_leftsib))) &&\n\t\tblock->bb_u.l.bb_rightsib &&\n\t\t(block->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK) ||\n\t\t XFS_FSB_SANITY_CHECK(mp,\n\t\t\tbe64_to_cpu(block->bb_u.l.bb_rightsib)));\n\n\tif (unlikely(XFS_TEST_ERROR(!lblock_ok, mp,\n\t\t\tXFS_ERRTAG_BTREE_CHECK_LBLOCK,\n\t\t\tXFS_RANDOM_BTREE_CHECK_LBLOCK))) {\n\t\tif (bp)\n\t\t\ttrace_xfs_btree_corrupt(bp, _RET_IP_);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "__func__",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_btree_corrupt",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "XFS_TEST_ERROR(!lblock_ok, mp,\n\t\t\tXFS_ERRTAG_BTREE_CHECK_LBLOCK,\n\t\t\tXFS_RANDOM_BTREE_CHECK_LBLOCK)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_TEST_ERROR",
          "args": [
            "!lblock_ok",
            "mp",
            "XFS_ERRTAG_BTREE_CHECK_LBLOCK",
            "XFS_RANDOM_BTREE_CHECK_LBLOCK"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_SANITY_CHECK",
          "args": [
            "mp",
            "be64_to_cpu(block->bb_u.l.bb_rightsib)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "block->bb_u.l.bb_rightsib"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "NULLFSBLOCK"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_SANITY_CHECK",
          "args": [
            "mp",
            "be64_to_cpu(block->bb_u.l.bb_leftsib)"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "block->bb_u.l.bb_leftsib"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "NULLFSBLOCK"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->bc_ops->get_maxrecs",
          "args": [
            "cur",
            "level"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "block->bb_numrecs"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "block->bb_level"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_magic",
          "args": [
            "cur"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "block->bb_magic"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bp ? bp->b_bn : XFS_BUF_DADDR_NULL"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_equal",
          "args": [
            "&block->bb_u.l.bb_uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_lblock(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* btree long form block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer for block, if any */\n{\n\tint\t\t\tlblock_ok = 1; /* block passes checks */\n\tstruct xfs_mount\t*mp;\t/* file system mount point */\n\n\tmp = cur->bc_mp;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tlblock_ok = lblock_ok &&\n\t\t\tuuid_equal(&block->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid) &&\n\t\t\tblock->bb_u.l.bb_blkno == cpu_to_be64(\n\t\t\t\tbp ? bp->b_bn : XFS_BUF_DADDR_NULL);\n\t}\n\n\tlblock_ok = lblock_ok &&\n\t\tbe32_to_cpu(block->bb_magic) == xfs_btree_magic(cur) &&\n\t\tbe16_to_cpu(block->bb_level) == level &&\n\t\tbe16_to_cpu(block->bb_numrecs) <=\n\t\t\tcur->bc_ops->get_maxrecs(cur, level) &&\n\t\tblock->bb_u.l.bb_leftsib &&\n\t\t(block->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK) ||\n\t\t XFS_FSB_SANITY_CHECK(mp,\n\t\t\tbe64_to_cpu(block->bb_u.l.bb_leftsib))) &&\n\t\tblock->bb_u.l.bb_rightsib &&\n\t\t(block->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK) ||\n\t\t XFS_FSB_SANITY_CHECK(mp,\n\t\t\tbe64_to_cpu(block->bb_u.l.bb_rightsib)));\n\n\tif (unlikely(XFS_TEST_ERROR(!lblock_ok, mp,\n\t\t\tXFS_ERRTAG_BTREE_CHECK_LBLOCK,\n\t\t\tXFS_RANDOM_BTREE_CHECK_LBLOCK))) {\n\t\tif (bp)\n\t\t\ttrace_xfs_btree_corrupt(bp, _RET_IP_);\n\t\tXFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}"
  }
]