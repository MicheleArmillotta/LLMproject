[
  {
    "function_name": "hfs_bmap_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/btree.c",
    "lines": "435-497",
    "snippet": "void hfs_bmap_free(struct hfs_bnode *node)\n{\n\tstruct hfs_btree *tree;\n\tstruct page *page;\n\tu16 off, len;\n\tu32 nidx;\n\tu8 *data, byte, m;\n\n\thfs_dbg(BNODE_MOD, \"btree_free_node: %u\\n\", node->this);\n\tBUG_ON(!node->this);\n\ttree = node->tree;\n\tnidx = node->this;\n\tnode = hfs_bnode_find(tree, 0);\n\tif (IS_ERR(node))\n\t\treturn;\n\tlen = hfs_brec_lenoff(node, 2, &off);\n\twhile (nidx >= len * 8) {\n\t\tu32 i;\n\n\t\tnidx -= len * 8;\n\t\ti = node->next;\n\t\thfs_bnode_put(node);\n\t\tif (!i) {\n\t\t\t/* panic */;\n\t\t\tpr_crit(\"unable to free bnode %u. \"\n\t\t\t\t\t\"bmap not found!\\n\",\n\t\t\t\tnode->this);\n\t\t\treturn;\n\t\t}\n\t\tnode = hfs_bnode_find(tree, i);\n\t\tif (IS_ERR(node))\n\t\t\treturn;\n\t\tif (node->type != HFS_NODE_MAP) {\n\t\t\t/* panic */;\n\t\t\tpr_crit(\"invalid bmap found! \"\n\t\t\t\t\t\"(%u,%d)\\n\",\n\t\t\t\tnode->this, node->type);\n\t\t\thfs_bnode_put(node);\n\t\t\treturn;\n\t\t}\n\t\tlen = hfs_brec_lenoff(node, 0, &off);\n\t}\n\toff += node->page_offset + nidx / 8;\n\tpage = node->page[off >> PAGE_CACHE_SHIFT];\n\tdata = kmap(page);\n\toff &= ~PAGE_CACHE_MASK;\n\tm = 1 << (~nidx & 7);\n\tbyte = data[off];\n\tif (!(byte & m)) {\n\t\tpr_crit(\"trying to free free bnode \"\n\t\t\t\t\"%u(%d)\\n\",\n\t\t\tnode->this, node->type);\n\t\tkunmap(page);\n\t\thfs_bnode_put(node);\n\t\treturn;\n\t}\n\tdata[off] = byte & ~m;\n\tset_page_dirty(page);\n\tkunmap(page);\n\thfs_bnode_put(node);\n\ttree->free_nodes++;\n\tmark_inode_dirty(tree->inode);\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/log2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "tree->inode"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_put",
          "args": [
            "node"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "628-657",
          "snippet": "void hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"trying to free free bnode \"\n\t\t\t\t\"%u(%d)\\n\"",
            "node->this",
            "node->type"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_brec_lenoff",
          "args": [
            "node",
            "0",
            "&off"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_lenoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
          "lines": "19-28",
          "snippet": "u16 hfs_brec_lenoff(struct hfs_bnode *node, u16 rec, u16 *off)\n{\n\t__be16 retval[2];\n\tu16 dataoff;\n\n\tdataoff = node->tree->node_size - (rec + 2) * 2;\n\thfs_bnode_read(node, retval, dataoff, 4);\n\t*off = be16_to_cpu(retval[1]);\n\treturn be16_to_cpu(retval[0]) - *off;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nu16 hfs_brec_lenoff(struct hfs_bnode *node, u16 rec, u16 *off)\n{\n\t__be16 retval[2];\n\tu16 dataoff;\n\n\tdataoff = node->tree->node_size - (rec + 2) * 2;\n\thfs_bnode_read(node, retval, dataoff, 4);\n\t*off = be16_to_cpu(retval[1]);\n\treturn be16_to_cpu(retval[0]) - *off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"invalid bmap found! \"\n\t\t\t\t\t\"(%u,%d)\\n\"",
            "node->this",
            "node->type"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "node"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_find",
          "args": [
            "tree",
            "i"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "482-565",
          "snippet": "struct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap(node->page[0]) +\n\t\t\tnode->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap(node->page[0]);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u16(node, off) + 2;\n\t\tif (key_size >= entry_size || key_size & 1)\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap(node->page[0]) +\n\t\t\tnode->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap(node->page[0]);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u16(node, off) + 2;\n\t\tif (key_size >= entry_size || key_size & 1)\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"unable to free bnode %u. \"\n\t\t\t\t\t\"bmap not found!\\n\"",
            "node->this"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "node"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!node->this"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "BNODE_MOD",
            "\"btree_free_node: %u\\n\"",
            "node->this"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/log2.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nvoid hfs_bmap_free(struct hfs_bnode *node)\n{\n\tstruct hfs_btree *tree;\n\tstruct page *page;\n\tu16 off, len;\n\tu32 nidx;\n\tu8 *data, byte, m;\n\n\thfs_dbg(BNODE_MOD, \"btree_free_node: %u\\n\", node->this);\n\tBUG_ON(!node->this);\n\ttree = node->tree;\n\tnidx = node->this;\n\tnode = hfs_bnode_find(tree, 0);\n\tif (IS_ERR(node))\n\t\treturn;\n\tlen = hfs_brec_lenoff(node, 2, &off);\n\twhile (nidx >= len * 8) {\n\t\tu32 i;\n\n\t\tnidx -= len * 8;\n\t\ti = node->next;\n\t\thfs_bnode_put(node);\n\t\tif (!i) {\n\t\t\t/* panic */;\n\t\t\tpr_crit(\"unable to free bnode %u. \"\n\t\t\t\t\t\"bmap not found!\\n\",\n\t\t\t\tnode->this);\n\t\t\treturn;\n\t\t}\n\t\tnode = hfs_bnode_find(tree, i);\n\t\tif (IS_ERR(node))\n\t\t\treturn;\n\t\tif (node->type != HFS_NODE_MAP) {\n\t\t\t/* panic */;\n\t\t\tpr_crit(\"invalid bmap found! \"\n\t\t\t\t\t\"(%u,%d)\\n\",\n\t\t\t\tnode->this, node->type);\n\t\t\thfs_bnode_put(node);\n\t\t\treturn;\n\t\t}\n\t\tlen = hfs_brec_lenoff(node, 0, &off);\n\t}\n\toff += node->page_offset + nidx / 8;\n\tpage = node->page[off >> PAGE_CACHE_SHIFT];\n\tdata = kmap(page);\n\toff &= ~PAGE_CACHE_MASK;\n\tm = 1 << (~nidx & 7);\n\tbyte = data[off];\n\tif (!(byte & m)) {\n\t\tpr_crit(\"trying to free free bnode \"\n\t\t\t\t\"%u(%d)\\n\",\n\t\t\tnode->this, node->type);\n\t\tkunmap(page);\n\t\thfs_bnode_put(node);\n\t\treturn;\n\t}\n\tdata[off] = byte & ~m;\n\tset_page_dirty(page);\n\tkunmap(page);\n\thfs_bnode_put(node);\n\ttree->free_nodes++;\n\tmark_inode_dirty(tree->inode);\n}"
  },
  {
    "function_name": "hfs_bmap_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/btree.c",
    "lines": "344-433",
    "snippet": "struct hfs_bnode *hfs_bmap_alloc(struct hfs_btree *tree)\n{\n\tstruct hfs_bnode *node, *next_node;\n\tstruct page **pagep;\n\tu32 nidx, idx;\n\tunsigned off;\n\tu16 off16;\n\tu16 len;\n\tu8 *data, byte, m;\n\tint i;\n\n\twhile (!tree->free_nodes) {\n\t\tstruct inode *inode = tree->inode;\n\t\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\t\tu32 count;\n\t\tint res;\n\n\t\tres = hfsplus_file_extend(inode, hfs_bnode_need_zeroout(tree));\n\t\tif (res)\n\t\t\treturn ERR_PTR(res);\n\t\thip->phys_size = inode->i_size =\n\t\t\t(loff_t)hip->alloc_blocks <<\n\t\t\t\tHFSPLUS_SB(tree->sb)->alloc_blksz_shift;\n\t\thip->fs_blocks =\n\t\t\thip->alloc_blocks << HFSPLUS_SB(tree->sb)->fs_shift;\n\t\tinode_set_bytes(inode, inode->i_size);\n\t\tcount = inode->i_size >> tree->node_size_shift;\n\t\ttree->free_nodes = count - tree->node_count;\n\t\ttree->node_count = count;\n\t}\n\n\tnidx = 0;\n\tnode = hfs_bnode_find(tree, nidx);\n\tif (IS_ERR(node))\n\t\treturn node;\n\tlen = hfs_brec_lenoff(node, 2, &off16);\n\toff = off16;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\tdata = kmap(*pagep);\n\toff &= ~PAGE_CACHE_MASK;\n\tidx = 0;\n\n\tfor (;;) {\n\t\twhile (len) {\n\t\t\tbyte = data[off];\n\t\t\tif (byte != 0xff) {\n\t\t\t\tfor (m = 0x80, i = 0; i < 8; m >>= 1, i++) {\n\t\t\t\t\tif (!(byte & m)) {\n\t\t\t\t\t\tidx += i;\n\t\t\t\t\t\tdata[off] |= m;\n\t\t\t\t\t\tset_page_dirty(*pagep);\n\t\t\t\t\t\tkunmap(*pagep);\n\t\t\t\t\t\ttree->free_nodes--;\n\t\t\t\t\t\tmark_inode_dirty(tree->inode);\n\t\t\t\t\t\thfs_bnode_put(node);\n\t\t\t\t\t\treturn hfs_bnode_create(tree,\n\t\t\t\t\t\t\tidx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (++off >= PAGE_CACHE_SIZE) {\n\t\t\t\tkunmap(*pagep);\n\t\t\t\tdata = kmap(*++pagep);\n\t\t\t\toff = 0;\n\t\t\t}\n\t\t\tidx += 8;\n\t\t\tlen--;\n\t\t}\n\t\tkunmap(*pagep);\n\t\tnidx = node->next;\n\t\tif (!nidx) {\n\t\t\thfs_dbg(BNODE_MOD, \"create new bmap node\\n\");\n\t\t\tnext_node = hfs_bmap_new_bmap(node, idx);\n\t\t} else\n\t\t\tnext_node = hfs_bnode_find(tree, nidx);\n\t\thfs_bnode_put(node);\n\t\tif (IS_ERR(next_node))\n\t\t\treturn next_node;\n\t\tnode = next_node;\n\n\t\tlen = hfs_brec_lenoff(node, 0, &off16);\n\t\toff = off16;\n\t\toff += node->page_offset;\n\t\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\t\tdata = kmap(*pagep);\n\t\toff &= ~PAGE_CACHE_MASK;\n\t}\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/log2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*pagep"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_brec_lenoff",
          "args": [
            "node",
            "0",
            "&off16"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_lenoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
          "lines": "19-28",
          "snippet": "u16 hfs_brec_lenoff(struct hfs_bnode *node, u16 rec, u16 *off)\n{\n\t__be16 retval[2];\n\tu16 dataoff;\n\n\tdataoff = node->tree->node_size - (rec + 2) * 2;\n\thfs_bnode_read(node, retval, dataoff, 4);\n\t*off = be16_to_cpu(retval[1]);\n\treturn be16_to_cpu(retval[0]) - *off;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nu16 hfs_brec_lenoff(struct hfs_bnode *node, u16 rec, u16 *off)\n{\n\t__be16 retval[2];\n\tu16 dataoff;\n\n\tdataoff = node->tree->node_size - (rec + 2) * 2;\n\thfs_bnode_read(node, retval, dataoff, 4);\n\t*off = be16_to_cpu(retval[1]);\n\treturn be16_to_cpu(retval[0]) - *off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "next_node"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_put",
          "args": [
            "node"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "628-657",
          "snippet": "void hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_find",
          "args": [
            "tree",
            "nidx"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "482-565",
          "snippet": "struct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap(node->page[0]) +\n\t\t\tnode->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap(node->page[0]);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u16(node, off) + 2;\n\t\tif (key_size >= entry_size || key_size & 1)\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap(node->page[0]) +\n\t\t\tnode->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap(node->page[0]);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u16(node, off) + 2;\n\t\tif (key_size >= entry_size || key_size & 1)\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bmap_new_bmap",
          "args": [
            "node",
            "idx"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bmap_new_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/btree.c",
          "lines": "311-342",
          "snippet": "static struct hfs_bnode *hfs_bmap_new_bmap(struct hfs_bnode *prev, u32 idx)\n{\n\tstruct hfs_btree *tree = prev->tree;\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc desc;\n\t__be32 cnid;\n\n\tnode = hfs_bnode_create(tree, idx);\n\tif (IS_ERR(node))\n\t\treturn node;\n\n\ttree->free_nodes--;\n\tprev->next = idx;\n\tcnid = cpu_to_be32(idx);\n\thfs_bnode_write(prev, &cnid, offsetof(struct hfs_bnode_desc, next), 4);\n\n\tnode->type = HFS_NODE_MAP;\n\tnode->num_recs = 1;\n\thfs_bnode_clear(node, 0, tree->node_size);\n\tdesc.next = 0;\n\tdesc.prev = 0;\n\tdesc.type = HFS_NODE_MAP;\n\tdesc.height = 0;\n\tdesc.num_recs = cpu_to_be16(1);\n\tdesc.reserved = 0;\n\thfs_bnode_write(node, &desc, 0, sizeof(desc));\n\thfs_bnode_write_u16(node, 14, 0x8000);\n\thfs_bnode_write_u16(node, tree->node_size - 2, 14);\n\thfs_bnode_write_u16(node, tree->node_size - 4, tree->node_size - 6);\n\n\treturn node;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/log2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/log2.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstatic struct hfs_bnode *hfs_bmap_new_bmap(struct hfs_bnode *prev, u32 idx)\n{\n\tstruct hfs_btree *tree = prev->tree;\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc desc;\n\t__be32 cnid;\n\n\tnode = hfs_bnode_create(tree, idx);\n\tif (IS_ERR(node))\n\t\treturn node;\n\n\ttree->free_nodes--;\n\tprev->next = idx;\n\tcnid = cpu_to_be32(idx);\n\thfs_bnode_write(prev, &cnid, offsetof(struct hfs_bnode_desc, next), 4);\n\n\tnode->type = HFS_NODE_MAP;\n\tnode->num_recs = 1;\n\thfs_bnode_clear(node, 0, tree->node_size);\n\tdesc.next = 0;\n\tdesc.prev = 0;\n\tdesc.type = HFS_NODE_MAP;\n\tdesc.height = 0;\n\tdesc.num_recs = cpu_to_be16(1);\n\tdesc.reserved = 0;\n\thfs_bnode_write(node, &desc, 0, sizeof(desc));\n\thfs_bnode_write_u16(node, 14, 0x8000);\n\thfs_bnode_write_u16(node, tree->node_size - 2, 14);\n\thfs_bnode_write_u16(node, tree->node_size - 4, tree->node_size - 6);\n\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "BNODE_MOD",
            "\"create new bmap node\\n\""
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*pagep"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*++pagep"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*pagep"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_create",
          "args": [
            "tree",
            "idx"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "579-615",
          "snippet": "struct hfs_bnode *hfs_bnode_create(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct page **pagep;\n\tint i;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tspin_unlock(&tree->hash_lock);\n\tif (node) {\n\t\tpr_crit(\"new node %u already hashed?\\n\", num);\n\t\tWARN_ON(1);\n\t\treturn node;\n\t}\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags)) {\n\t\thfs_bnode_put(node);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tpagep = node->page;\n\tmemset(kmap(*pagep) + node->page_offset, 0,\n\t       min_t(int, PAGE_CACHE_SIZE, tree->node_size));\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\tfor (i = 1; i < tree->pages_per_bnode; i++) {\n\t\tmemset(kmap(*++pagep), 0, PAGE_CACHE_SIZE);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\n\treturn node;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct hfs_bnode *hfs_bnode_create(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct page **pagep;\n\tint i;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tspin_unlock(&tree->hash_lock);\n\tif (node) {\n\t\tpr_crit(\"new node %u already hashed?\\n\", num);\n\t\tWARN_ON(1);\n\t\treturn node;\n\t}\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags)) {\n\t\thfs_bnode_put(node);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tpagep = node->page;\n\tmemset(kmap(*pagep) + node->page_offset, 0,\n\t       min_t(int, PAGE_CACHE_SIZE, tree->node_size));\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\tfor (i = 1; i < tree->pages_per_bnode; i++) {\n\t\tmemset(kmap(*++pagep), 0, PAGE_CACHE_SIZE);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "tree->inode"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*pagep"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "*pagep"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*pagep"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "node"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_set_bytes",
          "args": [
            "inode",
            "inode->i_size"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "inode_set_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "503-509",
          "snippet": "void inode_set_bytes(struct inode *inode, loff_t bytes)\n{\n\t/* Caller is here responsible for sufficient locking\n\t * (ie. inode->i_lock) */\n\tinode->i_blocks = bytes >> 9;\n\tinode->i_bytes = bytes & 511;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid inode_set_bytes(struct inode *inode, loff_t bytes)\n{\n\t/* Caller is here responsible for sufficient locking\n\t * (ie. inode->i_lock) */\n\tinode->i_blocks = bytes >> 9;\n\tinode->i_bytes = bytes & 511;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "tree->sb"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "res"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_file_extend",
          "args": [
            "inode",
            "hfs_bnode_need_zeroout(tree)"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_file_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "428-529",
          "snippet": "int hfsplus_file_extend(struct inode *inode, bool zeroout)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tu32 start, len, goal;\n\tint res;\n\n\tif (sbi->alloc_file->i_size * 8 <\n\t    sbi->total_blocks - sbi->free_blocks + 8) {\n\t\t/* extend alloc file */\n\t\tpr_err(\"extend alloc file! (%llu,%u,%u)\\n\",\n\t\t       sbi->alloc_file->i_size * 8,\n\t\t       sbi->total_blocks, sbi->free_blocks);\n\t\treturn -ENOSPC;\n\t}\n\n\tmutex_lock(&hip->extents_lock);\n\tif (hip->alloc_blocks == hip->first_blocks)\n\t\tgoal = hfsplus_ext_lastblock(hip->first_extents);\n\telse {\n\t\tres = hfsplus_ext_read_extent(inode, hip->alloc_blocks);\n\t\tif (res)\n\t\t\tgoto out;\n\t\tgoal = hfsplus_ext_lastblock(hip->cached_extents);\n\t}\n\n\tlen = hip->clump_blocks;\n\tstart = hfsplus_block_allocate(sb, sbi->total_blocks, goal, &len);\n\tif (start >= sbi->total_blocks) {\n\t\tstart = hfsplus_block_allocate(sb, goal, 0, &len);\n\t\tif (start >= goal) {\n\t\t\tres = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (zeroout) {\n\t\tres = sb_issue_zeroout(sb, start, len, GFP_NOFS);\n\t\tif (res)\n\t\t\tgoto out;\n\t}\n\n\thfs_dbg(EXTENT, \"extend %lu: %u,%u\\n\", inode->i_ino, start, len);\n\n\tif (hip->alloc_blocks <= hip->first_blocks) {\n\t\tif (!hip->first_blocks) {\n\t\t\thfs_dbg(EXTENT, \"first extents\\n\");\n\t\t\t/* no extents yet */\n\t\t\thip->first_extents[0].start_block = cpu_to_be32(start);\n\t\t\thip->first_extents[0].block_count = cpu_to_be32(len);\n\t\t\tres = 0;\n\t\t} else {\n\t\t\t/* try to append to extents in inode */\n\t\t\tres = hfsplus_add_extent(hip->first_extents,\n\t\t\t\t\t\t hip->alloc_blocks,\n\t\t\t\t\t\t start, len);\n\t\t\tif (res == -ENOSPC)\n\t\t\t\tgoto insert_extent;\n\t\t}\n\t\tif (!res) {\n\t\t\thfsplus_dump_extent(hip->first_extents);\n\t\t\thip->first_blocks += len;\n\t\t}\n\t} else {\n\t\tres = hfsplus_add_extent(hip->cached_extents,\n\t\t\t\t\t hip->alloc_blocks - hip->cached_start,\n\t\t\t\t\t start, len);\n\t\tif (!res) {\n\t\t\thfsplus_dump_extent(hip->cached_extents);\n\t\t\thip->extent_state |= HFSPLUS_EXT_DIRTY;\n\t\t\thip->cached_blocks += len;\n\t\t} else if (res == -ENOSPC)\n\t\t\tgoto insert_extent;\n\t}\nout:\n\tif (!res) {\n\t\thip->alloc_blocks += len;\n\t\tmutex_unlock(&hip->extents_lock);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ALLOC_DIRTY);\n\t\treturn 0;\n\t}\n\tmutex_unlock(&hip->extents_lock);\n\treturn res;\n\ninsert_extent:\n\thfs_dbg(EXTENT, \"insert new extent\\n\");\n\tres = hfsplus_ext_write_extent_locked(inode);\n\tif (res)\n\t\tgoto out;\n\n\tmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\n\thip->cached_extents[0].start_block = cpu_to_be32(start);\n\thip->cached_extents[0].block_count = cpu_to_be32(len);\n\thfsplus_dump_extent(hip->cached_extents);\n\thip->extent_state |= HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW;\n\thip->cached_start = hip->alloc_blocks;\n\thip->cached_blocks = len;\n\n\tres = 0;\n\tgoto out;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nint hfsplus_file_extend(struct inode *inode, bool zeroout)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tu32 start, len, goal;\n\tint res;\n\n\tif (sbi->alloc_file->i_size * 8 <\n\t    sbi->total_blocks - sbi->free_blocks + 8) {\n\t\t/* extend alloc file */\n\t\tpr_err(\"extend alloc file! (%llu,%u,%u)\\n\",\n\t\t       sbi->alloc_file->i_size * 8,\n\t\t       sbi->total_blocks, sbi->free_blocks);\n\t\treturn -ENOSPC;\n\t}\n\n\tmutex_lock(&hip->extents_lock);\n\tif (hip->alloc_blocks == hip->first_blocks)\n\t\tgoal = hfsplus_ext_lastblock(hip->first_extents);\n\telse {\n\t\tres = hfsplus_ext_read_extent(inode, hip->alloc_blocks);\n\t\tif (res)\n\t\t\tgoto out;\n\t\tgoal = hfsplus_ext_lastblock(hip->cached_extents);\n\t}\n\n\tlen = hip->clump_blocks;\n\tstart = hfsplus_block_allocate(sb, sbi->total_blocks, goal, &len);\n\tif (start >= sbi->total_blocks) {\n\t\tstart = hfsplus_block_allocate(sb, goal, 0, &len);\n\t\tif (start >= goal) {\n\t\t\tres = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (zeroout) {\n\t\tres = sb_issue_zeroout(sb, start, len, GFP_NOFS);\n\t\tif (res)\n\t\t\tgoto out;\n\t}\n\n\thfs_dbg(EXTENT, \"extend %lu: %u,%u\\n\", inode->i_ino, start, len);\n\n\tif (hip->alloc_blocks <= hip->first_blocks) {\n\t\tif (!hip->first_blocks) {\n\t\t\thfs_dbg(EXTENT, \"first extents\\n\");\n\t\t\t/* no extents yet */\n\t\t\thip->first_extents[0].start_block = cpu_to_be32(start);\n\t\t\thip->first_extents[0].block_count = cpu_to_be32(len);\n\t\t\tres = 0;\n\t\t} else {\n\t\t\t/* try to append to extents in inode */\n\t\t\tres = hfsplus_add_extent(hip->first_extents,\n\t\t\t\t\t\t hip->alloc_blocks,\n\t\t\t\t\t\t start, len);\n\t\t\tif (res == -ENOSPC)\n\t\t\t\tgoto insert_extent;\n\t\t}\n\t\tif (!res) {\n\t\t\thfsplus_dump_extent(hip->first_extents);\n\t\t\thip->first_blocks += len;\n\t\t}\n\t} else {\n\t\tres = hfsplus_add_extent(hip->cached_extents,\n\t\t\t\t\t hip->alloc_blocks - hip->cached_start,\n\t\t\t\t\t start, len);\n\t\tif (!res) {\n\t\t\thfsplus_dump_extent(hip->cached_extents);\n\t\t\thip->extent_state |= HFSPLUS_EXT_DIRTY;\n\t\t\thip->cached_blocks += len;\n\t\t} else if (res == -ENOSPC)\n\t\t\tgoto insert_extent;\n\t}\nout:\n\tif (!res) {\n\t\thip->alloc_blocks += len;\n\t\tmutex_unlock(&hip->extents_lock);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ALLOC_DIRTY);\n\t\treturn 0;\n\t}\n\tmutex_unlock(&hip->extents_lock);\n\treturn res;\n\ninsert_extent:\n\thfs_dbg(EXTENT, \"insert new extent\\n\");\n\tres = hfsplus_ext_write_extent_locked(inode);\n\tif (res)\n\t\tgoto out;\n\n\tmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\n\thip->cached_extents[0].start_block = cpu_to_be32(start);\n\thip->cached_extents[0].block_count = cpu_to_be32(len);\n\thfsplus_dump_extent(hip->cached_extents);\n\thip->extent_state |= HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW;\n\thip->cached_start = hip->alloc_blocks;\n\thip->cached_blocks = len;\n\n\tres = 0;\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_need_zeroout",
          "args": [
            "tree"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_need_zeroout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "663-671",
          "snippet": "bool hfs_bnode_need_zeroout(struct hfs_btree *tree)\n{\n\tstruct super_block *sb = tree->inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tconst u32 volume_attr = be32_to_cpu(sbi->s_vhdr->attributes);\n\n\treturn tree->cnid == HFSPLUS_CAT_CNID &&\n\t\tvolume_attr & HFSPLUS_VOL_UNUSED_NODE_FIX;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nbool hfs_bnode_need_zeroout(struct hfs_btree *tree)\n{\n\tstruct super_block *sb = tree->inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tconst u32 volume_attr = be32_to_cpu(sbi->s_vhdr->attributes);\n\n\treturn tree->cnid == HFSPLUS_CAT_CNID &&\n\t\tvolume_attr & HFSPLUS_VOL_UNUSED_NODE_FIX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/log2.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstruct hfs_bnode *hfs_bmap_alloc(struct hfs_btree *tree)\n{\n\tstruct hfs_bnode *node, *next_node;\n\tstruct page **pagep;\n\tu32 nidx, idx;\n\tunsigned off;\n\tu16 off16;\n\tu16 len;\n\tu8 *data, byte, m;\n\tint i;\n\n\twhile (!tree->free_nodes) {\n\t\tstruct inode *inode = tree->inode;\n\t\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\t\tu32 count;\n\t\tint res;\n\n\t\tres = hfsplus_file_extend(inode, hfs_bnode_need_zeroout(tree));\n\t\tif (res)\n\t\t\treturn ERR_PTR(res);\n\t\thip->phys_size = inode->i_size =\n\t\t\t(loff_t)hip->alloc_blocks <<\n\t\t\t\tHFSPLUS_SB(tree->sb)->alloc_blksz_shift;\n\t\thip->fs_blocks =\n\t\t\thip->alloc_blocks << HFSPLUS_SB(tree->sb)->fs_shift;\n\t\tinode_set_bytes(inode, inode->i_size);\n\t\tcount = inode->i_size >> tree->node_size_shift;\n\t\ttree->free_nodes = count - tree->node_count;\n\t\ttree->node_count = count;\n\t}\n\n\tnidx = 0;\n\tnode = hfs_bnode_find(tree, nidx);\n\tif (IS_ERR(node))\n\t\treturn node;\n\tlen = hfs_brec_lenoff(node, 2, &off16);\n\toff = off16;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\tdata = kmap(*pagep);\n\toff &= ~PAGE_CACHE_MASK;\n\tidx = 0;\n\n\tfor (;;) {\n\t\twhile (len) {\n\t\t\tbyte = data[off];\n\t\t\tif (byte != 0xff) {\n\t\t\t\tfor (m = 0x80, i = 0; i < 8; m >>= 1, i++) {\n\t\t\t\t\tif (!(byte & m)) {\n\t\t\t\t\t\tidx += i;\n\t\t\t\t\t\tdata[off] |= m;\n\t\t\t\t\t\tset_page_dirty(*pagep);\n\t\t\t\t\t\tkunmap(*pagep);\n\t\t\t\t\t\ttree->free_nodes--;\n\t\t\t\t\t\tmark_inode_dirty(tree->inode);\n\t\t\t\t\t\thfs_bnode_put(node);\n\t\t\t\t\t\treturn hfs_bnode_create(tree,\n\t\t\t\t\t\t\tidx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (++off >= PAGE_CACHE_SIZE) {\n\t\t\t\tkunmap(*pagep);\n\t\t\t\tdata = kmap(*++pagep);\n\t\t\t\toff = 0;\n\t\t\t}\n\t\t\tidx += 8;\n\t\t\tlen--;\n\t\t}\n\t\tkunmap(*pagep);\n\t\tnidx = node->next;\n\t\tif (!nidx) {\n\t\t\thfs_dbg(BNODE_MOD, \"create new bmap node\\n\");\n\t\t\tnext_node = hfs_bmap_new_bmap(node, idx);\n\t\t} else\n\t\t\tnext_node = hfs_bnode_find(tree, nidx);\n\t\thfs_bnode_put(node);\n\t\tif (IS_ERR(next_node))\n\t\t\treturn next_node;\n\t\tnode = next_node;\n\n\t\tlen = hfs_brec_lenoff(node, 0, &off16);\n\t\toff = off16;\n\t\toff += node->page_offset;\n\t\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\t\tdata = kmap(*pagep);\n\t\toff &= ~PAGE_CACHE_MASK;\n\t}\n}"
  },
  {
    "function_name": "hfs_bmap_new_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/btree.c",
    "lines": "311-342",
    "snippet": "static struct hfs_bnode *hfs_bmap_new_bmap(struct hfs_bnode *prev, u32 idx)\n{\n\tstruct hfs_btree *tree = prev->tree;\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc desc;\n\t__be32 cnid;\n\n\tnode = hfs_bnode_create(tree, idx);\n\tif (IS_ERR(node))\n\t\treturn node;\n\n\ttree->free_nodes--;\n\tprev->next = idx;\n\tcnid = cpu_to_be32(idx);\n\thfs_bnode_write(prev, &cnid, offsetof(struct hfs_bnode_desc, next), 4);\n\n\tnode->type = HFS_NODE_MAP;\n\tnode->num_recs = 1;\n\thfs_bnode_clear(node, 0, tree->node_size);\n\tdesc.next = 0;\n\tdesc.prev = 0;\n\tdesc.type = HFS_NODE_MAP;\n\tdesc.height = 0;\n\tdesc.num_recs = cpu_to_be16(1);\n\tdesc.reserved = 0;\n\thfs_bnode_write(node, &desc, 0, sizeof(desc));\n\thfs_bnode_write_u16(node, 14, 0x8000);\n\thfs_bnode_write_u16(node, tree->node_size - 2, 14);\n\thfs_bnode_write_u16(node, tree->node_size - 4, tree->node_size - 6);\n\n\treturn node;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/log2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_bnode_write_u16",
          "args": [
            "node",
            "tree->node_size - 4",
            "tree->node_size - 6"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_write_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "97-102",
          "snippet": "void hfs_bnode_write_u16(struct hfs_bnode *node, int off, u16 data)\n{\n\t__be16 v = cpu_to_be16(data);\n\t/* TODO: optimize later... */\n\thfs_bnode_write(node, &v, off, 2);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_write_u16(struct hfs_bnode *node, int off, u16 data)\n{\n\t__be16 v = cpu_to_be16(data);\n\t/* TODO: optimize later... */\n\thfs_bnode_write(node, &v, off, 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_write",
          "args": [
            "node",
            "&desc",
            "0",
            "sizeof(desc)"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "74-95",
          "snippet": "void hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(kmap(*pagep) + off, buf, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(kmap(*++pagep), buf, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(kmap(*pagep) + off, buf, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(kmap(*++pagep), buf, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "1"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_clear",
          "args": [
            "node",
            "0",
            "tree->node_size"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "104-124",
          "snippet": "void hfs_bnode_clear(struct hfs_bnode *node, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemset(kmap(*pagep) + off, 0, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemset(kmap(*++pagep), 0, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_clear(struct hfs_bnode *node, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemset(kmap(*pagep) + off, 0, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemset(kmap(*++pagep), 0, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "idx"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "node"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_create",
          "args": [
            "tree",
            "idx"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "579-615",
          "snippet": "struct hfs_bnode *hfs_bnode_create(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct page **pagep;\n\tint i;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tspin_unlock(&tree->hash_lock);\n\tif (node) {\n\t\tpr_crit(\"new node %u already hashed?\\n\", num);\n\t\tWARN_ON(1);\n\t\treturn node;\n\t}\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags)) {\n\t\thfs_bnode_put(node);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tpagep = node->page;\n\tmemset(kmap(*pagep) + node->page_offset, 0,\n\t       min_t(int, PAGE_CACHE_SIZE, tree->node_size));\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\tfor (i = 1; i < tree->pages_per_bnode; i++) {\n\t\tmemset(kmap(*++pagep), 0, PAGE_CACHE_SIZE);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\n\treturn node;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct hfs_bnode *hfs_bnode_create(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct page **pagep;\n\tint i;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tspin_unlock(&tree->hash_lock);\n\tif (node) {\n\t\tpr_crit(\"new node %u already hashed?\\n\", num);\n\t\tWARN_ON(1);\n\t\treturn node;\n\t}\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags)) {\n\t\thfs_bnode_put(node);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tpagep = node->page;\n\tmemset(kmap(*pagep) + node->page_offset, 0,\n\t       min_t(int, PAGE_CACHE_SIZE, tree->node_size));\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\tfor (i = 1; i < tree->pages_per_bnode; i++) {\n\t\tmemset(kmap(*++pagep), 0, PAGE_CACHE_SIZE);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\n\treturn node;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/log2.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstatic struct hfs_bnode *hfs_bmap_new_bmap(struct hfs_bnode *prev, u32 idx)\n{\n\tstruct hfs_btree *tree = prev->tree;\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc desc;\n\t__be32 cnid;\n\n\tnode = hfs_bnode_create(tree, idx);\n\tif (IS_ERR(node))\n\t\treturn node;\n\n\ttree->free_nodes--;\n\tprev->next = idx;\n\tcnid = cpu_to_be32(idx);\n\thfs_bnode_write(prev, &cnid, offsetof(struct hfs_bnode_desc, next), 4);\n\n\tnode->type = HFS_NODE_MAP;\n\tnode->num_recs = 1;\n\thfs_bnode_clear(node, 0, tree->node_size);\n\tdesc.next = 0;\n\tdesc.prev = 0;\n\tdesc.type = HFS_NODE_MAP;\n\tdesc.height = 0;\n\tdesc.num_recs = cpu_to_be16(1);\n\tdesc.reserved = 0;\n\thfs_bnode_write(node, &desc, 0, sizeof(desc));\n\thfs_bnode_write_u16(node, 14, 0x8000);\n\thfs_bnode_write_u16(node, tree->node_size - 2, 14);\n\thfs_bnode_write_u16(node, tree->node_size - 4, tree->node_size - 6);\n\n\treturn node;\n}"
  },
  {
    "function_name": "hfs_btree_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/btree.c",
    "lines": "281-309",
    "snippet": "int hfs_btree_write(struct hfs_btree *tree)\n{\n\tstruct hfs_btree_header_rec *head;\n\tstruct hfs_bnode *node;\n\tstruct page *page;\n\n\tnode = hfs_bnode_find(tree, 0);\n\tif (IS_ERR(node))\n\t\t/* panic? */\n\t\treturn -EIO;\n\t/* Load the header */\n\tpage = node->page[0];\n\thead = (struct hfs_btree_header_rec *)(kmap(page) +\n\t\tsizeof(struct hfs_bnode_desc));\n\n\thead->root = cpu_to_be32(tree->root);\n\thead->leaf_count = cpu_to_be32(tree->leaf_count);\n\thead->leaf_head = cpu_to_be32(tree->leaf_head);\n\thead->leaf_tail = cpu_to_be32(tree->leaf_tail);\n\thead->node_count = cpu_to_be32(tree->node_count);\n\thead->free_nodes = cpu_to_be32(tree->free_nodes);\n\thead->attributes = cpu_to_be32(tree->attributes);\n\thead->depth = cpu_to_be16(tree->depth);\n\n\tkunmap(page);\n\tset_page_dirty(page);\n\thfs_bnode_put(node);\n\treturn 0;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/log2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_bnode_put",
          "args": [
            "node"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "628-657",
          "snippet": "void hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "tree->depth"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tree->attributes"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tree->free_nodes"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tree->node_count"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tree->leaf_tail"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tree->leaf_head"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tree->leaf_count"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tree->root"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "node"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_find",
          "args": [
            "tree",
            "0"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "482-565",
          "snippet": "struct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap(node->page[0]) +\n\t\t\tnode->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap(node->page[0]);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u16(node, off) + 2;\n\t\tif (key_size >= entry_size || key_size & 1)\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap(node->page[0]) +\n\t\t\tnode->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap(node->page[0]);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u16(node, off) + 2;\n\t\tif (key_size >= entry_size || key_size & 1)\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/log2.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nint hfs_btree_write(struct hfs_btree *tree)\n{\n\tstruct hfs_btree_header_rec *head;\n\tstruct hfs_bnode *node;\n\tstruct page *page;\n\n\tnode = hfs_bnode_find(tree, 0);\n\tif (IS_ERR(node))\n\t\t/* panic? */\n\t\treturn -EIO;\n\t/* Load the header */\n\tpage = node->page[0];\n\thead = (struct hfs_btree_header_rec *)(kmap(page) +\n\t\tsizeof(struct hfs_bnode_desc));\n\n\thead->root = cpu_to_be32(tree->root);\n\thead->leaf_count = cpu_to_be32(tree->leaf_count);\n\thead->leaf_head = cpu_to_be32(tree->leaf_head);\n\thead->leaf_tail = cpu_to_be32(tree->leaf_tail);\n\thead->node_count = cpu_to_be32(tree->node_count);\n\thead->free_nodes = cpu_to_be32(tree->free_nodes);\n\thead->attributes = cpu_to_be32(tree->attributes);\n\thead->depth = cpu_to_be16(tree->depth);\n\n\tkunmap(page);\n\tset_page_dirty(page);\n\thfs_bnode_put(node);\n\treturn 0;\n}"
  },
  {
    "function_name": "hfs_btree_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/btree.c",
    "lines": "257-279",
    "snippet": "void hfs_btree_close(struct hfs_btree *tree)\n{\n\tstruct hfs_bnode *node;\n\tint i;\n\n\tif (!tree)\n\t\treturn;\n\n\tfor (i = 0; i < NODE_HASH_SIZE; i++) {\n\t\twhile ((node = tree->node_hash[i])) {\n\t\t\ttree->node_hash[i] = node->next_hash;\n\t\t\tif (atomic_read(&node->refcnt))\n\t\t\t\tpr_crit(\"node %d:%d \"\n\t\t\t\t\t\t\"still has %d user(s)!\\n\",\n\t\t\t\t\tnode->tree->cnid, node->this,\n\t\t\t\t\tatomic_read(&node->refcnt));\n\t\t\thfs_bnode_free(node);\n\t\t\ttree->node_hash_cnt--;\n\t\t}\n\t}\n\tiput(tree->inode);\n\tkfree(tree);\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/log2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tree"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "tree->inode"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_free",
          "args": [
            "node"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "567-577",
          "snippet": "void hfs_bnode_free(struct hfs_bnode *node)\n{\n#if 0\n\tint i;\n\n\tfor (i = 0; i < node->tree->pages_per_bnode; i++)\n\t\tif (node->page[i])\n\t\t\tpage_cache_release(node->page[i]);\n#endif\n\tkfree(node);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_free(struct hfs_bnode *node)\n{\n#if 0\n\tint i;\n\n\tfor (i = 0; i < node->tree->pages_per_bnode; i++)\n\t\tif (node->page[i])\n\t\t\tpage_cache_release(node->page[i]);\n#endif\n\tkfree(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"node %d:%d \"\n\t\t\t\t\t\t\"still has %d user(s)!\\n\"",
            "node->tree->cnid",
            "node->this",
            "atomic_read(&node->refcnt)"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&node->refcnt"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&node->refcnt"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/log2.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nvoid hfs_btree_close(struct hfs_btree *tree)\n{\n\tstruct hfs_bnode *node;\n\tint i;\n\n\tif (!tree)\n\t\treturn;\n\n\tfor (i = 0; i < NODE_HASH_SIZE; i++) {\n\t\twhile ((node = tree->node_hash[i])) {\n\t\t\ttree->node_hash[i] = node->next_hash;\n\t\t\tif (atomic_read(&node->refcnt))\n\t\t\t\tpr_crit(\"node %d:%d \"\n\t\t\t\t\t\t\"still has %d user(s)!\\n\",\n\t\t\t\t\tnode->tree->cnid, node->this,\n\t\t\t\t\tatomic_read(&node->refcnt));\n\t\t\thfs_bnode_free(node);\n\t\t\ttree->node_hash_cnt--;\n\t\t}\n\t}\n\tiput(tree->inode);\n\tkfree(tree);\n}"
  },
  {
    "function_name": "hfs_btree_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/btree.c",
    "lines": "132-254",
    "snippet": "struct hfs_btree *hfs_btree_open(struct super_block *sb, u32 id)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_btree_header_rec *head;\n\tstruct address_space *mapping;\n\tstruct inode *inode;\n\tstruct page *page;\n\tunsigned int size;\n\n\ttree = kzalloc(sizeof(*tree), GFP_KERNEL);\n\tif (!tree)\n\t\treturn NULL;\n\n\tmutex_init(&tree->tree_lock);\n\tspin_lock_init(&tree->hash_lock);\n\ttree->sb = sb;\n\ttree->cnid = id;\n\tinode = hfsplus_iget(sb, id);\n\tif (IS_ERR(inode))\n\t\tgoto free_tree;\n\ttree->inode = inode;\n\n\tif (!HFSPLUS_I(tree->inode)->first_blocks) {\n\t\tpr_err(\"invalid btree extent records (0 size)\\n\");\n\t\tgoto free_inode;\n\t}\n\n\tmapping = tree->inode->i_mapping;\n\tpage = read_mapping_page(mapping, 0, NULL);\n\tif (IS_ERR(page))\n\t\tgoto free_inode;\n\n\t/* Load the header */\n\thead = (struct hfs_btree_header_rec *)(kmap(page) +\n\t\tsizeof(struct hfs_bnode_desc));\n\ttree->root = be32_to_cpu(head->root);\n\ttree->leaf_count = be32_to_cpu(head->leaf_count);\n\ttree->leaf_head = be32_to_cpu(head->leaf_head);\n\ttree->leaf_tail = be32_to_cpu(head->leaf_tail);\n\ttree->node_count = be32_to_cpu(head->node_count);\n\ttree->free_nodes = be32_to_cpu(head->free_nodes);\n\ttree->attributes = be32_to_cpu(head->attributes);\n\ttree->node_size = be16_to_cpu(head->node_size);\n\ttree->max_key_len = be16_to_cpu(head->max_key_len);\n\ttree->depth = be16_to_cpu(head->depth);\n\n\t/* Verify the tree and set the correct compare function */\n\tswitch (id) {\n\tcase HFSPLUS_EXT_CNID:\n\t\tif (tree->max_key_len != HFSPLUS_EXT_KEYLEN - sizeof(u16)) {\n\t\t\tpr_err(\"invalid extent max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tif (tree->attributes & HFS_TREE_VARIDXKEYS) {\n\t\t\tpr_err(\"invalid extent btree flag\\n\");\n\t\t\tgoto fail_page;\n\t\t}\n\n\t\ttree->keycmp = hfsplus_ext_cmp_key;\n\t\tbreak;\n\tcase HFSPLUS_CAT_CNID:\n\t\tif (tree->max_key_len != HFSPLUS_CAT_KEYLEN - sizeof(u16)) {\n\t\t\tpr_err(\"invalid catalog max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tif (!(tree->attributes & HFS_TREE_VARIDXKEYS)) {\n\t\t\tpr_err(\"invalid catalog btree flag\\n\");\n\t\t\tgoto fail_page;\n\t\t}\n\n\t\tif (test_bit(HFSPLUS_SB_HFSX, &HFSPLUS_SB(sb)->flags) &&\n\t\t    (head->key_type == HFSPLUS_KEY_BINARY))\n\t\t\ttree->keycmp = hfsplus_cat_bin_cmp_key;\n\t\telse {\n\t\t\ttree->keycmp = hfsplus_cat_case_cmp_key;\n\t\t\tset_bit(HFSPLUS_SB_CASEFOLD, &HFSPLUS_SB(sb)->flags);\n\t\t}\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tif (tree->max_key_len != HFSPLUS_ATTR_KEYLEN - sizeof(u16)) {\n\t\t\tpr_err(\"invalid attributes max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\ttree->keycmp = hfsplus_attr_bin_cmp_key;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown B*Tree requested\\n\");\n\t\tgoto fail_page;\n\t}\n\n\tif (!(tree->attributes & HFS_TREE_BIGKEYS)) {\n\t\tpr_err(\"invalid btree flag\\n\");\n\t\tgoto fail_page;\n\t}\n\n\tsize = tree->node_size;\n\tif (!is_power_of_2(size))\n\t\tgoto fail_page;\n\tif (!tree->node_count)\n\t\tgoto fail_page;\n\n\ttree->node_size_shift = ffs(size) - 1;\n\n\ttree->pages_per_bnode =\n\t\t(tree->node_size + PAGE_CACHE_SIZE - 1) >>\n\t\tPAGE_CACHE_SHIFT;\n\n\tkunmap(page);\n\tpage_cache_release(page);\n\treturn tree;\n\n fail_page:\n\tpage_cache_release(page);\n free_inode:\n\ttree->inode->i_mapping->a_ops = &hfsplus_aops;\n\tiput(tree->inode);\n free_tree:\n\tkfree(tree);\n\treturn NULL;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/log2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tree"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "tree->inode"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "size"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "unsigned_offsets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "40-43",
          "snippet": "static inline int unsigned_offsets(struct file *file)\n{\n\treturn file->f_mode & FMODE_UNSIGNED_OFFSET;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline int unsigned_offsets(struct file *file)\n{\n\treturn file->f_mode & FMODE_UNSIGNED_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "size"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"invalid btree flag\\n\""
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unknown B*Tree requested\\n\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"invalid attributes max_key_len %d\\n\"",
            "tree->max_key_len"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "HFSPLUS_SB_CASEFOLD",
            "&HFSPLUS_SB(sb)->flags"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "HFSPLUS_SB_HFSX",
            "&HFSPLUS_SB(sb)->flags"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"invalid catalog btree flag\\n\""
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"invalid catalog max_key_len %d\\n\"",
            "tree->max_key_len"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"invalid extent btree flag\\n\""
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"invalid extent max_key_len %d\\n\"",
            "tree->max_key_len"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "head->depth"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "head->max_key_len"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "head->node_size"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "head->attributes"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "head->free_nodes"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "head->node_count"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "head->leaf_tail"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "head->leaf_head"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "head->leaf_count"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "head->root"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mapping_page",
          "args": [
            "mapping",
            "0",
            "NULL"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"invalid btree extent records (0 size)\\n\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "tree->inode"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_iget",
          "args": [
            "sb",
            "id"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
          "lines": "56-95",
          "snippet": "struct inode *hfsplus_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct hfs_find_data fd;\n\tstruct inode *inode;\n\tint err;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tINIT_LIST_HEAD(&HFSPLUS_I(inode)->open_dir_list);\n\tmutex_init(&HFSPLUS_I(inode)->extents_lock);\n\tHFSPLUS_I(inode)->flags = 0;\n\tHFSPLUS_I(inode)->extent_state = 0;\n\tHFSPLUS_I(inode)->rsrc_inode = NULL;\n\tatomic_set(&HFSPLUS_I(inode)->opencnt, 0);\n\n\tif (inode->i_ino >= HFSPLUS_FIRSTUSER_CNID ||\n\t    inode->i_ino == HFSPLUS_ROOT_CNID) {\n\t\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &fd);\n\t\tif (!err) {\n\t\t\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd);\n\t\t\tif (!err)\n\t\t\t\terr = hfsplus_cat_read_inode(inode, &fd);\n\t\t\thfs_find_exit(&fd);\n\t\t}\n\t} else {\n\t\terr = hfsplus_system_read_inode(inode);\n\t}\n\n\tif (err) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode *hfsplus_alloc_inode(struct super_block *sb);",
            "static void hfsplus_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct inode *hfsplus_alloc_inode(struct super_block *sb);\nstatic void hfsplus_destroy_inode(struct inode *inode);\n\nstruct inode *hfsplus_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct hfs_find_data fd;\n\tstruct inode *inode;\n\tint err;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tINIT_LIST_HEAD(&HFSPLUS_I(inode)->open_dir_list);\n\tmutex_init(&HFSPLUS_I(inode)->extents_lock);\n\tHFSPLUS_I(inode)->flags = 0;\n\tHFSPLUS_I(inode)->extent_state = 0;\n\tHFSPLUS_I(inode)->rsrc_inode = NULL;\n\tatomic_set(&HFSPLUS_I(inode)->opencnt, 0);\n\n\tif (inode->i_ino >= HFSPLUS_FIRSTUSER_CNID ||\n\t    inode->i_ino == HFSPLUS_ROOT_CNID) {\n\t\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &fd);\n\t\tif (!err) {\n\t\t\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd);\n\t\t\tif (!err)\n\t\t\t\terr = hfsplus_cat_read_inode(inode, &fd);\n\t\t\thfs_find_exit(&fd);\n\t\t}\n\t} else {\n\t\terr = hfsplus_system_read_inode(inode);\n\t}\n\n\tif (err) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&tree->hash_lock"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&tree->tree_lock"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*tree)",
            "GFP_KERNEL"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/log2.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstruct hfs_btree *hfs_btree_open(struct super_block *sb, u32 id)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_btree_header_rec *head;\n\tstruct address_space *mapping;\n\tstruct inode *inode;\n\tstruct page *page;\n\tunsigned int size;\n\n\ttree = kzalloc(sizeof(*tree), GFP_KERNEL);\n\tif (!tree)\n\t\treturn NULL;\n\n\tmutex_init(&tree->tree_lock);\n\tspin_lock_init(&tree->hash_lock);\n\ttree->sb = sb;\n\ttree->cnid = id;\n\tinode = hfsplus_iget(sb, id);\n\tif (IS_ERR(inode))\n\t\tgoto free_tree;\n\ttree->inode = inode;\n\n\tif (!HFSPLUS_I(tree->inode)->first_blocks) {\n\t\tpr_err(\"invalid btree extent records (0 size)\\n\");\n\t\tgoto free_inode;\n\t}\n\n\tmapping = tree->inode->i_mapping;\n\tpage = read_mapping_page(mapping, 0, NULL);\n\tif (IS_ERR(page))\n\t\tgoto free_inode;\n\n\t/* Load the header */\n\thead = (struct hfs_btree_header_rec *)(kmap(page) +\n\t\tsizeof(struct hfs_bnode_desc));\n\ttree->root = be32_to_cpu(head->root);\n\ttree->leaf_count = be32_to_cpu(head->leaf_count);\n\ttree->leaf_head = be32_to_cpu(head->leaf_head);\n\ttree->leaf_tail = be32_to_cpu(head->leaf_tail);\n\ttree->node_count = be32_to_cpu(head->node_count);\n\ttree->free_nodes = be32_to_cpu(head->free_nodes);\n\ttree->attributes = be32_to_cpu(head->attributes);\n\ttree->node_size = be16_to_cpu(head->node_size);\n\ttree->max_key_len = be16_to_cpu(head->max_key_len);\n\ttree->depth = be16_to_cpu(head->depth);\n\n\t/* Verify the tree and set the correct compare function */\n\tswitch (id) {\n\tcase HFSPLUS_EXT_CNID:\n\t\tif (tree->max_key_len != HFSPLUS_EXT_KEYLEN - sizeof(u16)) {\n\t\t\tpr_err(\"invalid extent max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tif (tree->attributes & HFS_TREE_VARIDXKEYS) {\n\t\t\tpr_err(\"invalid extent btree flag\\n\");\n\t\t\tgoto fail_page;\n\t\t}\n\n\t\ttree->keycmp = hfsplus_ext_cmp_key;\n\t\tbreak;\n\tcase HFSPLUS_CAT_CNID:\n\t\tif (tree->max_key_len != HFSPLUS_CAT_KEYLEN - sizeof(u16)) {\n\t\t\tpr_err(\"invalid catalog max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tif (!(tree->attributes & HFS_TREE_VARIDXKEYS)) {\n\t\t\tpr_err(\"invalid catalog btree flag\\n\");\n\t\t\tgoto fail_page;\n\t\t}\n\n\t\tif (test_bit(HFSPLUS_SB_HFSX, &HFSPLUS_SB(sb)->flags) &&\n\t\t    (head->key_type == HFSPLUS_KEY_BINARY))\n\t\t\ttree->keycmp = hfsplus_cat_bin_cmp_key;\n\t\telse {\n\t\t\ttree->keycmp = hfsplus_cat_case_cmp_key;\n\t\t\tset_bit(HFSPLUS_SB_CASEFOLD, &HFSPLUS_SB(sb)->flags);\n\t\t}\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tif (tree->max_key_len != HFSPLUS_ATTR_KEYLEN - sizeof(u16)) {\n\t\t\tpr_err(\"invalid attributes max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\ttree->keycmp = hfsplus_attr_bin_cmp_key;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown B*Tree requested\\n\");\n\t\tgoto fail_page;\n\t}\n\n\tif (!(tree->attributes & HFS_TREE_BIGKEYS)) {\n\t\tpr_err(\"invalid btree flag\\n\");\n\t\tgoto fail_page;\n\t}\n\n\tsize = tree->node_size;\n\tif (!is_power_of_2(size))\n\t\tgoto fail_page;\n\tif (!tree->node_count)\n\t\tgoto fail_page;\n\n\ttree->node_size_shift = ffs(size) - 1;\n\n\ttree->pages_per_bnode =\n\t\t(tree->node_size + PAGE_CACHE_SIZE - 1) >>\n\t\tPAGE_CACHE_SHIFT;\n\n\tkunmap(page);\n\tpage_cache_release(page);\n\treturn tree;\n\n fail_page:\n\tpage_cache_release(page);\n free_inode:\n\ttree->inode->i_mapping->a_ops = &hfsplus_aops;\n\tiput(tree->inode);\n free_tree:\n\tkfree(tree);\n\treturn NULL;\n}"
  },
  {
    "function_name": "hfsplus_calc_btree_clump_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/btree.c",
    "lines": "74-129",
    "snippet": "u32 hfsplus_calc_btree_clump_size(u32 block_size, u32 node_size,\n\t\t\t\t\tu64 sectors, int file_id)\n{\n\tu32 mod = max(node_size, block_size);\n\tu32 clump_size;\n\tint column;\n\tint i;\n\n\t/* Figure out which column of the above table to use for this file. */\n\tswitch (file_id) {\n\tcase HFSPLUS_ATTR_CNID:\n\t\tcolumn = 0;\n\t\tbreak;\n\tcase HFSPLUS_CAT_CNID:\n\t\tcolumn = 1;\n\t\tbreak;\n\tdefault:\n\t\tcolumn = 2;\n\t\tbreak;\n\t}\n\n\t/*\n\t * The default clump size is 0.8% of the volume size. And\n\t * it must also be a multiple of the node and block size.\n\t */\n\tif (sectors < 0x200000) {\n\t\tclump_size = sectors << 2;\t/*  0.8 %  */\n\t\tif (clump_size < (8 * node_size))\n\t\t\tclump_size = 8 * node_size;\n\t} else {\n\t\t/* turn exponent into table index... */\n\t\tfor (i = 0, sectors = sectors >> 22;\n\t\t     sectors && (i < CLUMP_ENTRIES - 1);\n\t\t     ++i, sectors = sectors >> 1) {\n\t\t\t/* empty body */\n\t\t}\n\n\t\tclump_size = clumptbl[column + (i) * 3] * 1024 * 1024;\n\t}\n\n\t/*\n\t * Round the clump size to a multiple of node and block size.\n\t * NOTE: This rounds down.\n\t */\n\tclump_size /= mod;\n\tclump_size *= mod;\n\n\t/*\n\t * Rounding down could have rounded down to 0 if the block size was\n\t * greater than the clump size.  If so, just use one block or node.\n\t */\n\tif (clump_size == 0)\n\t\tclump_size = mod;\n\n\treturn clump_size;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/log2.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define CLUMP_ENTRIES\t15"
    ],
    "globals_used": [
      "static short clumptbl[CLUMP_ENTRIES * 3] = {\n/*\n *\t    Volume\tAttributes\t Catalog\t Extents\n *\t     Size\tClump (MB)\tClump (MB)\tClump (MB)\n */\n\t/*   1GB */\t  4,\t\t  4,\t\t 4,\n\t/*   2GB */\t  6,\t\t  6,\t\t 4,\n\t/*   4GB */\t  8,\t\t  8,\t\t 4,\n\t/*   8GB */\t 11,\t\t 11,\t\t 5,\n\t/*\n\t * For volumes 16GB and larger, we want to make sure that a full OS\n\t * install won't require fragmentation of the Catalog or Attributes\n\t * B-trees.  We do this by making the clump sizes sufficiently large,\n\t * and by leaving a gap after the B-trees for them to grow into.\n\t *\n\t * For SnowLeopard 10A298, a FullNetInstall with all packages selected\n\t * results in:\n\t * Catalog B-tree Header\n\t *\tnodeSize:          8192\n\t *\ttotalNodes:       31616\n\t *\tfreeNodes:         1978\n\t * (used = 231.55 MB)\n\t * Attributes B-tree Header\n\t *\tnodeSize:          8192\n\t *\ttotalNodes:       63232\n\t *\tfreeNodes:          958\n\t * (used = 486.52 MB)\n\t *\n\t * We also want Time Machine backup volumes to have a sufficiently\n\t * large clump size to reduce fragmentation.\n\t *\n\t * The series of numbers for Catalog and Attribute form a geometric\n\t * series. For Catalog (16GB to 512GB), each term is 8**(1/5) times\n\t * the previous term.  For Attributes (16GB to 512GB), each term is\n\t * 4**(1/5) times the previous term.  For 1TB to 16TB, each term is\n\t * 2**(1/5) times the previous term.\n\t */\n\t/*  16GB */\t 64,\t\t 32,\t\t 5,\n\t/*  32GB */\t 84,\t\t 49,\t\t 6,\n\t/*  64GB */\t111,\t\t 74,\t\t 7,\n\t/* 128GB */\t147,\t\t111,\t\t 8,\n\t/* 256GB */\t194,\t\t169,\t\t 9,\n\t/* 512GB */\t256,\t\t256,\t\t11,\n\t/*   1TB */\t294,\t\t294,\t\t14,\n\t/*   2TB */\t338,\t\t338,\t\t16,\n\t/*   4TB */\t388,\t\t388,\t\t20,\n\t/*   8TB */\t446,\t\t446,\t\t25,\n\t/*  16TB */\t512,\t\t512,\t\t32\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "node_size",
            "block_size"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "max_select_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "342-382",
          "snippet": "static int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/log2.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\n#define CLUMP_ENTRIES\t15\n\nstatic short clumptbl[CLUMP_ENTRIES * 3] = {\n/*\n *\t    Volume\tAttributes\t Catalog\t Extents\n *\t     Size\tClump (MB)\tClump (MB)\tClump (MB)\n */\n\t/*   1GB */\t  4,\t\t  4,\t\t 4,\n\t/*   2GB */\t  6,\t\t  6,\t\t 4,\n\t/*   4GB */\t  8,\t\t  8,\t\t 4,\n\t/*   8GB */\t 11,\t\t 11,\t\t 5,\n\t/*\n\t * For volumes 16GB and larger, we want to make sure that a full OS\n\t * install won't require fragmentation of the Catalog or Attributes\n\t * B-trees.  We do this by making the clump sizes sufficiently large,\n\t * and by leaving a gap after the B-trees for them to grow into.\n\t *\n\t * For SnowLeopard 10A298, a FullNetInstall with all packages selected\n\t * results in:\n\t * Catalog B-tree Header\n\t *\tnodeSize:          8192\n\t *\ttotalNodes:       31616\n\t *\tfreeNodes:         1978\n\t * (used = 231.55 MB)\n\t * Attributes B-tree Header\n\t *\tnodeSize:          8192\n\t *\ttotalNodes:       63232\n\t *\tfreeNodes:          958\n\t * (used = 486.52 MB)\n\t *\n\t * We also want Time Machine backup volumes to have a sufficiently\n\t * large clump size to reduce fragmentation.\n\t *\n\t * The series of numbers for Catalog and Attribute form a geometric\n\t * series. For Catalog (16GB to 512GB), each term is 8**(1/5) times\n\t * the previous term.  For Attributes (16GB to 512GB), each term is\n\t * 4**(1/5) times the previous term.  For 1TB to 16TB, each term is\n\t * 2**(1/5) times the previous term.\n\t */\n\t/*  16GB */\t 64,\t\t 32,\t\t 5,\n\t/*  32GB */\t 84,\t\t 49,\t\t 6,\n\t/*  64GB */\t111,\t\t 74,\t\t 7,\n\t/* 128GB */\t147,\t\t111,\t\t 8,\n\t/* 256GB */\t194,\t\t169,\t\t 9,\n\t/* 512GB */\t256,\t\t256,\t\t11,\n\t/*   1TB */\t294,\t\t294,\t\t14,\n\t/*   2TB */\t338,\t\t338,\t\t16,\n\t/*   4TB */\t388,\t\t388,\t\t20,\n\t/*   8TB */\t446,\t\t446,\t\t25,\n\t/*  16TB */\t512,\t\t512,\t\t32\n};\n\nu32 hfsplus_calc_btree_clump_size(u32 block_size, u32 node_size,\n\t\t\t\t\tu64 sectors, int file_id)\n{\n\tu32 mod = max(node_size, block_size);\n\tu32 clump_size;\n\tint column;\n\tint i;\n\n\t/* Figure out which column of the above table to use for this file. */\n\tswitch (file_id) {\n\tcase HFSPLUS_ATTR_CNID:\n\t\tcolumn = 0;\n\t\tbreak;\n\tcase HFSPLUS_CAT_CNID:\n\t\tcolumn = 1;\n\t\tbreak;\n\tdefault:\n\t\tcolumn = 2;\n\t\tbreak;\n\t}\n\n\t/*\n\t * The default clump size is 0.8% of the volume size. And\n\t * it must also be a multiple of the node and block size.\n\t */\n\tif (sectors < 0x200000) {\n\t\tclump_size = sectors << 2;\t/*  0.8 %  */\n\t\tif (clump_size < (8 * node_size))\n\t\t\tclump_size = 8 * node_size;\n\t} else {\n\t\t/* turn exponent into table index... */\n\t\tfor (i = 0, sectors = sectors >> 22;\n\t\t     sectors && (i < CLUMP_ENTRIES - 1);\n\t\t     ++i, sectors = sectors >> 1) {\n\t\t\t/* empty body */\n\t\t}\n\n\t\tclump_size = clumptbl[column + (i) * 3] * 1024 * 1024;\n\t}\n\n\t/*\n\t * Round the clump size to a multiple of node and block size.\n\t * NOTE: This rounds down.\n\t */\n\tclump_size /= mod;\n\tclump_size *= mod;\n\n\t/*\n\t * Rounding down could have rounded down to 0 if the block size was\n\t * greater than the clump size.  If so, just use one block or node.\n\t */\n\tif (clump_size == 0)\n\t\tclump_size = mod;\n\n\treturn clump_size;\n}"
  }
]