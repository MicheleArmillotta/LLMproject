[
  {
    "function_name": "nfsd4_op_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "2320-2325",
    "snippet": "static const char *nfsd4_op_name(unsigned opnum)\n{\n\tif (opnum < ARRAY_SIZE(nfsd4_ops))\n\t\treturn nfsd4_ops[opnum].op_name;\n\treturn \"unknown_operation\";\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfsd4_operation nfsd4_ops[];",
      "static const char *nfsd4_op_name(unsigned opnum);",
      "static struct nfsd4_operation nfsd4_ops[] = {\n\t[OP_ACCESS] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_access,\n\t\t.op_name = \"OP_ACCESS\",\n\t},\n\t[OP_CLOSE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_close,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLOSE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_closestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_closestateid,\n\t},\n\t[OP_COMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_commit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_commit_rsize,\n\t},\n\t[OP_CREATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_CREATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_rsize,\n\t},\n\t[OP_DELEGRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_delegreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DELEGRETURN\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_delegreturnstateid,\n\t},\n\t[OP_GETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getattr,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS,\n\t\t.op_rsize_bop = nfsd4_getattr_rsize,\n\t\t.op_name = \"OP_GETATTR\",\n\t},\n\t[OP_GETFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getfh,\n\t\t.op_name = \"OP_GETFH\",\n\t},\n\t[OP_LINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_link,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS | OP_MODIFIES_SOMETHING\n\t\t\t\t| OP_CACHEME,\n\t\t.op_name = \"OP_LINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_link_rsize,\n\t},\n\t[OP_LOCK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lock,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_lockstateid,\n\t},\n\t[OP_LOCKT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lockt,\n\t\t.op_name = \"OP_LOCKT\",\n\t},\n\t[OP_LOCKU] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_locku,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCKU\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_lockustateid,\n\t},\n\t[OP_LOOKUP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookup,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUP\",\n\t},\n\t[OP_LOOKUPP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookupp,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUPP\",\n\t},\n\t[OP_NVERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_nverify,\n\t\t.op_name = \"OP_NVERIFY\",\n\t},\n\t[OP_OPEN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_open_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_openstateid,\n\t},\n\t[OP_OPEN_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_confirm,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t},\n\t[OP_OPEN_DOWNGRADE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_downgrade,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_DOWNGRADE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_opendowngradestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_opendowngradestateid,\n\t},\n\t[OP_PUTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTPUBFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTPUBFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTROOTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTROOTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_READ] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_read,\n\t\t.op_name = \"OP_READ\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_read_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_readstateid,\n\t},\n\t[OP_READDIR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readdir,\n\t\t.op_name = \"OP_READDIR\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readdir_rsize,\n\t},\n\t[OP_READLINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readlink,\n\t\t.op_name = \"OP_READLINK\",\n\t},\n\t[OP_REMOVE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_remove,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_remove_rsize,\n\t},\n\t[OP_RENAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_rename,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_RENAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_rename_rsize,\n\t},\n\t[OP_RENEW] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_renew,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RENEW\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\n\t},\n\t[OP_RESTOREFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_restorefh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RESTOREFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SAVEFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_savefh,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_SAVEFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO\",\n\t},\n\t[OP_SETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setattr,\n\t\t.op_name = \"OP_SETATTR\",\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setattr_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_setattrstateid,\n\t},\n\t[OP_SETCLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setclientid_rsize,\n\t},\n\t[OP_SETCLIENTID_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid_confirm,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_VERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_verify,\n\t\t.op_name = \"OP_VERIFY\",\n\t},\n\t[OP_WRITE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_write,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_WRITE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_writestateid,\n\t},\n\t[OP_RELEASE_LOCKOWNER] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_release_lockowner,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RELEASE_LOCKOWNER\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\n\t/* NFSv4.1 operations */\n\t[OP_EXCHANGE_ID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_exchange_id,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_EXCHANGE_ID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_exchange_id_rsize,\n\t},\n\t[OP_BACKCHANNEL_CTL] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_backchannel_ctl,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BACKCHANNEL_CTL\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_BIND_CONN_TO_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_bind_conn_to_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BIND_CONN_TO_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_bind_conn_to_session_rsize,\n\t},\n\t[OP_CREATE_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CREATE_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_session_rsize,\n\t},\n\t[OP_DESTROY_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SEQUENCE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_sequence,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,\n\t\t.op_name = \"OP_SEQUENCE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_sequence_rsize,\n\t},\n\t[OP_DESTROY_CLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_clientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_CLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_RECLAIM_COMPLETE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_reclaim_complete,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RECLAIM_COMPLETE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO_NO_NAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo_no_name,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO_NO_NAME\",\n\t},\n\t[OP_TEST_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_test_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_TEST_STATEID\",\n\t},\n\t[OP_FREE_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_free_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_FREE_STATEID\",\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_freestateid,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getdeviceinfo,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_GETDEVICEINFO\",\n\t},\n\t[OP_LAYOUTGET] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutget,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTGET\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutget_rsize,\n\t},\n\t[OP_LAYOUTCOMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutcommit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTCOMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutcommit_rsize,\n\t},\n\t[OP_LAYOUTRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTRETURN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutreturn_rsize,\n\t},\n#endif /* CONFIG_NFSD_PNFS */\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_allocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_ALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_DEALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_deallocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_DEALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_SEEK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_seek,\n\t\t.op_name = \"OP_SEEK\",\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "nfsd4_ops"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic struct nfsd4_operation nfsd4_ops[];\nstatic const char *nfsd4_op_name(unsigned opnum);\nstatic struct nfsd4_operation nfsd4_ops[] = {\n\t[OP_ACCESS] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_access,\n\t\t.op_name = \"OP_ACCESS\",\n\t},\n\t[OP_CLOSE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_close,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLOSE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_closestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_closestateid,\n\t},\n\t[OP_COMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_commit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_commit_rsize,\n\t},\n\t[OP_CREATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_CREATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_rsize,\n\t},\n\t[OP_DELEGRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_delegreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DELEGRETURN\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_delegreturnstateid,\n\t},\n\t[OP_GETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getattr,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS,\n\t\t.op_rsize_bop = nfsd4_getattr_rsize,\n\t\t.op_name = \"OP_GETATTR\",\n\t},\n\t[OP_GETFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getfh,\n\t\t.op_name = \"OP_GETFH\",\n\t},\n\t[OP_LINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_link,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS | OP_MODIFIES_SOMETHING\n\t\t\t\t| OP_CACHEME,\n\t\t.op_name = \"OP_LINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_link_rsize,\n\t},\n\t[OP_LOCK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lock,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_lockstateid,\n\t},\n\t[OP_LOCKT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lockt,\n\t\t.op_name = \"OP_LOCKT\",\n\t},\n\t[OP_LOCKU] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_locku,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCKU\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_lockustateid,\n\t},\n\t[OP_LOOKUP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookup,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUP\",\n\t},\n\t[OP_LOOKUPP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookupp,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUPP\",\n\t},\n\t[OP_NVERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_nverify,\n\t\t.op_name = \"OP_NVERIFY\",\n\t},\n\t[OP_OPEN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_open_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_openstateid,\n\t},\n\t[OP_OPEN_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_confirm,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t},\n\t[OP_OPEN_DOWNGRADE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_downgrade,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_DOWNGRADE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_opendowngradestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_opendowngradestateid,\n\t},\n\t[OP_PUTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTPUBFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTPUBFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTROOTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTROOTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_READ] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_read,\n\t\t.op_name = \"OP_READ\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_read_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_readstateid,\n\t},\n\t[OP_READDIR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readdir,\n\t\t.op_name = \"OP_READDIR\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readdir_rsize,\n\t},\n\t[OP_READLINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readlink,\n\t\t.op_name = \"OP_READLINK\",\n\t},\n\t[OP_REMOVE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_remove,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_remove_rsize,\n\t},\n\t[OP_RENAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_rename,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_RENAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_rename_rsize,\n\t},\n\t[OP_RENEW] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_renew,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RENEW\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\n\t},\n\t[OP_RESTOREFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_restorefh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RESTOREFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SAVEFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_savefh,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_SAVEFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO\",\n\t},\n\t[OP_SETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setattr,\n\t\t.op_name = \"OP_SETATTR\",\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setattr_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_setattrstateid,\n\t},\n\t[OP_SETCLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setclientid_rsize,\n\t},\n\t[OP_SETCLIENTID_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid_confirm,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_VERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_verify,\n\t\t.op_name = \"OP_VERIFY\",\n\t},\n\t[OP_WRITE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_write,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_WRITE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_writestateid,\n\t},\n\t[OP_RELEASE_LOCKOWNER] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_release_lockowner,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RELEASE_LOCKOWNER\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\n\t/* NFSv4.1 operations */\n\t[OP_EXCHANGE_ID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_exchange_id,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_EXCHANGE_ID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_exchange_id_rsize,\n\t},\n\t[OP_BACKCHANNEL_CTL] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_backchannel_ctl,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BACKCHANNEL_CTL\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_BIND_CONN_TO_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_bind_conn_to_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BIND_CONN_TO_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_bind_conn_to_session_rsize,\n\t},\n\t[OP_CREATE_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CREATE_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_session_rsize,\n\t},\n\t[OP_DESTROY_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SEQUENCE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_sequence,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,\n\t\t.op_name = \"OP_SEQUENCE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_sequence_rsize,\n\t},\n\t[OP_DESTROY_CLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_clientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_CLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_RECLAIM_COMPLETE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_reclaim_complete,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RECLAIM_COMPLETE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO_NO_NAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo_no_name,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO_NO_NAME\",\n\t},\n\t[OP_TEST_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_test_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_TEST_STATEID\",\n\t},\n\t[OP_FREE_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_free_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_FREE_STATEID\",\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_freestateid,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getdeviceinfo,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_GETDEVICEINFO\",\n\t},\n\t[OP_LAYOUTGET] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutget,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTGET\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutget_rsize,\n\t},\n\t[OP_LAYOUTCOMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutcommit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTCOMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutcommit_rsize,\n\t},\n\t[OP_LAYOUTRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTRETURN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutreturn_rsize,\n\t},\n#endif /* CONFIG_NFSD_PNFS */\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_allocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_ALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_DEALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_deallocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_DEALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_SEEK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_seek,\n\t\t.op_name = \"OP_SEEK\",\n\t},\n};\n\nstatic const char *nfsd4_op_name(unsigned opnum)\n{\n\tif (opnum < ARRAY_SIZE(nfsd4_ops))\n\t\treturn nfsd4_ops[opnum].op_name;\n\treturn \"unknown_operation\";\n}"
  },
  {
    "function_name": "warn_on_nonidempotent_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "2311-2318",
    "snippet": "void warn_on_nonidempotent_op(struct nfsd4_op *op)\n{\n\tif (OPDESC(op)->op_flags & OP_MODIFIES_SOMETHING) {\n\t\tpr_err(\"unable to encode reply to nonidempotent op %d (%s)\\n\",\n\t\t\top->opnum, nfsd4_op_name(op->opnum));\n\t\tWARN_ON_ONCE(1);\n\t}\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *nfsd4_op_name(unsigned opnum);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unable to encode reply to nonidempotent op %d (%s)\\n\"",
            "op->opnum",
            "nfsd4_op_name(op->opnum)"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_op_name",
          "args": [
            "op->opnum"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "2320-2325",
          "snippet": "static const char *nfsd4_op_name(unsigned opnum)\n{\n\tif (opnum < ARRAY_SIZE(nfsd4_ops))\n\t\treturn nfsd4_ops[opnum].op_name;\n\treturn \"unknown_operation\";\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfsd4_operation nfsd4_ops[];",
            "static const char *nfsd4_op_name(unsigned opnum);",
            "static struct nfsd4_operation nfsd4_ops[] = {\n\t[OP_ACCESS] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_access,\n\t\t.op_name = \"OP_ACCESS\",\n\t},\n\t[OP_CLOSE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_close,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLOSE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_closestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_closestateid,\n\t},\n\t[OP_COMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_commit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_commit_rsize,\n\t},\n\t[OP_CREATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_CREATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_rsize,\n\t},\n\t[OP_DELEGRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_delegreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DELEGRETURN\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_delegreturnstateid,\n\t},\n\t[OP_GETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getattr,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS,\n\t\t.op_rsize_bop = nfsd4_getattr_rsize,\n\t\t.op_name = \"OP_GETATTR\",\n\t},\n\t[OP_GETFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getfh,\n\t\t.op_name = \"OP_GETFH\",\n\t},\n\t[OP_LINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_link,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS | OP_MODIFIES_SOMETHING\n\t\t\t\t| OP_CACHEME,\n\t\t.op_name = \"OP_LINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_link_rsize,\n\t},\n\t[OP_LOCK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lock,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_lockstateid,\n\t},\n\t[OP_LOCKT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lockt,\n\t\t.op_name = \"OP_LOCKT\",\n\t},\n\t[OP_LOCKU] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_locku,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCKU\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_lockustateid,\n\t},\n\t[OP_LOOKUP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookup,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUP\",\n\t},\n\t[OP_LOOKUPP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookupp,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUPP\",\n\t},\n\t[OP_NVERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_nverify,\n\t\t.op_name = \"OP_NVERIFY\",\n\t},\n\t[OP_OPEN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_open_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_openstateid,\n\t},\n\t[OP_OPEN_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_confirm,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t},\n\t[OP_OPEN_DOWNGRADE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_downgrade,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_DOWNGRADE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_opendowngradestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_opendowngradestateid,\n\t},\n\t[OP_PUTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTPUBFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTPUBFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTROOTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTROOTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_READ] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_read,\n\t\t.op_name = \"OP_READ\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_read_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_readstateid,\n\t},\n\t[OP_READDIR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readdir,\n\t\t.op_name = \"OP_READDIR\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readdir_rsize,\n\t},\n\t[OP_READLINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readlink,\n\t\t.op_name = \"OP_READLINK\",\n\t},\n\t[OP_REMOVE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_remove,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_remove_rsize,\n\t},\n\t[OP_RENAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_rename,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_RENAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_rename_rsize,\n\t},\n\t[OP_RENEW] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_renew,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RENEW\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\n\t},\n\t[OP_RESTOREFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_restorefh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RESTOREFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SAVEFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_savefh,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_SAVEFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO\",\n\t},\n\t[OP_SETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setattr,\n\t\t.op_name = \"OP_SETATTR\",\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setattr_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_setattrstateid,\n\t},\n\t[OP_SETCLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setclientid_rsize,\n\t},\n\t[OP_SETCLIENTID_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid_confirm,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_VERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_verify,\n\t\t.op_name = \"OP_VERIFY\",\n\t},\n\t[OP_WRITE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_write,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_WRITE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_writestateid,\n\t},\n\t[OP_RELEASE_LOCKOWNER] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_release_lockowner,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RELEASE_LOCKOWNER\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\n\t/* NFSv4.1 operations */\n\t[OP_EXCHANGE_ID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_exchange_id,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_EXCHANGE_ID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_exchange_id_rsize,\n\t},\n\t[OP_BACKCHANNEL_CTL] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_backchannel_ctl,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BACKCHANNEL_CTL\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_BIND_CONN_TO_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_bind_conn_to_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BIND_CONN_TO_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_bind_conn_to_session_rsize,\n\t},\n\t[OP_CREATE_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CREATE_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_session_rsize,\n\t},\n\t[OP_DESTROY_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SEQUENCE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_sequence,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,\n\t\t.op_name = \"OP_SEQUENCE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_sequence_rsize,\n\t},\n\t[OP_DESTROY_CLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_clientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_CLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_RECLAIM_COMPLETE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_reclaim_complete,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RECLAIM_COMPLETE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO_NO_NAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo_no_name,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO_NO_NAME\",\n\t},\n\t[OP_TEST_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_test_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_TEST_STATEID\",\n\t},\n\t[OP_FREE_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_free_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_FREE_STATEID\",\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_freestateid,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getdeviceinfo,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_GETDEVICEINFO\",\n\t},\n\t[OP_LAYOUTGET] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutget,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTGET\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutget_rsize,\n\t},\n\t[OP_LAYOUTCOMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutcommit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTCOMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutcommit_rsize,\n\t},\n\t[OP_LAYOUTRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTRETURN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutreturn_rsize,\n\t},\n#endif /* CONFIG_NFSD_PNFS */\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_allocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_ALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_DEALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_deallocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_DEALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_SEEK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_seek,\n\t\t.op_name = \"OP_SEEK\",\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic struct nfsd4_operation nfsd4_ops[];\nstatic const char *nfsd4_op_name(unsigned opnum);\nstatic struct nfsd4_operation nfsd4_ops[] = {\n\t[OP_ACCESS] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_access,\n\t\t.op_name = \"OP_ACCESS\",\n\t},\n\t[OP_CLOSE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_close,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLOSE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_closestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_closestateid,\n\t},\n\t[OP_COMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_commit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_commit_rsize,\n\t},\n\t[OP_CREATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_CREATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_rsize,\n\t},\n\t[OP_DELEGRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_delegreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DELEGRETURN\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_delegreturnstateid,\n\t},\n\t[OP_GETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getattr,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS,\n\t\t.op_rsize_bop = nfsd4_getattr_rsize,\n\t\t.op_name = \"OP_GETATTR\",\n\t},\n\t[OP_GETFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getfh,\n\t\t.op_name = \"OP_GETFH\",\n\t},\n\t[OP_LINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_link,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS | OP_MODIFIES_SOMETHING\n\t\t\t\t| OP_CACHEME,\n\t\t.op_name = \"OP_LINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_link_rsize,\n\t},\n\t[OP_LOCK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lock,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_lockstateid,\n\t},\n\t[OP_LOCKT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lockt,\n\t\t.op_name = \"OP_LOCKT\",\n\t},\n\t[OP_LOCKU] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_locku,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCKU\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_lockustateid,\n\t},\n\t[OP_LOOKUP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookup,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUP\",\n\t},\n\t[OP_LOOKUPP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookupp,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUPP\",\n\t},\n\t[OP_NVERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_nverify,\n\t\t.op_name = \"OP_NVERIFY\",\n\t},\n\t[OP_OPEN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_open_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_openstateid,\n\t},\n\t[OP_OPEN_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_confirm,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t},\n\t[OP_OPEN_DOWNGRADE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_downgrade,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_DOWNGRADE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_opendowngradestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_opendowngradestateid,\n\t},\n\t[OP_PUTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTPUBFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTPUBFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTROOTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTROOTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_READ] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_read,\n\t\t.op_name = \"OP_READ\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_read_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_readstateid,\n\t},\n\t[OP_READDIR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readdir,\n\t\t.op_name = \"OP_READDIR\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readdir_rsize,\n\t},\n\t[OP_READLINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readlink,\n\t\t.op_name = \"OP_READLINK\",\n\t},\n\t[OP_REMOVE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_remove,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_remove_rsize,\n\t},\n\t[OP_RENAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_rename,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_RENAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_rename_rsize,\n\t},\n\t[OP_RENEW] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_renew,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RENEW\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\n\t},\n\t[OP_RESTOREFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_restorefh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RESTOREFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SAVEFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_savefh,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_SAVEFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO\",\n\t},\n\t[OP_SETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setattr,\n\t\t.op_name = \"OP_SETATTR\",\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setattr_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_setattrstateid,\n\t},\n\t[OP_SETCLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setclientid_rsize,\n\t},\n\t[OP_SETCLIENTID_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid_confirm,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_VERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_verify,\n\t\t.op_name = \"OP_VERIFY\",\n\t},\n\t[OP_WRITE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_write,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_WRITE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_writestateid,\n\t},\n\t[OP_RELEASE_LOCKOWNER] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_release_lockowner,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RELEASE_LOCKOWNER\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\n\t/* NFSv4.1 operations */\n\t[OP_EXCHANGE_ID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_exchange_id,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_EXCHANGE_ID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_exchange_id_rsize,\n\t},\n\t[OP_BACKCHANNEL_CTL] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_backchannel_ctl,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BACKCHANNEL_CTL\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_BIND_CONN_TO_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_bind_conn_to_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BIND_CONN_TO_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_bind_conn_to_session_rsize,\n\t},\n\t[OP_CREATE_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CREATE_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_session_rsize,\n\t},\n\t[OP_DESTROY_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SEQUENCE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_sequence,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,\n\t\t.op_name = \"OP_SEQUENCE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_sequence_rsize,\n\t},\n\t[OP_DESTROY_CLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_clientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_CLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_RECLAIM_COMPLETE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_reclaim_complete,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RECLAIM_COMPLETE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO_NO_NAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo_no_name,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO_NO_NAME\",\n\t},\n\t[OP_TEST_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_test_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_TEST_STATEID\",\n\t},\n\t[OP_FREE_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_free_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_FREE_STATEID\",\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_freestateid,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getdeviceinfo,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_GETDEVICEINFO\",\n\t},\n\t[OP_LAYOUTGET] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutget,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTGET\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutget_rsize,\n\t},\n\t[OP_LAYOUTCOMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutcommit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTCOMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutcommit_rsize,\n\t},\n\t[OP_LAYOUTRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTRETURN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutreturn_rsize,\n\t},\n#endif /* CONFIG_NFSD_PNFS */\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_allocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_ALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_DEALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_deallocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_DEALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_SEEK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_seek,\n\t\t.op_name = \"OP_SEEK\",\n\t},\n};\n\nstatic const char *nfsd4_op_name(unsigned opnum)\n{\n\tif (opnum < ARRAY_SIZE(nfsd4_ops))\n\t\treturn nfsd4_ops[opnum].op_name;\n\treturn \"unknown_operation\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "OPDESC",
          "args": [
            "op"
          ],
          "line": 2313
        },
        "resolved": true,
        "details": {
          "function_name": "OPDESC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "1534-1537",
          "snippet": "static inline struct nfsd4_operation *OPDESC(struct nfsd4_op *op)\n{\n\treturn &nfsd4_ops[op->opnum];\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfsd4_operation nfsd4_ops[];",
            "static const char *nfsd4_op_name(unsigned opnum);",
            "static struct nfsd4_operation nfsd4_ops[] = {\n\t[OP_ACCESS] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_access,\n\t\t.op_name = \"OP_ACCESS\",\n\t},\n\t[OP_CLOSE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_close,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLOSE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_closestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_closestateid,\n\t},\n\t[OP_COMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_commit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_commit_rsize,\n\t},\n\t[OP_CREATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_CREATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_rsize,\n\t},\n\t[OP_DELEGRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_delegreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DELEGRETURN\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_delegreturnstateid,\n\t},\n\t[OP_GETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getattr,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS,\n\t\t.op_rsize_bop = nfsd4_getattr_rsize,\n\t\t.op_name = \"OP_GETATTR\",\n\t},\n\t[OP_GETFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getfh,\n\t\t.op_name = \"OP_GETFH\",\n\t},\n\t[OP_LINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_link,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS | OP_MODIFIES_SOMETHING\n\t\t\t\t| OP_CACHEME,\n\t\t.op_name = \"OP_LINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_link_rsize,\n\t},\n\t[OP_LOCK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lock,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_lockstateid,\n\t},\n\t[OP_LOCKT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lockt,\n\t\t.op_name = \"OP_LOCKT\",\n\t},\n\t[OP_LOCKU] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_locku,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCKU\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_lockustateid,\n\t},\n\t[OP_LOOKUP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookup,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUP\",\n\t},\n\t[OP_LOOKUPP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookupp,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUPP\",\n\t},\n\t[OP_NVERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_nverify,\n\t\t.op_name = \"OP_NVERIFY\",\n\t},\n\t[OP_OPEN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_open_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_openstateid,\n\t},\n\t[OP_OPEN_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_confirm,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t},\n\t[OP_OPEN_DOWNGRADE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_downgrade,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_DOWNGRADE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_opendowngradestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_opendowngradestateid,\n\t},\n\t[OP_PUTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTPUBFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTPUBFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTROOTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTROOTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_READ] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_read,\n\t\t.op_name = \"OP_READ\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_read_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_readstateid,\n\t},\n\t[OP_READDIR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readdir,\n\t\t.op_name = \"OP_READDIR\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readdir_rsize,\n\t},\n\t[OP_READLINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readlink,\n\t\t.op_name = \"OP_READLINK\",\n\t},\n\t[OP_REMOVE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_remove,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_remove_rsize,\n\t},\n\t[OP_RENAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_rename,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_RENAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_rename_rsize,\n\t},\n\t[OP_RENEW] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_renew,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RENEW\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\n\t},\n\t[OP_RESTOREFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_restorefh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RESTOREFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SAVEFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_savefh,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_SAVEFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO\",\n\t},\n\t[OP_SETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setattr,\n\t\t.op_name = \"OP_SETATTR\",\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setattr_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_setattrstateid,\n\t},\n\t[OP_SETCLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setclientid_rsize,\n\t},\n\t[OP_SETCLIENTID_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid_confirm,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_VERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_verify,\n\t\t.op_name = \"OP_VERIFY\",\n\t},\n\t[OP_WRITE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_write,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_WRITE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_writestateid,\n\t},\n\t[OP_RELEASE_LOCKOWNER] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_release_lockowner,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RELEASE_LOCKOWNER\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\n\t/* NFSv4.1 operations */\n\t[OP_EXCHANGE_ID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_exchange_id,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_EXCHANGE_ID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_exchange_id_rsize,\n\t},\n\t[OP_BACKCHANNEL_CTL] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_backchannel_ctl,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BACKCHANNEL_CTL\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_BIND_CONN_TO_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_bind_conn_to_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BIND_CONN_TO_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_bind_conn_to_session_rsize,\n\t},\n\t[OP_CREATE_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CREATE_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_session_rsize,\n\t},\n\t[OP_DESTROY_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SEQUENCE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_sequence,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,\n\t\t.op_name = \"OP_SEQUENCE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_sequence_rsize,\n\t},\n\t[OP_DESTROY_CLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_clientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_CLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_RECLAIM_COMPLETE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_reclaim_complete,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RECLAIM_COMPLETE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO_NO_NAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo_no_name,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO_NO_NAME\",\n\t},\n\t[OP_TEST_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_test_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_TEST_STATEID\",\n\t},\n\t[OP_FREE_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_free_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_FREE_STATEID\",\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_freestateid,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getdeviceinfo,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_GETDEVICEINFO\",\n\t},\n\t[OP_LAYOUTGET] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutget,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTGET\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutget_rsize,\n\t},\n\t[OP_LAYOUTCOMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutcommit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTCOMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutcommit_rsize,\n\t},\n\t[OP_LAYOUTRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTRETURN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutreturn_rsize,\n\t},\n#endif /* CONFIG_NFSD_PNFS */\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_allocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_ALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_DEALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_deallocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_DEALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_SEEK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_seek,\n\t\t.op_name = \"OP_SEEK\",\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic struct nfsd4_operation nfsd4_ops[];\nstatic const char *nfsd4_op_name(unsigned opnum);\nstatic struct nfsd4_operation nfsd4_ops[] = {\n\t[OP_ACCESS] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_access,\n\t\t.op_name = \"OP_ACCESS\",\n\t},\n\t[OP_CLOSE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_close,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLOSE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_closestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_closestateid,\n\t},\n\t[OP_COMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_commit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_commit_rsize,\n\t},\n\t[OP_CREATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_CREATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_rsize,\n\t},\n\t[OP_DELEGRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_delegreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DELEGRETURN\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_delegreturnstateid,\n\t},\n\t[OP_GETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getattr,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS,\n\t\t.op_rsize_bop = nfsd4_getattr_rsize,\n\t\t.op_name = \"OP_GETATTR\",\n\t},\n\t[OP_GETFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getfh,\n\t\t.op_name = \"OP_GETFH\",\n\t},\n\t[OP_LINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_link,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS | OP_MODIFIES_SOMETHING\n\t\t\t\t| OP_CACHEME,\n\t\t.op_name = \"OP_LINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_link_rsize,\n\t},\n\t[OP_LOCK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lock,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_lockstateid,\n\t},\n\t[OP_LOCKT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lockt,\n\t\t.op_name = \"OP_LOCKT\",\n\t},\n\t[OP_LOCKU] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_locku,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCKU\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_lockustateid,\n\t},\n\t[OP_LOOKUP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookup,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUP\",\n\t},\n\t[OP_LOOKUPP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookupp,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUPP\",\n\t},\n\t[OP_NVERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_nverify,\n\t\t.op_name = \"OP_NVERIFY\",\n\t},\n\t[OP_OPEN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_open_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_openstateid,\n\t},\n\t[OP_OPEN_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_confirm,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t},\n\t[OP_OPEN_DOWNGRADE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_downgrade,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_DOWNGRADE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_opendowngradestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_opendowngradestateid,\n\t},\n\t[OP_PUTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTPUBFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTPUBFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTROOTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTROOTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_READ] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_read,\n\t\t.op_name = \"OP_READ\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_read_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_readstateid,\n\t},\n\t[OP_READDIR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readdir,\n\t\t.op_name = \"OP_READDIR\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readdir_rsize,\n\t},\n\t[OP_READLINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readlink,\n\t\t.op_name = \"OP_READLINK\",\n\t},\n\t[OP_REMOVE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_remove,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_remove_rsize,\n\t},\n\t[OP_RENAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_rename,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_RENAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_rename_rsize,\n\t},\n\t[OP_RENEW] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_renew,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RENEW\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\n\t},\n\t[OP_RESTOREFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_restorefh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RESTOREFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SAVEFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_savefh,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_SAVEFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO\",\n\t},\n\t[OP_SETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setattr,\n\t\t.op_name = \"OP_SETATTR\",\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setattr_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_setattrstateid,\n\t},\n\t[OP_SETCLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setclientid_rsize,\n\t},\n\t[OP_SETCLIENTID_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid_confirm,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_VERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_verify,\n\t\t.op_name = \"OP_VERIFY\",\n\t},\n\t[OP_WRITE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_write,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_WRITE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_writestateid,\n\t},\n\t[OP_RELEASE_LOCKOWNER] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_release_lockowner,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RELEASE_LOCKOWNER\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\n\t/* NFSv4.1 operations */\n\t[OP_EXCHANGE_ID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_exchange_id,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_EXCHANGE_ID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_exchange_id_rsize,\n\t},\n\t[OP_BACKCHANNEL_CTL] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_backchannel_ctl,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BACKCHANNEL_CTL\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_BIND_CONN_TO_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_bind_conn_to_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BIND_CONN_TO_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_bind_conn_to_session_rsize,\n\t},\n\t[OP_CREATE_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CREATE_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_session_rsize,\n\t},\n\t[OP_DESTROY_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SEQUENCE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_sequence,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,\n\t\t.op_name = \"OP_SEQUENCE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_sequence_rsize,\n\t},\n\t[OP_DESTROY_CLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_clientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_CLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_RECLAIM_COMPLETE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_reclaim_complete,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RECLAIM_COMPLETE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO_NO_NAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo_no_name,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO_NO_NAME\",\n\t},\n\t[OP_TEST_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_test_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_TEST_STATEID\",\n\t},\n\t[OP_FREE_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_free_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_FREE_STATEID\",\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_freestateid,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getdeviceinfo,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_GETDEVICEINFO\",\n\t},\n\t[OP_LAYOUTGET] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutget,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTGET\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutget_rsize,\n\t},\n\t[OP_LAYOUTCOMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutcommit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTCOMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutcommit_rsize,\n\t},\n\t[OP_LAYOUTRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTRETURN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutreturn_rsize,\n\t},\n#endif /* CONFIG_NFSD_PNFS */\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_allocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_ALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_DEALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_deallocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_DEALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_SEEK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_seek,\n\t\t.op_name = \"OP_SEEK\",\n\t},\n};\n\nstatic inline struct nfsd4_operation *OPDESC(struct nfsd4_op *op)\n{\n\treturn &nfsd4_ops[op->opnum];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic const char *nfsd4_op_name(unsigned opnum);\n\nvoid warn_on_nonidempotent_op(struct nfsd4_op *op)\n{\n\tif (OPDESC(op)->op_flags & OP_MODIFIES_SOMETHING) {\n\t\tpr_err(\"unable to encode reply to nonidempotent op %d (%s)\\n\",\n\t\t\top->opnum, nfsd4_op_name(op->opnum));\n\t\tWARN_ON_ONCE(1);\n\t}\n}"
  },
  {
    "function_name": "nfsd4_max_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "2299-2309",
    "snippet": "int nfsd4_max_reply(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tstruct nfsd4_operation *opdesc;\n\tnfsd4op_rsize estimator;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn op_encode_hdr_size * sizeof(__be32);\n\topdesc = OPDESC(op);\n\testimator = opdesc->op_rsize_bop;\n\treturn estimator ? estimator(rqstp, op) : PAGE_SIZE;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define op_encode_hdr_size\t\t(2)"
    ],
    "globals_used": [
      "static const char *nfsd4_op_name(unsigned opnum);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "estimator",
          "args": [
            "rqstp",
            "op"
          ],
          "line": 2308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPDESC",
          "args": [
            "op"
          ],
          "line": 2306
        },
        "resolved": true,
        "details": {
          "function_name": "OPDESC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "1534-1537",
          "snippet": "static inline struct nfsd4_operation *OPDESC(struct nfsd4_op *op)\n{\n\treturn &nfsd4_ops[op->opnum];\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfsd4_operation nfsd4_ops[];",
            "static const char *nfsd4_op_name(unsigned opnum);",
            "static struct nfsd4_operation nfsd4_ops[] = {\n\t[OP_ACCESS] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_access,\n\t\t.op_name = \"OP_ACCESS\",\n\t},\n\t[OP_CLOSE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_close,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLOSE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_closestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_closestateid,\n\t},\n\t[OP_COMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_commit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_commit_rsize,\n\t},\n\t[OP_CREATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_CREATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_rsize,\n\t},\n\t[OP_DELEGRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_delegreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DELEGRETURN\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_delegreturnstateid,\n\t},\n\t[OP_GETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getattr,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS,\n\t\t.op_rsize_bop = nfsd4_getattr_rsize,\n\t\t.op_name = \"OP_GETATTR\",\n\t},\n\t[OP_GETFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getfh,\n\t\t.op_name = \"OP_GETFH\",\n\t},\n\t[OP_LINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_link,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS | OP_MODIFIES_SOMETHING\n\t\t\t\t| OP_CACHEME,\n\t\t.op_name = \"OP_LINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_link_rsize,\n\t},\n\t[OP_LOCK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lock,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_lockstateid,\n\t},\n\t[OP_LOCKT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lockt,\n\t\t.op_name = \"OP_LOCKT\",\n\t},\n\t[OP_LOCKU] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_locku,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCKU\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_lockustateid,\n\t},\n\t[OP_LOOKUP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookup,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUP\",\n\t},\n\t[OP_LOOKUPP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookupp,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUPP\",\n\t},\n\t[OP_NVERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_nverify,\n\t\t.op_name = \"OP_NVERIFY\",\n\t},\n\t[OP_OPEN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_open_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_openstateid,\n\t},\n\t[OP_OPEN_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_confirm,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t},\n\t[OP_OPEN_DOWNGRADE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_downgrade,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_DOWNGRADE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_opendowngradestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_opendowngradestateid,\n\t},\n\t[OP_PUTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTPUBFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTPUBFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTROOTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTROOTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_READ] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_read,\n\t\t.op_name = \"OP_READ\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_read_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_readstateid,\n\t},\n\t[OP_READDIR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readdir,\n\t\t.op_name = \"OP_READDIR\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readdir_rsize,\n\t},\n\t[OP_READLINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readlink,\n\t\t.op_name = \"OP_READLINK\",\n\t},\n\t[OP_REMOVE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_remove,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_remove_rsize,\n\t},\n\t[OP_RENAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_rename,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_RENAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_rename_rsize,\n\t},\n\t[OP_RENEW] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_renew,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RENEW\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\n\t},\n\t[OP_RESTOREFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_restorefh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RESTOREFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SAVEFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_savefh,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_SAVEFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO\",\n\t},\n\t[OP_SETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setattr,\n\t\t.op_name = \"OP_SETATTR\",\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setattr_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_setattrstateid,\n\t},\n\t[OP_SETCLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setclientid_rsize,\n\t},\n\t[OP_SETCLIENTID_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid_confirm,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_VERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_verify,\n\t\t.op_name = \"OP_VERIFY\",\n\t},\n\t[OP_WRITE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_write,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_WRITE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_writestateid,\n\t},\n\t[OP_RELEASE_LOCKOWNER] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_release_lockowner,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RELEASE_LOCKOWNER\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\n\t/* NFSv4.1 operations */\n\t[OP_EXCHANGE_ID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_exchange_id,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_EXCHANGE_ID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_exchange_id_rsize,\n\t},\n\t[OP_BACKCHANNEL_CTL] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_backchannel_ctl,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BACKCHANNEL_CTL\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_BIND_CONN_TO_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_bind_conn_to_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BIND_CONN_TO_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_bind_conn_to_session_rsize,\n\t},\n\t[OP_CREATE_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CREATE_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_session_rsize,\n\t},\n\t[OP_DESTROY_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SEQUENCE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_sequence,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,\n\t\t.op_name = \"OP_SEQUENCE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_sequence_rsize,\n\t},\n\t[OP_DESTROY_CLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_clientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_CLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_RECLAIM_COMPLETE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_reclaim_complete,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RECLAIM_COMPLETE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO_NO_NAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo_no_name,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO_NO_NAME\",\n\t},\n\t[OP_TEST_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_test_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_TEST_STATEID\",\n\t},\n\t[OP_FREE_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_free_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_FREE_STATEID\",\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_freestateid,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getdeviceinfo,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_GETDEVICEINFO\",\n\t},\n\t[OP_LAYOUTGET] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutget,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTGET\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutget_rsize,\n\t},\n\t[OP_LAYOUTCOMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutcommit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTCOMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutcommit_rsize,\n\t},\n\t[OP_LAYOUTRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTRETURN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutreturn_rsize,\n\t},\n#endif /* CONFIG_NFSD_PNFS */\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_allocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_ALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_DEALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_deallocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_DEALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_SEEK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_seek,\n\t\t.op_name = \"OP_SEEK\",\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic struct nfsd4_operation nfsd4_ops[];\nstatic const char *nfsd4_op_name(unsigned opnum);\nstatic struct nfsd4_operation nfsd4_ops[] = {\n\t[OP_ACCESS] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_access,\n\t\t.op_name = \"OP_ACCESS\",\n\t},\n\t[OP_CLOSE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_close,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLOSE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_closestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_closestateid,\n\t},\n\t[OP_COMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_commit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_commit_rsize,\n\t},\n\t[OP_CREATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_CREATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_rsize,\n\t},\n\t[OP_DELEGRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_delegreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DELEGRETURN\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_delegreturnstateid,\n\t},\n\t[OP_GETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getattr,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS,\n\t\t.op_rsize_bop = nfsd4_getattr_rsize,\n\t\t.op_name = \"OP_GETATTR\",\n\t},\n\t[OP_GETFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getfh,\n\t\t.op_name = \"OP_GETFH\",\n\t},\n\t[OP_LINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_link,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS | OP_MODIFIES_SOMETHING\n\t\t\t\t| OP_CACHEME,\n\t\t.op_name = \"OP_LINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_link_rsize,\n\t},\n\t[OP_LOCK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lock,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_lockstateid,\n\t},\n\t[OP_LOCKT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lockt,\n\t\t.op_name = \"OP_LOCKT\",\n\t},\n\t[OP_LOCKU] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_locku,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCKU\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_lockustateid,\n\t},\n\t[OP_LOOKUP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookup,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUP\",\n\t},\n\t[OP_LOOKUPP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookupp,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUPP\",\n\t},\n\t[OP_NVERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_nverify,\n\t\t.op_name = \"OP_NVERIFY\",\n\t},\n\t[OP_OPEN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_open_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_openstateid,\n\t},\n\t[OP_OPEN_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_confirm,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t},\n\t[OP_OPEN_DOWNGRADE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_downgrade,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_DOWNGRADE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_opendowngradestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_opendowngradestateid,\n\t},\n\t[OP_PUTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTPUBFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTPUBFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTROOTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTROOTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_READ] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_read,\n\t\t.op_name = \"OP_READ\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_read_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_readstateid,\n\t},\n\t[OP_READDIR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readdir,\n\t\t.op_name = \"OP_READDIR\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readdir_rsize,\n\t},\n\t[OP_READLINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readlink,\n\t\t.op_name = \"OP_READLINK\",\n\t},\n\t[OP_REMOVE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_remove,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_remove_rsize,\n\t},\n\t[OP_RENAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_rename,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_RENAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_rename_rsize,\n\t},\n\t[OP_RENEW] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_renew,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RENEW\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\n\t},\n\t[OP_RESTOREFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_restorefh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RESTOREFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SAVEFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_savefh,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_SAVEFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO\",\n\t},\n\t[OP_SETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setattr,\n\t\t.op_name = \"OP_SETATTR\",\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setattr_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_setattrstateid,\n\t},\n\t[OP_SETCLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setclientid_rsize,\n\t},\n\t[OP_SETCLIENTID_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid_confirm,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_VERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_verify,\n\t\t.op_name = \"OP_VERIFY\",\n\t},\n\t[OP_WRITE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_write,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_WRITE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_writestateid,\n\t},\n\t[OP_RELEASE_LOCKOWNER] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_release_lockowner,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RELEASE_LOCKOWNER\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\n\t/* NFSv4.1 operations */\n\t[OP_EXCHANGE_ID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_exchange_id,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_EXCHANGE_ID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_exchange_id_rsize,\n\t},\n\t[OP_BACKCHANNEL_CTL] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_backchannel_ctl,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BACKCHANNEL_CTL\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_BIND_CONN_TO_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_bind_conn_to_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BIND_CONN_TO_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_bind_conn_to_session_rsize,\n\t},\n\t[OP_CREATE_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CREATE_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_session_rsize,\n\t},\n\t[OP_DESTROY_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SEQUENCE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_sequence,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,\n\t\t.op_name = \"OP_SEQUENCE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_sequence_rsize,\n\t},\n\t[OP_DESTROY_CLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_clientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_CLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_RECLAIM_COMPLETE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_reclaim_complete,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RECLAIM_COMPLETE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO_NO_NAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo_no_name,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO_NO_NAME\",\n\t},\n\t[OP_TEST_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_test_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_TEST_STATEID\",\n\t},\n\t[OP_FREE_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_free_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_FREE_STATEID\",\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_freestateid,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getdeviceinfo,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_GETDEVICEINFO\",\n\t},\n\t[OP_LAYOUTGET] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutget,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTGET\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutget_rsize,\n\t},\n\t[OP_LAYOUTCOMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutcommit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTCOMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutcommit_rsize,\n\t},\n\t[OP_LAYOUTRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTRETURN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutreturn_rsize,\n\t},\n#endif /* CONFIG_NFSD_PNFS */\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_allocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_ALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_DEALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_deallocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_DEALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_SEEK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_seek,\n\t\t.op_name = \"OP_SEEK\",\n\t},\n};\n\nstatic inline struct nfsd4_operation *OPDESC(struct nfsd4_op *op)\n{\n\treturn &nfsd4_ops[op->opnum];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_hdr_size\t\t(2)\n\nstatic const char *nfsd4_op_name(unsigned opnum);\n\nint nfsd4_max_reply(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tstruct nfsd4_operation *opdesc;\n\tnfsd4op_rsize estimator;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn op_encode_hdr_size * sizeof(__be32);\n\topdesc = OPDESC(op);\n\testimator = opdesc->op_rsize_bop;\n\treturn estimator ? estimator(rqstp, op) : PAGE_SIZE;\n}"
  },
  {
    "function_name": "nfsd4_layoutreturn_rsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1959-1964",
    "snippet": "static inline u32 nfsd4_layoutreturn_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size +\n\t\t1 /* lrs_stateid */ +\n\t\top_encode_stateid_maxsz) * sizeof(__be32);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define op_encode_stateid_maxsz\t\t(XDR_QUADLEN(NFS4_STATEID_SIZE))",
      "#define op_encode_hdr_size\t\t(2)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_stateid_maxsz\t\t(XDR_QUADLEN(NFS4_STATEID_SIZE))\n#define op_encode_hdr_size\t\t(2)\n\nstatic inline u32 nfsd4_layoutreturn_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size +\n\t\t1 /* lrs_stateid */ +\n\t\top_encode_stateid_maxsz) * sizeof(__be32);\n}"
  },
  {
    "function_name": "nfsd4_layoutcommit_rsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1952-1957",
    "snippet": "static inline u32 nfsd4_layoutcommit_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size +\n\t\t1 /* locr_newsize */ +\n\t\t2 /* ns_size */) * sizeof(__be32);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define op_encode_hdr_size\t\t(2)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_hdr_size\t\t(2)\n\nstatic inline u32 nfsd4_layoutcommit_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size +\n\t\t1 /* locr_newsize */ +\n\t\t2 /* ns_size */) * sizeof(__be32);\n}"
  },
  {
    "function_name": "nfsd4_layoutget_rsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1943-1950",
    "snippet": "static inline u32 nfsd4_layoutget_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size +\n\t\t1 /* logr_return_on_close */ +\n\t\top_encode_stateid_maxsz +\n\t\t1 /* nr of layouts */ +\n\t\tMAX_LAYOUT_SIZE) * sizeof(__be32);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define MAX_LAYOUT_SIZE\t\t128",
      "#define op_encode_stateid_maxsz\t\t(XDR_QUADLEN(NFS4_STATEID_SIZE))",
      "#define op_encode_hdr_size\t\t(2)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define MAX_LAYOUT_SIZE\t\t128\n#define op_encode_stateid_maxsz\t\t(XDR_QUADLEN(NFS4_STATEID_SIZE))\n#define op_encode_hdr_size\t\t(2)\n\nstatic inline u32 nfsd4_layoutget_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size +\n\t\t1 /* logr_return_on_close */ +\n\t\top_encode_stateid_maxsz +\n\t\t1 /* nr of layouts */ +\n\t\tMAX_LAYOUT_SIZE) * sizeof(__be32);\n}"
  },
  {
    "function_name": "nfsd4_create_session_rsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1928-1935",
    "snippet": "static inline u32 nfsd4_create_session_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + \\\n\t\tXDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + /* sessionid */\\\n\t\t2 + /* csr_sequence, csr_flags */\\\n\t\top_encode_channel_attrs_maxsz + \\\n\t\top_encode_channel_attrs_maxsz) * sizeof(__be32);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define op_encode_channel_attrs_maxsz\t(6 + 1 + 1)",
      "#define op_encode_hdr_size\t\t(2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_channel_attrs_maxsz\t(6 + 1 + 1)\n#define op_encode_hdr_size\t\t(2)\n\nstatic inline u32 nfsd4_create_session_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + \\\n\t\tXDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + /* sessionid */\\\n\t\t2 + /* csr_sequence, csr_flags */\\\n\t\top_encode_channel_attrs_maxsz + \\\n\t\top_encode_channel_attrs_maxsz) * sizeof(__be32);\n}"
  },
  {
    "function_name": "nfsd4_bind_conn_to_session_rsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1921-1926",
    "snippet": "static inline u32 nfsd4_bind_conn_to_session_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + \\\n\t\tXDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + /* bctsr_sessid */\\\n\t\t2 /* bctsr_dir, use_conn_in_rdma_mode */) * sizeof(__be32);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define op_encode_hdr_size\t\t(2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_hdr_size\t\t(2)\n\nstatic inline u32 nfsd4_bind_conn_to_session_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + \\\n\t\tXDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + /* bctsr_sessid */\\\n\t\t2 /* bctsr_dir, use_conn_in_rdma_mode */) * sizeof(__be32);\n}"
  },
  {
    "function_name": "nfsd4_exchange_id_rsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1907-1919",
    "snippet": "static inline u32 nfsd4_exchange_id_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 2 + 1 + /* eir_clientid, eir_sequenceid */\\\n\t\t1 + 1 + /* eir_flags, spr_how */\\\n\t\t4 + /* spo_must_enforce & _allow with bitmap */\\\n\t\t2 + /*eir_server_owner.so_minor_id */\\\n\t\t/* eir_server_owner.so_major_id<> */\\\n\t\tXDR_QUADLEN(NFS4_OPAQUE_LIMIT) + 1 +\\\n\t\t/* eir_server_scope<> */\\\n\t\tXDR_QUADLEN(NFS4_OPAQUE_LIMIT) + 1 +\\\n\t\t1 + /* eir_server_impl_id array length */\\\n\t\t0 /* ignored eir_server_impl_id contents */) * sizeof(__be32);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define op_encode_hdr_size\t\t(2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "NFS4_OPAQUE_LIMIT"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "NFS4_OPAQUE_LIMIT"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_hdr_size\t\t(2)\n\nstatic inline u32 nfsd4_exchange_id_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 2 + 1 + /* eir_clientid, eir_sequenceid */\\\n\t\t1 + 1 + /* eir_flags, spr_how */\\\n\t\t4 + /* spo_must_enforce & _allow with bitmap */\\\n\t\t2 + /*eir_server_owner.so_minor_id */\\\n\t\t/* eir_server_owner.so_major_id<> */\\\n\t\tXDR_QUADLEN(NFS4_OPAQUE_LIMIT) + 1 +\\\n\t\t/* eir_server_scope<> */\\\n\t\tXDR_QUADLEN(NFS4_OPAQUE_LIMIT) + 1 +\\\n\t\t1 + /* eir_server_impl_id array length */\\\n\t\t0 /* ignored eir_server_impl_id contents */) * sizeof(__be32);\n}"
  },
  {
    "function_name": "nfsd4_write_rsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1902-1905",
    "snippet": "static inline u32 nfsd4_write_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 2 + op_encode_verifier_maxsz) * sizeof(__be32);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define op_encode_verifier_maxsz\t(XDR_QUADLEN(NFS4_VERIFIER_SIZE))",
      "#define op_encode_hdr_size\t\t(2)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_verifier_maxsz\t(XDR_QUADLEN(NFS4_VERIFIER_SIZE))\n#define op_encode_hdr_size\t\t(2)\n\nstatic inline u32 nfsd4_write_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 2 + op_encode_verifier_maxsz) * sizeof(__be32);\n}"
  },
  {
    "function_name": "nfsd4_setclientid_rsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1896-1900",
    "snippet": "static inline u32 nfsd4_setclientid_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 2 + XDR_QUADLEN(NFS4_VERIFIER_SIZE)) *\n\t\t\t\t\t\t\t\tsizeof(__be32);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define op_encode_hdr_size\t\t(2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_hdr_size\t\t(2)\n\nstatic inline u32 nfsd4_setclientid_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 2 + XDR_QUADLEN(NFS4_VERIFIER_SIZE)) *\n\t\t\t\t\t\t\t\tsizeof(__be32);\n}"
  },
  {
    "function_name": "nfsd4_setattr_rsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1891-1894",
    "snippet": "static inline u32 nfsd4_setattr_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + nfs4_fattr_bitmap_maxsz) * sizeof(__be32);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define nfs4_fattr_bitmap_maxsz\t\t(4)",
      "#define op_encode_hdr_size\t\t(2)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define nfs4_fattr_bitmap_maxsz\t\t(4)\n#define op_encode_hdr_size\t\t(2)\n\nstatic inline u32 nfsd4_setattr_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + nfs4_fattr_bitmap_maxsz) * sizeof(__be32);\n}"
  },
  {
    "function_name": "nfsd4_sequence_rsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1884-1889",
    "snippet": "static inline u32 nfsd4_sequence_rsize(struct svc_rqst *rqstp,\n\t\t\t\t       struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size\n\t\t+ XDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + 5) * sizeof(__be32);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define op_encode_hdr_size\t\t(2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_hdr_size\t\t(2)\n\nstatic inline u32 nfsd4_sequence_rsize(struct svc_rqst *rqstp,\n\t\t\t\t       struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size\n\t\t+ XDR_QUADLEN(NFS4_MAX_SESSIONID_LEN) + 5) * sizeof(__be32);\n}"
  },
  {
    "function_name": "nfsd4_rename_rsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1878-1882",
    "snippet": "static inline u32 nfsd4_rename_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_change_info_maxsz\n\t\t+ op_encode_change_info_maxsz) * sizeof(__be32);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define op_encode_change_info_maxsz\t(5)",
      "#define op_encode_hdr_size\t\t(2)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_change_info_maxsz\t(5)\n#define op_encode_hdr_size\t\t(2)\n\nstatic inline u32 nfsd4_rename_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_change_info_maxsz\n\t\t+ op_encode_change_info_maxsz) * sizeof(__be32);\n}"
  },
  {
    "function_name": "nfsd4_remove_rsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1872-1876",
    "snippet": "static inline u32 nfsd4_remove_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_change_info_maxsz)\n\t\t* sizeof(__be32);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define op_encode_change_info_maxsz\t(5)",
      "#define op_encode_hdr_size\t\t(2)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_change_info_maxsz\t(5)\n#define op_encode_hdr_size\t\t(2)\n\nstatic inline u32 nfsd4_remove_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_change_info_maxsz)\n\t\t* sizeof(__be32);\n}"
  },
  {
    "function_name": "nfsd4_readdir_rsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1861-1870",
    "snippet": "static inline u32 nfsd4_readdir_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tu32 maxcount = 0, rlen = 0;\n\n\tmaxcount = svc_max_payload(rqstp);\n\trlen = min(op->u.readdir.rd_maxcount, maxcount);\n\n\treturn (op_encode_hdr_size + op_encode_verifier_maxsz +\n\t\tXDR_QUADLEN(rlen)) * sizeof(__be32);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define op_encode_verifier_maxsz\t(XDR_QUADLEN(NFS4_VERIFIER_SIZE))",
      "#define op_encode_hdr_size\t\t(2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "rlen"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "op->u.readdir.rd_maxcount",
            "maxcount"
          ],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_minorversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "152-169",
          "snippet": "int nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_max_payload",
          "args": [
            "rqstp"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_verifier_maxsz\t(XDR_QUADLEN(NFS4_VERIFIER_SIZE))\n#define op_encode_hdr_size\t\t(2)\n\nstatic inline u32 nfsd4_readdir_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tu32 maxcount = 0, rlen = 0;\n\n\tmaxcount = svc_max_payload(rqstp);\n\trlen = min(op->u.readdir.rd_maxcount, maxcount);\n\n\treturn (op_encode_hdr_size + op_encode_verifier_maxsz +\n\t\tXDR_QUADLEN(rlen)) * sizeof(__be32);\n}"
  },
  {
    "function_name": "nfsd4_read_rsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1851-1859",
    "snippet": "static inline u32 nfsd4_read_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tu32 maxcount = 0, rlen = 0;\n\n\tmaxcount = svc_max_payload(rqstp);\n\trlen = min(op->u.read.rd_length, maxcount);\n\n\treturn (op_encode_hdr_size + 2 + XDR_QUADLEN(rlen)) * sizeof(__be32);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define op_encode_hdr_size\t\t(2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "rlen"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "op->u.read.rd_length",
            "maxcount"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_minorversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "152-169",
          "snippet": "int nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_max_payload",
          "args": [
            "rqstp"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_hdr_size\t\t(2)\n\nstatic inline u32 nfsd4_read_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tu32 maxcount = 0, rlen = 0;\n\n\tmaxcount = svc_max_payload(rqstp);\n\trlen = min(op->u.read.rd_length, maxcount);\n\n\treturn (op_encode_hdr_size + 2 + XDR_QUADLEN(rlen)) * sizeof(__be32);\n}"
  },
  {
    "function_name": "nfsd4_open_rsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1843-1849",
    "snippet": "static inline u32 nfsd4_open_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_stateid_maxsz\n\t\t+ op_encode_change_info_maxsz + 1\n\t\t+ nfs4_fattr_bitmap_maxsz\n\t\t+ op_encode_delegation_maxsz) * sizeof(__be32);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define op_encode_delegation_maxsz\t(1 + op_encode_stateid_maxsz + 1 + \\\n\t\t\t\t\t op_encode_ace_maxsz)",
      "#define nfs4_fattr_bitmap_maxsz\t\t(4)",
      "#define op_encode_change_info_maxsz\t(5)",
      "#define op_encode_stateid_maxsz\t\t(XDR_QUADLEN(NFS4_STATEID_SIZE))",
      "#define op_encode_hdr_size\t\t(2)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_delegation_maxsz\t(1 + op_encode_stateid_maxsz + 1 + \\\n\t\t\t\t\t op_encode_ace_maxsz)\n#define nfs4_fattr_bitmap_maxsz\t\t(4)\n#define op_encode_change_info_maxsz\t(5)\n#define op_encode_stateid_maxsz\t\t(XDR_QUADLEN(NFS4_STATEID_SIZE))\n#define op_encode_hdr_size\t\t(2)\n\nstatic inline u32 nfsd4_open_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_stateid_maxsz\n\t\t+ op_encode_change_info_maxsz + 1\n\t\t+ nfs4_fattr_bitmap_maxsz\n\t\t+ op_encode_delegation_maxsz) * sizeof(__be32);\n}"
  },
  {
    "function_name": "nfsd4_lock_rsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1837-1841",
    "snippet": "static inline u32 nfsd4_lock_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_lock_denied_maxsz)\n\t\t* sizeof(__be32);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define op_encode_lock_denied_maxsz\t(8 + op_encode_lockowner_maxsz)",
      "#define op_encode_hdr_size\t\t(2)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_lock_denied_maxsz\t(8 + op_encode_lockowner_maxsz)\n#define op_encode_hdr_size\t\t(2)\n\nstatic inline u32 nfsd4_lock_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_lock_denied_maxsz)\n\t\t* sizeof(__be32);\n}"
  },
  {
    "function_name": "nfsd4_link_rsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1831-1835",
    "snippet": "static inline u32 nfsd4_link_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_change_info_maxsz)\n\t\t* sizeof(__be32);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define op_encode_change_info_maxsz\t(5)",
      "#define op_encode_hdr_size\t\t(2)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_change_info_maxsz\t(5)\n#define op_encode_hdr_size\t\t(2)\n\nstatic inline u32 nfsd4_link_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_change_info_maxsz)\n\t\t* sizeof(__be32);\n}"
  },
  {
    "function_name": "nfsd4_getattr_rsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1793-1829",
    "snippet": "static inline u32 nfsd4_getattr_rsize(struct svc_rqst *rqstp,\n\t\t\t\t      struct nfsd4_op *op)\n{\n\tu32 *bmap = op->u.getattr.ga_bmval;\n\tu32 bmap0 = bmap[0], bmap1 = bmap[1], bmap2 = bmap[2];\n\tu32 ret = 0;\n\n\tif (bmap0 & FATTR4_WORD0_ACL)\n\t\treturn svc_max_payload(rqstp);\n\tif (bmap0 & FATTR4_WORD0_FS_LOCATIONS)\n\t\treturn svc_max_payload(rqstp);\n\n\tif (bmap1 & FATTR4_WORD1_OWNER) {\n\t\tret += IDMAP_NAMESZ + 4;\n\t\tbmap1 &= ~FATTR4_WORD1_OWNER;\n\t}\n\tif (bmap1 & FATTR4_WORD1_OWNER_GROUP) {\n\t\tret += IDMAP_NAMESZ + 4;\n\t\tbmap1 &= ~FATTR4_WORD1_OWNER_GROUP;\n\t}\n\tif (bmap0 & FATTR4_WORD0_FILEHANDLE) {\n\t\tret += NFS4_FHSIZE + 4;\n\t\tbmap0 &= ~FATTR4_WORD0_FILEHANDLE;\n\t}\n\tif (bmap2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tret += NFSD4_MAX_SEC_LABEL_LEN + 12;\n\t\tbmap2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t}\n\t/*\n\t * Largest of remaining attributes are 16 bytes (e.g.,\n\t * supported_attributes)\n\t */\n\tret += 16 * (hweight32(bmap0) + hweight32(bmap1) + hweight32(bmap2));\n\t/* bitmask, length */\n\tret += 20;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hweight32",
          "args": [
            "bmap2"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hweight32",
          "args": [
            "bmap1"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hweight32",
          "args": [
            "bmap0"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_max_payload",
          "args": [
            "rqstp"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_max_payload",
          "args": [
            "rqstp"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic inline u32 nfsd4_getattr_rsize(struct svc_rqst *rqstp,\n\t\t\t\t      struct nfsd4_op *op)\n{\n\tu32 *bmap = op->u.getattr.ga_bmval;\n\tu32 bmap0 = bmap[0], bmap1 = bmap[1], bmap2 = bmap[2];\n\tu32 ret = 0;\n\n\tif (bmap0 & FATTR4_WORD0_ACL)\n\t\treturn svc_max_payload(rqstp);\n\tif (bmap0 & FATTR4_WORD0_FS_LOCATIONS)\n\t\treturn svc_max_payload(rqstp);\n\n\tif (bmap1 & FATTR4_WORD1_OWNER) {\n\t\tret += IDMAP_NAMESZ + 4;\n\t\tbmap1 &= ~FATTR4_WORD1_OWNER;\n\t}\n\tif (bmap1 & FATTR4_WORD1_OWNER_GROUP) {\n\t\tret += IDMAP_NAMESZ + 4;\n\t\tbmap1 &= ~FATTR4_WORD1_OWNER_GROUP;\n\t}\n\tif (bmap0 & FATTR4_WORD0_FILEHANDLE) {\n\t\tret += NFS4_FHSIZE + 4;\n\t\tbmap0 &= ~FATTR4_WORD0_FILEHANDLE;\n\t}\n\tif (bmap2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tret += NFSD4_MAX_SEC_LABEL_LEN + 12;\n\t\tbmap2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t}\n\t/*\n\t * Largest of remaining attributes are 16 bytes (e.g.,\n\t * supported_attributes)\n\t */\n\tret += 16 * (hweight32(bmap0) + hweight32(bmap1) + hweight32(bmap2));\n\t/* bitmask, length */\n\tret += 20;\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd4_create_rsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1782-1786",
    "snippet": "static inline u32 nfsd4_create_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_change_info_maxsz\n\t\t+ nfs4_fattr_bitmap_maxsz) * sizeof(__be32);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define nfs4_fattr_bitmap_maxsz\t\t(4)",
      "#define op_encode_change_info_maxsz\t(5)",
      "#define op_encode_hdr_size\t\t(2)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define nfs4_fattr_bitmap_maxsz\t\t(4)\n#define op_encode_change_info_maxsz\t(5)\n#define op_encode_hdr_size\t\t(2)\n\nstatic inline u32 nfsd4_create_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_change_info_maxsz\n\t\t+ nfs4_fattr_bitmap_maxsz) * sizeof(__be32);\n}"
  },
  {
    "function_name": "nfsd4_commit_rsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1777-1780",
    "snippet": "static inline u32 nfsd4_commit_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_verifier_maxsz) * sizeof(__be32);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define op_encode_verifier_maxsz\t(XDR_QUADLEN(NFS4_VERIFIER_SIZE))",
      "#define op_encode_hdr_size\t\t(2)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_verifier_maxsz\t(XDR_QUADLEN(NFS4_VERIFIER_SIZE))\n#define op_encode_hdr_size\t\t(2)\n\nstatic inline u32 nfsd4_commit_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_verifier_maxsz) * sizeof(__be32);\n}"
  },
  {
    "function_name": "nfsd4_status_stateid_rsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1772-1775",
    "snippet": "static inline u32 nfsd4_status_stateid_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_stateid_maxsz)* sizeof(__be32);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define op_encode_stateid_maxsz\t\t(XDR_QUADLEN(NFS4_STATEID_SIZE))",
      "#define op_encode_hdr_size\t\t(2)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_stateid_maxsz\t\t(XDR_QUADLEN(NFS4_STATEID_SIZE))\n#define op_encode_hdr_size\t\t(2)\n\nstatic inline u32 nfsd4_status_stateid_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_stateid_maxsz)* sizeof(__be32);\n}"
  },
  {
    "function_name": "nfsd4_only_status_rsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1767-1770",
    "snippet": "static inline u32 nfsd4_only_status_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size) * sizeof(__be32);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define op_encode_hdr_size\t\t(2)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_hdr_size\t\t(2)\n\nstatic inline u32 nfsd4_only_status_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size) * sizeof(__be32);\n}"
  },
  {
    "function_name": "nfsd4_proc_compound",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1602-1747",
    "snippet": "static __be32\nnfsd4_proc_compound(struct svc_rqst *rqstp,\n\t\t    struct nfsd4_compoundargs *args,\n\t\t    struct nfsd4_compoundres *resp)\n{\n\tstruct nfsd4_op\t*op;\n\tstruct nfsd4_operation *opdesc;\n\tstruct nfsd4_compound_state *cstate = &resp->cstate;\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct svc_fh *save_fh = &cstate->save_fh;\n\t__be32\t\tstatus;\n\n\tsvcxdr_init_encode(rqstp, resp);\n\tresp->tagp = resp->xdr.p;\n\t/* reserve space for: taglen, tag, and opcnt */\n\txdr_reserve_space(&resp->xdr, 8 + args->taglen);\n\tresp->taglen = args->taglen;\n\tresp->tag = args->tag;\n\tresp->rqstp = rqstp;\n\tcstate->minorversion = args->minorversion;\n\tfh_init(current_fh, NFS4_FHSIZE);\n\tfh_init(save_fh, NFS4_FHSIZE);\n\t/*\n\t * Don't use the deferral mechanism for NFSv4; compounds make it\n\t * too hard to avoid non-idempotency problems.\n\t */\n\tclear_bit(RQ_USEDEFERRAL, &rqstp->rq_flags);\n\n\t/*\n\t * According to RFC3010, this takes precedence over all other errors.\n\t */\n\tstatus = nfserr_minor_vers_mismatch;\n\tif (nfsd_minorversion(args->minorversion, NFSD_TEST) <= 0)\n\t\tgoto out;\n\n\tstatus = nfs41_check_op_ordering(args);\n\tif (status) {\n\t\top = &args->ops[0];\n\t\top->status = status;\n\t\tgoto encode_op;\n\t}\n\n\twhile (!status && resp->opcnt < args->opcnt) {\n\t\top = &args->ops[resp->opcnt++];\n\n\t\tdprintk(\"nfsv4 compound op #%d/%d: %d (%s)\\n\",\n\t\t\tresp->opcnt, args->opcnt, op->opnum,\n\t\t\tnfsd4_op_name(op->opnum));\n\t\t/*\n\t\t * The XDR decode routines may have pre-set op->status;\n\t\t * for example, if there is a miscellaneous XDR error\n\t\t * it will be set to nfserr_bad_xdr.\n\t\t */\n\t\tif (op->status) {\n\t\t\tif (op->opnum == OP_OPEN)\n\t\t\t\top->status = nfsd4_open_omfg(rqstp, cstate, op);\n\t\t\tgoto encode_op;\n\t\t}\n\n\t\topdesc = OPDESC(op);\n\n\t\tif (!current_fh->fh_dentry) {\n\t\t\tif (!(opdesc->op_flags & ALLOWED_WITHOUT_FH)) {\n\t\t\t\top->status = nfserr_nofilehandle;\n\t\t\t\tgoto encode_op;\n\t\t\t}\n\t\t} else if (current_fh->fh_export->ex_fslocs.migrated &&\n\t\t\t  !(opdesc->op_flags & ALLOWED_ON_ABSENT_FS)) {\n\t\t\top->status = nfserr_moved;\n\t\t\tgoto encode_op;\n\t\t}\n\n\t\tfh_clear_wcc(current_fh);\n\n\t\t/* If op is non-idempotent */\n\t\tif (opdesc->op_flags & OP_MODIFIES_SOMETHING) {\n\t\t\t/*\n\t\t\t * Don't execute this op if we couldn't encode a\n\t\t\t * succesful reply:\n\t\t\t */\n\t\t\tu32 plen = opdesc->op_rsize_bop(rqstp, op);\n\t\t\t/*\n\t\t\t * Plus if there's another operation, make sure\n\t\t\t * we'll have space to at least encode an error:\n\t\t\t */\n\t\t\tif (resp->opcnt < args->opcnt)\n\t\t\t\tplen += COMPOUND_ERR_SLACK_SPACE;\n\t\t\top->status = nfsd4_check_resp_size(resp, plen);\n\t\t}\n\n\t\tif (op->status)\n\t\t\tgoto encode_op;\n\n\t\tif (opdesc->op_get_currentstateid)\n\t\t\topdesc->op_get_currentstateid(cstate, &op->u);\n\t\top->status = opdesc->op_func(rqstp, cstate, &op->u);\n\n\t\tif (!op->status) {\n\t\t\tif (opdesc->op_set_currentstateid)\n\t\t\t\topdesc->op_set_currentstateid(cstate, &op->u);\n\n\t\t\tif (opdesc->op_flags & OP_CLEAR_STATEID)\n\t\t\t\tclear_current_stateid(cstate);\n\n\t\t\tif (need_wrongsec_check(rqstp))\n\t\t\t\top->status = check_nfsd_access(current_fh->fh_export, rqstp);\n\t\t}\n\nencode_op:\n\t\t/* Only from SEQUENCE */\n\t\tif (cstate->status == nfserr_replay_cache) {\n\t\t\tdprintk(\"%s NFS4.1 replay from cache\\n\", __func__);\n\t\t\tstatus = op->status;\n\t\t\tgoto out;\n\t\t}\n\t\tif (op->status == nfserr_replay_me) {\n\t\t\top->replay = &cstate->replay_owner->so_replay;\n\t\t\tnfsd4_encode_replay(&resp->xdr, op);\n\t\t\tstatus = op->status = op->replay->rp_status;\n\t\t} else {\n\t\t\tnfsd4_encode_operation(resp, op);\n\t\t\tstatus = op->status;\n\t\t}\n\n\t\tdprintk(\"nfsv4 compound op %p opcnt %d #%d: %d: status %d\\n\",\n\t\t\targs->ops, args->opcnt, resp->opcnt, op->opnum,\n\t\t\tbe32_to_cpu(status));\n\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\t/* XXX Ugh, we need to get rid of this kind of special case: */\n\t\tif (op->opnum == OP_READ && op->u.read.rd_filp)\n\t\t\tfput(op->u.read.rd_filp);\n\n\t\tnfsd4_increment_op_stats(op->opnum);\n\t}\n\n\tcstate->status = status;\n\tfh_put(current_fh);\n\tfh_put(save_fh);\n\tBUG_ON(cstate->replay_owner);\nout:\n\t/* Reset deferral mechanism for RPC deferrals */\n\tset_bit(RQ_USEDEFERRAL, &rqstp->rq_flags);\n\tdprintk(\"nfsv4 compound returned %d\\n\", ntohl(status));\n\treturn status;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *nfsd4_op_name(unsigned opnum);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsv4 compound returned %d\\n\"",
            "ntohl(status)"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "status"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "RQ_USEDEFERRAL",
            "&rqstp->rq_flags"
          ],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cstate->replay_owner"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "save_fh"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "625-645",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_increment_op_stats",
          "args": [
            "op->opnum"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_increment_op_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "1445-1449",
          "snippet": "static inline void nfsd4_increment_op_stats(u32 opnum)\n{\n\tif (opnum >= FIRST_NFS4_OP && opnum <= LAST_NFS4_OP)\n\t\tnfsdstats.nfs4_opcount[opnum]++;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *nfsd4_op_name(unsigned opnum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic const char *nfsd4_op_name(unsigned opnum);\n\nstatic inline void nfsd4_increment_op_stats(u32 opnum)\n{\n\tif (opnum >= FIRST_NFS4_OP && opnum <= LAST_NFS4_OP)\n\t\tnfsdstats.nfs4_opcount[opnum]++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "op->u.read.rd_filp"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cstate_clear_replay",
          "args": [
            "cstate"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cstate_clear_replay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3138-3147",
          "snippet": "void nfsd4_cstate_clear_replay(struct nfsd4_compound_state *cstate)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (so != NULL) {\n\t\tcstate->replay_owner = NULL;\n\t\tmutex_unlock(&so->so_replay.rp_mutex);\n\t\tnfs4_put_stateowner(so);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid nfsd4_cstate_clear_replay(struct nfsd4_compound_state *cstate)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (so != NULL) {\n\t\tcstate->replay_owner = NULL;\n\t\tmutex_unlock(&so->so_replay.rp_mutex);\n\t\tnfs4_put_stateowner(so);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsv4 compound op %p opcnt %d #%d: %d: status %d\\n\"",
            "args->ops",
            "args->opcnt",
            "resp->opcnt",
            "op->opnum",
            "be32_to_cpu(status)"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "status"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_operation",
          "args": [
            "resp",
            "op"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_operation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "4272-4337",
          "snippet": "void\nnfsd4_encode_operation(struct nfsd4_compoundres *resp, struct nfsd4_op *op)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct nfs4_stateowner *so = resp->cstate.replay_owner;\n\tstruct svc_rqst *rqstp = resp->rqstp;\n\tint post_err_offset;\n\tnfsd4_enc encoder;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 8);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\t*p++ = cpu_to_be32(op->opnum);\n\tpost_err_offset = xdr->buf->len;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\tgoto status;\n\tBUG_ON(op->opnum < 0 || op->opnum >= ARRAY_SIZE(nfsd4_enc_ops) ||\n\t       !nfsd4_enc_ops[op->opnum]);\n\tencoder = nfsd4_enc_ops[op->opnum];\n\top->status = encoder(resp, op->status, &op->u);\n\txdr_commit_encode(xdr);\n\n\t/* nfsd4_check_resp_size guarantees enough room for error status */\n\tif (!op->status) {\n\t\tint space_needed = 0;\n\t\tif (!nfsd4_last_compound_op(rqstp))\n\t\t\tspace_needed = COMPOUND_ERR_SLACK_SPACE;\n\t\top->status = nfsd4_check_resp_size(resp, space_needed);\n\t}\n\tif (op->status == nfserr_resource && nfsd4_has_session(&resp->cstate)) {\n\t\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\t\tif (slot->sl_flags & NFSD4_SLOT_CACHETHIS)\n\t\t\top->status = nfserr_rep_too_big_to_cache;\n\t\telse\n\t\t\top->status = nfserr_rep_too_big;\n\t}\n\tif (op->status == nfserr_resource ||\n\t    op->status == nfserr_rep_too_big ||\n\t    op->status == nfserr_rep_too_big_to_cache) {\n\t\t/*\n\t\t * The operation may have already been encoded or\n\t\t * partially encoded.  No op returns anything additional\n\t\t * in the case of one of these three errors, so we can\n\t\t * just truncate back to after the status.  But it's a\n\t\t * bug if we had to do this on a non-idempotent op:\n\t\t */\n\t\twarn_on_nonidempotent_op(op);\n\t\txdr_truncate_encode(xdr, post_err_offset);\n\t}\n\tif (so) {\n\t\tint len = xdr->buf->len - post_err_offset;\n\n\t\tso->so_replay.rp_status = op->status;\n\t\tso->so_replay.rp_buflen = len;\n\t\tread_bytes_from_xdr_buf(xdr->buf, post_err_offset,\n\t\t\t\t\t\tso->so_replay.rp_buf, len);\n\t}\nstatus:\n\t/* Note that op->status is already in network byte order: */\n\twrite_bytes_to_xdr_buf(xdr->buf, post_err_offset - 4, &op->status, 4);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nfsd4_enc nfsd4_enc_ops[] = {\n\t[OP_ACCESS]\t\t= (nfsd4_enc)nfsd4_encode_access,\n\t[OP_CLOSE]\t\t= (nfsd4_enc)nfsd4_encode_close,\n\t[OP_COMMIT]\t\t= (nfsd4_enc)nfsd4_encode_commit,\n\t[OP_CREATE]\t\t= (nfsd4_enc)nfsd4_encode_create,\n\t[OP_DELEGPURGE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DELEGRETURN]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GETATTR]\t\t= (nfsd4_enc)nfsd4_encode_getattr,\n\t[OP_GETFH]\t\t= (nfsd4_enc)nfsd4_encode_getfh,\n\t[OP_LINK]\t\t= (nfsd4_enc)nfsd4_encode_link,\n\t[OP_LOCK]\t\t= (nfsd4_enc)nfsd4_encode_lock,\n\t[OP_LOCKT]\t\t= (nfsd4_enc)nfsd4_encode_lockt,\n\t[OP_LOCKU]\t\t= (nfsd4_enc)nfsd4_encode_locku,\n\t[OP_LOOKUP]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LOOKUPP]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_NVERIFY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OPEN]\t\t= (nfsd4_enc)nfsd4_encode_open,\n\t[OP_OPENATTR]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OPEN_CONFIRM]\t= (nfsd4_enc)nfsd4_encode_open_confirm,\n\t[OP_OPEN_DOWNGRADE]\t= (nfsd4_enc)nfsd4_encode_open_downgrade,\n\t[OP_PUTFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_PUTPUBFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_PUTROOTFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_READ]\t\t= (nfsd4_enc)nfsd4_encode_read,\n\t[OP_READDIR]\t\t= (nfsd4_enc)nfsd4_encode_readdir,\n\t[OP_READLINK]\t\t= (nfsd4_enc)nfsd4_encode_readlink,\n\t[OP_REMOVE]\t\t= (nfsd4_enc)nfsd4_encode_remove,\n\t[OP_RENAME]\t\t= (nfsd4_enc)nfsd4_encode_rename,\n\t[OP_RENEW]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_RESTOREFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SAVEFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SECINFO]\t\t= (nfsd4_enc)nfsd4_encode_secinfo,\n\t[OP_SETATTR]\t\t= (nfsd4_enc)nfsd4_encode_setattr,\n\t[OP_SETCLIENTID]\t= (nfsd4_enc)nfsd4_encode_setclientid,\n\t[OP_SETCLIENTID_CONFIRM] = (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_VERIFY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_WRITE]\t\t= (nfsd4_enc)nfsd4_encode_write,\n\t[OP_RELEASE_LOCKOWNER]\t= (nfsd4_enc)nfsd4_encode_noop,\n\n\t/* NFSv4.1 operations */\n\t[OP_BACKCHANNEL_CTL]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_BIND_CONN_TO_SESSION] = (nfsd4_enc)nfsd4_encode_bind_conn_to_session,\n\t[OP_EXCHANGE_ID]\t= (nfsd4_enc)nfsd4_encode_exchange_id,\n\t[OP_CREATE_SESSION]\t= (nfsd4_enc)nfsd4_encode_create_session,\n\t[OP_DESTROY_SESSION]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_FREE_STATEID]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GET_DIR_DELEGATION]\t= (nfsd4_enc)nfsd4_encode_noop,\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO]\t= (nfsd4_enc)nfsd4_encode_getdeviceinfo,\n\t[OP_GETDEVICELIST]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_enc)nfsd4_encode_layoutcommit,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_enc)nfsd4_encode_layoutget,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_enc)nfsd4_encode_layoutreturn,\n#else\n\t[OP_GETDEVICEINFO]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GETDEVICELIST]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_enc)nfsd4_encode_noop,\n#endif\n\t[OP_SECINFO_NO_NAME]\t= (nfsd4_enc)nfsd4_encode_secinfo_no_name,\n\t[OP_SEQUENCE]\t\t= (nfsd4_enc)nfsd4_encode_sequence,\n\t[OP_SET_SSV]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_TEST_STATEID]\t= (nfsd4_enc)nfsd4_encode_test_stateid,\n\t[OP_WANT_DELEGATION]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DESTROY_CLIENTID]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_RECLAIM_COMPLETE]\t= (nfsd4_enc)nfsd4_encode_noop,\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_COPY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_COPY_NOTIFY]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DEALLOCATE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_IO_ADVISE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTERROR]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTSTATS]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OFFLOAD_CANCEL]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OFFLOAD_STATUS]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_READ_PLUS]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SEEK]\t\t= (nfsd4_enc)nfsd4_encode_seek,\n\t[OP_WRITE_SAME]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic nfsd4_enc nfsd4_enc_ops[] = {\n\t[OP_ACCESS]\t\t= (nfsd4_enc)nfsd4_encode_access,\n\t[OP_CLOSE]\t\t= (nfsd4_enc)nfsd4_encode_close,\n\t[OP_COMMIT]\t\t= (nfsd4_enc)nfsd4_encode_commit,\n\t[OP_CREATE]\t\t= (nfsd4_enc)nfsd4_encode_create,\n\t[OP_DELEGPURGE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DELEGRETURN]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GETATTR]\t\t= (nfsd4_enc)nfsd4_encode_getattr,\n\t[OP_GETFH]\t\t= (nfsd4_enc)nfsd4_encode_getfh,\n\t[OP_LINK]\t\t= (nfsd4_enc)nfsd4_encode_link,\n\t[OP_LOCK]\t\t= (nfsd4_enc)nfsd4_encode_lock,\n\t[OP_LOCKT]\t\t= (nfsd4_enc)nfsd4_encode_lockt,\n\t[OP_LOCKU]\t\t= (nfsd4_enc)nfsd4_encode_locku,\n\t[OP_LOOKUP]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LOOKUPP]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_NVERIFY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OPEN]\t\t= (nfsd4_enc)nfsd4_encode_open,\n\t[OP_OPENATTR]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OPEN_CONFIRM]\t= (nfsd4_enc)nfsd4_encode_open_confirm,\n\t[OP_OPEN_DOWNGRADE]\t= (nfsd4_enc)nfsd4_encode_open_downgrade,\n\t[OP_PUTFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_PUTPUBFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_PUTROOTFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_READ]\t\t= (nfsd4_enc)nfsd4_encode_read,\n\t[OP_READDIR]\t\t= (nfsd4_enc)nfsd4_encode_readdir,\n\t[OP_READLINK]\t\t= (nfsd4_enc)nfsd4_encode_readlink,\n\t[OP_REMOVE]\t\t= (nfsd4_enc)nfsd4_encode_remove,\n\t[OP_RENAME]\t\t= (nfsd4_enc)nfsd4_encode_rename,\n\t[OP_RENEW]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_RESTOREFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SAVEFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SECINFO]\t\t= (nfsd4_enc)nfsd4_encode_secinfo,\n\t[OP_SETATTR]\t\t= (nfsd4_enc)nfsd4_encode_setattr,\n\t[OP_SETCLIENTID]\t= (nfsd4_enc)nfsd4_encode_setclientid,\n\t[OP_SETCLIENTID_CONFIRM] = (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_VERIFY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_WRITE]\t\t= (nfsd4_enc)nfsd4_encode_write,\n\t[OP_RELEASE_LOCKOWNER]\t= (nfsd4_enc)nfsd4_encode_noop,\n\n\t/* NFSv4.1 operations */\n\t[OP_BACKCHANNEL_CTL]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_BIND_CONN_TO_SESSION] = (nfsd4_enc)nfsd4_encode_bind_conn_to_session,\n\t[OP_EXCHANGE_ID]\t= (nfsd4_enc)nfsd4_encode_exchange_id,\n\t[OP_CREATE_SESSION]\t= (nfsd4_enc)nfsd4_encode_create_session,\n\t[OP_DESTROY_SESSION]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_FREE_STATEID]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GET_DIR_DELEGATION]\t= (nfsd4_enc)nfsd4_encode_noop,\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO]\t= (nfsd4_enc)nfsd4_encode_getdeviceinfo,\n\t[OP_GETDEVICELIST]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_enc)nfsd4_encode_layoutcommit,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_enc)nfsd4_encode_layoutget,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_enc)nfsd4_encode_layoutreturn,\n#else\n\t[OP_GETDEVICEINFO]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GETDEVICELIST]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_enc)nfsd4_encode_noop,\n#endif\n\t[OP_SECINFO_NO_NAME]\t= (nfsd4_enc)nfsd4_encode_secinfo_no_name,\n\t[OP_SEQUENCE]\t\t= (nfsd4_enc)nfsd4_encode_sequence,\n\t[OP_SET_SSV]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_TEST_STATEID]\t= (nfsd4_enc)nfsd4_encode_test_stateid,\n\t[OP_WANT_DELEGATION]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DESTROY_CLIENTID]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_RECLAIM_COMPLETE]\t= (nfsd4_enc)nfsd4_encode_noop,\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_COPY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_COPY_NOTIFY]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DEALLOCATE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_IO_ADVISE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTERROR]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTSTATS]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OFFLOAD_CANCEL]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OFFLOAD_STATUS]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_READ_PLUS]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SEEK]\t\t= (nfsd4_enc)nfsd4_encode_seek,\n\t[OP_WRITE_SAME]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n};\n\nvoid\nnfsd4_encode_operation(struct nfsd4_compoundres *resp, struct nfsd4_op *op)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct nfs4_stateowner *so = resp->cstate.replay_owner;\n\tstruct svc_rqst *rqstp = resp->rqstp;\n\tint post_err_offset;\n\tnfsd4_enc encoder;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 8);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\t*p++ = cpu_to_be32(op->opnum);\n\tpost_err_offset = xdr->buf->len;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\tgoto status;\n\tBUG_ON(op->opnum < 0 || op->opnum >= ARRAY_SIZE(nfsd4_enc_ops) ||\n\t       !nfsd4_enc_ops[op->opnum]);\n\tencoder = nfsd4_enc_ops[op->opnum];\n\top->status = encoder(resp, op->status, &op->u);\n\txdr_commit_encode(xdr);\n\n\t/* nfsd4_check_resp_size guarantees enough room for error status */\n\tif (!op->status) {\n\t\tint space_needed = 0;\n\t\tif (!nfsd4_last_compound_op(rqstp))\n\t\t\tspace_needed = COMPOUND_ERR_SLACK_SPACE;\n\t\top->status = nfsd4_check_resp_size(resp, space_needed);\n\t}\n\tif (op->status == nfserr_resource && nfsd4_has_session(&resp->cstate)) {\n\t\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\t\tif (slot->sl_flags & NFSD4_SLOT_CACHETHIS)\n\t\t\top->status = nfserr_rep_too_big_to_cache;\n\t\telse\n\t\t\top->status = nfserr_rep_too_big;\n\t}\n\tif (op->status == nfserr_resource ||\n\t    op->status == nfserr_rep_too_big ||\n\t    op->status == nfserr_rep_too_big_to_cache) {\n\t\t/*\n\t\t * The operation may have already been encoded or\n\t\t * partially encoded.  No op returns anything additional\n\t\t * in the case of one of these three errors, so we can\n\t\t * just truncate back to after the status.  But it's a\n\t\t * bug if we had to do this on a non-idempotent op:\n\t\t */\n\t\twarn_on_nonidempotent_op(op);\n\t\txdr_truncate_encode(xdr, post_err_offset);\n\t}\n\tif (so) {\n\t\tint len = xdr->buf->len - post_err_offset;\n\n\t\tso->so_replay.rp_status = op->status;\n\t\tso->so_replay.rp_buflen = len;\n\t\tread_bytes_from_xdr_buf(xdr->buf, post_err_offset,\n\t\t\t\t\t\tso->so_replay.rp_buf, len);\n\t}\nstatus:\n\t/* Note that op->status is already in network byte order: */\n\twrite_bytes_to_xdr_buf(xdr->buf, post_err_offset - 4, &op->status, 4);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_replay",
          "args": [
            "&resp->xdr",
            "op"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_replay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "4345-4362",
          "snippet": "void\nnfsd4_encode_replay(struct xdr_stream *xdr, struct nfsd4_op *op)\n{\n\t__be32 *p;\n\tstruct nfs4_replay *rp = op->replay;\n\n\tBUG_ON(!rp);\n\n\tp = xdr_reserve_space(xdr, 8 + rp->rp_buflen);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\t*p++ = cpu_to_be32(op->opnum);\n\t*p++ = rp->rp_status;  /* already xdr'ed */\n\n\tp = xdr_encode_opaque_fixed(p, rp->rp_buf, rp->rp_buflen);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nvoid\nnfsd4_encode_replay(struct xdr_stream *xdr, struct nfsd4_op *op)\n{\n\t__be32 *p;\n\tstruct nfs4_replay *rp = op->replay;\n\n\tBUG_ON(!rp);\n\n\tp = xdr_reserve_space(xdr, 8 + rp->rp_buflen);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\t*p++ = cpu_to_be32(op->opnum);\n\t*p++ = rp->rp_status;  /* already xdr'ed */\n\n\tp = xdr_encode_opaque_fixed(p, rp->rp_buf, rp->rp_buflen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s NFS4.1 replay from cache\\n\"",
            "__func__"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_nfsd_access",
          "args": [
            "current_fh->fh_export",
            "rqstp"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "check_nfsd_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "939-959",
          "snippet": "__be32 check_nfsd_access(struct svc_export *exp, struct svc_rqst *rqstp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\n\t/* legacy gss-only clients are always OK: */\n\tif (exp->ex_client == rqstp->rq_gssclient)\n\t\treturn 0;\n\t/* ip-address based client; check sec= export option: */\n\tfor (f = exp->ex_flavors; f < end; f++) {\n\t\tif (f->pseudoflavor == rqstp->rq_cred.cr_flavor)\n\t\t\treturn 0;\n\t}\n\t/* defaults in absence of sec= options: */\n\tif (exp->ex_nflavors == 0) {\n\t\tif (rqstp->rq_cred.cr_flavor == RPC_AUTH_NULL ||\n\t\t    rqstp->rq_cred.cr_flavor == RPC_AUTH_UNIX)\n\t\t\treturn 0;\n\t}\n\treturn nfserr_wrongsec;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\n__be32 check_nfsd_access(struct svc_export *exp, struct svc_rqst *rqstp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\n\t/* legacy gss-only clients are always OK: */\n\tif (exp->ex_client == rqstp->rq_gssclient)\n\t\treturn 0;\n\t/* ip-address based client; check sec= export option: */\n\tfor (f = exp->ex_flavors; f < end; f++) {\n\t\tif (f->pseudoflavor == rqstp->rq_cred.cr_flavor)\n\t\t\treturn 0;\n\t}\n\t/* defaults in absence of sec= options: */\n\tif (exp->ex_nflavors == 0) {\n\t\tif (rqstp->rq_cred.cr_flavor == RPC_AUTH_NULL ||\n\t\t    rqstp->rq_cred.cr_flavor == RPC_AUTH_UNIX)\n\t\t\treturn 0;\n\t}\n\treturn nfserr_wrongsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_wrongsec_check",
          "args": [
            "rqstp"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "need_wrongsec_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "1546-1578",
          "snippet": "static bool need_wrongsec_check(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\tstruct nfsd4_op *this = &argp->ops[resp->opcnt - 1];\n\tstruct nfsd4_op *next = &argp->ops[resp->opcnt];\n\tstruct nfsd4_operation *thisd;\n\tstruct nfsd4_operation *nextd;\n\n\tthisd = OPDESC(this);\n\t/*\n\t * Most ops check wronsec on our own; only the putfh-like ops\n\t * have special rules.\n\t */\n\tif (!(thisd->op_flags & OP_IS_PUTFH_LIKE))\n\t\treturn false;\n\t/*\n\t * rfc 5661 2.6.3.1.1.6: don't bother erroring out a\n\t * put-filehandle operation if we're not going to use the\n\t * result:\n\t */\n\tif (argp->opcnt == resp->opcnt)\n\t\treturn false;\n\tif (next->opnum == OP_ILLEGAL)\n\t\treturn false;\n\tnextd = OPDESC(next);\n\t/*\n\t * Rest of 2.6.3.1.1: certain operations will return WRONGSEC\n\t * errors themselves as necessary; others should check for them\n\t * now:\n\t */\n\treturn !(nextd->op_flags & OP_HANDLES_WRONGSEC);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *nfsd4_op_name(unsigned opnum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic const char *nfsd4_op_name(unsigned opnum);\n\nstatic bool need_wrongsec_check(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\tstruct nfsd4_op *this = &argp->ops[resp->opcnt - 1];\n\tstruct nfsd4_op *next = &argp->ops[resp->opcnt];\n\tstruct nfsd4_operation *thisd;\n\tstruct nfsd4_operation *nextd;\n\n\tthisd = OPDESC(this);\n\t/*\n\t * Most ops check wronsec on our own; only the putfh-like ops\n\t * have special rules.\n\t */\n\tif (!(thisd->op_flags & OP_IS_PUTFH_LIKE))\n\t\treturn false;\n\t/*\n\t * rfc 5661 2.6.3.1.1.6: don't bother erroring out a\n\t * put-filehandle operation if we're not going to use the\n\t * result:\n\t */\n\tif (argp->opcnt == resp->opcnt)\n\t\treturn false;\n\tif (next->opnum == OP_ILLEGAL)\n\t\treturn false;\n\tnextd = OPDESC(next);\n\t/*\n\t * Rest of 2.6.3.1.1: certain operations will return WRONGSEC\n\t * errors themselves as necessary; others should check for them\n\t * now:\n\t */\n\treturn !(nextd->op_flags & OP_HANDLES_WRONGSEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_current_stateid",
          "args": [
            "cstate"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "clear_current_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "6521-6525",
          "snippet": "void\nclear_current_stateid(struct nfsd4_compound_state *cstate)\n{\n\tCLEAR_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nclear_current_stateid(struct nfsd4_compound_state *cstate)\n{\n\tCLEAR_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "opdesc->op_set_currentstateid",
          "args": [
            "cstate",
            "&op->u"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opdesc->op_func",
          "args": [
            "rqstp",
            "cstate",
            "&op->u"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opdesc->op_get_currentstateid",
          "args": [
            "cstate",
            "&op->u"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_check_resp_size",
          "args": [
            "resp",
            "plen"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_check_resp_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "4256-4270",
          "snippet": "__be32 nfsd4_check_resp_size(struct nfsd4_compoundres *resp, u32 respsize)\n{\n\tstruct xdr_buf *buf = &resp->rqstp->rq_res;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\tif (buf->len + respsize <= buf->buflen)\n\t\treturn nfs_ok;\n\tif (!nfsd4_has_session(&resp->cstate))\n\t\treturn nfserr_resource;\n\tif (slot->sl_flags & NFSD4_SLOT_CACHETHIS) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn nfserr_rep_too_big_to_cache;\n\t}\n\treturn nfserr_rep_too_big;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n__be32 nfsd4_check_resp_size(struct nfsd4_compoundres *resp, u32 respsize)\n{\n\tstruct xdr_buf *buf = &resp->rqstp->rq_res;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\tif (buf->len + respsize <= buf->buflen)\n\t\treturn nfs_ok;\n\tif (!nfsd4_has_session(&resp->cstate))\n\t\treturn nfserr_resource;\n\tif (slot->sl_flags & NFSD4_SLOT_CACHETHIS) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn nfserr_rep_too_big_to_cache;\n\t}\n\treturn nfserr_rep_too_big;\n}"
        }
      },
      {
        "call_info": {
          "callee": "opdesc->op_rsize_bop",
          "args": [
            "rqstp",
            "op"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_clear_wcc",
          "args": [
            "current_fh"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "fh_clear_wcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "213-218",
          "snippet": "static inline void\nfh_clear_wcc(struct svc_fh *fhp)\n{\n\tfhp->fh_post_saved = 0;\n\tfhp->fh_pre_saved = 0;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline void\nfh_clear_wcc(struct svc_fh *fhp)\n{\n\tfhp->fh_post_saved = 0;\n\tfhp->fh_pre_saved = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OPDESC",
          "args": [
            "op"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "OPDESC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "1534-1537",
          "snippet": "static inline struct nfsd4_operation *OPDESC(struct nfsd4_op *op)\n{\n\treturn &nfsd4_ops[op->opnum];\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfsd4_operation nfsd4_ops[];",
            "static const char *nfsd4_op_name(unsigned opnum);",
            "static struct nfsd4_operation nfsd4_ops[] = {\n\t[OP_ACCESS] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_access,\n\t\t.op_name = \"OP_ACCESS\",\n\t},\n\t[OP_CLOSE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_close,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLOSE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_closestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_closestateid,\n\t},\n\t[OP_COMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_commit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_commit_rsize,\n\t},\n\t[OP_CREATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_CREATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_rsize,\n\t},\n\t[OP_DELEGRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_delegreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DELEGRETURN\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_delegreturnstateid,\n\t},\n\t[OP_GETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getattr,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS,\n\t\t.op_rsize_bop = nfsd4_getattr_rsize,\n\t\t.op_name = \"OP_GETATTR\",\n\t},\n\t[OP_GETFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getfh,\n\t\t.op_name = \"OP_GETFH\",\n\t},\n\t[OP_LINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_link,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS | OP_MODIFIES_SOMETHING\n\t\t\t\t| OP_CACHEME,\n\t\t.op_name = \"OP_LINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_link_rsize,\n\t},\n\t[OP_LOCK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lock,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_lockstateid,\n\t},\n\t[OP_LOCKT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lockt,\n\t\t.op_name = \"OP_LOCKT\",\n\t},\n\t[OP_LOCKU] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_locku,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCKU\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_lockustateid,\n\t},\n\t[OP_LOOKUP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookup,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUP\",\n\t},\n\t[OP_LOOKUPP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookupp,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUPP\",\n\t},\n\t[OP_NVERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_nverify,\n\t\t.op_name = \"OP_NVERIFY\",\n\t},\n\t[OP_OPEN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_open_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_openstateid,\n\t},\n\t[OP_OPEN_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_confirm,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t},\n\t[OP_OPEN_DOWNGRADE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_downgrade,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_DOWNGRADE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_opendowngradestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_opendowngradestateid,\n\t},\n\t[OP_PUTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTPUBFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTPUBFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTROOTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTROOTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_READ] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_read,\n\t\t.op_name = \"OP_READ\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_read_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_readstateid,\n\t},\n\t[OP_READDIR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readdir,\n\t\t.op_name = \"OP_READDIR\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readdir_rsize,\n\t},\n\t[OP_READLINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readlink,\n\t\t.op_name = \"OP_READLINK\",\n\t},\n\t[OP_REMOVE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_remove,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_remove_rsize,\n\t},\n\t[OP_RENAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_rename,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_RENAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_rename_rsize,\n\t},\n\t[OP_RENEW] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_renew,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RENEW\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\n\t},\n\t[OP_RESTOREFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_restorefh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RESTOREFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SAVEFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_savefh,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_SAVEFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO\",\n\t},\n\t[OP_SETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setattr,\n\t\t.op_name = \"OP_SETATTR\",\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setattr_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_setattrstateid,\n\t},\n\t[OP_SETCLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setclientid_rsize,\n\t},\n\t[OP_SETCLIENTID_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid_confirm,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_VERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_verify,\n\t\t.op_name = \"OP_VERIFY\",\n\t},\n\t[OP_WRITE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_write,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_WRITE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_writestateid,\n\t},\n\t[OP_RELEASE_LOCKOWNER] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_release_lockowner,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RELEASE_LOCKOWNER\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\n\t/* NFSv4.1 operations */\n\t[OP_EXCHANGE_ID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_exchange_id,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_EXCHANGE_ID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_exchange_id_rsize,\n\t},\n\t[OP_BACKCHANNEL_CTL] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_backchannel_ctl,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BACKCHANNEL_CTL\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_BIND_CONN_TO_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_bind_conn_to_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BIND_CONN_TO_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_bind_conn_to_session_rsize,\n\t},\n\t[OP_CREATE_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CREATE_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_session_rsize,\n\t},\n\t[OP_DESTROY_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SEQUENCE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_sequence,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,\n\t\t.op_name = \"OP_SEQUENCE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_sequence_rsize,\n\t},\n\t[OP_DESTROY_CLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_clientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_CLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_RECLAIM_COMPLETE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_reclaim_complete,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RECLAIM_COMPLETE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO_NO_NAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo_no_name,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO_NO_NAME\",\n\t},\n\t[OP_TEST_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_test_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_TEST_STATEID\",\n\t},\n\t[OP_FREE_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_free_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_FREE_STATEID\",\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_freestateid,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getdeviceinfo,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_GETDEVICEINFO\",\n\t},\n\t[OP_LAYOUTGET] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutget,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTGET\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutget_rsize,\n\t},\n\t[OP_LAYOUTCOMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutcommit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTCOMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutcommit_rsize,\n\t},\n\t[OP_LAYOUTRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTRETURN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutreturn_rsize,\n\t},\n#endif /* CONFIG_NFSD_PNFS */\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_allocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_ALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_DEALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_deallocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_DEALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_SEEK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_seek,\n\t\t.op_name = \"OP_SEEK\",\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic struct nfsd4_operation nfsd4_ops[];\nstatic const char *nfsd4_op_name(unsigned opnum);\nstatic struct nfsd4_operation nfsd4_ops[] = {\n\t[OP_ACCESS] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_access,\n\t\t.op_name = \"OP_ACCESS\",\n\t},\n\t[OP_CLOSE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_close,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLOSE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_closestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_closestateid,\n\t},\n\t[OP_COMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_commit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_commit_rsize,\n\t},\n\t[OP_CREATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_CREATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_rsize,\n\t},\n\t[OP_DELEGRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_delegreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DELEGRETURN\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_delegreturnstateid,\n\t},\n\t[OP_GETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getattr,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS,\n\t\t.op_rsize_bop = nfsd4_getattr_rsize,\n\t\t.op_name = \"OP_GETATTR\",\n\t},\n\t[OP_GETFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getfh,\n\t\t.op_name = \"OP_GETFH\",\n\t},\n\t[OP_LINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_link,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS | OP_MODIFIES_SOMETHING\n\t\t\t\t| OP_CACHEME,\n\t\t.op_name = \"OP_LINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_link_rsize,\n\t},\n\t[OP_LOCK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lock,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_lockstateid,\n\t},\n\t[OP_LOCKT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lockt,\n\t\t.op_name = \"OP_LOCKT\",\n\t},\n\t[OP_LOCKU] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_locku,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCKU\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_lockustateid,\n\t},\n\t[OP_LOOKUP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookup,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUP\",\n\t},\n\t[OP_LOOKUPP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookupp,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUPP\",\n\t},\n\t[OP_NVERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_nverify,\n\t\t.op_name = \"OP_NVERIFY\",\n\t},\n\t[OP_OPEN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_open_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_openstateid,\n\t},\n\t[OP_OPEN_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_confirm,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t},\n\t[OP_OPEN_DOWNGRADE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_downgrade,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_DOWNGRADE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_opendowngradestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_opendowngradestateid,\n\t},\n\t[OP_PUTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTPUBFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTPUBFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTROOTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTROOTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_READ] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_read,\n\t\t.op_name = \"OP_READ\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_read_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_readstateid,\n\t},\n\t[OP_READDIR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readdir,\n\t\t.op_name = \"OP_READDIR\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readdir_rsize,\n\t},\n\t[OP_READLINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readlink,\n\t\t.op_name = \"OP_READLINK\",\n\t},\n\t[OP_REMOVE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_remove,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_remove_rsize,\n\t},\n\t[OP_RENAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_rename,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_RENAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_rename_rsize,\n\t},\n\t[OP_RENEW] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_renew,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RENEW\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\n\t},\n\t[OP_RESTOREFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_restorefh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RESTOREFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SAVEFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_savefh,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_SAVEFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO\",\n\t},\n\t[OP_SETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setattr,\n\t\t.op_name = \"OP_SETATTR\",\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setattr_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_setattrstateid,\n\t},\n\t[OP_SETCLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setclientid_rsize,\n\t},\n\t[OP_SETCLIENTID_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid_confirm,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_VERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_verify,\n\t\t.op_name = \"OP_VERIFY\",\n\t},\n\t[OP_WRITE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_write,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_WRITE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_writestateid,\n\t},\n\t[OP_RELEASE_LOCKOWNER] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_release_lockowner,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RELEASE_LOCKOWNER\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\n\t/* NFSv4.1 operations */\n\t[OP_EXCHANGE_ID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_exchange_id,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_EXCHANGE_ID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_exchange_id_rsize,\n\t},\n\t[OP_BACKCHANNEL_CTL] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_backchannel_ctl,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BACKCHANNEL_CTL\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_BIND_CONN_TO_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_bind_conn_to_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BIND_CONN_TO_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_bind_conn_to_session_rsize,\n\t},\n\t[OP_CREATE_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CREATE_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_session_rsize,\n\t},\n\t[OP_DESTROY_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SEQUENCE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_sequence,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,\n\t\t.op_name = \"OP_SEQUENCE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_sequence_rsize,\n\t},\n\t[OP_DESTROY_CLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_clientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_CLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_RECLAIM_COMPLETE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_reclaim_complete,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RECLAIM_COMPLETE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO_NO_NAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo_no_name,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO_NO_NAME\",\n\t},\n\t[OP_TEST_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_test_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_TEST_STATEID\",\n\t},\n\t[OP_FREE_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_free_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_FREE_STATEID\",\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_freestateid,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getdeviceinfo,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_GETDEVICEINFO\",\n\t},\n\t[OP_LAYOUTGET] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutget,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTGET\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutget_rsize,\n\t},\n\t[OP_LAYOUTCOMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutcommit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTCOMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutcommit_rsize,\n\t},\n\t[OP_LAYOUTRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTRETURN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutreturn_rsize,\n\t},\n#endif /* CONFIG_NFSD_PNFS */\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_allocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_ALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_DEALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_deallocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_DEALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_SEEK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_seek,\n\t\t.op_name = \"OP_SEEK\",\n\t},\n};\n\nstatic inline struct nfsd4_operation *OPDESC(struct nfsd4_op *op)\n{\n\treturn &nfsd4_ops[op->opnum];\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_open_omfg",
          "args": [
            "rqstp",
            "cstate",
            "op"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_open_omfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "484-494",
          "snippet": "static __be32 nfsd4_open_omfg(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_op *op)\n{\n\tstruct nfsd4_open *open = (struct nfsd4_open *)&op->u;\n\n\tif (!seqid_mutating_err(ntohl(op->status)))\n\t\treturn op->status;\n\tif (nfsd4_has_session(cstate))\n\t\treturn op->status;\n\topen->op_xdr_error = op->status;\n\treturn nfsd4_open(rqstp, cstate, open);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_open_omfg(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_op *op)\n{\n\tstruct nfsd4_open *open = (struct nfsd4_open *)&op->u;\n\n\tif (!seqid_mutating_err(ntohl(op->status)))\n\t\treturn op->status;\n\tif (nfsd4_has_session(cstate))\n\t\treturn op->status;\n\topen->op_xdr_error = op->status;\n\treturn nfsd4_open(rqstp, cstate, open);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsv4 compound op #%d/%d: %d (%s)\\n\"",
            "resp->opcnt",
            "args->opcnt",
            "op->opnum",
            "nfsd4_op_name(op->opnum)"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_op_name",
          "args": [
            "op->opnum"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "2320-2325",
          "snippet": "static const char *nfsd4_op_name(unsigned opnum)\n{\n\tif (opnum < ARRAY_SIZE(nfsd4_ops))\n\t\treturn nfsd4_ops[opnum].op_name;\n\treturn \"unknown_operation\";\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfsd4_operation nfsd4_ops[];",
            "static const char *nfsd4_op_name(unsigned opnum);",
            "static struct nfsd4_operation nfsd4_ops[] = {\n\t[OP_ACCESS] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_access,\n\t\t.op_name = \"OP_ACCESS\",\n\t},\n\t[OP_CLOSE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_close,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLOSE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_closestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_closestateid,\n\t},\n\t[OP_COMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_commit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_commit_rsize,\n\t},\n\t[OP_CREATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_CREATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_rsize,\n\t},\n\t[OP_DELEGRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_delegreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DELEGRETURN\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_delegreturnstateid,\n\t},\n\t[OP_GETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getattr,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS,\n\t\t.op_rsize_bop = nfsd4_getattr_rsize,\n\t\t.op_name = \"OP_GETATTR\",\n\t},\n\t[OP_GETFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getfh,\n\t\t.op_name = \"OP_GETFH\",\n\t},\n\t[OP_LINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_link,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS | OP_MODIFIES_SOMETHING\n\t\t\t\t| OP_CACHEME,\n\t\t.op_name = \"OP_LINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_link_rsize,\n\t},\n\t[OP_LOCK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lock,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_lockstateid,\n\t},\n\t[OP_LOCKT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lockt,\n\t\t.op_name = \"OP_LOCKT\",\n\t},\n\t[OP_LOCKU] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_locku,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCKU\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_lockustateid,\n\t},\n\t[OP_LOOKUP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookup,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUP\",\n\t},\n\t[OP_LOOKUPP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookupp,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUPP\",\n\t},\n\t[OP_NVERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_nverify,\n\t\t.op_name = \"OP_NVERIFY\",\n\t},\n\t[OP_OPEN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_open_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_openstateid,\n\t},\n\t[OP_OPEN_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_confirm,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t},\n\t[OP_OPEN_DOWNGRADE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_downgrade,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_DOWNGRADE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_opendowngradestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_opendowngradestateid,\n\t},\n\t[OP_PUTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTPUBFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTPUBFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTROOTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTROOTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_READ] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_read,\n\t\t.op_name = \"OP_READ\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_read_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_readstateid,\n\t},\n\t[OP_READDIR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readdir,\n\t\t.op_name = \"OP_READDIR\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readdir_rsize,\n\t},\n\t[OP_READLINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readlink,\n\t\t.op_name = \"OP_READLINK\",\n\t},\n\t[OP_REMOVE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_remove,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_remove_rsize,\n\t},\n\t[OP_RENAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_rename,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_RENAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_rename_rsize,\n\t},\n\t[OP_RENEW] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_renew,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RENEW\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\n\t},\n\t[OP_RESTOREFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_restorefh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RESTOREFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SAVEFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_savefh,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_SAVEFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO\",\n\t},\n\t[OP_SETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setattr,\n\t\t.op_name = \"OP_SETATTR\",\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setattr_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_setattrstateid,\n\t},\n\t[OP_SETCLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setclientid_rsize,\n\t},\n\t[OP_SETCLIENTID_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid_confirm,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_VERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_verify,\n\t\t.op_name = \"OP_VERIFY\",\n\t},\n\t[OP_WRITE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_write,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_WRITE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_writestateid,\n\t},\n\t[OP_RELEASE_LOCKOWNER] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_release_lockowner,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RELEASE_LOCKOWNER\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\n\t/* NFSv4.1 operations */\n\t[OP_EXCHANGE_ID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_exchange_id,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_EXCHANGE_ID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_exchange_id_rsize,\n\t},\n\t[OP_BACKCHANNEL_CTL] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_backchannel_ctl,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BACKCHANNEL_CTL\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_BIND_CONN_TO_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_bind_conn_to_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BIND_CONN_TO_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_bind_conn_to_session_rsize,\n\t},\n\t[OP_CREATE_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CREATE_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_session_rsize,\n\t},\n\t[OP_DESTROY_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SEQUENCE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_sequence,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,\n\t\t.op_name = \"OP_SEQUENCE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_sequence_rsize,\n\t},\n\t[OP_DESTROY_CLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_clientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_CLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_RECLAIM_COMPLETE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_reclaim_complete,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RECLAIM_COMPLETE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO_NO_NAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo_no_name,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO_NO_NAME\",\n\t},\n\t[OP_TEST_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_test_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_TEST_STATEID\",\n\t},\n\t[OP_FREE_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_free_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_FREE_STATEID\",\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_freestateid,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getdeviceinfo,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_GETDEVICEINFO\",\n\t},\n\t[OP_LAYOUTGET] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutget,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTGET\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutget_rsize,\n\t},\n\t[OP_LAYOUTCOMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutcommit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTCOMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutcommit_rsize,\n\t},\n\t[OP_LAYOUTRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTRETURN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutreturn_rsize,\n\t},\n#endif /* CONFIG_NFSD_PNFS */\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_allocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_ALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_DEALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_deallocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_DEALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_SEEK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_seek,\n\t\t.op_name = \"OP_SEEK\",\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic struct nfsd4_operation nfsd4_ops[];\nstatic const char *nfsd4_op_name(unsigned opnum);\nstatic struct nfsd4_operation nfsd4_ops[] = {\n\t[OP_ACCESS] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_access,\n\t\t.op_name = \"OP_ACCESS\",\n\t},\n\t[OP_CLOSE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_close,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLOSE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_closestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_closestateid,\n\t},\n\t[OP_COMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_commit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_commit_rsize,\n\t},\n\t[OP_CREATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_CREATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_rsize,\n\t},\n\t[OP_DELEGRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_delegreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DELEGRETURN\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_delegreturnstateid,\n\t},\n\t[OP_GETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getattr,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS,\n\t\t.op_rsize_bop = nfsd4_getattr_rsize,\n\t\t.op_name = \"OP_GETATTR\",\n\t},\n\t[OP_GETFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getfh,\n\t\t.op_name = \"OP_GETFH\",\n\t},\n\t[OP_LINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_link,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS | OP_MODIFIES_SOMETHING\n\t\t\t\t| OP_CACHEME,\n\t\t.op_name = \"OP_LINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_link_rsize,\n\t},\n\t[OP_LOCK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lock,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_lockstateid,\n\t},\n\t[OP_LOCKT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lockt,\n\t\t.op_name = \"OP_LOCKT\",\n\t},\n\t[OP_LOCKU] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_locku,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCKU\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_lockustateid,\n\t},\n\t[OP_LOOKUP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookup,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUP\",\n\t},\n\t[OP_LOOKUPP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookupp,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUPP\",\n\t},\n\t[OP_NVERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_nverify,\n\t\t.op_name = \"OP_NVERIFY\",\n\t},\n\t[OP_OPEN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_open_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_openstateid,\n\t},\n\t[OP_OPEN_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_confirm,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t},\n\t[OP_OPEN_DOWNGRADE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_downgrade,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_DOWNGRADE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_opendowngradestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_opendowngradestateid,\n\t},\n\t[OP_PUTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTPUBFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTPUBFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTROOTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTROOTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_READ] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_read,\n\t\t.op_name = \"OP_READ\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_read_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_readstateid,\n\t},\n\t[OP_READDIR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readdir,\n\t\t.op_name = \"OP_READDIR\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readdir_rsize,\n\t},\n\t[OP_READLINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readlink,\n\t\t.op_name = \"OP_READLINK\",\n\t},\n\t[OP_REMOVE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_remove,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_remove_rsize,\n\t},\n\t[OP_RENAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_rename,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_RENAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_rename_rsize,\n\t},\n\t[OP_RENEW] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_renew,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RENEW\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\n\t},\n\t[OP_RESTOREFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_restorefh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RESTOREFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SAVEFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_savefh,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_SAVEFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO\",\n\t},\n\t[OP_SETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setattr,\n\t\t.op_name = \"OP_SETATTR\",\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setattr_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_setattrstateid,\n\t},\n\t[OP_SETCLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setclientid_rsize,\n\t},\n\t[OP_SETCLIENTID_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid_confirm,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_VERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_verify,\n\t\t.op_name = \"OP_VERIFY\",\n\t},\n\t[OP_WRITE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_write,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_WRITE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_writestateid,\n\t},\n\t[OP_RELEASE_LOCKOWNER] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_release_lockowner,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RELEASE_LOCKOWNER\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\n\t/* NFSv4.1 operations */\n\t[OP_EXCHANGE_ID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_exchange_id,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_EXCHANGE_ID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_exchange_id_rsize,\n\t},\n\t[OP_BACKCHANNEL_CTL] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_backchannel_ctl,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BACKCHANNEL_CTL\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_BIND_CONN_TO_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_bind_conn_to_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BIND_CONN_TO_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_bind_conn_to_session_rsize,\n\t},\n\t[OP_CREATE_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CREATE_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_session_rsize,\n\t},\n\t[OP_DESTROY_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SEQUENCE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_sequence,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,\n\t\t.op_name = \"OP_SEQUENCE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_sequence_rsize,\n\t},\n\t[OP_DESTROY_CLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_clientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_CLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_RECLAIM_COMPLETE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_reclaim_complete,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RECLAIM_COMPLETE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO_NO_NAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo_no_name,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO_NO_NAME\",\n\t},\n\t[OP_TEST_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_test_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_TEST_STATEID\",\n\t},\n\t[OP_FREE_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_free_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_FREE_STATEID\",\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_freestateid,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getdeviceinfo,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_GETDEVICEINFO\",\n\t},\n\t[OP_LAYOUTGET] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutget,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTGET\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutget_rsize,\n\t},\n\t[OP_LAYOUTCOMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutcommit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTCOMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutcommit_rsize,\n\t},\n\t[OP_LAYOUTRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTRETURN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutreturn_rsize,\n\t},\n#endif /* CONFIG_NFSD_PNFS */\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_allocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_ALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_DEALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_deallocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_DEALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_SEEK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_seek,\n\t\t.op_name = \"OP_SEEK\",\n\t},\n};\n\nstatic const char *nfsd4_op_name(unsigned opnum)\n{\n\tif (opnum < ARRAY_SIZE(nfsd4_ops))\n\t\treturn nfsd4_ops[opnum].op_name;\n\treturn \"unknown_operation\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs41_check_op_ordering",
          "args": [
            "args"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "nfs41_check_op_ordering",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "1513-1532",
          "snippet": "static __be32 nfs41_check_op_ordering(struct nfsd4_compoundargs *args)\n{\n\tstruct nfsd4_op *op = &args->ops[0];\n\n\t/* These ordering requirements don't apply to NFSv4.0: */\n\tif (args->minorversion == 0)\n\t\treturn nfs_ok;\n\t/* This is weird, but OK, not our problem: */\n\tif (args->opcnt == 0)\n\t\treturn nfs_ok;\n\tif (op->status == nfserr_op_illegal)\n\t\treturn nfs_ok;\n\tif (!(nfsd4_ops[op->opnum].op_flags & ALLOWED_AS_FIRST_OP))\n\t\treturn nfserr_op_not_in_session;\n\tif (op->opnum == OP_SEQUENCE)\n\t\treturn nfs_ok;\n\tif (args->opcnt != 1)\n\t\treturn nfserr_not_only_op;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfsd4_operation nfsd4_ops[];",
            "static const char *nfsd4_op_name(unsigned opnum);",
            "static struct nfsd4_operation nfsd4_ops[] = {\n\t[OP_ACCESS] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_access,\n\t\t.op_name = \"OP_ACCESS\",\n\t},\n\t[OP_CLOSE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_close,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLOSE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_closestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_closestateid,\n\t},\n\t[OP_COMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_commit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_commit_rsize,\n\t},\n\t[OP_CREATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_CREATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_rsize,\n\t},\n\t[OP_DELEGRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_delegreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DELEGRETURN\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_delegreturnstateid,\n\t},\n\t[OP_GETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getattr,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS,\n\t\t.op_rsize_bop = nfsd4_getattr_rsize,\n\t\t.op_name = \"OP_GETATTR\",\n\t},\n\t[OP_GETFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getfh,\n\t\t.op_name = \"OP_GETFH\",\n\t},\n\t[OP_LINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_link,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS | OP_MODIFIES_SOMETHING\n\t\t\t\t| OP_CACHEME,\n\t\t.op_name = \"OP_LINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_link_rsize,\n\t},\n\t[OP_LOCK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lock,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_lockstateid,\n\t},\n\t[OP_LOCKT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lockt,\n\t\t.op_name = \"OP_LOCKT\",\n\t},\n\t[OP_LOCKU] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_locku,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCKU\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_lockustateid,\n\t},\n\t[OP_LOOKUP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookup,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUP\",\n\t},\n\t[OP_LOOKUPP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookupp,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUPP\",\n\t},\n\t[OP_NVERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_nverify,\n\t\t.op_name = \"OP_NVERIFY\",\n\t},\n\t[OP_OPEN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_open_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_openstateid,\n\t},\n\t[OP_OPEN_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_confirm,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t},\n\t[OP_OPEN_DOWNGRADE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_downgrade,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_DOWNGRADE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_opendowngradestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_opendowngradestateid,\n\t},\n\t[OP_PUTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTPUBFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTPUBFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTROOTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTROOTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_READ] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_read,\n\t\t.op_name = \"OP_READ\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_read_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_readstateid,\n\t},\n\t[OP_READDIR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readdir,\n\t\t.op_name = \"OP_READDIR\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readdir_rsize,\n\t},\n\t[OP_READLINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readlink,\n\t\t.op_name = \"OP_READLINK\",\n\t},\n\t[OP_REMOVE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_remove,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_remove_rsize,\n\t},\n\t[OP_RENAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_rename,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_RENAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_rename_rsize,\n\t},\n\t[OP_RENEW] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_renew,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RENEW\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\n\t},\n\t[OP_RESTOREFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_restorefh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RESTOREFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SAVEFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_savefh,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_SAVEFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO\",\n\t},\n\t[OP_SETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setattr,\n\t\t.op_name = \"OP_SETATTR\",\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setattr_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_setattrstateid,\n\t},\n\t[OP_SETCLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setclientid_rsize,\n\t},\n\t[OP_SETCLIENTID_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid_confirm,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_VERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_verify,\n\t\t.op_name = \"OP_VERIFY\",\n\t},\n\t[OP_WRITE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_write,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_WRITE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_writestateid,\n\t},\n\t[OP_RELEASE_LOCKOWNER] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_release_lockowner,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RELEASE_LOCKOWNER\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\n\t/* NFSv4.1 operations */\n\t[OP_EXCHANGE_ID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_exchange_id,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_EXCHANGE_ID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_exchange_id_rsize,\n\t},\n\t[OP_BACKCHANNEL_CTL] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_backchannel_ctl,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BACKCHANNEL_CTL\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_BIND_CONN_TO_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_bind_conn_to_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BIND_CONN_TO_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_bind_conn_to_session_rsize,\n\t},\n\t[OP_CREATE_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CREATE_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_session_rsize,\n\t},\n\t[OP_DESTROY_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SEQUENCE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_sequence,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,\n\t\t.op_name = \"OP_SEQUENCE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_sequence_rsize,\n\t},\n\t[OP_DESTROY_CLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_clientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_CLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_RECLAIM_COMPLETE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_reclaim_complete,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RECLAIM_COMPLETE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO_NO_NAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo_no_name,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO_NO_NAME\",\n\t},\n\t[OP_TEST_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_test_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_TEST_STATEID\",\n\t},\n\t[OP_FREE_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_free_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_FREE_STATEID\",\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_freestateid,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getdeviceinfo,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_GETDEVICEINFO\",\n\t},\n\t[OP_LAYOUTGET] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutget,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTGET\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutget_rsize,\n\t},\n\t[OP_LAYOUTCOMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutcommit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTCOMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutcommit_rsize,\n\t},\n\t[OP_LAYOUTRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTRETURN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutreturn_rsize,\n\t},\n#endif /* CONFIG_NFSD_PNFS */\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_allocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_ALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_DEALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_deallocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_DEALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_SEEK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_seek,\n\t\t.op_name = \"OP_SEEK\",\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic struct nfsd4_operation nfsd4_ops[];\nstatic const char *nfsd4_op_name(unsigned opnum);\nstatic struct nfsd4_operation nfsd4_ops[] = {\n\t[OP_ACCESS] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_access,\n\t\t.op_name = \"OP_ACCESS\",\n\t},\n\t[OP_CLOSE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_close,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLOSE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_closestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_closestateid,\n\t},\n\t[OP_COMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_commit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_commit_rsize,\n\t},\n\t[OP_CREATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_CREATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_rsize,\n\t},\n\t[OP_DELEGRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_delegreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DELEGRETURN\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_delegreturnstateid,\n\t},\n\t[OP_GETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getattr,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS,\n\t\t.op_rsize_bop = nfsd4_getattr_rsize,\n\t\t.op_name = \"OP_GETATTR\",\n\t},\n\t[OP_GETFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getfh,\n\t\t.op_name = \"OP_GETFH\",\n\t},\n\t[OP_LINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_link,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS | OP_MODIFIES_SOMETHING\n\t\t\t\t| OP_CACHEME,\n\t\t.op_name = \"OP_LINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_link_rsize,\n\t},\n\t[OP_LOCK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lock,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_lockstateid,\n\t},\n\t[OP_LOCKT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lockt,\n\t\t.op_name = \"OP_LOCKT\",\n\t},\n\t[OP_LOCKU] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_locku,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCKU\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_lockustateid,\n\t},\n\t[OP_LOOKUP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookup,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUP\",\n\t},\n\t[OP_LOOKUPP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookupp,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUPP\",\n\t},\n\t[OP_NVERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_nverify,\n\t\t.op_name = \"OP_NVERIFY\",\n\t},\n\t[OP_OPEN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_open_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_openstateid,\n\t},\n\t[OP_OPEN_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_confirm,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t},\n\t[OP_OPEN_DOWNGRADE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_downgrade,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_DOWNGRADE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_opendowngradestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_opendowngradestateid,\n\t},\n\t[OP_PUTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTPUBFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTPUBFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTROOTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTROOTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_READ] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_read,\n\t\t.op_name = \"OP_READ\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_read_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_readstateid,\n\t},\n\t[OP_READDIR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readdir,\n\t\t.op_name = \"OP_READDIR\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readdir_rsize,\n\t},\n\t[OP_READLINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readlink,\n\t\t.op_name = \"OP_READLINK\",\n\t},\n\t[OP_REMOVE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_remove,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_remove_rsize,\n\t},\n\t[OP_RENAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_rename,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_RENAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_rename_rsize,\n\t},\n\t[OP_RENEW] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_renew,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RENEW\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\n\t},\n\t[OP_RESTOREFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_restorefh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RESTOREFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SAVEFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_savefh,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_SAVEFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO\",\n\t},\n\t[OP_SETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setattr,\n\t\t.op_name = \"OP_SETATTR\",\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setattr_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_setattrstateid,\n\t},\n\t[OP_SETCLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setclientid_rsize,\n\t},\n\t[OP_SETCLIENTID_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid_confirm,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_VERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_verify,\n\t\t.op_name = \"OP_VERIFY\",\n\t},\n\t[OP_WRITE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_write,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_WRITE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_writestateid,\n\t},\n\t[OP_RELEASE_LOCKOWNER] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_release_lockowner,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RELEASE_LOCKOWNER\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\n\t/* NFSv4.1 operations */\n\t[OP_EXCHANGE_ID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_exchange_id,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_EXCHANGE_ID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_exchange_id_rsize,\n\t},\n\t[OP_BACKCHANNEL_CTL] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_backchannel_ctl,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BACKCHANNEL_CTL\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_BIND_CONN_TO_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_bind_conn_to_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BIND_CONN_TO_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_bind_conn_to_session_rsize,\n\t},\n\t[OP_CREATE_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CREATE_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_session_rsize,\n\t},\n\t[OP_DESTROY_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SEQUENCE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_sequence,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,\n\t\t.op_name = \"OP_SEQUENCE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_sequence_rsize,\n\t},\n\t[OP_DESTROY_CLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_clientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_CLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_RECLAIM_COMPLETE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_reclaim_complete,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RECLAIM_COMPLETE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO_NO_NAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo_no_name,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO_NO_NAME\",\n\t},\n\t[OP_TEST_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_test_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_TEST_STATEID\",\n\t},\n\t[OP_FREE_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_free_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_FREE_STATEID\",\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_freestateid,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getdeviceinfo,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_GETDEVICEINFO\",\n\t},\n\t[OP_LAYOUTGET] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutget,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTGET\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutget_rsize,\n\t},\n\t[OP_LAYOUTCOMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutcommit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTCOMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutcommit_rsize,\n\t},\n\t[OP_LAYOUTRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTRETURN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutreturn_rsize,\n\t},\n#endif /* CONFIG_NFSD_PNFS */\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_allocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_ALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_DEALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_deallocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_DEALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_SEEK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_seek,\n\t\t.op_name = \"OP_SEEK\",\n\t},\n};\n\nstatic __be32 nfs41_check_op_ordering(struct nfsd4_compoundargs *args)\n{\n\tstruct nfsd4_op *op = &args->ops[0];\n\n\t/* These ordering requirements don't apply to NFSv4.0: */\n\tif (args->minorversion == 0)\n\t\treturn nfs_ok;\n\t/* This is weird, but OK, not our problem: */\n\tif (args->opcnt == 0)\n\t\treturn nfs_ok;\n\tif (op->status == nfserr_op_illegal)\n\t\treturn nfs_ok;\n\tif (!(nfsd4_ops[op->opnum].op_flags & ALLOWED_AS_FIRST_OP))\n\t\treturn nfserr_op_not_in_session;\n\tif (op->opnum == OP_SEQUENCE)\n\t\treturn nfs_ok;\n\tif (args->opcnt != 1)\n\t\treturn nfserr_not_only_op;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_minorversion",
          "args": [
            "args->minorversion",
            "NFSD_TEST"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_minorversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "152-169",
          "snippet": "int nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "RQ_USEDEFERRAL",
            "&rqstp->rq_flags"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_init",
          "args": [
            "save_fh",
            "NFS4_FHSIZE"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "fh_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "182-188",
          "snippet": "static __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "&resp->xdr",
            "8 + args->taglen"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcxdr_init_encode",
          "args": [
            "rqstp",
            "resp"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "svcxdr_init_encode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "1580-1597",
          "snippet": "static void svcxdr_init_encode(struct svc_rqst *rqstp,\n\t\t\t       struct nfsd4_compoundres *resp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct xdr_buf *buf = &rqstp->rq_res;\n\tstruct kvec *head = buf->head;\n\n\txdr->buf = buf;\n\txdr->iov = head;\n\txdr->p   = head->iov_base + head->iov_len;\n\txdr->end = head->iov_base + PAGE_SIZE - rqstp->rq_auth_slack;\n\t/* Tail and page_len should be zero at this point: */\n\tbuf->len = buf->head[0].iov_len;\n\txdr->scratch.iov_len = 0;\n\txdr->page_ptr = buf->pages - 1;\n\tbuf->buflen = PAGE_SIZE * (1 + rqstp->rq_page_end - buf->pages)\n\t\t- rqstp->rq_auth_slack;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic void svcxdr_init_encode(struct svc_rqst *rqstp,\n\t\t\t       struct nfsd4_compoundres *resp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct xdr_buf *buf = &rqstp->rq_res;\n\tstruct kvec *head = buf->head;\n\n\txdr->buf = buf;\n\txdr->iov = head;\n\txdr->p   = head->iov_base + head->iov_len;\n\txdr->end = head->iov_base + PAGE_SIZE - rqstp->rq_auth_slack;\n\t/* Tail and page_len should be zero at this point: */\n\tbuf->len = buf->head[0].iov_len;\n\txdr->scratch.iov_len = 0;\n\txdr->page_ptr = buf->pages - 1;\n\tbuf->buflen = PAGE_SIZE * (1 + rqstp->rq_page_end - buf->pages)\n\t\t- rqstp->rq_auth_slack;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic const char *nfsd4_op_name(unsigned opnum);\n\nstatic __be32\nnfsd4_proc_compound(struct svc_rqst *rqstp,\n\t\t    struct nfsd4_compoundargs *args,\n\t\t    struct nfsd4_compoundres *resp)\n{\n\tstruct nfsd4_op\t*op;\n\tstruct nfsd4_operation *opdesc;\n\tstruct nfsd4_compound_state *cstate = &resp->cstate;\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct svc_fh *save_fh = &cstate->save_fh;\n\t__be32\t\tstatus;\n\n\tsvcxdr_init_encode(rqstp, resp);\n\tresp->tagp = resp->xdr.p;\n\t/* reserve space for: taglen, tag, and opcnt */\n\txdr_reserve_space(&resp->xdr, 8 + args->taglen);\n\tresp->taglen = args->taglen;\n\tresp->tag = args->tag;\n\tresp->rqstp = rqstp;\n\tcstate->minorversion = args->minorversion;\n\tfh_init(current_fh, NFS4_FHSIZE);\n\tfh_init(save_fh, NFS4_FHSIZE);\n\t/*\n\t * Don't use the deferral mechanism for NFSv4; compounds make it\n\t * too hard to avoid non-idempotency problems.\n\t */\n\tclear_bit(RQ_USEDEFERRAL, &rqstp->rq_flags);\n\n\t/*\n\t * According to RFC3010, this takes precedence over all other errors.\n\t */\n\tstatus = nfserr_minor_vers_mismatch;\n\tif (nfsd_minorversion(args->minorversion, NFSD_TEST) <= 0)\n\t\tgoto out;\n\n\tstatus = nfs41_check_op_ordering(args);\n\tif (status) {\n\t\top = &args->ops[0];\n\t\top->status = status;\n\t\tgoto encode_op;\n\t}\n\n\twhile (!status && resp->opcnt < args->opcnt) {\n\t\top = &args->ops[resp->opcnt++];\n\n\t\tdprintk(\"nfsv4 compound op #%d/%d: %d (%s)\\n\",\n\t\t\tresp->opcnt, args->opcnt, op->opnum,\n\t\t\tnfsd4_op_name(op->opnum));\n\t\t/*\n\t\t * The XDR decode routines may have pre-set op->status;\n\t\t * for example, if there is a miscellaneous XDR error\n\t\t * it will be set to nfserr_bad_xdr.\n\t\t */\n\t\tif (op->status) {\n\t\t\tif (op->opnum == OP_OPEN)\n\t\t\t\top->status = nfsd4_open_omfg(rqstp, cstate, op);\n\t\t\tgoto encode_op;\n\t\t}\n\n\t\topdesc = OPDESC(op);\n\n\t\tif (!current_fh->fh_dentry) {\n\t\t\tif (!(opdesc->op_flags & ALLOWED_WITHOUT_FH)) {\n\t\t\t\top->status = nfserr_nofilehandle;\n\t\t\t\tgoto encode_op;\n\t\t\t}\n\t\t} else if (current_fh->fh_export->ex_fslocs.migrated &&\n\t\t\t  !(opdesc->op_flags & ALLOWED_ON_ABSENT_FS)) {\n\t\t\top->status = nfserr_moved;\n\t\t\tgoto encode_op;\n\t\t}\n\n\t\tfh_clear_wcc(current_fh);\n\n\t\t/* If op is non-idempotent */\n\t\tif (opdesc->op_flags & OP_MODIFIES_SOMETHING) {\n\t\t\t/*\n\t\t\t * Don't execute this op if we couldn't encode a\n\t\t\t * succesful reply:\n\t\t\t */\n\t\t\tu32 plen = opdesc->op_rsize_bop(rqstp, op);\n\t\t\t/*\n\t\t\t * Plus if there's another operation, make sure\n\t\t\t * we'll have space to at least encode an error:\n\t\t\t */\n\t\t\tif (resp->opcnt < args->opcnt)\n\t\t\t\tplen += COMPOUND_ERR_SLACK_SPACE;\n\t\t\top->status = nfsd4_check_resp_size(resp, plen);\n\t\t}\n\n\t\tif (op->status)\n\t\t\tgoto encode_op;\n\n\t\tif (opdesc->op_get_currentstateid)\n\t\t\topdesc->op_get_currentstateid(cstate, &op->u);\n\t\top->status = opdesc->op_func(rqstp, cstate, &op->u);\n\n\t\tif (!op->status) {\n\t\t\tif (opdesc->op_set_currentstateid)\n\t\t\t\topdesc->op_set_currentstateid(cstate, &op->u);\n\n\t\t\tif (opdesc->op_flags & OP_CLEAR_STATEID)\n\t\t\t\tclear_current_stateid(cstate);\n\n\t\t\tif (need_wrongsec_check(rqstp))\n\t\t\t\top->status = check_nfsd_access(current_fh->fh_export, rqstp);\n\t\t}\n\nencode_op:\n\t\t/* Only from SEQUENCE */\n\t\tif (cstate->status == nfserr_replay_cache) {\n\t\t\tdprintk(\"%s NFS4.1 replay from cache\\n\", __func__);\n\t\t\tstatus = op->status;\n\t\t\tgoto out;\n\t\t}\n\t\tif (op->status == nfserr_replay_me) {\n\t\t\top->replay = &cstate->replay_owner->so_replay;\n\t\t\tnfsd4_encode_replay(&resp->xdr, op);\n\t\t\tstatus = op->status = op->replay->rp_status;\n\t\t} else {\n\t\t\tnfsd4_encode_operation(resp, op);\n\t\t\tstatus = op->status;\n\t\t}\n\n\t\tdprintk(\"nfsv4 compound op %p opcnt %d #%d: %d: status %d\\n\",\n\t\t\targs->ops, args->opcnt, resp->opcnt, op->opnum,\n\t\t\tbe32_to_cpu(status));\n\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\t/* XXX Ugh, we need to get rid of this kind of special case: */\n\t\tif (op->opnum == OP_READ && op->u.read.rd_filp)\n\t\t\tfput(op->u.read.rd_filp);\n\n\t\tnfsd4_increment_op_stats(op->opnum);\n\t}\n\n\tcstate->status = status;\n\tfh_put(current_fh);\n\tfh_put(save_fh);\n\tBUG_ON(cstate->replay_owner);\nout:\n\t/* Reset deferral mechanism for RPC deferrals */\n\tset_bit(RQ_USEDEFERRAL, &rqstp->rq_flags);\n\tdprintk(\"nfsv4 compound returned %d\\n\", ntohl(status));\n\treturn status;\n}"
  },
  {
    "function_name": "svcxdr_init_encode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1580-1597",
    "snippet": "static void svcxdr_init_encode(struct svc_rqst *rqstp,\n\t\t\t       struct nfsd4_compoundres *resp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct xdr_buf *buf = &rqstp->rq_res;\n\tstruct kvec *head = buf->head;\n\n\txdr->buf = buf;\n\txdr->iov = head;\n\txdr->p   = head->iov_base + head->iov_len;\n\txdr->end = head->iov_base + PAGE_SIZE - rqstp->rq_auth_slack;\n\t/* Tail and page_len should be zero at this point: */\n\tbuf->len = buf->head[0].iov_len;\n\txdr->scratch.iov_len = 0;\n\txdr->page_ptr = buf->pages - 1;\n\tbuf->buflen = PAGE_SIZE * (1 + rqstp->rq_page_end - buf->pages)\n\t\t- rqstp->rq_auth_slack;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic void svcxdr_init_encode(struct svc_rqst *rqstp,\n\t\t\t       struct nfsd4_compoundres *resp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct xdr_buf *buf = &rqstp->rq_res;\n\tstruct kvec *head = buf->head;\n\n\txdr->buf = buf;\n\txdr->iov = head;\n\txdr->p   = head->iov_base + head->iov_len;\n\txdr->end = head->iov_base + PAGE_SIZE - rqstp->rq_auth_slack;\n\t/* Tail and page_len should be zero at this point: */\n\tbuf->len = buf->head[0].iov_len;\n\txdr->scratch.iov_len = 0;\n\txdr->page_ptr = buf->pages - 1;\n\tbuf->buflen = PAGE_SIZE * (1 + rqstp->rq_page_end - buf->pages)\n\t\t- rqstp->rq_auth_slack;\n}"
  },
  {
    "function_name": "need_wrongsec_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1546-1578",
    "snippet": "static bool need_wrongsec_check(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\tstruct nfsd4_op *this = &argp->ops[resp->opcnt - 1];\n\tstruct nfsd4_op *next = &argp->ops[resp->opcnt];\n\tstruct nfsd4_operation *thisd;\n\tstruct nfsd4_operation *nextd;\n\n\tthisd = OPDESC(this);\n\t/*\n\t * Most ops check wronsec on our own; only the putfh-like ops\n\t * have special rules.\n\t */\n\tif (!(thisd->op_flags & OP_IS_PUTFH_LIKE))\n\t\treturn false;\n\t/*\n\t * rfc 5661 2.6.3.1.1.6: don't bother erroring out a\n\t * put-filehandle operation if we're not going to use the\n\t * result:\n\t */\n\tif (argp->opcnt == resp->opcnt)\n\t\treturn false;\n\tif (next->opnum == OP_ILLEGAL)\n\t\treturn false;\n\tnextd = OPDESC(next);\n\t/*\n\t * Rest of 2.6.3.1.1: certain operations will return WRONGSEC\n\t * errors themselves as necessary; others should check for them\n\t * now:\n\t */\n\treturn !(nextd->op_flags & OP_HANDLES_WRONGSEC);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *nfsd4_op_name(unsigned opnum);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OPDESC",
          "args": [
            "next"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "OPDESC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "1534-1537",
          "snippet": "static inline struct nfsd4_operation *OPDESC(struct nfsd4_op *op)\n{\n\treturn &nfsd4_ops[op->opnum];\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfsd4_operation nfsd4_ops[];",
            "static const char *nfsd4_op_name(unsigned opnum);",
            "static struct nfsd4_operation nfsd4_ops[] = {\n\t[OP_ACCESS] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_access,\n\t\t.op_name = \"OP_ACCESS\",\n\t},\n\t[OP_CLOSE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_close,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLOSE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_closestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_closestateid,\n\t},\n\t[OP_COMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_commit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_commit_rsize,\n\t},\n\t[OP_CREATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_CREATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_rsize,\n\t},\n\t[OP_DELEGRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_delegreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DELEGRETURN\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_delegreturnstateid,\n\t},\n\t[OP_GETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getattr,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS,\n\t\t.op_rsize_bop = nfsd4_getattr_rsize,\n\t\t.op_name = \"OP_GETATTR\",\n\t},\n\t[OP_GETFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getfh,\n\t\t.op_name = \"OP_GETFH\",\n\t},\n\t[OP_LINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_link,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS | OP_MODIFIES_SOMETHING\n\t\t\t\t| OP_CACHEME,\n\t\t.op_name = \"OP_LINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_link_rsize,\n\t},\n\t[OP_LOCK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lock,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_lockstateid,\n\t},\n\t[OP_LOCKT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lockt,\n\t\t.op_name = \"OP_LOCKT\",\n\t},\n\t[OP_LOCKU] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_locku,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCKU\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_lockustateid,\n\t},\n\t[OP_LOOKUP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookup,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUP\",\n\t},\n\t[OP_LOOKUPP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookupp,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUPP\",\n\t},\n\t[OP_NVERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_nverify,\n\t\t.op_name = \"OP_NVERIFY\",\n\t},\n\t[OP_OPEN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_open_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_openstateid,\n\t},\n\t[OP_OPEN_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_confirm,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t},\n\t[OP_OPEN_DOWNGRADE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_downgrade,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_DOWNGRADE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_opendowngradestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_opendowngradestateid,\n\t},\n\t[OP_PUTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTPUBFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTPUBFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTROOTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTROOTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_READ] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_read,\n\t\t.op_name = \"OP_READ\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_read_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_readstateid,\n\t},\n\t[OP_READDIR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readdir,\n\t\t.op_name = \"OP_READDIR\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readdir_rsize,\n\t},\n\t[OP_READLINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readlink,\n\t\t.op_name = \"OP_READLINK\",\n\t},\n\t[OP_REMOVE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_remove,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_remove_rsize,\n\t},\n\t[OP_RENAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_rename,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_RENAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_rename_rsize,\n\t},\n\t[OP_RENEW] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_renew,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RENEW\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\n\t},\n\t[OP_RESTOREFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_restorefh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RESTOREFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SAVEFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_savefh,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_SAVEFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO\",\n\t},\n\t[OP_SETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setattr,\n\t\t.op_name = \"OP_SETATTR\",\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setattr_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_setattrstateid,\n\t},\n\t[OP_SETCLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setclientid_rsize,\n\t},\n\t[OP_SETCLIENTID_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid_confirm,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_VERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_verify,\n\t\t.op_name = \"OP_VERIFY\",\n\t},\n\t[OP_WRITE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_write,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_WRITE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_writestateid,\n\t},\n\t[OP_RELEASE_LOCKOWNER] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_release_lockowner,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RELEASE_LOCKOWNER\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\n\t/* NFSv4.1 operations */\n\t[OP_EXCHANGE_ID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_exchange_id,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_EXCHANGE_ID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_exchange_id_rsize,\n\t},\n\t[OP_BACKCHANNEL_CTL] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_backchannel_ctl,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BACKCHANNEL_CTL\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_BIND_CONN_TO_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_bind_conn_to_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BIND_CONN_TO_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_bind_conn_to_session_rsize,\n\t},\n\t[OP_CREATE_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CREATE_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_session_rsize,\n\t},\n\t[OP_DESTROY_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SEQUENCE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_sequence,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,\n\t\t.op_name = \"OP_SEQUENCE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_sequence_rsize,\n\t},\n\t[OP_DESTROY_CLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_clientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_CLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_RECLAIM_COMPLETE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_reclaim_complete,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RECLAIM_COMPLETE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO_NO_NAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo_no_name,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO_NO_NAME\",\n\t},\n\t[OP_TEST_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_test_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_TEST_STATEID\",\n\t},\n\t[OP_FREE_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_free_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_FREE_STATEID\",\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_freestateid,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getdeviceinfo,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_GETDEVICEINFO\",\n\t},\n\t[OP_LAYOUTGET] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutget,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTGET\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutget_rsize,\n\t},\n\t[OP_LAYOUTCOMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutcommit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTCOMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutcommit_rsize,\n\t},\n\t[OP_LAYOUTRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTRETURN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutreturn_rsize,\n\t},\n#endif /* CONFIG_NFSD_PNFS */\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_allocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_ALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_DEALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_deallocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_DEALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_SEEK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_seek,\n\t\t.op_name = \"OP_SEEK\",\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic struct nfsd4_operation nfsd4_ops[];\nstatic const char *nfsd4_op_name(unsigned opnum);\nstatic struct nfsd4_operation nfsd4_ops[] = {\n\t[OP_ACCESS] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_access,\n\t\t.op_name = \"OP_ACCESS\",\n\t},\n\t[OP_CLOSE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_close,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLOSE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_closestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_closestateid,\n\t},\n\t[OP_COMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_commit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_commit_rsize,\n\t},\n\t[OP_CREATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_CREATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_rsize,\n\t},\n\t[OP_DELEGRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_delegreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DELEGRETURN\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_delegreturnstateid,\n\t},\n\t[OP_GETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getattr,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS,\n\t\t.op_rsize_bop = nfsd4_getattr_rsize,\n\t\t.op_name = \"OP_GETATTR\",\n\t},\n\t[OP_GETFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getfh,\n\t\t.op_name = \"OP_GETFH\",\n\t},\n\t[OP_LINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_link,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS | OP_MODIFIES_SOMETHING\n\t\t\t\t| OP_CACHEME,\n\t\t.op_name = \"OP_LINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_link_rsize,\n\t},\n\t[OP_LOCK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lock,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_lockstateid,\n\t},\n\t[OP_LOCKT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lockt,\n\t\t.op_name = \"OP_LOCKT\",\n\t},\n\t[OP_LOCKU] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_locku,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCKU\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_lockustateid,\n\t},\n\t[OP_LOOKUP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookup,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUP\",\n\t},\n\t[OP_LOOKUPP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookupp,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUPP\",\n\t},\n\t[OP_NVERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_nverify,\n\t\t.op_name = \"OP_NVERIFY\",\n\t},\n\t[OP_OPEN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_open_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_openstateid,\n\t},\n\t[OP_OPEN_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_confirm,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t},\n\t[OP_OPEN_DOWNGRADE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_downgrade,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_DOWNGRADE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_opendowngradestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_opendowngradestateid,\n\t},\n\t[OP_PUTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTPUBFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTPUBFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTROOTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTROOTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_READ] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_read,\n\t\t.op_name = \"OP_READ\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_read_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_readstateid,\n\t},\n\t[OP_READDIR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readdir,\n\t\t.op_name = \"OP_READDIR\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readdir_rsize,\n\t},\n\t[OP_READLINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readlink,\n\t\t.op_name = \"OP_READLINK\",\n\t},\n\t[OP_REMOVE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_remove,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_remove_rsize,\n\t},\n\t[OP_RENAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_rename,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_RENAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_rename_rsize,\n\t},\n\t[OP_RENEW] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_renew,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RENEW\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\n\t},\n\t[OP_RESTOREFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_restorefh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RESTOREFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SAVEFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_savefh,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_SAVEFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO\",\n\t},\n\t[OP_SETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setattr,\n\t\t.op_name = \"OP_SETATTR\",\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setattr_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_setattrstateid,\n\t},\n\t[OP_SETCLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setclientid_rsize,\n\t},\n\t[OP_SETCLIENTID_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid_confirm,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_VERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_verify,\n\t\t.op_name = \"OP_VERIFY\",\n\t},\n\t[OP_WRITE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_write,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_WRITE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_writestateid,\n\t},\n\t[OP_RELEASE_LOCKOWNER] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_release_lockowner,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RELEASE_LOCKOWNER\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\n\t/* NFSv4.1 operations */\n\t[OP_EXCHANGE_ID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_exchange_id,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_EXCHANGE_ID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_exchange_id_rsize,\n\t},\n\t[OP_BACKCHANNEL_CTL] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_backchannel_ctl,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BACKCHANNEL_CTL\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_BIND_CONN_TO_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_bind_conn_to_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BIND_CONN_TO_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_bind_conn_to_session_rsize,\n\t},\n\t[OP_CREATE_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CREATE_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_session_rsize,\n\t},\n\t[OP_DESTROY_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SEQUENCE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_sequence,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,\n\t\t.op_name = \"OP_SEQUENCE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_sequence_rsize,\n\t},\n\t[OP_DESTROY_CLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_clientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_CLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_RECLAIM_COMPLETE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_reclaim_complete,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RECLAIM_COMPLETE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO_NO_NAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo_no_name,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO_NO_NAME\",\n\t},\n\t[OP_TEST_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_test_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_TEST_STATEID\",\n\t},\n\t[OP_FREE_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_free_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_FREE_STATEID\",\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_freestateid,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getdeviceinfo,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_GETDEVICEINFO\",\n\t},\n\t[OP_LAYOUTGET] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutget,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTGET\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutget_rsize,\n\t},\n\t[OP_LAYOUTCOMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutcommit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTCOMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutcommit_rsize,\n\t},\n\t[OP_LAYOUTRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTRETURN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutreturn_rsize,\n\t},\n#endif /* CONFIG_NFSD_PNFS */\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_allocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_ALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_DEALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_deallocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_DEALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_SEEK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_seek,\n\t\t.op_name = \"OP_SEEK\",\n\t},\n};\n\nstatic inline struct nfsd4_operation *OPDESC(struct nfsd4_op *op)\n{\n\treturn &nfsd4_ops[op->opnum];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic const char *nfsd4_op_name(unsigned opnum);\n\nstatic bool need_wrongsec_check(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\tstruct nfsd4_op *this = &argp->ops[resp->opcnt - 1];\n\tstruct nfsd4_op *next = &argp->ops[resp->opcnt];\n\tstruct nfsd4_operation *thisd;\n\tstruct nfsd4_operation *nextd;\n\n\tthisd = OPDESC(this);\n\t/*\n\t * Most ops check wronsec on our own; only the putfh-like ops\n\t * have special rules.\n\t */\n\tif (!(thisd->op_flags & OP_IS_PUTFH_LIKE))\n\t\treturn false;\n\t/*\n\t * rfc 5661 2.6.3.1.1.6: don't bother erroring out a\n\t * put-filehandle operation if we're not going to use the\n\t * result:\n\t */\n\tif (argp->opcnt == resp->opcnt)\n\t\treturn false;\n\tif (next->opnum == OP_ILLEGAL)\n\t\treturn false;\n\tnextd = OPDESC(next);\n\t/*\n\t * Rest of 2.6.3.1.1: certain operations will return WRONGSEC\n\t * errors themselves as necessary; others should check for them\n\t * now:\n\t */\n\treturn !(nextd->op_flags & OP_HANDLES_WRONGSEC);\n}"
  },
  {
    "function_name": "nfsd4_cache_this_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1539-1544",
    "snippet": "bool nfsd4_cache_this_op(struct nfsd4_op *op)\n{\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn false;\n\treturn OPDESC(op)->op_flags & OP_CACHEME;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *nfsd4_op_name(unsigned opnum);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OPDESC",
          "args": [
            "op"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "OPDESC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "1534-1537",
          "snippet": "static inline struct nfsd4_operation *OPDESC(struct nfsd4_op *op)\n{\n\treturn &nfsd4_ops[op->opnum];\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfsd4_operation nfsd4_ops[];",
            "static const char *nfsd4_op_name(unsigned opnum);",
            "static struct nfsd4_operation nfsd4_ops[] = {\n\t[OP_ACCESS] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_access,\n\t\t.op_name = \"OP_ACCESS\",\n\t},\n\t[OP_CLOSE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_close,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLOSE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_closestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_closestateid,\n\t},\n\t[OP_COMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_commit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_commit_rsize,\n\t},\n\t[OP_CREATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_CREATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_rsize,\n\t},\n\t[OP_DELEGRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_delegreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DELEGRETURN\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_delegreturnstateid,\n\t},\n\t[OP_GETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getattr,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS,\n\t\t.op_rsize_bop = nfsd4_getattr_rsize,\n\t\t.op_name = \"OP_GETATTR\",\n\t},\n\t[OP_GETFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getfh,\n\t\t.op_name = \"OP_GETFH\",\n\t},\n\t[OP_LINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_link,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS | OP_MODIFIES_SOMETHING\n\t\t\t\t| OP_CACHEME,\n\t\t.op_name = \"OP_LINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_link_rsize,\n\t},\n\t[OP_LOCK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lock,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_lockstateid,\n\t},\n\t[OP_LOCKT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lockt,\n\t\t.op_name = \"OP_LOCKT\",\n\t},\n\t[OP_LOCKU] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_locku,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCKU\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_lockustateid,\n\t},\n\t[OP_LOOKUP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookup,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUP\",\n\t},\n\t[OP_LOOKUPP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookupp,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUPP\",\n\t},\n\t[OP_NVERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_nverify,\n\t\t.op_name = \"OP_NVERIFY\",\n\t},\n\t[OP_OPEN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_open_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_openstateid,\n\t},\n\t[OP_OPEN_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_confirm,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t},\n\t[OP_OPEN_DOWNGRADE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_downgrade,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_DOWNGRADE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_opendowngradestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_opendowngradestateid,\n\t},\n\t[OP_PUTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTPUBFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTPUBFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTROOTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTROOTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_READ] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_read,\n\t\t.op_name = \"OP_READ\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_read_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_readstateid,\n\t},\n\t[OP_READDIR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readdir,\n\t\t.op_name = \"OP_READDIR\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readdir_rsize,\n\t},\n\t[OP_READLINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readlink,\n\t\t.op_name = \"OP_READLINK\",\n\t},\n\t[OP_REMOVE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_remove,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_remove_rsize,\n\t},\n\t[OP_RENAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_rename,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_RENAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_rename_rsize,\n\t},\n\t[OP_RENEW] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_renew,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RENEW\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\n\t},\n\t[OP_RESTOREFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_restorefh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RESTOREFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SAVEFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_savefh,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_SAVEFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO\",\n\t},\n\t[OP_SETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setattr,\n\t\t.op_name = \"OP_SETATTR\",\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setattr_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_setattrstateid,\n\t},\n\t[OP_SETCLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setclientid_rsize,\n\t},\n\t[OP_SETCLIENTID_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid_confirm,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_VERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_verify,\n\t\t.op_name = \"OP_VERIFY\",\n\t},\n\t[OP_WRITE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_write,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_WRITE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_writestateid,\n\t},\n\t[OP_RELEASE_LOCKOWNER] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_release_lockowner,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RELEASE_LOCKOWNER\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\n\t/* NFSv4.1 operations */\n\t[OP_EXCHANGE_ID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_exchange_id,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_EXCHANGE_ID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_exchange_id_rsize,\n\t},\n\t[OP_BACKCHANNEL_CTL] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_backchannel_ctl,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BACKCHANNEL_CTL\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_BIND_CONN_TO_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_bind_conn_to_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BIND_CONN_TO_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_bind_conn_to_session_rsize,\n\t},\n\t[OP_CREATE_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CREATE_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_session_rsize,\n\t},\n\t[OP_DESTROY_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SEQUENCE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_sequence,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,\n\t\t.op_name = \"OP_SEQUENCE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_sequence_rsize,\n\t},\n\t[OP_DESTROY_CLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_clientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_CLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_RECLAIM_COMPLETE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_reclaim_complete,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RECLAIM_COMPLETE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO_NO_NAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo_no_name,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO_NO_NAME\",\n\t},\n\t[OP_TEST_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_test_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_TEST_STATEID\",\n\t},\n\t[OP_FREE_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_free_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_FREE_STATEID\",\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_freestateid,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getdeviceinfo,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_GETDEVICEINFO\",\n\t},\n\t[OP_LAYOUTGET] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutget,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTGET\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutget_rsize,\n\t},\n\t[OP_LAYOUTCOMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutcommit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTCOMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutcommit_rsize,\n\t},\n\t[OP_LAYOUTRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTRETURN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutreturn_rsize,\n\t},\n#endif /* CONFIG_NFSD_PNFS */\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_allocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_ALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_DEALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_deallocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_DEALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_SEEK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_seek,\n\t\t.op_name = \"OP_SEEK\",\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic struct nfsd4_operation nfsd4_ops[];\nstatic const char *nfsd4_op_name(unsigned opnum);\nstatic struct nfsd4_operation nfsd4_ops[] = {\n\t[OP_ACCESS] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_access,\n\t\t.op_name = \"OP_ACCESS\",\n\t},\n\t[OP_CLOSE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_close,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLOSE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_closestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_closestateid,\n\t},\n\t[OP_COMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_commit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_commit_rsize,\n\t},\n\t[OP_CREATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_CREATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_rsize,\n\t},\n\t[OP_DELEGRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_delegreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DELEGRETURN\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_delegreturnstateid,\n\t},\n\t[OP_GETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getattr,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS,\n\t\t.op_rsize_bop = nfsd4_getattr_rsize,\n\t\t.op_name = \"OP_GETATTR\",\n\t},\n\t[OP_GETFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getfh,\n\t\t.op_name = \"OP_GETFH\",\n\t},\n\t[OP_LINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_link,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS | OP_MODIFIES_SOMETHING\n\t\t\t\t| OP_CACHEME,\n\t\t.op_name = \"OP_LINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_link_rsize,\n\t},\n\t[OP_LOCK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lock,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_lockstateid,\n\t},\n\t[OP_LOCKT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lockt,\n\t\t.op_name = \"OP_LOCKT\",\n\t},\n\t[OP_LOCKU] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_locku,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCKU\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_lockustateid,\n\t},\n\t[OP_LOOKUP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookup,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUP\",\n\t},\n\t[OP_LOOKUPP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookupp,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUPP\",\n\t},\n\t[OP_NVERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_nverify,\n\t\t.op_name = \"OP_NVERIFY\",\n\t},\n\t[OP_OPEN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_open_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_openstateid,\n\t},\n\t[OP_OPEN_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_confirm,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t},\n\t[OP_OPEN_DOWNGRADE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_downgrade,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_DOWNGRADE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_opendowngradestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_opendowngradestateid,\n\t},\n\t[OP_PUTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTPUBFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTPUBFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTROOTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTROOTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_READ] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_read,\n\t\t.op_name = \"OP_READ\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_read_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_readstateid,\n\t},\n\t[OP_READDIR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readdir,\n\t\t.op_name = \"OP_READDIR\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readdir_rsize,\n\t},\n\t[OP_READLINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readlink,\n\t\t.op_name = \"OP_READLINK\",\n\t},\n\t[OP_REMOVE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_remove,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_remove_rsize,\n\t},\n\t[OP_RENAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_rename,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_RENAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_rename_rsize,\n\t},\n\t[OP_RENEW] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_renew,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RENEW\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\n\t},\n\t[OP_RESTOREFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_restorefh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RESTOREFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SAVEFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_savefh,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_SAVEFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO\",\n\t},\n\t[OP_SETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setattr,\n\t\t.op_name = \"OP_SETATTR\",\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setattr_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_setattrstateid,\n\t},\n\t[OP_SETCLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setclientid_rsize,\n\t},\n\t[OP_SETCLIENTID_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid_confirm,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_VERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_verify,\n\t\t.op_name = \"OP_VERIFY\",\n\t},\n\t[OP_WRITE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_write,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_WRITE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_writestateid,\n\t},\n\t[OP_RELEASE_LOCKOWNER] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_release_lockowner,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RELEASE_LOCKOWNER\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\n\t/* NFSv4.1 operations */\n\t[OP_EXCHANGE_ID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_exchange_id,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_EXCHANGE_ID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_exchange_id_rsize,\n\t},\n\t[OP_BACKCHANNEL_CTL] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_backchannel_ctl,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BACKCHANNEL_CTL\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_BIND_CONN_TO_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_bind_conn_to_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BIND_CONN_TO_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_bind_conn_to_session_rsize,\n\t},\n\t[OP_CREATE_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CREATE_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_session_rsize,\n\t},\n\t[OP_DESTROY_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SEQUENCE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_sequence,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,\n\t\t.op_name = \"OP_SEQUENCE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_sequence_rsize,\n\t},\n\t[OP_DESTROY_CLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_clientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_CLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_RECLAIM_COMPLETE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_reclaim_complete,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RECLAIM_COMPLETE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO_NO_NAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo_no_name,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO_NO_NAME\",\n\t},\n\t[OP_TEST_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_test_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_TEST_STATEID\",\n\t},\n\t[OP_FREE_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_free_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_FREE_STATEID\",\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_freestateid,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getdeviceinfo,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_GETDEVICEINFO\",\n\t},\n\t[OP_LAYOUTGET] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutget,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTGET\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutget_rsize,\n\t},\n\t[OP_LAYOUTCOMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutcommit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTCOMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutcommit_rsize,\n\t},\n\t[OP_LAYOUTRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTRETURN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutreturn_rsize,\n\t},\n#endif /* CONFIG_NFSD_PNFS */\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_allocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_ALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_DEALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_deallocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_DEALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_SEEK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_seek,\n\t\t.op_name = \"OP_SEEK\",\n\t},\n};\n\nstatic inline struct nfsd4_operation *OPDESC(struct nfsd4_op *op)\n{\n\treturn &nfsd4_ops[op->opnum];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic const char *nfsd4_op_name(unsigned opnum);\n\nbool nfsd4_cache_this_op(struct nfsd4_op *op)\n{\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn false;\n\treturn OPDESC(op)->op_flags & OP_CACHEME;\n}"
  },
  {
    "function_name": "OPDESC",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1534-1537",
    "snippet": "static inline struct nfsd4_operation *OPDESC(struct nfsd4_op *op)\n{\n\treturn &nfsd4_ops[op->opnum];\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfsd4_operation nfsd4_ops[];",
      "static const char *nfsd4_op_name(unsigned opnum);",
      "static struct nfsd4_operation nfsd4_ops[] = {\n\t[OP_ACCESS] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_access,\n\t\t.op_name = \"OP_ACCESS\",\n\t},\n\t[OP_CLOSE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_close,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLOSE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_closestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_closestateid,\n\t},\n\t[OP_COMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_commit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_commit_rsize,\n\t},\n\t[OP_CREATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_CREATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_rsize,\n\t},\n\t[OP_DELEGRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_delegreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DELEGRETURN\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_delegreturnstateid,\n\t},\n\t[OP_GETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getattr,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS,\n\t\t.op_rsize_bop = nfsd4_getattr_rsize,\n\t\t.op_name = \"OP_GETATTR\",\n\t},\n\t[OP_GETFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getfh,\n\t\t.op_name = \"OP_GETFH\",\n\t},\n\t[OP_LINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_link,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS | OP_MODIFIES_SOMETHING\n\t\t\t\t| OP_CACHEME,\n\t\t.op_name = \"OP_LINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_link_rsize,\n\t},\n\t[OP_LOCK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lock,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_lockstateid,\n\t},\n\t[OP_LOCKT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lockt,\n\t\t.op_name = \"OP_LOCKT\",\n\t},\n\t[OP_LOCKU] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_locku,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCKU\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_lockustateid,\n\t},\n\t[OP_LOOKUP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookup,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUP\",\n\t},\n\t[OP_LOOKUPP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookupp,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUPP\",\n\t},\n\t[OP_NVERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_nverify,\n\t\t.op_name = \"OP_NVERIFY\",\n\t},\n\t[OP_OPEN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_open_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_openstateid,\n\t},\n\t[OP_OPEN_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_confirm,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t},\n\t[OP_OPEN_DOWNGRADE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_downgrade,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_DOWNGRADE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_opendowngradestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_opendowngradestateid,\n\t},\n\t[OP_PUTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTPUBFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTPUBFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTROOTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTROOTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_READ] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_read,\n\t\t.op_name = \"OP_READ\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_read_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_readstateid,\n\t},\n\t[OP_READDIR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readdir,\n\t\t.op_name = \"OP_READDIR\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readdir_rsize,\n\t},\n\t[OP_READLINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readlink,\n\t\t.op_name = \"OP_READLINK\",\n\t},\n\t[OP_REMOVE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_remove,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_remove_rsize,\n\t},\n\t[OP_RENAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_rename,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_RENAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_rename_rsize,\n\t},\n\t[OP_RENEW] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_renew,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RENEW\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\n\t},\n\t[OP_RESTOREFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_restorefh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RESTOREFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SAVEFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_savefh,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_SAVEFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO\",\n\t},\n\t[OP_SETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setattr,\n\t\t.op_name = \"OP_SETATTR\",\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setattr_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_setattrstateid,\n\t},\n\t[OP_SETCLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setclientid_rsize,\n\t},\n\t[OP_SETCLIENTID_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid_confirm,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_VERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_verify,\n\t\t.op_name = \"OP_VERIFY\",\n\t},\n\t[OP_WRITE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_write,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_WRITE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_writestateid,\n\t},\n\t[OP_RELEASE_LOCKOWNER] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_release_lockowner,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RELEASE_LOCKOWNER\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\n\t/* NFSv4.1 operations */\n\t[OP_EXCHANGE_ID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_exchange_id,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_EXCHANGE_ID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_exchange_id_rsize,\n\t},\n\t[OP_BACKCHANNEL_CTL] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_backchannel_ctl,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BACKCHANNEL_CTL\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_BIND_CONN_TO_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_bind_conn_to_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BIND_CONN_TO_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_bind_conn_to_session_rsize,\n\t},\n\t[OP_CREATE_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CREATE_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_session_rsize,\n\t},\n\t[OP_DESTROY_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SEQUENCE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_sequence,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,\n\t\t.op_name = \"OP_SEQUENCE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_sequence_rsize,\n\t},\n\t[OP_DESTROY_CLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_clientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_CLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_RECLAIM_COMPLETE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_reclaim_complete,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RECLAIM_COMPLETE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO_NO_NAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo_no_name,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO_NO_NAME\",\n\t},\n\t[OP_TEST_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_test_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_TEST_STATEID\",\n\t},\n\t[OP_FREE_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_free_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_FREE_STATEID\",\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_freestateid,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getdeviceinfo,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_GETDEVICEINFO\",\n\t},\n\t[OP_LAYOUTGET] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutget,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTGET\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutget_rsize,\n\t},\n\t[OP_LAYOUTCOMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutcommit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTCOMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutcommit_rsize,\n\t},\n\t[OP_LAYOUTRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTRETURN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutreturn_rsize,\n\t},\n#endif /* CONFIG_NFSD_PNFS */\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_allocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_ALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_DEALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_deallocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_DEALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_SEEK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_seek,\n\t\t.op_name = \"OP_SEEK\",\n\t},\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic struct nfsd4_operation nfsd4_ops[];\nstatic const char *nfsd4_op_name(unsigned opnum);\nstatic struct nfsd4_operation nfsd4_ops[] = {\n\t[OP_ACCESS] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_access,\n\t\t.op_name = \"OP_ACCESS\",\n\t},\n\t[OP_CLOSE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_close,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLOSE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_closestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_closestateid,\n\t},\n\t[OP_COMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_commit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_commit_rsize,\n\t},\n\t[OP_CREATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_CREATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_rsize,\n\t},\n\t[OP_DELEGRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_delegreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DELEGRETURN\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_delegreturnstateid,\n\t},\n\t[OP_GETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getattr,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS,\n\t\t.op_rsize_bop = nfsd4_getattr_rsize,\n\t\t.op_name = \"OP_GETATTR\",\n\t},\n\t[OP_GETFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getfh,\n\t\t.op_name = \"OP_GETFH\",\n\t},\n\t[OP_LINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_link,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS | OP_MODIFIES_SOMETHING\n\t\t\t\t| OP_CACHEME,\n\t\t.op_name = \"OP_LINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_link_rsize,\n\t},\n\t[OP_LOCK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lock,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_lockstateid,\n\t},\n\t[OP_LOCKT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lockt,\n\t\t.op_name = \"OP_LOCKT\",\n\t},\n\t[OP_LOCKU] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_locku,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCKU\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_lockustateid,\n\t},\n\t[OP_LOOKUP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookup,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUP\",\n\t},\n\t[OP_LOOKUPP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookupp,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUPP\",\n\t},\n\t[OP_NVERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_nverify,\n\t\t.op_name = \"OP_NVERIFY\",\n\t},\n\t[OP_OPEN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_open_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_openstateid,\n\t},\n\t[OP_OPEN_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_confirm,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t},\n\t[OP_OPEN_DOWNGRADE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_downgrade,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_DOWNGRADE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_opendowngradestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_opendowngradestateid,\n\t},\n\t[OP_PUTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTPUBFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTPUBFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTROOTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTROOTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_READ] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_read,\n\t\t.op_name = \"OP_READ\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_read_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_readstateid,\n\t},\n\t[OP_READDIR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readdir,\n\t\t.op_name = \"OP_READDIR\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readdir_rsize,\n\t},\n\t[OP_READLINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readlink,\n\t\t.op_name = \"OP_READLINK\",\n\t},\n\t[OP_REMOVE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_remove,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_remove_rsize,\n\t},\n\t[OP_RENAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_rename,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_RENAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_rename_rsize,\n\t},\n\t[OP_RENEW] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_renew,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RENEW\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\n\t},\n\t[OP_RESTOREFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_restorefh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RESTOREFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SAVEFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_savefh,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_SAVEFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO\",\n\t},\n\t[OP_SETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setattr,\n\t\t.op_name = \"OP_SETATTR\",\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setattr_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_setattrstateid,\n\t},\n\t[OP_SETCLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setclientid_rsize,\n\t},\n\t[OP_SETCLIENTID_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid_confirm,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_VERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_verify,\n\t\t.op_name = \"OP_VERIFY\",\n\t},\n\t[OP_WRITE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_write,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_WRITE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_writestateid,\n\t},\n\t[OP_RELEASE_LOCKOWNER] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_release_lockowner,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RELEASE_LOCKOWNER\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\n\t/* NFSv4.1 operations */\n\t[OP_EXCHANGE_ID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_exchange_id,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_EXCHANGE_ID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_exchange_id_rsize,\n\t},\n\t[OP_BACKCHANNEL_CTL] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_backchannel_ctl,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BACKCHANNEL_CTL\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_BIND_CONN_TO_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_bind_conn_to_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BIND_CONN_TO_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_bind_conn_to_session_rsize,\n\t},\n\t[OP_CREATE_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CREATE_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_session_rsize,\n\t},\n\t[OP_DESTROY_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SEQUENCE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_sequence,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,\n\t\t.op_name = \"OP_SEQUENCE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_sequence_rsize,\n\t},\n\t[OP_DESTROY_CLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_clientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_CLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_RECLAIM_COMPLETE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_reclaim_complete,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RECLAIM_COMPLETE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO_NO_NAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo_no_name,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO_NO_NAME\",\n\t},\n\t[OP_TEST_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_test_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_TEST_STATEID\",\n\t},\n\t[OP_FREE_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_free_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_FREE_STATEID\",\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_freestateid,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getdeviceinfo,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_GETDEVICEINFO\",\n\t},\n\t[OP_LAYOUTGET] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutget,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTGET\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutget_rsize,\n\t},\n\t[OP_LAYOUTCOMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutcommit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTCOMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutcommit_rsize,\n\t},\n\t[OP_LAYOUTRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTRETURN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutreturn_rsize,\n\t},\n#endif /* CONFIG_NFSD_PNFS */\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_allocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_ALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_DEALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_deallocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_DEALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_SEEK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_seek,\n\t\t.op_name = \"OP_SEEK\",\n\t},\n};\n\nstatic inline struct nfsd4_operation *OPDESC(struct nfsd4_op *op)\n{\n\treturn &nfsd4_ops[op->opnum];\n}"
  },
  {
    "function_name": "nfs41_check_op_ordering",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1513-1532",
    "snippet": "static __be32 nfs41_check_op_ordering(struct nfsd4_compoundargs *args)\n{\n\tstruct nfsd4_op *op = &args->ops[0];\n\n\t/* These ordering requirements don't apply to NFSv4.0: */\n\tif (args->minorversion == 0)\n\t\treturn nfs_ok;\n\t/* This is weird, but OK, not our problem: */\n\tif (args->opcnt == 0)\n\t\treturn nfs_ok;\n\tif (op->status == nfserr_op_illegal)\n\t\treturn nfs_ok;\n\tif (!(nfsd4_ops[op->opnum].op_flags & ALLOWED_AS_FIRST_OP))\n\t\treturn nfserr_op_not_in_session;\n\tif (op->opnum == OP_SEQUENCE)\n\t\treturn nfs_ok;\n\tif (args->opcnt != 1)\n\t\treturn nfserr_not_only_op;\n\treturn nfs_ok;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfsd4_operation nfsd4_ops[];",
      "static const char *nfsd4_op_name(unsigned opnum);",
      "static struct nfsd4_operation nfsd4_ops[] = {\n\t[OP_ACCESS] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_access,\n\t\t.op_name = \"OP_ACCESS\",\n\t},\n\t[OP_CLOSE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_close,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLOSE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_closestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_closestateid,\n\t},\n\t[OP_COMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_commit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_commit_rsize,\n\t},\n\t[OP_CREATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_CREATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_rsize,\n\t},\n\t[OP_DELEGRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_delegreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DELEGRETURN\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_delegreturnstateid,\n\t},\n\t[OP_GETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getattr,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS,\n\t\t.op_rsize_bop = nfsd4_getattr_rsize,\n\t\t.op_name = \"OP_GETATTR\",\n\t},\n\t[OP_GETFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getfh,\n\t\t.op_name = \"OP_GETFH\",\n\t},\n\t[OP_LINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_link,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS | OP_MODIFIES_SOMETHING\n\t\t\t\t| OP_CACHEME,\n\t\t.op_name = \"OP_LINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_link_rsize,\n\t},\n\t[OP_LOCK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lock,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_lockstateid,\n\t},\n\t[OP_LOCKT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lockt,\n\t\t.op_name = \"OP_LOCKT\",\n\t},\n\t[OP_LOCKU] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_locku,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCKU\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_lockustateid,\n\t},\n\t[OP_LOOKUP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookup,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUP\",\n\t},\n\t[OP_LOOKUPP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookupp,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUPP\",\n\t},\n\t[OP_NVERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_nverify,\n\t\t.op_name = \"OP_NVERIFY\",\n\t},\n\t[OP_OPEN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_open_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_openstateid,\n\t},\n\t[OP_OPEN_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_confirm,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t},\n\t[OP_OPEN_DOWNGRADE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_downgrade,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_DOWNGRADE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_opendowngradestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_opendowngradestateid,\n\t},\n\t[OP_PUTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTPUBFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTPUBFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTROOTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTROOTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_READ] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_read,\n\t\t.op_name = \"OP_READ\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_read_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_readstateid,\n\t},\n\t[OP_READDIR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readdir,\n\t\t.op_name = \"OP_READDIR\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readdir_rsize,\n\t},\n\t[OP_READLINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readlink,\n\t\t.op_name = \"OP_READLINK\",\n\t},\n\t[OP_REMOVE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_remove,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_remove_rsize,\n\t},\n\t[OP_RENAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_rename,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_RENAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_rename_rsize,\n\t},\n\t[OP_RENEW] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_renew,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RENEW\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\n\t},\n\t[OP_RESTOREFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_restorefh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RESTOREFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SAVEFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_savefh,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_SAVEFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO\",\n\t},\n\t[OP_SETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setattr,\n\t\t.op_name = \"OP_SETATTR\",\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setattr_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_setattrstateid,\n\t},\n\t[OP_SETCLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setclientid_rsize,\n\t},\n\t[OP_SETCLIENTID_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid_confirm,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_VERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_verify,\n\t\t.op_name = \"OP_VERIFY\",\n\t},\n\t[OP_WRITE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_write,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_WRITE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_writestateid,\n\t},\n\t[OP_RELEASE_LOCKOWNER] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_release_lockowner,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RELEASE_LOCKOWNER\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\n\t/* NFSv4.1 operations */\n\t[OP_EXCHANGE_ID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_exchange_id,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_EXCHANGE_ID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_exchange_id_rsize,\n\t},\n\t[OP_BACKCHANNEL_CTL] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_backchannel_ctl,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BACKCHANNEL_CTL\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_BIND_CONN_TO_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_bind_conn_to_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BIND_CONN_TO_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_bind_conn_to_session_rsize,\n\t},\n\t[OP_CREATE_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CREATE_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_session_rsize,\n\t},\n\t[OP_DESTROY_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SEQUENCE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_sequence,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,\n\t\t.op_name = \"OP_SEQUENCE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_sequence_rsize,\n\t},\n\t[OP_DESTROY_CLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_clientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_CLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_RECLAIM_COMPLETE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_reclaim_complete,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RECLAIM_COMPLETE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO_NO_NAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo_no_name,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO_NO_NAME\",\n\t},\n\t[OP_TEST_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_test_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_TEST_STATEID\",\n\t},\n\t[OP_FREE_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_free_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_FREE_STATEID\",\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_freestateid,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getdeviceinfo,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_GETDEVICEINFO\",\n\t},\n\t[OP_LAYOUTGET] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutget,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTGET\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutget_rsize,\n\t},\n\t[OP_LAYOUTCOMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutcommit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTCOMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutcommit_rsize,\n\t},\n\t[OP_LAYOUTRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTRETURN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutreturn_rsize,\n\t},\n#endif /* CONFIG_NFSD_PNFS */\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_allocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_ALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_DEALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_deallocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_DEALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_SEEK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_seek,\n\t\t.op_name = \"OP_SEEK\",\n\t},\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic struct nfsd4_operation nfsd4_ops[];\nstatic const char *nfsd4_op_name(unsigned opnum);\nstatic struct nfsd4_operation nfsd4_ops[] = {\n\t[OP_ACCESS] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_access,\n\t\t.op_name = \"OP_ACCESS\",\n\t},\n\t[OP_CLOSE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_close,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CLOSE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_closestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_closestateid,\n\t},\n\t[OP_COMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_commit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_COMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_commit_rsize,\n\t},\n\t[OP_CREATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_CREATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_rsize,\n\t},\n\t[OP_DELEGRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_delegreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DELEGRETURN\",\n\t\t.op_rsize_bop = nfsd4_only_status_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_delegreturnstateid,\n\t},\n\t[OP_GETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getattr,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS,\n\t\t.op_rsize_bop = nfsd4_getattr_rsize,\n\t\t.op_name = \"OP_GETATTR\",\n\t},\n\t[OP_GETFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getfh,\n\t\t.op_name = \"OP_GETFH\",\n\t},\n\t[OP_LINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_link,\n\t\t.op_flags = ALLOWED_ON_ABSENT_FS | OP_MODIFIES_SOMETHING\n\t\t\t\t| OP_CACHEME,\n\t\t.op_name = \"OP_LINK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_link_rsize,\n\t},\n\t[OP_LOCK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lock,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCK\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_lock_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_lockstateid,\n\t},\n\t[OP_LOCKT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lockt,\n\t\t.op_name = \"OP_LOCKT\",\n\t},\n\t[OP_LOCKU] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_locku,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LOCKU\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_lockustateid,\n\t},\n\t[OP_LOOKUP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookup,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUP\",\n\t},\n\t[OP_LOOKUPP] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_lookupp,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_LOOKUPP\",\n\t},\n\t[OP_NVERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_nverify,\n\t\t.op_name = \"OP_NVERIFY\",\n\t},\n\t[OP_OPEN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_open_rsize,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_openstateid,\n\t},\n\t[OP_OPEN_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_confirm,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t},\n\t[OP_OPEN_DOWNGRADE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_open_downgrade,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_OPEN_DOWNGRADE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_status_stateid_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_opendowngradestateid,\n\t\t.op_set_currentstateid = (stateid_setter)nfsd4_set_opendowngradestateid,\n\t},\n\t[OP_PUTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTPUBFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTPUBFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_PUTROOTFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_putrootfh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_CLEAR_STATEID,\n\t\t.op_name = \"OP_PUTROOTFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_READ] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_read,\n\t\t.op_name = \"OP_READ\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_read_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_readstateid,\n\t},\n\t[OP_READDIR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readdir,\n\t\t.op_name = \"OP_READDIR\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_readdir_rsize,\n\t},\n\t[OP_READLINK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_readlink,\n\t\t.op_name = \"OP_READLINK\",\n\t},\n\t[OP_REMOVE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_remove,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_REMOVE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_remove_rsize,\n\t},\n\t[OP_RENAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_rename,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_RENAME\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_rename_rsize,\n\t},\n\t[OP_RENEW] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_renew,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RENEW\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\n\t},\n\t[OP_RESTOREFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_restorefh,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_IS_PUTFH_LIKE | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RESTOREFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SAVEFH] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_savefh,\n\t\t.op_flags = OP_HANDLES_WRONGSEC | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_SAVEFH\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO\",\n\t},\n\t[OP_SETATTR] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setattr,\n\t\t.op_name = \"OP_SETATTR\",\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setattr_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_setattrstateid,\n\t},\n\t[OP_SETCLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_setclientid_rsize,\n\t},\n\t[OP_SETCLIENTID_CONFIRM] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_setclientid_confirm,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_SETCLIENTID_CONFIRM\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_VERIFY] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_verify,\n\t\t.op_name = \"OP_VERIFY\",\n\t},\n\t[OP_WRITE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_write,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_WRITE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_writestateid,\n\t},\n\t[OP_RELEASE_LOCKOWNER] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_release_lockowner,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_ON_ABSENT_FS\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RELEASE_LOCKOWNER\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\n\t/* NFSv4.1 operations */\n\t[OP_EXCHANGE_ID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_exchange_id,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_EXCHANGE_ID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_exchange_id_rsize,\n\t},\n\t[OP_BACKCHANNEL_CTL] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_backchannel_ctl,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BACKCHANNEL_CTL\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_BIND_CONN_TO_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_bind_conn_to_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_BIND_CONN_TO_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_bind_conn_to_session_rsize,\n\t},\n\t[OP_CREATE_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_create_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_CREATE_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_create_session_rsize,\n\t},\n\t[OP_DESTROY_SESSION] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_session,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_SESSION\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SEQUENCE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_sequence,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP,\n\t\t.op_name = \"OP_SEQUENCE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_sequence_rsize,\n\t},\n\t[OP_DESTROY_CLIENTID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_destroy_clientid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | ALLOWED_AS_FIRST_OP\n\t\t\t\t| OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_DESTROY_CLIENTID\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_RECLAIM_COMPLETE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_reclaim_complete,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_RECLAIM_COMPLETE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n\t[OP_SECINFO_NO_NAME] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_secinfo_no_name,\n\t\t.op_flags = OP_HANDLES_WRONGSEC,\n\t\t.op_name = \"OP_SECINFO_NO_NAME\",\n\t},\n\t[OP_TEST_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_test_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_TEST_STATEID\",\n\t},\n\t[OP_FREE_STATEID] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_free_stateid,\n\t\t.op_flags = ALLOWED_WITHOUT_FH | OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_FREE_STATEID\",\n\t\t.op_get_currentstateid = (stateid_getter)nfsd4_get_freestateid,\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_only_status_rsize,\n\t},\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_getdeviceinfo,\n\t\t.op_flags = ALLOWED_WITHOUT_FH,\n\t\t.op_name = \"OP_GETDEVICEINFO\",\n\t},\n\t[OP_LAYOUTGET] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutget,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTGET\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutget_rsize,\n\t},\n\t[OP_LAYOUTCOMMIT] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutcommit,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTCOMMIT\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutcommit_rsize,\n\t},\n\t[OP_LAYOUTRETURN] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_layoutreturn,\n\t\t.op_flags = OP_MODIFIES_SOMETHING,\n\t\t.op_name = \"OP_LAYOUTRETURN\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_layoutreturn_rsize,\n\t},\n#endif /* CONFIG_NFSD_PNFS */\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_allocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_ALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_DEALLOCATE] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_deallocate,\n\t\t.op_flags = OP_MODIFIES_SOMETHING | OP_CACHEME,\n\t\t.op_name = \"OP_DEALLOCATE\",\n\t\t.op_rsize_bop = (nfsd4op_rsize)nfsd4_write_rsize,\n\t},\n\t[OP_SEEK] = {\n\t\t.op_func = (nfsd4op_func)nfsd4_seek,\n\t\t.op_name = \"OP_SEEK\",\n\t},\n};\n\nstatic __be32 nfs41_check_op_ordering(struct nfsd4_compoundargs *args)\n{\n\tstruct nfsd4_op *op = &args->ops[0];\n\n\t/* These ordering requirements don't apply to NFSv4.0: */\n\tif (args->minorversion == 0)\n\t\treturn nfs_ok;\n\t/* This is weird, but OK, not our problem: */\n\tif (args->opcnt == 0)\n\t\treturn nfs_ok;\n\tif (op->status == nfserr_op_illegal)\n\t\treturn nfs_ok;\n\tif (!(nfsd4_ops[op->opnum].op_flags & ALLOWED_AS_FIRST_OP))\n\t\treturn nfserr_op_not_in_session;\n\tif (op->opnum == OP_SEQUENCE)\n\t\treturn nfs_ok;\n\tif (args->opcnt != 1)\n\t\treturn nfserr_not_only_op;\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_increment_op_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1445-1449",
    "snippet": "static inline void nfsd4_increment_op_stats(u32 opnum)\n{\n\tif (opnum >= FIRST_NFS4_OP && opnum <= LAST_NFS4_OP)\n\t\tnfsdstats.nfs4_opcount[opnum]++;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *nfsd4_op_name(unsigned opnum);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic const char *nfsd4_op_name(unsigned opnum);\n\nstatic inline void nfsd4_increment_op_stats(u32 opnum)\n{\n\tif (opnum >= FIRST_NFS4_OP && opnum <= LAST_NFS4_OP)\n\t\tnfsdstats.nfs4_opcount[opnum]++;\n}"
  },
  {
    "function_name": "nfsd4_proc_null",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1439-1443",
    "snippet": "static __be32\nnfsd4_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)\n{\n\treturn nfs_ok;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)\n{\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_layoutreturn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1389-1433",
    "snippet": "static __be32\nnfsd4_layoutreturn(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\t__be32 nfserr;\n\n\tnfserr = fh_verify(rqstp, current_fh, 0, NFSD_MAY_NOP);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_layoutunavailable;\n\tif (!nfsd4_layout_verify(current_fh->fh_export, lrp->lr_layout_type))\n\t\tgoto out;\n\n\tswitch (lrp->lr_seg.iomode) {\n\tcase IOMODE_READ:\n\tcase IOMODE_RW:\n\tcase IOMODE_ANY:\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: invalid iomode %d\\n\", __func__,\n\t\t\tlrp->lr_seg.iomode);\n\t\tnfserr = nfserr_inval;\n\t\tgoto out;\n\t}\n\n\tswitch (lrp->lr_return_type) {\n\tcase RETURN_FILE:\n\t\tnfserr = nfsd4_return_file_layouts(rqstp, cstate, lrp);\n\t\tbreak;\n\tcase RETURN_FSID:\n\tcase RETURN_ALL:\n\t\tnfserr = nfsd4_return_client_layouts(rqstp, cstate, lrp);\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: invalid return_type %d\\n\", __func__,\n\t\t\tlrp->lr_return_type);\n\t\tnfserr = nfserr_inval;\n\t\tbreak;\n\t}\nout:\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: invalid return_type %d\\n\"",
            "__func__",
            "lrp->lr_return_type"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_return_client_layouts",
          "args": [
            "rqstp",
            "cstate",
            "lrp"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "502-533",
          "snippet": "__be32\nnfsd4_return_client_layouts(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_layout *lp, *t;\n\tLIST_HEAD(reaplist);\n\n\tlrp->lrs_present = 0;\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt) {\n\t\tif (lrp->lr_return_type == RETURN_FSID &&\n\t\t    !fh_fsid_match(&ls->ls_stid.sc_file->fi_fhandle,\n\t\t\t\t   &cstate->current_fh.fh_handle))\n\t\t\tcontinue;\n\n\t\tspin_lock(&ls->ls_lock);\n\t\tlist_for_each_entry_safe(lp, t, &ls->ls_layouts, lo_perstate) {\n\t\t\tif (lrp->lr_seg.iomode == IOMODE_ANY ||\n\t\t\t    lrp->lr_seg.iomode == lp->lo_seg.iomode)\n\t\t\t\tlist_move_tail(&lp->lo_perstate, &reaplist);\n\t\t}\n\t\tspin_unlock(&ls->ls_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\n__be32\nnfsd4_return_client_layouts(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_layout *lp, *t;\n\tLIST_HEAD(reaplist);\n\n\tlrp->lrs_present = 0;\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt) {\n\t\tif (lrp->lr_return_type == RETURN_FSID &&\n\t\t    !fh_fsid_match(&ls->ls_stid.sc_file->fi_fhandle,\n\t\t\t\t   &cstate->current_fh.fh_handle))\n\t\t\tcontinue;\n\n\t\tspin_lock(&ls->ls_lock);\n\t\tlist_for_each_entry_safe(lp, t, &ls->ls_layouts, lo_perstate) {\n\t\t\tif (lrp->lr_seg.iomode == IOMODE_ANY ||\n\t\t\t    lrp->lr_seg.iomode == lp->lo_seg.iomode)\n\t\t\t\tlist_move_tail(&lp->lo_perstate, &reaplist);\n\t\t}\n\t\tspin_unlock(&ls->ls_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_return_file_layouts",
          "args": [
            "rqstp",
            "cstate",
            "lrp"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_file_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "457-500",
          "snippet": "__be32\nnfsd4_return_file_layouts(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_layout *lp, *n;\n\tLIST_HEAD(reaplist);\n\t__be32 nfserr;\n\tint found = 0;\n\n\tnfserr = nfsd4_preprocess_layout_stateid(rqstp, cstate, &lrp->lr_sid,\n\t\t\t\t\t\tfalse, lrp->lr_layout_type,\n\t\t\t\t\t\t&ls);\n\tif (nfserr) {\n\t\ttrace_layout_return_lookup_fail(&lrp->lr_sid);\n\t\treturn nfserr;\n\t}\n\n\tspin_lock(&ls->ls_lock);\n\tlist_for_each_entry_safe(lp, n, &ls->ls_layouts, lo_perstate) {\n\t\tif (layouts_overlapping(lp, &lrp->lr_seg)) {\n\t\t\tnfsd4_return_file_layout(lp, &lrp->lr_seg, &reaplist);\n\t\t\tfound++;\n\t\t}\n\t}\n\tif (!list_empty(&ls->ls_layouts)) {\n\t\tif (found) {\n\t\t\tupdate_stateid(&ls->ls_stid.sc_stateid);\n\t\t\tmemcpy(&lrp->lr_sid, &ls->ls_stid.sc_stateid,\n\t\t\t\tsizeof(stateid_t));\n\t\t}\n\t\tlrp->lrs_present = 1;\n\t} else {\n\t\ttrace_layoutstate_unhash(&ls->ls_stid.sc_stateid);\n\t\tnfs4_unhash_stid(&ls->ls_stid);\n\t\tlrp->lrs_present = 0;\n\t}\n\tspin_unlock(&ls->ls_lock);\n\n\tnfs4_put_stid(&ls->ls_stid);\n\tnfsd4_free_layouts(&reaplist);\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\n__be32\nnfsd4_return_file_layouts(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_layout *lp, *n;\n\tLIST_HEAD(reaplist);\n\t__be32 nfserr;\n\tint found = 0;\n\n\tnfserr = nfsd4_preprocess_layout_stateid(rqstp, cstate, &lrp->lr_sid,\n\t\t\t\t\t\tfalse, lrp->lr_layout_type,\n\t\t\t\t\t\t&ls);\n\tif (nfserr) {\n\t\ttrace_layout_return_lookup_fail(&lrp->lr_sid);\n\t\treturn nfserr;\n\t}\n\n\tspin_lock(&ls->ls_lock);\n\tlist_for_each_entry_safe(lp, n, &ls->ls_layouts, lo_perstate) {\n\t\tif (layouts_overlapping(lp, &lrp->lr_seg)) {\n\t\t\tnfsd4_return_file_layout(lp, &lrp->lr_seg, &reaplist);\n\t\t\tfound++;\n\t\t}\n\t}\n\tif (!list_empty(&ls->ls_layouts)) {\n\t\tif (found) {\n\t\t\tupdate_stateid(&ls->ls_stid.sc_stateid);\n\t\t\tmemcpy(&lrp->lr_sid, &ls->ls_stid.sc_stateid,\n\t\t\t\tsizeof(stateid_t));\n\t\t}\n\t\tlrp->lrs_present = 1;\n\t} else {\n\t\ttrace_layoutstate_unhash(&ls->ls_stid.sc_stateid);\n\t\tnfs4_unhash_stid(&ls->ls_stid);\n\t\tlrp->lrs_present = 0;\n\t}\n\tspin_unlock(&ls->ls_lock);\n\n\tnfs4_put_stid(&ls->ls_stid);\n\tnfsd4_free_layouts(&reaplist);\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: invalid iomode %d\\n\"",
            "__func__",
            "lrp->lr_seg.iomode"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_layout_verify",
          "args": [
            "current_fh->fh_export",
            "lrp->lr_layout_type"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_layout_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "1184-1199",
          "snippet": "static const struct nfsd4_layout_ops *\nnfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_type) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (exp->ex_layout_type != layout_type) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\n\treturn nfsd4_layout_ops[layout_type];\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic const struct nfsd4_layout_ops *\nnfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_type) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (exp->ex_layout_type != layout_type) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\n\treturn nfsd4_layout_ops[layout_type];\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "current_fh",
            "0",
            "NFSD_MAY_NOP"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_layoutreturn(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\t__be32 nfserr;\n\n\tnfserr = fh_verify(rqstp, current_fh, 0, NFSD_MAY_NOP);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_layoutunavailable;\n\tif (!nfsd4_layout_verify(current_fh->fh_export, lrp->lr_layout_type))\n\t\tgoto out;\n\n\tswitch (lrp->lr_seg.iomode) {\n\tcase IOMODE_READ:\n\tcase IOMODE_RW:\n\tcase IOMODE_ANY:\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: invalid iomode %d\\n\", __func__,\n\t\t\tlrp->lr_seg.iomode);\n\t\tnfserr = nfserr_inval;\n\t\tgoto out;\n\t}\n\n\tswitch (lrp->lr_return_type) {\n\tcase RETURN_FILE:\n\t\tnfserr = nfsd4_return_file_layouts(rqstp, cstate, lrp);\n\t\tbreak;\n\tcase RETURN_FSID:\n\tcase RETURN_ALL:\n\t\tnfserr = nfsd4_return_client_layouts(rqstp, cstate, lrp);\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: invalid return_type %d\\n\", __func__,\n\t\t\tlrp->lr_return_type);\n\t\tnfserr = nfserr_inval;\n\t\tbreak;\n\t}\nout:\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_layoutcommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1324-1387",
    "snippet": "static __be32\nnfsd4_layoutcommit(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutcommit *lcp)\n{\n\tconst struct nfsd4_layout_seg *seg = &lcp->lc_seg;\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tconst struct nfsd4_layout_ops *ops;\n\tloff_t new_size = lcp->lc_last_wr + 1;\n\tstruct inode *inode;\n\tstruct nfs4_layout_stateid *ls;\n\t__be32 nfserr;\n\n\tnfserr = fh_verify(rqstp, current_fh, 0, NFSD_MAY_WRITE);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_layoutunavailable;\n\tops = nfsd4_layout_verify(current_fh->fh_export, lcp->lc_layout_type);\n\tif (!ops)\n\t\tgoto out;\n\tinode = current_fh->fh_dentry->d_inode;\n\n\tnfserr = nfserr_inval;\n\tif (new_size <= seg->offset) {\n\t\tdprintk(\"pnfsd: last write before layout segment\\n\");\n\t\tgoto out;\n\t}\n\tif (new_size > seg->offset + seg->length) {\n\t\tdprintk(\"pnfsd: last write beyond layout segment\\n\");\n\t\tgoto out;\n\t}\n\tif (!lcp->lc_newoffset && new_size > i_size_read(inode)) {\n\t\tdprintk(\"pnfsd: layoutcommit beyond EOF\\n\");\n\t\tgoto out;\n\t}\n\n\tnfserr = nfsd4_preprocess_layout_stateid(rqstp, cstate, &lcp->lc_sid,\n\t\t\t\t\t\tfalse, lcp->lc_layout_type,\n\t\t\t\t\t\t&ls);\n\tif (nfserr) {\n\t\ttrace_layout_commit_lookup_fail(&lcp->lc_sid);\n\t\t/* fixup error code as per RFC5661 */\n\t\tif (nfserr == nfserr_bad_stateid)\n\t\t\tnfserr = nfserr_badlayout;\n\t\tgoto out;\n\t}\n\n\tnfserr = ops->proc_layoutcommit(inode, lcp);\n\tif (nfserr)\n\t\tgoto out_put_stid;\n\n\tif (new_size > i_size_read(inode)) {\n\t\tlcp->lc_size_chg = 1;\n\t\tlcp->lc_newsize = new_size;\n\t} else {\n\t\tlcp->lc_size_chg = 0;\n\t}\n\nout_put_stid:\n\tnfs4_put_stid(&ls->ls_stid);\nout:\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&ls->ls_stid"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->proc_layoutcommit",
          "args": [
            "inode",
            "lcp"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_layout_commit_lookup_fail",
          "args": [
            "&lcp->lc_sid"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_preprocess_layout_stateid",
          "args": [
            "rqstp",
            "cstate",
            "&lcp->lc_sid",
            "false",
            "lcp->lc_layout_type",
            "&ls"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_preprocess_layout_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "233-281",
          "snippet": "__be32\nnfsd4_preprocess_layout_stateid(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, stateid_t *stateid,\n\t\tbool create, u32 layout_type, struct nfs4_layout_stateid **lsp)\n{\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_stid *stid;\n\tunsigned char typemask = NFS4_LAYOUT_STID;\n\t__be32 status;\n\n\tif (create)\n\t\ttypemask |= (NFS4_OPEN_STID | NFS4_LOCK_STID | NFS4_DELEG_STID);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &stid,\n\t\t\tnet_generic(SVC_NET(rqstp), nfsd_net_id));\n\tif (status)\n\t\tgoto out;\n\n\tif (!fh_match(&cstate->current_fh.fh_handle,\n\t\t      &stid->sc_file->fi_fhandle)) {\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out_put_stid;\n\t}\n\n\tif (stid->sc_type != NFS4_LAYOUT_STID) {\n\t\tls = nfsd4_alloc_layout_stateid(cstate, stid, layout_type);\n\t\tnfs4_put_stid(stid);\n\n\t\tstatus = nfserr_jukebox;\n\t\tif (!ls)\n\t\t\tgoto out;\n\t} else {\n\t\tls = container_of(stid, struct nfs4_layout_stateid, ls_stid);\n\n\t\tstatus = nfserr_bad_stateid;\n\t\tif (stateid->si_generation > stid->sc_stateid.si_generation)\n\t\t\tgoto out_put_stid;\n\t\tif (layout_type != ls->ls_layout_type)\n\t\t\tgoto out_put_stid;\n\t}\n\n\t*lsp = ls;\n\treturn 0;\n\nout_put_stid:\n\tnfs4_put_stid(stid);\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\n__be32\nnfsd4_preprocess_layout_stateid(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, stateid_t *stateid,\n\t\tbool create, u32 layout_type, struct nfs4_layout_stateid **lsp)\n{\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_stid *stid;\n\tunsigned char typemask = NFS4_LAYOUT_STID;\n\t__be32 status;\n\n\tif (create)\n\t\ttypemask |= (NFS4_OPEN_STID | NFS4_LOCK_STID | NFS4_DELEG_STID);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &stid,\n\t\t\tnet_generic(SVC_NET(rqstp), nfsd_net_id));\n\tif (status)\n\t\tgoto out;\n\n\tif (!fh_match(&cstate->current_fh.fh_handle,\n\t\t      &stid->sc_file->fi_fhandle)) {\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out_put_stid;\n\t}\n\n\tif (stid->sc_type != NFS4_LAYOUT_STID) {\n\t\tls = nfsd4_alloc_layout_stateid(cstate, stid, layout_type);\n\t\tnfs4_put_stid(stid);\n\n\t\tstatus = nfserr_jukebox;\n\t\tif (!ls)\n\t\t\tgoto out;\n\t} else {\n\t\tls = container_of(stid, struct nfs4_layout_stateid, ls_stid);\n\n\t\tstatus = nfserr_bad_stateid;\n\t\tif (stateid->si_generation > stid->sc_stateid.si_generation)\n\t\t\tgoto out_put_stid;\n\t\tif (layout_type != ls->ls_layout_type)\n\t\t\tgoto out_put_stid;\n\t}\n\n\t*lsp = ls;\n\treturn 0;\n\nout_put_stid:\n\tnfs4_put_stid(stid);\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"pnfsd: layoutcommit beyond EOF\\n\""
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"pnfsd: last write beyond layout segment\\n\""
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"pnfsd: last write before layout segment\\n\""
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_layout_verify",
          "args": [
            "current_fh->fh_export",
            "lcp->lc_layout_type"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_layout_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "1184-1199",
          "snippet": "static const struct nfsd4_layout_ops *\nnfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_type) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (exp->ex_layout_type != layout_type) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\n\treturn nfsd4_layout_ops[layout_type];\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic const struct nfsd4_layout_ops *\nnfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_type) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (exp->ex_layout_type != layout_type) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\n\treturn nfsd4_layout_ops[layout_type];\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "current_fh",
            "0",
            "NFSD_MAY_WRITE"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_layoutcommit(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutcommit *lcp)\n{\n\tconst struct nfsd4_layout_seg *seg = &lcp->lc_seg;\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tconst struct nfsd4_layout_ops *ops;\n\tloff_t new_size = lcp->lc_last_wr + 1;\n\tstruct inode *inode;\n\tstruct nfs4_layout_stateid *ls;\n\t__be32 nfserr;\n\n\tnfserr = fh_verify(rqstp, current_fh, 0, NFSD_MAY_WRITE);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_layoutunavailable;\n\tops = nfsd4_layout_verify(current_fh->fh_export, lcp->lc_layout_type);\n\tif (!ops)\n\t\tgoto out;\n\tinode = current_fh->fh_dentry->d_inode;\n\n\tnfserr = nfserr_inval;\n\tif (new_size <= seg->offset) {\n\t\tdprintk(\"pnfsd: last write before layout segment\\n\");\n\t\tgoto out;\n\t}\n\tif (new_size > seg->offset + seg->length) {\n\t\tdprintk(\"pnfsd: last write beyond layout segment\\n\");\n\t\tgoto out;\n\t}\n\tif (!lcp->lc_newoffset && new_size > i_size_read(inode)) {\n\t\tdprintk(\"pnfsd: layoutcommit beyond EOF\\n\");\n\t\tgoto out;\n\t}\n\n\tnfserr = nfsd4_preprocess_layout_stateid(rqstp, cstate, &lcp->lc_sid,\n\t\t\t\t\t\tfalse, lcp->lc_layout_type,\n\t\t\t\t\t\t&ls);\n\tif (nfserr) {\n\t\ttrace_layout_commit_lookup_fail(&lcp->lc_sid);\n\t\t/* fixup error code as per RFC5661 */\n\t\tif (nfserr == nfserr_bad_stateid)\n\t\t\tnfserr = nfserr_badlayout;\n\t\tgoto out;\n\t}\n\n\tnfserr = ops->proc_layoutcommit(inode, lcp);\n\tif (nfserr)\n\t\tgoto out_put_stid;\n\n\tif (new_size > i_size_read(inode)) {\n\t\tlcp->lc_size_chg = 1;\n\t\tlcp->lc_newsize = new_size;\n\t} else {\n\t\tlcp->lc_size_chg = 0;\n\t}\n\nout_put_stid:\n\tnfs4_put_stid(&ls->ls_stid);\nout:\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_layoutget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1245-1322",
    "snippet": "static __be32\nnfsd4_layoutget(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tconst struct nfsd4_layout_ops *ops;\n\tstruct nfs4_layout_stateid *ls;\n\t__be32 nfserr;\n\tint accmode;\n\n\tswitch (lgp->lg_seg.iomode) {\n\tcase IOMODE_READ:\n\t\taccmode = NFSD_MAY_READ;\n\t\tbreak;\n\tcase IOMODE_RW:\n\t\taccmode = NFSD_MAY_READ | NFSD_MAY_WRITE;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: invalid iomode %d\\n\",\n\t\t\t__func__, lgp->lg_seg.iomode);\n\t\tnfserr = nfserr_badiomode;\n\t\tgoto out;\n\t}\n\n\tnfserr = fh_verify(rqstp, current_fh, 0, accmode);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_layoutunavailable;\n\tops = nfsd4_layout_verify(current_fh->fh_export, lgp->lg_layout_type);\n\tif (!ops)\n\t\tgoto out;\n\n\t/*\n\t * Verify minlength and range as per RFC5661:\n\t *  o  If loga_length is less than loga_minlength,\n\t *     the metadata server MUST return NFS4ERR_INVAL.\n\t *  o  If the sum of loga_offset and loga_minlength exceeds\n\t *     NFS4_UINT64_MAX, and loga_minlength is not\n\t *     NFS4_UINT64_MAX, the error NFS4ERR_INVAL MUST result.\n\t *  o  If the sum of loga_offset and loga_length exceeds\n\t *     NFS4_UINT64_MAX, and loga_length is not NFS4_UINT64_MAX,\n\t *     the error NFS4ERR_INVAL MUST result.\n\t */\n\tnfserr = nfserr_inval;\n\tif (lgp->lg_seg.length < lgp->lg_minlength ||\n\t    (lgp->lg_minlength != NFS4_MAX_UINT64 &&\n\t     lgp->lg_minlength > NFS4_MAX_UINT64 - lgp->lg_seg.offset) ||\n\t    (lgp->lg_seg.length != NFS4_MAX_UINT64 &&\n\t     lgp->lg_seg.length > NFS4_MAX_UINT64 - lgp->lg_seg.offset))\n\t\tgoto out;\n\tif (lgp->lg_seg.length == 0)\n\t\tgoto out;\n\n\tnfserr = nfsd4_preprocess_layout_stateid(rqstp, cstate, &lgp->lg_sid,\n\t\t\t\t\t\ttrue, lgp->lg_layout_type, &ls);\n\tif (nfserr) {\n\t\ttrace_layout_get_lookup_fail(&lgp->lg_sid);\n\t\tgoto out;\n\t}\n\n\tnfserr = nfserr_recallconflict;\n\tif (atomic_read(&ls->ls_stid.sc_file->fi_lo_recalls))\n\t\tgoto out_put_stid;\n\n\tnfserr = ops->proc_layoutget(current_fh->fh_dentry->d_inode,\n\t\t\t\t     current_fh, lgp);\n\tif (nfserr)\n\t\tgoto out_put_stid;\n\n\tnfserr = nfsd4_insert_layout(lgp, ls);\n\nout_put_stid:\n\tnfs4_put_stid(&ls->ls_stid);\nout:\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&ls->ls_stid"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "644-661",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_insert_layout",
          "args": [
            "lgp",
            "ls"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_insert_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "368-416",
          "snippet": "__be32\nnfsd4_insert_layout(struct nfsd4_layoutget *lgp, struct nfs4_layout_stateid *ls)\n{\n\tstruct nfsd4_layout_seg *seg = &lgp->lg_seg;\n\tstruct nfs4_file *fp = ls->ls_stid.sc_file;\n\tstruct nfs4_layout *lp, *new = NULL;\n\t__be32 nfserr;\n\n\tspin_lock(&fp->fi_lock);\n\tnfserr = nfsd4_recall_conflict(ls);\n\tif (nfserr)\n\t\tgoto out;\n\tspin_lock(&ls->ls_lock);\n\tlist_for_each_entry(lp, &ls->ls_layouts, lo_perstate) {\n\t\tif (layouts_try_merge(&lp->lo_seg, seg))\n\t\t\tgoto done;\n\t}\n\tspin_unlock(&ls->ls_lock);\n\tspin_unlock(&fp->fi_lock);\n\n\tnew = kmem_cache_alloc(nfs4_layout_cache, GFP_KERNEL);\n\tif (!new)\n\t\treturn nfserr_jukebox;\n\tmemcpy(&new->lo_seg, seg, sizeof(lp->lo_seg));\n\tnew->lo_state = ls;\n\n\tspin_lock(&fp->fi_lock);\n\tnfserr = nfsd4_recall_conflict(ls);\n\tif (nfserr)\n\t\tgoto out;\n\tspin_lock(&ls->ls_lock);\n\tlist_for_each_entry(lp, &ls->ls_layouts, lo_perstate) {\n\t\tif (layouts_try_merge(&lp->lo_seg, seg))\n\t\t\tgoto done;\n\t}\n\n\tatomic_inc(&ls->ls_stid.sc_count);\n\tlist_add_tail(&new->lo_perstate, &ls->ls_layouts);\n\tnew = NULL;\ndone:\n\tupdate_stateid(&ls->ls_stid.sc_stateid);\n\tmemcpy(&lgp->lg_sid, &ls->ls_stid.sc_stateid, sizeof(stateid_t));\n\tspin_unlock(&ls->ls_lock);\nout:\n\tspin_unlock(&fp->fi_lock);\n\tif (new)\n\t\tkmem_cache_free(nfs4_layout_cache, new);\n\treturn nfserr;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nfs4_layout_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic struct kmem_cache *nfs4_layout_cache;\n\n__be32\nnfsd4_insert_layout(struct nfsd4_layoutget *lgp, struct nfs4_layout_stateid *ls)\n{\n\tstruct nfsd4_layout_seg *seg = &lgp->lg_seg;\n\tstruct nfs4_file *fp = ls->ls_stid.sc_file;\n\tstruct nfs4_layout *lp, *new = NULL;\n\t__be32 nfserr;\n\n\tspin_lock(&fp->fi_lock);\n\tnfserr = nfsd4_recall_conflict(ls);\n\tif (nfserr)\n\t\tgoto out;\n\tspin_lock(&ls->ls_lock);\n\tlist_for_each_entry(lp, &ls->ls_layouts, lo_perstate) {\n\t\tif (layouts_try_merge(&lp->lo_seg, seg))\n\t\t\tgoto done;\n\t}\n\tspin_unlock(&ls->ls_lock);\n\tspin_unlock(&fp->fi_lock);\n\n\tnew = kmem_cache_alloc(nfs4_layout_cache, GFP_KERNEL);\n\tif (!new)\n\t\treturn nfserr_jukebox;\n\tmemcpy(&new->lo_seg, seg, sizeof(lp->lo_seg));\n\tnew->lo_state = ls;\n\n\tspin_lock(&fp->fi_lock);\n\tnfserr = nfsd4_recall_conflict(ls);\n\tif (nfserr)\n\t\tgoto out;\n\tspin_lock(&ls->ls_lock);\n\tlist_for_each_entry(lp, &ls->ls_layouts, lo_perstate) {\n\t\tif (layouts_try_merge(&lp->lo_seg, seg))\n\t\t\tgoto done;\n\t}\n\n\tatomic_inc(&ls->ls_stid.sc_count);\n\tlist_add_tail(&new->lo_perstate, &ls->ls_layouts);\n\tnew = NULL;\ndone:\n\tupdate_stateid(&ls->ls_stid.sc_stateid);\n\tmemcpy(&lgp->lg_sid, &ls->ls_stid.sc_stateid, sizeof(stateid_t));\n\tspin_unlock(&ls->ls_lock);\nout:\n\tspin_unlock(&fp->fi_lock);\n\tif (new)\n\t\tkmem_cache_free(nfs4_layout_cache, new);\n\treturn nfserr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->proc_layoutget",
          "args": [
            "current_fh->fh_dentry->d_inode",
            "current_fh",
            "lgp"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ls->ls_stid.sc_file->fi_lo_recalls"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_layout_get_lookup_fail",
          "args": [
            "&lgp->lg_sid"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_preprocess_layout_stateid",
          "args": [
            "rqstp",
            "cstate",
            "&lgp->lg_sid",
            "true",
            "lgp->lg_layout_type",
            "&ls"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_preprocess_layout_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "233-281",
          "snippet": "__be32\nnfsd4_preprocess_layout_stateid(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, stateid_t *stateid,\n\t\tbool create, u32 layout_type, struct nfs4_layout_stateid **lsp)\n{\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_stid *stid;\n\tunsigned char typemask = NFS4_LAYOUT_STID;\n\t__be32 status;\n\n\tif (create)\n\t\ttypemask |= (NFS4_OPEN_STID | NFS4_LOCK_STID | NFS4_DELEG_STID);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &stid,\n\t\t\tnet_generic(SVC_NET(rqstp), nfsd_net_id));\n\tif (status)\n\t\tgoto out;\n\n\tif (!fh_match(&cstate->current_fh.fh_handle,\n\t\t      &stid->sc_file->fi_fhandle)) {\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out_put_stid;\n\t}\n\n\tif (stid->sc_type != NFS4_LAYOUT_STID) {\n\t\tls = nfsd4_alloc_layout_stateid(cstate, stid, layout_type);\n\t\tnfs4_put_stid(stid);\n\n\t\tstatus = nfserr_jukebox;\n\t\tif (!ls)\n\t\t\tgoto out;\n\t} else {\n\t\tls = container_of(stid, struct nfs4_layout_stateid, ls_stid);\n\n\t\tstatus = nfserr_bad_stateid;\n\t\tif (stateid->si_generation > stid->sc_stateid.si_generation)\n\t\t\tgoto out_put_stid;\n\t\tif (layout_type != ls->ls_layout_type)\n\t\t\tgoto out_put_stid;\n\t}\n\n\t*lsp = ls;\n\treturn 0;\n\nout_put_stid:\n\tnfs4_put_stid(stid);\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\n__be32\nnfsd4_preprocess_layout_stateid(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, stateid_t *stateid,\n\t\tbool create, u32 layout_type, struct nfs4_layout_stateid **lsp)\n{\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_stid *stid;\n\tunsigned char typemask = NFS4_LAYOUT_STID;\n\t__be32 status;\n\n\tif (create)\n\t\ttypemask |= (NFS4_OPEN_STID | NFS4_LOCK_STID | NFS4_DELEG_STID);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &stid,\n\t\t\tnet_generic(SVC_NET(rqstp), nfsd_net_id));\n\tif (status)\n\t\tgoto out;\n\n\tif (!fh_match(&cstate->current_fh.fh_handle,\n\t\t      &stid->sc_file->fi_fhandle)) {\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out_put_stid;\n\t}\n\n\tif (stid->sc_type != NFS4_LAYOUT_STID) {\n\t\tls = nfsd4_alloc_layout_stateid(cstate, stid, layout_type);\n\t\tnfs4_put_stid(stid);\n\n\t\tstatus = nfserr_jukebox;\n\t\tif (!ls)\n\t\t\tgoto out;\n\t} else {\n\t\tls = container_of(stid, struct nfs4_layout_stateid, ls_stid);\n\n\t\tstatus = nfserr_bad_stateid;\n\t\tif (stateid->si_generation > stid->sc_stateid.si_generation)\n\t\t\tgoto out_put_stid;\n\t\tif (layout_type != ls->ls_layout_type)\n\t\t\tgoto out_put_stid;\n\t}\n\n\t*lsp = ls;\n\treturn 0;\n\nout_put_stid:\n\tnfs4_put_stid(stid);\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_layout_verify",
          "args": [
            "current_fh->fh_export",
            "lgp->lg_layout_type"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_layout_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "1184-1199",
          "snippet": "static const struct nfsd4_layout_ops *\nnfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_type) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (exp->ex_layout_type != layout_type) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\n\treturn nfsd4_layout_ops[layout_type];\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic const struct nfsd4_layout_ops *\nnfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_type) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (exp->ex_layout_type != layout_type) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\n\treturn nfsd4_layout_ops[layout_type];\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "current_fh",
            "0",
            "accmode"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: invalid iomode %d\\n\"",
            "__func__",
            "lgp->lg_seg.iomode"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_layoutget(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tconst struct nfsd4_layout_ops *ops;\n\tstruct nfs4_layout_stateid *ls;\n\t__be32 nfserr;\n\tint accmode;\n\n\tswitch (lgp->lg_seg.iomode) {\n\tcase IOMODE_READ:\n\t\taccmode = NFSD_MAY_READ;\n\t\tbreak;\n\tcase IOMODE_RW:\n\t\taccmode = NFSD_MAY_READ | NFSD_MAY_WRITE;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"%s: invalid iomode %d\\n\",\n\t\t\t__func__, lgp->lg_seg.iomode);\n\t\tnfserr = nfserr_badiomode;\n\t\tgoto out;\n\t}\n\n\tnfserr = fh_verify(rqstp, current_fh, 0, accmode);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_layoutunavailable;\n\tops = nfsd4_layout_verify(current_fh->fh_export, lgp->lg_layout_type);\n\tif (!ops)\n\t\tgoto out;\n\n\t/*\n\t * Verify minlength and range as per RFC5661:\n\t *  o  If loga_length is less than loga_minlength,\n\t *     the metadata server MUST return NFS4ERR_INVAL.\n\t *  o  If the sum of loga_offset and loga_minlength exceeds\n\t *     NFS4_UINT64_MAX, and loga_minlength is not\n\t *     NFS4_UINT64_MAX, the error NFS4ERR_INVAL MUST result.\n\t *  o  If the sum of loga_offset and loga_length exceeds\n\t *     NFS4_UINT64_MAX, and loga_length is not NFS4_UINT64_MAX,\n\t *     the error NFS4ERR_INVAL MUST result.\n\t */\n\tnfserr = nfserr_inval;\n\tif (lgp->lg_seg.length < lgp->lg_minlength ||\n\t    (lgp->lg_minlength != NFS4_MAX_UINT64 &&\n\t     lgp->lg_minlength > NFS4_MAX_UINT64 - lgp->lg_seg.offset) ||\n\t    (lgp->lg_seg.length != NFS4_MAX_UINT64 &&\n\t     lgp->lg_seg.length > NFS4_MAX_UINT64 - lgp->lg_seg.offset))\n\t\tgoto out;\n\tif (lgp->lg_seg.length == 0)\n\t\tgoto out;\n\n\tnfserr = nfsd4_preprocess_layout_stateid(rqstp, cstate, &lgp->lg_sid,\n\t\t\t\t\t\ttrue, lgp->lg_layout_type, &ls);\n\tif (nfserr) {\n\t\ttrace_layout_get_lookup_fail(&lgp->lg_sid);\n\t\tgoto out;\n\t}\n\n\tnfserr = nfserr_recallconflict;\n\tif (atomic_read(&ls->ls_stid.sc_file->fi_lo_recalls))\n\t\tgoto out_put_stid;\n\n\tnfserr = ops->proc_layoutget(current_fh->fh_dentry->d_inode,\n\t\t\t\t     current_fh, lgp);\n\tif (nfserr)\n\t\tgoto out_put_stid;\n\n\tnfserr = nfsd4_insert_layout(lgp, ls);\n\nout_put_stid:\n\tnfs4_put_stid(&ls->ls_stid);\nout:\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_getdeviceinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1201-1243",
    "snippet": "static __be32\nnfsd4_getdeviceinfo(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tconst struct nfsd4_layout_ops *ops;\n\tstruct nfsd4_deviceid_map *map;\n\tstruct svc_export *exp;\n\t__be32 nfserr;\n\n\tdprintk(\"%s: layout_type %u dev_id [0x%llx:0x%x] maxcnt %u\\n\",\n\t       __func__,\n\t       gdp->gd_layout_type,\n\t       gdp->gd_devid.fsid_idx, gdp->gd_devid.generation,\n\t       gdp->gd_maxcount);\n\n\tmap = nfsd4_find_devid_map(gdp->gd_devid.fsid_idx);\n\tif (!map) {\n\t\tdprintk(\"%s: couldn't find device ID to export mapping!\\n\",\n\t\t\t__func__);\n\t\treturn nfserr_noent;\n\t}\n\n\texp = rqst_exp_find(rqstp, map->fsid_type, map->fsid);\n\tif (IS_ERR(exp)) {\n\t\tdprintk(\"%s: could not find device id\\n\", __func__);\n\t\treturn nfserr_noent;\n\t}\n\n\tnfserr = nfserr_layoutunavailable;\n\tops = nfsd4_layout_verify(exp, gdp->gd_layout_type);\n\tif (!ops)\n\t\tgoto out;\n\n\tnfserr = nfs_ok;\n\tif (gdp->gd_maxcount != 0)\n\t\tnfserr = ops->proc_getdeviceinfo(exp->ex_path.mnt->mnt_sb, gdp);\n\n\tgdp->gd_notify_types &= ops->notify_types;\n\texp_put(exp);\nout:\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp_put",
          "args": [
            "exp"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "exp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.h",
          "lines": "101-104",
          "snippet": "static inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->proc_getdeviceinfo",
          "args": [
            "exp->ex_path.mnt->mnt_sb",
            "gdp"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_layout_verify",
          "args": [
            "exp",
            "gdp->gd_layout_type"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_layout_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "1184-1199",
          "snippet": "static const struct nfsd4_layout_ops *\nnfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_type) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (exp->ex_layout_type != layout_type) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\n\treturn nfsd4_layout_ops[layout_type];\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic const struct nfsd4_layout_ops *\nnfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_type) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (exp->ex_layout_type != layout_type) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\n\treturn nfsd4_layout_ops[layout_type];\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: could not find device id\\n\"",
            "__func__"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "exp"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rqst_exp_find",
          "args": [
            "rqstp",
            "map->fsid_type",
            "map->fsid"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "rqst_exp_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "1001-1032",
          "snippet": "struct svc_export *\nrqst_exp_find(struct svc_rqst *rqstp, int fsid_type, u32 *fsidv)\n{\n\tstruct svc_export *gssexp, *exp = ERR_PTR(-ENOENT);\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct cache_detail *cd = nn->svc_export_cache;\n\n\tif (rqstp->rq_client == NULL)\n\t\tgoto gss;\n\n\t/* First try the auth_unix client: */\n\texp = exp_find(cd, rqstp->rq_client, fsid_type,\n\t\t       fsidv, &rqstp->rq_chandle);\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\tgoto gss;\n\tif (IS_ERR(exp))\n\t\treturn exp;\n\t/* If it has secinfo, assume there are no gss/... clients */\n\tif (exp->ex_nflavors > 0)\n\t\treturn exp;\ngss:\n\t/* Otherwise, try falling back on gss client */\n\tif (rqstp->rq_gssclient == NULL)\n\t\treturn exp;\n\tgssexp = exp_find(cd, rqstp->rq_gssclient, fsid_type, fsidv,\n\t\t\t\t\t\t&rqstp->rq_chandle);\n\tif (PTR_ERR(gssexp) == -ENOENT)\n\t\treturn exp;\n\tif (!IS_ERR(exp))\n\t\texp_put(exp);\n\treturn gssexp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstruct svc_export *\nrqst_exp_find(struct svc_rqst *rqstp, int fsid_type, u32 *fsidv)\n{\n\tstruct svc_export *gssexp, *exp = ERR_PTR(-ENOENT);\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct cache_detail *cd = nn->svc_export_cache;\n\n\tif (rqstp->rq_client == NULL)\n\t\tgoto gss;\n\n\t/* First try the auth_unix client: */\n\texp = exp_find(cd, rqstp->rq_client, fsid_type,\n\t\t       fsidv, &rqstp->rq_chandle);\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\tgoto gss;\n\tif (IS_ERR(exp))\n\t\treturn exp;\n\t/* If it has secinfo, assume there are no gss/... clients */\n\tif (exp->ex_nflavors > 0)\n\t\treturn exp;\ngss:\n\t/* Otherwise, try falling back on gss client */\n\tif (rqstp->rq_gssclient == NULL)\n\t\treturn exp;\n\tgssexp = exp_find(cd, rqstp->rq_gssclient, fsid_type, fsidv,\n\t\t\t\t\t\t&rqstp->rq_chandle);\n\tif (PTR_ERR(gssexp) == -ENOENT)\n\t\treturn exp;\n\tif (!IS_ERR(exp))\n\t\texp_put(exp);\n\treturn gssexp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: couldn't find device ID to export mapping!\\n\"",
            "__func__"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_find_devid_map",
          "args": [
            "gdp->gd_devid.fsid_idx"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_find_devid_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "87-99",
          "snippet": "struct nfsd4_deviceid_map *\nnfsd4_find_devid_map(int idx)\n{\n\tstruct nfsd4_deviceid_map *map, *ret = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(map, &nfsd_devid_hash[devid_hashfn(idx)], hash)\n\t\tif (map->idx == idx)\n\t\t\tret = map;\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];\n\nstruct nfsd4_deviceid_map *\nnfsd4_find_devid_map(int idx)\n{\n\tstruct nfsd4_deviceid_map *map, *ret = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(map, &nfsd_devid_hash[devid_hashfn(idx)], hash)\n\t\tif (map->idx == idx)\n\t\t\tret = map;\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: layout_type %u dev_id [0x%llx:0x%x] maxcnt %u\\n\"",
            "__func__",
            "gdp->gd_layout_type",
            "gdp->gd_devid.fsid_idx",
            "gdp->gd_devid.generation",
            "gdp->gd_maxcount"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_getdeviceinfo(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tconst struct nfsd4_layout_ops *ops;\n\tstruct nfsd4_deviceid_map *map;\n\tstruct svc_export *exp;\n\t__be32 nfserr;\n\n\tdprintk(\"%s: layout_type %u dev_id [0x%llx:0x%x] maxcnt %u\\n\",\n\t       __func__,\n\t       gdp->gd_layout_type,\n\t       gdp->gd_devid.fsid_idx, gdp->gd_devid.generation,\n\t       gdp->gd_maxcount);\n\n\tmap = nfsd4_find_devid_map(gdp->gd_devid.fsid_idx);\n\tif (!map) {\n\t\tdprintk(\"%s: couldn't find device ID to export mapping!\\n\",\n\t\t\t__func__);\n\t\treturn nfserr_noent;\n\t}\n\n\texp = rqst_exp_find(rqstp, map->fsid_type, map->fsid);\n\tif (IS_ERR(exp)) {\n\t\tdprintk(\"%s: could not find device id\\n\", __func__);\n\t\treturn nfserr_noent;\n\t}\n\n\tnfserr = nfserr_layoutunavailable;\n\tops = nfsd4_layout_verify(exp, gdp->gd_layout_type);\n\tif (!ops)\n\t\tgoto out;\n\n\tnfserr = nfs_ok;\n\tif (gdp->gd_maxcount != 0)\n\t\tnfserr = ops->proc_getdeviceinfo(exp->ex_path.mnt->mnt_sb, gdp);\n\n\tgdp->gd_notify_types &= ops->notify_types;\n\texp_put(exp);\nout:\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_layout_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1184-1199",
    "snippet": "static const struct nfsd4_layout_ops *\nnfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_type) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (exp->ex_layout_type != layout_type) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\n\treturn nfsd4_layout_ops[layout_type];\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: layout type %d not supported\\n\"",
            "__func__",
            "layout_type"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: export does not support pNFS\\n\"",
            "__func__"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic const struct nfsd4_layout_ops *\nnfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_type) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (exp->ex_layout_type != layout_type) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\n\treturn nfsd4_layout_ops[layout_type];\n}"
  },
  {
    "function_name": "nfsd4_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1173-1181",
    "snippet": "static __be32\nnfsd4_verify(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_verify *verify)\n{\n\t__be32 status;\n\n\tstatus = _nfsd4_verify(rqstp, cstate, verify);\n\treturn status == nfserr_same ? nfs_ok : status;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_nfsd4_verify",
          "args": [
            "rqstp",
            "cstate",
            "verify"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "_nfsd4_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "1105-1161",
          "snippet": "static __be32\n_nfsd4_verify(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_verify *verify)\n{\n\t__be32 *buf, *p;\n\tint count;\n\t__be32 status;\n\n\tstatus = fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_NOP);\n\tif (status)\n\t\treturn status;\n\n\tstatus = check_attr_support(rqstp, cstate, verify->ve_bmval, NULL);\n\tif (status)\n\t\treturn status;\n\n\tif ((verify->ve_bmval[0] & FATTR4_WORD0_RDATTR_ERROR)\n\t    || (verify->ve_bmval[1] & NFSD_WRITEONLY_ATTRS_WORD1))\n\t\treturn nfserr_inval;\n\tif (verify->ve_attrlen & 3)\n\t\treturn nfserr_inval;\n\n\t/* count in words:\n\t *   bitmap_len(1) + bitmap(2) + attr_len(1) = 4\n\t */\n\tcount = 4 + (verify->ve_attrlen >> 2);\n\tbuf = kmalloc(count << 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn nfserr_jukebox;\n\n\tp = buf;\n\tstatus = nfsd4_encode_fattr_to_buf(&p, count, &cstate->current_fh,\n\t\t\t\t    cstate->current_fh.fh_export,\n\t\t\t\t    cstate->current_fh.fh_dentry,\n\t\t\t\t    verify->ve_bmval,\n\t\t\t\t    rqstp, 0);\n\t/*\n\t * If nfsd4_encode_fattr() ran out of space, assume that's because\n\t * the attributes are longer (hence different) than those given:\n\t */\n\tif (status == nfserr_resource)\n\t\tstatus = nfserr_not_same;\n\tif (status)\n\t\tgoto out_kfree;\n\n\t/* skip bitmap */\n\tp = buf + 1 + ntohl(buf[0]);\n\tstatus = nfserr_not_same;\n\tif (ntohl(*p++) != verify->ve_attrlen)\n\t\tgoto out_kfree;\n\tif (!memcmp(p, verify->ve_attrval, verify->ve_attrlen))\n\t\tstatus = nfserr_same;\n\nout_kfree:\n\tkfree(buf);\n\treturn status;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\n_nfsd4_verify(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_verify *verify)\n{\n\t__be32 *buf, *p;\n\tint count;\n\t__be32 status;\n\n\tstatus = fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_NOP);\n\tif (status)\n\t\treturn status;\n\n\tstatus = check_attr_support(rqstp, cstate, verify->ve_bmval, NULL);\n\tif (status)\n\t\treturn status;\n\n\tif ((verify->ve_bmval[0] & FATTR4_WORD0_RDATTR_ERROR)\n\t    || (verify->ve_bmval[1] & NFSD_WRITEONLY_ATTRS_WORD1))\n\t\treturn nfserr_inval;\n\tif (verify->ve_attrlen & 3)\n\t\treturn nfserr_inval;\n\n\t/* count in words:\n\t *   bitmap_len(1) + bitmap(2) + attr_len(1) = 4\n\t */\n\tcount = 4 + (verify->ve_attrlen >> 2);\n\tbuf = kmalloc(count << 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn nfserr_jukebox;\n\n\tp = buf;\n\tstatus = nfsd4_encode_fattr_to_buf(&p, count, &cstate->current_fh,\n\t\t\t\t    cstate->current_fh.fh_export,\n\t\t\t\t    cstate->current_fh.fh_dentry,\n\t\t\t\t    verify->ve_bmval,\n\t\t\t\t    rqstp, 0);\n\t/*\n\t * If nfsd4_encode_fattr() ran out of space, assume that's because\n\t * the attributes are longer (hence different) than those given:\n\t */\n\tif (status == nfserr_resource)\n\t\tstatus = nfserr_not_same;\n\tif (status)\n\t\tgoto out_kfree;\n\n\t/* skip bitmap */\n\tp = buf + 1 + ntohl(buf[0]);\n\tstatus = nfserr_not_same;\n\tif (ntohl(*p++) != verify->ve_attrlen)\n\t\tgoto out_kfree;\n\tif (!memcmp(p, verify->ve_attrval, verify->ve_attrlen))\n\t\tstatus = nfserr_same;\n\nout_kfree:\n\tkfree(buf);\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_verify(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_verify *verify)\n{\n\t__be32 status;\n\n\tstatus = _nfsd4_verify(rqstp, cstate, verify);\n\treturn status == nfserr_same ? nfs_ok : status;\n}"
  },
  {
    "function_name": "nfsd4_nverify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1163-1171",
    "snippet": "static __be32\nnfsd4_nverify(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      struct nfsd4_verify *verify)\n{\n\t__be32 status;\n\n\tstatus = _nfsd4_verify(rqstp, cstate, verify);\n\treturn status == nfserr_not_same ? nfs_ok : status;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_nfsd4_verify",
          "args": [
            "rqstp",
            "cstate",
            "verify"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "_nfsd4_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "1105-1161",
          "snippet": "static __be32\n_nfsd4_verify(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_verify *verify)\n{\n\t__be32 *buf, *p;\n\tint count;\n\t__be32 status;\n\n\tstatus = fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_NOP);\n\tif (status)\n\t\treturn status;\n\n\tstatus = check_attr_support(rqstp, cstate, verify->ve_bmval, NULL);\n\tif (status)\n\t\treturn status;\n\n\tif ((verify->ve_bmval[0] & FATTR4_WORD0_RDATTR_ERROR)\n\t    || (verify->ve_bmval[1] & NFSD_WRITEONLY_ATTRS_WORD1))\n\t\treturn nfserr_inval;\n\tif (verify->ve_attrlen & 3)\n\t\treturn nfserr_inval;\n\n\t/* count in words:\n\t *   bitmap_len(1) + bitmap(2) + attr_len(1) = 4\n\t */\n\tcount = 4 + (verify->ve_attrlen >> 2);\n\tbuf = kmalloc(count << 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn nfserr_jukebox;\n\n\tp = buf;\n\tstatus = nfsd4_encode_fattr_to_buf(&p, count, &cstate->current_fh,\n\t\t\t\t    cstate->current_fh.fh_export,\n\t\t\t\t    cstate->current_fh.fh_dentry,\n\t\t\t\t    verify->ve_bmval,\n\t\t\t\t    rqstp, 0);\n\t/*\n\t * If nfsd4_encode_fattr() ran out of space, assume that's because\n\t * the attributes are longer (hence different) than those given:\n\t */\n\tif (status == nfserr_resource)\n\t\tstatus = nfserr_not_same;\n\tif (status)\n\t\tgoto out_kfree;\n\n\t/* skip bitmap */\n\tp = buf + 1 + ntohl(buf[0]);\n\tstatus = nfserr_not_same;\n\tif (ntohl(*p++) != verify->ve_attrlen)\n\t\tgoto out_kfree;\n\tif (!memcmp(p, verify->ve_attrval, verify->ve_attrlen))\n\t\tstatus = nfserr_same;\n\nout_kfree:\n\tkfree(buf);\n\treturn status;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\n_nfsd4_verify(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_verify *verify)\n{\n\t__be32 *buf, *p;\n\tint count;\n\t__be32 status;\n\n\tstatus = fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_NOP);\n\tif (status)\n\t\treturn status;\n\n\tstatus = check_attr_support(rqstp, cstate, verify->ve_bmval, NULL);\n\tif (status)\n\t\treturn status;\n\n\tif ((verify->ve_bmval[0] & FATTR4_WORD0_RDATTR_ERROR)\n\t    || (verify->ve_bmval[1] & NFSD_WRITEONLY_ATTRS_WORD1))\n\t\treturn nfserr_inval;\n\tif (verify->ve_attrlen & 3)\n\t\treturn nfserr_inval;\n\n\t/* count in words:\n\t *   bitmap_len(1) + bitmap(2) + attr_len(1) = 4\n\t */\n\tcount = 4 + (verify->ve_attrlen >> 2);\n\tbuf = kmalloc(count << 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn nfserr_jukebox;\n\n\tp = buf;\n\tstatus = nfsd4_encode_fattr_to_buf(&p, count, &cstate->current_fh,\n\t\t\t\t    cstate->current_fh.fh_export,\n\t\t\t\t    cstate->current_fh.fh_dentry,\n\t\t\t\t    verify->ve_bmval,\n\t\t\t\t    rqstp, 0);\n\t/*\n\t * If nfsd4_encode_fattr() ran out of space, assume that's because\n\t * the attributes are longer (hence different) than those given:\n\t */\n\tif (status == nfserr_resource)\n\t\tstatus = nfserr_not_same;\n\tif (status)\n\t\tgoto out_kfree;\n\n\t/* skip bitmap */\n\tp = buf + 1 + ntohl(buf[0]);\n\tstatus = nfserr_not_same;\n\tif (ntohl(*p++) != verify->ve_attrlen)\n\t\tgoto out_kfree;\n\tif (!memcmp(p, verify->ve_attrval, verify->ve_attrlen))\n\t\tstatus = nfserr_same;\n\nout_kfree:\n\tkfree(buf);\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_nverify(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      struct nfsd4_verify *verify)\n{\n\t__be32 status;\n\n\tstatus = _nfsd4_verify(rqstp, cstate, verify);\n\treturn status == nfserr_not_same ? nfs_ok : status;\n}"
  },
  {
    "function_name": "_nfsd4_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1105-1161",
    "snippet": "static __be32\n_nfsd4_verify(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_verify *verify)\n{\n\t__be32 *buf, *p;\n\tint count;\n\t__be32 status;\n\n\tstatus = fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_NOP);\n\tif (status)\n\t\treturn status;\n\n\tstatus = check_attr_support(rqstp, cstate, verify->ve_bmval, NULL);\n\tif (status)\n\t\treturn status;\n\n\tif ((verify->ve_bmval[0] & FATTR4_WORD0_RDATTR_ERROR)\n\t    || (verify->ve_bmval[1] & NFSD_WRITEONLY_ATTRS_WORD1))\n\t\treturn nfserr_inval;\n\tif (verify->ve_attrlen & 3)\n\t\treturn nfserr_inval;\n\n\t/* count in words:\n\t *   bitmap_len(1) + bitmap(2) + attr_len(1) = 4\n\t */\n\tcount = 4 + (verify->ve_attrlen >> 2);\n\tbuf = kmalloc(count << 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn nfserr_jukebox;\n\n\tp = buf;\n\tstatus = nfsd4_encode_fattr_to_buf(&p, count, &cstate->current_fh,\n\t\t\t\t    cstate->current_fh.fh_export,\n\t\t\t\t    cstate->current_fh.fh_dentry,\n\t\t\t\t    verify->ve_bmval,\n\t\t\t\t    rqstp, 0);\n\t/*\n\t * If nfsd4_encode_fattr() ran out of space, assume that's because\n\t * the attributes are longer (hence different) than those given:\n\t */\n\tif (status == nfserr_resource)\n\t\tstatus = nfserr_not_same;\n\tif (status)\n\t\tgoto out_kfree;\n\n\t/* skip bitmap */\n\tp = buf + 1 + ntohl(buf[0]);\n\tstatus = nfserr_not_same;\n\tif (ntohl(*p++) != verify->ve_attrlen)\n\t\tgoto out_kfree;\n\tif (!memcmp(p, verify->ve_attrval, verify->ve_attrlen))\n\t\tstatus = nfserr_same;\n\nout_kfree:\n\tkfree(buf);\n\treturn status;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "p",
            "verify->ve_attrval",
            "verify->ve_attrlen"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "buf[0]"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_fattr_to_buf",
          "args": [
            "&p",
            "count",
            "&cstate->current_fh",
            "cstate->current_fh.fh_export",
            "cstate->current_fh.fh_dentry",
            "verify->ve_bmval",
            "rqstp",
            "0"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_fattr_to_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2761-2775",
          "snippet": "__be32 nfsd4_encode_fattr_to_buf(__be32 **p, int words,\n\t\t\tstruct svc_fh *fhp, struct svc_export *exp,\n\t\t\tstruct dentry *dentry, u32 *bmval,\n\t\t\tstruct svc_rqst *rqstp, int ignore_crossmnt)\n{\n\tstruct xdr_buf dummy;\n\tstruct xdr_stream xdr;\n\t__be32 ret;\n\n\tsvcxdr_init_encode_from_buffer(&xdr, &dummy, *p, words << 2);\n\tret = nfsd4_encode_fattr(&xdr, fhp, exp, dentry, bmval, rqstp,\n\t\t\t\t\t\t\tignore_crossmnt);\n\t*p = xdr.p;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n__be32 nfsd4_encode_fattr_to_buf(__be32 **p, int words,\n\t\t\tstruct svc_fh *fhp, struct svc_export *exp,\n\t\t\tstruct dentry *dentry, u32 *bmval,\n\t\t\tstruct svc_rqst *rqstp, int ignore_crossmnt)\n{\n\tstruct xdr_buf dummy;\n\tstruct xdr_stream xdr;\n\t__be32 ret;\n\n\tsvcxdr_init_encode_from_buffer(&xdr, &dummy, *p, words << 2);\n\tret = nfsd4_encode_fattr(&xdr, fhp, exp, dentry, bmval, rqstp,\n\t\t\t\t\t\t\tignore_crossmnt);\n\t*p = xdr.p;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "count << 2",
            "GFP_KERNEL"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_attr_support",
          "args": [
            "rqstp",
            "cstate",
            "verify->ve_bmval",
            "NULL"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "check_attr_support",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "93-127",
          "snippet": "static __be32\ncheck_attr_support(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   u32 *bmval, u32 *writable)\n{\n\tstruct dentry *dentry = cstate->current_fh.fh_dentry;\n\n\t/*\n\t * Check about attributes are supported by the NFSv4 server or not.\n\t * According to spec, unsupported attributes return ERR_ATTRNOTSUPP.\n\t */\n\tif ((bmval[0] & ~nfsd_suppattrs0(cstate->minorversion)) ||\n\t    (bmval[1] & ~nfsd_suppattrs1(cstate->minorversion)) ||\n\t    (bmval[2] & ~nfsd_suppattrs2(cstate->minorversion)))\n\t\treturn nfserr_attrnotsupp;\n\n\t/*\n\t * Check FATTR4_WORD0_ACL can be supported\n\t * in current environment or not.\n\t */\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tif (!IS_POSIXACL(dentry->d_inode))\n\t\t\treturn nfserr_attrnotsupp;\n\t}\n\n\t/*\n\t * According to spec, read-only attributes return ERR_INVAL.\n\t */\n\tif (writable) {\n\t\tif ((bmval[0] & ~writable[0]) || (bmval[1] & ~writable[1]) ||\n\t\t    (bmval[2] & ~writable[2]))\n\t\t\treturn nfserr_inval;\n\t}\n\n\treturn nfs_ok;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\ncheck_attr_support(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   u32 *bmval, u32 *writable)\n{\n\tstruct dentry *dentry = cstate->current_fh.fh_dentry;\n\n\t/*\n\t * Check about attributes are supported by the NFSv4 server or not.\n\t * According to spec, unsupported attributes return ERR_ATTRNOTSUPP.\n\t */\n\tif ((bmval[0] & ~nfsd_suppattrs0(cstate->minorversion)) ||\n\t    (bmval[1] & ~nfsd_suppattrs1(cstate->minorversion)) ||\n\t    (bmval[2] & ~nfsd_suppattrs2(cstate->minorversion)))\n\t\treturn nfserr_attrnotsupp;\n\n\t/*\n\t * Check FATTR4_WORD0_ACL can be supported\n\t * in current environment or not.\n\t */\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tif (!IS_POSIXACL(dentry->d_inode))\n\t\t\treturn nfserr_attrnotsupp;\n\t}\n\n\t/*\n\t * According to spec, read-only attributes return ERR_INVAL.\n\t */\n\tif (writable) {\n\t\tif ((bmval[0] & ~writable[0]) || (bmval[1] & ~writable[1]) ||\n\t\t    (bmval[2] & ~writable[2]))\n\t\t\treturn nfserr_inval;\n\t}\n\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "0",
            "NFSD_MAY_NOP"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\n_nfsd4_verify(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_verify *verify)\n{\n\t__be32 *buf, *p;\n\tint count;\n\t__be32 status;\n\n\tstatus = fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_NOP);\n\tif (status)\n\t\treturn status;\n\n\tstatus = check_attr_support(rqstp, cstate, verify->ve_bmval, NULL);\n\tif (status)\n\t\treturn status;\n\n\tif ((verify->ve_bmval[0] & FATTR4_WORD0_RDATTR_ERROR)\n\t    || (verify->ve_bmval[1] & NFSD_WRITEONLY_ATTRS_WORD1))\n\t\treturn nfserr_inval;\n\tif (verify->ve_attrlen & 3)\n\t\treturn nfserr_inval;\n\n\t/* count in words:\n\t *   bitmap_len(1) + bitmap(2) + attr_len(1) = 4\n\t */\n\tcount = 4 + (verify->ve_attrlen >> 2);\n\tbuf = kmalloc(count << 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn nfserr_jukebox;\n\n\tp = buf;\n\tstatus = nfsd4_encode_fattr_to_buf(&p, count, &cstate->current_fh,\n\t\t\t\t    cstate->current_fh.fh_export,\n\t\t\t\t    cstate->current_fh.fh_dentry,\n\t\t\t\t    verify->ve_bmval,\n\t\t\t\t    rqstp, 0);\n\t/*\n\t * If nfsd4_encode_fattr() ran out of space, assume that's because\n\t * the attributes are longer (hence different) than those given:\n\t */\n\tif (status == nfserr_resource)\n\t\tstatus = nfserr_not_same;\n\tif (status)\n\t\tgoto out_kfree;\n\n\t/* skip bitmap */\n\tp = buf + 1 + ntohl(buf[0]);\n\tstatus = nfserr_not_same;\n\tif (ntohl(*p++) != verify->ve_attrlen)\n\t\tgoto out_kfree;\n\tif (!memcmp(p, verify->ve_attrval, verify->ve_attrlen))\n\t\tstatus = nfserr_same;\n\nout_kfree:\n\tkfree(buf);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_seek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1057-1098",
    "snippet": "static __be32\nnfsd4_seek(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_seek *seek)\n{\n\tint whence;\n\t__be32 status;\n\tstruct file *file;\n\n\tstatus = nfs4_preprocess_stateid_op(SVC_NET(rqstp), cstate,\n\t\t\t\t\t    &seek->seek_stateid,\n\t\t\t\t\t    RD_STATE, &file);\n\tif (status) {\n\t\tdprintk(\"NFSD: nfsd4_seek: couldn't process stateid!\\n\");\n\t\treturn status;\n\t}\n\n\tswitch (seek->seek_whence) {\n\tcase NFS4_CONTENT_DATA:\n\t\twhence = SEEK_DATA;\n\t\tbreak;\n\tcase NFS4_CONTENT_HOLE:\n\t\twhence = SEEK_HOLE;\n\t\tbreak;\n\tdefault:\n\t\tstatus = nfserr_union_notsupp;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Note:  This call does change file->f_pos, but nothing in NFSD\n\t *        should ever file->f_pos.\n\t */\n\tseek->seek_pos = vfs_llseek(file, seek->seek_offset, whence);\n\tif (seek->seek_pos < 0)\n\t\tstatus = nfserrno(seek->seek_pos);\n\telse if (seek->seek_pos >= i_size_read(file_inode(file)))\n\t\tseek->seek_eof = true;\n\nout:\n\tfput(file);\n\treturn status;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "file_inode(file)"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "seek->seek_pos"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
          "lines": "708-758",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_llseek",
          "args": [
            "file",
            "seek->seek_offset",
            "whence"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_llseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "255-265",
          "snippet": "loff_t vfs_llseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t (*fn)(struct file *, loff_t, int);\n\n\tfn = no_llseek;\n\tif (file->f_mode & FMODE_LSEEK) {\n\t\tif (file->f_op->llseek)\n\t\t\tfn = file->f_op->llseek;\n\t}\n\treturn fn(file, offset, whence);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t vfs_llseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t (*fn)(struct file *, loff_t, int);\n\n\tfn = no_llseek;\n\tif (file->f_mode & FMODE_LSEEK) {\n\t\tif (file->f_op->llseek)\n\t\t\tfn = file->f_op->llseek;\n\t}\n\treturn fn(file, offset, whence);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfsd4_seek: couldn't process stateid!\\n\""
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_preprocess_stateid_op",
          "args": [
            "SVC_NET(rqstp)",
            "cstate",
            "&seek->seek_stateid",
            "RD_STATE",
            "&file"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_preprocess_stateid_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4468-4545",
          "snippet": "__be32\nnfs4_preprocess_stateid_op(struct net *net, struct nfsd4_compound_state *cstate,\n\t\t\t   stateid_t *stateid, int flags, struct file **filpp)\n{\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\tstruct nfs4_delegation *dp = NULL;\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct inode *ino = current_fh->fh_dentry->d_inode;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct file *file = NULL;\n\t__be32 status;\n\n\tif (filpp)\n\t\t*filpp = NULL;\n\n\tif (grace_disallows_io(net, ino))\n\t\treturn nfserr_grace;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn check_special_stateids(net, current_fh, stateid, flags);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid,\n\t\t\t\tNFS4_DELEG_STID|NFS4_OPEN_STID|NFS4_LOCK_STID,\n\t\t\t\t&s, nn);\n\tif (status)\n\t\treturn status;\n\tstatus = check_stateid_generation(stateid, &s->sc_stateid, nfsd4_has_session(cstate));\n\tif (status)\n\t\tgoto out;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tdp = delegstateid(s);\n\t\tstatus = nfs4_check_delegmode(dp, flags);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (filpp) {\n\t\t\tfile = dp->dl_stid.sc_file->fi_deleg_file;\n\t\t\tif (!file) {\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\tstatus = nfserr_serverfault;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tget_file(file);\n\t\t}\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tstp = openlockstateid(s);\n\t\tstatus = nfs4_check_fh(current_fh, stp);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (stp->st_stateowner->so_is_open_owner\n\t\t    && !(openowner(stp->st_stateowner)->oo_flags & NFS4_OO_CONFIRMED))\n\t\t\tgoto out;\n\t\tstatus = nfs4_check_openmode(stp, flags);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (filpp) {\n\t\t\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\t\t\tif (flags & RD_STATE)\n\t\t\t\tfile = find_readable_file(fp);\n\t\t\telse\n\t\t\t\tfile = find_writeable_file(fp);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\n\tif (file)\n\t\t*filpp = file;\nout:\n\tnfs4_put_stid(s);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfs4_preprocess_stateid_op(struct net *net, struct nfsd4_compound_state *cstate,\n\t\t\t   stateid_t *stateid, int flags, struct file **filpp)\n{\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\tstruct nfs4_delegation *dp = NULL;\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct inode *ino = current_fh->fh_dentry->d_inode;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct file *file = NULL;\n\t__be32 status;\n\n\tif (filpp)\n\t\t*filpp = NULL;\n\n\tif (grace_disallows_io(net, ino))\n\t\treturn nfserr_grace;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn check_special_stateids(net, current_fh, stateid, flags);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid,\n\t\t\t\tNFS4_DELEG_STID|NFS4_OPEN_STID|NFS4_LOCK_STID,\n\t\t\t\t&s, nn);\n\tif (status)\n\t\treturn status;\n\tstatus = check_stateid_generation(stateid, &s->sc_stateid, nfsd4_has_session(cstate));\n\tif (status)\n\t\tgoto out;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tdp = delegstateid(s);\n\t\tstatus = nfs4_check_delegmode(dp, flags);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (filpp) {\n\t\t\tfile = dp->dl_stid.sc_file->fi_deleg_file;\n\t\t\tif (!file) {\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\tstatus = nfserr_serverfault;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tget_file(file);\n\t\t}\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tstp = openlockstateid(s);\n\t\tstatus = nfs4_check_fh(current_fh, stp);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (stp->st_stateowner->so_is_open_owner\n\t\t    && !(openowner(stp->st_stateowner)->oo_flags & NFS4_OO_CONFIRMED))\n\t\t\tgoto out;\n\t\tstatus = nfs4_check_openmode(stp, flags);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (filpp) {\n\t\t\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\t\t\tif (flags & RD_STATE)\n\t\t\t\tfile = find_readable_file(fp);\n\t\t\telse\n\t\t\t\tfile = find_writeable_file(fp);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\n\tif (file)\n\t\t*filpp = file;\nout:\n\tnfs4_put_stid(s);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_seek(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_seek *seek)\n{\n\tint whence;\n\t__be32 status;\n\tstruct file *file;\n\n\tstatus = nfs4_preprocess_stateid_op(SVC_NET(rqstp), cstate,\n\t\t\t\t\t    &seek->seek_stateid,\n\t\t\t\t\t    RD_STATE, &file);\n\tif (status) {\n\t\tdprintk(\"NFSD: nfsd4_seek: couldn't process stateid!\\n\");\n\t\treturn status;\n\t}\n\n\tswitch (seek->seek_whence) {\n\tcase NFS4_CONTENT_DATA:\n\t\twhence = SEEK_DATA;\n\t\tbreak;\n\tcase NFS4_CONTENT_HOLE:\n\t\twhence = SEEK_HOLE;\n\t\tbreak;\n\tdefault:\n\t\tstatus = nfserr_union_notsupp;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Note:  This call does change file->f_pos, but nothing in NFSD\n\t *        should ever file->f_pos.\n\t */\n\tseek->seek_pos = vfs_llseek(file, seek->seek_offset, whence);\n\tif (seek->seek_pos < 0)\n\t\tstatus = nfserrno(seek->seek_pos);\n\telse if (seek->seek_pos >= i_size_read(file_inode(file)))\n\t\tseek->seek_eof = true;\n\nout:\n\tfput(file);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_deallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1049-1055",
    "snippet": "static __be32\nnfsd4_deallocate(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t struct nfsd4_fallocate *fallocate)\n{\n\treturn nfsd4_fallocate(rqstp, cstate, fallocate,\n\t\t\t       FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_fallocate",
          "args": [
            "rqstp",
            "cstate",
            "fallocate",
            "FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_fallocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "1019-1040",
          "snippet": "static __be32\nnfsd4_fallocate(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_fallocate *fallocate, int flags)\n{\n\t__be32 status = nfserr_notsupp;\n\tstruct file *file;\n\n\tstatus = nfs4_preprocess_stateid_op(SVC_NET(rqstp), cstate,\n\t\t\t\t\t    &fallocate->falloc_stateid,\n\t\t\t\t\t    WR_STATE, &file);\n\tif (status != nfs_ok) {\n\t\tdprintk(\"NFSD: nfsd4_fallocate: couldn't process stateid!\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = nfsd4_vfs_fallocate(rqstp, &cstate->current_fh, file,\n\t\t\t\t     fallocate->falloc_offset,\n\t\t\t\t     fallocate->falloc_length,\n\t\t\t\t     flags);\n\tfput(file);\n\treturn status;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_fallocate(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_fallocate *fallocate, int flags)\n{\n\t__be32 status = nfserr_notsupp;\n\tstruct file *file;\n\n\tstatus = nfs4_preprocess_stateid_op(SVC_NET(rqstp), cstate,\n\t\t\t\t\t    &fallocate->falloc_stateid,\n\t\t\t\t\t    WR_STATE, &file);\n\tif (status != nfs_ok) {\n\t\tdprintk(\"NFSD: nfsd4_fallocate: couldn't process stateid!\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = nfsd4_vfs_fallocate(rqstp, &cstate->current_fh, file,\n\t\t\t\t     fallocate->falloc_offset,\n\t\t\t\t     fallocate->falloc_length,\n\t\t\t\t     flags);\n\tfput(file);\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_deallocate(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t struct nfsd4_fallocate *fallocate)\n{\n\treturn nfsd4_fallocate(rqstp, cstate, fallocate,\n\t\t\t       FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE);\n}"
  },
  {
    "function_name": "nfsd4_allocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1042-1047",
    "snippet": "static __be32\nnfsd4_allocate(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t       struct nfsd4_fallocate *fallocate)\n{\n\treturn nfsd4_fallocate(rqstp, cstate, fallocate, 0);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_fallocate",
          "args": [
            "rqstp",
            "cstate",
            "fallocate",
            "0"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_fallocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "1019-1040",
          "snippet": "static __be32\nnfsd4_fallocate(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_fallocate *fallocate, int flags)\n{\n\t__be32 status = nfserr_notsupp;\n\tstruct file *file;\n\n\tstatus = nfs4_preprocess_stateid_op(SVC_NET(rqstp), cstate,\n\t\t\t\t\t    &fallocate->falloc_stateid,\n\t\t\t\t\t    WR_STATE, &file);\n\tif (status != nfs_ok) {\n\t\tdprintk(\"NFSD: nfsd4_fallocate: couldn't process stateid!\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = nfsd4_vfs_fallocate(rqstp, &cstate->current_fh, file,\n\t\t\t\t     fallocate->falloc_offset,\n\t\t\t\t     fallocate->falloc_length,\n\t\t\t\t     flags);\n\tfput(file);\n\treturn status;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_fallocate(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_fallocate *fallocate, int flags)\n{\n\t__be32 status = nfserr_notsupp;\n\tstruct file *file;\n\n\tstatus = nfs4_preprocess_stateid_op(SVC_NET(rqstp), cstate,\n\t\t\t\t\t    &fallocate->falloc_stateid,\n\t\t\t\t\t    WR_STATE, &file);\n\tif (status != nfs_ok) {\n\t\tdprintk(\"NFSD: nfsd4_fallocate: couldn't process stateid!\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = nfsd4_vfs_fallocate(rqstp, &cstate->current_fh, file,\n\t\t\t\t     fallocate->falloc_offset,\n\t\t\t\t     fallocate->falloc_length,\n\t\t\t\t     flags);\n\tfput(file);\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_allocate(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t       struct nfsd4_fallocate *fallocate)\n{\n\treturn nfsd4_fallocate(rqstp, cstate, fallocate, 0);\n}"
  },
  {
    "function_name": "nfsd4_fallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "1019-1040",
    "snippet": "static __be32\nnfsd4_fallocate(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_fallocate *fallocate, int flags)\n{\n\t__be32 status = nfserr_notsupp;\n\tstruct file *file;\n\n\tstatus = nfs4_preprocess_stateid_op(SVC_NET(rqstp), cstate,\n\t\t\t\t\t    &fallocate->falloc_stateid,\n\t\t\t\t\t    WR_STATE, &file);\n\tif (status != nfs_ok) {\n\t\tdprintk(\"NFSD: nfsd4_fallocate: couldn't process stateid!\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = nfsd4_vfs_fallocate(rqstp, &cstate->current_fh, file,\n\t\t\t\t     fallocate->falloc_offset,\n\t\t\t\t     fallocate->falloc_length,\n\t\t\t\t     flags);\n\tfput(file);\n\treturn status;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_vfs_fallocate",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "file",
            "fallocate->falloc_offset",
            "fallocate->falloc_length",
            "flags"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_vfs_fallocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "537-556",
          "snippet": "__be32 nfsd4_vfs_fallocate(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t\t   struct file *file, loff_t offset, loff_t len,\n\t\t\t   int flags)\n{\n\t__be32 err;\n\tint error;\n\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\treturn nfserr_inval;\n\n\terr = nfsd_permission(rqstp, fhp->fh_export, fhp->fh_dentry, NFSD_MAY_WRITE);\n\tif (err)\n\t\treturn err;\n\n\terror = vfs_fallocate(file, flags, offset, len);\n\tif (!error)\n\t\terror = commit_metadata(fhp);\n\n\treturn nfserrno(error);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32 nfsd4_vfs_fallocate(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t\t   struct file *file, loff_t offset, loff_t len,\n\t\t\t   int flags)\n{\n\t__be32 err;\n\tint error;\n\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\treturn nfserr_inval;\n\n\terr = nfsd_permission(rqstp, fhp->fh_export, fhp->fh_dentry, NFSD_MAY_WRITE);\n\tif (err)\n\t\treturn err;\n\n\terror = vfs_fallocate(file, flags, offset, len);\n\tif (!error)\n\t\terror = commit_metadata(fhp);\n\n\treturn nfserrno(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfsd4_fallocate: couldn't process stateid!\\n\""
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_preprocess_stateid_op",
          "args": [
            "SVC_NET(rqstp)",
            "cstate",
            "&fallocate->falloc_stateid",
            "WR_STATE",
            "&file"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_preprocess_stateid_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4468-4545",
          "snippet": "__be32\nnfs4_preprocess_stateid_op(struct net *net, struct nfsd4_compound_state *cstate,\n\t\t\t   stateid_t *stateid, int flags, struct file **filpp)\n{\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\tstruct nfs4_delegation *dp = NULL;\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct inode *ino = current_fh->fh_dentry->d_inode;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct file *file = NULL;\n\t__be32 status;\n\n\tif (filpp)\n\t\t*filpp = NULL;\n\n\tif (grace_disallows_io(net, ino))\n\t\treturn nfserr_grace;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn check_special_stateids(net, current_fh, stateid, flags);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid,\n\t\t\t\tNFS4_DELEG_STID|NFS4_OPEN_STID|NFS4_LOCK_STID,\n\t\t\t\t&s, nn);\n\tif (status)\n\t\treturn status;\n\tstatus = check_stateid_generation(stateid, &s->sc_stateid, nfsd4_has_session(cstate));\n\tif (status)\n\t\tgoto out;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tdp = delegstateid(s);\n\t\tstatus = nfs4_check_delegmode(dp, flags);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (filpp) {\n\t\t\tfile = dp->dl_stid.sc_file->fi_deleg_file;\n\t\t\tif (!file) {\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\tstatus = nfserr_serverfault;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tget_file(file);\n\t\t}\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tstp = openlockstateid(s);\n\t\tstatus = nfs4_check_fh(current_fh, stp);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (stp->st_stateowner->so_is_open_owner\n\t\t    && !(openowner(stp->st_stateowner)->oo_flags & NFS4_OO_CONFIRMED))\n\t\t\tgoto out;\n\t\tstatus = nfs4_check_openmode(stp, flags);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (filpp) {\n\t\t\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\t\t\tif (flags & RD_STATE)\n\t\t\t\tfile = find_readable_file(fp);\n\t\t\telse\n\t\t\t\tfile = find_writeable_file(fp);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\n\tif (file)\n\t\t*filpp = file;\nout:\n\tnfs4_put_stid(s);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfs4_preprocess_stateid_op(struct net *net, struct nfsd4_compound_state *cstate,\n\t\t\t   stateid_t *stateid, int flags, struct file **filpp)\n{\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\tstruct nfs4_delegation *dp = NULL;\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct inode *ino = current_fh->fh_dentry->d_inode;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct file *file = NULL;\n\t__be32 status;\n\n\tif (filpp)\n\t\t*filpp = NULL;\n\n\tif (grace_disallows_io(net, ino))\n\t\treturn nfserr_grace;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn check_special_stateids(net, current_fh, stateid, flags);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid,\n\t\t\t\tNFS4_DELEG_STID|NFS4_OPEN_STID|NFS4_LOCK_STID,\n\t\t\t\t&s, nn);\n\tif (status)\n\t\treturn status;\n\tstatus = check_stateid_generation(stateid, &s->sc_stateid, nfsd4_has_session(cstate));\n\tif (status)\n\t\tgoto out;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tdp = delegstateid(s);\n\t\tstatus = nfs4_check_delegmode(dp, flags);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (filpp) {\n\t\t\tfile = dp->dl_stid.sc_file->fi_deleg_file;\n\t\t\tif (!file) {\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\tstatus = nfserr_serverfault;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tget_file(file);\n\t\t}\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tstp = openlockstateid(s);\n\t\tstatus = nfs4_check_fh(current_fh, stp);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (stp->st_stateowner->so_is_open_owner\n\t\t    && !(openowner(stp->st_stateowner)->oo_flags & NFS4_OO_CONFIRMED))\n\t\t\tgoto out;\n\t\tstatus = nfs4_check_openmode(stp, flags);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (filpp) {\n\t\t\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\t\t\tif (flags & RD_STATE)\n\t\t\t\tfile = find_readable_file(fp);\n\t\t\telse\n\t\t\t\tfile = find_writeable_file(fp);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\n\tif (file)\n\t\t*filpp = file;\nout:\n\tnfs4_put_stid(s);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_fallocate(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_fallocate *fallocate, int flags)\n{\n\t__be32 status = nfserr_notsupp;\n\tstruct file *file;\n\n\tstatus = nfs4_preprocess_stateid_op(SVC_NET(rqstp), cstate,\n\t\t\t\t\t    &fallocate->falloc_stateid,\n\t\t\t\t\t    WR_STATE, &file);\n\tif (status != nfs_ok) {\n\t\tdprintk(\"NFSD: nfsd4_fallocate: couldn't process stateid!\\n\");\n\t\treturn status;\n\t}\n\n\tstatus = nfsd4_vfs_fallocate(rqstp, &cstate->current_fh, file,\n\t\t\t\t     fallocate->falloc_offset,\n\t\t\t\t     fallocate->falloc_length,\n\t\t\t\t     flags);\n\tfput(file);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "979-1017",
    "snippet": "static __be32\nnfsd4_write(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct nfsd4_write *write)\n{\n\tstateid_t *stateid = &write->wr_stateid;\n\tstruct file *filp = NULL;\n\t__be32 status = nfs_ok;\n\tunsigned long cnt;\n\tint nvecs;\n\n\t/* no need to check permission - this will be done in nfsd_write() */\n\n\tif (write->wr_offset >= OFFSET_MAX)\n\t\treturn nfserr_inval;\n\n\tstatus = nfs4_preprocess_stateid_op(SVC_NET(rqstp),\n\t\t\t\t\tcstate, stateid, WR_STATE, &filp);\n\tif (status) {\n\t\tdprintk(\"NFSD: nfsd4_write: couldn't process stateid!\\n\");\n\t\treturn status;\n\t}\n\n\tcnt = write->wr_buflen;\n\twrite->wr_how_written = write->wr_stable_how;\n\tgen_boot_verifier(&write->wr_verifier, SVC_NET(rqstp));\n\n\tnvecs = fill_in_write_vector(rqstp->rq_vec, write);\n\tWARN_ON_ONCE(nvecs > ARRAY_SIZE(rqstp->rq_vec));\n\n\tstatus =  nfsd_write(rqstp, &cstate->current_fh, filp,\n\t\t\t     write->wr_offset, rqstp->rq_vec, nvecs,\n\t\t\t     &cnt, &write->wr_how_written);\n\tif (filp)\n\t\tfput(filp);\n\n\twrite->wr_bytes_written = cnt;\n\n\treturn status;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "filp"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_write",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "filp",
            "write->wr_offset",
            "rqstp->rq_vec",
            "nvecs",
            "&cnt",
            "&write->wr_how_written"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "1074-1100",
          "snippet": "__be32\nnfsd_write(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file *file,\n\t\tloff_t offset, struct kvec *vec, int vlen, unsigned long *cnt,\n\t\tint *stablep)\n{\n\t__be32\t\t\terr = 0;\n\n\tif (file) {\n\t\terr = nfsd_permission(rqstp, fhp->fh_export, fhp->fh_dentry,\n\t\t\t\tNFSD_MAY_WRITE|NFSD_MAY_OWNER_OVERRIDE);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = nfsd_vfs_write(rqstp, fhp, file, offset, vec, vlen, cnt,\n\t\t\t\tstablep);\n\t} else {\n\t\terr = nfsd_open(rqstp, fhp, S_IFREG, NFSD_MAY_WRITE, &file);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (cnt)\n\t\t\terr = nfsd_vfs_write(rqstp, fhp, file, offset, vec, vlen,\n\t\t\t\t\t     cnt, stablep);\n\t\tnfsd_close(file);\n\t}\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_write(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file *file,\n\t\tloff_t offset, struct kvec *vec, int vlen, unsigned long *cnt,\n\t\tint *stablep)\n{\n\t__be32\t\t\terr = 0;\n\n\tif (file) {\n\t\terr = nfsd_permission(rqstp, fhp->fh_export, fhp->fh_dentry,\n\t\t\t\tNFSD_MAY_WRITE|NFSD_MAY_OWNER_OVERRIDE);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = nfsd_vfs_write(rqstp, fhp, file, offset, vec, vlen, cnt,\n\t\t\t\tstablep);\n\t} else {\n\t\terr = nfsd_open(rqstp, fhp, S_IFREG, NFSD_MAY_WRITE, &file);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (cnt)\n\t\t\terr = nfsd_vfs_write(rqstp, fhp, file, offset, vec, vlen,\n\t\t\t\t\t     cnt, stablep);\n\t\tnfsd_close(file);\n\t}\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "nvecs > ARRAY_SIZE(rqstp->rq_vec)"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "rqstp->rq_vec"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_in_write_vector",
          "args": [
            "rqstp->rq_vec",
            "write"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "fill_in_write_vector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "961-977",
          "snippet": "static int fill_in_write_vector(struct kvec *vec, struct nfsd4_write *write)\n{\n        int i = 1;\n        int buflen = write->wr_buflen;\n\n        vec[0].iov_base = write->wr_head.iov_base;\n        vec[0].iov_len = min_t(int, buflen, write->wr_head.iov_len);\n        buflen -= vec[0].iov_len;\n\n        while (buflen) {\n                vec[i].iov_base = page_address(write->wr_pagelist[i - 1]);\n                vec[i].iov_len = min_t(int, PAGE_SIZE, buflen);\n                buflen -= vec[i].iov_len;\n                i++;\n        }\n        return i;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic int fill_in_write_vector(struct kvec *vec, struct nfsd4_write *write)\n{\n        int i = 1;\n        int buflen = write->wr_buflen;\n\n        vec[0].iov_base = write->wr_head.iov_base;\n        vec[0].iov_len = min_t(int, buflen, write->wr_head.iov_len);\n        buflen -= vec[0].iov_len;\n\n        while (buflen) {\n                vec[i].iov_base = page_address(write->wr_pagelist[i - 1]);\n                vec[i].iov_len = min_t(int, PAGE_SIZE, buflen);\n                buflen -= vec[i].iov_len;\n                i++;\n        }\n        return i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen_boot_verifier",
          "args": [
            "&write->wr_verifier",
            "SVC_NET(rqstp)"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "gen_boot_verifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "577-589",
          "snippet": "static void gen_boot_verifier(nfs4_verifier *verifier, struct net *net)\n{\n\t__be32 verf[2];\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\t/*\n\t * This is opaque to client, so no need to byte-swap. Use\n\t * __force to keep sparse happy\n\t */\n\tverf[0] = (__force __be32)nn->nfssvc_boot.tv_sec;\n\tverf[1] = (__force __be32)nn->nfssvc_boot.tv_usec;\n\tmemcpy(verifier->data, verf, sizeof(verifier->data));\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic void gen_boot_verifier(nfs4_verifier *verifier, struct net *net)\n{\n\t__be32 verf[2];\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\t/*\n\t * This is opaque to client, so no need to byte-swap. Use\n\t * __force to keep sparse happy\n\t */\n\tverf[0] = (__force __be32)nn->nfssvc_boot.tv_sec;\n\tverf[1] = (__force __be32)nn->nfssvc_boot.tv_usec;\n\tmemcpy(verifier->data, verf, sizeof(verifier->data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfsd4_write: couldn't process stateid!\\n\""
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_preprocess_stateid_op",
          "args": [
            "SVC_NET(rqstp)",
            "cstate",
            "stateid",
            "WR_STATE",
            "&filp"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_preprocess_stateid_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4468-4545",
          "snippet": "__be32\nnfs4_preprocess_stateid_op(struct net *net, struct nfsd4_compound_state *cstate,\n\t\t\t   stateid_t *stateid, int flags, struct file **filpp)\n{\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\tstruct nfs4_delegation *dp = NULL;\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct inode *ino = current_fh->fh_dentry->d_inode;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct file *file = NULL;\n\t__be32 status;\n\n\tif (filpp)\n\t\t*filpp = NULL;\n\n\tif (grace_disallows_io(net, ino))\n\t\treturn nfserr_grace;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn check_special_stateids(net, current_fh, stateid, flags);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid,\n\t\t\t\tNFS4_DELEG_STID|NFS4_OPEN_STID|NFS4_LOCK_STID,\n\t\t\t\t&s, nn);\n\tif (status)\n\t\treturn status;\n\tstatus = check_stateid_generation(stateid, &s->sc_stateid, nfsd4_has_session(cstate));\n\tif (status)\n\t\tgoto out;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tdp = delegstateid(s);\n\t\tstatus = nfs4_check_delegmode(dp, flags);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (filpp) {\n\t\t\tfile = dp->dl_stid.sc_file->fi_deleg_file;\n\t\t\tif (!file) {\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\tstatus = nfserr_serverfault;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tget_file(file);\n\t\t}\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tstp = openlockstateid(s);\n\t\tstatus = nfs4_check_fh(current_fh, stp);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (stp->st_stateowner->so_is_open_owner\n\t\t    && !(openowner(stp->st_stateowner)->oo_flags & NFS4_OO_CONFIRMED))\n\t\t\tgoto out;\n\t\tstatus = nfs4_check_openmode(stp, flags);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (filpp) {\n\t\t\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\t\t\tif (flags & RD_STATE)\n\t\t\t\tfile = find_readable_file(fp);\n\t\t\telse\n\t\t\t\tfile = find_writeable_file(fp);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\n\tif (file)\n\t\t*filpp = file;\nout:\n\tnfs4_put_stid(s);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfs4_preprocess_stateid_op(struct net *net, struct nfsd4_compound_state *cstate,\n\t\t\t   stateid_t *stateid, int flags, struct file **filpp)\n{\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\tstruct nfs4_delegation *dp = NULL;\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct inode *ino = current_fh->fh_dentry->d_inode;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct file *file = NULL;\n\t__be32 status;\n\n\tif (filpp)\n\t\t*filpp = NULL;\n\n\tif (grace_disallows_io(net, ino))\n\t\treturn nfserr_grace;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn check_special_stateids(net, current_fh, stateid, flags);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid,\n\t\t\t\tNFS4_DELEG_STID|NFS4_OPEN_STID|NFS4_LOCK_STID,\n\t\t\t\t&s, nn);\n\tif (status)\n\t\treturn status;\n\tstatus = check_stateid_generation(stateid, &s->sc_stateid, nfsd4_has_session(cstate));\n\tif (status)\n\t\tgoto out;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tdp = delegstateid(s);\n\t\tstatus = nfs4_check_delegmode(dp, flags);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (filpp) {\n\t\t\tfile = dp->dl_stid.sc_file->fi_deleg_file;\n\t\t\tif (!file) {\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\tstatus = nfserr_serverfault;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tget_file(file);\n\t\t}\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tstp = openlockstateid(s);\n\t\tstatus = nfs4_check_fh(current_fh, stp);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (stp->st_stateowner->so_is_open_owner\n\t\t    && !(openowner(stp->st_stateowner)->oo_flags & NFS4_OO_CONFIRMED))\n\t\t\tgoto out;\n\t\tstatus = nfs4_check_openmode(stp, flags);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (filpp) {\n\t\t\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\t\t\tif (flags & RD_STATE)\n\t\t\t\tfile = find_readable_file(fp);\n\t\t\telse\n\t\t\t\tfile = find_writeable_file(fp);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\n\tif (file)\n\t\t*filpp = file;\nout:\n\tnfs4_put_stid(s);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_write(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct nfsd4_write *write)\n{\n\tstateid_t *stateid = &write->wr_stateid;\n\tstruct file *filp = NULL;\n\t__be32 status = nfs_ok;\n\tunsigned long cnt;\n\tint nvecs;\n\n\t/* no need to check permission - this will be done in nfsd_write() */\n\n\tif (write->wr_offset >= OFFSET_MAX)\n\t\treturn nfserr_inval;\n\n\tstatus = nfs4_preprocess_stateid_op(SVC_NET(rqstp),\n\t\t\t\t\tcstate, stateid, WR_STATE, &filp);\n\tif (status) {\n\t\tdprintk(\"NFSD: nfsd4_write: couldn't process stateid!\\n\");\n\t\treturn status;\n\t}\n\n\tcnt = write->wr_buflen;\n\twrite->wr_how_written = write->wr_stable_how;\n\tgen_boot_verifier(&write->wr_verifier, SVC_NET(rqstp));\n\n\tnvecs = fill_in_write_vector(rqstp->rq_vec, write);\n\tWARN_ON_ONCE(nvecs > ARRAY_SIZE(rqstp->rq_vec));\n\n\tstatus =  nfsd_write(rqstp, &cstate->current_fh, filp,\n\t\t\t     write->wr_offset, rqstp->rq_vec, nvecs,\n\t\t\t     &cnt, &write->wr_how_written);\n\tif (filp)\n\t\tfput(filp);\n\n\twrite->wr_bytes_written = cnt;\n\n\treturn status;\n}"
  },
  {
    "function_name": "fill_in_write_vector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "961-977",
    "snippet": "static int fill_in_write_vector(struct kvec *vec, struct nfsd4_write *write)\n{\n        int i = 1;\n        int buflen = write->wr_buflen;\n\n        vec[0].iov_base = write->wr_head.iov_base;\n        vec[0].iov_len = min_t(int, buflen, write->wr_head.iov_len);\n        buflen -= vec[0].iov_len;\n\n        while (buflen) {\n                vec[i].iov_base = page_address(write->wr_pagelist[i - 1]);\n                vec[i].iov_len = min_t(int, PAGE_SIZE, buflen);\n                buflen -= vec[i].iov_len;\n                i++;\n        }\n        return i;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "PAGE_SIZE",
            "buflen"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "write->wr_pagelist[i - 1]"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "buflen",
            "write->wr_head.iov_len"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic int fill_in_write_vector(struct kvec *vec, struct nfsd4_write *write)\n{\n        int i = 1;\n        int buflen = write->wr_buflen;\n\n        vec[0].iov_base = write->wr_head.iov_base;\n        vec[0].iov_len = min_t(int, buflen, write->wr_head.iov_len);\n        buflen -= vec[0].iov_len;\n\n        while (buflen) {\n                vec[i].iov_base = page_address(write->wr_pagelist[i - 1]);\n                vec[i].iov_len = min_t(int, PAGE_SIZE, buflen);\n                buflen -= vec[i].iov_len;\n                i++;\n        }\n        return i;\n}"
  },
  {
    "function_name": "nfsd4_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "919-959",
    "snippet": "static __be32\nnfsd4_setattr(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      struct nfsd4_setattr *setattr)\n{\n\t__be32 status = nfs_ok;\n\tint err;\n\n\tif (setattr->sa_iattr.ia_valid & ATTR_SIZE) {\n\t\tstatus = nfs4_preprocess_stateid_op(SVC_NET(rqstp), cstate,\n\t\t\t&setattr->sa_stateid, WR_STATE, NULL);\n\t\tif (status) {\n\t\t\tdprintk(\"NFSD: nfsd4_setattr: couldn't process stateid!\\n\");\n\t\t\treturn status;\n\t\t}\n\t}\n\terr = fh_want_write(&cstate->current_fh);\n\tif (err)\n\t\treturn nfserrno(err);\n\tstatus = nfs_ok;\n\n\tstatus = check_attr_support(rqstp, cstate, setattr->sa_bmval,\n\t\t\t\t    nfsd_attrmask);\n\tif (status)\n\t\tgoto out;\n\n\tif (setattr->sa_acl != NULL)\n\t\tstatus = nfsd4_set_nfs4_acl(rqstp, &cstate->current_fh,\n\t\t\t\t\t    setattr->sa_acl);\n\tif (status)\n\t\tgoto out;\n\tif (setattr->sa_label.len)\n\t\tstatus = nfsd4_set_nfs4_label(rqstp, &cstate->current_fh,\n\t\t\t\t&setattr->sa_label);\n\tif (status)\n\t\tgoto out;\n\tstatus = nfsd_setattr(rqstp, &cstate->current_fh, &setattr->sa_iattr,\n\t\t\t\t0, (time_t)0);\nout:\n\tfh_drop_write(&cstate->current_fh);\n\treturn status;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 nfsd_attrmask[] = {\n\tNFSD_WRITEABLE_ATTRS_WORD0,\n\tNFSD_WRITEABLE_ATTRS_WORD1,\n\tNFSD_WRITEABLE_ATTRS_WORD2\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_drop_write",
          "args": [
            "&cstate->current_fh"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "fh_drop_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.h",
          "lines": "116-122",
          "snippet": "static inline void fh_drop_write(struct svc_fh *fh)\n{\n\tif (fh->fh_want_write) {\n\t\tfh->fh_want_write = 0;\n\t\tmnt_drop_write(fh->fh_export->ex_path.mnt);\n\t}\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline void fh_drop_write(struct svc_fh *fh)\n{\n\tif (fh->fh_want_write) {\n\t\tfh->fh_want_write = 0;\n\t\tmnt_drop_write(fh->fh_export->ex_path.mnt);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_setattr",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "&setattr->sa_iattr",
            "0",
            "(time_t)0"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "397-480",
          "snippet": "__be32\nnfsd_setattr(struct svc_rqst *rqstp, struct svc_fh *fhp, struct iattr *iap,\n\t     int check_guard, time_t guardtime)\n{\n\tstruct dentry\t*dentry;\n\tstruct inode\t*inode;\n\tint\t\taccmode = NFSD_MAY_SATTR;\n\tumode_t\t\tftype = 0;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\tbool\t\tget_write_count;\n\tint\t\tsize_change = 0;\n\n\tif (iap->ia_valid & (ATTR_ATIME | ATTR_MTIME | ATTR_SIZE))\n\t\taccmode |= NFSD_MAY_WRITE|NFSD_MAY_OWNER_OVERRIDE;\n\tif (iap->ia_valid & ATTR_SIZE)\n\t\tftype = S_IFREG;\n\n\t/* Callers that do fh_verify should do the fh_want_write: */\n\tget_write_count = !fhp->fh_dentry;\n\n\t/* Get inode */\n\terr = fh_verify(rqstp, fhp, ftype, accmode);\n\tif (err)\n\t\tgoto out;\n\tif (get_write_count) {\n\t\thost_err = fh_want_write(fhp);\n\t\tif (host_err)\n\t\t\treturn nfserrno(host_err);\n\t}\n\n\tdentry = fhp->fh_dentry;\n\tinode = dentry->d_inode;\n\n\t/* Ignore any mode updates on symlinks */\n\tif (S_ISLNK(inode->i_mode))\n\t\tiap->ia_valid &= ~ATTR_MODE;\n\n\tif (!iap->ia_valid)\n\t\tgoto out;\n\n\tnfsd_sanitize_attrs(inode, iap);\n\n\t/*\n\t * The size case is special, it changes the file in addition to the\n\t * attributes.\n\t */\n\tif (iap->ia_valid & ATTR_SIZE) {\n\t\terr = nfsd_get_write_access(rqstp, fhp, iap);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tsize_change = 1;\n\n\t\t/*\n\t\t * RFC5661, Section 18.30.4:\n\t\t *   Changing the size of a file with SETATTR indirectly\n\t\t *   changes the time_modify and change attributes.\n\t\t *\n\t\t * (and similar for the older RFCs)\n\t\t */\n\t\tif (iap->ia_size != i_size_read(inode))\n\t\t\tiap->ia_valid |= ATTR_MTIME;\n\t}\n\n\tiap->ia_valid |= ATTR_CTIME;\n\n\tif (check_guard && guardtime != inode->i_ctime.tv_sec) {\n\t\terr = nfserr_notsync;\n\t\tgoto out_put_write_access;\n\t}\n\n\tfh_lock(fhp);\n\thost_err = notify_change(dentry, iap, NULL);\n\tfh_unlock(fhp);\n\terr = nfserrno(host_err);\n\nout_put_write_access:\n\tif (size_change)\n\t\tput_write_access(inode);\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_setattr(struct svc_rqst *rqstp, struct svc_fh *fhp, struct iattr *iap,\n\t     int check_guard, time_t guardtime)\n{\n\tstruct dentry\t*dentry;\n\tstruct inode\t*inode;\n\tint\t\taccmode = NFSD_MAY_SATTR;\n\tumode_t\t\tftype = 0;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\tbool\t\tget_write_count;\n\tint\t\tsize_change = 0;\n\n\tif (iap->ia_valid & (ATTR_ATIME | ATTR_MTIME | ATTR_SIZE))\n\t\taccmode |= NFSD_MAY_WRITE|NFSD_MAY_OWNER_OVERRIDE;\n\tif (iap->ia_valid & ATTR_SIZE)\n\t\tftype = S_IFREG;\n\n\t/* Callers that do fh_verify should do the fh_want_write: */\n\tget_write_count = !fhp->fh_dentry;\n\n\t/* Get inode */\n\terr = fh_verify(rqstp, fhp, ftype, accmode);\n\tif (err)\n\t\tgoto out;\n\tif (get_write_count) {\n\t\thost_err = fh_want_write(fhp);\n\t\tif (host_err)\n\t\t\treturn nfserrno(host_err);\n\t}\n\n\tdentry = fhp->fh_dentry;\n\tinode = dentry->d_inode;\n\n\t/* Ignore any mode updates on symlinks */\n\tif (S_ISLNK(inode->i_mode))\n\t\tiap->ia_valid &= ~ATTR_MODE;\n\n\tif (!iap->ia_valid)\n\t\tgoto out;\n\n\tnfsd_sanitize_attrs(inode, iap);\n\n\t/*\n\t * The size case is special, it changes the file in addition to the\n\t * attributes.\n\t */\n\tif (iap->ia_valid & ATTR_SIZE) {\n\t\terr = nfsd_get_write_access(rqstp, fhp, iap);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tsize_change = 1;\n\n\t\t/*\n\t\t * RFC5661, Section 18.30.4:\n\t\t *   Changing the size of a file with SETATTR indirectly\n\t\t *   changes the time_modify and change attributes.\n\t\t *\n\t\t * (and similar for the older RFCs)\n\t\t */\n\t\tif (iap->ia_size != i_size_read(inode))\n\t\t\tiap->ia_valid |= ATTR_MTIME;\n\t}\n\n\tiap->ia_valid |= ATTR_CTIME;\n\n\tif (check_guard && guardtime != inode->i_ctime.tv_sec) {\n\t\terr = nfserr_notsync;\n\t\tgoto out_put_write_access;\n\t}\n\n\tfh_lock(fhp);\n\thost_err = notify_change(dentry, iap, NULL);\n\tfh_unlock(fhp);\n\terr = nfserrno(host_err);\n\nout_put_write_access:\n\tif (size_change)\n\t\tput_write_access(inode);\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_set_nfs4_label",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "&setattr->sa_label"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_set_nfs4_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "530-534",
          "snippet": "__be32 nfsd4_set_nfs4_label(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct xdr_netobj *label)\n{\n\treturn nfserr_notsupp;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32 nfsd4_set_nfs4_label(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct xdr_netobj *label)\n{\n\treturn nfserr_notsupp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_set_nfs4_acl",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "setattr->sa_acl"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_set_nfs4_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "814-862",
          "snippet": "__be32\nnfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl)\n{\n\t__be32 error;\n\tint host_error;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\n\t/* Get inode */\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);\n\tif (error)\n\t\treturn error;\n\n\tdentry = fhp->fh_dentry;\n\tinode = dentry->d_inode;\n\n\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n\t\treturn nfserr_attrnotsupp;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tflags = NFS4_ACL_DIR;\n\n\thost_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);\n\tif (host_error == -EINVAL)\n\t\treturn nfserr_attrnotsupp;\n\tif (host_error < 0)\n\t\tgoto out_nfserr;\n\n\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);\n\tif (host_error < 0)\n\t\tgoto out_release;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\thost_error = inode->i_op->set_acl(inode, dpacl,\n\t\t\t\t\t\t  ACL_TYPE_DEFAULT);\n\t}\n\nout_release:\n\tposix_acl_release(pacl);\n\tposix_acl_release(dpacl);\nout_nfserr:\n\tif (host_error == -EOPNOTSUPP)\n\t\treturn nfserr_attrnotsupp;\n\telse\n\t\treturn nfserrno(host_error);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define NFS4_ACL_DIR\t\t0x02"
          ],
          "globals_used": [
            "static void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\n#define NFS4_ACL_DIR\t\t0x02\n\nstatic void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);\n\n__be32\nnfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl)\n{\n\t__be32 error;\n\tint host_error;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\n\t/* Get inode */\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);\n\tif (error)\n\t\treturn error;\n\n\tdentry = fhp->fh_dentry;\n\tinode = dentry->d_inode;\n\n\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n\t\treturn nfserr_attrnotsupp;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tflags = NFS4_ACL_DIR;\n\n\thost_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);\n\tif (host_error == -EINVAL)\n\t\treturn nfserr_attrnotsupp;\n\tif (host_error < 0)\n\t\tgoto out_nfserr;\n\n\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);\n\tif (host_error < 0)\n\t\tgoto out_release;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\thost_error = inode->i_op->set_acl(inode, dpacl,\n\t\t\t\t\t\t  ACL_TYPE_DEFAULT);\n\t}\n\nout_release:\n\tposix_acl_release(pacl);\n\tposix_acl_release(dpacl);\nout_nfserr:\n\tif (host_error == -EOPNOTSUPP)\n\t\treturn nfserr_attrnotsupp;\n\telse\n\t\treturn nfserrno(host_error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_attr_support",
          "args": [
            "rqstp",
            "cstate",
            "setattr->sa_bmval",
            "nfsd_attrmask"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "check_attr_support",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "93-127",
          "snippet": "static __be32\ncheck_attr_support(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   u32 *bmval, u32 *writable)\n{\n\tstruct dentry *dentry = cstate->current_fh.fh_dentry;\n\n\t/*\n\t * Check about attributes are supported by the NFSv4 server or not.\n\t * According to spec, unsupported attributes return ERR_ATTRNOTSUPP.\n\t */\n\tif ((bmval[0] & ~nfsd_suppattrs0(cstate->minorversion)) ||\n\t    (bmval[1] & ~nfsd_suppattrs1(cstate->minorversion)) ||\n\t    (bmval[2] & ~nfsd_suppattrs2(cstate->minorversion)))\n\t\treturn nfserr_attrnotsupp;\n\n\t/*\n\t * Check FATTR4_WORD0_ACL can be supported\n\t * in current environment or not.\n\t */\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tif (!IS_POSIXACL(dentry->d_inode))\n\t\t\treturn nfserr_attrnotsupp;\n\t}\n\n\t/*\n\t * According to spec, read-only attributes return ERR_INVAL.\n\t */\n\tif (writable) {\n\t\tif ((bmval[0] & ~writable[0]) || (bmval[1] & ~writable[1]) ||\n\t\t    (bmval[2] & ~writable[2]))\n\t\t\treturn nfserr_inval;\n\t}\n\n\treturn nfs_ok;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\ncheck_attr_support(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   u32 *bmval, u32 *writable)\n{\n\tstruct dentry *dentry = cstate->current_fh.fh_dentry;\n\n\t/*\n\t * Check about attributes are supported by the NFSv4 server or not.\n\t * According to spec, unsupported attributes return ERR_ATTRNOTSUPP.\n\t */\n\tif ((bmval[0] & ~nfsd_suppattrs0(cstate->minorversion)) ||\n\t    (bmval[1] & ~nfsd_suppattrs1(cstate->minorversion)) ||\n\t    (bmval[2] & ~nfsd_suppattrs2(cstate->minorversion)))\n\t\treturn nfserr_attrnotsupp;\n\n\t/*\n\t * Check FATTR4_WORD0_ACL can be supported\n\t * in current environment or not.\n\t */\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tif (!IS_POSIXACL(dentry->d_inode))\n\t\t\treturn nfserr_attrnotsupp;\n\t}\n\n\t/*\n\t * According to spec, read-only attributes return ERR_INVAL.\n\t */\n\tif (writable) {\n\t\tif ((bmval[0] & ~writable[0]) || (bmval[1] & ~writable[1]) ||\n\t\t    (bmval[2] & ~writable[2]))\n\t\t\treturn nfserr_inval;\n\t}\n\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "err"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
          "lines": "708-758",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_want_write",
          "args": [
            "&cstate->current_fh"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "fh_want_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.h",
          "lines": "107-114",
          "snippet": "static inline int fh_want_write(struct svc_fh *fh)\n{\n\tint ret = mnt_want_write(fh->fh_export->ex_path.mnt);\n\n\tif (!ret)\n\t\tfh->fh_want_write = 1;\n\treturn ret;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline int fh_want_write(struct svc_fh *fh)\n{\n\tint ret = mnt_want_write(fh->fh_export->ex_path.mnt);\n\n\tif (!ret)\n\t\tfh->fh_want_write = 1;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfsd4_setattr: couldn't process stateid!\\n\""
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_preprocess_stateid_op",
          "args": [
            "SVC_NET(rqstp)",
            "cstate",
            "&setattr->sa_stateid",
            "WR_STATE",
            "NULL"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_preprocess_stateid_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4468-4545",
          "snippet": "__be32\nnfs4_preprocess_stateid_op(struct net *net, struct nfsd4_compound_state *cstate,\n\t\t\t   stateid_t *stateid, int flags, struct file **filpp)\n{\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\tstruct nfs4_delegation *dp = NULL;\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct inode *ino = current_fh->fh_dentry->d_inode;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct file *file = NULL;\n\t__be32 status;\n\n\tif (filpp)\n\t\t*filpp = NULL;\n\n\tif (grace_disallows_io(net, ino))\n\t\treturn nfserr_grace;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn check_special_stateids(net, current_fh, stateid, flags);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid,\n\t\t\t\tNFS4_DELEG_STID|NFS4_OPEN_STID|NFS4_LOCK_STID,\n\t\t\t\t&s, nn);\n\tif (status)\n\t\treturn status;\n\tstatus = check_stateid_generation(stateid, &s->sc_stateid, nfsd4_has_session(cstate));\n\tif (status)\n\t\tgoto out;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tdp = delegstateid(s);\n\t\tstatus = nfs4_check_delegmode(dp, flags);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (filpp) {\n\t\t\tfile = dp->dl_stid.sc_file->fi_deleg_file;\n\t\t\tif (!file) {\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\tstatus = nfserr_serverfault;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tget_file(file);\n\t\t}\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tstp = openlockstateid(s);\n\t\tstatus = nfs4_check_fh(current_fh, stp);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (stp->st_stateowner->so_is_open_owner\n\t\t    && !(openowner(stp->st_stateowner)->oo_flags & NFS4_OO_CONFIRMED))\n\t\t\tgoto out;\n\t\tstatus = nfs4_check_openmode(stp, flags);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (filpp) {\n\t\t\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\t\t\tif (flags & RD_STATE)\n\t\t\t\tfile = find_readable_file(fp);\n\t\t\telse\n\t\t\t\tfile = find_writeable_file(fp);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\n\tif (file)\n\t\t*filpp = file;\nout:\n\tnfs4_put_stid(s);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfs4_preprocess_stateid_op(struct net *net, struct nfsd4_compound_state *cstate,\n\t\t\t   stateid_t *stateid, int flags, struct file **filpp)\n{\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\tstruct nfs4_delegation *dp = NULL;\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct inode *ino = current_fh->fh_dentry->d_inode;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct file *file = NULL;\n\t__be32 status;\n\n\tif (filpp)\n\t\t*filpp = NULL;\n\n\tif (grace_disallows_io(net, ino))\n\t\treturn nfserr_grace;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn check_special_stateids(net, current_fh, stateid, flags);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid,\n\t\t\t\tNFS4_DELEG_STID|NFS4_OPEN_STID|NFS4_LOCK_STID,\n\t\t\t\t&s, nn);\n\tif (status)\n\t\treturn status;\n\tstatus = check_stateid_generation(stateid, &s->sc_stateid, nfsd4_has_session(cstate));\n\tif (status)\n\t\tgoto out;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tdp = delegstateid(s);\n\t\tstatus = nfs4_check_delegmode(dp, flags);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (filpp) {\n\t\t\tfile = dp->dl_stid.sc_file->fi_deleg_file;\n\t\t\tif (!file) {\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\tstatus = nfserr_serverfault;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tget_file(file);\n\t\t}\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tstp = openlockstateid(s);\n\t\tstatus = nfs4_check_fh(current_fh, stp);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (stp->st_stateowner->so_is_open_owner\n\t\t    && !(openowner(stp->st_stateowner)->oo_flags & NFS4_OO_CONFIRMED))\n\t\t\tgoto out;\n\t\tstatus = nfs4_check_openmode(stp, flags);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (filpp) {\n\t\t\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\t\t\tif (flags & RD_STATE)\n\t\t\t\tfile = find_readable_file(fp);\n\t\t\telse\n\t\t\t\tfile = find_writeable_file(fp);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\n\tif (file)\n\t\t*filpp = file;\nout:\n\tnfs4_put_stid(s);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic u32 nfsd_attrmask[] = {\n\tNFSD_WRITEABLE_ATTRS_WORD0,\n\tNFSD_WRITEABLE_ATTRS_WORD1,\n\tNFSD_WRITEABLE_ATTRS_WORD2\n};\n\nstatic __be32\nnfsd4_setattr(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      struct nfsd4_setattr *setattr)\n{\n\t__be32 status = nfs_ok;\n\tint err;\n\n\tif (setattr->sa_iattr.ia_valid & ATTR_SIZE) {\n\t\tstatus = nfs4_preprocess_stateid_op(SVC_NET(rqstp), cstate,\n\t\t\t&setattr->sa_stateid, WR_STATE, NULL);\n\t\tif (status) {\n\t\t\tdprintk(\"NFSD: nfsd4_setattr: couldn't process stateid!\\n\");\n\t\t\treturn status;\n\t\t}\n\t}\n\terr = fh_want_write(&cstate->current_fh);\n\tif (err)\n\t\treturn nfserrno(err);\n\tstatus = nfs_ok;\n\n\tstatus = check_attr_support(rqstp, cstate, setattr->sa_bmval,\n\t\t\t\t    nfsd_attrmask);\n\tif (status)\n\t\tgoto out;\n\n\tif (setattr->sa_acl != NULL)\n\t\tstatus = nfsd4_set_nfs4_acl(rqstp, &cstate->current_fh,\n\t\t\t\t\t    setattr->sa_acl);\n\tif (status)\n\t\tgoto out;\n\tif (setattr->sa_label.len)\n\t\tstatus = nfsd4_set_nfs4_label(rqstp, &cstate->current_fh,\n\t\t\t\t&setattr->sa_label);\n\tif (status)\n\t\tgoto out;\n\tstatus = nfsd_setattr(rqstp, &cstate->current_fh, &setattr->sa_iattr,\n\t\t\t\t0, (time_t)0);\nout:\n\tfh_drop_write(&cstate->current_fh);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_secinfo_no_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "896-917",
    "snippet": "static __be32\nnfsd4_secinfo_no_name(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      struct nfsd4_secinfo_no_name *sin)\n{\n\t__be32 err;\n\n\tswitch (sin->sin_style) {\n\tcase NFS4_SECINFO_STYLE4_CURRENT_FH:\n\t\tbreak;\n\tcase NFS4_SECINFO_STYLE4_PARENT:\n\t\terr = nfsd4_do_lookupp(rqstp, &cstate->current_fh);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_inval;\n\t}\n\n\tsin->sin_exp = exp_get(cstate->current_fh.fh_export);\n\tfh_put(&cstate->current_fh);\n\treturn nfs_ok;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&cstate->current_fh"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "625-645",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp_get",
          "args": [
            "cstate->current_fh.fh_export"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "exp_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.h",
          "lines": "106-110",
          "snippet": "static inline struct svc_export *exp_get(struct svc_export *exp)\n{\n\tcache_get(&exp->h);\n\treturn exp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline struct svc_export *exp_get(struct svc_export *exp)\n{\n\tcache_get(&exp->h);\n\treturn exp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_do_lookupp",
          "args": [
            "rqstp",
            "&cstate->current_fh"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_do_lookupp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "724-739",
          "snippet": "static __be32 nfsd4_do_lookupp(struct svc_rqst *rqstp, struct svc_fh *fh)\n{\n\tstruct svc_fh tmp_fh;\n\t__be32 ret;\n\n\tfh_init(&tmp_fh, NFS4_FHSIZE);\n\tret = exp_pseudoroot(rqstp, &tmp_fh);\n\tif (ret)\n\t\treturn ret;\n\tif (tmp_fh.fh_dentry == fh->fh_dentry) {\n\t\tfh_put(&tmp_fh);\n\t\treturn nfserr_noent;\n\t}\n\tfh_put(&tmp_fh);\n\treturn nfsd_lookup(rqstp, fh, \"..\", 2, fh);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_do_lookupp(struct svc_rqst *rqstp, struct svc_fh *fh)\n{\n\tstruct svc_fh tmp_fh;\n\t__be32 ret;\n\n\tfh_init(&tmp_fh, NFS4_FHSIZE);\n\tret = exp_pseudoroot(rqstp, &tmp_fh);\n\tif (ret)\n\t\treturn ret;\n\tif (tmp_fh.fh_dentry == fh->fh_dentry) {\n\t\tfh_put(&tmp_fh);\n\t\treturn nfserr_noent;\n\t}\n\tfh_put(&tmp_fh);\n\treturn nfsd_lookup(rqstp, fh, \"..\", 2, fh);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_secinfo_no_name(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      struct nfsd4_secinfo_no_name *sin)\n{\n\t__be32 err;\n\n\tswitch (sin->sin_style) {\n\tcase NFS4_SECINFO_STYLE4_CURRENT_FH:\n\t\tbreak;\n\tcase NFS4_SECINFO_STYLE4_PARENT:\n\t\terr = nfsd4_do_lookupp(rqstp, &cstate->current_fh);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_inval;\n\t}\n\n\tsin->sin_exp = exp_get(cstate->current_fh.fh_export);\n\tfh_put(&cstate->current_fh);\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_secinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "866-894",
    "snippet": "static __be32\nnfsd4_secinfo(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      struct nfsd4_secinfo *secinfo)\n{\n\tstruct svc_fh resfh;\n\tstruct svc_export *exp;\n\tstruct dentry *dentry;\n\t__be32 err;\n\n\tfh_init(&resfh, NFS4_FHSIZE);\n\terr = fh_verify(rqstp, &cstate->current_fh, S_IFDIR, NFSD_MAY_EXEC);\n\tif (err)\n\t\treturn err;\n\terr = nfsd_lookup_dentry(rqstp, &cstate->current_fh,\n\t\t\t\t    secinfo->si_name, secinfo->si_namelen,\n\t\t\t\t    &exp, &dentry);\n\tif (err)\n\t\treturn err;\n\tif (dentry->d_inode == NULL) {\n\t\texp_put(exp);\n\t\terr = nfserr_noent;\n\t} else\n\t\tsecinfo->si_exp = exp;\n\tdput(dentry);\n\tif (cstate->minorversion)\n\t\t/* See rfc 5661 section 2.6.3.1.1.8 */\n\t\tfh_put(&cstate->current_fh);\n\treturn err;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&cstate->current_fh"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "625-645",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp_put",
          "args": [
            "exp"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "exp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.h",
          "lines": "101-104",
          "snippet": "static inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_lookup_dentry",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "secinfo->si_name",
            "secinfo->si_namelen",
            "&exp",
            "&dentry"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_lookup_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "180-237",
          "snippet": "__be32\nnfsd_lookup_dentry(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t   const char *name, unsigned int len,\n\t\t   struct svc_export **exp_ret, struct dentry **dentry_ret)\n{\n\tstruct svc_export\t*exp;\n\tstruct dentry\t\t*dparent;\n\tstruct dentry\t\t*dentry;\n\tint\t\t\thost_err;\n\n\tdprintk(\"nfsd: nfsd_lookup(fh %s, %.*s)\\n\", SVCFH_fmt(fhp), len,name);\n\n\tdparent = fhp->fh_dentry;\n\texp = exp_get(fhp->fh_export);\n\n\t/* Lookup the name, but don't follow links */\n\tif (isdotent(name, len)) {\n\t\tif (len==1)\n\t\t\tdentry = dget(dparent);\n\t\telse if (dparent != exp->ex_path.dentry)\n\t\t\tdentry = dget_parent(dparent);\n\t\telse if (!EX_NOHIDE(exp) && !nfsd_v4client(rqstp))\n\t\t\tdentry = dget(dparent); /* .. == . just like at / */\n\t\telse {\n\t\t\t/* checking mountpoint crossing is very different when stepping up */\n\t\t\thost_err = nfsd_lookup_parent(rqstp, dparent, &exp, &dentry);\n\t\t\tif (host_err)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * In the nfsd4_open() case, this may be held across\n\t\t * subsequent open and delegation acquisition which may\n\t\t * need to take the child's i_mutex:\n\t\t */\n\t\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\t\tdentry = lookup_one_len(name, dparent, len);\n\t\thost_err = PTR_ERR(dentry);\n\t\tif (IS_ERR(dentry))\n\t\t\tgoto out_nfserr;\n\t\t/*\n\t\t * check if we have crossed a mount point ...\n\t\t */\n\t\tif (nfsd_mountpoint(dentry, exp)) {\n\t\t\tif ((host_err = nfsd_cross_mnt(rqstp, &dentry, &exp))) {\n\t\t\t\tdput(dentry);\n\t\t\t\tgoto out_nfserr;\n\t\t\t}\n\t\t}\n\t}\n\t*dentry_ret = dentry;\n\t*exp_ret = exp;\n\treturn 0;\n\nout_nfserr:\n\texp_put(exp);\n\treturn nfserrno(host_err);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_lookup_dentry(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t   const char *name, unsigned int len,\n\t\t   struct svc_export **exp_ret, struct dentry **dentry_ret)\n{\n\tstruct svc_export\t*exp;\n\tstruct dentry\t\t*dparent;\n\tstruct dentry\t\t*dentry;\n\tint\t\t\thost_err;\n\n\tdprintk(\"nfsd: nfsd_lookup(fh %s, %.*s)\\n\", SVCFH_fmt(fhp), len,name);\n\n\tdparent = fhp->fh_dentry;\n\texp = exp_get(fhp->fh_export);\n\n\t/* Lookup the name, but don't follow links */\n\tif (isdotent(name, len)) {\n\t\tif (len==1)\n\t\t\tdentry = dget(dparent);\n\t\telse if (dparent != exp->ex_path.dentry)\n\t\t\tdentry = dget_parent(dparent);\n\t\telse if (!EX_NOHIDE(exp) && !nfsd_v4client(rqstp))\n\t\t\tdentry = dget(dparent); /* .. == . just like at / */\n\t\telse {\n\t\t\t/* checking mountpoint crossing is very different when stepping up */\n\t\t\thost_err = nfsd_lookup_parent(rqstp, dparent, &exp, &dentry);\n\t\t\tif (host_err)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * In the nfsd4_open() case, this may be held across\n\t\t * subsequent open and delegation acquisition which may\n\t\t * need to take the child's i_mutex:\n\t\t */\n\t\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\t\tdentry = lookup_one_len(name, dparent, len);\n\t\thost_err = PTR_ERR(dentry);\n\t\tif (IS_ERR(dentry))\n\t\t\tgoto out_nfserr;\n\t\t/*\n\t\t * check if we have crossed a mount point ...\n\t\t */\n\t\tif (nfsd_mountpoint(dentry, exp)) {\n\t\t\tif ((host_err = nfsd_cross_mnt(rqstp, &dentry, &exp))) {\n\t\t\t\tdput(dentry);\n\t\t\t\tgoto out_nfserr;\n\t\t\t}\n\t\t}\n\t}\n\t*dentry_ret = dentry;\n\t*exp_ret = exp;\n\treturn 0;\n\nout_nfserr:\n\texp_put(exp);\n\treturn nfserrno(host_err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "S_IFDIR",
            "NFSD_MAY_EXEC"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_init",
          "args": [
            "&resfh",
            "NFS4_FHSIZE"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "fh_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "182-188",
          "snippet": "static __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_secinfo(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      struct nfsd4_secinfo *secinfo)\n{\n\tstruct svc_fh resfh;\n\tstruct svc_export *exp;\n\tstruct dentry *dentry;\n\t__be32 err;\n\n\tfh_init(&resfh, NFS4_FHSIZE);\n\terr = fh_verify(rqstp, &cstate->current_fh, S_IFDIR, NFSD_MAY_EXEC);\n\tif (err)\n\t\treturn err;\n\terr = nfsd_lookup_dentry(rqstp, &cstate->current_fh,\n\t\t\t\t    secinfo->si_name, secinfo->si_namelen,\n\t\t\t\t    &exp, &dentry);\n\tif (err)\n\t\treturn err;\n\tif (dentry->d_inode == NULL) {\n\t\texp_put(exp);\n\t\terr = nfserr_noent;\n\t} else\n\t\tsecinfo->si_exp = exp;\n\tdput(dentry);\n\tif (cstate->minorversion)\n\t\t/* See rfc 5661 section 2.6.3.1.1.8 */\n\t\tfh_put(&cstate->current_fh);\n\treturn err;\n}"
  },
  {
    "function_name": "nfsd4_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "845-864",
    "snippet": "static __be32\nnfsd4_rename(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_rename *rename)\n{\n\t__be32 status = nfserr_nofilehandle;\n\n\tif (!cstate->save_fh.fh_dentry)\n\t\treturn status;\n\tif (locks_in_grace(SVC_NET(rqstp)) &&\n\t\t!(cstate->save_fh.fh_export->ex_flags & NFSEXP_NOSUBTREECHECK))\n\t\treturn nfserr_grace;\n\tstatus = nfsd_rename(rqstp, &cstate->save_fh, rename->rn_sname,\n\t\t\t     rename->rn_snamelen, &cstate->current_fh,\n\t\t\t     rename->rn_tname, rename->rn_tnamelen);\n\tif (status)\n\t\treturn status;\n\tset_change_info(&rename->rn_sinfo, &cstate->current_fh);\n\tset_change_info(&rename->rn_tinfo, &cstate->save_fh);\n\treturn nfs_ok;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_change_info",
          "args": [
            "&rename->rn_tinfo",
            "&cstate->save_fh"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "set_change_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/xdr4.h",
          "lines": "630-644",
          "snippet": "static inline void\nset_change_info(struct nfsd4_change_info *cinfo, struct svc_fh *fhp)\n{\n\tBUG_ON(!fhp->fh_pre_saved);\n\tcinfo->atomic = fhp->fh_post_saved;\n\tcinfo->change_supported = IS_I_VERSION(fhp->fh_dentry->d_inode);\n\n\tcinfo->before_change = fhp->fh_pre_change;\n\tcinfo->after_change = fhp->fh_post_change;\n\tcinfo->before_ctime_sec = fhp->fh_pre_ctime.tv_sec;\n\tcinfo->before_ctime_nsec = fhp->fh_pre_ctime.tv_nsec;\n\tcinfo->after_ctime_sec = fhp->fh_post_attr.ctime.tv_sec;\n\tcinfo->after_ctime_nsec = fhp->fh_post_attr.ctime.tv_nsec;\n\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline void\nset_change_info(struct nfsd4_change_info *cinfo, struct svc_fh *fhp)\n{\n\tBUG_ON(!fhp->fh_pre_saved);\n\tcinfo->atomic = fhp->fh_post_saved;\n\tcinfo->change_supported = IS_I_VERSION(fhp->fh_dentry->d_inode);\n\n\tcinfo->before_change = fhp->fh_pre_change;\n\tcinfo->after_change = fhp->fh_post_change;\n\tcinfo->before_ctime_sec = fhp->fh_pre_ctime.tv_sec;\n\tcinfo->before_ctime_nsec = fhp->fh_pre_ctime.tv_nsec;\n\tcinfo->after_ctime_sec = fhp->fh_post_attr.ctime.tv_sec;\n\tcinfo->after_ctime_nsec = fhp->fh_post_attr.ctime.tv_nsec;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_rename",
          "args": [
            "rqstp",
            "&cstate->save_fh",
            "rename->rn_sname",
            "rename->rn_snamelen",
            "&cstate->current_fh",
            "rename->rn_tname",
            "rename->rn_tnamelen"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "1675-1765",
          "snippet": "__be32\nnfsd_rename(struct svc_rqst *rqstp, struct svc_fh *ffhp, char *fname, int flen,\n\t\t\t    struct svc_fh *tfhp, char *tname, int tlen)\n{\n\tstruct dentry\t*fdentry, *tdentry, *odentry, *ndentry, *trap;\n\tstruct inode\t*fdir, *tdir;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\terr = fh_verify(rqstp, ffhp, S_IFDIR, NFSD_MAY_REMOVE);\n\tif (err)\n\t\tgoto out;\n\terr = fh_verify(rqstp, tfhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\tfdentry = ffhp->fh_dentry;\n\tfdir = fdentry->d_inode;\n\n\ttdentry = tfhp->fh_dentry;\n\ttdir = tdentry->d_inode;\n\n\terr = nfserr_perm;\n\tif (!flen || isdotent(fname, flen) || !tlen || isdotent(tname, tlen))\n\t\tgoto out;\n\n\thost_err = fh_want_write(ffhp);\n\tif (host_err) {\n\t\terr = nfserrno(host_err);\n\t\tgoto out;\n\t}\n\n\t/* cannot use fh_lock as we need deadlock protective ordering\n\t * so do it by hand */\n\ttrap = lock_rename(tdentry, fdentry);\n\tffhp->fh_locked = tfhp->fh_locked = 1;\n\tfill_pre_wcc(ffhp);\n\tfill_pre_wcc(tfhp);\n\n\todentry = lookup_one_len(fname, fdentry, flen);\n\thost_err = PTR_ERR(odentry);\n\tif (IS_ERR(odentry))\n\t\tgoto out_nfserr;\n\n\thost_err = -ENOENT;\n\tif (!odentry->d_inode)\n\t\tgoto out_dput_old;\n\thost_err = -EINVAL;\n\tif (odentry == trap)\n\t\tgoto out_dput_old;\n\n\tndentry = lookup_one_len(tname, tdentry, tlen);\n\thost_err = PTR_ERR(ndentry);\n\tif (IS_ERR(ndentry))\n\t\tgoto out_dput_old;\n\thost_err = -ENOTEMPTY;\n\tif (ndentry == trap)\n\t\tgoto out_dput_new;\n\n\thost_err = -EXDEV;\n\tif (ffhp->fh_export->ex_path.mnt != tfhp->fh_export->ex_path.mnt)\n\t\tgoto out_dput_new;\n\tif (ffhp->fh_export->ex_path.dentry != tfhp->fh_export->ex_path.dentry)\n\t\tgoto out_dput_new;\n\n\thost_err = vfs_rename(fdir, odentry, tdir, ndentry, NULL, 0);\n\tif (!host_err) {\n\t\thost_err = commit_metadata(tfhp);\n\t\tif (!host_err)\n\t\t\thost_err = commit_metadata(ffhp);\n\t}\n out_dput_new:\n\tdput(ndentry);\n out_dput_old:\n\tdput(odentry);\n out_nfserr:\n\terr = nfserrno(host_err);\n\t/*\n\t * We cannot rely on fh_unlock on the two filehandles,\n\t * as that would do the wrong thing if the two directories\n\t * were the same, so again we do it by hand.\n\t */\n\tfill_post_wcc(ffhp);\n\tfill_post_wcc(tfhp);\n\tunlock_rename(tdentry, fdentry);\n\tffhp->fh_locked = tfhp->fh_locked = 0;\n\tfh_drop_write(ffhp);\n\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_rename(struct svc_rqst *rqstp, struct svc_fh *ffhp, char *fname, int flen,\n\t\t\t    struct svc_fh *tfhp, char *tname, int tlen)\n{\n\tstruct dentry\t*fdentry, *tdentry, *odentry, *ndentry, *trap;\n\tstruct inode\t*fdir, *tdir;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\terr = fh_verify(rqstp, ffhp, S_IFDIR, NFSD_MAY_REMOVE);\n\tif (err)\n\t\tgoto out;\n\terr = fh_verify(rqstp, tfhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\tfdentry = ffhp->fh_dentry;\n\tfdir = fdentry->d_inode;\n\n\ttdentry = tfhp->fh_dentry;\n\ttdir = tdentry->d_inode;\n\n\terr = nfserr_perm;\n\tif (!flen || isdotent(fname, flen) || !tlen || isdotent(tname, tlen))\n\t\tgoto out;\n\n\thost_err = fh_want_write(ffhp);\n\tif (host_err) {\n\t\terr = nfserrno(host_err);\n\t\tgoto out;\n\t}\n\n\t/* cannot use fh_lock as we need deadlock protective ordering\n\t * so do it by hand */\n\ttrap = lock_rename(tdentry, fdentry);\n\tffhp->fh_locked = tfhp->fh_locked = 1;\n\tfill_pre_wcc(ffhp);\n\tfill_pre_wcc(tfhp);\n\n\todentry = lookup_one_len(fname, fdentry, flen);\n\thost_err = PTR_ERR(odentry);\n\tif (IS_ERR(odentry))\n\t\tgoto out_nfserr;\n\n\thost_err = -ENOENT;\n\tif (!odentry->d_inode)\n\t\tgoto out_dput_old;\n\thost_err = -EINVAL;\n\tif (odentry == trap)\n\t\tgoto out_dput_old;\n\n\tndentry = lookup_one_len(tname, tdentry, tlen);\n\thost_err = PTR_ERR(ndentry);\n\tif (IS_ERR(ndentry))\n\t\tgoto out_dput_old;\n\thost_err = -ENOTEMPTY;\n\tif (ndentry == trap)\n\t\tgoto out_dput_new;\n\n\thost_err = -EXDEV;\n\tif (ffhp->fh_export->ex_path.mnt != tfhp->fh_export->ex_path.mnt)\n\t\tgoto out_dput_new;\n\tif (ffhp->fh_export->ex_path.dentry != tfhp->fh_export->ex_path.dentry)\n\t\tgoto out_dput_new;\n\n\thost_err = vfs_rename(fdir, odentry, tdir, ndentry, NULL, 0);\n\tif (!host_err) {\n\t\thost_err = commit_metadata(tfhp);\n\t\tif (!host_err)\n\t\t\thost_err = commit_metadata(ffhp);\n\t}\n out_dput_new:\n\tdput(ndentry);\n out_dput_old:\n\tdput(odentry);\n out_nfserr:\n\terr = nfserrno(host_err);\n\t/*\n\t * We cannot rely on fh_unlock on the two filehandles,\n\t * as that would do the wrong thing if the two directories\n\t * were the same, so again we do it by hand.\n\t */\n\tfill_post_wcc(ffhp);\n\tfill_post_wcc(tfhp);\n\tunlock_rename(tdentry, fdentry);\n\tffhp->fh_locked = tfhp->fh_locked = 0;\n\tfh_drop_write(ffhp);\n\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_in_grace",
          "args": [
            "SVC_NET(rqstp)"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "locks_in_grace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/grace.c",
          "lines": "65-71",
          "snippet": "int\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <net/netns/generic.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int grace_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <net/netns/generic.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n\nstatic int grace_net_id;\n\nint\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_rename(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_rename *rename)\n{\n\t__be32 status = nfserr_nofilehandle;\n\n\tif (!cstate->save_fh.fh_dentry)\n\t\treturn status;\n\tif (locks_in_grace(SVC_NET(rqstp)) &&\n\t\t!(cstate->save_fh.fh_export->ex_flags & NFSEXP_NOSUBTREECHECK))\n\t\treturn nfserr_grace;\n\tstatus = nfsd_rename(rqstp, &cstate->save_fh, rename->rn_sname,\n\t\t\t     rename->rn_snamelen, &cstate->current_fh,\n\t\t\t     rename->rn_tname, rename->rn_tnamelen);\n\tif (status)\n\t\treturn status;\n\tset_change_info(&rename->rn_sinfo, &cstate->current_fh);\n\tset_change_info(&rename->rn_tinfo, &cstate->save_fh);\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "828-843",
    "snippet": "static __be32\nnfsd4_remove(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_remove *remove)\n{\n\t__be32 status;\n\n\tif (locks_in_grace(SVC_NET(rqstp)))\n\t\treturn nfserr_grace;\n\tstatus = nfsd_unlink(rqstp, &cstate->current_fh, 0,\n\t\t\t     remove->rm_name, remove->rm_namelen);\n\tif (!status) {\n\t\tfh_unlock(&cstate->current_fh);\n\t\tset_change_info(&remove->rm_cinfo, &cstate->current_fh);\n\t}\n\treturn status;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_change_info",
          "args": [
            "&remove->rm_cinfo",
            "&cstate->current_fh"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "set_change_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/xdr4.h",
          "lines": "630-644",
          "snippet": "static inline void\nset_change_info(struct nfsd4_change_info *cinfo, struct svc_fh *fhp)\n{\n\tBUG_ON(!fhp->fh_pre_saved);\n\tcinfo->atomic = fhp->fh_post_saved;\n\tcinfo->change_supported = IS_I_VERSION(fhp->fh_dentry->d_inode);\n\n\tcinfo->before_change = fhp->fh_pre_change;\n\tcinfo->after_change = fhp->fh_post_change;\n\tcinfo->before_ctime_sec = fhp->fh_pre_ctime.tv_sec;\n\tcinfo->before_ctime_nsec = fhp->fh_pre_ctime.tv_nsec;\n\tcinfo->after_ctime_sec = fhp->fh_post_attr.ctime.tv_sec;\n\tcinfo->after_ctime_nsec = fhp->fh_post_attr.ctime.tv_nsec;\n\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline void\nset_change_info(struct nfsd4_change_info *cinfo, struct svc_fh *fhp)\n{\n\tBUG_ON(!fhp->fh_pre_saved);\n\tcinfo->atomic = fhp->fh_post_saved;\n\tcinfo->change_supported = IS_I_VERSION(fhp->fh_dentry->d_inode);\n\n\tcinfo->before_change = fhp->fh_pre_change;\n\tcinfo->after_change = fhp->fh_post_change;\n\tcinfo->before_ctime_sec = fhp->fh_pre_ctime.tv_sec;\n\tcinfo->before_ctime_nsec = fhp->fh_pre_ctime.tv_nsec;\n\tcinfo->after_ctime_sec = fhp->fh_post_attr.ctime.tv_sec;\n\tcinfo->after_ctime_nsec = fhp->fh_post_attr.ctime.tv_nsec;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_unlock",
          "args": [
            "&cstate->current_fh"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "fh_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "282-290",
          "snippet": "static inline void\nfh_unlock(struct svc_fh *fhp)\n{\n\tif (fhp->fh_locked) {\n\t\tfill_post_wcc(fhp);\n\t\tmutex_unlock(&fhp->fh_dentry->d_inode->i_mutex);\n\t\tfhp->fh_locked = 0;\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline void\nfh_unlock(struct svc_fh *fhp)\n{\n\tif (fhp->fh_locked) {\n\t\tfill_post_wcc(fhp);\n\t\tmutex_unlock(&fhp->fh_dentry->d_inode->i_mutex);\n\t\tfhp->fh_locked = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_unlink",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "0",
            "remove->rm_name",
            "remove->rm_namelen"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "1771-1821",
          "snippet": "__be32\nnfsd_unlink(struct svc_rqst *rqstp, struct svc_fh *fhp, int type,\n\t\t\t\tchar *fname, int flen)\n{\n\tstruct dentry\t*dentry, *rdentry;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\terr = nfserr_acces;\n\tif (!flen || isdotent(fname, flen))\n\t\tgoto out;\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_REMOVE);\n\tif (err)\n\t\tgoto out;\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\tgoto out_nfserr;\n\n\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\tdentry = fhp->fh_dentry;\n\tdirp = dentry->d_inode;\n\n\trdentry = lookup_one_len(fname, dentry, flen);\n\thost_err = PTR_ERR(rdentry);\n\tif (IS_ERR(rdentry))\n\t\tgoto out_nfserr;\n\n\tif (!rdentry->d_inode) {\n\t\tdput(rdentry);\n\t\terr = nfserr_noent;\n\t\tgoto out;\n\t}\n\n\tif (!type)\n\t\ttype = rdentry->d_inode->i_mode & S_IFMT;\n\n\tif (type != S_IFDIR)\n\t\thost_err = vfs_unlink(dirp, rdentry, NULL);\n\telse\n\t\thost_err = vfs_rmdir(dirp, rdentry);\n\tif (!host_err)\n\t\thost_err = commit_metadata(fhp);\n\tdput(rdentry);\n\nout_nfserr:\n\terr = nfserrno(host_err);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_unlink(struct svc_rqst *rqstp, struct svc_fh *fhp, int type,\n\t\t\t\tchar *fname, int flen)\n{\n\tstruct dentry\t*dentry, *rdentry;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\terr = nfserr_acces;\n\tif (!flen || isdotent(fname, flen))\n\t\tgoto out;\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_REMOVE);\n\tif (err)\n\t\tgoto out;\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\tgoto out_nfserr;\n\n\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\tdentry = fhp->fh_dentry;\n\tdirp = dentry->d_inode;\n\n\trdentry = lookup_one_len(fname, dentry, flen);\n\thost_err = PTR_ERR(rdentry);\n\tif (IS_ERR(rdentry))\n\t\tgoto out_nfserr;\n\n\tif (!rdentry->d_inode) {\n\t\tdput(rdentry);\n\t\terr = nfserr_noent;\n\t\tgoto out;\n\t}\n\n\tif (!type)\n\t\ttype = rdentry->d_inode->i_mode & S_IFMT;\n\n\tif (type != S_IFDIR)\n\t\thost_err = vfs_unlink(dirp, rdentry, NULL);\n\telse\n\t\thost_err = vfs_rmdir(dirp, rdentry);\n\tif (!host_err)\n\t\thost_err = commit_metadata(fhp);\n\tdput(rdentry);\n\nout_nfserr:\n\terr = nfserrno(host_err);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_in_grace",
          "args": [
            "SVC_NET(rqstp)"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "locks_in_grace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/grace.c",
          "lines": "65-71",
          "snippet": "int\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <net/netns/generic.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int grace_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <net/netns/generic.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n\nstatic int grace_net_id;\n\nint\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_remove(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_remove *remove)\n{\n\t__be32 status;\n\n\tif (locks_in_grace(SVC_NET(rqstp)))\n\t\treturn nfserr_grace;\n\tstatus = nfsd_unlink(rqstp, &cstate->current_fh, 0,\n\t\t\t     remove->rm_name, remove->rm_namelen);\n\tif (!status) {\n\t\tfh_unlock(&cstate->current_fh);\n\t\tset_change_info(&remove->rm_cinfo, &cstate->current_fh);\n\t}\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_readlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "819-826",
    "snippet": "static __be32\nnfsd4_readlink(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t       struct nfsd4_readlink *readlink)\n{\n\treadlink->rl_rqstp = rqstp;\n\treadlink->rl_fhp = &cstate->current_fh;\n\treturn nfs_ok;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_readlink(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t       struct nfsd4_readlink *readlink)\n{\n\treadlink->rl_rqstp = rqstp;\n\treadlink->rl_fhp = &cstate->current_fh;\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "794-817",
    "snippet": "static __be32\nnfsd4_readdir(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      struct nfsd4_readdir *readdir)\n{\n\tu64 cookie = readdir->rd_cookie;\n\tstatic const nfs4_verifier zeroverf;\n\n\t/* no need to check permission - this will be done in nfsd_readdir() */\n\n\tif (readdir->rd_bmval[1] & NFSD_WRITEONLY_ATTRS_WORD1)\n\t\treturn nfserr_inval;\n\n\treaddir->rd_bmval[0] &= nfsd_suppattrs0(cstate->minorversion);\n\treaddir->rd_bmval[1] &= nfsd_suppattrs1(cstate->minorversion);\n\treaddir->rd_bmval[2] &= nfsd_suppattrs2(cstate->minorversion);\n\n\tif ((cookie == 1) || (cookie == 2) ||\n\t    (cookie == 0 && memcmp(readdir->rd_verf.data, zeroverf.data, NFS4_VERIFIER_SIZE)))\n\t\treturn nfserr_bad_cookie;\n\n\treaddir->rd_rqstp = rqstp;\n\treaddir->rd_fhp = &cstate->current_fh;\n\treturn nfs_ok;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "readdir->rd_verf.data",
            "zeroverf.data",
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_suppattrs2",
          "args": [
            "cstate->minorversion"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_suppattrs2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsd.h",
          "lines": "371-378",
          "snippet": "static inline u32 nfsd_suppattrs2(u32 minorversion)\n{\n\tswitch (minorversion) {\n\tdefault: return NFSD4_2_SUPPORTED_ATTRS_WORD2;\n\tcase 1:  return NFSD4_1_SUPPORTED_ATTRS_WORD2;\n\tcase 0:  return NFSD4_SUPPORTED_ATTRS_WORD2;\n\t}\n}",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFSD4_2_SUPPORTED_ATTRS_WORD2 \\\n\t(NFSD4_1_SUPPORTED_ATTRS_WORD2 | \\\n\tNFSD4_2_SECURITY_ATTRS)",
            "#define NFSD4_1_SUPPORTED_ATTRS_WORD2 \\\n\t(NFSD4_SUPPORTED_ATTRS_WORD2\t| PNFSD_SUPPORTED_ATTRS_WORD2 | \\\n\t FATTR4_WORD2_SUPPATTR_EXCLCREAT)",
            "#define NFSD4_SUPPORTED_ATTRS_WORD2 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\n#define NFSD4_2_SUPPORTED_ATTRS_WORD2 \\\n\t(NFSD4_1_SUPPORTED_ATTRS_WORD2 | \\\n\tNFSD4_2_SECURITY_ATTRS)\n#define NFSD4_1_SUPPORTED_ATTRS_WORD2 \\\n\t(NFSD4_SUPPORTED_ATTRS_WORD2\t| PNFSD_SUPPORTED_ATTRS_WORD2 | \\\n\t FATTR4_WORD2_SUPPATTR_EXCLCREAT)\n#define NFSD4_SUPPORTED_ATTRS_WORD2 0\n\nstatic inline u32 nfsd_suppattrs2(u32 minorversion)\n{\n\tswitch (minorversion) {\n\tdefault: return NFSD4_2_SUPPORTED_ATTRS_WORD2;\n\tcase 1:  return NFSD4_1_SUPPORTED_ATTRS_WORD2;\n\tcase 0:  return NFSD4_SUPPORTED_ATTRS_WORD2;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_suppattrs1",
          "args": [
            "cstate->minorversion"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_suppattrs1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsd.h",
          "lines": "365-369",
          "snippet": "static inline u32 nfsd_suppattrs1(u32 minorversion)\n{\n\treturn minorversion ? NFSD4_1_SUPPORTED_ATTRS_WORD1\n\t\t\t    : NFSD4_SUPPORTED_ATTRS_WORD1;\n}",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFSD4_1_SUPPORTED_ATTRS_WORD1 \\\n\t(NFSD4_SUPPORTED_ATTRS_WORD1\t| PNFSD_SUPPORTED_ATTRS_WORD1)",
            "#define NFSD4_SUPPORTED_ATTRS_WORD1                                                         \\\n(FATTR4_WORD1_MODE              | FATTR4_WORD1_NO_TRUNC     | FATTR4_WORD1_NUMLINKS         \\\n | FATTR4_WORD1_OWNER\t        | FATTR4_WORD1_OWNER_GROUP  | FATTR4_WORD1_RAWDEV           \\\n | FATTR4_WORD1_SPACE_AVAIL     | FATTR4_WORD1_SPACE_FREE   | FATTR4_WORD1_SPACE_TOTAL      \\\n | FATTR4_WORD1_SPACE_USED      | FATTR4_WORD1_TIME_ACCESS  | FATTR4_WORD1_TIME_ACCESS_SET  \\\n | FATTR4_WORD1_TIME_DELTA   | FATTR4_WORD1_TIME_METADATA    \\\n | FATTR4_WORD1_TIME_MODIFY     | FATTR4_WORD1_TIME_MODIFY_SET | FATTR4_WORD1_MOUNTED_ON_FILEID)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\n#define NFSD4_1_SUPPORTED_ATTRS_WORD1 \\\n\t(NFSD4_SUPPORTED_ATTRS_WORD1\t| PNFSD_SUPPORTED_ATTRS_WORD1)\n#define NFSD4_SUPPORTED_ATTRS_WORD1                                                         \\\n(FATTR4_WORD1_MODE              | FATTR4_WORD1_NO_TRUNC     | FATTR4_WORD1_NUMLINKS         \\\n | FATTR4_WORD1_OWNER\t        | FATTR4_WORD1_OWNER_GROUP  | FATTR4_WORD1_RAWDEV           \\\n | FATTR4_WORD1_SPACE_AVAIL     | FATTR4_WORD1_SPACE_FREE   | FATTR4_WORD1_SPACE_TOTAL      \\\n | FATTR4_WORD1_SPACE_USED      | FATTR4_WORD1_TIME_ACCESS  | FATTR4_WORD1_TIME_ACCESS_SET  \\\n | FATTR4_WORD1_TIME_DELTA   | FATTR4_WORD1_TIME_METADATA    \\\n | FATTR4_WORD1_TIME_MODIFY     | FATTR4_WORD1_TIME_MODIFY_SET | FATTR4_WORD1_MOUNTED_ON_FILEID)\n\nstatic inline u32 nfsd_suppattrs1(u32 minorversion)\n{\n\treturn minorversion ? NFSD4_1_SUPPORTED_ATTRS_WORD1\n\t\t\t    : NFSD4_SUPPORTED_ATTRS_WORD1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_suppattrs0",
          "args": [
            "cstate->minorversion"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_suppattrs0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsd.h",
          "lines": "359-363",
          "snippet": "static inline u32 nfsd_suppattrs0(u32 minorversion)\n{\n\treturn minorversion ? NFSD4_1_SUPPORTED_ATTRS_WORD0\n\t\t\t    : NFSD4_SUPPORTED_ATTRS_WORD0;\n}",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFSD4_1_SUPPORTED_ATTRS_WORD0 \\\n\tNFSD4_SUPPORTED_ATTRS_WORD0",
            "#define NFSD4_SUPPORTED_ATTRS_WORD0                                                         \\\n(FATTR4_WORD0_SUPPORTED_ATTRS   | FATTR4_WORD0_TYPE         | FATTR4_WORD0_FH_EXPIRE_TYPE   \\\n | FATTR4_WORD0_CHANGE          | FATTR4_WORD0_SIZE         | FATTR4_WORD0_LINK_SUPPORT     \\\n | FATTR4_WORD0_SYMLINK_SUPPORT | FATTR4_WORD0_NAMED_ATTR   | FATTR4_WORD0_FSID             \\\n | FATTR4_WORD0_UNIQUE_HANDLES  | FATTR4_WORD0_LEASE_TIME   | FATTR4_WORD0_RDATTR_ERROR     \\\n | FATTR4_WORD0_ACLSUPPORT      | FATTR4_WORD0_CANSETTIME   | FATTR4_WORD0_CASE_INSENSITIVE \\\n | FATTR4_WORD0_CASE_PRESERVING | FATTR4_WORD0_CHOWN_RESTRICTED                             \\\n | FATTR4_WORD0_FILEHANDLE      | FATTR4_WORD0_FILEID       | FATTR4_WORD0_FILES_AVAIL      \\\n | FATTR4_WORD0_FILES_FREE      | FATTR4_WORD0_FILES_TOTAL  | FATTR4_WORD0_FS_LOCATIONS | FATTR4_WORD0_HOMOGENEOUS      \\\n | FATTR4_WORD0_MAXFILESIZE     | FATTR4_WORD0_MAXLINK      | FATTR4_WORD0_MAXNAME          \\\n | FATTR4_WORD0_MAXREAD         | FATTR4_WORD0_MAXWRITE     | FATTR4_WORD0_ACL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\n#define NFSD4_1_SUPPORTED_ATTRS_WORD0 \\\n\tNFSD4_SUPPORTED_ATTRS_WORD0\n#define NFSD4_SUPPORTED_ATTRS_WORD0                                                         \\\n(FATTR4_WORD0_SUPPORTED_ATTRS   | FATTR4_WORD0_TYPE         | FATTR4_WORD0_FH_EXPIRE_TYPE   \\\n | FATTR4_WORD0_CHANGE          | FATTR4_WORD0_SIZE         | FATTR4_WORD0_LINK_SUPPORT     \\\n | FATTR4_WORD0_SYMLINK_SUPPORT | FATTR4_WORD0_NAMED_ATTR   | FATTR4_WORD0_FSID             \\\n | FATTR4_WORD0_UNIQUE_HANDLES  | FATTR4_WORD0_LEASE_TIME   | FATTR4_WORD0_RDATTR_ERROR     \\\n | FATTR4_WORD0_ACLSUPPORT      | FATTR4_WORD0_CANSETTIME   | FATTR4_WORD0_CASE_INSENSITIVE \\\n | FATTR4_WORD0_CASE_PRESERVING | FATTR4_WORD0_CHOWN_RESTRICTED                             \\\n | FATTR4_WORD0_FILEHANDLE      | FATTR4_WORD0_FILEID       | FATTR4_WORD0_FILES_AVAIL      \\\n | FATTR4_WORD0_FILES_FREE      | FATTR4_WORD0_FILES_TOTAL  | FATTR4_WORD0_FS_LOCATIONS | FATTR4_WORD0_HOMOGENEOUS      \\\n | FATTR4_WORD0_MAXFILESIZE     | FATTR4_WORD0_MAXLINK      | FATTR4_WORD0_MAXNAME          \\\n | FATTR4_WORD0_MAXREAD         | FATTR4_WORD0_MAXWRITE     | FATTR4_WORD0_ACL)\n\nstatic inline u32 nfsd_suppattrs0(u32 minorversion)\n{\n\treturn minorversion ? NFSD4_1_SUPPORTED_ATTRS_WORD0\n\t\t\t    : NFSD4_SUPPORTED_ATTRS_WORD0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_readdir(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      struct nfsd4_readdir *readdir)\n{\n\tu64 cookie = readdir->rd_cookie;\n\tstatic const nfs4_verifier zeroverf;\n\n\t/* no need to check permission - this will be done in nfsd_readdir() */\n\n\tif (readdir->rd_bmval[1] & NFSD_WRITEONLY_ATTRS_WORD1)\n\t\treturn nfserr_inval;\n\n\treaddir->rd_bmval[0] &= nfsd_suppattrs0(cstate->minorversion);\n\treaddir->rd_bmval[1] &= nfsd_suppattrs1(cstate->minorversion);\n\treaddir->rd_bmval[2] &= nfsd_suppattrs2(cstate->minorversion);\n\n\tif ((cookie == 1) || (cookie == 2) ||\n\t    (cookie == 0 && memcmp(readdir->rd_verf.data, zeroverf.data, NFS4_VERIFIER_SIZE)))\n\t\treturn nfserr_bad_cookie;\n\n\treaddir->rd_rqstp = rqstp;\n\treaddir->rd_fhp = &cstate->current_fh;\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "757-792",
    "snippet": "static __be32\nnfsd4_read(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t   struct nfsd4_read *read)\n{\n\t__be32 status;\n\n\t/* no need to check permission - this will be done in nfsd_read() */\n\n\tread->rd_filp = NULL;\n\tif (read->rd_offset >= OFFSET_MAX)\n\t\treturn nfserr_inval;\n\n\t/*\n\t * If we do a zero copy read, then a client will see read data\n\t * that reflects the state of the file *after* performing the\n\t * following compound.\n\t *\n\t * To ensure proper ordering, we therefore turn off zero copy if\n\t * the client wants us to do more in this compound:\n\t */\n\tif (!nfsd4_last_compound_op(rqstp))\n\t\tclear_bit(RQ_SPLICE_OK, &rqstp->rq_flags);\n\n\t/* check stateid */\n\tif ((status = nfs4_preprocess_stateid_op(SVC_NET(rqstp),\n\t\t\t\t\t\t cstate, &read->rd_stateid,\n\t\t\t\t\t\t RD_STATE, &read->rd_filp))) {\n\t\tdprintk(\"NFSD: nfsd4_read: couldn't process stateid!\\n\");\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\nout:\n\tread->rd_rqstp = rqstp;\n\tread->rd_fhp = &cstate->current_fh;\n\treturn status;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfsd4_read: couldn't process stateid!\\n\""
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_preprocess_stateid_op",
          "args": [
            "SVC_NET(rqstp)",
            "cstate",
            "&read->rd_stateid",
            "RD_STATE",
            "&read->rd_filp"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_preprocess_stateid_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4468-4545",
          "snippet": "__be32\nnfs4_preprocess_stateid_op(struct net *net, struct nfsd4_compound_state *cstate,\n\t\t\t   stateid_t *stateid, int flags, struct file **filpp)\n{\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\tstruct nfs4_delegation *dp = NULL;\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct inode *ino = current_fh->fh_dentry->d_inode;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct file *file = NULL;\n\t__be32 status;\n\n\tif (filpp)\n\t\t*filpp = NULL;\n\n\tif (grace_disallows_io(net, ino))\n\t\treturn nfserr_grace;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn check_special_stateids(net, current_fh, stateid, flags);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid,\n\t\t\t\tNFS4_DELEG_STID|NFS4_OPEN_STID|NFS4_LOCK_STID,\n\t\t\t\t&s, nn);\n\tif (status)\n\t\treturn status;\n\tstatus = check_stateid_generation(stateid, &s->sc_stateid, nfsd4_has_session(cstate));\n\tif (status)\n\t\tgoto out;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tdp = delegstateid(s);\n\t\tstatus = nfs4_check_delegmode(dp, flags);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (filpp) {\n\t\t\tfile = dp->dl_stid.sc_file->fi_deleg_file;\n\t\t\tif (!file) {\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\tstatus = nfserr_serverfault;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tget_file(file);\n\t\t}\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tstp = openlockstateid(s);\n\t\tstatus = nfs4_check_fh(current_fh, stp);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (stp->st_stateowner->so_is_open_owner\n\t\t    && !(openowner(stp->st_stateowner)->oo_flags & NFS4_OO_CONFIRMED))\n\t\t\tgoto out;\n\t\tstatus = nfs4_check_openmode(stp, flags);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (filpp) {\n\t\t\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\t\t\tif (flags & RD_STATE)\n\t\t\t\tfile = find_readable_file(fp);\n\t\t\telse\n\t\t\t\tfile = find_writeable_file(fp);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\n\tif (file)\n\t\t*filpp = file;\nout:\n\tnfs4_put_stid(s);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfs4_preprocess_stateid_op(struct net *net, struct nfsd4_compound_state *cstate,\n\t\t\t   stateid_t *stateid, int flags, struct file **filpp)\n{\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\tstruct nfs4_delegation *dp = NULL;\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct inode *ino = current_fh->fh_dentry->d_inode;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct file *file = NULL;\n\t__be32 status;\n\n\tif (filpp)\n\t\t*filpp = NULL;\n\n\tif (grace_disallows_io(net, ino))\n\t\treturn nfserr_grace;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn check_special_stateids(net, current_fh, stateid, flags);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid,\n\t\t\t\tNFS4_DELEG_STID|NFS4_OPEN_STID|NFS4_LOCK_STID,\n\t\t\t\t&s, nn);\n\tif (status)\n\t\treturn status;\n\tstatus = check_stateid_generation(stateid, &s->sc_stateid, nfsd4_has_session(cstate));\n\tif (status)\n\t\tgoto out;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tdp = delegstateid(s);\n\t\tstatus = nfs4_check_delegmode(dp, flags);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (filpp) {\n\t\t\tfile = dp->dl_stid.sc_file->fi_deleg_file;\n\t\t\tif (!file) {\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\tstatus = nfserr_serverfault;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tget_file(file);\n\t\t}\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tstp = openlockstateid(s);\n\t\tstatus = nfs4_check_fh(current_fh, stp);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (stp->st_stateowner->so_is_open_owner\n\t\t    && !(openowner(stp->st_stateowner)->oo_flags & NFS4_OO_CONFIRMED))\n\t\t\tgoto out;\n\t\tstatus = nfs4_check_openmode(stp, flags);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tif (filpp) {\n\t\t\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\t\t\tif (flags & RD_STATE)\n\t\t\t\tfile = find_readable_file(fp);\n\t\t\telse\n\t\t\t\tfile = find_writeable_file(fp);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\n\tif (file)\n\t\t*filpp = file;\nout:\n\tnfs4_put_stid(s);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "RQ_SPLICE_OK",
            "&rqstp->rq_flags"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_last_compound_op",
          "args": [
            "rqstp"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_last_compound_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/xdr4.h",
          "lines": "617-623",
          "snippet": "static inline bool nfsd4_last_compound_op(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\n\treturn argp->opcnt == resp->opcnt;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_last_compound_op(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\n\treturn argp->opcnt == resp->opcnt;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_read(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t   struct nfsd4_read *read)\n{\n\t__be32 status;\n\n\t/* no need to check permission - this will be done in nfsd_read() */\n\n\tread->rd_filp = NULL;\n\tif (read->rd_offset >= OFFSET_MAX)\n\t\treturn nfserr_inval;\n\n\t/*\n\t * If we do a zero copy read, then a client will see read data\n\t * that reflects the state of the file *after* performing the\n\t * following compound.\n\t *\n\t * To ensure proper ordering, we therefore turn off zero copy if\n\t * the client wants us to do more in this compound:\n\t */\n\tif (!nfsd4_last_compound_op(rqstp))\n\t\tclear_bit(RQ_SPLICE_OK, &rqstp->rq_flags);\n\n\t/* check stateid */\n\tif ((status = nfs4_preprocess_stateid_op(SVC_NET(rqstp),\n\t\t\t\t\t\t cstate, &read->rd_stateid,\n\t\t\t\t\t\t RD_STATE, &read->rd_filp))) {\n\t\tdprintk(\"NFSD: nfsd4_read: couldn't process stateid!\\n\");\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\nout:\n\tread->rd_rqstp = rqstp;\n\tread->rd_fhp = &cstate->current_fh;\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "748-755",
    "snippet": "static __be32\nnfsd4_lookup(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_lookup *lookup)\n{\n\treturn nfsd_lookup(rqstp, &cstate->current_fh,\n\t\t\t   lookup->lo_name, lookup->lo_len,\n\t\t\t   &cstate->current_fh);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_lookup",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "lookup->lo_name",
            "lookup->lo_len",
            "&cstate->current_fh"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "251-279",
          "snippet": "__be32\nnfsd_lookup(struct svc_rqst *rqstp, struct svc_fh *fhp, const char *name,\n\t\t\t\tunsigned int len, struct svc_fh *resfh)\n{\n\tstruct svc_export\t*exp;\n\tstruct dentry\t\t*dentry;\n\t__be32 err;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_EXEC);\n\tif (err)\n\t\treturn err;\n\terr = nfsd_lookup_dentry(rqstp, fhp, name, len, &exp, &dentry);\n\tif (err)\n\t\treturn err;\n\terr = check_nfsd_access(exp, rqstp);\n\tif (err)\n\t\tgoto out;\n\t/*\n\t * Note: we compose the file handle now, but as the\n\t * dentry may be negative, it may need to be updated.\n\t */\n\terr = fh_compose(resfh, exp, dentry, fhp);\n\tif (!err && !dentry->d_inode)\n\t\terr = nfserr_noent;\nout:\n\tdput(dentry);\n\texp_put(exp);\n\treturn err;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_lookup(struct svc_rqst *rqstp, struct svc_fh *fhp, const char *name,\n\t\t\t\tunsigned int len, struct svc_fh *resfh)\n{\n\tstruct svc_export\t*exp;\n\tstruct dentry\t\t*dentry;\n\t__be32 err;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_EXEC);\n\tif (err)\n\t\treturn err;\n\terr = nfsd_lookup_dentry(rqstp, fhp, name, len, &exp, &dentry);\n\tif (err)\n\t\treturn err;\n\terr = check_nfsd_access(exp, rqstp);\n\tif (err)\n\t\tgoto out;\n\t/*\n\t * Note: we compose the file handle now, but as the\n\t * dentry may be negative, it may need to be updated.\n\t */\n\terr = fh_compose(resfh, exp, dentry, fhp);\n\tif (!err && !dentry->d_inode)\n\t\terr = nfserr_noent;\nout:\n\tdput(dentry);\n\texp_put(exp);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_lookup(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_lookup *lookup)\n{\n\treturn nfsd_lookup(rqstp, &cstate->current_fh,\n\t\t\t   lookup->lo_name, lookup->lo_len,\n\t\t\t   &cstate->current_fh);\n}"
  },
  {
    "function_name": "nfsd4_lookupp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "741-746",
    "snippet": "static __be32\nnfsd4_lookupp(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      void *arg)\n{\n\treturn nfsd4_do_lookupp(rqstp, &cstate->current_fh);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_do_lookupp",
          "args": [
            "rqstp",
            "&cstate->current_fh"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_do_lookupp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "724-739",
          "snippet": "static __be32 nfsd4_do_lookupp(struct svc_rqst *rqstp, struct svc_fh *fh)\n{\n\tstruct svc_fh tmp_fh;\n\t__be32 ret;\n\n\tfh_init(&tmp_fh, NFS4_FHSIZE);\n\tret = exp_pseudoroot(rqstp, &tmp_fh);\n\tif (ret)\n\t\treturn ret;\n\tif (tmp_fh.fh_dentry == fh->fh_dentry) {\n\t\tfh_put(&tmp_fh);\n\t\treturn nfserr_noent;\n\t}\n\tfh_put(&tmp_fh);\n\treturn nfsd_lookup(rqstp, fh, \"..\", 2, fh);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_do_lookupp(struct svc_rqst *rqstp, struct svc_fh *fh)\n{\n\tstruct svc_fh tmp_fh;\n\t__be32 ret;\n\n\tfh_init(&tmp_fh, NFS4_FHSIZE);\n\tret = exp_pseudoroot(rqstp, &tmp_fh);\n\tif (ret)\n\t\treturn ret;\n\tif (tmp_fh.fh_dentry == fh->fh_dentry) {\n\t\tfh_put(&tmp_fh);\n\t\treturn nfserr_noent;\n\t}\n\tfh_put(&tmp_fh);\n\treturn nfsd_lookup(rqstp, fh, \"..\", 2, fh);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_lookupp(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      void *arg)\n{\n\treturn nfsd4_do_lookupp(rqstp, &cstate->current_fh);\n}"
  },
  {
    "function_name": "nfsd4_do_lookupp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "724-739",
    "snippet": "static __be32 nfsd4_do_lookupp(struct svc_rqst *rqstp, struct svc_fh *fh)\n{\n\tstruct svc_fh tmp_fh;\n\t__be32 ret;\n\n\tfh_init(&tmp_fh, NFS4_FHSIZE);\n\tret = exp_pseudoroot(rqstp, &tmp_fh);\n\tif (ret)\n\t\treturn ret;\n\tif (tmp_fh.fh_dentry == fh->fh_dentry) {\n\t\tfh_put(&tmp_fh);\n\t\treturn nfserr_noent;\n\t}\n\tfh_put(&tmp_fh);\n\treturn nfsd_lookup(rqstp, fh, \"..\", 2, fh);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_lookup",
          "args": [
            "rqstp",
            "fh",
            "\"..\"",
            "2",
            "fh"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "251-279",
          "snippet": "__be32\nnfsd_lookup(struct svc_rqst *rqstp, struct svc_fh *fhp, const char *name,\n\t\t\t\tunsigned int len, struct svc_fh *resfh)\n{\n\tstruct svc_export\t*exp;\n\tstruct dentry\t\t*dentry;\n\t__be32 err;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_EXEC);\n\tif (err)\n\t\treturn err;\n\terr = nfsd_lookup_dentry(rqstp, fhp, name, len, &exp, &dentry);\n\tif (err)\n\t\treturn err;\n\terr = check_nfsd_access(exp, rqstp);\n\tif (err)\n\t\tgoto out;\n\t/*\n\t * Note: we compose the file handle now, but as the\n\t * dentry may be negative, it may need to be updated.\n\t */\n\terr = fh_compose(resfh, exp, dentry, fhp);\n\tif (!err && !dentry->d_inode)\n\t\terr = nfserr_noent;\nout:\n\tdput(dentry);\n\texp_put(exp);\n\treturn err;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_lookup(struct svc_rqst *rqstp, struct svc_fh *fhp, const char *name,\n\t\t\t\tunsigned int len, struct svc_fh *resfh)\n{\n\tstruct svc_export\t*exp;\n\tstruct dentry\t\t*dentry;\n\t__be32 err;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_EXEC);\n\tif (err)\n\t\treturn err;\n\terr = nfsd_lookup_dentry(rqstp, fhp, name, len, &exp, &dentry);\n\tif (err)\n\t\treturn err;\n\terr = check_nfsd_access(exp, rqstp);\n\tif (err)\n\t\tgoto out;\n\t/*\n\t * Note: we compose the file handle now, but as the\n\t * dentry may be negative, it may need to be updated.\n\t */\n\terr = fh_compose(resfh, exp, dentry, fhp);\n\tif (!err && !dentry->d_inode)\n\t\terr = nfserr_noent;\nout:\n\tdput(dentry);\n\texp_put(exp);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&tmp_fh"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "625-645",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp_pseudoroot",
          "args": [
            "rqstp",
            "&tmp_fh"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "exp_pseudoroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "1065-1077",
          "snippet": "__be32\nexp_pseudoroot(struct svc_rqst *rqstp, struct svc_fh *fhp)\n{\n\tstruct svc_export *exp;\n\t__be32 rv;\n\n\texp = rqst_find_fsidzero_export(rqstp);\n\tif (IS_ERR(exp))\n\t\treturn nfserrno(PTR_ERR(exp));\n\trv = fh_compose(fhp, exp, exp->ex_path.dentry, NULL);\n\texp_put(exp);\n\treturn rv;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\n__be32\nexp_pseudoroot(struct svc_rqst *rqstp, struct svc_fh *fhp)\n{\n\tstruct svc_export *exp;\n\t__be32 rv;\n\n\texp = rqst_find_fsidzero_export(rqstp);\n\tif (IS_ERR(exp))\n\t\treturn nfserrno(PTR_ERR(exp));\n\trv = fh_compose(fhp, exp, exp->ex_path.dentry, NULL);\n\texp_put(exp);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_init",
          "args": [
            "&tmp_fh",
            "NFS4_FHSIZE"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "fh_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "182-188",
          "snippet": "static __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_do_lookupp(struct svc_rqst *rqstp, struct svc_fh *fh)\n{\n\tstruct svc_fh tmp_fh;\n\t__be32 ret;\n\n\tfh_init(&tmp_fh, NFS4_FHSIZE);\n\tret = exp_pseudoroot(rqstp, &tmp_fh);\n\tif (ret)\n\t\treturn ret;\n\tif (tmp_fh.fh_dentry == fh->fh_dentry) {\n\t\tfh_put(&tmp_fh);\n\t\treturn nfserr_noent;\n\t}\n\tfh_put(&tmp_fh);\n\treturn nfsd_lookup(rqstp, fh, \"..\", 2, fh);\n}"
  },
  {
    "function_name": "nfsd4_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "709-722",
    "snippet": "static __be32\nnfsd4_link(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t   struct nfsd4_link *link)\n{\n\t__be32 status = nfserr_nofilehandle;\n\n\tif (!cstate->save_fh.fh_dentry)\n\t\treturn status;\n\tstatus = nfsd_link(rqstp, &cstate->current_fh,\n\t\t\t   link->li_name, link->li_namelen, &cstate->save_fh);\n\tif (!status)\n\t\tset_change_info(&link->li_cinfo, &cstate->current_fh);\n\treturn status;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_change_info",
          "args": [
            "&link->li_cinfo",
            "&cstate->current_fh"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "set_change_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/xdr4.h",
          "lines": "630-644",
          "snippet": "static inline void\nset_change_info(struct nfsd4_change_info *cinfo, struct svc_fh *fhp)\n{\n\tBUG_ON(!fhp->fh_pre_saved);\n\tcinfo->atomic = fhp->fh_post_saved;\n\tcinfo->change_supported = IS_I_VERSION(fhp->fh_dentry->d_inode);\n\n\tcinfo->before_change = fhp->fh_pre_change;\n\tcinfo->after_change = fhp->fh_post_change;\n\tcinfo->before_ctime_sec = fhp->fh_pre_ctime.tv_sec;\n\tcinfo->before_ctime_nsec = fhp->fh_pre_ctime.tv_nsec;\n\tcinfo->after_ctime_sec = fhp->fh_post_attr.ctime.tv_sec;\n\tcinfo->after_ctime_nsec = fhp->fh_post_attr.ctime.tv_nsec;\n\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline void\nset_change_info(struct nfsd4_change_info *cinfo, struct svc_fh *fhp)\n{\n\tBUG_ON(!fhp->fh_pre_saved);\n\tcinfo->atomic = fhp->fh_post_saved;\n\tcinfo->change_supported = IS_I_VERSION(fhp->fh_dentry->d_inode);\n\n\tcinfo->before_change = fhp->fh_pre_change;\n\tcinfo->after_change = fhp->fh_post_change;\n\tcinfo->before_ctime_sec = fhp->fh_pre_ctime.tv_sec;\n\tcinfo->before_ctime_nsec = fhp->fh_pre_ctime.tv_nsec;\n\tcinfo->after_ctime_sec = fhp->fh_post_attr.ctime.tv_sec;\n\tcinfo->after_ctime_nsec = fhp->fh_post_attr.ctime.tv_nsec;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_link",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "link->li_name",
            "link->li_namelen",
            "&cstate->save_fh"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "1602-1669",
          "snippet": "__be32\nnfsd_link(struct svc_rqst *rqstp, struct svc_fh *ffhp,\n\t\t\t\tchar *name, int len, struct svc_fh *tfhp)\n{\n\tstruct dentry\t*ddir, *dnew, *dold;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\terr = fh_verify(rqstp, ffhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\terr = fh_verify(rqstp, tfhp, 0, NFSD_MAY_NOP);\n\tif (err)\n\t\tgoto out;\n\terr = nfserr_isdir;\n\tif (d_is_dir(tfhp->fh_dentry))\n\t\tgoto out;\n\terr = nfserr_perm;\n\tif (!len)\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(name, len))\n\t\tgoto out;\n\n\thost_err = fh_want_write(tfhp);\n\tif (host_err) {\n\t\terr = nfserrno(host_err);\n\t\tgoto out;\n\t}\n\n\tfh_lock_nested(ffhp, I_MUTEX_PARENT);\n\tddir = ffhp->fh_dentry;\n\tdirp = ddir->d_inode;\n\n\tdnew = lookup_one_len(name, ddir, len);\n\thost_err = PTR_ERR(dnew);\n\tif (IS_ERR(dnew))\n\t\tgoto out_nfserr;\n\n\tdold = tfhp->fh_dentry;\n\n\terr = nfserr_noent;\n\tif (!dold->d_inode)\n\t\tgoto out_dput;\n\thost_err = vfs_link(dold, dirp, dnew, NULL);\n\tif (!host_err) {\n\t\terr = nfserrno(commit_metadata(ffhp));\n\t\tif (!err)\n\t\t\terr = nfserrno(commit_metadata(tfhp));\n\t} else {\n\t\tif (host_err == -EXDEV && rqstp->rq_vers == 2)\n\t\t\terr = nfserr_acces;\n\t\telse\n\t\t\terr = nfserrno(host_err);\n\t}\nout_dput:\n\tdput(dnew);\nout_unlock:\n\tfh_unlock(ffhp);\n\tfh_drop_write(tfhp);\nout:\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_link(struct svc_rqst *rqstp, struct svc_fh *ffhp,\n\t\t\t\tchar *name, int len, struct svc_fh *tfhp)\n{\n\tstruct dentry\t*ddir, *dnew, *dold;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\terr = fh_verify(rqstp, ffhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\terr = fh_verify(rqstp, tfhp, 0, NFSD_MAY_NOP);\n\tif (err)\n\t\tgoto out;\n\terr = nfserr_isdir;\n\tif (d_is_dir(tfhp->fh_dentry))\n\t\tgoto out;\n\terr = nfserr_perm;\n\tif (!len)\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(name, len))\n\t\tgoto out;\n\n\thost_err = fh_want_write(tfhp);\n\tif (host_err) {\n\t\terr = nfserrno(host_err);\n\t\tgoto out;\n\t}\n\n\tfh_lock_nested(ffhp, I_MUTEX_PARENT);\n\tddir = ffhp->fh_dentry;\n\tdirp = ddir->d_inode;\n\n\tdnew = lookup_one_len(name, ddir, len);\n\thost_err = PTR_ERR(dnew);\n\tif (IS_ERR(dnew))\n\t\tgoto out_nfserr;\n\n\tdold = tfhp->fh_dentry;\n\n\terr = nfserr_noent;\n\tif (!dold->d_inode)\n\t\tgoto out_dput;\n\thost_err = vfs_link(dold, dirp, dnew, NULL);\n\tif (!host_err) {\n\t\terr = nfserrno(commit_metadata(ffhp));\n\t\tif (!err)\n\t\t\terr = nfserrno(commit_metadata(tfhp));\n\t} else {\n\t\tif (host_err == -EXDEV && rqstp->rq_vers == 2)\n\t\t\terr = nfserr_acces;\n\t\telse\n\t\t\terr = nfserrno(host_err);\n\t}\nout_dput:\n\tdput(dnew);\nout_unlock:\n\tfh_unlock(ffhp);\n\tfh_drop_write(tfhp);\nout:\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out_unlock;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_link(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t   struct nfsd4_link *link)\n{\n\t__be32 status = nfserr_nofilehandle;\n\n\tif (!cstate->save_fh.fh_dentry)\n\t\treturn status;\n\tstatus = nfsd_link(rqstp, &cstate->current_fh,\n\t\t\t   link->li_name, link->li_namelen, &cstate->save_fh);\n\tif (!status)\n\t\tset_change_info(&link->li_cinfo, &cstate->current_fh);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "688-707",
    "snippet": "static __be32\nnfsd4_getattr(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      struct nfsd4_getattr *getattr)\n{\n\t__be32 status;\n\n\tstatus = fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_NOP);\n\tif (status)\n\t\treturn status;\n\n\tif (getattr->ga_bmval[1] & NFSD_WRITEONLY_ATTRS_WORD1)\n\t\treturn nfserr_inval;\n\n\tgetattr->ga_bmval[0] &= nfsd_suppattrs0(cstate->minorversion);\n\tgetattr->ga_bmval[1] &= nfsd_suppattrs1(cstate->minorversion);\n\tgetattr->ga_bmval[2] &= nfsd_suppattrs2(cstate->minorversion);\n\n\tgetattr->ga_fhp = &cstate->current_fh;\n\treturn nfs_ok;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_suppattrs2",
          "args": [
            "cstate->minorversion"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_suppattrs2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsd.h",
          "lines": "371-378",
          "snippet": "static inline u32 nfsd_suppattrs2(u32 minorversion)\n{\n\tswitch (minorversion) {\n\tdefault: return NFSD4_2_SUPPORTED_ATTRS_WORD2;\n\tcase 1:  return NFSD4_1_SUPPORTED_ATTRS_WORD2;\n\tcase 0:  return NFSD4_SUPPORTED_ATTRS_WORD2;\n\t}\n}",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFSD4_2_SUPPORTED_ATTRS_WORD2 \\\n\t(NFSD4_1_SUPPORTED_ATTRS_WORD2 | \\\n\tNFSD4_2_SECURITY_ATTRS)",
            "#define NFSD4_1_SUPPORTED_ATTRS_WORD2 \\\n\t(NFSD4_SUPPORTED_ATTRS_WORD2\t| PNFSD_SUPPORTED_ATTRS_WORD2 | \\\n\t FATTR4_WORD2_SUPPATTR_EXCLCREAT)",
            "#define NFSD4_SUPPORTED_ATTRS_WORD2 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\n#define NFSD4_2_SUPPORTED_ATTRS_WORD2 \\\n\t(NFSD4_1_SUPPORTED_ATTRS_WORD2 | \\\n\tNFSD4_2_SECURITY_ATTRS)\n#define NFSD4_1_SUPPORTED_ATTRS_WORD2 \\\n\t(NFSD4_SUPPORTED_ATTRS_WORD2\t| PNFSD_SUPPORTED_ATTRS_WORD2 | \\\n\t FATTR4_WORD2_SUPPATTR_EXCLCREAT)\n#define NFSD4_SUPPORTED_ATTRS_WORD2 0\n\nstatic inline u32 nfsd_suppattrs2(u32 minorversion)\n{\n\tswitch (minorversion) {\n\tdefault: return NFSD4_2_SUPPORTED_ATTRS_WORD2;\n\tcase 1:  return NFSD4_1_SUPPORTED_ATTRS_WORD2;\n\tcase 0:  return NFSD4_SUPPORTED_ATTRS_WORD2;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_suppattrs1",
          "args": [
            "cstate->minorversion"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_suppattrs1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsd.h",
          "lines": "365-369",
          "snippet": "static inline u32 nfsd_suppattrs1(u32 minorversion)\n{\n\treturn minorversion ? NFSD4_1_SUPPORTED_ATTRS_WORD1\n\t\t\t    : NFSD4_SUPPORTED_ATTRS_WORD1;\n}",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFSD4_1_SUPPORTED_ATTRS_WORD1 \\\n\t(NFSD4_SUPPORTED_ATTRS_WORD1\t| PNFSD_SUPPORTED_ATTRS_WORD1)",
            "#define NFSD4_SUPPORTED_ATTRS_WORD1                                                         \\\n(FATTR4_WORD1_MODE              | FATTR4_WORD1_NO_TRUNC     | FATTR4_WORD1_NUMLINKS         \\\n | FATTR4_WORD1_OWNER\t        | FATTR4_WORD1_OWNER_GROUP  | FATTR4_WORD1_RAWDEV           \\\n | FATTR4_WORD1_SPACE_AVAIL     | FATTR4_WORD1_SPACE_FREE   | FATTR4_WORD1_SPACE_TOTAL      \\\n | FATTR4_WORD1_SPACE_USED      | FATTR4_WORD1_TIME_ACCESS  | FATTR4_WORD1_TIME_ACCESS_SET  \\\n | FATTR4_WORD1_TIME_DELTA   | FATTR4_WORD1_TIME_METADATA    \\\n | FATTR4_WORD1_TIME_MODIFY     | FATTR4_WORD1_TIME_MODIFY_SET | FATTR4_WORD1_MOUNTED_ON_FILEID)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\n#define NFSD4_1_SUPPORTED_ATTRS_WORD1 \\\n\t(NFSD4_SUPPORTED_ATTRS_WORD1\t| PNFSD_SUPPORTED_ATTRS_WORD1)\n#define NFSD4_SUPPORTED_ATTRS_WORD1                                                         \\\n(FATTR4_WORD1_MODE              | FATTR4_WORD1_NO_TRUNC     | FATTR4_WORD1_NUMLINKS         \\\n | FATTR4_WORD1_OWNER\t        | FATTR4_WORD1_OWNER_GROUP  | FATTR4_WORD1_RAWDEV           \\\n | FATTR4_WORD1_SPACE_AVAIL     | FATTR4_WORD1_SPACE_FREE   | FATTR4_WORD1_SPACE_TOTAL      \\\n | FATTR4_WORD1_SPACE_USED      | FATTR4_WORD1_TIME_ACCESS  | FATTR4_WORD1_TIME_ACCESS_SET  \\\n | FATTR4_WORD1_TIME_DELTA   | FATTR4_WORD1_TIME_METADATA    \\\n | FATTR4_WORD1_TIME_MODIFY     | FATTR4_WORD1_TIME_MODIFY_SET | FATTR4_WORD1_MOUNTED_ON_FILEID)\n\nstatic inline u32 nfsd_suppattrs1(u32 minorversion)\n{\n\treturn minorversion ? NFSD4_1_SUPPORTED_ATTRS_WORD1\n\t\t\t    : NFSD4_SUPPORTED_ATTRS_WORD1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_suppattrs0",
          "args": [
            "cstate->minorversion"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_suppattrs0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsd.h",
          "lines": "359-363",
          "snippet": "static inline u32 nfsd_suppattrs0(u32 minorversion)\n{\n\treturn minorversion ? NFSD4_1_SUPPORTED_ATTRS_WORD0\n\t\t\t    : NFSD4_SUPPORTED_ATTRS_WORD0;\n}",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFSD4_1_SUPPORTED_ATTRS_WORD0 \\\n\tNFSD4_SUPPORTED_ATTRS_WORD0",
            "#define NFSD4_SUPPORTED_ATTRS_WORD0                                                         \\\n(FATTR4_WORD0_SUPPORTED_ATTRS   | FATTR4_WORD0_TYPE         | FATTR4_WORD0_FH_EXPIRE_TYPE   \\\n | FATTR4_WORD0_CHANGE          | FATTR4_WORD0_SIZE         | FATTR4_WORD0_LINK_SUPPORT     \\\n | FATTR4_WORD0_SYMLINK_SUPPORT | FATTR4_WORD0_NAMED_ATTR   | FATTR4_WORD0_FSID             \\\n | FATTR4_WORD0_UNIQUE_HANDLES  | FATTR4_WORD0_LEASE_TIME   | FATTR4_WORD0_RDATTR_ERROR     \\\n | FATTR4_WORD0_ACLSUPPORT      | FATTR4_WORD0_CANSETTIME   | FATTR4_WORD0_CASE_INSENSITIVE \\\n | FATTR4_WORD0_CASE_PRESERVING | FATTR4_WORD0_CHOWN_RESTRICTED                             \\\n | FATTR4_WORD0_FILEHANDLE      | FATTR4_WORD0_FILEID       | FATTR4_WORD0_FILES_AVAIL      \\\n | FATTR4_WORD0_FILES_FREE      | FATTR4_WORD0_FILES_TOTAL  | FATTR4_WORD0_FS_LOCATIONS | FATTR4_WORD0_HOMOGENEOUS      \\\n | FATTR4_WORD0_MAXFILESIZE     | FATTR4_WORD0_MAXLINK      | FATTR4_WORD0_MAXNAME          \\\n | FATTR4_WORD0_MAXREAD         | FATTR4_WORD0_MAXWRITE     | FATTR4_WORD0_ACL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\n#define NFSD4_1_SUPPORTED_ATTRS_WORD0 \\\n\tNFSD4_SUPPORTED_ATTRS_WORD0\n#define NFSD4_SUPPORTED_ATTRS_WORD0                                                         \\\n(FATTR4_WORD0_SUPPORTED_ATTRS   | FATTR4_WORD0_TYPE         | FATTR4_WORD0_FH_EXPIRE_TYPE   \\\n | FATTR4_WORD0_CHANGE          | FATTR4_WORD0_SIZE         | FATTR4_WORD0_LINK_SUPPORT     \\\n | FATTR4_WORD0_SYMLINK_SUPPORT | FATTR4_WORD0_NAMED_ATTR   | FATTR4_WORD0_FSID             \\\n | FATTR4_WORD0_UNIQUE_HANDLES  | FATTR4_WORD0_LEASE_TIME   | FATTR4_WORD0_RDATTR_ERROR     \\\n | FATTR4_WORD0_ACLSUPPORT      | FATTR4_WORD0_CANSETTIME   | FATTR4_WORD0_CASE_INSENSITIVE \\\n | FATTR4_WORD0_CASE_PRESERVING | FATTR4_WORD0_CHOWN_RESTRICTED                             \\\n | FATTR4_WORD0_FILEHANDLE      | FATTR4_WORD0_FILEID       | FATTR4_WORD0_FILES_AVAIL      \\\n | FATTR4_WORD0_FILES_FREE      | FATTR4_WORD0_FILES_TOTAL  | FATTR4_WORD0_FS_LOCATIONS | FATTR4_WORD0_HOMOGENEOUS      \\\n | FATTR4_WORD0_MAXFILESIZE     | FATTR4_WORD0_MAXLINK      | FATTR4_WORD0_MAXNAME          \\\n | FATTR4_WORD0_MAXREAD         | FATTR4_WORD0_MAXWRITE     | FATTR4_WORD0_ACL)\n\nstatic inline u32 nfsd_suppattrs0(u32 minorversion)\n{\n\treturn minorversion ? NFSD4_1_SUPPORTED_ATTRS_WORD0\n\t\t\t    : NFSD4_SUPPORTED_ATTRS_WORD0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "0",
            "NFSD_MAY_NOP"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_getattr(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      struct nfsd4_getattr *getattr)\n{\n\t__be32 status;\n\n\tstatus = fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_NOP);\n\tif (status)\n\t\treturn status;\n\n\tif (getattr->ga_bmval[1] & NFSD_WRITEONLY_ATTRS_WORD1)\n\t\treturn nfserr_inval;\n\n\tgetattr->ga_bmval[0] &= nfsd_suppattrs0(cstate->minorversion);\n\tgetattr->ga_bmval[1] &= nfsd_suppattrs1(cstate->minorversion);\n\tgetattr->ga_bmval[2] &= nfsd_suppattrs2(cstate->minorversion);\n\n\tgetattr->ga_fhp = &cstate->current_fh;\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "600-686",
    "snippet": "static __be32\nnfsd4_create(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_create *create)\n{\n\tstruct svc_fh resfh;\n\t__be32 status;\n\tdev_t rdev;\n\n\tfh_init(&resfh, NFS4_FHSIZE);\n\n\tstatus = fh_verify(rqstp, &cstate->current_fh, S_IFDIR,\n\t\t\t   NFSD_MAY_CREATE);\n\tif (status)\n\t\treturn status;\n\n\tstatus = check_attr_support(rqstp, cstate, create->cr_bmval,\n\t\t\t\t    nfsd_attrmask);\n\tif (status)\n\t\treturn status;\n\n\tswitch (create->cr_type) {\n\tcase NF4LNK:\n\t\tstatus = nfsd_symlink(rqstp, &cstate->current_fh,\n\t\t\t\t      create->cr_name, create->cr_namelen,\n\t\t\t\t      create->cr_data, &resfh);\n\t\tbreak;\n\n\tcase NF4BLK:\n\t\trdev = MKDEV(create->cr_specdata1, create->cr_specdata2);\n\t\tif (MAJOR(rdev) != create->cr_specdata1 ||\n\t\t    MINOR(rdev) != create->cr_specdata2)\n\t\t\treturn nfserr_inval;\n\t\tstatus = nfsd_create(rqstp, &cstate->current_fh,\n\t\t\t\t     create->cr_name, create->cr_namelen,\n\t\t\t\t     &create->cr_iattr, S_IFBLK, rdev, &resfh);\n\t\tbreak;\n\n\tcase NF4CHR:\n\t\trdev = MKDEV(create->cr_specdata1, create->cr_specdata2);\n\t\tif (MAJOR(rdev) != create->cr_specdata1 ||\n\t\t    MINOR(rdev) != create->cr_specdata2)\n\t\t\treturn nfserr_inval;\n\t\tstatus = nfsd_create(rqstp, &cstate->current_fh,\n\t\t\t\t     create->cr_name, create->cr_namelen,\n\t\t\t\t     &create->cr_iattr,S_IFCHR, rdev, &resfh);\n\t\tbreak;\n\n\tcase NF4SOCK:\n\t\tstatus = nfsd_create(rqstp, &cstate->current_fh,\n\t\t\t\t     create->cr_name, create->cr_namelen,\n\t\t\t\t     &create->cr_iattr, S_IFSOCK, 0, &resfh);\n\t\tbreak;\n\n\tcase NF4FIFO:\n\t\tstatus = nfsd_create(rqstp, &cstate->current_fh,\n\t\t\t\t     create->cr_name, create->cr_namelen,\n\t\t\t\t     &create->cr_iattr, S_IFIFO, 0, &resfh);\n\t\tbreak;\n\n\tcase NF4DIR:\n\t\tcreate->cr_iattr.ia_valid &= ~ATTR_SIZE;\n\t\tstatus = nfsd_create(rqstp, &cstate->current_fh,\n\t\t\t\t     create->cr_name, create->cr_namelen,\n\t\t\t\t     &create->cr_iattr, S_IFDIR, 0, &resfh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = nfserr_badtype;\n\t}\n\n\tif (status)\n\t\tgoto out;\n\n\tif (create->cr_label.len)\n\t\tnfsd4_security_inode_setsecctx(&resfh, &create->cr_label, create->cr_bmval);\n\n\tif (create->cr_acl != NULL)\n\t\tdo_set_nfs4_acl(rqstp, &resfh, create->cr_acl,\n\t\t\t\tcreate->cr_bmval);\n\n\tfh_unlock(&cstate->current_fh);\n\tset_change_info(&create->cr_cinfo, &cstate->current_fh);\n\tfh_dup2(&cstate->current_fh, &resfh);\nout:\n\tfh_put(&resfh);\n\treturn status;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 nfsd_attrmask[] = {\n\tNFSD_WRITEABLE_ATTRS_WORD0,\n\tNFSD_WRITEABLE_ATTRS_WORD1,\n\tNFSD_WRITEABLE_ATTRS_WORD2\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&resfh"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "625-645",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_dup2",
          "args": [
            "&cstate->current_fh",
            "&resfh"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "fh_dup2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "177-185",
          "snippet": "static inline void\nfh_dup2(struct svc_fh *dst, struct svc_fh *src)\n{\n\tfh_put(dst);\n\tdget(src->fh_dentry);\n\tif (src->fh_export)\n\t\texp_get(src->fh_export);\n\t*dst = *src;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic inline void\nfh_dup2(struct svc_fh *dst, struct svc_fh *src)\n{\n\tfh_put(dst);\n\tdget(src->fh_dentry);\n\tif (src->fh_export)\n\t\texp_get(src->fh_export);\n\t*dst = *src;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_change_info",
          "args": [
            "&create->cr_cinfo",
            "&cstate->current_fh"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "set_change_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/xdr4.h",
          "lines": "630-644",
          "snippet": "static inline void\nset_change_info(struct nfsd4_change_info *cinfo, struct svc_fh *fhp)\n{\n\tBUG_ON(!fhp->fh_pre_saved);\n\tcinfo->atomic = fhp->fh_post_saved;\n\tcinfo->change_supported = IS_I_VERSION(fhp->fh_dentry->d_inode);\n\n\tcinfo->before_change = fhp->fh_pre_change;\n\tcinfo->after_change = fhp->fh_post_change;\n\tcinfo->before_ctime_sec = fhp->fh_pre_ctime.tv_sec;\n\tcinfo->before_ctime_nsec = fhp->fh_pre_ctime.tv_nsec;\n\tcinfo->after_ctime_sec = fhp->fh_post_attr.ctime.tv_sec;\n\tcinfo->after_ctime_nsec = fhp->fh_post_attr.ctime.tv_nsec;\n\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline void\nset_change_info(struct nfsd4_change_info *cinfo, struct svc_fh *fhp)\n{\n\tBUG_ON(!fhp->fh_pre_saved);\n\tcinfo->atomic = fhp->fh_post_saved;\n\tcinfo->change_supported = IS_I_VERSION(fhp->fh_dentry->d_inode);\n\n\tcinfo->before_change = fhp->fh_pre_change;\n\tcinfo->after_change = fhp->fh_post_change;\n\tcinfo->before_ctime_sec = fhp->fh_pre_ctime.tv_sec;\n\tcinfo->before_ctime_nsec = fhp->fh_pre_ctime.tv_nsec;\n\tcinfo->after_ctime_sec = fhp->fh_post_attr.ctime.tv_sec;\n\tcinfo->after_ctime_nsec = fhp->fh_post_attr.ctime.tv_nsec;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_unlock",
          "args": [
            "&cstate->current_fh"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "fh_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "282-290",
          "snippet": "static inline void\nfh_unlock(struct svc_fh *fhp)\n{\n\tif (fhp->fh_locked) {\n\t\tfill_post_wcc(fhp);\n\t\tmutex_unlock(&fhp->fh_dentry->d_inode->i_mutex);\n\t\tfhp->fh_locked = 0;\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline void\nfh_unlock(struct svc_fh *fhp)\n{\n\tif (fhp->fh_locked) {\n\t\tfill_post_wcc(fhp);\n\t\tmutex_unlock(&fhp->fh_dentry->d_inode->i_mutex);\n\t\tfhp->fh_locked = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_set_nfs4_acl",
          "args": [
            "rqstp",
            "&resfh",
            "create->cr_acl",
            "create->cr_bmval"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "do_set_nfs4_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "161-175",
          "snippet": "static void\ndo_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl, u32 *bmval)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_set_nfs4_acl(rqstp, fhp, acl);\n\tif (status)\n\t\t/*\n\t\t * We should probably fail the whole open at this point,\n\t\t * but we've already created the file, so it's too late;\n\t\t * So this seems the least of evils:\n\t\t */\n\t\tbmval[0] &= ~FATTR4_WORD0_ACL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic void\ndo_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl, u32 *bmval)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_set_nfs4_acl(rqstp, fhp, acl);\n\tif (status)\n\t\t/*\n\t\t * We should probably fail the whole open at this point,\n\t\t * but we've already created the file, so it's too late;\n\t\t * So this seems the least of evils:\n\t\t */\n\t\tbmval[0] &= ~FATTR4_WORD0_ACL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_security_inode_setsecctx",
          "args": [
            "&resfh",
            "&create->cr_label",
            "create->cr_bmval"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_security_inode_setsecctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "74-76",
          "snippet": "static inline void\nnfsd4_security_inode_setsecctx(struct svc_fh *resfh, struct xdr_netobj *label, u32 *bmval)\n{ }",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic inline void\nnfsd4_security_inode_setsecctx(struct svc_fh *resfh, struct xdr_netobj *label, u32 *bmval)\n{ }"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_create",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "create->cr_name",
            "create->cr_namelen",
            "&create->cr_iattr",
            "S_IFDIR",
            "0",
            "&resfh"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "1191-1318",
          "snippet": "__be32\nnfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tchar *fname, int flen, struct iattr *iap,\n\t\tint type, dev_t rdev, struct svc_fh *resfhp)\n{\n\tstruct dentry\t*dentry, *dchild = NULL;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\t__be32\t\terr2;\n\tint\t\thost_err;\n\n\terr = nfserr_perm;\n\tif (!flen)\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(fname, flen))\n\t\tgoto out;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\tdentry = fhp->fh_dentry;\n\tdirp = dentry->d_inode;\n\n\terr = nfserr_notdir;\n\tif (!dirp->i_op->lookup)\n\t\tgoto out;\n\t/*\n\t * Check whether the response file handle has been verified yet.\n\t * If it has, the parent directory should already be locked.\n\t */\n\tif (!resfhp->fh_dentry) {\n\t\thost_err = fh_want_write(fhp);\n\t\tif (host_err)\n\t\t\tgoto out_nfserr;\n\n\t\t/* called from nfsd_proc_mkdir, or possibly nfsd3_proc_create */\n\t\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\t\tdchild = lookup_one_len(fname, dentry, flen);\n\t\thost_err = PTR_ERR(dchild);\n\t\tif (IS_ERR(dchild))\n\t\t\tgoto out_nfserr;\n\t\terr = fh_compose(resfhp, fhp->fh_export, dchild, fhp);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\t/* called from nfsd_proc_create */\n\t\tdchild = dget(resfhp->fh_dentry);\n\t\tif (!fhp->fh_locked) {\n\t\t\t/* not actually possible */\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"nfsd_create: parent %pd2 not locked!\\n\",\n\t\t\t\tdentry);\n\t\t\terr = nfserr_io;\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/*\n\t * Make sure the child dentry is still negative ...\n\t */\n\terr = nfserr_exist;\n\tif (dchild->d_inode) {\n\t\tdprintk(\"nfsd_create: dentry %pd/%pd not negative!\\n\",\n\t\t\tdentry, dchild);\n\t\tgoto out; \n\t}\n\n\tif (!(iap->ia_valid & ATTR_MODE))\n\t\tiap->ia_mode = 0;\n\tiap->ia_mode = (iap->ia_mode & S_IALLUGO) | type;\n\n\terr = nfserr_inval;\n\tif (!S_ISREG(type) && !S_ISDIR(type) && !special_file(type)) {\n\t\tprintk(KERN_WARNING \"nfsd: bad file type %o in nfsd_create\\n\",\n\t\t       type);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Get the dir op function pointer.\n\t */\n\terr = 0;\n\thost_err = 0;\n\tswitch (type) {\n\tcase S_IFREG:\n\t\thost_err = vfs_create(dirp, dchild, iap->ia_mode, true);\n\t\tif (!host_err)\n\t\t\tnfsd_check_ignore_resizing(iap);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\thost_err = vfs_mkdir(dirp, dchild, iap->ia_mode);\n\t\tbreak;\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\thost_err = vfs_mknod(dirp, dchild, iap->ia_mode, rdev);\n\t\tbreak;\n\t}\n\tif (host_err < 0)\n\t\tgoto out_nfserr;\n\n\terr = nfsd_create_setattr(rqstp, resfhp, iap);\n\n\t/*\n\t * nfsd_create_setattr already committed the child.  Transactional\n\t * filesystems had a chance to commit changes for both parent and\n\t * child * simultaneously making the following commit_metadata a\n\t * noop.\n\t */\n\terr2 = nfserrno(commit_metadata(fhp));\n\tif (err2)\n\t\terr = err2;\n\t/*\n\t * Update the file handle to get the new inode info.\n\t */\n\tif (!err)\n\t\terr = fh_update(resfhp);\nout:\n\tif (dchild && !IS_ERR(dchild))\n\t\tdput(dchild);\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tchar *fname, int flen, struct iattr *iap,\n\t\tint type, dev_t rdev, struct svc_fh *resfhp)\n{\n\tstruct dentry\t*dentry, *dchild = NULL;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\t__be32\t\terr2;\n\tint\t\thost_err;\n\n\terr = nfserr_perm;\n\tif (!flen)\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(fname, flen))\n\t\tgoto out;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\tdentry = fhp->fh_dentry;\n\tdirp = dentry->d_inode;\n\n\terr = nfserr_notdir;\n\tif (!dirp->i_op->lookup)\n\t\tgoto out;\n\t/*\n\t * Check whether the response file handle has been verified yet.\n\t * If it has, the parent directory should already be locked.\n\t */\n\tif (!resfhp->fh_dentry) {\n\t\thost_err = fh_want_write(fhp);\n\t\tif (host_err)\n\t\t\tgoto out_nfserr;\n\n\t\t/* called from nfsd_proc_mkdir, or possibly nfsd3_proc_create */\n\t\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\t\tdchild = lookup_one_len(fname, dentry, flen);\n\t\thost_err = PTR_ERR(dchild);\n\t\tif (IS_ERR(dchild))\n\t\t\tgoto out_nfserr;\n\t\terr = fh_compose(resfhp, fhp->fh_export, dchild, fhp);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\t/* called from nfsd_proc_create */\n\t\tdchild = dget(resfhp->fh_dentry);\n\t\tif (!fhp->fh_locked) {\n\t\t\t/* not actually possible */\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"nfsd_create: parent %pd2 not locked!\\n\",\n\t\t\t\tdentry);\n\t\t\terr = nfserr_io;\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/*\n\t * Make sure the child dentry is still negative ...\n\t */\n\terr = nfserr_exist;\n\tif (dchild->d_inode) {\n\t\tdprintk(\"nfsd_create: dentry %pd/%pd not negative!\\n\",\n\t\t\tdentry, dchild);\n\t\tgoto out; \n\t}\n\n\tif (!(iap->ia_valid & ATTR_MODE))\n\t\tiap->ia_mode = 0;\n\tiap->ia_mode = (iap->ia_mode & S_IALLUGO) | type;\n\n\terr = nfserr_inval;\n\tif (!S_ISREG(type) && !S_ISDIR(type) && !special_file(type)) {\n\t\tprintk(KERN_WARNING \"nfsd: bad file type %o in nfsd_create\\n\",\n\t\t       type);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Get the dir op function pointer.\n\t */\n\terr = 0;\n\thost_err = 0;\n\tswitch (type) {\n\tcase S_IFREG:\n\t\thost_err = vfs_create(dirp, dchild, iap->ia_mode, true);\n\t\tif (!host_err)\n\t\t\tnfsd_check_ignore_resizing(iap);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\thost_err = vfs_mkdir(dirp, dchild, iap->ia_mode);\n\t\tbreak;\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\thost_err = vfs_mknod(dirp, dchild, iap->ia_mode, rdev);\n\t\tbreak;\n\t}\n\tif (host_err < 0)\n\t\tgoto out_nfserr;\n\n\terr = nfsd_create_setattr(rqstp, resfhp, iap);\n\n\t/*\n\t * nfsd_create_setattr already committed the child.  Transactional\n\t * filesystems had a chance to commit changes for both parent and\n\t * child * simultaneously making the following commit_metadata a\n\t * noop.\n\t */\n\terr2 = nfserrno(commit_metadata(fhp));\n\tif (err2)\n\t\terr = err2;\n\t/*\n\t * Update the file handle to get the new inode info.\n\t */\n\tif (!err)\n\t\terr = fh_update(resfhp);\nout:\n\tif (dchild && !IS_ERR(dchild))\n\t\tdput(dchild);\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "rdev"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "rdev"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "create->cr_specdata1",
            "create->cr_specdata2"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "rdev"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "rdev"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "create->cr_specdata1",
            "create->cr_specdata2"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_symlink",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "create->cr_name",
            "create->cr_namelen",
            "create->cr_data",
            "&resfh"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "1547-1596",
          "snippet": "__be32\nnfsd_symlink(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t\t\tchar *fname, int flen,\n\t\t\t\tchar *path,\n\t\t\t\tstruct svc_fh *resfhp)\n{\n\tstruct dentry\t*dentry, *dnew;\n\t__be32\t\terr, cerr;\n\tint\t\thost_err;\n\n\terr = nfserr_noent;\n\tif (!flen || path[0] == '\\0')\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(fname, flen))\n\t\tgoto out;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\tgoto out_nfserr;\n\n\tfh_lock(fhp);\n\tdentry = fhp->fh_dentry;\n\tdnew = lookup_one_len(fname, dentry, flen);\n\thost_err = PTR_ERR(dnew);\n\tif (IS_ERR(dnew))\n\t\tgoto out_nfserr;\n\n\thost_err = vfs_symlink(dentry->d_inode, dnew, path);\n\terr = nfserrno(host_err);\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\n\tfh_unlock(fhp);\n\n\tfh_drop_write(fhp);\n\n\tcerr = fh_compose(resfhp, fhp->fh_export, dnew, fhp);\n\tdput(dnew);\n\tif (err==0) err = cerr;\nout:\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_symlink(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t\t\tchar *fname, int flen,\n\t\t\t\tchar *path,\n\t\t\t\tstruct svc_fh *resfhp)\n{\n\tstruct dentry\t*dentry, *dnew;\n\t__be32\t\terr, cerr;\n\tint\t\thost_err;\n\n\terr = nfserr_noent;\n\tif (!flen || path[0] == '\\0')\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(fname, flen))\n\t\tgoto out;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\tgoto out_nfserr;\n\n\tfh_lock(fhp);\n\tdentry = fhp->fh_dentry;\n\tdnew = lookup_one_len(fname, dentry, flen);\n\thost_err = PTR_ERR(dnew);\n\tif (IS_ERR(dnew))\n\t\tgoto out_nfserr;\n\n\thost_err = vfs_symlink(dentry->d_inode, dnew, path);\n\terr = nfserrno(host_err);\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\n\tfh_unlock(fhp);\n\n\tfh_drop_write(fhp);\n\n\tcerr = fh_compose(resfhp, fhp->fh_export, dnew, fhp);\n\tdput(dnew);\n\tif (err==0) err = cerr;\nout:\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_attr_support",
          "args": [
            "rqstp",
            "cstate",
            "create->cr_bmval",
            "nfsd_attrmask"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "check_attr_support",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "93-127",
          "snippet": "static __be32\ncheck_attr_support(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   u32 *bmval, u32 *writable)\n{\n\tstruct dentry *dentry = cstate->current_fh.fh_dentry;\n\n\t/*\n\t * Check about attributes are supported by the NFSv4 server or not.\n\t * According to spec, unsupported attributes return ERR_ATTRNOTSUPP.\n\t */\n\tif ((bmval[0] & ~nfsd_suppattrs0(cstate->minorversion)) ||\n\t    (bmval[1] & ~nfsd_suppattrs1(cstate->minorversion)) ||\n\t    (bmval[2] & ~nfsd_suppattrs2(cstate->minorversion)))\n\t\treturn nfserr_attrnotsupp;\n\n\t/*\n\t * Check FATTR4_WORD0_ACL can be supported\n\t * in current environment or not.\n\t */\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tif (!IS_POSIXACL(dentry->d_inode))\n\t\t\treturn nfserr_attrnotsupp;\n\t}\n\n\t/*\n\t * According to spec, read-only attributes return ERR_INVAL.\n\t */\n\tif (writable) {\n\t\tif ((bmval[0] & ~writable[0]) || (bmval[1] & ~writable[1]) ||\n\t\t    (bmval[2] & ~writable[2]))\n\t\t\treturn nfserr_inval;\n\t}\n\n\treturn nfs_ok;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\ncheck_attr_support(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   u32 *bmval, u32 *writable)\n{\n\tstruct dentry *dentry = cstate->current_fh.fh_dentry;\n\n\t/*\n\t * Check about attributes are supported by the NFSv4 server or not.\n\t * According to spec, unsupported attributes return ERR_ATTRNOTSUPP.\n\t */\n\tif ((bmval[0] & ~nfsd_suppattrs0(cstate->minorversion)) ||\n\t    (bmval[1] & ~nfsd_suppattrs1(cstate->minorversion)) ||\n\t    (bmval[2] & ~nfsd_suppattrs2(cstate->minorversion)))\n\t\treturn nfserr_attrnotsupp;\n\n\t/*\n\t * Check FATTR4_WORD0_ACL can be supported\n\t * in current environment or not.\n\t */\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tif (!IS_POSIXACL(dentry->d_inode))\n\t\t\treturn nfserr_attrnotsupp;\n\t}\n\n\t/*\n\t * According to spec, read-only attributes return ERR_INVAL.\n\t */\n\tif (writable) {\n\t\tif ((bmval[0] & ~writable[0]) || (bmval[1] & ~writable[1]) ||\n\t\t    (bmval[2] & ~writable[2]))\n\t\t\treturn nfserr_inval;\n\t}\n\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "S_IFDIR",
            "NFSD_MAY_CREATE"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_init",
          "args": [
            "&resfh",
            "NFS4_FHSIZE"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "fh_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "182-188",
          "snippet": "static __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic u32 nfsd_attrmask[] = {\n\tNFSD_WRITEABLE_ATTRS_WORD0,\n\tNFSD_WRITEABLE_ATTRS_WORD1,\n\tNFSD_WRITEABLE_ATTRS_WORD2\n};\n\nstatic __be32\nnfsd4_create(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_create *create)\n{\n\tstruct svc_fh resfh;\n\t__be32 status;\n\tdev_t rdev;\n\n\tfh_init(&resfh, NFS4_FHSIZE);\n\n\tstatus = fh_verify(rqstp, &cstate->current_fh, S_IFDIR,\n\t\t\t   NFSD_MAY_CREATE);\n\tif (status)\n\t\treturn status;\n\n\tstatus = check_attr_support(rqstp, cstate, create->cr_bmval,\n\t\t\t\t    nfsd_attrmask);\n\tif (status)\n\t\treturn status;\n\n\tswitch (create->cr_type) {\n\tcase NF4LNK:\n\t\tstatus = nfsd_symlink(rqstp, &cstate->current_fh,\n\t\t\t\t      create->cr_name, create->cr_namelen,\n\t\t\t\t      create->cr_data, &resfh);\n\t\tbreak;\n\n\tcase NF4BLK:\n\t\trdev = MKDEV(create->cr_specdata1, create->cr_specdata2);\n\t\tif (MAJOR(rdev) != create->cr_specdata1 ||\n\t\t    MINOR(rdev) != create->cr_specdata2)\n\t\t\treturn nfserr_inval;\n\t\tstatus = nfsd_create(rqstp, &cstate->current_fh,\n\t\t\t\t     create->cr_name, create->cr_namelen,\n\t\t\t\t     &create->cr_iattr, S_IFBLK, rdev, &resfh);\n\t\tbreak;\n\n\tcase NF4CHR:\n\t\trdev = MKDEV(create->cr_specdata1, create->cr_specdata2);\n\t\tif (MAJOR(rdev) != create->cr_specdata1 ||\n\t\t    MINOR(rdev) != create->cr_specdata2)\n\t\t\treturn nfserr_inval;\n\t\tstatus = nfsd_create(rqstp, &cstate->current_fh,\n\t\t\t\t     create->cr_name, create->cr_namelen,\n\t\t\t\t     &create->cr_iattr,S_IFCHR, rdev, &resfh);\n\t\tbreak;\n\n\tcase NF4SOCK:\n\t\tstatus = nfsd_create(rqstp, &cstate->current_fh,\n\t\t\t\t     create->cr_name, create->cr_namelen,\n\t\t\t\t     &create->cr_iattr, S_IFSOCK, 0, &resfh);\n\t\tbreak;\n\n\tcase NF4FIFO:\n\t\tstatus = nfsd_create(rqstp, &cstate->current_fh,\n\t\t\t\t     create->cr_name, create->cr_namelen,\n\t\t\t\t     &create->cr_iattr, S_IFIFO, 0, &resfh);\n\t\tbreak;\n\n\tcase NF4DIR:\n\t\tcreate->cr_iattr.ia_valid &= ~ATTR_SIZE;\n\t\tstatus = nfsd_create(rqstp, &cstate->current_fh,\n\t\t\t\t     create->cr_name, create->cr_namelen,\n\t\t\t\t     &create->cr_iattr, S_IFDIR, 0, &resfh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = nfserr_badtype;\n\t}\n\n\tif (status)\n\t\tgoto out;\n\n\tif (create->cr_label.len)\n\t\tnfsd4_security_inode_setsecctx(&resfh, &create->cr_label, create->cr_bmval);\n\n\tif (create->cr_acl != NULL)\n\t\tdo_set_nfs4_acl(rqstp, &resfh, create->cr_acl,\n\t\t\t\tcreate->cr_bmval);\n\n\tfh_unlock(&cstate->current_fh);\n\tset_change_info(&create->cr_cinfo, &cstate->current_fh);\n\tfh_dup2(&cstate->current_fh, &resfh);\nout:\n\tfh_put(&resfh);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "591-598",
    "snippet": "static __be32\nnfsd4_commit(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_commit *commit)\n{\n\tgen_boot_verifier(&commit->co_verf, SVC_NET(rqstp));\n\treturn nfsd_commit(rqstp, &cstate->current_fh, commit->co_offset,\n\t\t\t     commit->co_count);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_commit",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "commit->co_offset",
            "commit->co_count"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "1112-1144",
          "snippet": "__be32\nnfsd_commit(struct svc_rqst *rqstp, struct svc_fh *fhp,\n               loff_t offset, unsigned long count)\n{\n\tstruct file\t*file;\n\tloff_t\t\tend = LLONG_MAX;\n\t__be32\t\terr = nfserr_inval;\n\n\tif (offset < 0)\n\t\tgoto out;\n\tif (count != 0) {\n\t\tend = offset + (loff_t)count - 1;\n\t\tif (end < offset)\n\t\t\tgoto out;\n\t}\n\n\terr = nfsd_open(rqstp, fhp, S_IFREG,\n\t\t\tNFSD_MAY_WRITE|NFSD_MAY_NOT_BREAK_LEASE, &file);\n\tif (err)\n\t\tgoto out;\n\tif (EX_ISSYNC(fhp->fh_export)) {\n\t\tint err2 = vfs_fsync_range(file, offset, end, 0);\n\n\t\tif (err2 != -EINVAL)\n\t\t\terr = nfserrno(err2);\n\t\telse\n\t\t\terr = nfserr_notsupp;\n\t}\n\n\tnfsd_close(file);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_commit(struct svc_rqst *rqstp, struct svc_fh *fhp,\n               loff_t offset, unsigned long count)\n{\n\tstruct file\t*file;\n\tloff_t\t\tend = LLONG_MAX;\n\t__be32\t\terr = nfserr_inval;\n\n\tif (offset < 0)\n\t\tgoto out;\n\tif (count != 0) {\n\t\tend = offset + (loff_t)count - 1;\n\t\tif (end < offset)\n\t\t\tgoto out;\n\t}\n\n\terr = nfsd_open(rqstp, fhp, S_IFREG,\n\t\t\tNFSD_MAY_WRITE|NFSD_MAY_NOT_BREAK_LEASE, &file);\n\tif (err)\n\t\tgoto out;\n\tif (EX_ISSYNC(fhp->fh_export)) {\n\t\tint err2 = vfs_fsync_range(file, offset, end, 0);\n\n\t\tif (err2 != -EINVAL)\n\t\t\terr = nfserrno(err2);\n\t\telse\n\t\t\terr = nfserr_notsupp;\n\t}\n\n\tnfsd_close(file);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen_boot_verifier",
          "args": [
            "&commit->co_verf",
            "SVC_NET(rqstp)"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "gen_boot_verifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "577-589",
          "snippet": "static void gen_boot_verifier(nfs4_verifier *verifier, struct net *net)\n{\n\t__be32 verf[2];\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\t/*\n\t * This is opaque to client, so no need to byte-swap. Use\n\t * __force to keep sparse happy\n\t */\n\tverf[0] = (__force __be32)nn->nfssvc_boot.tv_sec;\n\tverf[1] = (__force __be32)nn->nfssvc_boot.tv_usec;\n\tmemcpy(verifier->data, verf, sizeof(verifier->data));\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic void gen_boot_verifier(nfs4_verifier *verifier, struct net *net)\n{\n\t__be32 verf[2];\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\t/*\n\t * This is opaque to client, so no need to byte-swap. Use\n\t * __force to keep sparse happy\n\t */\n\tverf[0] = (__force __be32)nn->nfssvc_boot.tv_sec;\n\tverf[1] = (__force __be32)nn->nfssvc_boot.tv_usec;\n\tmemcpy(verifier->data, verf, sizeof(verifier->data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_commit(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_commit *commit)\n{\n\tgen_boot_verifier(&commit->co_verf, SVC_NET(rqstp));\n\treturn nfsd_commit(rqstp, &cstate->current_fh, commit->co_offset,\n\t\t\t     commit->co_count);\n}"
  },
  {
    "function_name": "gen_boot_verifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "577-589",
    "snippet": "static void gen_boot_verifier(nfs4_verifier *verifier, struct net *net)\n{\n\t__be32 verf[2];\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\t/*\n\t * This is opaque to client, so no need to byte-swap. Use\n\t * __force to keep sparse happy\n\t */\n\tverf[0] = (__force __be32)nn->nfssvc_boot.tv_sec;\n\tverf[1] = (__force __be32)nn->nfssvc_boot.tv_usec;\n\tmemcpy(verifier->data, verf, sizeof(verifier->data));\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "verifier->data",
            "verf",
            "sizeof(verifier->data)"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic void gen_boot_verifier(nfs4_verifier *verifier, struct net *net)\n{\n\t__be32 verf[2];\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\t/*\n\t * This is opaque to client, so no need to byte-swap. Use\n\t * __force to keep sparse happy\n\t */\n\tverf[0] = (__force __be32)nn->nfssvc_boot.tv_sec;\n\tverf[1] = (__force __be32)nn->nfssvc_boot.tv_usec;\n\tmemcpy(verifier->data, verf, sizeof(verifier->data));\n}"
  },
  {
    "function_name": "nfsd4_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "565-575",
    "snippet": "static __be32\nnfsd4_access(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_access *access)\n{\n\tif (access->ac_req_access & ~NFS3_ACCESS_FULL)\n\t\treturn nfserr_inval;\n\n\taccess->ac_resp_access = access->ac_req_access;\n\treturn nfsd_access(rqstp, &cstate->current_fh, &access->ac_resp_access,\n\t\t\t   &access->ac_supported);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_access",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "&access->ac_resp_access",
            "&access->ac_supported"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "602-658",
          "snippet": "__be32\nnfsd_access(struct svc_rqst *rqstp, struct svc_fh *fhp, u32 *access, u32 *supported)\n{\n\tstruct accessmap\t*map;\n\tstruct svc_export\t*export;\n\tstruct dentry\t\t*dentry;\n\tu32\t\t\tquery, result = 0, sresult = 0;\n\t__be32\t\t\terror;\n\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_NOP);\n\tif (error)\n\t\tgoto out;\n\n\texport = fhp->fh_export;\n\tdentry = fhp->fh_dentry;\n\n\tif (d_is_reg(dentry))\n\t\tmap = nfs3_regaccess;\n\telse if (d_is_dir(dentry))\n\t\tmap = nfs3_diraccess;\n\telse\n\t\tmap = nfs3_anyaccess;\n\n\n\tquery = *access;\n\tfor  (; map->access; map++) {\n\t\tif (map->access & query) {\n\t\t\t__be32 err2;\n\n\t\t\tsresult |= map->access;\n\n\t\t\terr2 = nfsd_permission(rqstp, export, dentry, map->how);\n\t\t\tswitch (err2) {\n\t\t\tcase nfs_ok:\n\t\t\t\tresult |= map->access;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t/* the following error codes just mean the access was not allowed,\n\t\t\t * rather than an error occurred */\n\t\t\tcase nfserr_rofs:\n\t\t\tcase nfserr_acces:\n\t\t\tcase nfserr_perm:\n\t\t\t\t/* simply don't \"or\" in the access bit. */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = err2;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\t*access = result;\n\tif (supported)\n\t\t*supported = sresult;\n\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_access(struct svc_rqst *rqstp, struct svc_fh *fhp, u32 *access, u32 *supported)\n{\n\tstruct accessmap\t*map;\n\tstruct svc_export\t*export;\n\tstruct dentry\t\t*dentry;\n\tu32\t\t\tquery, result = 0, sresult = 0;\n\t__be32\t\t\terror;\n\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_NOP);\n\tif (error)\n\t\tgoto out;\n\n\texport = fhp->fh_export;\n\tdentry = fhp->fh_dentry;\n\n\tif (d_is_reg(dentry))\n\t\tmap = nfs3_regaccess;\n\telse if (d_is_dir(dentry))\n\t\tmap = nfs3_diraccess;\n\telse\n\t\tmap = nfs3_anyaccess;\n\n\n\tquery = *access;\n\tfor  (; map->access; map++) {\n\t\tif (map->access & query) {\n\t\t\t__be32 err2;\n\n\t\t\tsresult |= map->access;\n\n\t\t\terr2 = nfsd_permission(rqstp, export, dentry, map->how);\n\t\t\tswitch (err2) {\n\t\t\tcase nfs_ok:\n\t\t\t\tresult |= map->access;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t/* the following error codes just mean the access was not allowed,\n\t\t\t * rather than an error occurred */\n\t\t\tcase nfserr_rofs:\n\t\t\tcase nfserr_acces:\n\t\t\tcase nfserr_perm:\n\t\t\t\t/* simply don't \"or\" in the access bit. */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = err2;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\t*access = result;\n\tif (supported)\n\t\t*supported = sresult;\n\n out:\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_access(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_access *access)\n{\n\tif (access->ac_req_access & ~NFS3_ACCESS_FULL)\n\t\treturn nfserr_inval;\n\n\taccess->ac_resp_access = access->ac_req_access;\n\treturn nfsd_access(rqstp, &cstate->current_fh, &access->ac_resp_access,\n\t\t\t   &access->ac_supported);\n}"
  },
  {
    "function_name": "nfsd4_savefh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "547-560",
    "snippet": "static __be32\nnfsd4_savefh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     void *arg)\n{\n\tif (!cstate->current_fh.fh_dentry)\n\t\treturn nfserr_nofilehandle;\n\n\tfh_dup2(&cstate->save_fh, &cstate->current_fh);\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG)) {\n\t\tmemcpy(&cstate->save_stateid, &cstate->current_stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, SAVED_STATE_ID_FLAG);\n\t}\n\treturn nfs_ok;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SET_STATE_ID",
          "args": [
            "cstate",
            "SAVED_STATE_ID_FLAG"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&cstate->save_stateid",
            "&cstate->current_stateid",
            "sizeof(stateid_t)"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_STATE_ID",
          "args": [
            "cstate",
            "CURRENT_STATE_ID_FLAG"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_dup2",
          "args": [
            "&cstate->save_fh",
            "&cstate->current_fh"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "fh_dup2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "177-185",
          "snippet": "static inline void\nfh_dup2(struct svc_fh *dst, struct svc_fh *src)\n{\n\tfh_put(dst);\n\tdget(src->fh_dentry);\n\tif (src->fh_export)\n\t\texp_get(src->fh_export);\n\t*dst = *src;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic inline void\nfh_dup2(struct svc_fh *dst, struct svc_fh *src)\n{\n\tfh_put(dst);\n\tdget(src->fh_dentry);\n\tif (src->fh_export)\n\t\texp_get(src->fh_export);\n\t*dst = *src;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_savefh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     void *arg)\n{\n\tif (!cstate->current_fh.fh_dentry)\n\t\treturn nfserr_nofilehandle;\n\n\tfh_dup2(&cstate->save_fh, &cstate->current_fh);\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG)) {\n\t\tmemcpy(&cstate->save_stateid, &cstate->current_stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, SAVED_STATE_ID_FLAG);\n\t}\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_restorefh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "532-545",
    "snippet": "static __be32\nnfsd4_restorefh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tvoid *arg)\n{\n\tif (!cstate->save_fh.fh_dentry)\n\t\treturn nfserr_restorefh;\n\n\tfh_dup2(&cstate->current_fh, &cstate->save_fh);\n\tif (HAS_STATE_ID(cstate, SAVED_STATE_ID_FLAG)) {\n\t\tmemcpy(&cstate->current_stateid, &cstate->save_stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n\treturn nfs_ok;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SET_STATE_ID",
          "args": [
            "cstate",
            "CURRENT_STATE_ID_FLAG"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&cstate->current_stateid",
            "&cstate->save_stateid",
            "sizeof(stateid_t)"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_STATE_ID",
          "args": [
            "cstate",
            "SAVED_STATE_ID_FLAG"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_dup2",
          "args": [
            "&cstate->current_fh",
            "&cstate->save_fh"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "fh_dup2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "177-185",
          "snippet": "static inline void\nfh_dup2(struct svc_fh *dst, struct svc_fh *src)\n{\n\tfh_put(dst);\n\tdget(src->fh_dentry);\n\tif (src->fh_export)\n\t\texp_get(src->fh_export);\n\t*dst = *src;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic inline void\nfh_dup2(struct svc_fh *dst, struct svc_fh *src)\n{\n\tfh_put(dst);\n\tdget(src->fh_dentry);\n\tif (src->fh_export)\n\t\texp_get(src->fh_export);\n\t*dst = *src;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_restorefh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tvoid *arg)\n{\n\tif (!cstate->save_fh.fh_dentry)\n\t\treturn nfserr_restorefh;\n\n\tfh_dup2(&cstate->current_fh, &cstate->save_fh);\n\tif (HAS_STATE_ID(cstate, SAVED_STATE_ID_FLAG)) {\n\t\tmemcpy(&cstate->current_stateid, &cstate->save_stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_putrootfh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "521-530",
    "snippet": "static __be32\nnfsd4_putrootfh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tvoid *arg)\n{\n\t__be32 status;\n\n\tfh_put(&cstate->current_fh);\n\tstatus = exp_pseudoroot(rqstp, &cstate->current_fh);\n\treturn status;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp_pseudoroot",
          "args": [
            "rqstp",
            "&cstate->current_fh"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "exp_pseudoroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "1065-1077",
          "snippet": "__be32\nexp_pseudoroot(struct svc_rqst *rqstp, struct svc_fh *fhp)\n{\n\tstruct svc_export *exp;\n\t__be32 rv;\n\n\texp = rqst_find_fsidzero_export(rqstp);\n\tif (IS_ERR(exp))\n\t\treturn nfserrno(PTR_ERR(exp));\n\trv = fh_compose(fhp, exp, exp->ex_path.dentry, NULL);\n\texp_put(exp);\n\treturn rv;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\n__be32\nexp_pseudoroot(struct svc_rqst *rqstp, struct svc_fh *fhp)\n{\n\tstruct svc_export *exp;\n\t__be32 rv;\n\n\texp = rqst_find_fsidzero_export(rqstp);\n\tif (IS_ERR(exp))\n\t\treturn nfserrno(PTR_ERR(exp));\n\trv = fh_compose(fhp, exp, exp->ex_path.dentry, NULL);\n\texp_put(exp);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&cstate->current_fh"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "625-645",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_putrootfh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tvoid *arg)\n{\n\t__be32 status;\n\n\tfh_put(&cstate->current_fh);\n\tstatus = exp_pseudoroot(rqstp, &cstate->current_fh);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_putfh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "510-519",
    "snippet": "static __be32\nnfsd4_putfh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct nfsd4_putfh *putfh)\n{\n\tfh_put(&cstate->current_fh);\n\tcstate->current_fh.fh_handle.fh_size = putfh->pf_fhlen;\n\tmemcpy(&cstate->current_fh.fh_handle.fh_base, putfh->pf_fhval,\n\t       putfh->pf_fhlen);\n\treturn fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_BYPASS_GSS);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "0",
            "NFSD_MAY_BYPASS_GSS"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&cstate->current_fh.fh_handle.fh_base",
            "putfh->pf_fhval",
            "putfh->pf_fhlen"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&cstate->current_fh"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "625-645",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_putfh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct nfsd4_putfh *putfh)\n{\n\tfh_put(&cstate->current_fh);\n\tcstate->current_fh.fh_handle.fh_size = putfh->pf_fhlen;\n\tmemcpy(&cstate->current_fh.fh_handle.fh_base, putfh->pf_fhval,\n\t       putfh->pf_fhlen);\n\treturn fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_BYPASS_GSS);\n}"
  },
  {
    "function_name": "nfsd4_getfh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "499-508",
    "snippet": "static __be32\nnfsd4_getfh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct svc_fh **getfh)\n{\n\tif (!cstate->current_fh.fh_dentry)\n\t\treturn nfserr_nofilehandle;\n\n\t*getfh = &cstate->current_fh;\n\treturn nfs_ok;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_getfh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct svc_fh **getfh)\n{\n\tif (!cstate->current_fh.fh_dentry)\n\t\treturn nfserr_nofilehandle;\n\n\t*getfh = &cstate->current_fh;\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_open_omfg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "484-494",
    "snippet": "static __be32 nfsd4_open_omfg(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_op *op)\n{\n\tstruct nfsd4_open *open = (struct nfsd4_open *)&op->u;\n\n\tif (!seqid_mutating_err(ntohl(op->status)))\n\t\treturn op->status;\n\tif (nfsd4_has_session(cstate))\n\t\treturn op->status;\n\topen->op_xdr_error = op->status;\n\treturn nfsd4_open(rqstp, cstate, open);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_open",
          "args": [
            "rqstp",
            "cstate",
            "open"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_open_omfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "484-494",
          "snippet": "static __be32 nfsd4_open_omfg(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_op *op)\n{\n\tstruct nfsd4_open *open = (struct nfsd4_open *)&op->u;\n\n\tif (!seqid_mutating_err(ntohl(op->status)))\n\t\treturn op->status;\n\tif (nfsd4_has_session(cstate))\n\t\treturn op->status;\n\topen->op_xdr_error = op->status;\n\treturn nfsd4_open(rqstp, cstate, open);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "cstate"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/xdr4.h",
          "lines": "72-75",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seqid_mutating_err",
          "args": [
            "ntohl(op->status)"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "op->status"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_open_omfg(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_op *op)\n{\n\tstruct nfsd4_open *open = (struct nfsd4_open *)&op->u;\n\n\tif (!seqid_mutating_err(ntohl(op->status)))\n\t\treturn op->status;\n\tif (nfsd4_has_session(cstate))\n\t\treturn op->status;\n\topen->op_xdr_error = op->status;\n\treturn nfsd4_open(rqstp, cstate, open);\n}"
  },
  {
    "function_name": "nfsd4_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "359-476",
    "snippet": "static __be32\nnfsd4_open(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t   struct nfsd4_open *open)\n{\n\t__be32 status;\n\tstruct svc_fh *resfh = NULL;\n\tstruct nfsd4_compoundres *resp;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_open filename %.*s op_openowner %p\\n\",\n\t\t(int)open->op_fname.len, open->op_fname.data,\n\t\topen->op_openowner);\n\n\t/* This check required by spec. */\n\tif (open->op_create && open->op_claim_type != NFS4_OPEN_CLAIM_NULL)\n\t\treturn nfserr_inval;\n\n\topen->op_created = 0;\n\t/*\n\t * RFC5661 18.51.3\n\t * Before RECLAIM_COMPLETE done, server should deny new lock\n\t */\n\tif (nfsd4_has_session(cstate) &&\n\t    !test_bit(NFSD4_CLIENT_RECLAIM_COMPLETE,\n\t\t      &cstate->session->se_client->cl_flags) &&\n\t    open->op_claim_type != NFS4_OPEN_CLAIM_PREVIOUS)\n\t\treturn nfserr_grace;\n\n\tif (nfsd4_has_session(cstate))\n\t\tcopy_clientid(&open->op_clientid, cstate->session);\n\n\t/* check seqid for replay. set nfs4_owner */\n\tresp = rqstp->rq_resp;\n\tstatus = nfsd4_process_open1(&resp->cstate, open, nn);\n\tif (status == nfserr_replay_me) {\n\t\tstruct nfs4_replay *rp = &open->op_openowner->oo_owner.so_replay;\n\t\tfh_put(&cstate->current_fh);\n\t\tfh_copy_shallow(&cstate->current_fh.fh_handle,\n\t\t\t\t&rp->rp_openfh);\n\t\tstatus = fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_NOP);\n\t\tif (status)\n\t\t\tdprintk(\"nfsd4_open: replay failed\"\n\t\t\t\t\" restoring previous filehandle\\n\");\n\t\telse\n\t\t\tstatus = nfserr_replay_me;\n\t}\n\tif (status)\n\t\tgoto out;\n\tif (open->op_xdr_error) {\n\t\tstatus = open->op_xdr_error;\n\t\tgoto out;\n\t}\n\n\tstatus = nfsd4_check_open_attributes(rqstp, cstate, open);\n\tif (status)\n\t\tgoto out;\n\n\t/* Openowner is now set, so sequence id will get bumped.  Now we need\n\t * these checks before we do any creates: */\n\tstatus = nfserr_grace;\n\tif (locks_in_grace(net) && open->op_claim_type != NFS4_OPEN_CLAIM_PREVIOUS)\n\t\tgoto out;\n\tstatus = nfserr_no_grace;\n\tif (!locks_in_grace(net) && open->op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS)\n\t\tgoto out;\n\n\tswitch (open->op_claim_type) {\n\t\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\t\tcase NFS4_OPEN_CLAIM_NULL:\n\t\t\tstatus = do_open_lookup(rqstp, cstate, open, &resfh);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\t\tstatus = nfs4_check_open_reclaim(&open->op_clientid,\n\t\t\t\t\t\t\t cstate, nn);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t\topen->op_openowner->oo_flags |= NFS4_OO_CONFIRMED;\n\t\tcase NFS4_OPEN_CLAIM_FH:\n\t\tcase NFS4_OPEN_CLAIM_DELEG_CUR_FH:\n\t\t\tstatus = do_open_fhandle(rqstp, cstate, open);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t\tresfh = &cstate->current_fh;\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_CLAIM_DELEG_PREV_FH:\n             \tcase NFS4_OPEN_CLAIM_DELEGATE_PREV:\n\t\t\tdprintk(\"NFSD: unsupported OPEN claim type %d\\n\",\n\t\t\t\topen->op_claim_type);\n\t\t\tstatus = nfserr_notsupp;\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tdprintk(\"NFSD: Invalid OPEN claim type %d\\n\",\n\t\t\t\topen->op_claim_type);\n\t\t\tstatus = nfserr_inval;\n\t\t\tgoto out;\n\t}\n\t/*\n\t * nfsd4_process_open2() does the actual opening of the file.  If\n\t * successful, it (1) truncates the file if open->op_truncate was\n\t * set, (2) sets open->op_stateid, (3) sets open->op_delegation.\n\t */\n\tstatus = nfsd4_process_open2(rqstp, resfh, open);\n\tWARN(status && open->op_created,\n\t     \"nfsd4_process_open2 failed to open newly-created file! status=%u\\n\",\n\t     be32_to_cpu(status));\nout:\n\tif (resfh && resfh != &cstate->current_fh) {\n\t\tfh_dup2(&cstate->current_fh, resfh);\n\t\tfh_put(resfh);\n\t\tkfree(resfh);\n\t}\n\tnfsd4_cleanup_open_state(cstate, open, status);\n\tnfsd4_bump_seqid(cstate, status);\n\treturn status;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_bump_seqid",
          "args": [
            "cstate",
            "status"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_bump_seqid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "1160-1177",
          "snippet": "void nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cleanup_open_state",
          "args": [
            "cstate",
            "open",
            "status"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cleanup_open_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4120-4133",
          "snippet": "void nfsd4_cleanup_open_state(struct nfsd4_compound_state *cstate,\n\t\t\t      struct nfsd4_open *open, __be32 status)\n{\n\tif (open->op_openowner) {\n\t\tstruct nfs4_stateowner *so = &open->op_openowner->oo_owner;\n\n\t\tnfsd4_cstate_assign_replay(cstate, so);\n\t\tnfs4_put_stateowner(so);\n\t}\n\tif (open->op_file)\n\t\tkmem_cache_free(file_slab, open->op_file);\n\tif (open->op_stp)\n\t\tnfs4_put_stid(&open->op_stp->st_stid);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *file_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *file_slab;\n\nvoid nfsd4_cleanup_open_state(struct nfsd4_compound_state *cstate,\n\t\t\t      struct nfsd4_open *open, __be32 status)\n{\n\tif (open->op_openowner) {\n\t\tstruct nfs4_stateowner *so = &open->op_openowner->oo_owner;\n\n\t\tnfsd4_cstate_assign_replay(cstate, so);\n\t\tnfs4_put_stateowner(so);\n\t}\n\tif (open->op_file)\n\t\tkmem_cache_free(file_slab, open->op_file);\n\tif (open->op_stp)\n\t\tnfs4_put_stid(&open->op_stp->st_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "resfh"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "resfh"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "625-645",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_dup2",
          "args": [
            "&cstate->current_fh",
            "resfh"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "fh_dup2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "177-185",
          "snippet": "static inline void\nfh_dup2(struct svc_fh *dst, struct svc_fh *src)\n{\n\tfh_put(dst);\n\tdget(src->fh_dentry);\n\tif (src->fh_export)\n\t\texp_get(src->fh_export);\n\t*dst = *src;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic inline void\nfh_dup2(struct svc_fh *dst, struct svc_fh *src)\n{\n\tfh_put(dst);\n\tdget(src->fh_dentry);\n\tif (src->fh_export)\n\t\texp_get(src->fh_export);\n\t*dst = *src;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "status && open->op_created",
            "\"nfsd4_process_open2 failed to open newly-created file! status=%u\\n\"",
            "be32_to_cpu(status)"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "status"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_process_open2",
          "args": [
            "rqstp",
            "resfh",
            "open"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_process_open2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "4026-4118",
          "snippet": "__be32\nnfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_open *open)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfs4_client *cl = open->op_openowner->oo_owner.so_client;\n\tstruct nfs4_file *fp = NULL;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\tstruct nfs4_delegation *dp = NULL;\n\t__be32 status;\n\n\t/*\n\t * Lookup file; if found, lookup stateid and check open request,\n\t * and check for delegations in the process of being recalled.\n\t * If not found, create the nfs4_file struct\n\t */\n\tfp = find_or_add_file(open->op_file, &current_fh->fh_handle);\n\tif (fp != open->op_file) {\n\t\tstatus = nfs4_check_deleg(cl, open, &dp);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tstp = nfsd4_find_existing_open(fp, open);\n\t} else {\n\t\topen->op_file = NULL;\n\t\tstatus = nfserr_bad_stateid;\n\t\tif (nfsd4_is_deleg_cur(open))\n\t\t\tgoto out;\n\t\tstatus = nfserr_jukebox;\n\t}\n\n\t/*\n\t * OPEN the file, or upgrade an existing OPEN.\n\t * If truncate fails, the OPEN fails.\n\t */\n\tif (stp) {\n\t\t/* Stateid was found, this is an OPEN upgrade */\n\t\tstatus = nfs4_upgrade_open(rqstp, fp, current_fh, stp, open);\n\t\tif (status)\n\t\t\tgoto out;\n\t} else {\n\t\tstp = open->op_stp;\n\t\topen->op_stp = NULL;\n\t\tinit_open_stateid(stp, fp, open);\n\t\tstatus = nfs4_get_vfs_file(rqstp, fp, current_fh, stp, open);\n\t\tif (status) {\n\t\t\trelease_open_stateid(stp);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tupdate_stateid(&stp->st_stid.sc_stateid);\n\tmemcpy(&open->op_stateid, &stp->st_stid.sc_stateid, sizeof(stateid_t));\n\n\tif (nfsd4_has_session(&resp->cstate)) {\n\t\tif (open->op_deleg_want & NFS4_SHARE_WANT_NO_DELEG) {\n\t\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\t\topen->op_why_no_deleg = WND4_NOT_WANTED;\n\t\t\tgoto nodeleg;\n\t\t}\n\t}\n\n\t/*\n\t* Attempt to hand out a delegation. No error return, because the\n\t* OPEN succeeds even if we fail.\n\t*/\n\tnfs4_open_delegation(current_fh, open, stp);\nnodeleg:\n\tstatus = nfs_ok;\n\n\tdprintk(\"%s: stateid=\" STATEID_FMT \"\\n\", __func__,\n\t\tSTATEID_VAL(&stp->st_stid.sc_stateid));\nout:\n\t/* 4.1 client trying to upgrade/downgrade delegation? */\n\tif (open->op_delegate_type == NFS4_OPEN_DELEGATE_NONE && dp &&\n\t    open->op_deleg_want)\n\t\tnfsd4_deleg_xgrade_none_ext(open, dp);\n\n\tif (fp)\n\t\tput_nfs4_file(fp);\n\tif (status == 0 && open->op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS)\n\t\tnfs4_set_claim_prev(open, nfsd4_has_session(&resp->cstate));\n\t/*\n\t* To finish the open response, we just need to set the rflags.\n\t*/\n\topen->op_rflags = NFS4_OPEN_RESULT_LOCKTYPE_POSIX;\n\tif (!(open->op_openowner->oo_flags & NFS4_OO_CONFIRMED) &&\n\t    !nfsd4_has_session(&resp->cstate))\n\t\topen->op_rflags |= NFS4_OPEN_RESULT_CONFIRM;\n\tif (dp)\n\t\tnfs4_put_stid(&dp->dl_stid);\n\tif (stp)\n\t\tnfs4_put_stid(&stp->st_stid);\n\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\n__be32\nnfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_open *open)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfs4_client *cl = open->op_openowner->oo_owner.so_client;\n\tstruct nfs4_file *fp = NULL;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\tstruct nfs4_delegation *dp = NULL;\n\t__be32 status;\n\n\t/*\n\t * Lookup file; if found, lookup stateid and check open request,\n\t * and check for delegations in the process of being recalled.\n\t * If not found, create the nfs4_file struct\n\t */\n\tfp = find_or_add_file(open->op_file, &current_fh->fh_handle);\n\tif (fp != open->op_file) {\n\t\tstatus = nfs4_check_deleg(cl, open, &dp);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tstp = nfsd4_find_existing_open(fp, open);\n\t} else {\n\t\topen->op_file = NULL;\n\t\tstatus = nfserr_bad_stateid;\n\t\tif (nfsd4_is_deleg_cur(open))\n\t\t\tgoto out;\n\t\tstatus = nfserr_jukebox;\n\t}\n\n\t/*\n\t * OPEN the file, or upgrade an existing OPEN.\n\t * If truncate fails, the OPEN fails.\n\t */\n\tif (stp) {\n\t\t/* Stateid was found, this is an OPEN upgrade */\n\t\tstatus = nfs4_upgrade_open(rqstp, fp, current_fh, stp, open);\n\t\tif (status)\n\t\t\tgoto out;\n\t} else {\n\t\tstp = open->op_stp;\n\t\topen->op_stp = NULL;\n\t\tinit_open_stateid(stp, fp, open);\n\t\tstatus = nfs4_get_vfs_file(rqstp, fp, current_fh, stp, open);\n\t\tif (status) {\n\t\t\trelease_open_stateid(stp);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tupdate_stateid(&stp->st_stid.sc_stateid);\n\tmemcpy(&open->op_stateid, &stp->st_stid.sc_stateid, sizeof(stateid_t));\n\n\tif (nfsd4_has_session(&resp->cstate)) {\n\t\tif (open->op_deleg_want & NFS4_SHARE_WANT_NO_DELEG) {\n\t\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\t\topen->op_why_no_deleg = WND4_NOT_WANTED;\n\t\t\tgoto nodeleg;\n\t\t}\n\t}\n\n\t/*\n\t* Attempt to hand out a delegation. No error return, because the\n\t* OPEN succeeds even if we fail.\n\t*/\n\tnfs4_open_delegation(current_fh, open, stp);\nnodeleg:\n\tstatus = nfs_ok;\n\n\tdprintk(\"%s: stateid=\" STATEID_FMT \"\\n\", __func__,\n\t\tSTATEID_VAL(&stp->st_stid.sc_stateid));\nout:\n\t/* 4.1 client trying to upgrade/downgrade delegation? */\n\tif (open->op_delegate_type == NFS4_OPEN_DELEGATE_NONE && dp &&\n\t    open->op_deleg_want)\n\t\tnfsd4_deleg_xgrade_none_ext(open, dp);\n\n\tif (fp)\n\t\tput_nfs4_file(fp);\n\tif (status == 0 && open->op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS)\n\t\tnfs4_set_claim_prev(open, nfsd4_has_session(&resp->cstate));\n\t/*\n\t* To finish the open response, we just need to set the rflags.\n\t*/\n\topen->op_rflags = NFS4_OPEN_RESULT_LOCKTYPE_POSIX;\n\tif (!(open->op_openowner->oo_flags & NFS4_OO_CONFIRMED) &&\n\t    !nfsd4_has_session(&resp->cstate))\n\t\topen->op_rflags |= NFS4_OPEN_RESULT_CONFIRM;\n\tif (dp)\n\t\tnfs4_put_stid(&dp->dl_stid);\n\tif (stp)\n\t\tnfs4_put_stid(&stp->st_stid);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: Invalid OPEN claim type %d\\n\"",
            "open->op_claim_type"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: unsupported OPEN claim type %d\\n\"",
            "open->op_claim_type"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_open_fhandle",
          "args": [
            "rqstp",
            "cstate",
            "open"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "do_open_fhandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "315-347",
          "snippet": "static __be32\ndo_open_fhandle(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_open *open)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\t__be32 status;\n\tint accmode = 0;\n\n\t/* We don't know the target directory, and therefore can not\n\t* set the change info\n\t*/\n\n\tmemset(&open->op_cinfo, 0, sizeof(struct nfsd4_change_info));\n\n\tnfsd4_set_open_owner_reply_cache(cstate, open, current_fh);\n\n\topen->op_truncate = (open->op_iattr.ia_valid & ATTR_SIZE) &&\n\t\t(open->op_iattr.ia_size == 0);\n\t/*\n\t * In the delegation case, the client is telling us about an\n\t * open that it *already* performed locally, some time ago.  We\n\t * should let it succeed now if possible.\n\t *\n\t * In the case of a CLAIM_FH open, on the other hand, the client\n\t * may be counting on us to enforce permissions (the Linux 4.1\n\t * client uses this for normal opens, for example).\n\t */\n\tif (open->op_claim_type == NFS4_OPEN_CLAIM_DELEG_CUR_FH)\n\t\taccmode = NFSD_MAY_OWNER_OVERRIDE;\n\n\tstatus = do_open_permission(rqstp, current_fh, open, accmode);\n\n\treturn status;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\ndo_open_fhandle(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_open *open)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\t__be32 status;\n\tint accmode = 0;\n\n\t/* We don't know the target directory, and therefore can not\n\t* set the change info\n\t*/\n\n\tmemset(&open->op_cinfo, 0, sizeof(struct nfsd4_change_info));\n\n\tnfsd4_set_open_owner_reply_cache(cstate, open, current_fh);\n\n\topen->op_truncate = (open->op_iattr.ia_valid & ATTR_SIZE) &&\n\t\t(open->op_iattr.ia_size == 0);\n\t/*\n\t * In the delegation case, the client is telling us about an\n\t * open that it *already* performed locally, some time ago.  We\n\t * should let it succeed now if possible.\n\t *\n\t * In the case of a CLAIM_FH open, on the other hand, the client\n\t * may be counting on us to enforce permissions (the Linux 4.1\n\t * client uses this for normal opens, for example).\n\t */\n\tif (open->op_claim_type == NFS4_OPEN_CLAIM_DELEG_CUR_FH)\n\t\taccmode = NFSD_MAY_OWNER_OVERRIDE;\n\n\tstatus = do_open_permission(rqstp, current_fh, open, accmode);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_check_open_reclaim",
          "args": [
            "&open->op_clientid",
            "cstate",
            "nn"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_check_open_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5718-5737",
          "snippet": "__be32\nnfs4_check_open_reclaim(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\t__be32 status;\n\n\t/* find clientid in conf_id_hashtbl */\n\tstatus = lookup_clientid(clid, cstate, nn);\n\tif (status)\n\t\treturn nfserr_reclaim_bad;\n\n\tif (test_bit(NFSD4_CLIENT_RECLAIM_COMPLETE, &cstate->clp->cl_flags))\n\t\treturn nfserr_no_grace;\n\n\tif (nfsd4_client_record_check(cstate->clp))\n\t\treturn nfserr_reclaim_bad;\n\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfs4_check_open_reclaim(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\t__be32 status;\n\n\t/* find clientid in conf_id_hashtbl */\n\tstatus = lookup_clientid(clid, cstate, nn);\n\tif (status)\n\t\treturn nfserr_reclaim_bad;\n\n\tif (test_bit(NFSD4_CLIENT_RECLAIM_COMPLETE, &cstate->clp->cl_flags))\n\t\treturn nfserr_no_grace;\n\n\tif (nfsd4_client_record_check(cstate->clp))\n\t\treturn nfserr_reclaim_bad;\n\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_open_lookup",
          "args": [
            "rqstp",
            "cstate",
            "open",
            "&resfh"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "do_open_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "236-313",
          "snippet": "static __be32\ndo_open_lookup(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_open *open, struct svc_fh **resfh)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tint accmode;\n\t__be32 status;\n\n\t*resfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);\n\tif (!*resfh)\n\t\treturn nfserr_jukebox;\n\tfh_init(*resfh, NFS4_FHSIZE);\n\topen->op_truncate = 0;\n\n\tif (open->op_create) {\n\t\t/* FIXME: check session persistence and pnfs flags.\n\t\t * The nfsv4.1 spec requires the following semantics:\n\t\t *\n\t\t * Persistent   | pNFS   | Server REQUIRED | Client Allowed\n\t\t * Reply Cache  | server |                 |\n\t\t * -------------+--------+-----------------+--------------------\n\t\t * no           | no     | EXCLUSIVE4_1    | EXCLUSIVE4_1\n\t\t *              |        |                 | (SHOULD)\n\t\t *              |        | and EXCLUSIVE4  | or EXCLUSIVE4\n\t\t *              |        |                 | (SHOULD NOT)\n\t\t * no           | yes    | EXCLUSIVE4_1    | EXCLUSIVE4_1\n\t\t * yes          | no     | GUARDED4        | GUARDED4\n\t\t * yes          | yes    | GUARDED4        | GUARDED4\n\t\t */\n\n\t\t/*\n\t\t * Note: create modes (UNCHECKED,GUARDED...) are the same\n\t\t * in NFSv4 as in v3 except EXCLUSIVE4_1.\n\t\t */\n\t\tstatus = do_nfsd_create(rqstp, current_fh, open->op_fname.data,\n\t\t\t\t\topen->op_fname.len, &open->op_iattr,\n\t\t\t\t\t*resfh, open->op_createmode,\n\t\t\t\t\t(u32 *)open->op_verf.data,\n\t\t\t\t\t&open->op_truncate, &open->op_created);\n\n\t\tif (!status && open->op_label.len)\n\t\t\tnfsd4_security_inode_setsecctx(*resfh, &open->op_label, open->op_bmval);\n\n\t\t/*\n\t\t * Following rfc 3530 14.2.16, use the returned bitmask\n\t\t * to indicate which attributes we used to store the\n\t\t * verifier:\n\t\t */\n\t\tif (open->op_createmode == NFS4_CREATE_EXCLUSIVE && status == 0)\n\t\t\topen->op_bmval[1] = (FATTR4_WORD1_TIME_ACCESS |\n\t\t\t\t\t\t\tFATTR4_WORD1_TIME_MODIFY);\n\t} else\n\t\t/*\n\t\t * Note this may exit with the parent still locked.\n\t\t * We will hold the lock until nfsd4_open's final\n\t\t * lookup, to prevent renames or unlinks until we've had\n\t\t * a chance to an acquire a delegation if appropriate.\n\t\t */\n\t\tstatus = nfsd_lookup(rqstp, current_fh,\n\t\t\t\t     open->op_fname.data, open->op_fname.len, *resfh);\n\tif (status)\n\t\tgoto out;\n\tstatus = nfsd_check_obj_isreg(*resfh);\n\tif (status)\n\t\tgoto out;\n\n\tif (is_create_with_attrs(open) && open->op_acl != NULL)\n\t\tdo_set_nfs4_acl(rqstp, *resfh, open->op_acl, open->op_bmval);\n\n\tnfsd4_set_open_owner_reply_cache(cstate, open, *resfh);\n\taccmode = NFSD_MAY_NOP;\n\tif (open->op_created ||\n\t\t\topen->op_claim_type == NFS4_OPEN_CLAIM_DELEGATE_CUR)\n\t\taccmode |= NFSD_MAY_OWNER_OVERRIDE;\n\tstatus = do_open_permission(rqstp, *resfh, open, accmode);\n\tset_change_info(&open->op_cinfo, current_fh);\nout:\n\treturn status;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\ndo_open_lookup(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_open *open, struct svc_fh **resfh)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tint accmode;\n\t__be32 status;\n\n\t*resfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);\n\tif (!*resfh)\n\t\treturn nfserr_jukebox;\n\tfh_init(*resfh, NFS4_FHSIZE);\n\topen->op_truncate = 0;\n\n\tif (open->op_create) {\n\t\t/* FIXME: check session persistence and pnfs flags.\n\t\t * The nfsv4.1 spec requires the following semantics:\n\t\t *\n\t\t * Persistent   | pNFS   | Server REQUIRED | Client Allowed\n\t\t * Reply Cache  | server |                 |\n\t\t * -------------+--------+-----------------+--------------------\n\t\t * no           | no     | EXCLUSIVE4_1    | EXCLUSIVE4_1\n\t\t *              |        |                 | (SHOULD)\n\t\t *              |        | and EXCLUSIVE4  | or EXCLUSIVE4\n\t\t *              |        |                 | (SHOULD NOT)\n\t\t * no           | yes    | EXCLUSIVE4_1    | EXCLUSIVE4_1\n\t\t * yes          | no     | GUARDED4        | GUARDED4\n\t\t * yes          | yes    | GUARDED4        | GUARDED4\n\t\t */\n\n\t\t/*\n\t\t * Note: create modes (UNCHECKED,GUARDED...) are the same\n\t\t * in NFSv4 as in v3 except EXCLUSIVE4_1.\n\t\t */\n\t\tstatus = do_nfsd_create(rqstp, current_fh, open->op_fname.data,\n\t\t\t\t\topen->op_fname.len, &open->op_iattr,\n\t\t\t\t\t*resfh, open->op_createmode,\n\t\t\t\t\t(u32 *)open->op_verf.data,\n\t\t\t\t\t&open->op_truncate, &open->op_created);\n\n\t\tif (!status && open->op_label.len)\n\t\t\tnfsd4_security_inode_setsecctx(*resfh, &open->op_label, open->op_bmval);\n\n\t\t/*\n\t\t * Following rfc 3530 14.2.16, use the returned bitmask\n\t\t * to indicate which attributes we used to store the\n\t\t * verifier:\n\t\t */\n\t\tif (open->op_createmode == NFS4_CREATE_EXCLUSIVE && status == 0)\n\t\t\topen->op_bmval[1] = (FATTR4_WORD1_TIME_ACCESS |\n\t\t\t\t\t\t\tFATTR4_WORD1_TIME_MODIFY);\n\t} else\n\t\t/*\n\t\t * Note this may exit with the parent still locked.\n\t\t * We will hold the lock until nfsd4_open's final\n\t\t * lookup, to prevent renames or unlinks until we've had\n\t\t * a chance to an acquire a delegation if appropriate.\n\t\t */\n\t\tstatus = nfsd_lookup(rqstp, current_fh,\n\t\t\t\t     open->op_fname.data, open->op_fname.len, *resfh);\n\tif (status)\n\t\tgoto out;\n\tstatus = nfsd_check_obj_isreg(*resfh);\n\tif (status)\n\t\tgoto out;\n\n\tif (is_create_with_attrs(open) && open->op_acl != NULL)\n\t\tdo_set_nfs4_acl(rqstp, *resfh, open->op_acl, open->op_bmval);\n\n\tnfsd4_set_open_owner_reply_cache(cstate, open, *resfh);\n\taccmode = NFSD_MAY_NOP;\n\tif (open->op_created ||\n\t\t\topen->op_claim_type == NFS4_OPEN_CLAIM_DELEGATE_CUR)\n\t\taccmode |= NFSD_MAY_OWNER_OVERRIDE;\n\tstatus = do_open_permission(rqstp, *resfh, open, accmode);\n\tset_change_info(&open->op_cinfo, current_fh);\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_in_grace",
          "args": [
            "net"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "locks_in_grace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/grace.c",
          "lines": "65-71",
          "snippet": "int\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <net/netns/generic.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int grace_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <net/netns/generic.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n\nstatic int grace_net_id;\n\nint\nlocks_in_grace(struct net *net)\n{\n\tstruct list_head *grace_list = net_generic(net, grace_net_id);\n\n\treturn !list_empty(grace_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_check_open_attributes",
          "args": [
            "rqstp",
            "cstate",
            "open"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_check_open_attributes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "129-146",
          "snippet": "static __be32\nnfsd4_check_open_attributes(struct svc_rqst *rqstp,\n\tstruct nfsd4_compound_state *cstate, struct nfsd4_open *open)\n{\n\t__be32 status = nfs_ok;\n\n\tif (open->op_create == NFS4_OPEN_CREATE) {\n\t\tif (open->op_createmode == NFS4_CREATE_UNCHECKED\n\t\t    || open->op_createmode == NFS4_CREATE_GUARDED)\n\t\t\tstatus = check_attr_support(rqstp, cstate,\n\t\t\t\t\topen->op_bmval, nfsd_attrmask);\n\t\telse if (open->op_createmode == NFS4_CREATE_EXCLUSIVE4_1)\n\t\t\tstatus = check_attr_support(rqstp, cstate,\n\t\t\t\t\topen->op_bmval, nfsd41_ex_attrmask);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 nfsd_attrmask[] = {\n\tNFSD_WRITEABLE_ATTRS_WORD0,\n\tNFSD_WRITEABLE_ATTRS_WORD1,\n\tNFSD_WRITEABLE_ATTRS_WORD2\n};",
            "static u32 nfsd41_ex_attrmask[] = {\n\tNFSD_SUPPATTR_EXCLCREAT_WORD0,\n\tNFSD_SUPPATTR_EXCLCREAT_WORD1,\n\tNFSD_SUPPATTR_EXCLCREAT_WORD2\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic u32 nfsd_attrmask[] = {\n\tNFSD_WRITEABLE_ATTRS_WORD0,\n\tNFSD_WRITEABLE_ATTRS_WORD1,\n\tNFSD_WRITEABLE_ATTRS_WORD2\n};\nstatic u32 nfsd41_ex_attrmask[] = {\n\tNFSD_SUPPATTR_EXCLCREAT_WORD0,\n\tNFSD_SUPPATTR_EXCLCREAT_WORD1,\n\tNFSD_SUPPATTR_EXCLCREAT_WORD2\n};\n\nstatic __be32\nnfsd4_check_open_attributes(struct svc_rqst *rqstp,\n\tstruct nfsd4_compound_state *cstate, struct nfsd4_open *open)\n{\n\t__be32 status = nfs_ok;\n\n\tif (open->op_create == NFS4_OPEN_CREATE) {\n\t\tif (open->op_createmode == NFS4_CREATE_UNCHECKED\n\t\t    || open->op_createmode == NFS4_CREATE_GUARDED)\n\t\t\tstatus = check_attr_support(rqstp, cstate,\n\t\t\t\t\topen->op_bmval, nfsd_attrmask);\n\t\telse if (open->op_createmode == NFS4_CREATE_EXCLUSIVE4_1)\n\t\t\tstatus = check_attr_support(rqstp, cstate,\n\t\t\t\t\topen->op_bmval, nfsd41_ex_attrmask);\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd4_open: replay failed\"\n\t\t\t\t\" restoring previous filehandle\\n\""
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "0",
            "NFSD_MAY_NOP"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_copy_shallow",
          "args": [
            "&cstate->current_fh.fh_handle",
            "&rp->rp_openfh"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "fh_copy_shallow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "175-180",
          "snippet": "static inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_process_open1",
          "args": [
            "&resp->cstate",
            "open",
            "nn"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_process_open1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "3534-3585",
          "snippet": "__be32\nnfsd4_process_open1(struct nfsd4_compound_state *cstate,\n\t\t    struct nfsd4_open *open, struct nfsd_net *nn)\n{\n\tclientid_t *clientid = &open->op_clientid;\n\tstruct nfs4_client *clp = NULL;\n\tunsigned int strhashval;\n\tstruct nfs4_openowner *oo = NULL;\n\t__be32 status;\n\n\tif (STALE_CLIENTID(&open->op_clientid, nn))\n\t\treturn nfserr_stale_clientid;\n\t/*\n\t * In case we need it later, after we've already created the\n\t * file and don't want to risk a further failure:\n\t */\n\topen->op_file = nfsd4_alloc_file();\n\tif (open->op_file == NULL)\n\t\treturn nfserr_jukebox;\n\n\tstatus = lookup_clientid(clientid, cstate, nn);\n\tif (status)\n\t\treturn status;\n\tclp = cstate->clp;\n\n\tstrhashval = ownerstr_hashval(&open->op_owner);\n\too = find_openstateowner_str(strhashval, open, clp);\n\topen->op_openowner = oo;\n\tif (!oo) {\n\t\tgoto new_owner;\n\t}\n\tif (!(oo->oo_flags & NFS4_OO_CONFIRMED)) {\n\t\t/* Replace unconfirmed owners without checking for replay. */\n\t\trelease_openowner(oo);\n\t\topen->op_openowner = NULL;\n\t\tgoto new_owner;\n\t}\n\tstatus = nfsd4_check_seqid(cstate, &oo->oo_owner, open->op_seqid);\n\tif (status)\n\t\treturn status;\n\tgoto alloc_stateid;\nnew_owner:\n\too = alloc_init_open_stateowner(strhashval, open, cstate);\n\tif (oo == NULL)\n\t\treturn nfserr_jukebox;\n\topen->op_openowner = oo;\nalloc_stateid:\n\topen->op_stp = nfs4_alloc_open_stateid(clp);\n\tif (!open->op_stp)\n\t\treturn nfserr_jukebox;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_process_open1(struct nfsd4_compound_state *cstate,\n\t\t    struct nfsd4_open *open, struct nfsd_net *nn)\n{\n\tclientid_t *clientid = &open->op_clientid;\n\tstruct nfs4_client *clp = NULL;\n\tunsigned int strhashval;\n\tstruct nfs4_openowner *oo = NULL;\n\t__be32 status;\n\n\tif (STALE_CLIENTID(&open->op_clientid, nn))\n\t\treturn nfserr_stale_clientid;\n\t/*\n\t * In case we need it later, after we've already created the\n\t * file and don't want to risk a further failure:\n\t */\n\topen->op_file = nfsd4_alloc_file();\n\tif (open->op_file == NULL)\n\t\treturn nfserr_jukebox;\n\n\tstatus = lookup_clientid(clientid, cstate, nn);\n\tif (status)\n\t\treturn status;\n\tclp = cstate->clp;\n\n\tstrhashval = ownerstr_hashval(&open->op_owner);\n\too = find_openstateowner_str(strhashval, open, clp);\n\topen->op_openowner = oo;\n\tif (!oo) {\n\t\tgoto new_owner;\n\t}\n\tif (!(oo->oo_flags & NFS4_OO_CONFIRMED)) {\n\t\t/* Replace unconfirmed owners without checking for replay. */\n\t\trelease_openowner(oo);\n\t\topen->op_openowner = NULL;\n\t\tgoto new_owner;\n\t}\n\tstatus = nfsd4_check_seqid(cstate, &oo->oo_owner, open->op_seqid);\n\tif (status)\n\t\treturn status;\n\tgoto alloc_stateid;\nnew_owner:\n\too = alloc_init_open_stateowner(strhashval, open, cstate);\n\tif (oo == NULL)\n\t\treturn nfserr_jukebox;\n\topen->op_openowner = oo;\nalloc_stateid:\n\topen->op_stp = nfs4_alloc_open_stateid(clp);\n\tif (!open->op_stp)\n\t\treturn nfserr_jukebox;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_clientid",
          "args": [
            "&open->op_clientid",
            "cstate->session"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "copy_clientid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "349-357",
          "snippet": "static void\ncopy_clientid(clientid_t *clid, struct nfsd4_session *session)\n{\n\tstruct nfsd4_sessionid *sid =\n\t\t\t(struct nfsd4_sessionid *)session->se_sessionid.data;\n\n\tclid->cl_boot = sid->clientid.cl_boot;\n\tclid->cl_id = sid->clientid.cl_id;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic void\ncopy_clientid(clientid_t *clid, struct nfsd4_session *session)\n{\n\tstruct nfsd4_sessionid *sid =\n\t\t\t(struct nfsd4_sessionid *)session->se_sessionid.data;\n\n\tclid->cl_boot = sid->clientid.cl_boot;\n\tclid->cl_id = sid->clientid.cl_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "cstate"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/xdr4.h",
          "lines": "72-75",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFSD4_CLIENT_RECLAIM_COMPLETE",
            "&cstate->session->se_client->cl_flags"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfsd4_open filename %.*s op_openowner %p\\n\"",
            "(int)open->op_fname.len",
            "open->op_fname.data",
            "open->op_openowner"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_open(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t   struct nfsd4_open *open)\n{\n\t__be32 status;\n\tstruct svc_fh *resfh = NULL;\n\tstruct nfsd4_compoundres *resp;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_open filename %.*s op_openowner %p\\n\",\n\t\t(int)open->op_fname.len, open->op_fname.data,\n\t\topen->op_openowner);\n\n\t/* This check required by spec. */\n\tif (open->op_create && open->op_claim_type != NFS4_OPEN_CLAIM_NULL)\n\t\treturn nfserr_inval;\n\n\topen->op_created = 0;\n\t/*\n\t * RFC5661 18.51.3\n\t * Before RECLAIM_COMPLETE done, server should deny new lock\n\t */\n\tif (nfsd4_has_session(cstate) &&\n\t    !test_bit(NFSD4_CLIENT_RECLAIM_COMPLETE,\n\t\t      &cstate->session->se_client->cl_flags) &&\n\t    open->op_claim_type != NFS4_OPEN_CLAIM_PREVIOUS)\n\t\treturn nfserr_grace;\n\n\tif (nfsd4_has_session(cstate))\n\t\tcopy_clientid(&open->op_clientid, cstate->session);\n\n\t/* check seqid for replay. set nfs4_owner */\n\tresp = rqstp->rq_resp;\n\tstatus = nfsd4_process_open1(&resp->cstate, open, nn);\n\tif (status == nfserr_replay_me) {\n\t\tstruct nfs4_replay *rp = &open->op_openowner->oo_owner.so_replay;\n\t\tfh_put(&cstate->current_fh);\n\t\tfh_copy_shallow(&cstate->current_fh.fh_handle,\n\t\t\t\t&rp->rp_openfh);\n\t\tstatus = fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_NOP);\n\t\tif (status)\n\t\t\tdprintk(\"nfsd4_open: replay failed\"\n\t\t\t\t\" restoring previous filehandle\\n\");\n\t\telse\n\t\t\tstatus = nfserr_replay_me;\n\t}\n\tif (status)\n\t\tgoto out;\n\tif (open->op_xdr_error) {\n\t\tstatus = open->op_xdr_error;\n\t\tgoto out;\n\t}\n\n\tstatus = nfsd4_check_open_attributes(rqstp, cstate, open);\n\tif (status)\n\t\tgoto out;\n\n\t/* Openowner is now set, so sequence id will get bumped.  Now we need\n\t * these checks before we do any creates: */\n\tstatus = nfserr_grace;\n\tif (locks_in_grace(net) && open->op_claim_type != NFS4_OPEN_CLAIM_PREVIOUS)\n\t\tgoto out;\n\tstatus = nfserr_no_grace;\n\tif (!locks_in_grace(net) && open->op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS)\n\t\tgoto out;\n\n\tswitch (open->op_claim_type) {\n\t\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\t\tcase NFS4_OPEN_CLAIM_NULL:\n\t\t\tstatus = do_open_lookup(rqstp, cstate, open, &resfh);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\t\tstatus = nfs4_check_open_reclaim(&open->op_clientid,\n\t\t\t\t\t\t\t cstate, nn);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t\topen->op_openowner->oo_flags |= NFS4_OO_CONFIRMED;\n\t\tcase NFS4_OPEN_CLAIM_FH:\n\t\tcase NFS4_OPEN_CLAIM_DELEG_CUR_FH:\n\t\t\tstatus = do_open_fhandle(rqstp, cstate, open);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t\tresfh = &cstate->current_fh;\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_CLAIM_DELEG_PREV_FH:\n             \tcase NFS4_OPEN_CLAIM_DELEGATE_PREV:\n\t\t\tdprintk(\"NFSD: unsupported OPEN claim type %d\\n\",\n\t\t\t\topen->op_claim_type);\n\t\t\tstatus = nfserr_notsupp;\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tdprintk(\"NFSD: Invalid OPEN claim type %d\\n\",\n\t\t\t\topen->op_claim_type);\n\t\t\tstatus = nfserr_inval;\n\t\t\tgoto out;\n\t}\n\t/*\n\t * nfsd4_process_open2() does the actual opening of the file.  If\n\t * successful, it (1) truncates the file if open->op_truncate was\n\t * set, (2) sets open->op_stateid, (3) sets open->op_delegation.\n\t */\n\tstatus = nfsd4_process_open2(rqstp, resfh, open);\n\tWARN(status && open->op_created,\n\t     \"nfsd4_process_open2 failed to open newly-created file! status=%u\\n\",\n\t     be32_to_cpu(status));\nout:\n\tif (resfh && resfh != &cstate->current_fh) {\n\t\tfh_dup2(&cstate->current_fh, resfh);\n\t\tfh_put(resfh);\n\t\tkfree(resfh);\n\t}\n\tnfsd4_cleanup_open_state(cstate, open, status);\n\tnfsd4_bump_seqid(cstate, status);\n\treturn status;\n}"
  },
  {
    "function_name": "copy_clientid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "349-357",
    "snippet": "static void\ncopy_clientid(clientid_t *clid, struct nfsd4_session *session)\n{\n\tstruct nfsd4_sessionid *sid =\n\t\t\t(struct nfsd4_sessionid *)session->se_sessionid.data;\n\n\tclid->cl_boot = sid->clientid.cl_boot;\n\tclid->cl_id = sid->clientid.cl_id;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic void\ncopy_clientid(clientid_t *clid, struct nfsd4_session *session)\n{\n\tstruct nfsd4_sessionid *sid =\n\t\t\t(struct nfsd4_sessionid *)session->se_sessionid.data;\n\n\tclid->cl_boot = sid->clientid.cl_boot;\n\tclid->cl_id = sid->clientid.cl_id;\n}"
  },
  {
    "function_name": "do_open_fhandle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "315-347",
    "snippet": "static __be32\ndo_open_fhandle(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_open *open)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\t__be32 status;\n\tint accmode = 0;\n\n\t/* We don't know the target directory, and therefore can not\n\t* set the change info\n\t*/\n\n\tmemset(&open->op_cinfo, 0, sizeof(struct nfsd4_change_info));\n\n\tnfsd4_set_open_owner_reply_cache(cstate, open, current_fh);\n\n\topen->op_truncate = (open->op_iattr.ia_valid & ATTR_SIZE) &&\n\t\t(open->op_iattr.ia_size == 0);\n\t/*\n\t * In the delegation case, the client is telling us about an\n\t * open that it *already* performed locally, some time ago.  We\n\t * should let it succeed now if possible.\n\t *\n\t * In the case of a CLAIM_FH open, on the other hand, the client\n\t * may be counting on us to enforce permissions (the Linux 4.1\n\t * client uses this for normal opens, for example).\n\t */\n\tif (open->op_claim_type == NFS4_OPEN_CLAIM_DELEG_CUR_FH)\n\t\taccmode = NFSD_MAY_OWNER_OVERRIDE;\n\n\tstatus = do_open_permission(rqstp, current_fh, open, accmode);\n\n\treturn status;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_open_permission",
          "args": [
            "rqstp",
            "current_fh",
            "open",
            "accmode"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "do_open_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "187-208",
          "snippet": "static __be32\ndo_open_permission(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_open *open, int accmode)\n{\n\t__be32 status;\n\n\tif (open->op_truncate &&\n\t\t!(open->op_share_access & NFS4_SHARE_ACCESS_WRITE))\n\t\treturn nfserr_inval;\n\n\taccmode |= NFSD_MAY_READ_IF_EXEC;\n\n\tif (open->op_share_access & NFS4_SHARE_ACCESS_READ)\n\t\taccmode |= NFSD_MAY_READ;\n\tif (open->op_share_access & NFS4_SHARE_ACCESS_WRITE)\n\t\taccmode |= (NFSD_MAY_WRITE | NFSD_MAY_TRUNC);\n\tif (open->op_share_deny & NFS4_SHARE_DENY_READ)\n\t\taccmode |= NFSD_MAY_WRITE;\n\n\tstatus = fh_verify(rqstp, current_fh, S_IFREG, accmode);\n\n\treturn status;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\ndo_open_permission(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_open *open, int accmode)\n{\n\t__be32 status;\n\n\tif (open->op_truncate &&\n\t\t!(open->op_share_access & NFS4_SHARE_ACCESS_WRITE))\n\t\treturn nfserr_inval;\n\n\taccmode |= NFSD_MAY_READ_IF_EXEC;\n\n\tif (open->op_share_access & NFS4_SHARE_ACCESS_READ)\n\t\taccmode |= NFSD_MAY_READ;\n\tif (open->op_share_access & NFS4_SHARE_ACCESS_WRITE)\n\t\taccmode |= (NFSD_MAY_WRITE | NFSD_MAY_TRUNC);\n\tif (open->op_share_deny & NFS4_SHARE_DENY_READ)\n\t\taccmode |= NFSD_MAY_WRITE;\n\n\tstatus = fh_verify(rqstp, current_fh, S_IFREG, accmode);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_set_open_owner_reply_cache",
          "args": [
            "cstate",
            "open",
            "current_fh"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_set_open_owner_reply_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "228-234",
          "snippet": "static void nfsd4_set_open_owner_reply_cache(struct nfsd4_compound_state *cstate, struct nfsd4_open *open, struct svc_fh *resfh)\n{\n\tif (nfsd4_has_session(cstate))\n\t\treturn;\n\tfh_copy_shallow(&open->op_openowner->oo_owner.so_replay.rp_openfh,\n\t\t\t&resfh->fh_handle);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic void nfsd4_set_open_owner_reply_cache(struct nfsd4_compound_state *cstate, struct nfsd4_open *open, struct svc_fh *resfh)\n{\n\tif (nfsd4_has_session(cstate))\n\t\treturn;\n\tfh_copy_shallow(&open->op_openowner->oo_owner.so_replay.rp_openfh,\n\t\t\t&resfh->fh_handle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&open->op_cinfo",
            "0",
            "sizeof(struct nfsd4_change_info)"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\ndo_open_fhandle(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_open *open)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\t__be32 status;\n\tint accmode = 0;\n\n\t/* We don't know the target directory, and therefore can not\n\t* set the change info\n\t*/\n\n\tmemset(&open->op_cinfo, 0, sizeof(struct nfsd4_change_info));\n\n\tnfsd4_set_open_owner_reply_cache(cstate, open, current_fh);\n\n\topen->op_truncate = (open->op_iattr.ia_valid & ATTR_SIZE) &&\n\t\t(open->op_iattr.ia_size == 0);\n\t/*\n\t * In the delegation case, the client is telling us about an\n\t * open that it *already* performed locally, some time ago.  We\n\t * should let it succeed now if possible.\n\t *\n\t * In the case of a CLAIM_FH open, on the other hand, the client\n\t * may be counting on us to enforce permissions (the Linux 4.1\n\t * client uses this for normal opens, for example).\n\t */\n\tif (open->op_claim_type == NFS4_OPEN_CLAIM_DELEG_CUR_FH)\n\t\taccmode = NFSD_MAY_OWNER_OVERRIDE;\n\n\tstatus = do_open_permission(rqstp, current_fh, open, accmode);\n\n\treturn status;\n}"
  },
  {
    "function_name": "do_open_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "236-313",
    "snippet": "static __be32\ndo_open_lookup(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_open *open, struct svc_fh **resfh)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tint accmode;\n\t__be32 status;\n\n\t*resfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);\n\tif (!*resfh)\n\t\treturn nfserr_jukebox;\n\tfh_init(*resfh, NFS4_FHSIZE);\n\topen->op_truncate = 0;\n\n\tif (open->op_create) {\n\t\t/* FIXME: check session persistence and pnfs flags.\n\t\t * The nfsv4.1 spec requires the following semantics:\n\t\t *\n\t\t * Persistent   | pNFS   | Server REQUIRED | Client Allowed\n\t\t * Reply Cache  | server |                 |\n\t\t * -------------+--------+-----------------+--------------------\n\t\t * no           | no     | EXCLUSIVE4_1    | EXCLUSIVE4_1\n\t\t *              |        |                 | (SHOULD)\n\t\t *              |        | and EXCLUSIVE4  | or EXCLUSIVE4\n\t\t *              |        |                 | (SHOULD NOT)\n\t\t * no           | yes    | EXCLUSIVE4_1    | EXCLUSIVE4_1\n\t\t * yes          | no     | GUARDED4        | GUARDED4\n\t\t * yes          | yes    | GUARDED4        | GUARDED4\n\t\t */\n\n\t\t/*\n\t\t * Note: create modes (UNCHECKED,GUARDED...) are the same\n\t\t * in NFSv4 as in v3 except EXCLUSIVE4_1.\n\t\t */\n\t\tstatus = do_nfsd_create(rqstp, current_fh, open->op_fname.data,\n\t\t\t\t\topen->op_fname.len, &open->op_iattr,\n\t\t\t\t\t*resfh, open->op_createmode,\n\t\t\t\t\t(u32 *)open->op_verf.data,\n\t\t\t\t\t&open->op_truncate, &open->op_created);\n\n\t\tif (!status && open->op_label.len)\n\t\t\tnfsd4_security_inode_setsecctx(*resfh, &open->op_label, open->op_bmval);\n\n\t\t/*\n\t\t * Following rfc 3530 14.2.16, use the returned bitmask\n\t\t * to indicate which attributes we used to store the\n\t\t * verifier:\n\t\t */\n\t\tif (open->op_createmode == NFS4_CREATE_EXCLUSIVE && status == 0)\n\t\t\topen->op_bmval[1] = (FATTR4_WORD1_TIME_ACCESS |\n\t\t\t\t\t\t\tFATTR4_WORD1_TIME_MODIFY);\n\t} else\n\t\t/*\n\t\t * Note this may exit with the parent still locked.\n\t\t * We will hold the lock until nfsd4_open's final\n\t\t * lookup, to prevent renames or unlinks until we've had\n\t\t * a chance to an acquire a delegation if appropriate.\n\t\t */\n\t\tstatus = nfsd_lookup(rqstp, current_fh,\n\t\t\t\t     open->op_fname.data, open->op_fname.len, *resfh);\n\tif (status)\n\t\tgoto out;\n\tstatus = nfsd_check_obj_isreg(*resfh);\n\tif (status)\n\t\tgoto out;\n\n\tif (is_create_with_attrs(open) && open->op_acl != NULL)\n\t\tdo_set_nfs4_acl(rqstp, *resfh, open->op_acl, open->op_bmval);\n\n\tnfsd4_set_open_owner_reply_cache(cstate, open, *resfh);\n\taccmode = NFSD_MAY_NOP;\n\tif (open->op_created ||\n\t\t\topen->op_claim_type == NFS4_OPEN_CLAIM_DELEGATE_CUR)\n\t\taccmode |= NFSD_MAY_OWNER_OVERRIDE;\n\tstatus = do_open_permission(rqstp, *resfh, open, accmode);\n\tset_change_info(&open->op_cinfo, current_fh);\nout:\n\treturn status;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_change_info",
          "args": [
            "&open->op_cinfo",
            "current_fh"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "set_change_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/xdr4.h",
          "lines": "630-644",
          "snippet": "static inline void\nset_change_info(struct nfsd4_change_info *cinfo, struct svc_fh *fhp)\n{\n\tBUG_ON(!fhp->fh_pre_saved);\n\tcinfo->atomic = fhp->fh_post_saved;\n\tcinfo->change_supported = IS_I_VERSION(fhp->fh_dentry->d_inode);\n\n\tcinfo->before_change = fhp->fh_pre_change;\n\tcinfo->after_change = fhp->fh_post_change;\n\tcinfo->before_ctime_sec = fhp->fh_pre_ctime.tv_sec;\n\tcinfo->before_ctime_nsec = fhp->fh_pre_ctime.tv_nsec;\n\tcinfo->after_ctime_sec = fhp->fh_post_attr.ctime.tv_sec;\n\tcinfo->after_ctime_nsec = fhp->fh_post_attr.ctime.tv_nsec;\n\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline void\nset_change_info(struct nfsd4_change_info *cinfo, struct svc_fh *fhp)\n{\n\tBUG_ON(!fhp->fh_pre_saved);\n\tcinfo->atomic = fhp->fh_post_saved;\n\tcinfo->change_supported = IS_I_VERSION(fhp->fh_dentry->d_inode);\n\n\tcinfo->before_change = fhp->fh_pre_change;\n\tcinfo->after_change = fhp->fh_post_change;\n\tcinfo->before_ctime_sec = fhp->fh_pre_ctime.tv_sec;\n\tcinfo->before_ctime_nsec = fhp->fh_pre_ctime.tv_nsec;\n\tcinfo->after_ctime_sec = fhp->fh_post_attr.ctime.tv_sec;\n\tcinfo->after_ctime_nsec = fhp->fh_post_attr.ctime.tv_nsec;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_open_permission",
          "args": [
            "rqstp",
            "*resfh",
            "open",
            "accmode"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "do_open_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "187-208",
          "snippet": "static __be32\ndo_open_permission(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_open *open, int accmode)\n{\n\t__be32 status;\n\n\tif (open->op_truncate &&\n\t\t!(open->op_share_access & NFS4_SHARE_ACCESS_WRITE))\n\t\treturn nfserr_inval;\n\n\taccmode |= NFSD_MAY_READ_IF_EXEC;\n\n\tif (open->op_share_access & NFS4_SHARE_ACCESS_READ)\n\t\taccmode |= NFSD_MAY_READ;\n\tif (open->op_share_access & NFS4_SHARE_ACCESS_WRITE)\n\t\taccmode |= (NFSD_MAY_WRITE | NFSD_MAY_TRUNC);\n\tif (open->op_share_deny & NFS4_SHARE_DENY_READ)\n\t\taccmode |= NFSD_MAY_WRITE;\n\n\tstatus = fh_verify(rqstp, current_fh, S_IFREG, accmode);\n\n\treturn status;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\ndo_open_permission(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_open *open, int accmode)\n{\n\t__be32 status;\n\n\tif (open->op_truncate &&\n\t\t!(open->op_share_access & NFS4_SHARE_ACCESS_WRITE))\n\t\treturn nfserr_inval;\n\n\taccmode |= NFSD_MAY_READ_IF_EXEC;\n\n\tif (open->op_share_access & NFS4_SHARE_ACCESS_READ)\n\t\taccmode |= NFSD_MAY_READ;\n\tif (open->op_share_access & NFS4_SHARE_ACCESS_WRITE)\n\t\taccmode |= (NFSD_MAY_WRITE | NFSD_MAY_TRUNC);\n\tif (open->op_share_deny & NFS4_SHARE_DENY_READ)\n\t\taccmode |= NFSD_MAY_WRITE;\n\n\tstatus = fh_verify(rqstp, current_fh, S_IFREG, accmode);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_set_open_owner_reply_cache",
          "args": [
            "cstate",
            "open",
            "*resfh"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_set_open_owner_reply_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "228-234",
          "snippet": "static void nfsd4_set_open_owner_reply_cache(struct nfsd4_compound_state *cstate, struct nfsd4_open *open, struct svc_fh *resfh)\n{\n\tif (nfsd4_has_session(cstate))\n\t\treturn;\n\tfh_copy_shallow(&open->op_openowner->oo_owner.so_replay.rp_openfh,\n\t\t\t&resfh->fh_handle);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic void nfsd4_set_open_owner_reply_cache(struct nfsd4_compound_state *cstate, struct nfsd4_open *open, struct svc_fh *resfh)\n{\n\tif (nfsd4_has_session(cstate))\n\t\treturn;\n\tfh_copy_shallow(&open->op_openowner->oo_owner.so_replay.rp_openfh,\n\t\t\t&resfh->fh_handle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_set_nfs4_acl",
          "args": [
            "rqstp",
            "*resfh",
            "open->op_acl",
            "open->op_bmval"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "do_set_nfs4_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "161-175",
          "snippet": "static void\ndo_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl, u32 *bmval)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_set_nfs4_acl(rqstp, fhp, acl);\n\tif (status)\n\t\t/*\n\t\t * We should probably fail the whole open at this point,\n\t\t * but we've already created the file, so it's too late;\n\t\t * So this seems the least of evils:\n\t\t */\n\t\tbmval[0] &= ~FATTR4_WORD0_ACL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic void\ndo_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl, u32 *bmval)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_set_nfs4_acl(rqstp, fhp, acl);\n\tif (status)\n\t\t/*\n\t\t * We should probably fail the whole open at this point,\n\t\t * but we've already created the file, so it's too late;\n\t\t * So this seems the least of evils:\n\t\t */\n\t\tbmval[0] &= ~FATTR4_WORD0_ACL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_create_with_attrs",
          "args": [
            "open"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "is_create_with_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "148-155",
          "snippet": "static int\nis_create_with_attrs(struct nfsd4_open *open)\n{\n\treturn open->op_create == NFS4_OPEN_CREATE\n\t\t&& (open->op_createmode == NFS4_CREATE_UNCHECKED\n\t\t    || open->op_createmode == NFS4_CREATE_GUARDED\n\t\t    || open->op_createmode == NFS4_CREATE_EXCLUSIVE4_1);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic int\nis_create_with_attrs(struct nfsd4_open *open)\n{\n\treturn open->op_create == NFS4_OPEN_CREATE\n\t\t&& (open->op_createmode == NFS4_CREATE_UNCHECKED\n\t\t    || open->op_createmode == NFS4_CREATE_GUARDED\n\t\t    || open->op_createmode == NFS4_CREATE_EXCLUSIVE4_1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_check_obj_isreg",
          "args": [
            "*resfh"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_check_obj_isreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "210-226",
          "snippet": "static __be32 nfsd_check_obj_isreg(struct svc_fh *fh)\n{\n\tumode_t mode = fh->fh_dentry->d_inode->i_mode;\n\n\tif (S_ISREG(mode))\n\t\treturn nfs_ok;\n\tif (S_ISDIR(mode))\n\t\treturn nfserr_isdir;\n\t/*\n\t * Using err_symlink as our catch-all case may look odd; but\n\t * there's no other obvious error for this case in 4.0, and we\n\t * happen to know that it will cause the linux v4 client to do\n\t * the right thing on attempts to open something other than a\n\t * regular file.\n\t */\n\treturn nfserr_symlink;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd_check_obj_isreg(struct svc_fh *fh)\n{\n\tumode_t mode = fh->fh_dentry->d_inode->i_mode;\n\n\tif (S_ISREG(mode))\n\t\treturn nfs_ok;\n\tif (S_ISDIR(mode))\n\t\treturn nfserr_isdir;\n\t/*\n\t * Using err_symlink as our catch-all case may look odd; but\n\t * there's no other obvious error for this case in 4.0, and we\n\t * happen to know that it will cause the linux v4 client to do\n\t * the right thing on attempts to open something other than a\n\t * regular file.\n\t */\n\treturn nfserr_symlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_lookup",
          "args": [
            "rqstp",
            "current_fh",
            "open->op_fname.data",
            "open->op_fname.len",
            "*resfh"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "251-279",
          "snippet": "__be32\nnfsd_lookup(struct svc_rqst *rqstp, struct svc_fh *fhp, const char *name,\n\t\t\t\tunsigned int len, struct svc_fh *resfh)\n{\n\tstruct svc_export\t*exp;\n\tstruct dentry\t\t*dentry;\n\t__be32 err;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_EXEC);\n\tif (err)\n\t\treturn err;\n\terr = nfsd_lookup_dentry(rqstp, fhp, name, len, &exp, &dentry);\n\tif (err)\n\t\treturn err;\n\terr = check_nfsd_access(exp, rqstp);\n\tif (err)\n\t\tgoto out;\n\t/*\n\t * Note: we compose the file handle now, but as the\n\t * dentry may be negative, it may need to be updated.\n\t */\n\terr = fh_compose(resfh, exp, dentry, fhp);\n\tif (!err && !dentry->d_inode)\n\t\terr = nfserr_noent;\nout:\n\tdput(dentry);\n\texp_put(exp);\n\treturn err;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_lookup(struct svc_rqst *rqstp, struct svc_fh *fhp, const char *name,\n\t\t\t\tunsigned int len, struct svc_fh *resfh)\n{\n\tstruct svc_export\t*exp;\n\tstruct dentry\t\t*dentry;\n\t__be32 err;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_EXEC);\n\tif (err)\n\t\treturn err;\n\terr = nfsd_lookup_dentry(rqstp, fhp, name, len, &exp, &dentry);\n\tif (err)\n\t\treturn err;\n\terr = check_nfsd_access(exp, rqstp);\n\tif (err)\n\t\tgoto out;\n\t/*\n\t * Note: we compose the file handle now, but as the\n\t * dentry may be negative, it may need to be updated.\n\t */\n\terr = fh_compose(resfh, exp, dentry, fhp);\n\tif (!err && !dentry->d_inode)\n\t\terr = nfserr_noent;\nout:\n\tdput(dentry);\n\texp_put(exp);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_security_inode_setsecctx",
          "args": [
            "*resfh",
            "&open->op_label",
            "open->op_bmval"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_security_inode_setsecctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "74-76",
          "snippet": "static inline void\nnfsd4_security_inode_setsecctx(struct svc_fh *resfh, struct xdr_netobj *label, u32 *bmval)\n{ }",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic inline void\nnfsd4_security_inode_setsecctx(struct svc_fh *resfh, struct xdr_netobj *label, u32 *bmval)\n{ }"
        }
      },
      {
        "call_info": {
          "callee": "do_nfsd_create",
          "args": [
            "rqstp",
            "current_fh",
            "open->op_fname.data",
            "open->op_fname.len",
            "&open->op_iattr",
            "*resfh",
            "open->op_createmode",
            "(u32 *)open->op_verf.data",
            "&open->op_truncate",
            "&open->op_created"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "do_nfsd_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "1331-1493",
          "snippet": "__be32\ndo_nfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tchar *fname, int flen, struct iattr *iap,\n\t\tstruct svc_fh *resfhp, int createmode, u32 *verifier,\n\t        bool *truncp, bool *created)\n{\n\tstruct dentry\t*dentry, *dchild = NULL;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\t__u32\t\tv_mtime=0, v_atime=0;\n\n\terr = nfserr_perm;\n\tif (!flen)\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(fname, flen))\n\t\tgoto out;\n\tif (!(iap->ia_valid & ATTR_MODE))\n\t\tiap->ia_mode = 0;\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_EXEC);\n\tif (err)\n\t\tgoto out;\n\n\tdentry = fhp->fh_dentry;\n\tdirp = dentry->d_inode;\n\n\t/* Get all the sanity checks out of the way before\n\t * we lock the parent. */\n\terr = nfserr_notdir;\n\tif (!dirp->i_op->lookup)\n\t\tgoto out;\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\tgoto out_nfserr;\n\n\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\n\t/*\n\t * Compose the response file handle.\n\t */\n\tdchild = lookup_one_len(fname, dentry, flen);\n\thost_err = PTR_ERR(dchild);\n\tif (IS_ERR(dchild))\n\t\tgoto out_nfserr;\n\n\t/* If file doesn't exist, check for permissions to create one */\n\tif (!dchild->d_inode) {\n\t\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = fh_compose(resfhp, fhp->fh_export, dchild, fhp);\n\tif (err)\n\t\tgoto out;\n\n\tif (nfsd_create_is_exclusive(createmode)) {\n\t\t/* solaris7 gets confused (bugid 4218508) if these have\n\t\t * the high bit set, so just clear the high bits. If this is\n\t\t * ever changed to use different attrs for storing the\n\t\t * verifier, then do_open_lookup() will also need to be fixed\n\t\t * accordingly.\n\t\t */\n\t\tv_mtime = verifier[0]&0x7fffffff;\n\t\tv_atime = verifier[1]&0x7fffffff;\n\t}\n\t\n\tif (dchild->d_inode) {\n\t\terr = 0;\n\n\t\tswitch (createmode) {\n\t\tcase NFS3_CREATE_UNCHECKED:\n\t\t\tif (! d_is_reg(dchild))\n\t\t\t\tgoto out;\n\t\t\telse if (truncp) {\n\t\t\t\t/* in nfsv4, we need to treat this case a little\n\t\t\t\t * differently.  we don't want to truncate the\n\t\t\t\t * file now; this would be wrong if the OPEN\n\t\t\t\t * fails for some other reason.  furthermore,\n\t\t\t\t * if the size is nonzero, we should ignore it\n\t\t\t\t * according to spec!\n\t\t\t\t */\n\t\t\t\t*truncp = (iap->ia_valid & ATTR_SIZE) && !iap->ia_size;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tiap->ia_valid &= ATTR_SIZE;\n\t\t\t\tgoto set_attr;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFS3_CREATE_EXCLUSIVE:\n\t\t\tif (   dchild->d_inode->i_mtime.tv_sec == v_mtime\n\t\t\t    && dchild->d_inode->i_atime.tv_sec == v_atime\n\t\t\t    && dchild->d_inode->i_size  == 0 ) {\n\t\t\t\tif (created)\n\t\t\t\t\t*created = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase NFS4_CREATE_EXCLUSIVE4_1:\n\t\t\tif (   dchild->d_inode->i_mtime.tv_sec == v_mtime\n\t\t\t    && dchild->d_inode->i_atime.tv_sec == v_atime\n\t\t\t    && dchild->d_inode->i_size  == 0 ) {\n\t\t\t\tif (created)\n\t\t\t\t\t*created = 1;\n\t\t\t\tgoto set_attr;\n\t\t\t}\n\t\t\t /* fallthru */\n\t\tcase NFS3_CREATE_GUARDED:\n\t\t\terr = nfserr_exist;\n\t\t}\n\t\tfh_drop_write(fhp);\n\t\tgoto out;\n\t}\n\n\thost_err = vfs_create(dirp, dchild, iap->ia_mode, true);\n\tif (host_err < 0) {\n\t\tfh_drop_write(fhp);\n\t\tgoto out_nfserr;\n\t}\n\tif (created)\n\t\t*created = 1;\n\n\tnfsd_check_ignore_resizing(iap);\n\n\tif (nfsd_create_is_exclusive(createmode)) {\n\t\t/* Cram the verifier into atime/mtime */\n\t\tiap->ia_valid = ATTR_MTIME|ATTR_ATIME\n\t\t\t| ATTR_MTIME_SET|ATTR_ATIME_SET;\n\t\t/* XXX someone who knows this better please fix it for nsec */ \n\t\tiap->ia_mtime.tv_sec = v_mtime;\n\t\tiap->ia_atime.tv_sec = v_atime;\n\t\tiap->ia_mtime.tv_nsec = 0;\n\t\tiap->ia_atime.tv_nsec = 0;\n\t}\n\n set_attr:\n\terr = nfsd_create_setattr(rqstp, resfhp, iap);\n\n\t/*\n\t * nfsd_create_setattr already committed the child\n\t * (and possibly also the parent).\n\t */\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\n\n\t/*\n\t * Update the filehandle to get the new inode info.\n\t */\n\tif (!err)\n\t\terr = fh_update(resfhp);\n\n out:\n\tfh_unlock(fhp);\n\tif (dchild && !IS_ERR(dchild))\n\t\tdput(dchild);\n\tfh_drop_write(fhp);\n \treturn err;\n \n out_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\ndo_nfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tchar *fname, int flen, struct iattr *iap,\n\t\tstruct svc_fh *resfhp, int createmode, u32 *verifier,\n\t        bool *truncp, bool *created)\n{\n\tstruct dentry\t*dentry, *dchild = NULL;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\t__u32\t\tv_mtime=0, v_atime=0;\n\n\terr = nfserr_perm;\n\tif (!flen)\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(fname, flen))\n\t\tgoto out;\n\tif (!(iap->ia_valid & ATTR_MODE))\n\t\tiap->ia_mode = 0;\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_EXEC);\n\tif (err)\n\t\tgoto out;\n\n\tdentry = fhp->fh_dentry;\n\tdirp = dentry->d_inode;\n\n\t/* Get all the sanity checks out of the way before\n\t * we lock the parent. */\n\terr = nfserr_notdir;\n\tif (!dirp->i_op->lookup)\n\t\tgoto out;\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\tgoto out_nfserr;\n\n\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\n\t/*\n\t * Compose the response file handle.\n\t */\n\tdchild = lookup_one_len(fname, dentry, flen);\n\thost_err = PTR_ERR(dchild);\n\tif (IS_ERR(dchild))\n\t\tgoto out_nfserr;\n\n\t/* If file doesn't exist, check for permissions to create one */\n\tif (!dchild->d_inode) {\n\t\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = fh_compose(resfhp, fhp->fh_export, dchild, fhp);\n\tif (err)\n\t\tgoto out;\n\n\tif (nfsd_create_is_exclusive(createmode)) {\n\t\t/* solaris7 gets confused (bugid 4218508) if these have\n\t\t * the high bit set, so just clear the high bits. If this is\n\t\t * ever changed to use different attrs for storing the\n\t\t * verifier, then do_open_lookup() will also need to be fixed\n\t\t * accordingly.\n\t\t */\n\t\tv_mtime = verifier[0]&0x7fffffff;\n\t\tv_atime = verifier[1]&0x7fffffff;\n\t}\n\t\n\tif (dchild->d_inode) {\n\t\terr = 0;\n\n\t\tswitch (createmode) {\n\t\tcase NFS3_CREATE_UNCHECKED:\n\t\t\tif (! d_is_reg(dchild))\n\t\t\t\tgoto out;\n\t\t\telse if (truncp) {\n\t\t\t\t/* in nfsv4, we need to treat this case a little\n\t\t\t\t * differently.  we don't want to truncate the\n\t\t\t\t * file now; this would be wrong if the OPEN\n\t\t\t\t * fails for some other reason.  furthermore,\n\t\t\t\t * if the size is nonzero, we should ignore it\n\t\t\t\t * according to spec!\n\t\t\t\t */\n\t\t\t\t*truncp = (iap->ia_valid & ATTR_SIZE) && !iap->ia_size;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tiap->ia_valid &= ATTR_SIZE;\n\t\t\t\tgoto set_attr;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFS3_CREATE_EXCLUSIVE:\n\t\t\tif (   dchild->d_inode->i_mtime.tv_sec == v_mtime\n\t\t\t    && dchild->d_inode->i_atime.tv_sec == v_atime\n\t\t\t    && dchild->d_inode->i_size  == 0 ) {\n\t\t\t\tif (created)\n\t\t\t\t\t*created = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase NFS4_CREATE_EXCLUSIVE4_1:\n\t\t\tif (   dchild->d_inode->i_mtime.tv_sec == v_mtime\n\t\t\t    && dchild->d_inode->i_atime.tv_sec == v_atime\n\t\t\t    && dchild->d_inode->i_size  == 0 ) {\n\t\t\t\tif (created)\n\t\t\t\t\t*created = 1;\n\t\t\t\tgoto set_attr;\n\t\t\t}\n\t\t\t /* fallthru */\n\t\tcase NFS3_CREATE_GUARDED:\n\t\t\terr = nfserr_exist;\n\t\t}\n\t\tfh_drop_write(fhp);\n\t\tgoto out;\n\t}\n\n\thost_err = vfs_create(dirp, dchild, iap->ia_mode, true);\n\tif (host_err < 0) {\n\t\tfh_drop_write(fhp);\n\t\tgoto out_nfserr;\n\t}\n\tif (created)\n\t\t*created = 1;\n\n\tnfsd_check_ignore_resizing(iap);\n\n\tif (nfsd_create_is_exclusive(createmode)) {\n\t\t/* Cram the verifier into atime/mtime */\n\t\tiap->ia_valid = ATTR_MTIME|ATTR_ATIME\n\t\t\t| ATTR_MTIME_SET|ATTR_ATIME_SET;\n\t\t/* XXX someone who knows this better please fix it for nsec */ \n\t\tiap->ia_mtime.tv_sec = v_mtime;\n\t\tiap->ia_atime.tv_sec = v_atime;\n\t\tiap->ia_mtime.tv_nsec = 0;\n\t\tiap->ia_atime.tv_nsec = 0;\n\t}\n\n set_attr:\n\terr = nfsd_create_setattr(rqstp, resfhp, iap);\n\n\t/*\n\t * nfsd_create_setattr already committed the child\n\t * (and possibly also the parent).\n\t */\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\n\n\t/*\n\t * Update the filehandle to get the new inode info.\n\t */\n\tif (!err)\n\t\terr = fh_update(resfhp);\n\n out:\n\tfh_unlock(fhp);\n\tif (dchild && !IS_ERR(dchild))\n\t\tdput(dchild);\n\tfh_drop_write(fhp);\n \treturn err;\n \n out_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_init",
          "args": [
            "*resfh",
            "NFS4_FHSIZE"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "fh_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "182-188",
          "snippet": "static __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct svc_fh)",
            "GFP_KERNEL"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\ndo_open_lookup(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_open *open, struct svc_fh **resfh)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tint accmode;\n\t__be32 status;\n\n\t*resfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);\n\tif (!*resfh)\n\t\treturn nfserr_jukebox;\n\tfh_init(*resfh, NFS4_FHSIZE);\n\topen->op_truncate = 0;\n\n\tif (open->op_create) {\n\t\t/* FIXME: check session persistence and pnfs flags.\n\t\t * The nfsv4.1 spec requires the following semantics:\n\t\t *\n\t\t * Persistent   | pNFS   | Server REQUIRED | Client Allowed\n\t\t * Reply Cache  | server |                 |\n\t\t * -------------+--------+-----------------+--------------------\n\t\t * no           | no     | EXCLUSIVE4_1    | EXCLUSIVE4_1\n\t\t *              |        |                 | (SHOULD)\n\t\t *              |        | and EXCLUSIVE4  | or EXCLUSIVE4\n\t\t *              |        |                 | (SHOULD NOT)\n\t\t * no           | yes    | EXCLUSIVE4_1    | EXCLUSIVE4_1\n\t\t * yes          | no     | GUARDED4        | GUARDED4\n\t\t * yes          | yes    | GUARDED4        | GUARDED4\n\t\t */\n\n\t\t/*\n\t\t * Note: create modes (UNCHECKED,GUARDED...) are the same\n\t\t * in NFSv4 as in v3 except EXCLUSIVE4_1.\n\t\t */\n\t\tstatus = do_nfsd_create(rqstp, current_fh, open->op_fname.data,\n\t\t\t\t\topen->op_fname.len, &open->op_iattr,\n\t\t\t\t\t*resfh, open->op_createmode,\n\t\t\t\t\t(u32 *)open->op_verf.data,\n\t\t\t\t\t&open->op_truncate, &open->op_created);\n\n\t\tif (!status && open->op_label.len)\n\t\t\tnfsd4_security_inode_setsecctx(*resfh, &open->op_label, open->op_bmval);\n\n\t\t/*\n\t\t * Following rfc 3530 14.2.16, use the returned bitmask\n\t\t * to indicate which attributes we used to store the\n\t\t * verifier:\n\t\t */\n\t\tif (open->op_createmode == NFS4_CREATE_EXCLUSIVE && status == 0)\n\t\t\topen->op_bmval[1] = (FATTR4_WORD1_TIME_ACCESS |\n\t\t\t\t\t\t\tFATTR4_WORD1_TIME_MODIFY);\n\t} else\n\t\t/*\n\t\t * Note this may exit with the parent still locked.\n\t\t * We will hold the lock until nfsd4_open's final\n\t\t * lookup, to prevent renames or unlinks until we've had\n\t\t * a chance to an acquire a delegation if appropriate.\n\t\t */\n\t\tstatus = nfsd_lookup(rqstp, current_fh,\n\t\t\t\t     open->op_fname.data, open->op_fname.len, *resfh);\n\tif (status)\n\t\tgoto out;\n\tstatus = nfsd_check_obj_isreg(*resfh);\n\tif (status)\n\t\tgoto out;\n\n\tif (is_create_with_attrs(open) && open->op_acl != NULL)\n\t\tdo_set_nfs4_acl(rqstp, *resfh, open->op_acl, open->op_bmval);\n\n\tnfsd4_set_open_owner_reply_cache(cstate, open, *resfh);\n\taccmode = NFSD_MAY_NOP;\n\tif (open->op_created ||\n\t\t\topen->op_claim_type == NFS4_OPEN_CLAIM_DELEGATE_CUR)\n\t\taccmode |= NFSD_MAY_OWNER_OVERRIDE;\n\tstatus = do_open_permission(rqstp, *resfh, open, accmode);\n\tset_change_info(&open->op_cinfo, current_fh);\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_set_open_owner_reply_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "228-234",
    "snippet": "static void nfsd4_set_open_owner_reply_cache(struct nfsd4_compound_state *cstate, struct nfsd4_open *open, struct svc_fh *resfh)\n{\n\tif (nfsd4_has_session(cstate))\n\t\treturn;\n\tfh_copy_shallow(&open->op_openowner->oo_owner.so_replay.rp_openfh,\n\t\t\t&resfh->fh_handle);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_copy_shallow",
          "args": [
            "&open->op_openowner->oo_owner.so_replay.rp_openfh",
            "&resfh->fh_handle"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "fh_copy_shallow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "175-180",
          "snippet": "static inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "cstate"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/xdr4.h",
          "lines": "72-75",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic void nfsd4_set_open_owner_reply_cache(struct nfsd4_compound_state *cstate, struct nfsd4_open *open, struct svc_fh *resfh)\n{\n\tif (nfsd4_has_session(cstate))\n\t\treturn;\n\tfh_copy_shallow(&open->op_openowner->oo_owner.so_replay.rp_openfh,\n\t\t\t&resfh->fh_handle);\n}"
  },
  {
    "function_name": "nfsd_check_obj_isreg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "210-226",
    "snippet": "static __be32 nfsd_check_obj_isreg(struct svc_fh *fh)\n{\n\tumode_t mode = fh->fh_dentry->d_inode->i_mode;\n\n\tif (S_ISREG(mode))\n\t\treturn nfs_ok;\n\tif (S_ISDIR(mode))\n\t\treturn nfserr_isdir;\n\t/*\n\t * Using err_symlink as our catch-all case may look odd; but\n\t * there's no other obvious error for this case in 4.0, and we\n\t * happen to know that it will cause the linux v4 client to do\n\t * the right thing on attempts to open something other than a\n\t * regular file.\n\t */\n\treturn nfserr_symlink;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd_check_obj_isreg(struct svc_fh *fh)\n{\n\tumode_t mode = fh->fh_dentry->d_inode->i_mode;\n\n\tif (S_ISREG(mode))\n\t\treturn nfs_ok;\n\tif (S_ISDIR(mode))\n\t\treturn nfserr_isdir;\n\t/*\n\t * Using err_symlink as our catch-all case may look odd; but\n\t * there's no other obvious error for this case in 4.0, and we\n\t * happen to know that it will cause the linux v4 client to do\n\t * the right thing on attempts to open something other than a\n\t * regular file.\n\t */\n\treturn nfserr_symlink;\n}"
  },
  {
    "function_name": "do_open_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "187-208",
    "snippet": "static __be32\ndo_open_permission(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_open *open, int accmode)\n{\n\t__be32 status;\n\n\tif (open->op_truncate &&\n\t\t!(open->op_share_access & NFS4_SHARE_ACCESS_WRITE))\n\t\treturn nfserr_inval;\n\n\taccmode |= NFSD_MAY_READ_IF_EXEC;\n\n\tif (open->op_share_access & NFS4_SHARE_ACCESS_READ)\n\t\taccmode |= NFSD_MAY_READ;\n\tif (open->op_share_access & NFS4_SHARE_ACCESS_WRITE)\n\t\taccmode |= (NFSD_MAY_WRITE | NFSD_MAY_TRUNC);\n\tif (open->op_share_deny & NFS4_SHARE_DENY_READ)\n\t\taccmode |= NFSD_MAY_WRITE;\n\n\tstatus = fh_verify(rqstp, current_fh, S_IFREG, accmode);\n\n\treturn status;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "current_fh",
            "S_IFREG",
            "accmode"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\ndo_open_permission(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_open *open, int accmode)\n{\n\t__be32 status;\n\n\tif (open->op_truncate &&\n\t\t!(open->op_share_access & NFS4_SHARE_ACCESS_WRITE))\n\t\treturn nfserr_inval;\n\n\taccmode |= NFSD_MAY_READ_IF_EXEC;\n\n\tif (open->op_share_access & NFS4_SHARE_ACCESS_READ)\n\t\taccmode |= NFSD_MAY_READ;\n\tif (open->op_share_access & NFS4_SHARE_ACCESS_WRITE)\n\t\taccmode |= (NFSD_MAY_WRITE | NFSD_MAY_TRUNC);\n\tif (open->op_share_deny & NFS4_SHARE_DENY_READ)\n\t\taccmode |= NFSD_MAY_WRITE;\n\n\tstatus = fh_verify(rqstp, current_fh, S_IFREG, accmode);\n\n\treturn status;\n}"
  },
  {
    "function_name": "fh_dup2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "177-185",
    "snippet": "static inline void\nfh_dup2(struct svc_fh *dst, struct svc_fh *src)\n{\n\tfh_put(dst);\n\tdget(src->fh_dentry);\n\tif (src->fh_export)\n\t\texp_get(src->fh_export);\n\t*dst = *src;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp_get",
          "args": [
            "src->fh_export"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "exp_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.h",
          "lines": "106-110",
          "snippet": "static inline struct svc_export *exp_get(struct svc_export *exp)\n{\n\tcache_get(&exp->h);\n\treturn exp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline struct svc_export *exp_get(struct svc_export *exp)\n{\n\tcache_get(&exp->h);\n\treturn exp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "src->fh_dentry"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "dst"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "625-645",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic inline void\nfh_dup2(struct svc_fh *dst, struct svc_fh *src)\n{\n\tfh_put(dst);\n\tdget(src->fh_dentry);\n\tif (src->fh_export)\n\t\texp_get(src->fh_export);\n\t*dst = *src;\n}"
  },
  {
    "function_name": "do_set_nfs4_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "161-175",
    "snippet": "static void\ndo_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl, u32 *bmval)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_set_nfs4_acl(rqstp, fhp, acl);\n\tif (status)\n\t\t/*\n\t\t * We should probably fail the whole open at this point,\n\t\t * but we've already created the file, so it's too late;\n\t\t * So this seems the least of evils:\n\t\t */\n\t\tbmval[0] &= ~FATTR4_WORD0_ACL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_set_nfs4_acl",
          "args": [
            "rqstp",
            "fhp",
            "acl"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_set_nfs4_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4acl.c",
          "lines": "814-862",
          "snippet": "__be32\nnfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl)\n{\n\t__be32 error;\n\tint host_error;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\n\t/* Get inode */\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);\n\tif (error)\n\t\treturn error;\n\n\tdentry = fhp->fh_dentry;\n\tinode = dentry->d_inode;\n\n\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n\t\treturn nfserr_attrnotsupp;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tflags = NFS4_ACL_DIR;\n\n\thost_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);\n\tif (host_error == -EINVAL)\n\t\treturn nfserr_attrnotsupp;\n\tif (host_error < 0)\n\t\tgoto out_nfserr;\n\n\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);\n\tif (host_error < 0)\n\t\tgoto out_release;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\thost_error = inode->i_op->set_acl(inode, dpacl,\n\t\t\t\t\t\t  ACL_TYPE_DEFAULT);\n\t}\n\nout_release:\n\tposix_acl_release(pacl);\n\tposix_acl_release(dpacl);\nout_nfserr:\n\tif (host_error == -EOPNOTSUPP)\n\t\treturn nfserr_attrnotsupp;\n\telse\n\t\treturn nfserrno(host_error);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define NFS4_ACL_DIR\t\t0x02"
          ],
          "globals_used": [
            "static void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n\n#define NFS4_ACL_DIR\t\t0x02\n\nstatic void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);\n\n__be32\nnfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl)\n{\n\t__be32 error;\n\tint host_error;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\n\t/* Get inode */\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);\n\tif (error)\n\t\treturn error;\n\n\tdentry = fhp->fh_dentry;\n\tinode = dentry->d_inode;\n\n\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n\t\treturn nfserr_attrnotsupp;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tflags = NFS4_ACL_DIR;\n\n\thost_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);\n\tif (host_error == -EINVAL)\n\t\treturn nfserr_attrnotsupp;\n\tif (host_error < 0)\n\t\tgoto out_nfserr;\n\n\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);\n\tif (host_error < 0)\n\t\tgoto out_release;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\thost_error = inode->i_op->set_acl(inode, dpacl,\n\t\t\t\t\t\t  ACL_TYPE_DEFAULT);\n\t}\n\nout_release:\n\tposix_acl_release(pacl);\n\tposix_acl_release(dpacl);\nout_nfserr:\n\tif (host_error == -EOPNOTSUPP)\n\t\treturn nfserr_attrnotsupp;\n\telse\n\t\treturn nfserrno(host_error);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic void\ndo_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl, u32 *bmval)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_set_nfs4_acl(rqstp, fhp, acl);\n\tif (status)\n\t\t/*\n\t\t * We should probably fail the whole open at this point,\n\t\t * but we've already created the file, so it's too late;\n\t\t * So this seems the least of evils:\n\t\t */\n\t\tbmval[0] &= ~FATTR4_WORD0_ACL;\n}"
  },
  {
    "function_name": "is_create_with_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "148-155",
    "snippet": "static int\nis_create_with_attrs(struct nfsd4_open *open)\n{\n\treturn open->op_create == NFS4_OPEN_CREATE\n\t\t&& (open->op_createmode == NFS4_CREATE_UNCHECKED\n\t\t    || open->op_createmode == NFS4_CREATE_GUARDED\n\t\t    || open->op_createmode == NFS4_CREATE_EXCLUSIVE4_1);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic int\nis_create_with_attrs(struct nfsd4_open *open)\n{\n\treturn open->op_create == NFS4_OPEN_CREATE\n\t\t&& (open->op_createmode == NFS4_CREATE_UNCHECKED\n\t\t    || open->op_createmode == NFS4_CREATE_GUARDED\n\t\t    || open->op_createmode == NFS4_CREATE_EXCLUSIVE4_1);\n}"
  },
  {
    "function_name": "nfsd4_check_open_attributes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "129-146",
    "snippet": "static __be32\nnfsd4_check_open_attributes(struct svc_rqst *rqstp,\n\tstruct nfsd4_compound_state *cstate, struct nfsd4_open *open)\n{\n\t__be32 status = nfs_ok;\n\n\tif (open->op_create == NFS4_OPEN_CREATE) {\n\t\tif (open->op_createmode == NFS4_CREATE_UNCHECKED\n\t\t    || open->op_createmode == NFS4_CREATE_GUARDED)\n\t\t\tstatus = check_attr_support(rqstp, cstate,\n\t\t\t\t\topen->op_bmval, nfsd_attrmask);\n\t\telse if (open->op_createmode == NFS4_CREATE_EXCLUSIVE4_1)\n\t\t\tstatus = check_attr_support(rqstp, cstate,\n\t\t\t\t\topen->op_bmval, nfsd41_ex_attrmask);\n\t}\n\n\treturn status;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 nfsd_attrmask[] = {\n\tNFSD_WRITEABLE_ATTRS_WORD0,\n\tNFSD_WRITEABLE_ATTRS_WORD1,\n\tNFSD_WRITEABLE_ATTRS_WORD2\n};",
      "static u32 nfsd41_ex_attrmask[] = {\n\tNFSD_SUPPATTR_EXCLCREAT_WORD0,\n\tNFSD_SUPPATTR_EXCLCREAT_WORD1,\n\tNFSD_SUPPATTR_EXCLCREAT_WORD2\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_attr_support",
          "args": [
            "rqstp",
            "cstate",
            "open->op_bmval",
            "nfsd41_ex_attrmask"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "check_attr_support",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "93-127",
          "snippet": "static __be32\ncheck_attr_support(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   u32 *bmval, u32 *writable)\n{\n\tstruct dentry *dentry = cstate->current_fh.fh_dentry;\n\n\t/*\n\t * Check about attributes are supported by the NFSv4 server or not.\n\t * According to spec, unsupported attributes return ERR_ATTRNOTSUPP.\n\t */\n\tif ((bmval[0] & ~nfsd_suppattrs0(cstate->minorversion)) ||\n\t    (bmval[1] & ~nfsd_suppattrs1(cstate->minorversion)) ||\n\t    (bmval[2] & ~nfsd_suppattrs2(cstate->minorversion)))\n\t\treturn nfserr_attrnotsupp;\n\n\t/*\n\t * Check FATTR4_WORD0_ACL can be supported\n\t * in current environment or not.\n\t */\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tif (!IS_POSIXACL(dentry->d_inode))\n\t\t\treturn nfserr_attrnotsupp;\n\t}\n\n\t/*\n\t * According to spec, read-only attributes return ERR_INVAL.\n\t */\n\tif (writable) {\n\t\tif ((bmval[0] & ~writable[0]) || (bmval[1] & ~writable[1]) ||\n\t\t    (bmval[2] & ~writable[2]))\n\t\t\treturn nfserr_inval;\n\t}\n\n\treturn nfs_ok;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\ncheck_attr_support(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   u32 *bmval, u32 *writable)\n{\n\tstruct dentry *dentry = cstate->current_fh.fh_dentry;\n\n\t/*\n\t * Check about attributes are supported by the NFSv4 server or not.\n\t * According to spec, unsupported attributes return ERR_ATTRNOTSUPP.\n\t */\n\tif ((bmval[0] & ~nfsd_suppattrs0(cstate->minorversion)) ||\n\t    (bmval[1] & ~nfsd_suppattrs1(cstate->minorversion)) ||\n\t    (bmval[2] & ~nfsd_suppattrs2(cstate->minorversion)))\n\t\treturn nfserr_attrnotsupp;\n\n\t/*\n\t * Check FATTR4_WORD0_ACL can be supported\n\t * in current environment or not.\n\t */\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tif (!IS_POSIXACL(dentry->d_inode))\n\t\t\treturn nfserr_attrnotsupp;\n\t}\n\n\t/*\n\t * According to spec, read-only attributes return ERR_INVAL.\n\t */\n\tif (writable) {\n\t\tif ((bmval[0] & ~writable[0]) || (bmval[1] & ~writable[1]) ||\n\t\t    (bmval[2] & ~writable[2]))\n\t\t\treturn nfserr_inval;\n\t}\n\n\treturn nfs_ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic u32 nfsd_attrmask[] = {\n\tNFSD_WRITEABLE_ATTRS_WORD0,\n\tNFSD_WRITEABLE_ATTRS_WORD1,\n\tNFSD_WRITEABLE_ATTRS_WORD2\n};\nstatic u32 nfsd41_ex_attrmask[] = {\n\tNFSD_SUPPATTR_EXCLCREAT_WORD0,\n\tNFSD_SUPPATTR_EXCLCREAT_WORD1,\n\tNFSD_SUPPATTR_EXCLCREAT_WORD2\n};\n\nstatic __be32\nnfsd4_check_open_attributes(struct svc_rqst *rqstp,\n\tstruct nfsd4_compound_state *cstate, struct nfsd4_open *open)\n{\n\t__be32 status = nfs_ok;\n\n\tif (open->op_create == NFS4_OPEN_CREATE) {\n\t\tif (open->op_createmode == NFS4_CREATE_UNCHECKED\n\t\t    || open->op_createmode == NFS4_CREATE_GUARDED)\n\t\t\tstatus = check_attr_support(rqstp, cstate,\n\t\t\t\t\topen->op_bmval, nfsd_attrmask);\n\t\telse if (open->op_createmode == NFS4_CREATE_EXCLUSIVE4_1)\n\t\t\tstatus = check_attr_support(rqstp, cstate,\n\t\t\t\t\topen->op_bmval, nfsd41_ex_attrmask);\n\t}\n\n\treturn status;\n}"
  },
  {
    "function_name": "check_attr_support",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "93-127",
    "snippet": "static __be32\ncheck_attr_support(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   u32 *bmval, u32 *writable)\n{\n\tstruct dentry *dentry = cstate->current_fh.fh_dentry;\n\n\t/*\n\t * Check about attributes are supported by the NFSv4 server or not.\n\t * According to spec, unsupported attributes return ERR_ATTRNOTSUPP.\n\t */\n\tif ((bmval[0] & ~nfsd_suppattrs0(cstate->minorversion)) ||\n\t    (bmval[1] & ~nfsd_suppattrs1(cstate->minorversion)) ||\n\t    (bmval[2] & ~nfsd_suppattrs2(cstate->minorversion)))\n\t\treturn nfserr_attrnotsupp;\n\n\t/*\n\t * Check FATTR4_WORD0_ACL can be supported\n\t * in current environment or not.\n\t */\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tif (!IS_POSIXACL(dentry->d_inode))\n\t\t\treturn nfserr_attrnotsupp;\n\t}\n\n\t/*\n\t * According to spec, read-only attributes return ERR_INVAL.\n\t */\n\tif (writable) {\n\t\tif ((bmval[0] & ~writable[0]) || (bmval[1] & ~writable[1]) ||\n\t\t    (bmval[2] & ~writable[2]))\n\t\t\treturn nfserr_inval;\n\t}\n\n\treturn nfs_ok;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_POSIXACL",
          "args": [
            "dentry->d_inode"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_suppattrs2",
          "args": [
            "cstate->minorversion"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_suppattrs2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsd.h",
          "lines": "371-378",
          "snippet": "static inline u32 nfsd_suppattrs2(u32 minorversion)\n{\n\tswitch (minorversion) {\n\tdefault: return NFSD4_2_SUPPORTED_ATTRS_WORD2;\n\tcase 1:  return NFSD4_1_SUPPORTED_ATTRS_WORD2;\n\tcase 0:  return NFSD4_SUPPORTED_ATTRS_WORD2;\n\t}\n}",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFSD4_2_SUPPORTED_ATTRS_WORD2 \\\n\t(NFSD4_1_SUPPORTED_ATTRS_WORD2 | \\\n\tNFSD4_2_SECURITY_ATTRS)",
            "#define NFSD4_1_SUPPORTED_ATTRS_WORD2 \\\n\t(NFSD4_SUPPORTED_ATTRS_WORD2\t| PNFSD_SUPPORTED_ATTRS_WORD2 | \\\n\t FATTR4_WORD2_SUPPATTR_EXCLCREAT)",
            "#define NFSD4_SUPPORTED_ATTRS_WORD2 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\n#define NFSD4_2_SUPPORTED_ATTRS_WORD2 \\\n\t(NFSD4_1_SUPPORTED_ATTRS_WORD2 | \\\n\tNFSD4_2_SECURITY_ATTRS)\n#define NFSD4_1_SUPPORTED_ATTRS_WORD2 \\\n\t(NFSD4_SUPPORTED_ATTRS_WORD2\t| PNFSD_SUPPORTED_ATTRS_WORD2 | \\\n\t FATTR4_WORD2_SUPPATTR_EXCLCREAT)\n#define NFSD4_SUPPORTED_ATTRS_WORD2 0\n\nstatic inline u32 nfsd_suppattrs2(u32 minorversion)\n{\n\tswitch (minorversion) {\n\tdefault: return NFSD4_2_SUPPORTED_ATTRS_WORD2;\n\tcase 1:  return NFSD4_1_SUPPORTED_ATTRS_WORD2;\n\tcase 0:  return NFSD4_SUPPORTED_ATTRS_WORD2;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_suppattrs1",
          "args": [
            "cstate->minorversion"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_suppattrs1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsd.h",
          "lines": "365-369",
          "snippet": "static inline u32 nfsd_suppattrs1(u32 minorversion)\n{\n\treturn minorversion ? NFSD4_1_SUPPORTED_ATTRS_WORD1\n\t\t\t    : NFSD4_SUPPORTED_ATTRS_WORD1;\n}",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFSD4_1_SUPPORTED_ATTRS_WORD1 \\\n\t(NFSD4_SUPPORTED_ATTRS_WORD1\t| PNFSD_SUPPORTED_ATTRS_WORD1)",
            "#define NFSD4_SUPPORTED_ATTRS_WORD1                                                         \\\n(FATTR4_WORD1_MODE              | FATTR4_WORD1_NO_TRUNC     | FATTR4_WORD1_NUMLINKS         \\\n | FATTR4_WORD1_OWNER\t        | FATTR4_WORD1_OWNER_GROUP  | FATTR4_WORD1_RAWDEV           \\\n | FATTR4_WORD1_SPACE_AVAIL     | FATTR4_WORD1_SPACE_FREE   | FATTR4_WORD1_SPACE_TOTAL      \\\n | FATTR4_WORD1_SPACE_USED      | FATTR4_WORD1_TIME_ACCESS  | FATTR4_WORD1_TIME_ACCESS_SET  \\\n | FATTR4_WORD1_TIME_DELTA   | FATTR4_WORD1_TIME_METADATA    \\\n | FATTR4_WORD1_TIME_MODIFY     | FATTR4_WORD1_TIME_MODIFY_SET | FATTR4_WORD1_MOUNTED_ON_FILEID)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\n#define NFSD4_1_SUPPORTED_ATTRS_WORD1 \\\n\t(NFSD4_SUPPORTED_ATTRS_WORD1\t| PNFSD_SUPPORTED_ATTRS_WORD1)\n#define NFSD4_SUPPORTED_ATTRS_WORD1                                                         \\\n(FATTR4_WORD1_MODE              | FATTR4_WORD1_NO_TRUNC     | FATTR4_WORD1_NUMLINKS         \\\n | FATTR4_WORD1_OWNER\t        | FATTR4_WORD1_OWNER_GROUP  | FATTR4_WORD1_RAWDEV           \\\n | FATTR4_WORD1_SPACE_AVAIL     | FATTR4_WORD1_SPACE_FREE   | FATTR4_WORD1_SPACE_TOTAL      \\\n | FATTR4_WORD1_SPACE_USED      | FATTR4_WORD1_TIME_ACCESS  | FATTR4_WORD1_TIME_ACCESS_SET  \\\n | FATTR4_WORD1_TIME_DELTA   | FATTR4_WORD1_TIME_METADATA    \\\n | FATTR4_WORD1_TIME_MODIFY     | FATTR4_WORD1_TIME_MODIFY_SET | FATTR4_WORD1_MOUNTED_ON_FILEID)\n\nstatic inline u32 nfsd_suppattrs1(u32 minorversion)\n{\n\treturn minorversion ? NFSD4_1_SUPPORTED_ATTRS_WORD1\n\t\t\t    : NFSD4_SUPPORTED_ATTRS_WORD1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_suppattrs0",
          "args": [
            "cstate->minorversion"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_suppattrs0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsd.h",
          "lines": "359-363",
          "snippet": "static inline u32 nfsd_suppattrs0(u32 minorversion)\n{\n\treturn minorversion ? NFSD4_1_SUPPORTED_ATTRS_WORD0\n\t\t\t    : NFSD4_SUPPORTED_ATTRS_WORD0;\n}",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFSD4_1_SUPPORTED_ATTRS_WORD0 \\\n\tNFSD4_SUPPORTED_ATTRS_WORD0",
            "#define NFSD4_SUPPORTED_ATTRS_WORD0                                                         \\\n(FATTR4_WORD0_SUPPORTED_ATTRS   | FATTR4_WORD0_TYPE         | FATTR4_WORD0_FH_EXPIRE_TYPE   \\\n | FATTR4_WORD0_CHANGE          | FATTR4_WORD0_SIZE         | FATTR4_WORD0_LINK_SUPPORT     \\\n | FATTR4_WORD0_SYMLINK_SUPPORT | FATTR4_WORD0_NAMED_ATTR   | FATTR4_WORD0_FSID             \\\n | FATTR4_WORD0_UNIQUE_HANDLES  | FATTR4_WORD0_LEASE_TIME   | FATTR4_WORD0_RDATTR_ERROR     \\\n | FATTR4_WORD0_ACLSUPPORT      | FATTR4_WORD0_CANSETTIME   | FATTR4_WORD0_CASE_INSENSITIVE \\\n | FATTR4_WORD0_CASE_PRESERVING | FATTR4_WORD0_CHOWN_RESTRICTED                             \\\n | FATTR4_WORD0_FILEHANDLE      | FATTR4_WORD0_FILEID       | FATTR4_WORD0_FILES_AVAIL      \\\n | FATTR4_WORD0_FILES_FREE      | FATTR4_WORD0_FILES_TOTAL  | FATTR4_WORD0_FS_LOCATIONS | FATTR4_WORD0_HOMOGENEOUS      \\\n | FATTR4_WORD0_MAXFILESIZE     | FATTR4_WORD0_MAXLINK      | FATTR4_WORD0_MAXNAME          \\\n | FATTR4_WORD0_MAXREAD         | FATTR4_WORD0_MAXWRITE     | FATTR4_WORD0_ACL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\n#define NFSD4_1_SUPPORTED_ATTRS_WORD0 \\\n\tNFSD4_SUPPORTED_ATTRS_WORD0\n#define NFSD4_SUPPORTED_ATTRS_WORD0                                                         \\\n(FATTR4_WORD0_SUPPORTED_ATTRS   | FATTR4_WORD0_TYPE         | FATTR4_WORD0_FH_EXPIRE_TYPE   \\\n | FATTR4_WORD0_CHANGE          | FATTR4_WORD0_SIZE         | FATTR4_WORD0_LINK_SUPPORT     \\\n | FATTR4_WORD0_SYMLINK_SUPPORT | FATTR4_WORD0_NAMED_ATTR   | FATTR4_WORD0_FSID             \\\n | FATTR4_WORD0_UNIQUE_HANDLES  | FATTR4_WORD0_LEASE_TIME   | FATTR4_WORD0_RDATTR_ERROR     \\\n | FATTR4_WORD0_ACLSUPPORT      | FATTR4_WORD0_CANSETTIME   | FATTR4_WORD0_CASE_INSENSITIVE \\\n | FATTR4_WORD0_CASE_PRESERVING | FATTR4_WORD0_CHOWN_RESTRICTED                             \\\n | FATTR4_WORD0_FILEHANDLE      | FATTR4_WORD0_FILEID       | FATTR4_WORD0_FILES_AVAIL      \\\n | FATTR4_WORD0_FILES_FREE      | FATTR4_WORD0_FILES_TOTAL  | FATTR4_WORD0_FS_LOCATIONS | FATTR4_WORD0_HOMOGENEOUS      \\\n | FATTR4_WORD0_MAXFILESIZE     | FATTR4_WORD0_MAXLINK      | FATTR4_WORD0_MAXNAME          \\\n | FATTR4_WORD0_MAXREAD         | FATTR4_WORD0_MAXWRITE     | FATTR4_WORD0_ACL)\n\nstatic inline u32 nfsd_suppattrs0(u32 minorversion)\n{\n\treturn minorversion ? NFSD4_1_SUPPORTED_ATTRS_WORD0\n\t\t\t    : NFSD4_SUPPORTED_ATTRS_WORD0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic __be32\ncheck_attr_support(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   u32 *bmval, u32 *writable)\n{\n\tstruct dentry *dentry = cstate->current_fh.fh_dentry;\n\n\t/*\n\t * Check about attributes are supported by the NFSv4 server or not.\n\t * According to spec, unsupported attributes return ERR_ATTRNOTSUPP.\n\t */\n\tif ((bmval[0] & ~nfsd_suppattrs0(cstate->minorversion)) ||\n\t    (bmval[1] & ~nfsd_suppattrs1(cstate->minorversion)) ||\n\t    (bmval[2] & ~nfsd_suppattrs2(cstate->minorversion)))\n\t\treturn nfserr_attrnotsupp;\n\n\t/*\n\t * Check FATTR4_WORD0_ACL can be supported\n\t * in current environment or not.\n\t */\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tif (!IS_POSIXACL(dentry->d_inode))\n\t\t\treturn nfserr_attrnotsupp;\n\t}\n\n\t/*\n\t * According to spec, read-only attributes return ERR_INVAL.\n\t */\n\tif (writable) {\n\t\tif ((bmval[0] & ~writable[0]) || (bmval[1] & ~writable[1]) ||\n\t\t    (bmval[2] & ~writable[2]))\n\t\t\treturn nfserr_inval;\n\t}\n\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_security_inode_setsecctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "74-76",
    "snippet": "static inline void\nnfsd4_security_inode_setsecctx(struct svc_fh *resfh, struct xdr_netobj *label, u32 *bmval)\n{ }",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic inline void\nnfsd4_security_inode_setsecctx(struct svc_fh *resfh, struct xdr_netobj *label, u32 *bmval)\n{ }"
  },
  {
    "function_name": "nfsd4_security_inode_setsecctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
    "lines": "52-72",
    "snippet": "static inline void\nnfsd4_security_inode_setsecctx(struct svc_fh *resfh, struct xdr_netobj *label, u32 *bmval)\n{\n\tstruct inode *inode = resfh->fh_dentry->d_inode;\n\tint status;\n\n\tmutex_lock(&inode->i_mutex);\n\tstatus = security_inode_setsecctx(resfh->fh_dentry,\n\t\tlabel->data, label->len);\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (status)\n\t\t/*\n\t\t * XXX: We should really fail the whole open, but we may\n\t\t * already have created a new file, so it may be too\n\t\t * late.  For now this seems the least of evils:\n\t\t */\n\t\tbmval[2] &= ~FATTR4_WORD2_SECURITY_LABEL;\n\n\treturn;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"trace.h\"",
      "#include \"pnfs.h\"",
      "#include \"acl.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"cache.h\"",
      "#include \"idmap.h\"",
      "#include <linux/slab.h>",
      "#include <linux/falloc.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_inode_setsecctx",
          "args": [
            "resfh->fh_dentry",
            "label->data",
            "label->len"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_security_inode_setsecctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "74-76",
          "snippet": "static inline void\nnfsd4_security_inode_setsecctx(struct svc_fh *resfh, struct xdr_netobj *label, u32 *bmval)\n{ }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic inline void\nnfsd4_security_inode_setsecctx(struct svc_fh *resfh, struct xdr_netobj *label, u32 *bmval)\n{\n\tstruct inode *inode = resfh->fh_dentry->d_inode;\n\tint status;\n\n\tmutex_lock(&inode->i_mutex);\n\tstatus = security_inode_setsecctx(resfh->fh_dentry,\n\t\tlabel->data, label->len);\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (status)\n\t\t/*\n\t\t * XXX: We should really fail the whole open, but we may\n\t\t * already have created a new file, so it may be too\n\t\t * late.  For now this seems the least of evils:\n\t\t */\n\t\tbmval[2] &= ~FATTR4_WORD2_SECURITY_LABEL;\n\n\treturn;\n}"
  }
]