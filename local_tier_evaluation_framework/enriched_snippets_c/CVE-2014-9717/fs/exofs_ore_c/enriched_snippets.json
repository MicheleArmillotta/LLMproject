[
  {
    "function_name": "e_truncate(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "1100-1159",
    "snippet": "t ore_truncate(struct ore_layout *layout, struct ore_components *oc,\n\t\t   u64 size)\n{\n\tstruct ore_io_state *ios;\n\tstruct exofs_trunc_attr {\n\t\tstruct osd_attr attr;\n\t\t__be64 newsize;\n\t} *size_attrs;\n\tstruct _trunc_info ti;\n\tint i, ret;\n\n\tret = ore_get_io_state(layout, oc, &ios);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\t_calc_trunk_info(ios->layout, size, &ti);\n\n\tsize_attrs = kcalloc(ios->oc->numdevs, sizeof(*size_attrs),\n\t\t\t     GFP_KERNEL);\n\tif (unlikely(!size_attrs)) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tios->numdevs = ios->oc->numdevs;\n\n\tfor (i = 0; i < ios->numdevs; ++i) {\n\t\tstruct exofs_trunc_attr *size_attr = &size_attrs[i];\n\t\tu64 obj_size;\n\n\t\tif (i < ti.first_group_dev)\n\t\t\tobj_size = ti.prev_group_obj_off;\n\t\telse if (i >= ti.nex_group_dev)\n\t\t\tobj_size = ti.next_group_obj_off;\n\t\telse if (i < ti.si.dev) /* dev within this group */\n\t\t\tobj_size = ti.si.obj_offset +\n\t\t\t\t      ios->layout->stripe_unit - ti.si.unit_off;\n\t\telse if (i == ti.si.dev)\n\t\t\tobj_size = ti.si.obj_offset;\n\t\telse /* i > ti.dev */\n\t\t\tobj_size = ti.si.obj_offset - ti.si.unit_off;\n\n\t\tsize_attr->newsize = cpu_to_be64(obj_size);\n\t\tsize_attr->attr = g_attr_logical_length;\n\t\tsize_attr->attr.val_ptr = &size_attr->newsize;\n\n\t\tORE_DBGMSG2(\"trunc(0x%llx) obj_offset=0x%llx dev=%d\\n\",\n\t\t\t     _LLU(oc->comps->obj.id), _LLU(obj_size), i);\n\t\tret = _truncate_mirrors(ios, i * ios->layout->mirrors_p1,\n\t\t\t\t\t&size_attr->attr);\n\t\tif (unlikely(ret))\n\t\t\tgoto out;\n\t}\n\tret = ore_io_execute(ios);\n\nout:\n\tkfree(size_attrs);\n\tore_put_io_state(ios);\n\treturn ret;\n}\nE",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "nst struct osd_attr g_attr_logical_length = ATTR_DEF(\n\tOSD_APAGE_OBJECT_INFORMATION, OSD_ATTR_OI_LOGICAL_LENGTH, 8);\nE"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "e_put_io_state(i",
          "args": [
            "s);"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(s",
          "args": [
            "ze_attrs);"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "jffs2_dbg_dump_fragtree(s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/debug.c",
          "lines": "694-700",
          "snippet": "id\n__jffs2_dbg_dump_fragtree(struct jffs2_inode_info *f)\n{\n\tmutex_lock(&f->sem);\n\tjffs2_dbg_dump_fragtree_nolock(f);\n\tmutex_unlock(&f->sem);\n}",
          "includes": [
            "nclude \"debug.h\"\n\n#",
            "nclude \"nodelist.h\"\n#i",
            "nclude <linux/slab.h>\n#i",
            "nclude <linux/mtd/mtd.h>\n#i",
            "nclude <linux/jffs2.h>\n#i",
            "nclude <linux/crc32.h>\n#i",
            "nclude <linux/pagemap.h>\n#i",
            "nclude <linux/types.h>\n#i",
            "nclude <linux/kernel.h>\n#i"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "nclude \"debug.h\"\n\n#\nnclude \"nodelist.h\"\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/jffs2.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/types.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nid\n__jffs2_dbg_dump_fragtree(struct jffs2_inode_info *f)\n{\n\tmutex_lock(&f->sem);\n\tjffs2_dbg_dump_fragtree_nolock(f);\n\tmutex_unlock(&f->sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "e_io_execute(i",
          "args": [
            "s);"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely(r",
          "args": [
            "t))"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "runcate_mirrors(i",
          "args": [
            "s,",
            "* ios->layout->mirrors_p1,",
            "ize_attr->attr);"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E_DBGMSG2(\"",
          "args": [
            "runc(0x%llx) obj_offset=0x%llx dev=%d\\n\",",
            "LU(oc->comps->obj.id),",
            "LU(obj_size),",
            ";"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LU(o",
          "args": [
            "j_size),"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LU(o",
          "args": [
            "->comps->obj.id),"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_be64(o",
          "args": [
            "j_size);"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely(!",
          "args": [
            "ize_attrs))"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(i",
          "args": [
            "s->oc->numdevs,",
            "zeof(*size_attrs),",
            "P_KERNEL);"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alc_trunk_info(i",
          "args": [
            "s->layout,",
            "ze,",
            "i);"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely(r",
          "args": [
            "t))"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_get_io_state(l",
          "args": [
            "yout,",
            ",",
            "os);"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nnst struct osd_attr g_attr_logical_length = ATTR_DEF(\n\tOSD_APAGE_OBJECT_INFORMATION, OSD_ATTR_OI_LOGICAL_LENGTH, 8);\nE;\n\nt ore_truncate(struct ore_layout *layout, struct ore_components *oc,\n\t\t   u64 size)\n{\n\tstruct ore_io_state *ios;\n\tstruct exofs_trunc_attr {\n\t\tstruct osd_attr attr;\n\t\t__be64 newsize;\n\t} *size_attrs;\n\tstruct _trunc_info ti;\n\tint i, ret;\n\n\tret = ore_get_io_state(layout, oc, &ios);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\t_calc_trunk_info(ios->layout, size, &ti);\n\n\tsize_attrs = kcalloc(ios->oc->numdevs, sizeof(*size_attrs),\n\t\t\t     GFP_KERNEL);\n\tif (unlikely(!size_attrs)) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tios->numdevs = ios->oc->numdevs;\n\n\tfor (i = 0; i < ios->numdevs; ++i) {\n\t\tstruct exofs_trunc_attr *size_attr = &size_attrs[i];\n\t\tu64 obj_size;\n\n\t\tif (i < ti.first_group_dev)\n\t\t\tobj_size = ti.prev_group_obj_off;\n\t\telse if (i >= ti.nex_group_dev)\n\t\t\tobj_size = ti.next_group_obj_off;\n\t\telse if (i < ti.si.dev) /* dev within this group */\n\t\t\tobj_size = ti.si.obj_offset +\n\t\t\t\t      ios->layout->stripe_unit - ti.si.unit_off;\n\t\telse if (i == ti.si.dev)\n\t\t\tobj_size = ti.si.obj_offset;\n\t\telse /* i > ti.dev */\n\t\t\tobj_size = ti.si.obj_offset - ti.si.unit_off;\n\n\t\tsize_attr->newsize = cpu_to_be64(obj_size);\n\t\tsize_attr->attr = g_attr_logical_length;\n\t\tsize_attr->attr.val_ptr = &size_attr->newsize;\n\n\t\tORE_DBGMSG2(\"trunc(0x%llx) obj_offset=0x%llx dev=%d\\n\",\n\t\t\t     _LLU(oc->comps->obj.id), _LLU(obj_size), i);\n\t\tret = _truncate_mirrors(ios, i * ios->layout->mirrors_p1,\n\t\t\t\t\t&size_attr->attr);\n\t\tif (unlikely(ret))\n\t\t\tgoto out;\n\t}\n\tret = ore_io_execute(ios);\n\nout:\n\tkfree(size_attrs);\n\tore_put_io_state(ios);\n\treturn ret;\n}\nE"
  },
  {
    "function_name": "alc_trunk_info(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "1086-1098",
    "snippet": "atic void _calc_trunk_info(struct ore_layout *layout, u64 file_offset,\n\t\t\t     struct _trunc_info *ti)\n{\n\tunsigned stripe_unit = layout->stripe_unit;\n\n\tore_calc_stripe_info(layout, file_offset, 0, &ti->si);\n\n\tti->prev_group_obj_off = ti->si.M * stripe_unit;\n\tti->next_group_obj_off = ti->si.M ? (ti->si.M - 1) * stripe_unit : 0;\n\n\tti->first_group_dev = ti->si.dev - (ti->si.dev % layout->group_width);\n\tti->nex_group_dev = ti->first_group_dev + layout->group_width;\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "e_calc_stripe_info(l",
          "args": [
            "yout,",
            "le_offset,",
            "i->si);"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\natic void _calc_trunk_info(struct ore_layout *layout, u64 file_offset,\n\t\t\t     struct _trunc_info *ti)\n{\n\tunsigned stripe_unit = layout->stripe_unit;\n\n\tore_calc_stripe_info(layout, file_offset, 0, &ti->si);\n\n\tti->prev_group_obj_off = ti->si.M * stripe_unit;\n\tti->next_group_obj_off = ti->si.M ? (ti->si.M - 1) * stripe_unit : 0;\n\n\tti->first_group_dev = ti->si.dev - (ti->si.dev % layout->group_width);\n\tti->nex_group_dev = ti->first_group_dev + layout->group_width;\n}"
  },
  {
    "function_name": "runcate_mirrors(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "1054-1075",
    "snippet": "atic int _truncate_mirrors(struct ore_io_state *ios, unsigned cur_comp,\n\t\t\t     struct osd_attr *attr)\n{\n\tint last_comp = cur_comp + ios->layout->mirrors_p1;\n\n\tfor (; cur_comp < last_comp; ++cur_comp) {\n\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[cur_comp];\n\t\tstruct osd_request *or;\n\n\t\tor = osd_start_request(_ios_od(ios, cur_comp), GFP_KERNEL);\n\t\tif (unlikely(!or)) {\n\t\t\tORE_ERR(\"%s: osd_start_request failed\\n\", __func__);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tper_dev->or = or;\n\n\t\tosd_req_set_attributes(or, _ios_obj(ios, cur_comp));\n\t\tosd_req_add_set_attr_list(or, attr, 1);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_req_add_set_attr_list(o",
          "args": [
            ",",
            "tr,",
            ";"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_req_set_attributes(o",
          "args": [
            ",",
            "os_obj(ios, cur_comp));"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "os_obj(i",
          "args": [
            "s,",
            "r_comp))"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E_ERR(\"",
          "args": [
            "s: osd_start_request failed\\n\",",
            "func__);"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely(!",
          "args": [
            "r))"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_start_request(_",
          "args": [
            "os_od(ios, cur_comp),",
            "P_KERNEL);"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "os_od(i",
          "args": [
            "s,",
            "r_comp),"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\natic int _truncate_mirrors(struct ore_io_state *ios, unsigned cur_comp,\n\t\t\t     struct osd_attr *attr)\n{\n\tint last_comp = cur_comp + ios->layout->mirrors_p1;\n\n\tfor (; cur_comp < last_comp; ++cur_comp) {\n\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[cur_comp];\n\t\tstruct osd_request *or;\n\n\t\tor = osd_start_request(_ios_od(ios, cur_comp), GFP_KERNEL);\n\t\tif (unlikely(!or)) {\n\t\t\tORE_ERR(\"%s: osd_start_request failed\\n\", __func__);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tper_dev->or = or;\n\n\t\tosd_req_set_attributes(or, _ios_obj(ios, cur_comp));\n\t\tosd_req_add_set_attr_list(or, attr, 1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tract_attr_from_ios(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "1032-1051",
    "snippet": "t extract_attr_from_ios(struct ore_io_state *ios, struct osd_attr *attr)\n{\n\tstruct osd_attr cur_attr = {.attr_page = 0}; /* start with zeros */\n\tvoid *iter = NULL;\n\tint nelem;\n\n\tdo {\n\t\tnelem = 1;\n\t\tosd_req_decode_get_attr_list(ios->per_dev[0].or,\n\t\t\t\t\t     &cur_attr, &nelem, &iter);\n\t\tif ((cur_attr.attr_page == attr->attr_page) &&\n\t\t    (cur_attr.attr_id == attr->attr_id)) {\n\t\t\tattr->len = cur_attr.len;\n\t\t\tattr->val_ptr = cur_attr.val_ptr;\n\t\t\treturn 0;\n\t\t}\n\t} while (iter);\n\n\treturn -EIO;\n}\nE",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_req_decode_get_attr_list(i",
          "args": [
            "s->per_dev[0].or,",
            "ur_attr,",
            "elem,",
            "ter);"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nt extract_attr_from_ios(struct ore_io_state *ios, struct osd_attr *attr)\n{\n\tstruct osd_attr cur_attr = {.attr_page = 0}; /* start with zeros */\n\tvoid *iter = NULL;\n\tint nelem;\n\n\tdo {\n\t\tnelem = 1;\n\t\tosd_req_decode_get_attr_list(ios->per_dev[0].or,\n\t\t\t\t\t     &cur_attr, &nelem, &iter);\n\t\tif ((cur_attr.attr_page == attr->attr_page) &&\n\t\t    (cur_attr.attr_id == attr->attr_id)) {\n\t\t\tattr->len = cur_attr.len;\n\t\t\tattr->val_ptr = cur_attr.val_ptr;\n\t\t\treturn 0;\n\t\t}\n\t} while (iter);\n\n\treturn -EIO;\n}\nE"
  },
  {
    "function_name": "e_read(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "1012-1029",
    "snippet": "t ore_read(struct ore_io_state *ios)\n{\n\tint i;\n\tint ret;\n\n\tret = _prepare_for_striping(ios);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tfor (i = 0; i < ios->numdevs; i += ios->layout->mirrors_p1) {\n\t\tret = _ore_read_mirror(ios, i);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tret = ore_io_execute(ios);\n\treturn ret;\n}\nE",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "e_io_execute(i",
          "args": [
            "s);"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely(r",
          "args": [
            "t))"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "re_read_mirror(i",
          "args": [
            "s,",
            ";"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely(r",
          "args": [
            "t))"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repare_for_striping(i",
          "args": [
            "s);"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nt ore_read(struct ore_io_state *ios)\n{\n\tint i;\n\tint ret;\n\n\tret = _prepare_for_striping(ios);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tfor (i = 0; i < ios->numdevs; i += ios->layout->mirrors_p1) {\n\t\tret = _ore_read_mirror(ios, i);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tret = ore_io_execute(ios);\n\treturn ret;\n}\nE"
  },
  {
    "function_name": "re_read_mirror(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "958-1010",
    "snippet": "t _ore_read_mirror(struct ore_io_state *ios, unsigned cur_comp)\n{\n\tstruct osd_request *or;\n\tstruct ore_per_dev_state *per_dev = &ios->per_dev[cur_comp];\n\tstruct osd_obj_id *obj = _ios_obj(ios, cur_comp);\n\tunsigned first_dev = (unsigned)obj->id;\n\n\tif (ios->pages && !per_dev->length)\n\t\treturn 0; /* Just an empty slot */\n\n\tfirst_dev = per_dev->dev + first_dev % ios->layout->mirrors_p1;\n\tor = osd_start_request(_ios_od(ios, first_dev), GFP_KERNEL);\n\tif (unlikely(!or)) {\n\t\tORE_ERR(\"%s: osd_start_request failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tper_dev->or = or;\n\n\tif (ios->pages) {\n\t\tif (per_dev->cur_sg) {\n\t\t\t/* finalize the last sg_entry */\n\t\t\t_ore_add_sg_seg(per_dev, 0, false);\n\t\t\tif (unlikely(!per_dev->cur_sg))\n\t\t\t\treturn 0; /* Skip parity only device */\n\n\t\t\tosd_req_read_sg(or, obj, per_dev->bio,\n\t\t\t\t\tper_dev->sglist, per_dev->cur_sg);\n\t\t} else {\n\t\t\t/* The no raid case */\n\t\t\tosd_req_read(or, obj, per_dev->offset,\n\t\t\t\t     per_dev->bio, per_dev->length);\n\t\t}\n\n\t\tORE_DBGMSG(\"read(0x%llx) offset=0x%llx length=0x%llx\"\n\t\t\t     \" dev=%d sg_len=%d\\n\", _LLU(obj->id),\n\t\t\t     _LLU(per_dev->offset), _LLU(per_dev->length),\n\t\t\t     first_dev, per_dev->cur_sg);\n\t} else {\n\t\tBUG_ON(ios->kern_buff);\n\n\t\tosd_req_get_attributes(or, obj);\n\t\tORE_DBGMSG2(\"obj(0x%llx) get_attributes=%d dev=%d\\n\",\n\t\t\t      _LLU(obj->id),\n\t\t\t      ios->in_attr_len, first_dev);\n\t}\n\tif (ios->out_attr)\n\t\tosd_req_add_set_attr_list(or, ios->out_attr, ios->out_attr_len);\n\n\tif (ios->in_attr)\n\t\tosd_req_add_get_attr_list(or, ios->in_attr, ios->in_attr_len);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_req_add_get_attr_list(o",
          "args": [
            ",",
            "s->in_attr,",
            "s->in_attr_len);"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_req_add_set_attr_list(o",
          "args": [
            ",",
            "s->out_attr,",
            "s->out_attr_len);"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E_DBGMSG2(\"",
          "args": [
            "bj(0x%llx) get_attributes=%d dev=%d\\n\",",
            "LU(obj->id),",
            "s->in_attr_len,",
            "rst_dev);"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LU(o",
          "args": [
            "j->id),"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_req_get_attributes(o",
          "args": [
            ",",
            "j);"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_ON(i",
          "args": [
            "s->kern_buff);"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E_DBGMSG(\"",
          "args": [
            "ead(0x%llx) offset=0x%llx length=0x%llx\"\n\t\t\t     \" dev=%d sg_len=%d\\n\",",
            "LU(obj->id),",
            "LU(per_dev->offset),",
            "LU(per_dev->length),",
            "rst_dev,",
            "r_dev->cur_sg);"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LU(p",
          "args": [
            "r_dev->length),"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LU(p",
          "args": [
            "r_dev->offset),"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LU(o",
          "args": [
            "j->id),"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_req_read(o",
          "args": [
            ",",
            "j,",
            "r_dev->offset,",
            "r_dev->bio,",
            "r_dev->length);"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_req_read_sg(o",
          "args": [
            ",",
            "j,",
            "r_dev->bio,",
            "r_dev->sglist,",
            "r_dev->cur_sg);"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely(!",
          "args": [
            "er_dev->cur_sg))"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "re_add_sg_seg(p",
          "args": [
            "r_dev,",
            "lse);"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E_ERR(\"",
          "args": [
            "s: osd_start_request failed\\n\",",
            "func__);"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely(!",
          "args": [
            "r))"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_start_request(_",
          "args": [
            "os_od(ios, first_dev),",
            "P_KERNEL);"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "os_od(i",
          "args": [
            "s,",
            "rst_dev),"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "os_obj(i",
          "args": [
            "s,",
            "r_comp);"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nt _ore_read_mirror(struct ore_io_state *ios, unsigned cur_comp)\n{\n\tstruct osd_request *or;\n\tstruct ore_per_dev_state *per_dev = &ios->per_dev[cur_comp];\n\tstruct osd_obj_id *obj = _ios_obj(ios, cur_comp);\n\tunsigned first_dev = (unsigned)obj->id;\n\n\tif (ios->pages && !per_dev->length)\n\t\treturn 0; /* Just an empty slot */\n\n\tfirst_dev = per_dev->dev + first_dev % ios->layout->mirrors_p1;\n\tor = osd_start_request(_ios_od(ios, first_dev), GFP_KERNEL);\n\tif (unlikely(!or)) {\n\t\tORE_ERR(\"%s: osd_start_request failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tper_dev->or = or;\n\n\tif (ios->pages) {\n\t\tif (per_dev->cur_sg) {\n\t\t\t/* finalize the last sg_entry */\n\t\t\t_ore_add_sg_seg(per_dev, 0, false);\n\t\t\tif (unlikely(!per_dev->cur_sg))\n\t\t\t\treturn 0; /* Skip parity only device */\n\n\t\t\tosd_req_read_sg(or, obj, per_dev->bio,\n\t\t\t\t\tper_dev->sglist, per_dev->cur_sg);\n\t\t} else {\n\t\t\t/* The no raid case */\n\t\t\tosd_req_read(or, obj, per_dev->offset,\n\t\t\t\t     per_dev->bio, per_dev->length);\n\t\t}\n\n\t\tORE_DBGMSG(\"read(0x%llx) offset=0x%llx length=0x%llx\"\n\t\t\t     \" dev=%d sg_len=%d\\n\", _LLU(obj->id),\n\t\t\t     _LLU(per_dev->offset), _LLU(per_dev->length),\n\t\t\t     first_dev, per_dev->cur_sg);\n\t} else {\n\t\tBUG_ON(ios->kern_buff);\n\n\t\tosd_req_get_attributes(or, obj);\n\t\tORE_DBGMSG2(\"obj(0x%llx) get_attributes=%d dev=%d\\n\",\n\t\t\t      _LLU(obj->id),\n\t\t\t      ios->in_attr_len, first_dev);\n\t}\n\tif (ios->out_attr)\n\t\tosd_req_add_set_attr_list(or, ios->out_attr, ios->out_attr_len);\n\n\tif (ios->in_attr)\n\t\tosd_req_add_get_attr_list(or, ios->in_attr, ios->in_attr_len);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "e_write(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "930-955",
    "snippet": "t ore_write(struct ore_io_state *ios)\n{\n\tint i;\n\tint ret;\n\n\tif (unlikely(ios->sp2d && !ios->r4w)) {\n\t\t/* A library is attempting a RAID-write without providing\n\t\t * a pages lock interface.\n\t\t */\n\t\tWARN_ON_ONCE(1);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tret = _prepare_for_striping(ios);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tfor (i = 0; i < ios->numdevs; i += ios->layout->mirrors_p1) {\n\t\tret = _write_mirror(ios, i);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tret = ore_io_execute(ios);\n\treturn ret;\n}\nE",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "e_io_execute(i",
          "args": [
            "s);"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely(r",
          "args": [
            "t))"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rite_mirror(i",
          "args": [
            "s,",
            ";"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely(r",
          "args": [
            "t))"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repare_for_striping(i",
          "args": [
            "s);"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RN_ON_ONCE(1",
          "args": [
            ";"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely(i",
          "args": [
            "s->sp2d && !ios->r4w))"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nt ore_write(struct ore_io_state *ios)\n{\n\tint i;\n\tint ret;\n\n\tif (unlikely(ios->sp2d && !ios->r4w)) {\n\t\t/* A library is attempting a RAID-write without providing\n\t\t * a pages lock interface.\n\t\t */\n\t\tWARN_ON_ONCE(1);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tret = _prepare_for_striping(ios);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tfor (i = 0; i < ios->numdevs; i += ios->layout->mirrors_p1) {\n\t\tret = _write_mirror(ios, i);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tret = ore_io_execute(ios);\n\treturn ret;\n}\nE"
  },
  {
    "function_name": "rite_mirror(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "836-928",
    "snippet": "atic int _write_mirror(struct ore_io_state *ios, int cur_comp)\n{\n\tstruct ore_per_dev_state *master_dev = &ios->per_dev[cur_comp];\n\tunsigned dev = ios->per_dev[cur_comp].dev;\n\tunsigned last_comp = cur_comp + ios->layout->mirrors_p1;\n\tint ret = 0;\n\n\tif (ios->pages && !master_dev->length)\n\t\treturn 0; /* Just an empty slot */\n\n\tfor (; cur_comp < last_comp; ++cur_comp, ++dev) {\n\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[cur_comp];\n\t\tstruct osd_request *or;\n\n\t\tor = osd_start_request(_ios_od(ios, dev), GFP_KERNEL);\n\t\tif (unlikely(!or)) {\n\t\t\tORE_ERR(\"%s: osd_start_request failed\\n\", __func__);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tper_dev->or = or;\n\n\t\tif (ios->pages) {\n\t\t\tstruct bio *bio;\n\n\t\t\tif (per_dev != master_dev) {\n\t\t\t\tbio = bio_clone_kmalloc(master_dev->bio,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\tif (unlikely(!bio)) {\n\t\t\t\t\tORE_DBGMSG(\n\t\t\t\t\t      \"Failed to allocate BIO size=%u\\n\",\n\t\t\t\t\t      master_dev->bio->bi_max_vecs);\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tbio->bi_bdev = NULL;\n\t\t\t\tbio->bi_next = NULL;\n\t\t\t\tper_dev->offset = master_dev->offset;\n\t\t\t\tper_dev->length = master_dev->length;\n\t\t\t\tper_dev->bio =  bio;\n\t\t\t\tper_dev->dev = dev;\n\t\t\t} else {\n\t\t\t\tbio = master_dev->bio;\n\t\t\t\t/* FIXME: bio_set_dir() */\n\t\t\t\tbio->bi_rw |= REQ_WRITE;\n\t\t\t}\n\n\t\t\tosd_req_write(or, _ios_obj(ios, cur_comp),\n\t\t\t\t      per_dev->offset, bio, per_dev->length);\n\t\t\tORE_DBGMSG(\"write(0x%llx) offset=0x%llx \"\n\t\t\t\t      \"length=0x%llx dev=%d\\n\",\n\t\t\t\t     _LLU(_ios_obj(ios, cur_comp)->id),\n\t\t\t\t     _LLU(per_dev->offset),\n\t\t\t\t     _LLU(per_dev->length), dev);\n\t\t} else if (ios->kern_buff) {\n\t\t\tper_dev->offset = ios->si.obj_offset;\n\t\t\tper_dev->dev = ios->si.dev + dev;\n\n\t\t\t/* no cross device without page array */\n\t\t\tBUG_ON((ios->layout->group_width > 1) &&\n\t\t\t       (ios->si.unit_off + ios->length >\n\t\t\t\tios->layout->stripe_unit));\n\n\t\t\tret = osd_req_write_kern(or, _ios_obj(ios, cur_comp),\n\t\t\t\t\t\t per_dev->offset,\n\t\t\t\t\t\t ios->kern_buff, ios->length);\n\t\t\tif (unlikely(ret))\n\t\t\t\tgoto out;\n\t\t\tORE_DBGMSG2(\"write_kern(0x%llx) offset=0x%llx \"\n\t\t\t\t      \"length=0x%llx dev=%d\\n\",\n\t\t\t\t     _LLU(_ios_obj(ios, cur_comp)->id),\n\t\t\t\t     _LLU(per_dev->offset),\n\t\t\t\t     _LLU(ios->length), per_dev->dev);\n\t\t} else {\n\t\t\tosd_req_set_attributes(or, _ios_obj(ios, cur_comp));\n\t\t\tORE_DBGMSG2(\"obj(0x%llx) set_attributes=%d dev=%d\\n\",\n\t\t\t\t     _LLU(_ios_obj(ios, cur_comp)->id),\n\t\t\t\t     ios->out_attr_len, dev);\n\t\t}\n\n\t\tif (ios->out_attr)\n\t\t\tosd_req_add_set_attr_list(or, ios->out_attr,\n\t\t\t\t\t\t  ios->out_attr_len);\n\n\t\tif (ios->in_attr)\n\t\t\tosd_req_add_get_attr_list(or, ios->in_attr,\n\t\t\t\t\t\t  ios->in_attr_len);\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_req_add_get_attr_list(o",
          "args": [
            ",",
            "s->in_attr,",
            "s->in_attr_len);"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_req_add_set_attr_list(o",
          "args": [
            ",",
            "s->out_attr,",
            "s->out_attr_len);"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E_DBGMSG2(\"",
          "args": [
            "bj(0x%llx) set_attributes=%d dev=%d\\n\",",
            "LU(_ios_obj(ios, cur_comp)->id),",
            "s->out_attr_len,",
            "v);"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LU(_",
          "args": [
            "os_obj(ios, cur_comp)->id),"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "os_obj(i",
          "args": [
            "s,",
            "r_comp)-"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_req_set_attributes(o",
          "args": [
            ",",
            "os_obj(ios, cur_comp));"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "os_obj(i",
          "args": [
            "s,",
            "r_comp))"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E_DBGMSG2(\"",
          "args": [
            "rite_kern(0x%llx) offset=0x%llx \"\n\t\t\t\t      \"length=0x%llx dev=%d\\n\",",
            "LU(_ios_obj(ios, cur_comp)->id),",
            "LU(per_dev->offset),",
            "LU(ios->length),",
            "r_dev->dev);"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LU(i",
          "args": [
            "s->length),"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LU(p",
          "args": [
            "r_dev->offset),"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LU(_",
          "args": [
            "os_obj(ios, cur_comp)->id),"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "os_obj(i",
          "args": [
            "s,",
            "r_comp)-"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely(r",
          "args": [
            "t))"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_req_write_kern(o",
          "args": [
            ",",
            "os_obj(ios, cur_comp),",
            "r_dev->offset,",
            "s->kern_buff,",
            "s->length);"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "os_obj(i",
          "args": [
            "s,",
            "r_comp),"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_ON((",
          "args": [
            "os->layout->group_width > 1) &&\n\t\t\t       (ios->si.unit_off + ios->length >\n\t\t\t\tios->layout->stripe_unit));"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E_DBGMSG(\"",
          "args": [
            "rite(0x%llx) offset=0x%llx \"\n\t\t\t\t      \"length=0x%llx dev=%d\\n\",",
            "LU(_ios_obj(ios, cur_comp)->id),",
            "LU(per_dev->offset),",
            "LU(per_dev->length),",
            "v);"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LU(p",
          "args": [
            "r_dev->length),"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LU(p",
          "args": [
            "r_dev->offset),"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LU(_",
          "args": [
            "os_obj(ios, cur_comp)->id),"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "os_obj(i",
          "args": [
            "s,",
            "r_comp)-"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_req_write(o",
          "args": [
            ",",
            "os_obj(ios, cur_comp),",
            "r_dev->offset,",
            "o,",
            "r_dev->length);"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "os_obj(i",
          "args": [
            "s,",
            "r_comp),"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E_DBGMSG(",
          "args": [
            "ailed to allocate BIO size=%u\\n\",",
            "ster_dev->bio->bi_max_vecs);"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely(!",
          "args": [
            "io))"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o_clone_kmalloc(m",
          "args": [
            "ster_dev->bio,",
            "P_KERNEL);"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E_ERR(\"",
          "args": [
            "s: osd_start_request failed\\n\",",
            "func__);"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely(!",
          "args": [
            "r))"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_start_request(_",
          "args": [
            "os_od(ios, dev),",
            "P_KERNEL);"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "os_od(i",
          "args": [
            "s,",
            "v),"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\natic int _write_mirror(struct ore_io_state *ios, int cur_comp)\n{\n\tstruct ore_per_dev_state *master_dev = &ios->per_dev[cur_comp];\n\tunsigned dev = ios->per_dev[cur_comp].dev;\n\tunsigned last_comp = cur_comp + ios->layout->mirrors_p1;\n\tint ret = 0;\n\n\tif (ios->pages && !master_dev->length)\n\t\treturn 0; /* Just an empty slot */\n\n\tfor (; cur_comp < last_comp; ++cur_comp, ++dev) {\n\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[cur_comp];\n\t\tstruct osd_request *or;\n\n\t\tor = osd_start_request(_ios_od(ios, dev), GFP_KERNEL);\n\t\tif (unlikely(!or)) {\n\t\t\tORE_ERR(\"%s: osd_start_request failed\\n\", __func__);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tper_dev->or = or;\n\n\t\tif (ios->pages) {\n\t\t\tstruct bio *bio;\n\n\t\t\tif (per_dev != master_dev) {\n\t\t\t\tbio = bio_clone_kmalloc(master_dev->bio,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\tif (unlikely(!bio)) {\n\t\t\t\t\tORE_DBGMSG(\n\t\t\t\t\t      \"Failed to allocate BIO size=%u\\n\",\n\t\t\t\t\t      master_dev->bio->bi_max_vecs);\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tbio->bi_bdev = NULL;\n\t\t\t\tbio->bi_next = NULL;\n\t\t\t\tper_dev->offset = master_dev->offset;\n\t\t\t\tper_dev->length = master_dev->length;\n\t\t\t\tper_dev->bio =  bio;\n\t\t\t\tper_dev->dev = dev;\n\t\t\t} else {\n\t\t\t\tbio = master_dev->bio;\n\t\t\t\t/* FIXME: bio_set_dir() */\n\t\t\t\tbio->bi_rw |= REQ_WRITE;\n\t\t\t}\n\n\t\t\tosd_req_write(or, _ios_obj(ios, cur_comp),\n\t\t\t\t      per_dev->offset, bio, per_dev->length);\n\t\t\tORE_DBGMSG(\"write(0x%llx) offset=0x%llx \"\n\t\t\t\t      \"length=0x%llx dev=%d\\n\",\n\t\t\t\t     _LLU(_ios_obj(ios, cur_comp)->id),\n\t\t\t\t     _LLU(per_dev->offset),\n\t\t\t\t     _LLU(per_dev->length), dev);\n\t\t} else if (ios->kern_buff) {\n\t\t\tper_dev->offset = ios->si.obj_offset;\n\t\t\tper_dev->dev = ios->si.dev + dev;\n\n\t\t\t/* no cross device without page array */\n\t\t\tBUG_ON((ios->layout->group_width > 1) &&\n\t\t\t       (ios->si.unit_off + ios->length >\n\t\t\t\tios->layout->stripe_unit));\n\n\t\t\tret = osd_req_write_kern(or, _ios_obj(ios, cur_comp),\n\t\t\t\t\t\t per_dev->offset,\n\t\t\t\t\t\t ios->kern_buff, ios->length);\n\t\t\tif (unlikely(ret))\n\t\t\t\tgoto out;\n\t\t\tORE_DBGMSG2(\"write_kern(0x%llx) offset=0x%llx \"\n\t\t\t\t      \"length=0x%llx dev=%d\\n\",\n\t\t\t\t     _LLU(_ios_obj(ios, cur_comp)->id),\n\t\t\t\t     _LLU(per_dev->offset),\n\t\t\t\t     _LLU(ios->length), per_dev->dev);\n\t\t} else {\n\t\t\tosd_req_set_attributes(or, _ios_obj(ios, cur_comp));\n\t\t\tORE_DBGMSG2(\"obj(0x%llx) set_attributes=%d dev=%d\\n\",\n\t\t\t\t     _LLU(_ios_obj(ios, cur_comp)->id),\n\t\t\t\t     ios->out_attr_len, dev);\n\t\t}\n\n\t\tif (ios->out_attr)\n\t\t\tosd_req_add_set_attr_list(or, ios->out_attr,\n\t\t\t\t\t\t  ios->out_attr_len);\n\n\t\tif (ios->in_attr)\n\t\t\tosd_req_add_get_attr_list(or, ios->in_attr,\n\t\t\t\t\t\t  ios->in_attr_len);\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "e_remove(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "811-833",
    "snippet": "t ore_remove(struct ore_io_state *ios)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ios->oc->numdevs; i++) {\n\t\tstruct osd_request *or;\n\n\t\tor = osd_start_request(_ios_od(ios, i), GFP_KERNEL);\n\t\tif (unlikely(!or)) {\n\t\t\tORE_ERR(\"%s: osd_start_request failed\\n\", __func__);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tios->per_dev[i].or = or;\n\t\tios->numdevs++;\n\n\t\tosd_req_remove_object(or, _ios_obj(ios, i));\n\t}\n\tret = ore_io_execute(ios);\n\nout:\n\treturn ret;\n}\nE",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "e_io_execute(i",
          "args": [
            "s);"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_req_remove_object(o",
          "args": [
            ",",
            "os_obj(ios, i));"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "os_obj(i",
          "args": [
            "s,",
            ")"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E_ERR(\"",
          "args": [
            "s: osd_start_request failed\\n\",",
            "func__);"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely(!",
          "args": [
            "r))"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_start_request(_",
          "args": [
            "os_od(ios, i),",
            "P_KERNEL);"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "os_od(i",
          "args": [
            "s,",
            ","
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nt ore_remove(struct ore_io_state *ios)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ios->oc->numdevs; i++) {\n\t\tstruct osd_request *or;\n\n\t\tor = osd_start_request(_ios_od(ios, i), GFP_KERNEL);\n\t\tif (unlikely(!or)) {\n\t\t\tORE_ERR(\"%s: osd_start_request failed\\n\", __func__);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tios->per_dev[i].or = or;\n\t\tios->numdevs++;\n\n\t\tosd_req_remove_object(or, _ios_obj(ios, i));\n\t}\n\tret = ore_io_execute(ios);\n\nout:\n\treturn ret;\n}\nE"
  },
  {
    "function_name": "e_create(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "786-808",
    "snippet": "t ore_create(struct ore_io_state *ios)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ios->oc->numdevs; i++) {\n\t\tstruct osd_request *or;\n\n\t\tor = osd_start_request(_ios_od(ios, i), GFP_KERNEL);\n\t\tif (unlikely(!or)) {\n\t\t\tORE_ERR(\"%s: osd_start_request failed\\n\", __func__);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tios->per_dev[i].or = or;\n\t\tios->numdevs++;\n\n\t\tosd_req_create_object(or, _ios_obj(ios, i));\n\t}\n\tret = ore_io_execute(ios);\n\nout:\n\treturn ret;\n}\nE",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "e_io_execute(i",
          "args": [
            "s);"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_req_create_object(o",
          "args": [
            ",",
            "os_obj(ios, i));"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "os_obj(i",
          "args": [
            "s,",
            ")"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E_ERR(\"",
          "args": [
            "s: osd_start_request failed\\n\",",
            "func__);"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely(!",
          "args": [
            "r))"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_start_request(_",
          "args": [
            "os_od(ios, i),",
            "P_KERNEL);"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "os_od(i",
          "args": [
            "s,",
            ","
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nt ore_create(struct ore_io_state *ios)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ios->oc->numdevs; i++) {\n\t\tstruct osd_request *or;\n\n\t\tor = osd_start_request(_ios_od(ios, i), GFP_KERNEL);\n\t\tif (unlikely(!or)) {\n\t\t\tORE_ERR(\"%s: osd_start_request failed\\n\", __func__);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tios->per_dev[i].or = or;\n\t\tios->numdevs++;\n\n\t\tosd_req_create_object(or, _ios_obj(ios, i));\n\t}\n\tret = ore_io_execute(ios);\n\nout:\n\treturn ret;\n}\nE"
  },
  {
    "function_name": "repare_for_striping(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "697-784",
    "snippet": "atic int _prepare_for_striping(struct ore_io_state *ios)\n{\n\tstruct ore_striping_info *si = &ios->si;\n\tunsigned stripe_unit = ios->layout->stripe_unit;\n\tunsigned mirrors_p1 = ios->layout->mirrors_p1;\n\tunsigned group_width = ios->layout->group_width;\n\tunsigned devs_in_group = group_width * mirrors_p1;\n\tunsigned dev = si->dev;\n\tunsigned first_dev = dev - (dev % devs_in_group);\n\tunsigned cur_pg = ios->pages_consumed;\n\tu64 length = ios->length;\n\tint ret = 0;\n\n\tif (!ios->pages) {\n\t\tios->numdevs = ios->layout->mirrors_p1;\n\t\treturn 0;\n\t}\n\n\tBUG_ON(length > si->length);\n\n\twhile (length) {\n\t\tstruct ore_per_dev_state *per_dev =\n\t\t\t\t\t\t&ios->per_dev[dev - first_dev];\n\t\tunsigned cur_len, page_off = 0;\n\n\t\tif (!per_dev->length && !per_dev->offset) {\n\t\t\t/* First time initialize the per_dev info. */\n\t\t\tper_dev->dev = dev;\n\t\t\tif (dev == si->dev) {\n\t\t\t\tWARN_ON(dev == si->par_dev);\n\t\t\t\tper_dev->offset = si->obj_offset;\n\t\t\t\tcur_len = stripe_unit - si->unit_off;\n\t\t\t\tpage_off = si->unit_off & ~PAGE_MASK;\n\t\t\t\tBUG_ON(page_off && (page_off != ios->pgbase));\n\t\t\t} else {\n\t\t\t\tper_dev->offset = si->obj_offset - si->unit_off;\n\t\t\t\tcur_len = stripe_unit;\n\t\t\t}\n\t\t} else {\n\t\t\tcur_len = stripe_unit;\n\t\t}\n\t\tif (cur_len >= length)\n\t\t\tcur_len = length;\n\n\t\tret = _ore_add_stripe_unit(ios, &cur_pg, page_off, ios->pages,\n\t\t\t\t\t   per_dev, cur_len);\n\t\tif (unlikely(ret))\n\t\t\tgoto out;\n\n\t\tlength -= cur_len;\n\n\t\tdev = ((dev + mirrors_p1) % devs_in_group) + first_dev;\n\t\tsi->cur_comp = (si->cur_comp + 1) % group_width;\n\t\tif (unlikely((dev == si->par_dev) || (!length && ios->sp2d))) {\n\t\t\tif (!length && ios->sp2d) {\n\t\t\t\t/* If we are writing and this is the very last\n\t\t\t\t * stripe. then operate on parity dev.\n\t\t\t\t */\n\t\t\t\tdev = si->par_dev;\n\t\t\t\t/* If last stripe operate on parity comp */\n\t\t\t\tsi->cur_comp = group_width - ios->layout->parity;\n\t\t\t}\n\n\t\t\t/* In writes cur_len just means if it's the\n\t\t\t * last one. See _ore_add_parity_unit.\n\t\t\t */\n\t\t\tret = _add_parity_units(ios, si, dev, first_dev,\n\t\t\t\t\t\tmirrors_p1, devs_in_group,\n\t\t\t\t\t\tios->sp2d ? length : cur_len);\n\t\t\tif (unlikely(ret))\n\t\t\t\t\tgoto out;\n\n\t\t\t/* Rotate next par_dev backwards with wraping */\n\t\t\tsi->par_dev = (devs_in_group + si->par_dev -\n\t\t\t\t       ios->layout->parity * mirrors_p1) %\n\t\t\t\t      devs_in_group + first_dev;\n\t\t\t/* Next stripe, start fresh */\n\t\t\tsi->cur_comp = 0;\n\t\t\tsi->cur_pg = 0;\n\t\t\tsi->obj_offset += cur_len;\n\t\t\tsi->unit_off = 0;\n\t\t}\n\t}\nout:\n\tios->numdevs = devs_in_group;\n\tios->pages_consumed = cur_pg;\n\treturn ret;\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely(r",
          "args": [
            "t))"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dd_parity_units(i",
          "args": [
            "s,",
            ",",
            "v,",
            "rst_dev,",
            "rrors_p1,",
            "vs_in_group,",
            "s->sp2d ? length : cur_len);"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely((",
          "args": [
            "ev == si->par_dev) || (!length && ios->sp2d)))"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely(r",
          "args": [
            "t))"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "re_add_stripe_unit(i",
          "args": [
            "s,",
            "ur_pg,",
            "ge_off,",
            "s->pages,",
            "r_dev,",
            "r_len);"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_ON(p",
          "args": [
            "ge_off && (page_off != ios->pgbase));"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RN_ON(d",
          "args": [
            "v == si->par_dev);"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_ON(l",
          "args": [
            "ngth > si->length);"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\natic int _prepare_for_striping(struct ore_io_state *ios)\n{\n\tstruct ore_striping_info *si = &ios->si;\n\tunsigned stripe_unit = ios->layout->stripe_unit;\n\tunsigned mirrors_p1 = ios->layout->mirrors_p1;\n\tunsigned group_width = ios->layout->group_width;\n\tunsigned devs_in_group = group_width * mirrors_p1;\n\tunsigned dev = si->dev;\n\tunsigned first_dev = dev - (dev % devs_in_group);\n\tunsigned cur_pg = ios->pages_consumed;\n\tu64 length = ios->length;\n\tint ret = 0;\n\n\tif (!ios->pages) {\n\t\tios->numdevs = ios->layout->mirrors_p1;\n\t\treturn 0;\n\t}\n\n\tBUG_ON(length > si->length);\n\n\twhile (length) {\n\t\tstruct ore_per_dev_state *per_dev =\n\t\t\t\t\t\t&ios->per_dev[dev - first_dev];\n\t\tunsigned cur_len, page_off = 0;\n\n\t\tif (!per_dev->length && !per_dev->offset) {\n\t\t\t/* First time initialize the per_dev info. */\n\t\t\tper_dev->dev = dev;\n\t\t\tif (dev == si->dev) {\n\t\t\t\tWARN_ON(dev == si->par_dev);\n\t\t\t\tper_dev->offset = si->obj_offset;\n\t\t\t\tcur_len = stripe_unit - si->unit_off;\n\t\t\t\tpage_off = si->unit_off & ~PAGE_MASK;\n\t\t\t\tBUG_ON(page_off && (page_off != ios->pgbase));\n\t\t\t} else {\n\t\t\t\tper_dev->offset = si->obj_offset - si->unit_off;\n\t\t\t\tcur_len = stripe_unit;\n\t\t\t}\n\t\t} else {\n\t\t\tcur_len = stripe_unit;\n\t\t}\n\t\tif (cur_len >= length)\n\t\t\tcur_len = length;\n\n\t\tret = _ore_add_stripe_unit(ios, &cur_pg, page_off, ios->pages,\n\t\t\t\t\t   per_dev, cur_len);\n\t\tif (unlikely(ret))\n\t\t\tgoto out;\n\n\t\tlength -= cur_len;\n\n\t\tdev = ((dev + mirrors_p1) % devs_in_group) + first_dev;\n\t\tsi->cur_comp = (si->cur_comp + 1) % group_width;\n\t\tif (unlikely((dev == si->par_dev) || (!length && ios->sp2d))) {\n\t\t\tif (!length && ios->sp2d) {\n\t\t\t\t/* If we are writing and this is the very last\n\t\t\t\t * stripe. then operate on parity dev.\n\t\t\t\t */\n\t\t\t\tdev = si->par_dev;\n\t\t\t\t/* If last stripe operate on parity comp */\n\t\t\t\tsi->cur_comp = group_width - ios->layout->parity;\n\t\t\t}\n\n\t\t\t/* In writes cur_len just means if it's the\n\t\t\t * last one. See _ore_add_parity_unit.\n\t\t\t */\n\t\t\tret = _add_parity_units(ios, si, dev, first_dev,\n\t\t\t\t\t\tmirrors_p1, devs_in_group,\n\t\t\t\t\t\tios->sp2d ? length : cur_len);\n\t\t\tif (unlikely(ret))\n\t\t\t\t\tgoto out;\n\n\t\t\t/* Rotate next par_dev backwards with wraping */\n\t\t\tsi->par_dev = (devs_in_group + si->par_dev -\n\t\t\t\t       ios->layout->parity * mirrors_p1) %\n\t\t\t\t      devs_in_group + first_dev;\n\t\t\t/* Next stripe, start fresh */\n\t\t\tsi->cur_comp = 0;\n\t\t\tsi->cur_pg = 0;\n\t\t\tsi->obj_offset += cur_len;\n\t\t\tsi->unit_off = 0;\n\t\t}\n\t}\nout:\n\tios->numdevs = devs_in_group;\n\tios->pages_consumed = cur_pg;\n\treturn ret;\n}"
  },
  {
    "function_name": "dd_parity_units(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "660-695",
    "snippet": "atic int _add_parity_units(struct ore_io_state *ios,\n\t\t\t     struct ore_striping_info *si,\n\t\t\t     unsigned dev, unsigned first_dev,\n\t\t\t     unsigned mirrors_p1, unsigned devs_in_group,\n\t\t\t     unsigned cur_len)\n{\n\tunsigned do_parity;\n\tint ret = 0;\n\n\tfor (do_parity = ios->layout->parity; do_parity; --do_parity) {\n\t\tstruct ore_per_dev_state *per_dev;\n\n\t\tper_dev = &ios->per_dev[dev - first_dev];\n\t\tif (!per_dev->length && !per_dev->offset) {\n\t\t\t/* Only/always the parity unit of the first\n\t\t\t * stripe will be empty. So this is a chance to\n\t\t\t * initialize the per_dev info.\n\t\t\t */\n\t\t\tper_dev->dev = dev;\n\t\t\tper_dev->offset = si->obj_offset - si->unit_off;\n\t\t}\n\n\t\tret = _ore_add_parity_unit(ios, si, per_dev, cur_len,\n\t\t\t\t\t   do_parity == 1);\n\t\tif (unlikely(ret))\n\t\t\t\tbreak;\n\n\t\tif (do_parity != 1) {\n\t\t\tdev = ((dev + mirrors_p1) % devs_in_group) + first_dev;\n\t\t\tsi->cur_comp = (si->cur_comp + 1) %\n\t\t\t\t\t\t       ios->layout->group_width;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely(r",
          "args": [
            "t))"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "re_add_parity_unit(i",
          "args": [
            "s,",
            ",",
            "r_dev,",
            "r_len,",
            "_parity == 1);"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\natic int _add_parity_units(struct ore_io_state *ios,\n\t\t\t     struct ore_striping_info *si,\n\t\t\t     unsigned dev, unsigned first_dev,\n\t\t\t     unsigned mirrors_p1, unsigned devs_in_group,\n\t\t\t     unsigned cur_len)\n{\n\tunsigned do_parity;\n\tint ret = 0;\n\n\tfor (do_parity = ios->layout->parity; do_parity; --do_parity) {\n\t\tstruct ore_per_dev_state *per_dev;\n\n\t\tper_dev = &ios->per_dev[dev - first_dev];\n\t\tif (!per_dev->length && !per_dev->offset) {\n\t\t\t/* Only/always the parity unit of the first\n\t\t\t * stripe will be empty. So this is a chance to\n\t\t\t * initialize the per_dev info.\n\t\t\t */\n\t\t\tper_dev->dev = dev;\n\t\t\tper_dev->offset = si->obj_offset - si->unit_off;\n\t\t}\n\n\t\tret = _ore_add_parity_unit(ios, si, per_dev, cur_len,\n\t\t\t\t\t   do_parity == 1);\n\t\tif (unlikely(ret))\n\t\t\t\tbreak;\n\n\t\tif (do_parity != 1) {\n\t\t\tdev = ((dev + mirrors_p1) % devs_in_group) + first_dev;\n\t\t\tsi->cur_comp = (si->cur_comp + 1) %\n\t\t\t\t\t\t       ios->layout->group_width;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "re_add_stripe_unit(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "593-658",
    "snippet": "t _ore_add_stripe_unit(struct ore_io_state *ios,  unsigned *cur_pg,\n\t\t\t unsigned pgbase, struct page **pages,\n\t\t\t struct ore_per_dev_state *per_dev, int cur_len)\n{\n\tunsigned pg = *cur_pg;\n\tstruct request_queue *q =\n\t\t\tosd_request_queue(_ios_od(ios, per_dev->dev));\n\tunsigned len = cur_len;\n\tint ret;\n\n\tif (per_dev->bio == NULL) {\n\t\tunsigned bio_size;\n\n\t\tif (!ios->reading) {\n\t\t\tbio_size = ios->si.maxdevUnits;\n\t\t} else {\n\t\t\tbio_size = (ios->si.maxdevUnits + 1) *\n\t\t\t     (ios->layout->group_width - ios->layout->parity) /\n\t\t\t     ios->layout->group_width;\n\t\t}\n\t\tbio_size *= (ios->layout->stripe_unit / PAGE_SIZE);\n\n\t\tper_dev->bio = bio_kmalloc(GFP_KERNEL, bio_size);\n\t\tif (unlikely(!per_dev->bio)) {\n\t\t\tORE_DBGMSG(\"Failed to allocate BIO size=%u\\n\",\n\t\t\t\t     bio_size);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\twhile (cur_len > 0) {\n\t\tunsigned pglen = min_t(unsigned, PAGE_SIZE - pgbase, cur_len);\n\t\tunsigned added_len;\n\n\t\tcur_len -= pglen;\n\n\t\tadded_len = bio_add_pc_page(q, per_dev->bio, pages[pg],\n\t\t\t\t\t    pglen, pgbase);\n\t\tif (unlikely(pglen != added_len)) {\n\t\t\t/* If bi_vcnt == bi_max then this is a SW BUG */\n\t\t\tORE_DBGMSG(\"Failed bio_add_pc_page bi_vcnt=0x%x \"\n\t\t\t\t   \"bi_max=0x%x BIO_MAX=0x%x cur_len=0x%x\\n\",\n\t\t\t\t   per_dev->bio->bi_vcnt,\n\t\t\t\t   per_dev->bio->bi_max_vecs,\n\t\t\t\t   BIO_MAX_PAGES_KMALLOC, cur_len);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t_add_stripe_page(ios->sp2d, &ios->si, pages[pg]);\n\n\t\tpgbase = 0;\n\t\t++pg;\n\t}\n\tBUG_ON(cur_len);\n\n\tper_dev->length += len;\n\t*cur_pg = pg;\n\tret = 0;\nout:\t/* we fail the complete unit on an error eg don't advance\n\t * per_dev->length and cur_pg. This means that we might have a bigger\n\t * bio than the CDB requested length (per_dev->length). That's fine\n\t * only the oposite is fatal.\n\t */\n\treturn ret;\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "G_ON(c",
          "args": [
            "r_len);"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dd_stripe_page(i",
          "args": [
            "s->sp2d,",
            "os->si,",
            "ges[pg]);"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E_DBGMSG(\"",
          "args": [
            "ailed bio_add_pc_page bi_vcnt=0x%x \"\n\t\t\t\t   \"bi_max=0x%x BIO_MAX=0x%x cur_len=0x%x\\n\",",
            "r_dev->bio->bi_vcnt,",
            "r_dev->bio->bi_max_vecs,",
            "O_MAX_PAGES_KMALLOC,",
            "r_len);"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely(p",
          "args": [
            "len != added_len))"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o_add_pc_page(q",
          "args": [
            "r_dev->bio,",
            "ges[pg],",
            "len,",
            "base);"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_t(u",
          "args": [
            "signed,",
            "GE_SIZE - pgbase,",
            "r_len);"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E_DBGMSG(\"",
          "args": [
            "ailed to allocate BIO size=%u\\n\",",
            "o_size);"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely(!",
          "args": [
            "er_dev->bio))"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o_kmalloc(G",
          "args": [
            "P_KERNEL,",
            "o_size);"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_request_queue(_",
          "args": [
            "os_od(ios, per_dev->dev));"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "os_od(i",
          "args": [
            "s,",
            "r_dev->dev))"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nt _ore_add_stripe_unit(struct ore_io_state *ios,  unsigned *cur_pg,\n\t\t\t unsigned pgbase, struct page **pages,\n\t\t\t struct ore_per_dev_state *per_dev, int cur_len)\n{\n\tunsigned pg = *cur_pg;\n\tstruct request_queue *q =\n\t\t\tosd_request_queue(_ios_od(ios, per_dev->dev));\n\tunsigned len = cur_len;\n\tint ret;\n\n\tif (per_dev->bio == NULL) {\n\t\tunsigned bio_size;\n\n\t\tif (!ios->reading) {\n\t\t\tbio_size = ios->si.maxdevUnits;\n\t\t} else {\n\t\t\tbio_size = (ios->si.maxdevUnits + 1) *\n\t\t\t     (ios->layout->group_width - ios->layout->parity) /\n\t\t\t     ios->layout->group_width;\n\t\t}\n\t\tbio_size *= (ios->layout->stripe_unit / PAGE_SIZE);\n\n\t\tper_dev->bio = bio_kmalloc(GFP_KERNEL, bio_size);\n\t\tif (unlikely(!per_dev->bio)) {\n\t\t\tORE_DBGMSG(\"Failed to allocate BIO size=%u\\n\",\n\t\t\t\t     bio_size);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\twhile (cur_len > 0) {\n\t\tunsigned pglen = min_t(unsigned, PAGE_SIZE - pgbase, cur_len);\n\t\tunsigned added_len;\n\n\t\tcur_len -= pglen;\n\n\t\tadded_len = bio_add_pc_page(q, per_dev->bio, pages[pg],\n\t\t\t\t\t    pglen, pgbase);\n\t\tif (unlikely(pglen != added_len)) {\n\t\t\t/* If bi_vcnt == bi_max then this is a SW BUG */\n\t\t\tORE_DBGMSG(\"Failed bio_add_pc_page bi_vcnt=0x%x \"\n\t\t\t\t   \"bi_max=0x%x BIO_MAX=0x%x cur_len=0x%x\\n\",\n\t\t\t\t   per_dev->bio->bi_vcnt,\n\t\t\t\t   per_dev->bio->bi_max_vecs,\n\t\t\t\t   BIO_MAX_PAGES_KMALLOC, cur_len);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t_add_stripe_page(ios->sp2d, &ios->si, pages[pg]);\n\n\t\tpgbase = 0;\n\t\t++pg;\n\t}\n\tBUG_ON(cur_len);\n\n\tper_dev->length += len;\n\t*cur_pg = pg;\n\tret = 0;\nout:\t/* we fail the complete unit on an error eg don't advance\n\t * per_dev->length and cur_pg. This means that we might have a bigger\n\t * bio than the CDB requested length (per_dev->length). That's fine\n\t * only the oposite is fatal.\n\t */\n\treturn ret;\n}"
  },
  {
    "function_name": "e_calc_stripe_info(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "526-590",
    "snippet": "id ore_calc_stripe_info(struct ore_layout *layout, u64 file_offset,\n\t\t\t  u64 length, struct ore_striping_info *si)\n{\n\tu32\tstripe_unit = layout->stripe_unit;\n\tu32\tgroup_width = layout->group_width;\n\tu64\tgroup_depth = layout->group_depth;\n\tu32\tparity      = layout->parity;\n\n\tu32\tD = group_width - parity;\n\tu32\tU = D * stripe_unit;\n\tu64\tT = U * group_depth;\n\tu64\tS = T * layout->group_count;\n\tu64\tM = div64_u64(file_offset, S);\n\n\t/*\n\tG = (L - (M * S)) / T\n\tH = (L - (M * S)) % T\n\t*/\n\tu64\tLmodS = file_offset - M * S;\n\tu32\tG = div64_u64(LmodS, T);\n\tu64\tH = LmodS - G * T;\n\n\tu32\tN = div_u64(H, U);\n\tu32\tNlast;\n\n\t/* \"H - (N * U)\" is just \"H % U\" so it's bound to u32 */\n\tu32\tC = (u32)(H - (N * U)) / stripe_unit + G * group_width;\n\tu32 first_dev = C - C % group_width;\n\n\tdiv_u64_rem(file_offset, stripe_unit, &si->unit_off);\n\n\tsi->obj_offset = si->unit_off + (N * stripe_unit) +\n\t\t\t\t  (M * group_depth * stripe_unit);\n\tsi->cur_comp = C - first_dev;\n\tsi->cur_pg = si->unit_off / PAGE_SIZE;\n\n\tif (parity) {\n\t\tu32 LCMdP = lcm(group_width, parity) / parity;\n\t\t/* R     = N % LCMdP; */\n\t\tu32 RxP   = (N % LCMdP) * parity;\n\n\t\tsi->par_dev = (group_width + group_width - parity - RxP) %\n\t\t\t      group_width + first_dev;\n\t\tsi->dev = (group_width + group_width + C - RxP) %\n\t\t\t  group_width + first_dev;\n\t\tsi->bytes_in_stripe = U;\n\t\tsi->first_stripe_start = M * S + G * T + N * U;\n\t} else {\n\t\t/* Make the math correct see _prepare_one_group */\n\t\tsi->par_dev = group_width;\n\t\tsi->dev = C;\n\t}\n\n\tsi->dev *= layout->mirrors_p1;\n\tsi->par_dev *= layout->mirrors_p1;\n\tsi->offset = file_offset;\n\tsi->length = T - H;\n\tif (si->length > length)\n\t\tsi->length = length;\n\n\tNlast = div_u64(H + si->length + U - 1, U);\n\tsi->maxdevUnits = Nlast - N;\n\n\tsi->M = M;\n}\nE",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v_u64(H",
          "args": [
            "+ si->length + U - 1,",
            ";"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m(g",
          "args": [
            "oup_width,",
            "rity)"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v_u64_rem(f",
          "args": [
            "le_offset,",
            "ripe_unit,",
            "i->unit_off);"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32)",
          "args": [
            "- (N * U))"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v_u64(H",
          "args": [
            ";"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v64_u64(L",
          "args": [
            "odS,",
            ";"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v64_u64(f",
          "args": [
            "le_offset,",
            ";"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nid ore_calc_stripe_info(struct ore_layout *layout, u64 file_offset,\n\t\t\t  u64 length, struct ore_striping_info *si)\n{\n\tu32\tstripe_unit = layout->stripe_unit;\n\tu32\tgroup_width = layout->group_width;\n\tu64\tgroup_depth = layout->group_depth;\n\tu32\tparity      = layout->parity;\n\n\tu32\tD = group_width - parity;\n\tu32\tU = D * stripe_unit;\n\tu64\tT = U * group_depth;\n\tu64\tS = T * layout->group_count;\n\tu64\tM = div64_u64(file_offset, S);\n\n\t/*\n\tG = (L - (M * S)) / T\n\tH = (L - (M * S)) % T\n\t*/\n\tu64\tLmodS = file_offset - M * S;\n\tu32\tG = div64_u64(LmodS, T);\n\tu64\tH = LmodS - G * T;\n\n\tu32\tN = div_u64(H, U);\n\tu32\tNlast;\n\n\t/* \"H - (N * U)\" is just \"H % U\" so it's bound to u32 */\n\tu32\tC = (u32)(H - (N * U)) / stripe_unit + G * group_width;\n\tu32 first_dev = C - C % group_width;\n\n\tdiv_u64_rem(file_offset, stripe_unit, &si->unit_off);\n\n\tsi->obj_offset = si->unit_off + (N * stripe_unit) +\n\t\t\t\t  (M * group_depth * stripe_unit);\n\tsi->cur_comp = C - first_dev;\n\tsi->cur_pg = si->unit_off / PAGE_SIZE;\n\n\tif (parity) {\n\t\tu32 LCMdP = lcm(group_width, parity) / parity;\n\t\t/* R     = N % LCMdP; */\n\t\tu32 RxP   = (N % LCMdP) * parity;\n\n\t\tsi->par_dev = (group_width + group_width - parity - RxP) %\n\t\t\t      group_width + first_dev;\n\t\tsi->dev = (group_width + group_width + C - RxP) %\n\t\t\t  group_width + first_dev;\n\t\tsi->bytes_in_stripe = U;\n\t\tsi->first_stripe_start = M * S + G * T + N * U;\n\t} else {\n\t\t/* Make the math correct see _prepare_one_group */\n\t\tsi->par_dev = group_width;\n\t\tsi->dev = C;\n\t}\n\n\tsi->dev *= layout->mirrors_p1;\n\tsi->par_dev *= layout->mirrors_p1;\n\tsi->offset = file_offset;\n\tsi->length = T - H;\n\tif (si->length > length)\n\t\tsi->length = length;\n\n\tNlast = div_u64(H + si->length + U - 1, U);\n\tsi->maxdevUnits = Nlast - N;\n\n\tsi->M = M;\n}\nE"
  },
  {
    "function_name": "ore_check_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "420-471",
    "snippet": "int ore_check_io(struct ore_io_state *ios, ore_on_dev_error on_dev_error)\n{\n\tenum osd_err_priority acumulated_osd_err = 0;\n\tint acumulated_lin_err = 0;\n\tint i;\n\n\tfor (i = 0; i < ios->numdevs; i++) {\n\t\tstruct osd_sense_info osi;\n\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\t\tstruct osd_request *or = per_dev->or;\n\t\tint ret;\n\n\t\tif (unlikely(!or))\n\t\t\tcontinue;\n\n\t\tret = osd_req_decode_sense(or, &osi);\n\t\tif (likely(!ret))\n\t\t\tcontinue;\n\n\t\tif ((OSD_ERR_PRI_CLEAR_PAGES == osi.osd_err_pri) &&\n\t\t    per_dev->bio) {\n\t\t\t/* start read offset passed endof file.\n\t\t\t * Note: if we do not have bio it means read-attributes\n\t\t\t * In this case we should return error to caller.\n\t\t\t */\n\t\t\t_clear_bio(per_dev->bio);\n\t\t\tORE_DBGMSG(\"start read offset passed end of file \"\n\t\t\t\t\"offset=0x%llx, length=0x%llx\\n\",\n\t\t\t\t_LLU(per_dev->offset),\n\t\t\t\t_LLU(per_dev->length));\n\n\t\t\tcontinue; /* we recovered */\n\t\t}\n\n\t\tif (on_dev_error) {\n\t\t\tu64 residual = ios->reading ?\n\t\t\t\t\tor->in.residual : or->out.residual;\n\t\t\tu64 offset = (ios->offset + ios->length) - residual;\n\t\t\tunsigned dev = per_dev->dev - ios->oc->first_dev;\n\t\t\tstruct ore_dev *od = ios->oc->ods[dev];\n\n\t\t\ton_dev_error(ios, od, dev, osi.osd_err_pri,\n\t\t\t\t     offset, residual);\n\t\t}\n\t\tif (osi.osd_err_pri >= acumulated_osd_err) {\n\t\t\tacumulated_osd_err = osi.osd_err_pri;\n\t\t\tacumulated_lin_err = ret;\n\t\t}\n\t}\n\n\treturn acumulated_lin_err;\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "on_dev_error",
          "args": [
            "ios",
            "od",
            "dev",
            "osi.osd_err_pri",
            "offset",
            "residual"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "__on_dev_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
          "lines": "370-389",
          "snippet": "static void __on_dev_error(struct ore_io_state *ios,\n\tstruct ore_dev *od, unsigned dev_index, enum osd_err_priority oep,\n\tu64 dev_offset, u64  dev_len)\n{\n\tstruct objio_state *objios = ios->private;\n\tstruct pnfs_osd_objid pooid;\n\tstruct objio_dev_ent *ode = container_of(od, typeof(*ode), od);\n\t/* FIXME: what to do with more-then-one-group layouts. We need to\n\t * translate from ore_io_state index to oc->comps index\n\t */\n\tunsigned comp = dev_index;\n\n\tpooid.oid_device_id = ode->id_node.deviceid;\n\tpooid.oid_partition_id = ios->oc->comps[comp].obj.partition;\n\tpooid.oid_object_id = ios->oc->comps[comp].obj.id;\n\n\tobjlayout_io_set_result(&objios->oir, comp,\n\t\t\t\t&pooid, osd_pri_2_pnfs_err(oep),\n\t\t\t\tdev_offset, dev_len, !ios->reading);\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"objlayout.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic void __on_dev_error(struct ore_io_state *ios,\n\tstruct ore_dev *od, unsigned dev_index, enum osd_err_priority oep,\n\tu64 dev_offset, u64  dev_len)\n{\n\tstruct objio_state *objios = ios->private;\n\tstruct pnfs_osd_objid pooid;\n\tstruct objio_dev_ent *ode = container_of(od, typeof(*ode), od);\n\t/* FIXME: what to do with more-then-one-group layouts. We need to\n\t * translate from ore_io_state index to oc->comps index\n\t */\n\tunsigned comp = dev_index;\n\n\tpooid.oid_device_id = ode->id_node.deviceid;\n\tpooid.oid_partition_id = ios->oc->comps[comp].obj.partition;\n\tpooid.oid_object_id = ios->oc->comps[comp].obj.id;\n\n\tobjlayout_io_set_result(&objios->oir, comp,\n\t\t\t\t&pooid, osd_pri_2_pnfs_err(oep),\n\t\t\t\tdev_offset, dev_len, !ios->reading);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ORE_DBGMSG",
          "args": [
            "\"start read offset passed end of file \"\n\t\t\t\t\"offset=0x%llx, length=0x%llx\\n\"",
            "_LLU(per_dev->offset)",
            "_LLU(per_dev->length)"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "per_dev->length"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "per_dev->offset"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_clear_bio",
          "args": [
            "per_dev->bio"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "_clear_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "405-418",
          "snippet": "static void _clear_bio(struct bio *bio)\n{\n\tstruct bio_vec *bv;\n\tunsigned i;\n\n\tbio_for_each_segment_all(bv, bio, i) {\n\t\tunsigned this_count = bv->bv_len;\n\n\t\tif (likely(PAGE_SIZE == this_count))\n\t\t\tclear_highpage(bv->bv_page);\n\t\telse\n\t\t\tzero_user(bv->bv_page, bv->bv_offset, this_count);\n\t}\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic void _clear_bio(struct bio *bio)\n{\n\tstruct bio_vec *bv;\n\tunsigned i;\n\n\tbio_for_each_segment_all(bv, bio, i) {\n\t\tunsigned this_count = bv->bv_len;\n\n\t\tif (likely(PAGE_SIZE == this_count))\n\t\t\tclear_highpage(bv->bv_page);\n\t\telse\n\t\t\tzero_user(bv->bv_page, bv->bv_offset, this_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ret"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osd_req_decode_sense",
          "args": [
            "or",
            "&osi"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!or"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint ore_check_io(struct ore_io_state *ios, ore_on_dev_error on_dev_error)\n{\n\tenum osd_err_priority acumulated_osd_err = 0;\n\tint acumulated_lin_err = 0;\n\tint i;\n\n\tfor (i = 0; i < ios->numdevs; i++) {\n\t\tstruct osd_sense_info osi;\n\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\t\tstruct osd_request *or = per_dev->or;\n\t\tint ret;\n\n\t\tif (unlikely(!or))\n\t\t\tcontinue;\n\n\t\tret = osd_req_decode_sense(or, &osi);\n\t\tif (likely(!ret))\n\t\t\tcontinue;\n\n\t\tif ((OSD_ERR_PRI_CLEAR_PAGES == osi.osd_err_pri) &&\n\t\t    per_dev->bio) {\n\t\t\t/* start read offset passed endof file.\n\t\t\t * Note: if we do not have bio it means read-attributes\n\t\t\t * In this case we should return error to caller.\n\t\t\t */\n\t\t\t_clear_bio(per_dev->bio);\n\t\t\tORE_DBGMSG(\"start read offset passed end of file \"\n\t\t\t\t\"offset=0x%llx, length=0x%llx\\n\",\n\t\t\t\t_LLU(per_dev->offset),\n\t\t\t\t_LLU(per_dev->length));\n\n\t\t\tcontinue; /* we recovered */\n\t\t}\n\n\t\tif (on_dev_error) {\n\t\t\tu64 residual = ios->reading ?\n\t\t\t\t\tor->in.residual : or->out.residual;\n\t\t\tu64 offset = (ios->offset + ios->length) - residual;\n\t\t\tunsigned dev = per_dev->dev - ios->oc->first_dev;\n\t\t\tstruct ore_dev *od = ios->oc->ods[dev];\n\n\t\t\ton_dev_error(ios, od, dev, osi.osd_err_pri,\n\t\t\t\t     offset, residual);\n\t\t}\n\t\tif (osi.osd_err_pri >= acumulated_osd_err) {\n\t\t\tacumulated_osd_err = osi.osd_err_pri;\n\t\t\tacumulated_lin_err = ret;\n\t\t}\n\t}\n\n\treturn acumulated_lin_err;\n}"
  },
  {
    "function_name": "_clear_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "405-418",
    "snippet": "static void _clear_bio(struct bio *bio)\n{\n\tstruct bio_vec *bv;\n\tunsigned i;\n\n\tbio_for_each_segment_all(bv, bio, i) {\n\t\tunsigned this_count = bv->bv_len;\n\n\t\tif (likely(PAGE_SIZE == this_count))\n\t\t\tclear_highpage(bv->bv_page);\n\t\telse\n\t\t\tzero_user(bv->bv_page, bv->bv_offset, this_count);\n\t}\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "bv->bv_page",
            "bv->bv_offset",
            "this_count"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_highpage",
          "args": [
            "bv->bv_page"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "PAGE_SIZE == this_count"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_for_each_segment_all",
          "args": [
            "bv",
            "bio",
            "i"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic void _clear_bio(struct bio *bio)\n{\n\tstruct bio_vec *bv;\n\tunsigned i;\n\n\tbio_for_each_segment_all(bv, bio, i) {\n\t\tunsigned this_count = bv->bv_len;\n\n\t\tif (likely(PAGE_SIZE == this_count))\n\t\t\tclear_highpage(bv->bv_page);\n\t\telse\n\t\t\tzero_user(bv->bv_page, bv->bv_offset, this_count);\n\t}\n}"
  },
  {
    "function_name": "ore_io_execute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "360-403",
    "snippet": "int ore_io_execute(struct ore_io_state *ios)\n{\n\tDECLARE_COMPLETION_ONSTACK(wait);\n\tbool sync = (ios->done == NULL);\n\tint i, ret;\n\n\tif (sync) {\n\t\tios->done = _sync_done;\n\t\tios->private = &wait;\n\t}\n\n\tfor (i = 0; i < ios->numdevs; i++) {\n\t\tstruct osd_request *or = ios->per_dev[i].or;\n\t\tif (unlikely(!or))\n\t\t\tcontinue;\n\n\t\tret = osd_finalize_request(or, 0, _ios_cred(ios, i), NULL);\n\t\tif (unlikely(ret)) {\n\t\t\tORE_DBGMSG(\"Failed to osd_finalize_request() => %d\\n\",\n\t\t\t\t     ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tkref_init(&ios->kref);\n\n\tfor (i = 0; i < ios->numdevs; i++) {\n\t\tstruct osd_request *or = ios->per_dev[i].or;\n\t\tif (unlikely(!or))\n\t\t\tcontinue;\n\n\t\tkref_get(&ios->kref);\n\t\tosd_execute_request_async(or, _done_io, ios);\n\t}\n\n\tkref_put(&ios->kref, _last_io);\n\tret = 0;\n\n\tif (sync) {\n\t\twait_for_completion(&wait);\n\t\tret = ore_check_io(ios, NULL);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ore_check_io",
          "args": [
            "ios",
            "NULL"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "ore_check_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "420-471",
          "snippet": "int ore_check_io(struct ore_io_state *ios, ore_on_dev_error on_dev_error)\n{\n\tenum osd_err_priority acumulated_osd_err = 0;\n\tint acumulated_lin_err = 0;\n\tint i;\n\n\tfor (i = 0; i < ios->numdevs; i++) {\n\t\tstruct osd_sense_info osi;\n\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\t\tstruct osd_request *or = per_dev->or;\n\t\tint ret;\n\n\t\tif (unlikely(!or))\n\t\t\tcontinue;\n\n\t\tret = osd_req_decode_sense(or, &osi);\n\t\tif (likely(!ret))\n\t\t\tcontinue;\n\n\t\tif ((OSD_ERR_PRI_CLEAR_PAGES == osi.osd_err_pri) &&\n\t\t    per_dev->bio) {\n\t\t\t/* start read offset passed endof file.\n\t\t\t * Note: if we do not have bio it means read-attributes\n\t\t\t * In this case we should return error to caller.\n\t\t\t */\n\t\t\t_clear_bio(per_dev->bio);\n\t\t\tORE_DBGMSG(\"start read offset passed end of file \"\n\t\t\t\t\"offset=0x%llx, length=0x%llx\\n\",\n\t\t\t\t_LLU(per_dev->offset),\n\t\t\t\t_LLU(per_dev->length));\n\n\t\t\tcontinue; /* we recovered */\n\t\t}\n\n\t\tif (on_dev_error) {\n\t\t\tu64 residual = ios->reading ?\n\t\t\t\t\tor->in.residual : or->out.residual;\n\t\t\tu64 offset = (ios->offset + ios->length) - residual;\n\t\t\tunsigned dev = per_dev->dev - ios->oc->first_dev;\n\t\t\tstruct ore_dev *od = ios->oc->ods[dev];\n\n\t\t\ton_dev_error(ios, od, dev, osi.osd_err_pri,\n\t\t\t\t     offset, residual);\n\t\t}\n\t\tif (osi.osd_err_pri >= acumulated_osd_err) {\n\t\t\tacumulated_osd_err = osi.osd_err_pri;\n\t\t\tacumulated_lin_err = ret;\n\t\t}\n\t}\n\n\treturn acumulated_lin_err;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint ore_check_io(struct ore_io_state *ios, ore_on_dev_error on_dev_error)\n{\n\tenum osd_err_priority acumulated_osd_err = 0;\n\tint acumulated_lin_err = 0;\n\tint i;\n\n\tfor (i = 0; i < ios->numdevs; i++) {\n\t\tstruct osd_sense_info osi;\n\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\t\tstruct osd_request *or = per_dev->or;\n\t\tint ret;\n\n\t\tif (unlikely(!or))\n\t\t\tcontinue;\n\n\t\tret = osd_req_decode_sense(or, &osi);\n\t\tif (likely(!ret))\n\t\t\tcontinue;\n\n\t\tif ((OSD_ERR_PRI_CLEAR_PAGES == osi.osd_err_pri) &&\n\t\t    per_dev->bio) {\n\t\t\t/* start read offset passed endof file.\n\t\t\t * Note: if we do not have bio it means read-attributes\n\t\t\t * In this case we should return error to caller.\n\t\t\t */\n\t\t\t_clear_bio(per_dev->bio);\n\t\t\tORE_DBGMSG(\"start read offset passed end of file \"\n\t\t\t\t\"offset=0x%llx, length=0x%llx\\n\",\n\t\t\t\t_LLU(per_dev->offset),\n\t\t\t\t_LLU(per_dev->length));\n\n\t\t\tcontinue; /* we recovered */\n\t\t}\n\n\t\tif (on_dev_error) {\n\t\t\tu64 residual = ios->reading ?\n\t\t\t\t\tor->in.residual : or->out.residual;\n\t\t\tu64 offset = (ios->offset + ios->length) - residual;\n\t\t\tunsigned dev = per_dev->dev - ios->oc->first_dev;\n\t\t\tstruct ore_dev *od = ios->oc->ods[dev];\n\n\t\t\ton_dev_error(ios, od, dev, osi.osd_err_pri,\n\t\t\t\t     offset, residual);\n\t\t}\n\t\tif (osi.osd_err_pri >= acumulated_osd_err) {\n\t\t\tacumulated_osd_err = osi.osd_err_pri;\n\t\t\tacumulated_lin_err = ret;\n\t\t}\n\t}\n\n\treturn acumulated_lin_err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&wait"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_for_completion_rpc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "1116-1122",
          "snippet": "static int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&ios->kref",
            "_last_io"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osd_execute_request_async",
          "args": [
            "or",
            "_done_io",
            "ios"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&ios->kref"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!or"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&ios->kref"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ORE_DBGMSG",
          "args": [
            "\"Failed to osd_finalize_request() => %d\\n\"",
            "ret"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osd_finalize_request",
          "args": [
            "or",
            "0",
            "_ios_cred(ios, i)",
            "NULL"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ios_cred",
          "args": [
            "ios",
            "i"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "_ios_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "124-127",
          "snippet": "static u8 *_ios_cred(struct ore_io_state *ios, unsigned index)\n{\n\treturn ios->oc->comps[index & ios->oc->single_comp].cred;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic u8 *_ios_cred(struct ore_io_state *ios, unsigned index)\n{\n\treturn ios->oc->comps[index & ios->oc->single_comp].cred;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!or"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_COMPLETION_ONSTACK",
          "args": [
            "wait"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint ore_io_execute(struct ore_io_state *ios)\n{\n\tDECLARE_COMPLETION_ONSTACK(wait);\n\tbool sync = (ios->done == NULL);\n\tint i, ret;\n\n\tif (sync) {\n\t\tios->done = _sync_done;\n\t\tios->private = &wait;\n\t}\n\n\tfor (i = 0; i < ios->numdevs; i++) {\n\t\tstruct osd_request *or = ios->per_dev[i].or;\n\t\tif (unlikely(!or))\n\t\t\tcontinue;\n\n\t\tret = osd_finalize_request(or, 0, _ios_cred(ios, i), NULL);\n\t\tif (unlikely(ret)) {\n\t\t\tORE_DBGMSG(\"Failed to osd_finalize_request() => %d\\n\",\n\t\t\t\t     ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tkref_init(&ios->kref);\n\n\tfor (i = 0; i < ios->numdevs; i++) {\n\t\tstruct osd_request *or = ios->per_dev[i].or;\n\t\tif (unlikely(!or))\n\t\t\tcontinue;\n\n\t\tkref_get(&ios->kref);\n\t\tosd_execute_request_async(or, _done_io, ios);\n\t}\n\n\tkref_put(&ios->kref, _last_io);\n\tret = 0;\n\n\tif (sync) {\n\t\twait_for_completion(&wait);\n\t\tret = ore_check_io(ios, NULL);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "_done_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "353-358",
    "snippet": "static void _done_io(struct osd_request *or, void *p)\n{\n\tstruct ore_io_state *ios = p;\n\n\tkref_put(&ios->kref, _last_io);\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&ios->kref",
            "_last_io"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic void _done_io(struct osd_request *or, void *p)\n{\n\tstruct ore_io_state *ios = p;\n\n\tkref_put(&ios->kref, _last_io);\n}"
  },
  {
    "function_name": "_last_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "345-351",
    "snippet": "static void _last_io(struct kref *kref)\n{\n\tstruct ore_io_state *ios = container_of(\n\t\t\t\t\tkref, struct ore_io_state, kref);\n\n\tios->done(ios, ios->private);\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ios->done",
          "args": [
            "ios",
            "ios->private"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structore_io_state",
            "kref"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic void _last_io(struct kref *kref)\n{\n\tstruct ore_io_state *ios = container_of(\n\t\t\t\t\tkref, struct ore_io_state, kref);\n\n\tios->done(ios, ios->private);\n}"
  },
  {
    "function_name": "_sync_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "338-343",
    "snippet": "static void _sync_done(struct ore_io_state *ios, void *p)\n{\n\tstruct completion *waiting = p;\n\n\tcomplete(waiting);\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "waiting"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "dio_aio_complete_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/direct-io.c",
          "lines": "275-280",
          "snippet": "static void dio_aio_complete_work(struct work_struct *work)\n{\n\tstruct dio *dio = container_of(work, struct dio, complete_work);\n\n\tdio_complete(dio, dio->iocb->ki_pos, 0, true);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uio.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/err.h>",
            "#include <linux/wait.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/prefetch.h>\n#include <linux/atomic.h>\n#include <linux/uio.h>\n#include <linux/rwsem.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/err.h>\n#include <linux/wait.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void dio_aio_complete_work(struct work_struct *work)\n{\n\tstruct dio *dio = container_of(work, struct dio, complete_work);\n\n\tdio_complete(dio, dio->iocb->ki_pos, 0, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic void _sync_done(struct ore_io_state *ios, void *p)\n{\n\tstruct completion *waiting = p;\n\n\tcomplete(waiting);\n}"
  },
  {
    "function_name": "ore_put_io_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "318-335",
    "snippet": "void ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ios"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ore_free_raid_stuff",
          "args": [
            "ios"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "_ore_free_raid_stuff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "698-721",
          "snippet": "void _ore_free_raid_stuff(struct ore_io_state *ios)\n{\n\tif (ios->sp2d) { /* writing and raid */\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->cur_par_page; i++) {\n\t\t\tstruct page *page = ios->parity_pages[i];\n\n\t\t\tif (page)\n\t\t\t\t_raid_page_free(page);\n\t\t}\n\t\tif (ios->extra_part_alloc)\n\t\t\tkfree(ios->parity_pages);\n\t\t/* If IO returned an error pages might need unlocking */\n\t\t_sp2d_reset(ios->sp2d, ios->r4w, ios->private);\n\t\t_sp2d_free(ios->sp2d);\n\t} else {\n\t\t/* Will only be set if raid reading && sglist is big */\n\t\tif (ios->extra_part_alloc)\n\t\t\tkfree(ios->per_dev[0].sglist);\n\t}\n\tif (ios->ios_read_4_write)\n\t\tore_put_io_state(ios->ios_read_4_write);\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nvoid _ore_free_raid_stuff(struct ore_io_state *ios)\n{\n\tif (ios->sp2d) { /* writing and raid */\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->cur_par_page; i++) {\n\t\t\tstruct page *page = ios->parity_pages[i];\n\n\t\t\tif (page)\n\t\t\t\t_raid_page_free(page);\n\t\t}\n\t\tif (ios->extra_part_alloc)\n\t\t\tkfree(ios->parity_pages);\n\t\t/* If IO returned an error pages might need unlocking */\n\t\t_sp2d_reset(ios->sp2d, ios->r4w, ios->private);\n\t\t_sp2d_free(ios->sp2d);\n\t} else {\n\t\t/* Will only be set if raid reading && sglist is big */\n\t\tif (ios->extra_part_alloc)\n\t\t\tkfree(ios->per_dev[0].sglist);\n\t}\n\tif (ios->ios_read_4_write)\n\t\tore_put_io_state(ios->ios_read_4_write);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "per_dev->bio"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osd_end_request",
          "args": [
            "per_dev->or"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nvoid ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}"
  },
  {
    "function_name": "ore_get_io_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "311-315",
    "snippet": "int  ore_get_io_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      struct ore_io_state **pios)\n{\n\treturn _ore_get_io_state(layout, oc, oc->numdevs, 0, 0, pios);\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ore_get_io_state",
          "args": [
            "layout",
            "oc",
            "oc->numdevs",
            "0",
            "0",
            "pios"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "_ore_get_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "143-224",
          "snippet": "int  _ore_get_io_state(struct ore_layout *layout,\n\t\t\tstruct ore_components *oc, unsigned numdevs,\n\t\t\tunsigned sgs_per_dev, unsigned num_par_pages,\n\t\t\tstruct ore_io_state **pios)\n{\n\tstruct ore_io_state *ios;\n\tstruct page **pages;\n\tstruct osd_sg_entry *sgilist;\n\tstruct __alloc_all_io_state {\n\t\tstruct ore_io_state ios;\n\t\tstruct ore_per_dev_state per_dev[numdevs];\n\t\tunion {\n\t\t\tstruct osd_sg_entry sglist[sgs_per_dev * numdevs];\n\t\t\tstruct page *pages[num_par_pages];\n\t\t};\n\t} *_aios;\n\n\tif (likely(sizeof(*_aios) <= PAGE_SIZE)) {\n\t\t_aios = kzalloc(sizeof(*_aios), GFP_KERNEL);\n\t\tif (unlikely(!_aios)) {\n\t\t\tORE_DBGMSG(\"Failed kzalloc bytes=%zd\\n\",\n\t\t\t\t   sizeof(*_aios));\n\t\t\t*pios = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpages = num_par_pages ? _aios->pages : NULL;\n\t\tsgilist = sgs_per_dev ? _aios->sglist : NULL;\n\t\tios = &_aios->ios;\n\t} else {\n\t\tstruct __alloc_small_io_state {\n\t\t\tstruct ore_io_state ios;\n\t\t\tstruct ore_per_dev_state per_dev[numdevs];\n\t\t} *_aio_small;\n\t\tunion __extra_part {\n\t\t\tstruct osd_sg_entry sglist[sgs_per_dev * numdevs];\n\t\t\tstruct page *pages[num_par_pages];\n\t\t} *extra_part;\n\n\t\t_aio_small = kzalloc(sizeof(*_aio_small), GFP_KERNEL);\n\t\tif (unlikely(!_aio_small)) {\n\t\t\tORE_DBGMSG(\"Failed alloc first part bytes=%zd\\n\",\n\t\t\t\t   sizeof(*_aio_small));\n\t\t\t*pios = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\textra_part = kzalloc(sizeof(*extra_part), GFP_KERNEL);\n\t\tif (unlikely(!extra_part)) {\n\t\t\tORE_DBGMSG(\"Failed alloc second part bytes=%zd\\n\",\n\t\t\t\t   sizeof(*extra_part));\n\t\t\tkfree(_aio_small);\n\t\t\t*pios = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpages = num_par_pages ? extra_part->pages : NULL;\n\t\tsgilist = sgs_per_dev ? extra_part->sglist : NULL;\n\t\t/* In this case the per_dev[0].sgilist holds the pointer to\n\t\t * be freed\n\t\t */\n\t\tios = &_aio_small->ios;\n\t\tios->extra_part_alloc = true;\n\t}\n\n\tif (pages) {\n\t\tios->parity_pages = pages;\n\t\tios->max_par_pages = num_par_pages;\n\t}\n\tif (sgilist) {\n\t\tunsigned d;\n\n\t\tfor (d = 0; d < numdevs; ++d) {\n\t\t\tios->per_dev[d].sglist = sgilist;\n\t\t\tsgilist += sgs_per_dev;\n\t\t}\n\t\tios->sgs_per_dev = sgs_per_dev;\n\t}\n\n\tios->layout = layout;\n\tios->oc = oc;\n\t*pios = ios;\n\treturn 0;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint  _ore_get_io_state(struct ore_layout *layout,\n\t\t\tstruct ore_components *oc, unsigned numdevs,\n\t\t\tunsigned sgs_per_dev, unsigned num_par_pages,\n\t\t\tstruct ore_io_state **pios)\n{\n\tstruct ore_io_state *ios;\n\tstruct page **pages;\n\tstruct osd_sg_entry *sgilist;\n\tstruct __alloc_all_io_state {\n\t\tstruct ore_io_state ios;\n\t\tstruct ore_per_dev_state per_dev[numdevs];\n\t\tunion {\n\t\t\tstruct osd_sg_entry sglist[sgs_per_dev * numdevs];\n\t\t\tstruct page *pages[num_par_pages];\n\t\t};\n\t} *_aios;\n\n\tif (likely(sizeof(*_aios) <= PAGE_SIZE)) {\n\t\t_aios = kzalloc(sizeof(*_aios), GFP_KERNEL);\n\t\tif (unlikely(!_aios)) {\n\t\t\tORE_DBGMSG(\"Failed kzalloc bytes=%zd\\n\",\n\t\t\t\t   sizeof(*_aios));\n\t\t\t*pios = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpages = num_par_pages ? _aios->pages : NULL;\n\t\tsgilist = sgs_per_dev ? _aios->sglist : NULL;\n\t\tios = &_aios->ios;\n\t} else {\n\t\tstruct __alloc_small_io_state {\n\t\t\tstruct ore_io_state ios;\n\t\t\tstruct ore_per_dev_state per_dev[numdevs];\n\t\t} *_aio_small;\n\t\tunion __extra_part {\n\t\t\tstruct osd_sg_entry sglist[sgs_per_dev * numdevs];\n\t\t\tstruct page *pages[num_par_pages];\n\t\t} *extra_part;\n\n\t\t_aio_small = kzalloc(sizeof(*_aio_small), GFP_KERNEL);\n\t\tif (unlikely(!_aio_small)) {\n\t\t\tORE_DBGMSG(\"Failed alloc first part bytes=%zd\\n\",\n\t\t\t\t   sizeof(*_aio_small));\n\t\t\t*pios = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\textra_part = kzalloc(sizeof(*extra_part), GFP_KERNEL);\n\t\tif (unlikely(!extra_part)) {\n\t\t\tORE_DBGMSG(\"Failed alloc second part bytes=%zd\\n\",\n\t\t\t\t   sizeof(*extra_part));\n\t\t\tkfree(_aio_small);\n\t\t\t*pios = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpages = num_par_pages ? extra_part->pages : NULL;\n\t\tsgilist = sgs_per_dev ? extra_part->sglist : NULL;\n\t\t/* In this case the per_dev[0].sgilist holds the pointer to\n\t\t * be freed\n\t\t */\n\t\tios = &_aio_small->ios;\n\t\tios->extra_part_alloc = true;\n\t}\n\n\tif (pages) {\n\t\tios->parity_pages = pages;\n\t\tios->max_par_pages = num_par_pages;\n\t}\n\tif (sgilist) {\n\t\tunsigned d;\n\n\t\tfor (d = 0; d < numdevs; ++d) {\n\t\t\tios->per_dev[d].sglist = sgilist;\n\t\t\tsgilist += sgs_per_dev;\n\t\t}\n\t\tios->sgs_per_dev = sgs_per_dev;\n\t}\n\n\tios->layout = layout;\n\tios->oc = oc;\n\t*pios = ios;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint  ore_get_io_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      struct ore_io_state **pios)\n{\n\treturn _ore_get_io_state(layout, oc, oc->numdevs, 0, 0, pios);\n}"
  },
  {
    "function_name": "ore_get_rw_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "242-301",
    "snippet": "int  ore_get_rw_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      bool is_reading, u64 offset, u64 length,\n\t\t      struct ore_io_state **pios)\n{\n\tstruct ore_io_state *ios;\n\tunsigned numdevs = layout->group_width * layout->mirrors_p1;\n\tunsigned sgs_per_dev = 0, max_par_pages = 0;\n\tint ret;\n\n\tif (layout->parity && length) {\n\t\tunsigned data_devs = layout->group_width - layout->parity;\n\t\tunsigned stripe_size = layout->stripe_unit * data_devs;\n\t\tunsigned pages_in_unit = layout->stripe_unit / PAGE_SIZE;\n\t\tu32 remainder;\n\t\tu64 num_stripes;\n\t\tu64 num_raid_units;\n\n\t\tnum_stripes = div_u64_rem(length, stripe_size, &remainder);\n\t\tif (remainder)\n\t\t\t++num_stripes;\n\n\t\tnum_raid_units =  num_stripes * layout->parity;\n\n\t\tif (is_reading) {\n\t\t\t/* For reads add per_dev sglist array */\n\t\t\t/* TODO: Raid 6 we need twice more. Actually:\n\t\t\t*         num_stripes / LCMdP(W,P);\n\t\t\t*         if (W%P != 0) num_stripes *= parity;\n\t\t\t*/\n\n\t\t\t/* first/last seg is split */\n\t\t\tnum_raid_units += layout->group_width;\n\t\t\tsgs_per_dev = div_u64(num_raid_units, data_devs) + 2;\n\t\t} else {\n\t\t\t/* For Writes add parity pages array. */\n\t\t\tmax_par_pages = num_raid_units * pages_in_unit *\n\t\t\t\t\t\tsizeof(struct page *);\n\t\t}\n\t}\n\n\tret = _ore_get_io_state(layout, oc, numdevs, sgs_per_dev, max_par_pages,\n\t\t\t\tpios);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tios = *pios;\n\tios->reading = is_reading;\n\tios->offset = offset;\n\n\tif (length) {\n\t\tore_calc_stripe_info(layout, offset, length, &ios->si);\n\t\tios->length = ios->si.length;\n\t\tios->nr_pages = ((ios->offset & (PAGE_SIZE - 1)) +\n\t\t\t\t ios->length + PAGE_SIZE - 1) / PAGE_SIZE;\n\t\tif (layout->parity)\n\t\t\t_ore_post_alloc_raid_stuff(ios);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ore_post_alloc_raid_stuff",
          "args": [
            "ios"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "_ore_post_alloc_raid_stuff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore_raid.c",
          "lines": "684-696",
          "snippet": "int _ore_post_alloc_raid_stuff(struct ore_io_state *ios)\n{\n\tif (ios->parity_pages) {\n\t\tstruct ore_layout *layout = ios->layout;\n\t\tunsigned pages_in_unit = layout->stripe_unit / PAGE_SIZE;\n\n\t\tif (_sp2d_alloc(pages_in_unit, layout->group_width,\n\t\t\t\tlayout->parity, &ios->sp2d)) {\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/async_tx.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/async_tx.h>\n#include <linux/gfp.h>\n\nint _ore_post_alloc_raid_stuff(struct ore_io_state *ios)\n{\n\tif (ios->parity_pages) {\n\t\tstruct ore_layout *layout = ios->layout;\n\t\tunsigned pages_in_unit = layout->stripe_unit / PAGE_SIZE;\n\n\t\tif (_sp2d_alloc(pages_in_unit, layout->group_width,\n\t\t\t\tlayout->parity, &ios->sp2d)) {\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ore_calc_stripe_info",
          "args": [
            "layout",
            "offset",
            "length",
            "&ios->si"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ore_get_io_state",
          "args": [
            "layout",
            "oc",
            "numdevs",
            "sgs_per_dev",
            "max_par_pages",
            "pios"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "_ore_get_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "143-224",
          "snippet": "int  _ore_get_io_state(struct ore_layout *layout,\n\t\t\tstruct ore_components *oc, unsigned numdevs,\n\t\t\tunsigned sgs_per_dev, unsigned num_par_pages,\n\t\t\tstruct ore_io_state **pios)\n{\n\tstruct ore_io_state *ios;\n\tstruct page **pages;\n\tstruct osd_sg_entry *sgilist;\n\tstruct __alloc_all_io_state {\n\t\tstruct ore_io_state ios;\n\t\tstruct ore_per_dev_state per_dev[numdevs];\n\t\tunion {\n\t\t\tstruct osd_sg_entry sglist[sgs_per_dev * numdevs];\n\t\t\tstruct page *pages[num_par_pages];\n\t\t};\n\t} *_aios;\n\n\tif (likely(sizeof(*_aios) <= PAGE_SIZE)) {\n\t\t_aios = kzalloc(sizeof(*_aios), GFP_KERNEL);\n\t\tif (unlikely(!_aios)) {\n\t\t\tORE_DBGMSG(\"Failed kzalloc bytes=%zd\\n\",\n\t\t\t\t   sizeof(*_aios));\n\t\t\t*pios = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpages = num_par_pages ? _aios->pages : NULL;\n\t\tsgilist = sgs_per_dev ? _aios->sglist : NULL;\n\t\tios = &_aios->ios;\n\t} else {\n\t\tstruct __alloc_small_io_state {\n\t\t\tstruct ore_io_state ios;\n\t\t\tstruct ore_per_dev_state per_dev[numdevs];\n\t\t} *_aio_small;\n\t\tunion __extra_part {\n\t\t\tstruct osd_sg_entry sglist[sgs_per_dev * numdevs];\n\t\t\tstruct page *pages[num_par_pages];\n\t\t} *extra_part;\n\n\t\t_aio_small = kzalloc(sizeof(*_aio_small), GFP_KERNEL);\n\t\tif (unlikely(!_aio_small)) {\n\t\t\tORE_DBGMSG(\"Failed alloc first part bytes=%zd\\n\",\n\t\t\t\t   sizeof(*_aio_small));\n\t\t\t*pios = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\textra_part = kzalloc(sizeof(*extra_part), GFP_KERNEL);\n\t\tif (unlikely(!extra_part)) {\n\t\t\tORE_DBGMSG(\"Failed alloc second part bytes=%zd\\n\",\n\t\t\t\t   sizeof(*extra_part));\n\t\t\tkfree(_aio_small);\n\t\t\t*pios = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpages = num_par_pages ? extra_part->pages : NULL;\n\t\tsgilist = sgs_per_dev ? extra_part->sglist : NULL;\n\t\t/* In this case the per_dev[0].sgilist holds the pointer to\n\t\t * be freed\n\t\t */\n\t\tios = &_aio_small->ios;\n\t\tios->extra_part_alloc = true;\n\t}\n\n\tif (pages) {\n\t\tios->parity_pages = pages;\n\t\tios->max_par_pages = num_par_pages;\n\t}\n\tif (sgilist) {\n\t\tunsigned d;\n\n\t\tfor (d = 0; d < numdevs; ++d) {\n\t\t\tios->per_dev[d].sglist = sgilist;\n\t\t\tsgilist += sgs_per_dev;\n\t\t}\n\t\tios->sgs_per_dev = sgs_per_dev;\n\t}\n\n\tios->layout = layout;\n\tios->oc = oc;\n\t*pios = ios;\n\treturn 0;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint  _ore_get_io_state(struct ore_layout *layout,\n\t\t\tstruct ore_components *oc, unsigned numdevs,\n\t\t\tunsigned sgs_per_dev, unsigned num_par_pages,\n\t\t\tstruct ore_io_state **pios)\n{\n\tstruct ore_io_state *ios;\n\tstruct page **pages;\n\tstruct osd_sg_entry *sgilist;\n\tstruct __alloc_all_io_state {\n\t\tstruct ore_io_state ios;\n\t\tstruct ore_per_dev_state per_dev[numdevs];\n\t\tunion {\n\t\t\tstruct osd_sg_entry sglist[sgs_per_dev * numdevs];\n\t\t\tstruct page *pages[num_par_pages];\n\t\t};\n\t} *_aios;\n\n\tif (likely(sizeof(*_aios) <= PAGE_SIZE)) {\n\t\t_aios = kzalloc(sizeof(*_aios), GFP_KERNEL);\n\t\tif (unlikely(!_aios)) {\n\t\t\tORE_DBGMSG(\"Failed kzalloc bytes=%zd\\n\",\n\t\t\t\t   sizeof(*_aios));\n\t\t\t*pios = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpages = num_par_pages ? _aios->pages : NULL;\n\t\tsgilist = sgs_per_dev ? _aios->sglist : NULL;\n\t\tios = &_aios->ios;\n\t} else {\n\t\tstruct __alloc_small_io_state {\n\t\t\tstruct ore_io_state ios;\n\t\t\tstruct ore_per_dev_state per_dev[numdevs];\n\t\t} *_aio_small;\n\t\tunion __extra_part {\n\t\t\tstruct osd_sg_entry sglist[sgs_per_dev * numdevs];\n\t\t\tstruct page *pages[num_par_pages];\n\t\t} *extra_part;\n\n\t\t_aio_small = kzalloc(sizeof(*_aio_small), GFP_KERNEL);\n\t\tif (unlikely(!_aio_small)) {\n\t\t\tORE_DBGMSG(\"Failed alloc first part bytes=%zd\\n\",\n\t\t\t\t   sizeof(*_aio_small));\n\t\t\t*pios = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\textra_part = kzalloc(sizeof(*extra_part), GFP_KERNEL);\n\t\tif (unlikely(!extra_part)) {\n\t\t\tORE_DBGMSG(\"Failed alloc second part bytes=%zd\\n\",\n\t\t\t\t   sizeof(*extra_part));\n\t\t\tkfree(_aio_small);\n\t\t\t*pios = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpages = num_par_pages ? extra_part->pages : NULL;\n\t\tsgilist = sgs_per_dev ? extra_part->sglist : NULL;\n\t\t/* In this case the per_dev[0].sgilist holds the pointer to\n\t\t * be freed\n\t\t */\n\t\tios = &_aio_small->ios;\n\t\tios->extra_part_alloc = true;\n\t}\n\n\tif (pages) {\n\t\tios->parity_pages = pages;\n\t\tios->max_par_pages = num_par_pages;\n\t}\n\tif (sgilist) {\n\t\tunsigned d;\n\n\t\tfor (d = 0; d < numdevs; ++d) {\n\t\t\tios->per_dev[d].sglist = sgilist;\n\t\t\tsgilist += sgs_per_dev;\n\t\t}\n\t\tios->sgs_per_dev = sgs_per_dev;\n\t}\n\n\tios->layout = layout;\n\tios->oc = oc;\n\t*pios = ios;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "num_raid_units",
            "data_devs"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64_rem",
          "args": [
            "length",
            "stripe_size",
            "&remainder"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint  ore_get_rw_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      bool is_reading, u64 offset, u64 length,\n\t\t      struct ore_io_state **pios)\n{\n\tstruct ore_io_state *ios;\n\tunsigned numdevs = layout->group_width * layout->mirrors_p1;\n\tunsigned sgs_per_dev = 0, max_par_pages = 0;\n\tint ret;\n\n\tif (layout->parity && length) {\n\t\tunsigned data_devs = layout->group_width - layout->parity;\n\t\tunsigned stripe_size = layout->stripe_unit * data_devs;\n\t\tunsigned pages_in_unit = layout->stripe_unit / PAGE_SIZE;\n\t\tu32 remainder;\n\t\tu64 num_stripes;\n\t\tu64 num_raid_units;\n\n\t\tnum_stripes = div_u64_rem(length, stripe_size, &remainder);\n\t\tif (remainder)\n\t\t\t++num_stripes;\n\n\t\tnum_raid_units =  num_stripes * layout->parity;\n\n\t\tif (is_reading) {\n\t\t\t/* For reads add per_dev sglist array */\n\t\t\t/* TODO: Raid 6 we need twice more. Actually:\n\t\t\t*         num_stripes / LCMdP(W,P);\n\t\t\t*         if (W%P != 0) num_stripes *= parity;\n\t\t\t*/\n\n\t\t\t/* first/last seg is split */\n\t\t\tnum_raid_units += layout->group_width;\n\t\t\tsgs_per_dev = div_u64(num_raid_units, data_devs) + 2;\n\t\t} else {\n\t\t\t/* For Writes add parity pages array. */\n\t\t\tmax_par_pages = num_raid_units * pages_in_unit *\n\t\t\t\t\t\tsizeof(struct page *);\n\t\t}\n\t}\n\n\tret = _ore_get_io_state(layout, oc, numdevs, sgs_per_dev, max_par_pages,\n\t\t\t\tpios);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tios = *pios;\n\tios->reading = is_reading;\n\tios->offset = offset;\n\n\tif (length) {\n\t\tore_calc_stripe_info(layout, offset, length, &ios->si);\n\t\tios->length = ios->si.length;\n\t\tios->nr_pages = ((ios->offset & (PAGE_SIZE - 1)) +\n\t\t\t\t ios->length + PAGE_SIZE - 1) / PAGE_SIZE;\n\t\tif (layout->parity)\n\t\t\t_ore_post_alloc_raid_stuff(ios);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "_ore_get_io_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "143-224",
    "snippet": "int  _ore_get_io_state(struct ore_layout *layout,\n\t\t\tstruct ore_components *oc, unsigned numdevs,\n\t\t\tunsigned sgs_per_dev, unsigned num_par_pages,\n\t\t\tstruct ore_io_state **pios)\n{\n\tstruct ore_io_state *ios;\n\tstruct page **pages;\n\tstruct osd_sg_entry *sgilist;\n\tstruct __alloc_all_io_state {\n\t\tstruct ore_io_state ios;\n\t\tstruct ore_per_dev_state per_dev[numdevs];\n\t\tunion {\n\t\t\tstruct osd_sg_entry sglist[sgs_per_dev * numdevs];\n\t\t\tstruct page *pages[num_par_pages];\n\t\t};\n\t} *_aios;\n\n\tif (likely(sizeof(*_aios) <= PAGE_SIZE)) {\n\t\t_aios = kzalloc(sizeof(*_aios), GFP_KERNEL);\n\t\tif (unlikely(!_aios)) {\n\t\t\tORE_DBGMSG(\"Failed kzalloc bytes=%zd\\n\",\n\t\t\t\t   sizeof(*_aios));\n\t\t\t*pios = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpages = num_par_pages ? _aios->pages : NULL;\n\t\tsgilist = sgs_per_dev ? _aios->sglist : NULL;\n\t\tios = &_aios->ios;\n\t} else {\n\t\tstruct __alloc_small_io_state {\n\t\t\tstruct ore_io_state ios;\n\t\t\tstruct ore_per_dev_state per_dev[numdevs];\n\t\t} *_aio_small;\n\t\tunion __extra_part {\n\t\t\tstruct osd_sg_entry sglist[sgs_per_dev * numdevs];\n\t\t\tstruct page *pages[num_par_pages];\n\t\t} *extra_part;\n\n\t\t_aio_small = kzalloc(sizeof(*_aio_small), GFP_KERNEL);\n\t\tif (unlikely(!_aio_small)) {\n\t\t\tORE_DBGMSG(\"Failed alloc first part bytes=%zd\\n\",\n\t\t\t\t   sizeof(*_aio_small));\n\t\t\t*pios = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\textra_part = kzalloc(sizeof(*extra_part), GFP_KERNEL);\n\t\tif (unlikely(!extra_part)) {\n\t\t\tORE_DBGMSG(\"Failed alloc second part bytes=%zd\\n\",\n\t\t\t\t   sizeof(*extra_part));\n\t\t\tkfree(_aio_small);\n\t\t\t*pios = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpages = num_par_pages ? extra_part->pages : NULL;\n\t\tsgilist = sgs_per_dev ? extra_part->sglist : NULL;\n\t\t/* In this case the per_dev[0].sgilist holds the pointer to\n\t\t * be freed\n\t\t */\n\t\tios = &_aio_small->ios;\n\t\tios->extra_part_alloc = true;\n\t}\n\n\tif (pages) {\n\t\tios->parity_pages = pages;\n\t\tios->max_par_pages = num_par_pages;\n\t}\n\tif (sgilist) {\n\t\tunsigned d;\n\n\t\tfor (d = 0; d < numdevs; ++d) {\n\t\t\tios->per_dev[d].sglist = sgilist;\n\t\t\tsgilist += sgs_per_dev;\n\t\t}\n\t\tios->sgs_per_dev = sgs_per_dev;\n\t}\n\n\tios->layout = layout;\n\tios->oc = oc;\n\t*pios = ios;\n\treturn 0;\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "_aio_small"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ORE_DBGMSG",
          "args": [
            "\"Failed alloc second part bytes=%zd\\n\"",
            "sizeof(*extra_part)"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!extra_part"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*extra_part)",
            "GFP_KERNEL"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ORE_DBGMSG",
          "args": [
            "\"Failed alloc first part bytes=%zd\\n\"",
            "sizeof(*_aio_small)"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!_aio_small"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*_aio_small)",
            "GFP_KERNEL"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ORE_DBGMSG",
          "args": [
            "\"Failed kzalloc bytes=%zd\\n\"",
            "sizeof(*_aios)"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!_aios"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*_aios)",
            "GFP_KERNEL"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "sizeof(*_aios) <= PAGE_SIZE"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint  _ore_get_io_state(struct ore_layout *layout,\n\t\t\tstruct ore_components *oc, unsigned numdevs,\n\t\t\tunsigned sgs_per_dev, unsigned num_par_pages,\n\t\t\tstruct ore_io_state **pios)\n{\n\tstruct ore_io_state *ios;\n\tstruct page **pages;\n\tstruct osd_sg_entry *sgilist;\n\tstruct __alloc_all_io_state {\n\t\tstruct ore_io_state ios;\n\t\tstruct ore_per_dev_state per_dev[numdevs];\n\t\tunion {\n\t\t\tstruct osd_sg_entry sglist[sgs_per_dev * numdevs];\n\t\t\tstruct page *pages[num_par_pages];\n\t\t};\n\t} *_aios;\n\n\tif (likely(sizeof(*_aios) <= PAGE_SIZE)) {\n\t\t_aios = kzalloc(sizeof(*_aios), GFP_KERNEL);\n\t\tif (unlikely(!_aios)) {\n\t\t\tORE_DBGMSG(\"Failed kzalloc bytes=%zd\\n\",\n\t\t\t\t   sizeof(*_aios));\n\t\t\t*pios = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpages = num_par_pages ? _aios->pages : NULL;\n\t\tsgilist = sgs_per_dev ? _aios->sglist : NULL;\n\t\tios = &_aios->ios;\n\t} else {\n\t\tstruct __alloc_small_io_state {\n\t\t\tstruct ore_io_state ios;\n\t\t\tstruct ore_per_dev_state per_dev[numdevs];\n\t\t} *_aio_small;\n\t\tunion __extra_part {\n\t\t\tstruct osd_sg_entry sglist[sgs_per_dev * numdevs];\n\t\t\tstruct page *pages[num_par_pages];\n\t\t} *extra_part;\n\n\t\t_aio_small = kzalloc(sizeof(*_aio_small), GFP_KERNEL);\n\t\tif (unlikely(!_aio_small)) {\n\t\t\tORE_DBGMSG(\"Failed alloc first part bytes=%zd\\n\",\n\t\t\t\t   sizeof(*_aio_small));\n\t\t\t*pios = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\textra_part = kzalloc(sizeof(*extra_part), GFP_KERNEL);\n\t\tif (unlikely(!extra_part)) {\n\t\t\tORE_DBGMSG(\"Failed alloc second part bytes=%zd\\n\",\n\t\t\t\t   sizeof(*extra_part));\n\t\t\tkfree(_aio_small);\n\t\t\t*pios = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpages = num_par_pages ? extra_part->pages : NULL;\n\t\tsgilist = sgs_per_dev ? extra_part->sglist : NULL;\n\t\t/* In this case the per_dev[0].sgilist holds the pointer to\n\t\t * be freed\n\t\t */\n\t\tios = &_aio_small->ios;\n\t\tios->extra_part_alloc = true;\n\t}\n\n\tif (pages) {\n\t\tios->parity_pages = pages;\n\t\tios->max_par_pages = num_par_pages;\n\t}\n\tif (sgilist) {\n\t\tunsigned d;\n\n\t\tfor (d = 0; d < numdevs; ++d) {\n\t\t\tios->per_dev[d].sglist = sgilist;\n\t\t\tsgilist += sgs_per_dev;\n\t\t}\n\t\tios->sgs_per_dev = sgs_per_dev;\n\t}\n\n\tios->layout = layout;\n\tios->oc = oc;\n\t*pios = ios;\n\treturn 0;\n}"
  },
  {
    "function_name": "_ios_od",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "134-141",
    "snippet": "static struct osd_dev *_ios_od(struct ore_io_state *ios, unsigned index)\n{\n\tORE_DBGMSG2(\"oc->first_dev=%d oc->numdevs=%d i=%d oc->ods=%p\\n\",\n\t\t    ios->oc->first_dev, ios->oc->numdevs, index,\n\t\t    ios->oc->ods);\n\n\treturn ore_comp_dev(ios->oc, index);\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ore_comp_dev",
          "args": [
            "ios->oc",
            "index"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ORE_DBGMSG2",
          "args": [
            "\"oc->first_dev=%d oc->numdevs=%d i=%d oc->ods=%p\\n\"",
            "ios->oc->first_dev",
            "ios->oc->numdevs",
            "index",
            "ios->oc->ods"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic struct osd_dev *_ios_od(struct ore_io_state *ios, unsigned index)\n{\n\tORE_DBGMSG2(\"oc->first_dev=%d oc->numdevs=%d i=%d oc->ods=%p\\n\",\n\t\t    ios->oc->first_dev, ios->oc->numdevs, index,\n\t\t    ios->oc->ods);\n\n\treturn ore_comp_dev(ios->oc, index);\n}"
  },
  {
    "function_name": "_ios_obj",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "129-132",
    "snippet": "static struct osd_obj_id *_ios_obj(struct ore_io_state *ios, unsigned index)\n{\n\treturn &ios->oc->comps[index & ios->oc->single_comp].obj;\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic struct osd_obj_id *_ios_obj(struct ore_io_state *ios, unsigned index)\n{\n\treturn &ios->oc->comps[index & ios->oc->single_comp].obj;\n}"
  },
  {
    "function_name": "_ios_cred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "124-127",
    "snippet": "static u8 *_ios_cred(struct ore_io_state *ios, unsigned index)\n{\n\treturn ios->oc->comps[index & ios->oc->single_comp].cred;\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic u8 *_ios_cred(struct ore_io_state *ios, unsigned index)\n{\n\treturn ios->oc->comps[index & ios->oc->single_comp].cred;\n}"
  },
  {
    "function_name": "ore_verify_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
    "lines": "49-121",
    "snippet": "int ore_verify_layout(unsigned total_comps, struct ore_layout *layout)\n{\n\tu64 stripe_length;\n\n\tswitch (layout->raid_algorithm) {\n\tcase PNFS_OSD_RAID_0:\n\t\tlayout->parity = 0;\n\t\tbreak;\n\tcase PNFS_OSD_RAID_5:\n\t\tlayout->parity = 1;\n\t\tbreak;\n\tcase PNFS_OSD_RAID_PQ:\n\t\tlayout->parity = 2;\n\t\tbreak;\n\tcase PNFS_OSD_RAID_4:\n\tdefault:\n\t\tORE_ERR(\"Only RAID_0/5/6 for now received-enum=%d\\n\",\n\t\t\tlayout->raid_algorithm);\n\t\treturn -EINVAL;\n\t}\n\tif (0 != (layout->stripe_unit & ~PAGE_MASK)) {\n\t\tORE_ERR(\"Stripe Unit(0x%llx)\"\n\t\t\t  \" must be Multples of PAGE_SIZE(0x%lx)\\n\",\n\t\t\t  _LLU(layout->stripe_unit), PAGE_SIZE);\n\t\treturn -EINVAL;\n\t}\n\tif (layout->group_width) {\n\t\tif (!layout->group_depth) {\n\t\t\tORE_ERR(\"group_depth == 0 && group_width != 0\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (total_comps < (layout->group_width * layout->mirrors_p1)) {\n\t\t\tORE_ERR(\"Data Map wrong, \"\n\t\t\t\t\"numdevs=%d < group_width=%d * mirrors=%d\\n\",\n\t\t\t\ttotal_comps, layout->group_width,\n\t\t\t\tlayout->mirrors_p1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlayout->group_count = total_comps / layout->mirrors_p1 /\n\t\t\t\t\t\tlayout->group_width;\n\t} else {\n\t\tif (layout->group_depth) {\n\t\t\tprintk(KERN_NOTICE \"Warning: group_depth ignored \"\n\t\t\t\t\"group_width == 0 && group_depth == %lld\\n\",\n\t\t\t\t_LLU(layout->group_depth));\n\t\t}\n\t\tlayout->group_width = total_comps / layout->mirrors_p1;\n\t\tlayout->group_depth = -1;\n\t\tlayout->group_count = 1;\n\t}\n\n\tstripe_length = (u64)layout->group_width * layout->stripe_unit;\n\tif (stripe_length >= (1ULL << 32)) {\n\t\tORE_ERR(\"Stripe_length(0x%llx) >= 32bit is not supported\\n\",\n\t\t\t_LLU(stripe_length));\n\t\treturn -EINVAL;\n\t}\n\n\tlayout->max_io_length =\n\t\t(BIO_MAX_PAGES_KMALLOC * PAGE_SIZE - layout->stripe_unit) *\n\t\t\t\t\t(layout->group_width - layout->parity);\n\tif (layout->parity) {\n\t\tunsigned stripe_length =\n\t\t\t\t(layout->group_width - layout->parity) *\n\t\t\t\tlayout->stripe_unit;\n\n\t\tlayout->max_io_length /= stripe_length;\n\t\tlayout->max_io_length *= stripe_length;\n\t}\n\tORE_DBGMSG(\"max_io_length=0x%lx\\n\", layout->max_io_length);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ore_raid.h\"",
      "#include <linux/lcm.h>",
      "#include <asm/div64.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ORE_DBGMSG",
          "args": [
            "\"max_io_length=0x%lx\\n\"",
            "layout->max_io_length"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ORE_ERR",
          "args": [
            "\"Stripe_length(0x%llx) >= 32bit is not supported\\n\"",
            "_LLU(stripe_length)"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "stripe_length"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"Warning: group_depth ignored \"\n\t\t\t\t\"group_width == 0 && group_depth == %lld\\n\"",
            "_LLU(layout->group_depth)"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "layout->group_depth"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ORE_ERR",
          "args": [
            "\"Data Map wrong, \"\n\t\t\t\t\"numdevs=%d < group_width=%d * mirrors=%d\\n\"",
            "total_comps",
            "layout->group_width",
            "layout->mirrors_p1"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ORE_ERR",
          "args": [
            "\"group_depth == 0 && group_width != 0\\n\""
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ORE_ERR",
          "args": [
            "\"Stripe Unit(0x%llx)\"\n\t\t\t  \" must be Multples of PAGE_SIZE(0x%lx)\\n\"",
            "_LLU(layout->stripe_unit)",
            "PAGE_SIZE"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "layout->stripe_unit"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ORE_ERR",
          "args": [
            "\"Only RAID_0/5/6 for now received-enum=%d\\n\"",
            "layout->raid_algorithm"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint ore_verify_layout(unsigned total_comps, struct ore_layout *layout)\n{\n\tu64 stripe_length;\n\n\tswitch (layout->raid_algorithm) {\n\tcase PNFS_OSD_RAID_0:\n\t\tlayout->parity = 0;\n\t\tbreak;\n\tcase PNFS_OSD_RAID_5:\n\t\tlayout->parity = 1;\n\t\tbreak;\n\tcase PNFS_OSD_RAID_PQ:\n\t\tlayout->parity = 2;\n\t\tbreak;\n\tcase PNFS_OSD_RAID_4:\n\tdefault:\n\t\tORE_ERR(\"Only RAID_0/5/6 for now received-enum=%d\\n\",\n\t\t\tlayout->raid_algorithm);\n\t\treturn -EINVAL;\n\t}\n\tif (0 != (layout->stripe_unit & ~PAGE_MASK)) {\n\t\tORE_ERR(\"Stripe Unit(0x%llx)\"\n\t\t\t  \" must be Multples of PAGE_SIZE(0x%lx)\\n\",\n\t\t\t  _LLU(layout->stripe_unit), PAGE_SIZE);\n\t\treturn -EINVAL;\n\t}\n\tif (layout->group_width) {\n\t\tif (!layout->group_depth) {\n\t\t\tORE_ERR(\"group_depth == 0 && group_width != 0\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (total_comps < (layout->group_width * layout->mirrors_p1)) {\n\t\t\tORE_ERR(\"Data Map wrong, \"\n\t\t\t\t\"numdevs=%d < group_width=%d * mirrors=%d\\n\",\n\t\t\t\ttotal_comps, layout->group_width,\n\t\t\t\tlayout->mirrors_p1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlayout->group_count = total_comps / layout->mirrors_p1 /\n\t\t\t\t\t\tlayout->group_width;\n\t} else {\n\t\tif (layout->group_depth) {\n\t\t\tprintk(KERN_NOTICE \"Warning: group_depth ignored \"\n\t\t\t\t\"group_width == 0 && group_depth == %lld\\n\",\n\t\t\t\t_LLU(layout->group_depth));\n\t\t}\n\t\tlayout->group_width = total_comps / layout->mirrors_p1;\n\t\tlayout->group_depth = -1;\n\t\tlayout->group_count = 1;\n\t}\n\n\tstripe_length = (u64)layout->group_width * layout->stripe_unit;\n\tif (stripe_length >= (1ULL << 32)) {\n\t\tORE_ERR(\"Stripe_length(0x%llx) >= 32bit is not supported\\n\",\n\t\t\t_LLU(stripe_length));\n\t\treturn -EINVAL;\n\t}\n\n\tlayout->max_io_length =\n\t\t(BIO_MAX_PAGES_KMALLOC * PAGE_SIZE - layout->stripe_unit) *\n\t\t\t\t\t(layout->group_width - layout->parity);\n\tif (layout->parity) {\n\t\tunsigned stripe_length =\n\t\t\t\t(layout->group_width - layout->parity) *\n\t\t\t\tlayout->stripe_unit;\n\n\t\tlayout->max_io_length /= stripe_length;\n\t\tlayout->max_io_length *= stripe_length;\n\t}\n\tORE_DBGMSG(\"max_io_length=0x%lx\\n\", layout->max_io_length);\n\n\treturn 0;\n}"
  }
]