[
  {
    "function_name": "lockd_remove_procfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/procfs.c",
    "lines": "87-92",
    "snippet": "void __exit\nlockd_remove_procfs(void)\n{\n\tremove_proc_entry(\"fs/lockd/nlm_end_grace\", NULL);\n\tremove_proc_entry(\"fs/lockd\", NULL);\n}",
    "includes": [
      "#include \"procfs.h\"",
      "#include \"netns.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"fs/lockd\"",
            "NULL"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "remove_proc_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "523-554",
          "snippet": "void remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(proc_subdir_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic DEFINE_SPINLOCK(proc_subdir_lock);\n\nvoid remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"procfs.h\"\n#include \"netns.h\"\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n\nvoid __exit\nlockd_remove_procfs(void)\n{\n\tremove_proc_entry(\"fs/lockd/nlm_end_grace\", NULL);\n\tremove_proc_entry(\"fs/lockd\", NULL);\n}"
  },
  {
    "function_name": "lockd_create_procfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/procfs.c",
    "lines": "70-85",
    "snippet": "int __init\nlockd_create_procfs(void)\n{\n\tstruct proc_dir_entry *entry;\n\n\tentry = proc_mkdir(\"fs/lockd\", NULL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tentry = proc_create(\"nlm_end_grace\", S_IRUGO|S_IWUSR, entry,\n\t\t\t\t &lockd_end_grace_operations);\n\tif (!entry) {\n\t\tremove_proc_entry(\"fs/lockd\", NULL);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"procfs.h\"",
      "#include \"netns.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations lockd_end_grace_operations = {\n\t.write\t\t= nlm_end_grace_write,\n\t.read\t\t= nlm_end_grace_read,\n\t.llseek\t\t= default_llseek,\n\t.release\t= simple_transaction_release,\n\t.owner\t\t= THIS_MODULE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"fs/lockd\"",
            "NULL"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "remove_proc_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "523-554",
          "snippet": "void remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(proc_subdir_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic DEFINE_SPINLOCK(proc_subdir_lock);\n\nvoid remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"nlm_end_grace\"",
            "S_IRUGO|S_IWUSR",
            "entry",
            "&lockd_end_grace_operations"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "__proc_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "355-391",
          "snippet": "static struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  umode_t mode,\n\t\t\t\t\t  nlink_t nlink)\n{\n\tstruct proc_dir_entry *ent = NULL;\n\tconst char *fn;\n\tstruct qstr qstr;\n\n\tif (xlate_proc_name(name, parent, &fn) != 0)\n\t\tgoto out;\n\tqstr.name = fn;\n\tqstr.len = strlen(fn);\n\tif (qstr.len == 0 || qstr.len >= 256) {\n\t\tWARN(1, \"name len %u\\n\", qstr.len);\n\t\treturn NULL;\n\t}\n\tif (*parent == &proc_root && name_to_int(&qstr) != ~0U) {\n\t\tWARN(1, \"create '/proc/%s' by hand\\n\", qstr.name);\n\t\treturn NULL;\n\t}\n\n\tent = kzalloc(sizeof(struct proc_dir_entry) + qstr.len + 1, GFP_KERNEL);\n\tif (!ent)\n\t\tgoto out;\n\n\tmemcpy(ent->name, fn, qstr.len + 1);\n\tent->namelen = qstr.len;\n\tent->mode = mode;\n\tent->nlink = nlink;\n\tent->subdir = RB_ROOT;\n\tatomic_set(&ent->count, 1);\n\tspin_lock_init(&ent->pde_unload_lock);\n\tINIT_LIST_HEAD(&ent->pde_openers);\nout:\n\treturn ent;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  umode_t mode,\n\t\t\t\t\t  nlink_t nlink)\n{\n\tstruct proc_dir_entry *ent = NULL;\n\tconst char *fn;\n\tstruct qstr qstr;\n\n\tif (xlate_proc_name(name, parent, &fn) != 0)\n\t\tgoto out;\n\tqstr.name = fn;\n\tqstr.len = strlen(fn);\n\tif (qstr.len == 0 || qstr.len >= 256) {\n\t\tWARN(1, \"name len %u\\n\", qstr.len);\n\t\treturn NULL;\n\t}\n\tif (*parent == &proc_root && name_to_int(&qstr) != ~0U) {\n\t\tWARN(1, \"create '/proc/%s' by hand\\n\", qstr.name);\n\t\treturn NULL;\n\t}\n\n\tent = kzalloc(sizeof(struct proc_dir_entry) + qstr.len + 1, GFP_KERNEL);\n\tif (!ent)\n\t\tgoto out;\n\n\tmemcpy(ent->name, fn, qstr.len + 1);\n\tent->namelen = qstr.len;\n\tent->mode = mode;\n\tent->nlink = nlink;\n\tent->subdir = RB_ROOT;\n\tatomic_set(&ent->count, 1);\n\tspin_lock_init(&ent->pde_unload_lock);\n\tINIT_LIST_HEAD(&ent->pde_openers);\nout:\n\treturn ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_mkdir",
          "args": [
            "\"fs/lockd\"",
            "NULL"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "proc_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "451-455",
          "snippet": "struct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstruct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"procfs.h\"\n#include \"netns.h\"\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n\nstatic const struct file_operations lockd_end_grace_operations = {\n\t.write\t\t= nlm_end_grace_write,\n\t.read\t\t= nlm_end_grace_read,\n\t.llseek\t\t= default_llseek,\n\t.release\t= simple_transaction_release,\n\t.owner\t\t= THIS_MODULE,\n};\n\nint __init\nlockd_create_procfs(void)\n{\n\tstruct proc_dir_entry *entry;\n\n\tentry = proc_mkdir(\"fs/lockd\", NULL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tentry = proc_create(\"nlm_end_grace\", S_IRUGO|S_IWUSR, entry,\n\t\t\t\t &lockd_end_grace_operations);\n\tif (!entry) {\n\t\tremove_proc_entry(\"fs/lockd\", NULL);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nlm_end_grace_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/procfs.c",
    "lines": "47-60",
    "snippet": "static ssize_t\nnlm_end_grace_read(struct file *file, char __user *buf, size_t size,\n\t\t   loff_t *pos)\n{\n\tstruct lockd_net *ln = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t   lockd_net_id);\n\tchar resp[3];\n\n\tresp[0] = list_empty(&ln->lockd_manager.list) ? 'Y' : 'N';\n\tresp[1] = '\\n';\n\tresp[2] = '\\0';\n\n\treturn simple_read_from_buffer(buf, size, pos, resp, sizeof(resp));\n}",
    "includes": [
      "#include \"procfs.h\"",
      "#include \"netns.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "size",
            "pos",
            "resp",
            "sizeof(resp)"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "simple_read_from_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "590-608",
          "snippet": "ssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ln->lockd_manager.list"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "lockd_net_id"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"procfs.h\"\n#include \"netns.h\"\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n\nstatic ssize_t\nnlm_end_grace_read(struct file *file, char __user *buf, size_t size,\n\t\t   loff_t *pos)\n{\n\tstruct lockd_net *ln = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t   lockd_net_id);\n\tchar resp[3];\n\n\tresp[0] = list_empty(&ln->lockd_manager.list) ? 'Y' : 'N';\n\tresp[1] = '\\n';\n\tresp[2] = '\\0';\n\n\treturn simple_read_from_buffer(buf, size, pos, resp, sizeof(resp));\n}"
  },
  {
    "function_name": "nlm_end_grace_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/procfs.c",
    "lines": "19-45",
    "snippet": "static ssize_t\nnlm_end_grace_write(struct file *file, const char __user *buf, size_t size,\n\t\t    loff_t *pos)\n{\n\tchar *data;\n\tstruct lockd_net *ln = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t   lockd_net_id);\n\n\tif (size < 1)\n\t\treturn -EINVAL;\n\n\tdata = simple_transaction_get(file, buf, size);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tswitch(data[0]) {\n\tcase 'Y':\n\tcase 'y':\n\tcase '1':\n\t\tlocks_end_grace(&ln->lockd_manager);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn size;\n}",
    "includes": [
      "#include \"procfs.h\"",
      "#include \"netns.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_end_grace",
          "args": [
            "&ln->lockd_manager"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "locks_end_grace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/grace.c",
          "lines": "49-55",
          "snippet": "void\nlocks_end_grace(struct lock_manager *lm)\n{\n\tspin_lock(&grace_lock);\n\tlist_del_init(&lm->list);\n\tspin_unlock(&grace_lock);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <net/netns/generic.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(grace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <net/netns/generic.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n\nstatic DEFINE_SPINLOCK(grace_lock);\n\nvoid\nlocks_end_grace(struct lock_manager *lm)\n{\n\tspin_lock(&grace_lock);\n\tlist_del_init(&lm->list);\n\tspin_unlock(&grace_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_transaction_get",
          "args": [
            "file",
            "buf",
            "size"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "simple_transaction_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "700-729",
          "snippet": "char *simple_transaction_get(struct file *file, const char __user *buf, size_t size)\n{\n\tstruct simple_transaction_argresp *ar;\n\tstatic DEFINE_SPINLOCK(simple_transaction_lock);\n\n\tif (size > SIMPLE_TRANSACTION_LIMIT - 1)\n\t\treturn ERR_PTR(-EFBIG);\n\n\tar = (struct simple_transaction_argresp *)get_zeroed_page(GFP_KERNEL);\n\tif (!ar)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock(&simple_transaction_lock);\n\n\t/* only one write allowed per open */\n\tif (file->private_data) {\n\t\tspin_unlock(&simple_transaction_lock);\n\t\tfree_page((unsigned long)ar);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tfile->private_data = ar;\n\n\tspin_unlock(&simple_transaction_lock);\n\n\tif (copy_from_user(ar->data, buf, size))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn ar->data;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nchar *simple_transaction_get(struct file *file, const char __user *buf, size_t size)\n{\n\tstruct simple_transaction_argresp *ar;\n\tstatic DEFINE_SPINLOCK(simple_transaction_lock);\n\n\tif (size > SIMPLE_TRANSACTION_LIMIT - 1)\n\t\treturn ERR_PTR(-EFBIG);\n\n\tar = (struct simple_transaction_argresp *)get_zeroed_page(GFP_KERNEL);\n\tif (!ar)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock(&simple_transaction_lock);\n\n\t/* only one write allowed per open */\n\tif (file->private_data) {\n\t\tspin_unlock(&simple_transaction_lock);\n\t\tfree_page((unsigned long)ar);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tfile->private_data = ar;\n\n\tspin_unlock(&simple_transaction_lock);\n\n\tif (copy_from_user(ar->data, buf, size))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn ar->data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "lockd_net_id"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"procfs.h\"\n#include \"netns.h\"\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n\nstatic ssize_t\nnlm_end_grace_write(struct file *file, const char __user *buf, size_t size,\n\t\t    loff_t *pos)\n{\n\tchar *data;\n\tstruct lockd_net *ln = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t   lockd_net_id);\n\n\tif (size < 1)\n\t\treturn -EINVAL;\n\n\tdata = simple_transaction_get(file, buf, size);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tswitch(data[0]) {\n\tcase 'Y':\n\tcase 'y':\n\tcase '1':\n\t\tlocks_end_grace(&ln->lockd_manager);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn size;\n}"
  }
]