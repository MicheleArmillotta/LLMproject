[
  {
    "function_name": "tid_numa_maps_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "1607-1610",
    "snippet": "static int tid_numa_maps_open(struct inode *inode, struct file *file)\n{\n\treturn numa_maps_open(inode, file, &proc_tid_numa_maps_op);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "numa_maps_open",
          "args": [
            "inode",
            "file",
            "&proc_tid_numa_maps_op"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "numa_maps_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "1595-1600",
          "snippet": "static int numa_maps_open(struct inode *inode, struct file *file,\n\t\t\t  const struct seq_operations *ops)\n{\n\treturn proc_maps_open(inode, file, ops,\n\t\t\t\tsizeof(struct numa_maps_private));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int numa_maps_open(struct inode *inode, struct file *file,\n\t\t\t  const struct seq_operations *ops)\n{\n\treturn proc_maps_open(inode, file, ops,\n\t\t\t\tsizeof(struct numa_maps_private));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int tid_numa_maps_open(struct inode *inode, struct file *file)\n{\n\treturn numa_maps_open(inode, file, &proc_tid_numa_maps_op);\n}"
  },
  {
    "function_name": "pid_numa_maps_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "1602-1605",
    "snippet": "static int pid_numa_maps_open(struct inode *inode, struct file *file)\n{\n\treturn numa_maps_open(inode, file, &proc_pid_numa_maps_op);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "numa_maps_open",
          "args": [
            "inode",
            "file",
            "&proc_pid_numa_maps_op"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "numa_maps_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "1595-1600",
          "snippet": "static int numa_maps_open(struct inode *inode, struct file *file,\n\t\t\t  const struct seq_operations *ops)\n{\n\treturn proc_maps_open(inode, file, ops,\n\t\t\t\tsizeof(struct numa_maps_private));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int numa_maps_open(struct inode *inode, struct file *file,\n\t\t\t  const struct seq_operations *ops)\n{\n\treturn proc_maps_open(inode, file, ops,\n\t\t\t\tsizeof(struct numa_maps_private));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int pid_numa_maps_open(struct inode *inode, struct file *file)\n{\n\treturn numa_maps_open(inode, file, &proc_pid_numa_maps_op);\n}"
  },
  {
    "function_name": "numa_maps_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "1595-1600",
    "snippet": "static int numa_maps_open(struct inode *inode, struct file *file,\n\t\t\t  const struct seq_operations *ops)\n{\n\treturn proc_maps_open(inode, file, ops,\n\t\t\t\tsizeof(struct numa_maps_private));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_maps_open",
          "args": [
            "inode",
            "file",
            "ops",
            "sizeof(struct numa_maps_private)"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "proc_maps_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "211-229",
          "snippet": "static int proc_maps_open(struct inode *inode, struct file *file,\n\t\t\tconst struct seq_operations *ops, int psize)\n{\n\tstruct proc_maps_private *priv = __seq_open_private(file, ops, psize);\n\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->inode = inode;\n\tpriv->mm = proc_mem_open(inode, PTRACE_MODE_READ);\n\tif (IS_ERR(priv->mm)) {\n\t\tint err = PTR_ERR(priv->mm);\n\n\t\tseq_release_private(inode, file);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int proc_maps_open(struct inode *inode, struct file *file,\n\t\t\tconst struct seq_operations *ops, int psize)\n{\n\tstruct proc_maps_private *priv = __seq_open_private(file, ops, psize);\n\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->inode = inode;\n\tpriv->mm = proc_mem_open(inode, PTRACE_MODE_READ);\n\tif (IS_ERR(priv->mm)) {\n\t\tint err = PTR_ERR(priv->mm);\n\n\t\tseq_release_private(inode, file);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int numa_maps_open(struct inode *inode, struct file *file,\n\t\t\t  const struct seq_operations *ops)\n{\n\treturn proc_maps_open(inode, file, ops,\n\t\t\t\tsizeof(struct numa_maps_private));\n}"
  },
  {
    "function_name": "show_tid_numa_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "1576-1579",
    "snippet": "static int show_tid_numa_map(struct seq_file *m, void *v)\n{\n\treturn show_numa_map(m, v, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_numa_map",
          "args": [
            "m",
            "v",
            "0"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "show_numa_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "1476-1569",
          "snippet": "static int show_numa_map(struct seq_file *m, void *v, int is_pid)\n{\n\tstruct numa_maps_private *numa_priv = m->private;\n\tstruct proc_maps_private *proc_priv = &numa_priv->proc_maps;\n\tstruct vm_area_struct *vma = v;\n\tstruct numa_maps *md = &numa_priv->md;\n\tstruct file *file = vma->vm_file;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mm_walk walk = {\n\t\t.hugetlb_entry = gather_hugetlb_stats,\n\t\t.pmd_entry = gather_pte_stats,\n\t\t.private = md,\n\t\t.mm = mm,\n\t};\n\tstruct mempolicy *pol;\n\tchar buffer[64];\n\tint nid;\n\n\tif (!mm)\n\t\treturn 0;\n\n\t/* Ensure we start with an empty set of numa_maps statistics. */\n\tmemset(md, 0, sizeof(*md));\n\n\tpol = __get_vma_policy(vma, vma->vm_start);\n\tif (pol) {\n\t\tmpol_to_str(buffer, sizeof(buffer), pol);\n\t\tmpol_cond_put(pol);\n\t} else {\n\t\tmpol_to_str(buffer, sizeof(buffer), proc_priv->task_mempolicy);\n\t}\n\n\tseq_printf(m, \"%08lx %s\", vma->vm_start, buffer);\n\n\tif (file) {\n\t\tseq_puts(m, \" file=\");\n\t\tseq_path(m, &file->f_path, \"\\n\\t= \");\n\t} else if (vma->vm_start <= mm->brk && vma->vm_end >= mm->start_brk) {\n\t\tseq_puts(m, \" heap\");\n\t} else {\n\t\tpid_t tid = pid_of_stack(proc_priv, vma, is_pid);\n\t\tif (tid != 0) {\n\t\t\t/*\n\t\t\t * Thread stack in /proc/PID/task/TID/maps or\n\t\t\t * the main process stack.\n\t\t\t */\n\t\t\tif (!is_pid || (vma->vm_start <= mm->start_stack &&\n\t\t\t    vma->vm_end >= mm->start_stack))\n\t\t\t\tseq_puts(m, \" stack\");\n\t\t\telse\n\t\t\t\tseq_printf(m, \" stack:%d\", tid);\n\t\t}\n\t}\n\n\tif (is_vm_hugetlb_page(vma))\n\t\tseq_puts(m, \" huge\");\n\n\t/* mmap_sem is held by m_start */\n\twalk_page_vma(vma, &walk);\n\n\tif (!md->pages)\n\t\tgoto out;\n\n\tif (md->anon)\n\t\tseq_printf(m, \" anon=%lu\", md->anon);\n\n\tif (md->dirty)\n\t\tseq_printf(m, \" dirty=%lu\", md->dirty);\n\n\tif (md->pages != md->anon && md->pages != md->dirty)\n\t\tseq_printf(m, \" mapped=%lu\", md->pages);\n\n\tif (md->mapcount_max > 1)\n\t\tseq_printf(m, \" mapmax=%lu\", md->mapcount_max);\n\n\tif (md->swapcache)\n\t\tseq_printf(m, \" swapcache=%lu\", md->swapcache);\n\n\tif (md->active < md->pages && !is_vm_hugetlb_page(vma))\n\t\tseq_printf(m, \" active=%lu\", md->active);\n\n\tif (md->writeback)\n\t\tseq_printf(m, \" writeback=%lu\", md->writeback);\n\n\tfor_each_node_state(nid, N_MEMORY)\n\t\tif (md->node[nid])\n\t\t\tseq_printf(m, \" N%d=%lu\", nid, md->node[nid]);\n\n\tseq_printf(m, \" kernelpagesize_kB=%lu\", vma_kernel_pagesize(vma) >> 10);\nout:\n\tseq_putc(m, '\\n');\n\tm_cache_vma(m, vma);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int show_numa_map(struct seq_file *m, void *v, int is_pid)\n{\n\tstruct numa_maps_private *numa_priv = m->private;\n\tstruct proc_maps_private *proc_priv = &numa_priv->proc_maps;\n\tstruct vm_area_struct *vma = v;\n\tstruct numa_maps *md = &numa_priv->md;\n\tstruct file *file = vma->vm_file;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mm_walk walk = {\n\t\t.hugetlb_entry = gather_hugetlb_stats,\n\t\t.pmd_entry = gather_pte_stats,\n\t\t.private = md,\n\t\t.mm = mm,\n\t};\n\tstruct mempolicy *pol;\n\tchar buffer[64];\n\tint nid;\n\n\tif (!mm)\n\t\treturn 0;\n\n\t/* Ensure we start with an empty set of numa_maps statistics. */\n\tmemset(md, 0, sizeof(*md));\n\n\tpol = __get_vma_policy(vma, vma->vm_start);\n\tif (pol) {\n\t\tmpol_to_str(buffer, sizeof(buffer), pol);\n\t\tmpol_cond_put(pol);\n\t} else {\n\t\tmpol_to_str(buffer, sizeof(buffer), proc_priv->task_mempolicy);\n\t}\n\n\tseq_printf(m, \"%08lx %s\", vma->vm_start, buffer);\n\n\tif (file) {\n\t\tseq_puts(m, \" file=\");\n\t\tseq_path(m, &file->f_path, \"\\n\\t= \");\n\t} else if (vma->vm_start <= mm->brk && vma->vm_end >= mm->start_brk) {\n\t\tseq_puts(m, \" heap\");\n\t} else {\n\t\tpid_t tid = pid_of_stack(proc_priv, vma, is_pid);\n\t\tif (tid != 0) {\n\t\t\t/*\n\t\t\t * Thread stack in /proc/PID/task/TID/maps or\n\t\t\t * the main process stack.\n\t\t\t */\n\t\t\tif (!is_pid || (vma->vm_start <= mm->start_stack &&\n\t\t\t    vma->vm_end >= mm->start_stack))\n\t\t\t\tseq_puts(m, \" stack\");\n\t\t\telse\n\t\t\t\tseq_printf(m, \" stack:%d\", tid);\n\t\t}\n\t}\n\n\tif (is_vm_hugetlb_page(vma))\n\t\tseq_puts(m, \" huge\");\n\n\t/* mmap_sem is held by m_start */\n\twalk_page_vma(vma, &walk);\n\n\tif (!md->pages)\n\t\tgoto out;\n\n\tif (md->anon)\n\t\tseq_printf(m, \" anon=%lu\", md->anon);\n\n\tif (md->dirty)\n\t\tseq_printf(m, \" dirty=%lu\", md->dirty);\n\n\tif (md->pages != md->anon && md->pages != md->dirty)\n\t\tseq_printf(m, \" mapped=%lu\", md->pages);\n\n\tif (md->mapcount_max > 1)\n\t\tseq_printf(m, \" mapmax=%lu\", md->mapcount_max);\n\n\tif (md->swapcache)\n\t\tseq_printf(m, \" swapcache=%lu\", md->swapcache);\n\n\tif (md->active < md->pages && !is_vm_hugetlb_page(vma))\n\t\tseq_printf(m, \" active=%lu\", md->active);\n\n\tif (md->writeback)\n\t\tseq_printf(m, \" writeback=%lu\", md->writeback);\n\n\tfor_each_node_state(nid, N_MEMORY)\n\t\tif (md->node[nid])\n\t\t\tseq_printf(m, \" N%d=%lu\", nid, md->node[nid]);\n\n\tseq_printf(m, \" kernelpagesize_kB=%lu\", vma_kernel_pagesize(vma) >> 10);\nout:\n\tseq_putc(m, '\\n');\n\tm_cache_vma(m, vma);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int show_tid_numa_map(struct seq_file *m, void *v)\n{\n\treturn show_numa_map(m, v, 0);\n}"
  },
  {
    "function_name": "show_pid_numa_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "1571-1574",
    "snippet": "static int show_pid_numa_map(struct seq_file *m, void *v)\n{\n\treturn show_numa_map(m, v, 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_numa_map",
          "args": [
            "m",
            "v",
            "1"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "show_numa_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "1476-1569",
          "snippet": "static int show_numa_map(struct seq_file *m, void *v, int is_pid)\n{\n\tstruct numa_maps_private *numa_priv = m->private;\n\tstruct proc_maps_private *proc_priv = &numa_priv->proc_maps;\n\tstruct vm_area_struct *vma = v;\n\tstruct numa_maps *md = &numa_priv->md;\n\tstruct file *file = vma->vm_file;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mm_walk walk = {\n\t\t.hugetlb_entry = gather_hugetlb_stats,\n\t\t.pmd_entry = gather_pte_stats,\n\t\t.private = md,\n\t\t.mm = mm,\n\t};\n\tstruct mempolicy *pol;\n\tchar buffer[64];\n\tint nid;\n\n\tif (!mm)\n\t\treturn 0;\n\n\t/* Ensure we start with an empty set of numa_maps statistics. */\n\tmemset(md, 0, sizeof(*md));\n\n\tpol = __get_vma_policy(vma, vma->vm_start);\n\tif (pol) {\n\t\tmpol_to_str(buffer, sizeof(buffer), pol);\n\t\tmpol_cond_put(pol);\n\t} else {\n\t\tmpol_to_str(buffer, sizeof(buffer), proc_priv->task_mempolicy);\n\t}\n\n\tseq_printf(m, \"%08lx %s\", vma->vm_start, buffer);\n\n\tif (file) {\n\t\tseq_puts(m, \" file=\");\n\t\tseq_path(m, &file->f_path, \"\\n\\t= \");\n\t} else if (vma->vm_start <= mm->brk && vma->vm_end >= mm->start_brk) {\n\t\tseq_puts(m, \" heap\");\n\t} else {\n\t\tpid_t tid = pid_of_stack(proc_priv, vma, is_pid);\n\t\tif (tid != 0) {\n\t\t\t/*\n\t\t\t * Thread stack in /proc/PID/task/TID/maps or\n\t\t\t * the main process stack.\n\t\t\t */\n\t\t\tif (!is_pid || (vma->vm_start <= mm->start_stack &&\n\t\t\t    vma->vm_end >= mm->start_stack))\n\t\t\t\tseq_puts(m, \" stack\");\n\t\t\telse\n\t\t\t\tseq_printf(m, \" stack:%d\", tid);\n\t\t}\n\t}\n\n\tif (is_vm_hugetlb_page(vma))\n\t\tseq_puts(m, \" huge\");\n\n\t/* mmap_sem is held by m_start */\n\twalk_page_vma(vma, &walk);\n\n\tif (!md->pages)\n\t\tgoto out;\n\n\tif (md->anon)\n\t\tseq_printf(m, \" anon=%lu\", md->anon);\n\n\tif (md->dirty)\n\t\tseq_printf(m, \" dirty=%lu\", md->dirty);\n\n\tif (md->pages != md->anon && md->pages != md->dirty)\n\t\tseq_printf(m, \" mapped=%lu\", md->pages);\n\n\tif (md->mapcount_max > 1)\n\t\tseq_printf(m, \" mapmax=%lu\", md->mapcount_max);\n\n\tif (md->swapcache)\n\t\tseq_printf(m, \" swapcache=%lu\", md->swapcache);\n\n\tif (md->active < md->pages && !is_vm_hugetlb_page(vma))\n\t\tseq_printf(m, \" active=%lu\", md->active);\n\n\tif (md->writeback)\n\t\tseq_printf(m, \" writeback=%lu\", md->writeback);\n\n\tfor_each_node_state(nid, N_MEMORY)\n\t\tif (md->node[nid])\n\t\t\tseq_printf(m, \" N%d=%lu\", nid, md->node[nid]);\n\n\tseq_printf(m, \" kernelpagesize_kB=%lu\", vma_kernel_pagesize(vma) >> 10);\nout:\n\tseq_putc(m, '\\n');\n\tm_cache_vma(m, vma);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int show_numa_map(struct seq_file *m, void *v, int is_pid)\n{\n\tstruct numa_maps_private *numa_priv = m->private;\n\tstruct proc_maps_private *proc_priv = &numa_priv->proc_maps;\n\tstruct vm_area_struct *vma = v;\n\tstruct numa_maps *md = &numa_priv->md;\n\tstruct file *file = vma->vm_file;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mm_walk walk = {\n\t\t.hugetlb_entry = gather_hugetlb_stats,\n\t\t.pmd_entry = gather_pte_stats,\n\t\t.private = md,\n\t\t.mm = mm,\n\t};\n\tstruct mempolicy *pol;\n\tchar buffer[64];\n\tint nid;\n\n\tif (!mm)\n\t\treturn 0;\n\n\t/* Ensure we start with an empty set of numa_maps statistics. */\n\tmemset(md, 0, sizeof(*md));\n\n\tpol = __get_vma_policy(vma, vma->vm_start);\n\tif (pol) {\n\t\tmpol_to_str(buffer, sizeof(buffer), pol);\n\t\tmpol_cond_put(pol);\n\t} else {\n\t\tmpol_to_str(buffer, sizeof(buffer), proc_priv->task_mempolicy);\n\t}\n\n\tseq_printf(m, \"%08lx %s\", vma->vm_start, buffer);\n\n\tif (file) {\n\t\tseq_puts(m, \" file=\");\n\t\tseq_path(m, &file->f_path, \"\\n\\t= \");\n\t} else if (vma->vm_start <= mm->brk && vma->vm_end >= mm->start_brk) {\n\t\tseq_puts(m, \" heap\");\n\t} else {\n\t\tpid_t tid = pid_of_stack(proc_priv, vma, is_pid);\n\t\tif (tid != 0) {\n\t\t\t/*\n\t\t\t * Thread stack in /proc/PID/task/TID/maps or\n\t\t\t * the main process stack.\n\t\t\t */\n\t\t\tif (!is_pid || (vma->vm_start <= mm->start_stack &&\n\t\t\t    vma->vm_end >= mm->start_stack))\n\t\t\t\tseq_puts(m, \" stack\");\n\t\t\telse\n\t\t\t\tseq_printf(m, \" stack:%d\", tid);\n\t\t}\n\t}\n\n\tif (is_vm_hugetlb_page(vma))\n\t\tseq_puts(m, \" huge\");\n\n\t/* mmap_sem is held by m_start */\n\twalk_page_vma(vma, &walk);\n\n\tif (!md->pages)\n\t\tgoto out;\n\n\tif (md->anon)\n\t\tseq_printf(m, \" anon=%lu\", md->anon);\n\n\tif (md->dirty)\n\t\tseq_printf(m, \" dirty=%lu\", md->dirty);\n\n\tif (md->pages != md->anon && md->pages != md->dirty)\n\t\tseq_printf(m, \" mapped=%lu\", md->pages);\n\n\tif (md->mapcount_max > 1)\n\t\tseq_printf(m, \" mapmax=%lu\", md->mapcount_max);\n\n\tif (md->swapcache)\n\t\tseq_printf(m, \" swapcache=%lu\", md->swapcache);\n\n\tif (md->active < md->pages && !is_vm_hugetlb_page(vma))\n\t\tseq_printf(m, \" active=%lu\", md->active);\n\n\tif (md->writeback)\n\t\tseq_printf(m, \" writeback=%lu\", md->writeback);\n\n\tfor_each_node_state(nid, N_MEMORY)\n\t\tif (md->node[nid])\n\t\t\tseq_printf(m, \" N%d=%lu\", nid, md->node[nid]);\n\n\tseq_printf(m, \" kernelpagesize_kB=%lu\", vma_kernel_pagesize(vma) >> 10);\nout:\n\tseq_putc(m, '\\n');\n\tm_cache_vma(m, vma);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int show_pid_numa_map(struct seq_file *m, void *v)\n{\n\treturn show_numa_map(m, v, 1);\n}"
  },
  {
    "function_name": "show_numa_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "1476-1569",
    "snippet": "static int show_numa_map(struct seq_file *m, void *v, int is_pid)\n{\n\tstruct numa_maps_private *numa_priv = m->private;\n\tstruct proc_maps_private *proc_priv = &numa_priv->proc_maps;\n\tstruct vm_area_struct *vma = v;\n\tstruct numa_maps *md = &numa_priv->md;\n\tstruct file *file = vma->vm_file;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mm_walk walk = {\n\t\t.hugetlb_entry = gather_hugetlb_stats,\n\t\t.pmd_entry = gather_pte_stats,\n\t\t.private = md,\n\t\t.mm = mm,\n\t};\n\tstruct mempolicy *pol;\n\tchar buffer[64];\n\tint nid;\n\n\tif (!mm)\n\t\treturn 0;\n\n\t/* Ensure we start with an empty set of numa_maps statistics. */\n\tmemset(md, 0, sizeof(*md));\n\n\tpol = __get_vma_policy(vma, vma->vm_start);\n\tif (pol) {\n\t\tmpol_to_str(buffer, sizeof(buffer), pol);\n\t\tmpol_cond_put(pol);\n\t} else {\n\t\tmpol_to_str(buffer, sizeof(buffer), proc_priv->task_mempolicy);\n\t}\n\n\tseq_printf(m, \"%08lx %s\", vma->vm_start, buffer);\n\n\tif (file) {\n\t\tseq_puts(m, \" file=\");\n\t\tseq_path(m, &file->f_path, \"\\n\\t= \");\n\t} else if (vma->vm_start <= mm->brk && vma->vm_end >= mm->start_brk) {\n\t\tseq_puts(m, \" heap\");\n\t} else {\n\t\tpid_t tid = pid_of_stack(proc_priv, vma, is_pid);\n\t\tif (tid != 0) {\n\t\t\t/*\n\t\t\t * Thread stack in /proc/PID/task/TID/maps or\n\t\t\t * the main process stack.\n\t\t\t */\n\t\t\tif (!is_pid || (vma->vm_start <= mm->start_stack &&\n\t\t\t    vma->vm_end >= mm->start_stack))\n\t\t\t\tseq_puts(m, \" stack\");\n\t\t\telse\n\t\t\t\tseq_printf(m, \" stack:%d\", tid);\n\t\t}\n\t}\n\n\tif (is_vm_hugetlb_page(vma))\n\t\tseq_puts(m, \" huge\");\n\n\t/* mmap_sem is held by m_start */\n\twalk_page_vma(vma, &walk);\n\n\tif (!md->pages)\n\t\tgoto out;\n\n\tif (md->anon)\n\t\tseq_printf(m, \" anon=%lu\", md->anon);\n\n\tif (md->dirty)\n\t\tseq_printf(m, \" dirty=%lu\", md->dirty);\n\n\tif (md->pages != md->anon && md->pages != md->dirty)\n\t\tseq_printf(m, \" mapped=%lu\", md->pages);\n\n\tif (md->mapcount_max > 1)\n\t\tseq_printf(m, \" mapmax=%lu\", md->mapcount_max);\n\n\tif (md->swapcache)\n\t\tseq_printf(m, \" swapcache=%lu\", md->swapcache);\n\n\tif (md->active < md->pages && !is_vm_hugetlb_page(vma))\n\t\tseq_printf(m, \" active=%lu\", md->active);\n\n\tif (md->writeback)\n\t\tseq_printf(m, \" writeback=%lu\", md->writeback);\n\n\tfor_each_node_state(nid, N_MEMORY)\n\t\tif (md->node[nid])\n\t\t\tseq_printf(m, \" N%d=%lu\", nid, md->node[nid]);\n\n\tseq_printf(m, \" kernelpagesize_kB=%lu\", vma_kernel_pagesize(vma) >> 10);\nout:\n\tseq_putc(m, '\\n');\n\tm_cache_vma(m, vma);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_cache_vma",
          "args": [
            "m",
            "vma"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "m_cache_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "134-138",
          "snippet": "static void m_cache_vma(struct seq_file *m, struct vm_area_struct *vma)\n{\n\tif (m->count < m->size)\t/* vma is copied successfully */\n\t\tm->version = m_next_vma(m->private, vma) ? vma->vm_start : -1UL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void m_cache_vma(struct seq_file *m, struct vm_area_struct *vma)\n{\n\tif (m->count < m->size)\t/* vma is copied successfully */\n\t\tm->version = m_next_vma(m->private, vma) ? vma->vm_start : -1UL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "648-655",
          "snippet": "int seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" kernelpagesize_kB=%lu\"",
            "vma_kernel_pagesize(vma) >> 10"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_kernel_pagesize",
          "args": [
            "vma"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_node_state",
          "args": [
            "nid",
            "N_MEMORY"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_page_vma",
          "args": [
            "vma",
            "&walk"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" huge\""
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_of_stack",
          "args": [
            "proc_priv",
            "vma",
            "is_pid"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "pid_of_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "249-266",
          "snippet": "static pid_t pid_of_stack(struct proc_maps_private *priv,\n\t\t\t\tstruct vm_area_struct *vma, bool is_pid)\n{\n\tstruct inode *inode = priv->inode;\n\tstruct task_struct *task;\n\tpid_t ret = 0;\n\n\trcu_read_lock();\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\ttask = task_of_stack(task, vma, is_pid);\n\t\tif (task)\n\t\t\tret = task_pid_nr_ns(task, inode->i_sb->s_fs_info);\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic pid_t pid_of_stack(struct proc_maps_private *priv,\n\t\t\t\tstruct vm_area_struct *vma, bool is_pid)\n{\n\tstruct inode *inode = priv->inode;\n\tstruct task_struct *task;\n\tpid_t ret = 0;\n\n\trcu_read_lock();\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\ttask = task_of_stack(task, vma, is_pid);\n\t\tif (task)\n\t\t\tret = task_pid_nr_ns(task, inode->i_sb->s_fs_info);\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_path",
          "args": [
            "m",
            "&file->f_path",
            "\"\\n\\t= \""
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "seq_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "470-487",
          "snippet": "int seq_path(struct seq_file *m, const struct path *path, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = d_path(path, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_path(struct seq_file *m, const struct path *path, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = d_path(path, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpol_to_str",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "proc_priv->task_mempolicy"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_cond_put",
          "args": [
            "pol"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_to_str",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "pol"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_vma_policy",
          "args": [
            "vma",
            "vma->vm_start"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "md",
            "0",
            "sizeof(*md)"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int show_numa_map(struct seq_file *m, void *v, int is_pid)\n{\n\tstruct numa_maps_private *numa_priv = m->private;\n\tstruct proc_maps_private *proc_priv = &numa_priv->proc_maps;\n\tstruct vm_area_struct *vma = v;\n\tstruct numa_maps *md = &numa_priv->md;\n\tstruct file *file = vma->vm_file;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mm_walk walk = {\n\t\t.hugetlb_entry = gather_hugetlb_stats,\n\t\t.pmd_entry = gather_pte_stats,\n\t\t.private = md,\n\t\t.mm = mm,\n\t};\n\tstruct mempolicy *pol;\n\tchar buffer[64];\n\tint nid;\n\n\tif (!mm)\n\t\treturn 0;\n\n\t/* Ensure we start with an empty set of numa_maps statistics. */\n\tmemset(md, 0, sizeof(*md));\n\n\tpol = __get_vma_policy(vma, vma->vm_start);\n\tif (pol) {\n\t\tmpol_to_str(buffer, sizeof(buffer), pol);\n\t\tmpol_cond_put(pol);\n\t} else {\n\t\tmpol_to_str(buffer, sizeof(buffer), proc_priv->task_mempolicy);\n\t}\n\n\tseq_printf(m, \"%08lx %s\", vma->vm_start, buffer);\n\n\tif (file) {\n\t\tseq_puts(m, \" file=\");\n\t\tseq_path(m, &file->f_path, \"\\n\\t= \");\n\t} else if (vma->vm_start <= mm->brk && vma->vm_end >= mm->start_brk) {\n\t\tseq_puts(m, \" heap\");\n\t} else {\n\t\tpid_t tid = pid_of_stack(proc_priv, vma, is_pid);\n\t\tif (tid != 0) {\n\t\t\t/*\n\t\t\t * Thread stack in /proc/PID/task/TID/maps or\n\t\t\t * the main process stack.\n\t\t\t */\n\t\t\tif (!is_pid || (vma->vm_start <= mm->start_stack &&\n\t\t\t    vma->vm_end >= mm->start_stack))\n\t\t\t\tseq_puts(m, \" stack\");\n\t\t\telse\n\t\t\t\tseq_printf(m, \" stack:%d\", tid);\n\t\t}\n\t}\n\n\tif (is_vm_hugetlb_page(vma))\n\t\tseq_puts(m, \" huge\");\n\n\t/* mmap_sem is held by m_start */\n\twalk_page_vma(vma, &walk);\n\n\tif (!md->pages)\n\t\tgoto out;\n\n\tif (md->anon)\n\t\tseq_printf(m, \" anon=%lu\", md->anon);\n\n\tif (md->dirty)\n\t\tseq_printf(m, \" dirty=%lu\", md->dirty);\n\n\tif (md->pages != md->anon && md->pages != md->dirty)\n\t\tseq_printf(m, \" mapped=%lu\", md->pages);\n\n\tif (md->mapcount_max > 1)\n\t\tseq_printf(m, \" mapmax=%lu\", md->mapcount_max);\n\n\tif (md->swapcache)\n\t\tseq_printf(m, \" swapcache=%lu\", md->swapcache);\n\n\tif (md->active < md->pages && !is_vm_hugetlb_page(vma))\n\t\tseq_printf(m, \" active=%lu\", md->active);\n\n\tif (md->writeback)\n\t\tseq_printf(m, \" writeback=%lu\", md->writeback);\n\n\tfor_each_node_state(nid, N_MEMORY)\n\t\tif (md->node[nid])\n\t\t\tseq_printf(m, \" N%d=%lu\", nid, md->node[nid]);\n\n\tseq_printf(m, \" kernelpagesize_kB=%lu\", vma_kernel_pagesize(vma) >> 10);\nout:\n\tseq_putc(m, '\\n');\n\tm_cache_vma(m, vma);\n\treturn 0;\n}"
  },
  {
    "function_name": "gather_hugetlb_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "1466-1470",
    "snippet": "static int gather_hugetlb_stats(pte_t *pte, unsigned long hmask,\n\t\tunsigned long addr, unsigned long end, struct mm_walk *walk)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int gather_hugetlb_stats(pte_t *pte, unsigned long hmask,\n\t\tunsigned long addr, unsigned long end, struct mm_walk *walk)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "gather_hugetlb_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "1447-1463",
    "snippet": "static int gather_hugetlb_stats(pte_t *pte, unsigned long hmask,\n\t\tunsigned long addr, unsigned long end, struct mm_walk *walk)\n{\n\tstruct numa_maps *md;\n\tstruct page *page;\n\n\tif (!pte_present(*pte))\n\t\treturn 0;\n\n\tpage = pte_page(*pte);\n\tif (!page)\n\t\treturn 0;\n\n\tmd = walk->private;\n\tgather_stats(page, md, pte_dirty(*pte), 1);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gather_stats",
          "args": [
            "page",
            "md",
            "pte_dirty(*pte)",
            "1"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "gather_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "1362-1387",
          "snippet": "static void gather_stats(struct page *page, struct numa_maps *md, int pte_dirty,\n\t\t\tunsigned long nr_pages)\n{\n\tint count = page_mapcount(page);\n\n\tmd->pages += nr_pages;\n\tif (pte_dirty || PageDirty(page))\n\t\tmd->dirty += nr_pages;\n\n\tif (PageSwapCache(page))\n\t\tmd->swapcache += nr_pages;\n\n\tif (PageActive(page) || PageUnevictable(page))\n\t\tmd->active += nr_pages;\n\n\tif (PageWriteback(page))\n\t\tmd->writeback += nr_pages;\n\n\tif (PageAnon(page))\n\t\tmd->anon += nr_pages;\n\n\tif (count > md->mapcount_max)\n\t\tmd->mapcount_max = count;\n\n\tmd->node[page_to_nid(page)] += nr_pages;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void gather_stats(struct page *page, struct numa_maps *md, int pte_dirty,\n\t\t\tunsigned long nr_pages)\n{\n\tint count = page_mapcount(page);\n\n\tmd->pages += nr_pages;\n\tif (pte_dirty || PageDirty(page))\n\t\tmd->dirty += nr_pages;\n\n\tif (PageSwapCache(page))\n\t\tmd->swapcache += nr_pages;\n\n\tif (PageActive(page) || PageUnevictable(page))\n\t\tmd->active += nr_pages;\n\n\tif (PageWriteback(page))\n\t\tmd->writeback += nr_pages;\n\n\tif (PageAnon(page))\n\t\tmd->anon += nr_pages;\n\n\tif (count > md->mapcount_max)\n\t\tmd->mapcount_max = count;\n\n\tmd->node[page_to_nid(page)] += nr_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_dirty",
          "args": [
            "*pte"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_page",
          "args": [
            "*pte"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "*pte"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int gather_hugetlb_stats(pte_t *pte, unsigned long hmask,\n\t\tunsigned long addr, unsigned long end, struct mm_walk *walk)\n{\n\tstruct numa_maps *md;\n\tstruct page *page;\n\n\tif (!pte_present(*pte))\n\t\treturn 0;\n\n\tpage = pte_page(*pte);\n\tif (!page)\n\t\treturn 0;\n\n\tmd = walk->private;\n\tgather_stats(page, md, pte_dirty(*pte), 1);\n\treturn 0;\n}"
  },
  {
    "function_name": "gather_pte_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "1412-1445",
    "snippet": "static int gather_pte_stats(pmd_t *pmd, unsigned long addr,\n\t\tunsigned long end, struct mm_walk *walk)\n{\n\tstruct numa_maps *md = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tspinlock_t *ptl;\n\tpte_t *orig_pte;\n\tpte_t *pte;\n\n\tif (pmd_trans_huge_lock(pmd, vma, &ptl) == 1) {\n\t\tpte_t huge_pte = *(pte_t *)pmd;\n\t\tstruct page *page;\n\n\t\tpage = can_gather_numa_stats(huge_pte, vma, addr);\n\t\tif (page)\n\t\t\tgather_stats(page, md, pte_dirty(huge_pte),\n\t\t\t\t     HPAGE_PMD_SIZE/PAGE_SIZE);\n\t\tspin_unlock(ptl);\n\t\treturn 0;\n\t}\n\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\n\torig_pte = pte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tdo {\n\t\tstruct page *page = can_gather_numa_stats(*pte, vma, addr);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tgather_stats(page, md, pte_dirty(*pte), 1);\n\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\tpte_unmap_unlock(orig_pte, ptl);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "orig_pte",
            "ptl"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gather_stats",
          "args": [
            "page",
            "md",
            "pte_dirty(*pte)",
            "1"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "gather_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "1362-1387",
          "snippet": "static void gather_stats(struct page *page, struct numa_maps *md, int pte_dirty,\n\t\t\tunsigned long nr_pages)\n{\n\tint count = page_mapcount(page);\n\n\tmd->pages += nr_pages;\n\tif (pte_dirty || PageDirty(page))\n\t\tmd->dirty += nr_pages;\n\n\tif (PageSwapCache(page))\n\t\tmd->swapcache += nr_pages;\n\n\tif (PageActive(page) || PageUnevictable(page))\n\t\tmd->active += nr_pages;\n\n\tif (PageWriteback(page))\n\t\tmd->writeback += nr_pages;\n\n\tif (PageAnon(page))\n\t\tmd->anon += nr_pages;\n\n\tif (count > md->mapcount_max)\n\t\tmd->mapcount_max = count;\n\n\tmd->node[page_to_nid(page)] += nr_pages;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void gather_stats(struct page *page, struct numa_maps *md, int pte_dirty,\n\t\t\tunsigned long nr_pages)\n{\n\tint count = page_mapcount(page);\n\n\tmd->pages += nr_pages;\n\tif (pte_dirty || PageDirty(page))\n\t\tmd->dirty += nr_pages;\n\n\tif (PageSwapCache(page))\n\t\tmd->swapcache += nr_pages;\n\n\tif (PageActive(page) || PageUnevictable(page))\n\t\tmd->active += nr_pages;\n\n\tif (PageWriteback(page))\n\t\tmd->writeback += nr_pages;\n\n\tif (PageAnon(page))\n\t\tmd->anon += nr_pages;\n\n\tif (count > md->mapcount_max)\n\t\tmd->mapcount_max = count;\n\n\tmd->node[page_to_nid(page)] += nr_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_dirty",
          "args": [
            "*pte"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "can_gather_numa_stats",
          "args": [
            "*pte",
            "vma",
            "addr"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "can_gather_numa_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "1389-1410",
          "snippet": "static struct page *can_gather_numa_stats(pte_t pte, struct vm_area_struct *vma,\n\t\tunsigned long addr)\n{\n\tstruct page *page;\n\tint nid;\n\n\tif (!pte_present(pte))\n\t\treturn NULL;\n\n\tpage = vm_normal_page(vma, addr, pte);\n\tif (!page)\n\t\treturn NULL;\n\n\tif (PageReserved(page))\n\t\treturn NULL;\n\n\tnid = page_to_nid(page);\n\tif (!node_isset(nid, node_states[N_MEMORY]))\n\t\treturn NULL;\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic struct page *can_gather_numa_stats(pte_t pte, struct vm_area_struct *vma,\n\t\tunsigned long addr)\n{\n\tstruct page *page;\n\tint nid;\n\n\tif (!pte_present(pte))\n\t\treturn NULL;\n\n\tpage = vm_normal_page(vma, addr, pte);\n\tif (!page)\n\t\treturn NULL;\n\n\tif (PageReserved(page))\n\t\treturn NULL;\n\n\tnid = page_to_nid(page);\n\tif (!node_isset(nid, node_states[N_MEMORY]))\n\t\treturn NULL;\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "walk->mm",
            "pmd",
            "addr",
            "&ptl"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_unstable",
          "args": [
            "pmd"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_dirty",
          "args": [
            "huge_pte"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge_lock",
          "args": [
            "pmd",
            "vma",
            "&ptl"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int gather_pte_stats(pmd_t *pmd, unsigned long addr,\n\t\tunsigned long end, struct mm_walk *walk)\n{\n\tstruct numa_maps *md = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tspinlock_t *ptl;\n\tpte_t *orig_pte;\n\tpte_t *pte;\n\n\tif (pmd_trans_huge_lock(pmd, vma, &ptl) == 1) {\n\t\tpte_t huge_pte = *(pte_t *)pmd;\n\t\tstruct page *page;\n\n\t\tpage = can_gather_numa_stats(huge_pte, vma, addr);\n\t\tif (page)\n\t\t\tgather_stats(page, md, pte_dirty(huge_pte),\n\t\t\t\t     HPAGE_PMD_SIZE/PAGE_SIZE);\n\t\tspin_unlock(ptl);\n\t\treturn 0;\n\t}\n\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\n\torig_pte = pte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tdo {\n\t\tstruct page *page = can_gather_numa_stats(*pte, vma, addr);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tgather_stats(page, md, pte_dirty(*pte), 1);\n\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\tpte_unmap_unlock(orig_pte, ptl);\n\treturn 0;\n}"
  },
  {
    "function_name": "can_gather_numa_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "1389-1410",
    "snippet": "static struct page *can_gather_numa_stats(pte_t pte, struct vm_area_struct *vma,\n\t\tunsigned long addr)\n{\n\tstruct page *page;\n\tint nid;\n\n\tif (!pte_present(pte))\n\t\treturn NULL;\n\n\tpage = vm_normal_page(vma, addr, pte);\n\tif (!page)\n\t\treturn NULL;\n\n\tif (PageReserved(page))\n\t\treturn NULL;\n\n\tnid = page_to_nid(page);\n\tif (!node_isset(nid, node_states[N_MEMORY]))\n\t\treturn NULL;\n\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_isset",
          "args": [
            "nid",
            "node_states[N_MEMORY]"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageReserved",
          "args": [
            "page"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_normal_page",
          "args": [
            "vma",
            "addr",
            "pte"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "pte"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic struct page *can_gather_numa_stats(pte_t pte, struct vm_area_struct *vma,\n\t\tunsigned long addr)\n{\n\tstruct page *page;\n\tint nid;\n\n\tif (!pte_present(pte))\n\t\treturn NULL;\n\n\tpage = vm_normal_page(vma, addr, pte);\n\tif (!page)\n\t\treturn NULL;\n\n\tif (PageReserved(page))\n\t\treturn NULL;\n\n\tnid = page_to_nid(page);\n\tif (!node_isset(nid, node_states[N_MEMORY]))\n\t\treturn NULL;\n\n\treturn page;\n}"
  },
  {
    "function_name": "gather_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "1362-1387",
    "snippet": "static void gather_stats(struct page *page, struct numa_maps *md, int pte_dirty,\n\t\t\tunsigned long nr_pages)\n{\n\tint count = page_mapcount(page);\n\n\tmd->pages += nr_pages;\n\tif (pte_dirty || PageDirty(page))\n\t\tmd->dirty += nr_pages;\n\n\tif (PageSwapCache(page))\n\t\tmd->swapcache += nr_pages;\n\n\tif (PageActive(page) || PageUnevictable(page))\n\t\tmd->active += nr_pages;\n\n\tif (PageWriteback(page))\n\t\tmd->writeback += nr_pages;\n\n\tif (PageAnon(page))\n\t\tmd->anon += nr_pages;\n\n\tif (count > md->mapcount_max)\n\t\tmd->mapcount_max = count;\n\n\tmd->node[page_to_nid(page)] += nr_pages;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUnevictable",
          "args": [
            "page"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageActive",
          "args": [
            "page"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void gather_stats(struct page *page, struct numa_maps *md, int pte_dirty,\n\t\t\tunsigned long nr_pages)\n{\n\tint count = page_mapcount(page);\n\n\tmd->pages += nr_pages;\n\tif (pte_dirty || PageDirty(page))\n\t\tmd->dirty += nr_pages;\n\n\tif (PageSwapCache(page))\n\t\tmd->swapcache += nr_pages;\n\n\tif (PageActive(page) || PageUnevictable(page))\n\t\tmd->active += nr_pages;\n\n\tif (PageWriteback(page))\n\t\tmd->writeback += nr_pages;\n\n\tif (PageAnon(page))\n\t\tmd->anon += nr_pages;\n\n\tif (count > md->mapcount_max)\n\t\tmd->mapcount_max = count;\n\n\tmd->node[page_to_nid(page)] += nr_pages;\n}"
  },
  {
    "function_name": "pagemap_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "1326-1335",
    "snippet": "static int pagemap_open(struct inode *inode, struct file *file)\n{\n\t/* do not disclose physical addresses: attack vector */\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tpr_warn_once(\"Bits 55-60 of /proc/PID/pagemap entries are about \"\n\t\t\t\"to stop being page-shift some time soon. See the \"\n\t\t\t\"linux/Documentation/vm/pagemap.txt for details.\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "\"Bits 55-60 of /proc/PID/pagemap entries are about \"\n\t\t\t\"to stop being page-shift some time soon. See the \"\n\t\t\t\"linux/Documentation/vm/pagemap.txt for details.\\n\""
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int pagemap_open(struct inode *inode, struct file *file)\n{\n\t/* do not disclose physical addresses: attack vector */\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tpr_warn_once(\"Bits 55-60 of /proc/PID/pagemap entries are about \"\n\t\t\t\"to stop being page-shift some time soon. See the \"\n\t\t\t\"linux/Documentation/vm/pagemap.txt for details.\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "pagemap_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "1227-1324",
    "snippet": "static ssize_t pagemap_read(struct file *file, char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tstruct mm_struct *mm;\n\tstruct pagemapread pm;\n\tint ret = -ESRCH;\n\tstruct mm_walk pagemap_walk = {};\n\tunsigned long src;\n\tunsigned long svpfn;\n\tunsigned long start_vaddr;\n\tunsigned long end_vaddr;\n\tint copied = 0;\n\n\tif (!task)\n\t\tgoto out;\n\n\tret = -EINVAL;\n\t/* file position must be aligned */\n\tif ((*ppos % PM_ENTRY_BYTES) || (count % PM_ENTRY_BYTES))\n\t\tgoto out_task;\n\n\tret = 0;\n\tif (!count)\n\t\tgoto out_task;\n\n\tpm.v2 = soft_dirty_cleared;\n\tpm.len = (PAGEMAP_WALK_SIZE >> PAGE_SHIFT);\n\tpm.buffer = kmalloc(pm.len * PM_ENTRY_BYTES, GFP_TEMPORARY);\n\tret = -ENOMEM;\n\tif (!pm.buffer)\n\t\tgoto out_task;\n\n\tmm = mm_access(task, PTRACE_MODE_READ);\n\tret = PTR_ERR(mm);\n\tif (!mm || IS_ERR(mm))\n\t\tgoto out_free;\n\n\tpagemap_walk.pmd_entry = pagemap_pte_range;\n\tpagemap_walk.pte_hole = pagemap_pte_hole;\n#ifdef CONFIG_HUGETLB_PAGE\n\tpagemap_walk.hugetlb_entry = pagemap_hugetlb_range;\n#endif\n\tpagemap_walk.mm = mm;\n\tpagemap_walk.private = &pm;\n\n\tsrc = *ppos;\n\tsvpfn = src / PM_ENTRY_BYTES;\n\tstart_vaddr = svpfn << PAGE_SHIFT;\n\tend_vaddr = TASK_SIZE_OF(task);\n\n\t/* watch out for wraparound */\n\tif (svpfn > TASK_SIZE_OF(task) >> PAGE_SHIFT)\n\t\tstart_vaddr = end_vaddr;\n\n\t/*\n\t * The odds are that this will stop walking way\n\t * before end_vaddr, because the length of the\n\t * user buffer is tracked in \"pm\", and the walk\n\t * will stop when we hit the end of the buffer.\n\t */\n\tret = 0;\n\twhile (count && (start_vaddr < end_vaddr)) {\n\t\tint len;\n\t\tunsigned long end;\n\n\t\tpm.pos = 0;\n\t\tend = (start_vaddr + PAGEMAP_WALK_SIZE) & PAGEMAP_WALK_MASK;\n\t\t/* overflow ? */\n\t\tif (end < start_vaddr || end > end_vaddr)\n\t\t\tend = end_vaddr;\n\t\tdown_read(&mm->mmap_sem);\n\t\tret = walk_page_range(start_vaddr, end, &pagemap_walk);\n\t\tup_read(&mm->mmap_sem);\n\t\tstart_vaddr = end;\n\n\t\tlen = min(count, PM_ENTRY_BYTES * pm.pos);\n\t\tif (copy_to_user(buf, pm.buffer, len)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_mm;\n\t\t}\n\t\tcopied += len;\n\t\tbuf += len;\n\t\tcount -= len;\n\t}\n\t*ppos += copied;\n\tif (!ret || ret == PM_END_OF_BUFFER)\n\t\tret = copied;\n\nout_mm:\n\tmmput(mm);\nout_free:\n\tkfree(pm.buffer);\nout_task:\n\tput_task_struct(task);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define PM_END_OF_BUFFER    1",
      "#define PM_ENTRY_BYTES      sizeof(pagemap_entry_t)",
      "#define PAGEMAP_WALK_MASK\t(PMD_MASK)",
      "#define PAGEMAP_WALK_SIZE\t(PMD_SIZE)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pm.buffer"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "pm.buffer",
            "len"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "count",
            "PM_ENTRY_BYTES * pm.pos"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "meminfo_proc_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/meminfo.c",
          "lines": "217-220",
          "snippet": "static int meminfo_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, meminfo_proc_show, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/cma.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/swap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quicklist.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/cma.h>\n#include <linux/vmalloc.h>\n#include <linux/atomic.h>\n#include <linux/vmstat.h>\n#include <linux/swap.h>\n#include <linux/seq_file.h>\n#include <linux/quicklist.h>\n#include <linux/proc_fs.h>\n#include <linux/mmzone.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int meminfo_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, meminfo_proc_show, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_page_range",
          "args": [
            "start_vaddr",
            "end",
            "&pagemap_walk"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TASK_SIZE_OF",
          "args": [
            "task"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TASK_SIZE_OF",
          "args": [
            "task"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mm"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mm"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_access",
          "args": [
            "task",
            "PTRACE_MODE_READ"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "pm.len * PM_ENTRY_BYTES",
            "GFP_TEMPORARY"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "file_inode(file)"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\n#define PM_END_OF_BUFFER    1\n#define PM_ENTRY_BYTES      sizeof(pagemap_entry_t)\n#define PAGEMAP_WALK_MASK\t(PMD_MASK)\n#define PAGEMAP_WALK_SIZE\t(PMD_SIZE)\n\nstatic ssize_t pagemap_read(struct file *file, char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tstruct mm_struct *mm;\n\tstruct pagemapread pm;\n\tint ret = -ESRCH;\n\tstruct mm_walk pagemap_walk = {};\n\tunsigned long src;\n\tunsigned long svpfn;\n\tunsigned long start_vaddr;\n\tunsigned long end_vaddr;\n\tint copied = 0;\n\n\tif (!task)\n\t\tgoto out;\n\n\tret = -EINVAL;\n\t/* file position must be aligned */\n\tif ((*ppos % PM_ENTRY_BYTES) || (count % PM_ENTRY_BYTES))\n\t\tgoto out_task;\n\n\tret = 0;\n\tif (!count)\n\t\tgoto out_task;\n\n\tpm.v2 = soft_dirty_cleared;\n\tpm.len = (PAGEMAP_WALK_SIZE >> PAGE_SHIFT);\n\tpm.buffer = kmalloc(pm.len * PM_ENTRY_BYTES, GFP_TEMPORARY);\n\tret = -ENOMEM;\n\tif (!pm.buffer)\n\t\tgoto out_task;\n\n\tmm = mm_access(task, PTRACE_MODE_READ);\n\tret = PTR_ERR(mm);\n\tif (!mm || IS_ERR(mm))\n\t\tgoto out_free;\n\n\tpagemap_walk.pmd_entry = pagemap_pte_range;\n\tpagemap_walk.pte_hole = pagemap_pte_hole;\n#ifdef CONFIG_HUGETLB_PAGE\n\tpagemap_walk.hugetlb_entry = pagemap_hugetlb_range;\n#endif\n\tpagemap_walk.mm = mm;\n\tpagemap_walk.private = &pm;\n\n\tsrc = *ppos;\n\tsvpfn = src / PM_ENTRY_BYTES;\n\tstart_vaddr = svpfn << PAGE_SHIFT;\n\tend_vaddr = TASK_SIZE_OF(task);\n\n\t/* watch out for wraparound */\n\tif (svpfn > TASK_SIZE_OF(task) >> PAGE_SHIFT)\n\t\tstart_vaddr = end_vaddr;\n\n\t/*\n\t * The odds are that this will stop walking way\n\t * before end_vaddr, because the length of the\n\t * user buffer is tracked in \"pm\", and the walk\n\t * will stop when we hit the end of the buffer.\n\t */\n\tret = 0;\n\twhile (count && (start_vaddr < end_vaddr)) {\n\t\tint len;\n\t\tunsigned long end;\n\n\t\tpm.pos = 0;\n\t\tend = (start_vaddr + PAGEMAP_WALK_SIZE) & PAGEMAP_WALK_MASK;\n\t\t/* overflow ? */\n\t\tif (end < start_vaddr || end > end_vaddr)\n\t\t\tend = end_vaddr;\n\t\tdown_read(&mm->mmap_sem);\n\t\tret = walk_page_range(start_vaddr, end, &pagemap_walk);\n\t\tup_read(&mm->mmap_sem);\n\t\tstart_vaddr = end;\n\n\t\tlen = min(count, PM_ENTRY_BYTES * pm.pos);\n\t\tif (copy_to_user(buf, pm.buffer, len)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_mm;\n\t\t}\n\t\tcopied += len;\n\t\tbuf += len;\n\t\tcount -= len;\n\t}\n\t*ppos += copied;\n\tif (!ret || ret == PM_END_OF_BUFFER)\n\t\tret = copied;\n\nout_mm:\n\tmmput(mm);\nout_free:\n\tkfree(pm.buffer);\nout_task:\n\tput_task_struct(task);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "pagemap_hugetlb_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "1174-1200",
    "snippet": "static int pagemap_hugetlb_range(pte_t *pte, unsigned long hmask,\n\t\t\t\t unsigned long addr, unsigned long end,\n\t\t\t\t struct mm_walk *walk)\n{\n\tstruct pagemapread *pm = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tint err = 0;\n\tint flags2;\n\tpagemap_entry_t pme;\n\n\tif (vma->vm_flags & VM_SOFTDIRTY)\n\t\tflags2 = __PM_SOFT_DIRTY;\n\telse\n\t\tflags2 = 0;\n\n\tfor (; addr != end; addr += PAGE_SIZE) {\n\t\tint offset = (addr & ~hmask) >> PAGE_SHIFT;\n\t\thuge_pte_to_pagemap_entry(&pme, pm, *pte, offset, flags2);\n\t\terr = add_to_pagemap(addr, &pme, pm);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tcond_resched();\n\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define __PM_SOFT_DIRTY      (1LL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_pagemap",
          "args": [
            "addr",
            "&pme",
            "pm"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_pagemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "996-1003",
          "snippet": "static int add_to_pagemap(unsigned long addr, pagemap_entry_t *pme,\n\t\t\t  struct pagemapread *pm)\n{\n\tpm->buffer[pm->pos++] = *pme;\n\tif (pm->pos >= pm->len)\n\t\treturn PM_END_OF_BUFFER;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define PM_END_OF_BUFFER    1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\n#define PM_END_OF_BUFFER    1\n\nstatic int add_to_pagemap(unsigned long addr, pagemap_entry_t *pme,\n\t\t\t  struct pagemapread *pm)\n{\n\tpm->buffer[pm->pos++] = *pme;\n\tif (pm->pos >= pm->len)\n\t\treturn PM_END_OF_BUFFER;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_pte_to_pagemap_entry",
          "args": [
            "&pme",
            "pm",
            "*pte",
            "offset",
            "flags2"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pte_to_pagemap_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "1161-1171",
          "snippet": "static void huge_pte_to_pagemap_entry(pagemap_entry_t *pme, struct pagemapread *pm,\n\t\t\t\t\tpte_t pte, int offset, int flags2)\n{\n\tif (pte_present(pte))\n\t\t*pme = make_pme(PM_PFRAME(pte_pfn(pte) + offset)\t|\n\t\t\t\tPM_STATUS2(pm->v2, flags2)\t\t|\n\t\t\t\tPM_PRESENT);\n\telse\n\t\t*pme = make_pme(PM_NOT_PRESENT(pm->v2)\t\t\t|\n\t\t\t\tPM_STATUS2(pm->v2, flags2));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define PM_PRESENT          PM_STATUS(4LL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\n#define PM_PRESENT          PM_STATUS(4LL)\n\nstatic void huge_pte_to_pagemap_entry(pagemap_entry_t *pme, struct pagemapread *pm,\n\t\t\t\t\tpte_t pte, int offset, int flags2)\n{\n\tif (pte_present(pte))\n\t\t*pme = make_pme(PM_PFRAME(pte_pfn(pte) + offset)\t|\n\t\t\t\tPM_STATUS2(pm->v2, flags2)\t\t|\n\t\t\t\tPM_PRESENT);\n\telse\n\t\t*pme = make_pme(PM_NOT_PRESENT(pm->v2)\t\t\t|\n\t\t\t\tPM_STATUS2(pm->v2, flags2));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\n#define __PM_SOFT_DIRTY      (1LL)\n\nstatic int pagemap_hugetlb_range(pte_t *pte, unsigned long hmask,\n\t\t\t\t unsigned long addr, unsigned long end,\n\t\t\t\t struct mm_walk *walk)\n{\n\tstruct pagemapread *pm = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tint err = 0;\n\tint flags2;\n\tpagemap_entry_t pme;\n\n\tif (vma->vm_flags & VM_SOFTDIRTY)\n\t\tflags2 = __PM_SOFT_DIRTY;\n\telse\n\t\tflags2 = 0;\n\n\tfor (; addr != end; addr += PAGE_SIZE) {\n\t\tint offset = (addr & ~hmask) >> PAGE_SHIFT;\n\t\thuge_pte_to_pagemap_entry(&pme, pm, *pte, offset, flags2);\n\t\terr = add_to_pagemap(addr, &pme, pm);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tcond_resched();\n\n\treturn err;\n}"
  },
  {
    "function_name": "huge_pte_to_pagemap_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "1161-1171",
    "snippet": "static void huge_pte_to_pagemap_entry(pagemap_entry_t *pme, struct pagemapread *pm,\n\t\t\t\t\tpte_t pte, int offset, int flags2)\n{\n\tif (pte_present(pte))\n\t\t*pme = make_pme(PM_PFRAME(pte_pfn(pte) + offset)\t|\n\t\t\t\tPM_STATUS2(pm->v2, flags2)\t\t|\n\t\t\t\tPM_PRESENT);\n\telse\n\t\t*pme = make_pme(PM_NOT_PRESENT(pm->v2)\t\t\t|\n\t\t\t\tPM_STATUS2(pm->v2, flags2));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define PM_PRESENT          PM_STATUS(4LL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "make_pme",
          "args": [
            "PM_NOT_PRESENT(pm->v2)\t\t\t|\n\t\t\t\tPM_STATUS2(pm->v2, flags2)"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "make_pme",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "991-994",
          "snippet": "static inline pagemap_entry_t make_pme(u64 val)\n{\n\treturn (pagemap_entry_t) { .pme = val };\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic inline pagemap_entry_t make_pme(u64 val)\n{\n\treturn (pagemap_entry_t) { .pme = val };\n}"
        }
      },
      {
        "call_info": {
          "callee": "PM_STATUS2",
          "args": [
            "pm->v2",
            "flags2"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PM_NOT_PRESENT",
          "args": [
            "pm->v2"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PM_STATUS2",
          "args": [
            "pm->v2",
            "flags2"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PM_PFRAME",
          "args": [
            "pte_pfn(pte) + offset"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "pte"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "pte"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\n#define PM_PRESENT          PM_STATUS(4LL)\n\nstatic void huge_pte_to_pagemap_entry(pagemap_entry_t *pme, struct pagemapread *pm,\n\t\t\t\t\tpte_t pte, int offset, int flags2)\n{\n\tif (pte_present(pte))\n\t\t*pme = make_pme(PM_PFRAME(pte_pfn(pte) + offset)\t|\n\t\t\t\tPM_STATUS2(pm->v2, flags2)\t\t|\n\t\t\t\tPM_PRESENT);\n\telse\n\t\t*pme = make_pme(PM_NOT_PRESENT(pm->v2)\t\t\t|\n\t\t\t\tPM_STATUS2(pm->v2, flags2));\n}"
  },
  {
    "function_name": "pagemap_pte_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "1105-1158",
    "snippet": "static int pagemap_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\t     struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct pagemapread *pm = walk->private;\n\tspinlock_t *ptl;\n\tpte_t *pte, *orig_pte;\n\tint err = 0;\n\n\tif (pmd_trans_huge_lock(pmd, vma, &ptl) == 1) {\n\t\tint pmd_flags2;\n\n\t\tif ((vma->vm_flags & VM_SOFTDIRTY) || pmd_soft_dirty(*pmd))\n\t\t\tpmd_flags2 = __PM_SOFT_DIRTY;\n\t\telse\n\t\t\tpmd_flags2 = 0;\n\n\t\tfor (; addr != end; addr += PAGE_SIZE) {\n\t\t\tunsigned long offset;\n\t\t\tpagemap_entry_t pme;\n\n\t\t\toffset = (addr & ~PAGEMAP_WALK_MASK) >>\n\t\t\t\t\tPAGE_SHIFT;\n\t\t\tthp_pmd_to_pagemap_entry(&pme, pm, *pmd, offset, pmd_flags2);\n\t\t\terr = add_to_pagemap(addr, &pme, pm);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(ptl);\n\t\treturn err;\n\t}\n\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\n\n\t/*\n\t * We can assume that @vma always points to a valid one and @end never\n\t * goes beyond vma->vm_end.\n\t */\n\torig_pte = pte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tfor (; addr < end; pte++, addr += PAGE_SIZE) {\n\t\tpagemap_entry_t pme;\n\n\t\tpte_to_pagemap_entry(&pme, pm, vma, addr, *pte);\n\t\terr = add_to_pagemap(addr, &pme, pm);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tpte_unmap_unlock(orig_pte, ptl);\n\n\tcond_resched();\n\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define __PM_SOFT_DIRTY      (1LL)",
      "#define PAGEMAP_WALK_MASK\t(PMD_MASK)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "orig_pte",
            "ptl"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_pagemap",
          "args": [
            "addr",
            "&pme",
            "pm"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_pagemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "996-1003",
          "snippet": "static int add_to_pagemap(unsigned long addr, pagemap_entry_t *pme,\n\t\t\t  struct pagemapread *pm)\n{\n\tpm->buffer[pm->pos++] = *pme;\n\tif (pm->pos >= pm->len)\n\t\treturn PM_END_OF_BUFFER;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define PM_END_OF_BUFFER    1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\n#define PM_END_OF_BUFFER    1\n\nstatic int add_to_pagemap(unsigned long addr, pagemap_entry_t *pme,\n\t\t\t  struct pagemapread *pm)\n{\n\tpm->buffer[pm->pos++] = *pme;\n\tif (pm->pos >= pm->len)\n\t\treturn PM_END_OF_BUFFER;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_to_pagemap_entry",
          "args": [
            "&pme",
            "pm",
            "vma",
            "addr",
            "*pte"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pte_to_pagemap_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "1161-1171",
          "snippet": "static void huge_pte_to_pagemap_entry(pagemap_entry_t *pme, struct pagemapread *pm,\n\t\t\t\t\tpte_t pte, int offset, int flags2)\n{\n\tif (pte_present(pte))\n\t\t*pme = make_pme(PM_PFRAME(pte_pfn(pte) + offset)\t|\n\t\t\t\tPM_STATUS2(pm->v2, flags2)\t\t|\n\t\t\t\tPM_PRESENT);\n\telse\n\t\t*pme = make_pme(PM_NOT_PRESENT(pm->v2)\t\t\t|\n\t\t\t\tPM_STATUS2(pm->v2, flags2));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define PM_PRESENT          PM_STATUS(4LL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\n#define PM_PRESENT          PM_STATUS(4LL)\n\nstatic void huge_pte_to_pagemap_entry(pagemap_entry_t *pme, struct pagemapread *pm,\n\t\t\t\t\tpte_t pte, int offset, int flags2)\n{\n\tif (pte_present(pte))\n\t\t*pme = make_pme(PM_PFRAME(pte_pfn(pte) + offset)\t|\n\t\t\t\tPM_STATUS2(pm->v2, flags2)\t\t|\n\t\t\t\tPM_PRESENT);\n\telse\n\t\t*pme = make_pme(PM_NOT_PRESENT(pm->v2)\t\t\t|\n\t\t\t\tPM_STATUS2(pm->v2, flags2));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "walk->mm",
            "pmd",
            "addr",
            "&ptl"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_unstable",
          "args": [
            "pmd"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "thp_pmd_to_pagemap_entry",
          "args": [
            "&pme",
            "pm",
            "*pmd",
            "offset",
            "pmd_flags2"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "thp_pmd_to_pagemap_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "1099-1102",
          "snippet": "static inline void thp_pmd_to_pagemap_entry(pagemap_entry_t *pme, struct pagemapread *pm,\n\t\tpmd_t pmd, int offset, int pmd_flags2)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic inline void thp_pmd_to_pagemap_entry(pagemap_entry_t *pme, struct pagemapread *pm,\n\t\tpmd_t pmd, int offset, int pmd_flags2)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_soft_dirty",
          "args": [
            "*pmd"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge_lock",
          "args": [
            "pmd",
            "vma",
            "&ptl"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\n#define __PM_SOFT_DIRTY      (1LL)\n#define PAGEMAP_WALK_MASK\t(PMD_MASK)\n\nstatic int pagemap_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\t     struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct pagemapread *pm = walk->private;\n\tspinlock_t *ptl;\n\tpte_t *pte, *orig_pte;\n\tint err = 0;\n\n\tif (pmd_trans_huge_lock(pmd, vma, &ptl) == 1) {\n\t\tint pmd_flags2;\n\n\t\tif ((vma->vm_flags & VM_SOFTDIRTY) || pmd_soft_dirty(*pmd))\n\t\t\tpmd_flags2 = __PM_SOFT_DIRTY;\n\t\telse\n\t\t\tpmd_flags2 = 0;\n\n\t\tfor (; addr != end; addr += PAGE_SIZE) {\n\t\t\tunsigned long offset;\n\t\t\tpagemap_entry_t pme;\n\n\t\t\toffset = (addr & ~PAGEMAP_WALK_MASK) >>\n\t\t\t\t\tPAGE_SHIFT;\n\t\t\tthp_pmd_to_pagemap_entry(&pme, pm, *pmd, offset, pmd_flags2);\n\t\t\terr = add_to_pagemap(addr, &pme, pm);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(ptl);\n\t\treturn err;\n\t}\n\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\n\n\t/*\n\t * We can assume that @vma always points to a valid one and @end never\n\t * goes beyond vma->vm_end.\n\t */\n\torig_pte = pte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tfor (; addr < end; pte++, addr += PAGE_SIZE) {\n\t\tpagemap_entry_t pme;\n\n\t\tpte_to_pagemap_entry(&pme, pm, vma, addr, *pte);\n\t\terr = add_to_pagemap(addr, &pme, pm);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tpte_unmap_unlock(orig_pte, ptl);\n\n\tcond_resched();\n\n\treturn err;\n}"
  },
  {
    "function_name": "thp_pmd_to_pagemap_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "1099-1102",
    "snippet": "static inline void thp_pmd_to_pagemap_entry(pagemap_entry_t *pme, struct pagemapread *pm,\n\t\tpmd_t pmd, int offset, int pmd_flags2)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic inline void thp_pmd_to_pagemap_entry(pagemap_entry_t *pme, struct pagemapread *pm,\n\t\tpmd_t pmd, int offset, int pmd_flags2)\n{\n}"
  },
  {
    "function_name": "thp_pmd_to_pagemap_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "1084-1097",
    "snippet": "static void thp_pmd_to_pagemap_entry(pagemap_entry_t *pme, struct pagemapread *pm,\n\t\tpmd_t pmd, int offset, int pmd_flags2)\n{\n\t/*\n\t * Currently pmd for thp is always present because thp can not be\n\t * swapped-out, migrated, or HWPOISONed (split in such cases instead.)\n\t * This if-check is just to prepare for future implementation.\n\t */\n\tif (pmd_present(pmd))\n\t\t*pme = make_pme(PM_PFRAME(pmd_pfn(pmd) + offset)\n\t\t\t\t| PM_STATUS2(pm->v2, pmd_flags2) | PM_PRESENT);\n\telse\n\t\t*pme = make_pme(PM_NOT_PRESENT(pm->v2) | PM_STATUS2(pm->v2, pmd_flags2));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define PM_PRESENT          PM_STATUS(4LL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "make_pme",
          "args": [
            "PM_NOT_PRESENT(pm->v2) | PM_STATUS2(pm->v2, pmd_flags2)"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "make_pme",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "991-994",
          "snippet": "static inline pagemap_entry_t make_pme(u64 val)\n{\n\treturn (pagemap_entry_t) { .pme = val };\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic inline pagemap_entry_t make_pme(u64 val)\n{\n\treturn (pagemap_entry_t) { .pme = val };\n}"
        }
      },
      {
        "call_info": {
          "callee": "PM_STATUS2",
          "args": [
            "pm->v2",
            "pmd_flags2"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PM_NOT_PRESENT",
          "args": [
            "pm->v2"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PM_STATUS2",
          "args": [
            "pm->v2",
            "pmd_flags2"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PM_PFRAME",
          "args": [
            "pmd_pfn(pmd) + offset"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_pfn",
          "args": [
            "pmd"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_present",
          "args": [
            "pmd"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\n#define PM_PRESENT          PM_STATUS(4LL)\n\nstatic void thp_pmd_to_pagemap_entry(pagemap_entry_t *pme, struct pagemapread *pm,\n\t\tpmd_t pmd, int offset, int pmd_flags2)\n{\n\t/*\n\t * Currently pmd for thp is always present because thp can not be\n\t * swapped-out, migrated, or HWPOISONed (split in such cases instead.)\n\t * This if-check is just to prepare for future implementation.\n\t */\n\tif (pmd_present(pmd))\n\t\t*pme = make_pme(PM_PFRAME(pmd_pfn(pmd) + offset)\n\t\t\t\t| PM_STATUS2(pm->v2, pmd_flags2) | PM_PRESENT);\n\telse\n\t\t*pme = make_pme(PM_NOT_PRESENT(pm->v2) | PM_STATUS2(pm->v2, pmd_flags2));\n}"
  },
  {
    "function_name": "pte_to_pagemap_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "1045-1081",
    "snippet": "static void pte_to_pagemap_entry(pagemap_entry_t *pme, struct pagemapread *pm,\n\t\tstruct vm_area_struct *vma, unsigned long addr, pte_t pte)\n{\n\tu64 frame, flags;\n\tstruct page *page = NULL;\n\tint flags2 = 0;\n\n\tif (pte_present(pte)) {\n\t\tframe = pte_pfn(pte);\n\t\tflags = PM_PRESENT;\n\t\tpage = vm_normal_page(vma, addr, pte);\n\t\tif (pte_soft_dirty(pte))\n\t\t\tflags2 |= __PM_SOFT_DIRTY;\n\t} else if (is_swap_pte(pte)) {\n\t\tswp_entry_t entry;\n\t\tif (pte_swp_soft_dirty(pte))\n\t\t\tflags2 |= __PM_SOFT_DIRTY;\n\t\tentry = pte_to_swp_entry(pte);\n\t\tframe = swp_type(entry) |\n\t\t\t(swp_offset(entry) << MAX_SWAPFILES_SHIFT);\n\t\tflags = PM_SWAP;\n\t\tif (is_migration_entry(entry))\n\t\t\tpage = migration_entry_to_page(entry);\n\t} else {\n\t\tif (vma->vm_flags & VM_SOFTDIRTY)\n\t\t\tflags2 |= __PM_SOFT_DIRTY;\n\t\t*pme = make_pme(PM_NOT_PRESENT(pm->v2) | PM_STATUS2(pm->v2, flags2));\n\t\treturn;\n\t}\n\n\tif (page && !PageAnon(page))\n\t\tflags |= PM_FILE;\n\tif ((vma->vm_flags & VM_SOFTDIRTY))\n\t\tflags2 |= __PM_SOFT_DIRTY;\n\n\t*pme = make_pme(PM_PFRAME(frame) | PM_STATUS2(pm->v2, flags2) | flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define PM_FILE             PM_STATUS(1LL)",
      "#define PM_SWAP             PM_STATUS(2LL)",
      "#define PM_PRESENT          PM_STATUS(4LL)",
      "#define __PM_SOFT_DIRTY      (1LL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "make_pme",
          "args": [
            "PM_PFRAME(frame) | PM_STATUS2(pm->v2, flags2) | flags"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "make_pme",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "991-994",
          "snippet": "static inline pagemap_entry_t make_pme(u64 val)\n{\n\treturn (pagemap_entry_t) { .pme = val };\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic inline pagemap_entry_t make_pme(u64 val)\n{\n\treturn (pagemap_entry_t) { .pme = val };\n}"
        }
      },
      {
        "call_info": {
          "callee": "PM_STATUS2",
          "args": [
            "pm->v2",
            "flags2"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PM_PFRAME",
          "args": [
            "frame"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PM_STATUS2",
          "args": [
            "pm->v2",
            "flags2"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PM_NOT_PRESENT",
          "args": [
            "pm->v2"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migration_entry_to_page",
          "args": [
            "entry"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migration_entry",
          "args": [
            "entry"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_type",
          "args": [
            "entry"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "pte"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_swp_soft_dirty",
          "args": [
            "pte"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swap_pte",
          "args": [
            "pte"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_soft_dirty",
          "args": [
            "pte"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_normal_page",
          "args": [
            "vma",
            "addr",
            "pte"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "pte"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "pte"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\n#define PM_FILE             PM_STATUS(1LL)\n#define PM_SWAP             PM_STATUS(2LL)\n#define PM_PRESENT          PM_STATUS(4LL)\n#define __PM_SOFT_DIRTY      (1LL)\n\nstatic void pte_to_pagemap_entry(pagemap_entry_t *pme, struct pagemapread *pm,\n\t\tstruct vm_area_struct *vma, unsigned long addr, pte_t pte)\n{\n\tu64 frame, flags;\n\tstruct page *page = NULL;\n\tint flags2 = 0;\n\n\tif (pte_present(pte)) {\n\t\tframe = pte_pfn(pte);\n\t\tflags = PM_PRESENT;\n\t\tpage = vm_normal_page(vma, addr, pte);\n\t\tif (pte_soft_dirty(pte))\n\t\t\tflags2 |= __PM_SOFT_DIRTY;\n\t} else if (is_swap_pte(pte)) {\n\t\tswp_entry_t entry;\n\t\tif (pte_swp_soft_dirty(pte))\n\t\t\tflags2 |= __PM_SOFT_DIRTY;\n\t\tentry = pte_to_swp_entry(pte);\n\t\tframe = swp_type(entry) |\n\t\t\t(swp_offset(entry) << MAX_SWAPFILES_SHIFT);\n\t\tflags = PM_SWAP;\n\t\tif (is_migration_entry(entry))\n\t\t\tpage = migration_entry_to_page(entry);\n\t} else {\n\t\tif (vma->vm_flags & VM_SOFTDIRTY)\n\t\t\tflags2 |= __PM_SOFT_DIRTY;\n\t\t*pme = make_pme(PM_NOT_PRESENT(pm->v2) | PM_STATUS2(pm->v2, flags2));\n\t\treturn;\n\t}\n\n\tif (page && !PageAnon(page))\n\t\tflags |= PM_FILE;\n\tif ((vma->vm_flags & VM_SOFTDIRTY))\n\t\tflags2 |= __PM_SOFT_DIRTY;\n\n\t*pme = make_pme(PM_PFRAME(frame) | PM_STATUS2(pm->v2, flags2) | flags);\n}"
  },
  {
    "function_name": "pagemap_pte_hole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "1005-1043",
    "snippet": "static int pagemap_pte_hole(unsigned long start, unsigned long end,\n\t\t\t\tstruct mm_walk *walk)\n{\n\tstruct pagemapread *pm = walk->private;\n\tunsigned long addr = start;\n\tint err = 0;\n\n\twhile (addr < end) {\n\t\tstruct vm_area_struct *vma = find_vma(walk->mm, addr);\n\t\tpagemap_entry_t pme = make_pme(PM_NOT_PRESENT(pm->v2));\n\t\t/* End of address space hole, which we mark as non-present. */\n\t\tunsigned long hole_end;\n\n\t\tif (vma)\n\t\t\thole_end = min(end, vma->vm_start);\n\t\telse\n\t\t\thole_end = end;\n\n\t\tfor (; addr < hole_end; addr += PAGE_SIZE) {\n\t\t\terr = add_to_pagemap(addr, &pme, pm);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (!vma)\n\t\t\tbreak;\n\n\t\t/* Addresses in the VMA. */\n\t\tif (vma->vm_flags & VM_SOFTDIRTY)\n\t\t\tpme.pme |= PM_STATUS2(pm->v2, __PM_SOFT_DIRTY);\n\t\tfor (; addr < min(end, vma->vm_end); addr += PAGE_SIZE) {\n\t\t\terr = add_to_pagemap(addr, &pme, pm);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define __PM_SOFT_DIRTY      (1LL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_to_pagemap",
          "args": [
            "addr",
            "&pme",
            "pm"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_pagemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "996-1003",
          "snippet": "static int add_to_pagemap(unsigned long addr, pagemap_entry_t *pme,\n\t\t\t  struct pagemapread *pm)\n{\n\tpm->buffer[pm->pos++] = *pme;\n\tif (pm->pos >= pm->len)\n\t\treturn PM_END_OF_BUFFER;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define PM_END_OF_BUFFER    1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\n#define PM_END_OF_BUFFER    1\n\nstatic int add_to_pagemap(unsigned long addr, pagemap_entry_t *pme,\n\t\t\t  struct pagemapread *pm)\n{\n\tpm->buffer[pm->pos++] = *pme;\n\tif (pm->pos >= pm->len)\n\t\treturn PM_END_OF_BUFFER;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end",
            "vma->vm_end"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "meminfo_proc_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/meminfo.c",
          "lines": "217-220",
          "snippet": "static int meminfo_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, meminfo_proc_show, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/cma.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/swap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quicklist.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/cma.h>\n#include <linux/vmalloc.h>\n#include <linux/atomic.h>\n#include <linux/vmstat.h>\n#include <linux/swap.h>\n#include <linux/seq_file.h>\n#include <linux/quicklist.h>\n#include <linux/proc_fs.h>\n#include <linux/mmzone.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int meminfo_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, meminfo_proc_show, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PM_STATUS2",
          "args": [
            "pm->v2",
            "__PM_SOFT_DIRTY"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_pme",
          "args": [
            "PM_NOT_PRESENT(pm->v2)"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "make_pme",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "991-994",
          "snippet": "static inline pagemap_entry_t make_pme(u64 val)\n{\n\treturn (pagemap_entry_t) { .pme = val };\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic inline pagemap_entry_t make_pme(u64 val)\n{\n\treturn (pagemap_entry_t) { .pme = val };\n}"
        }
      },
      {
        "call_info": {
          "callee": "PM_NOT_PRESENT",
          "args": [
            "pm->v2"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "walk->mm",
            "addr"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\n#define __PM_SOFT_DIRTY      (1LL)\n\nstatic int pagemap_pte_hole(unsigned long start, unsigned long end,\n\t\t\t\tstruct mm_walk *walk)\n{\n\tstruct pagemapread *pm = walk->private;\n\tunsigned long addr = start;\n\tint err = 0;\n\n\twhile (addr < end) {\n\t\tstruct vm_area_struct *vma = find_vma(walk->mm, addr);\n\t\tpagemap_entry_t pme = make_pme(PM_NOT_PRESENT(pm->v2));\n\t\t/* End of address space hole, which we mark as non-present. */\n\t\tunsigned long hole_end;\n\n\t\tif (vma)\n\t\t\thole_end = min(end, vma->vm_start);\n\t\telse\n\t\t\thole_end = end;\n\n\t\tfor (; addr < hole_end; addr += PAGE_SIZE) {\n\t\t\terr = add_to_pagemap(addr, &pme, pm);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (!vma)\n\t\t\tbreak;\n\n\t\t/* Addresses in the VMA. */\n\t\tif (vma->vm_flags & VM_SOFTDIRTY)\n\t\t\tpme.pme |= PM_STATUS2(pm->v2, __PM_SOFT_DIRTY);\n\t\tfor (; addr < min(end, vma->vm_end); addr += PAGE_SIZE) {\n\t\t\terr = add_to_pagemap(addr, &pme, pm);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "add_to_pagemap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "996-1003",
    "snippet": "static int add_to_pagemap(unsigned long addr, pagemap_entry_t *pme,\n\t\t\t  struct pagemapread *pm)\n{\n\tpm->buffer[pm->pos++] = *pme;\n\tif (pm->pos >= pm->len)\n\t\treturn PM_END_OF_BUFFER;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define PM_END_OF_BUFFER    1"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\n#define PM_END_OF_BUFFER    1\n\nstatic int add_to_pagemap(unsigned long addr, pagemap_entry_t *pme,\n\t\t\t  struct pagemapread *pm)\n{\n\tpm->buffer[pm->pos++] = *pme;\n\tif (pm->pos >= pm->len)\n\t\treturn PM_END_OF_BUFFER;\n\treturn 0;\n}"
  },
  {
    "function_name": "make_pme",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "991-994",
    "snippet": "static inline pagemap_entry_t make_pme(u64 val)\n{\n\treturn (pagemap_entry_t) { .pme = val };\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic inline pagemap_entry_t make_pme(u64 val)\n{\n\treturn (pagemap_entry_t) { .pme = val };\n}"
  },
  {
    "function_name": "clear_refs_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "867-950",
    "snippet": "static ssize_t clear_refs_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF];\n\tstruct mm_struct *mm;\n\tstruct vm_area_struct *vma;\n\tenum clear_refs_types type;\n\tint itype;\n\tint rv;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\trv = kstrtoint(strstrip(buffer), 10, &itype);\n\tif (rv < 0)\n\t\treturn rv;\n\ttype = (enum clear_refs_types)itype;\n\tif (type < CLEAR_REFS_ALL || type >= CLEAR_REFS_LAST)\n\t\treturn -EINVAL;\n\n\tif (type == CLEAR_REFS_SOFT_DIRTY) {\n\t\tsoft_dirty_cleared = true;\n\t\tpr_warn_once(\"The pagemap bits 55-60 has changed their meaning!\"\n\t\t\t     \" See the linux/Documentation/vm/pagemap.txt for \"\n\t\t\t     \"details.\\n\");\n\t}\n\n\ttask = get_proc_task(file_inode(file));\n\tif (!task)\n\t\treturn -ESRCH;\n\tmm = get_task_mm(task);\n\tif (mm) {\n\t\tstruct clear_refs_private cp = {\n\t\t\t.type = type,\n\t\t};\n\t\tstruct mm_walk clear_refs_walk = {\n\t\t\t.pmd_entry = clear_refs_pte_range,\n\t\t\t.test_walk = clear_refs_test_walk,\n\t\t\t.mm = mm,\n\t\t\t.private = &cp,\n\t\t};\n\n\t\tif (type == CLEAR_REFS_MM_HIWATER_RSS) {\n\t\t\t/*\n\t\t\t * Writing 5 to /proc/pid/clear_refs resets the peak\n\t\t\t * resident set size to this mm's current rss value.\n\t\t\t */\n\t\t\tdown_write(&mm->mmap_sem);\n\t\t\treset_mm_hiwater_rss(mm);\n\t\t\tup_write(&mm->mmap_sem);\n\t\t\tgoto out_mm;\n\t\t}\n\n\t\tdown_read(&mm->mmap_sem);\n\t\tif (type == CLEAR_REFS_SOFT_DIRTY) {\n\t\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\t\t\tif (!(vma->vm_flags & VM_SOFTDIRTY))\n\t\t\t\t\tcontinue;\n\t\t\t\tup_read(&mm->mmap_sem);\n\t\t\t\tdown_write(&mm->mmap_sem);\n\t\t\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\t\t\t\tvma->vm_flags &= ~VM_SOFTDIRTY;\n\t\t\t\t\tvma_set_page_prot(vma);\n\t\t\t\t}\n\t\t\t\tdowngrade_write(&mm->mmap_sem);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmmu_notifier_invalidate_range_start(mm, 0, -1);\n\t\t}\n\t\twalk_page_range(0, ~0UL, &clear_refs_walk);\n\t\tif (type == CLEAR_REFS_SOFT_DIRTY)\n\t\t\tmmu_notifier_invalidate_range_end(mm, 0, -1);\n\t\tflush_tlb_mm(mm);\n\t\tup_read(&mm->mmap_sem);\nout_mm:\n\t\tmmput(mm);\n\t}\n\tput_task_struct(task);\n\n\treturn count;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_tlb_mm",
          "args": [
            "mm"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_end",
          "args": [
            "mm",
            "0",
            "-1"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_page_range",
          "args": [
            "0",
            "~0UL",
            "&clear_refs_walk"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "mm",
            "0",
            "-1"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "downgrade_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_set_page_prot",
          "args": [
            "vma"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reset_mm_hiwater_rss",
          "args": [
            "mm"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_mm",
          "args": [
            "task"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "file_inode(file)"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "\"The pagemap bits 55-60 has changed their meaning!\"\n\t\t\t     \" See the linux/Documentation/vm/pagemap.txt for \"\n\t\t\t     \"details.\\n\""
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "strstrip(buffer)",
            "10",
            "&itype"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "suffix_kstrtoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "140-164",
          "snippet": "STATIC unsigned long\nsuffix_kstrtoint(char *s, unsigned int base, int *res)\n{\n\tint\tlast, shift_left_factor = 0, _res;\n\tchar\t*value = s;\n\n\tlast = strlen(value) - 1;\n\tif (value[last] == 'K' || value[last] == 'k') {\n\t\tshift_left_factor = 10;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'M' || value[last] == 'm') {\n\t\tshift_left_factor = 20;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'G' || value[last] == 'g') {\n\t\tshift_left_factor = 30;\n\t\tvalue[last] = '\\0';\n\t}\n\n\tif (kstrtoint(s, base, &_res))\n\t\treturn -EINVAL;\n\t*res = _res << shift_left_factor;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC unsigned long\nsuffix_kstrtoint(char *s, unsigned int base, int *res)\n{\n\tint\tlast, shift_left_factor = 0, _res;\n\tchar\t*value = s;\n\n\tlast = strlen(value) - 1;\n\tif (value[last] == 'K' || value[last] == 'k') {\n\t\tshift_left_factor = 10;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'M' || value[last] == 'm') {\n\t\tshift_left_factor = 20;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'G' || value[last] == 'g') {\n\t\tshift_left_factor = 30;\n\t\tvalue[last] = '\\0';\n\t}\n\n\tif (kstrtoint(s, base, &_res))\n\t\treturn -EINVAL;\n\t*res = _res << shift_left_factor;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buffer"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "buffer",
            "buf",
            "count"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buffer",
            "0",
            "sizeof(buffer)"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic ssize_t clear_refs_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF];\n\tstruct mm_struct *mm;\n\tstruct vm_area_struct *vma;\n\tenum clear_refs_types type;\n\tint itype;\n\tint rv;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\trv = kstrtoint(strstrip(buffer), 10, &itype);\n\tif (rv < 0)\n\t\treturn rv;\n\ttype = (enum clear_refs_types)itype;\n\tif (type < CLEAR_REFS_ALL || type >= CLEAR_REFS_LAST)\n\t\treturn -EINVAL;\n\n\tif (type == CLEAR_REFS_SOFT_DIRTY) {\n\t\tsoft_dirty_cleared = true;\n\t\tpr_warn_once(\"The pagemap bits 55-60 has changed their meaning!\"\n\t\t\t     \" See the linux/Documentation/vm/pagemap.txt for \"\n\t\t\t     \"details.\\n\");\n\t}\n\n\ttask = get_proc_task(file_inode(file));\n\tif (!task)\n\t\treturn -ESRCH;\n\tmm = get_task_mm(task);\n\tif (mm) {\n\t\tstruct clear_refs_private cp = {\n\t\t\t.type = type,\n\t\t};\n\t\tstruct mm_walk clear_refs_walk = {\n\t\t\t.pmd_entry = clear_refs_pte_range,\n\t\t\t.test_walk = clear_refs_test_walk,\n\t\t\t.mm = mm,\n\t\t\t.private = &cp,\n\t\t};\n\n\t\tif (type == CLEAR_REFS_MM_HIWATER_RSS) {\n\t\t\t/*\n\t\t\t * Writing 5 to /proc/pid/clear_refs resets the peak\n\t\t\t * resident set size to this mm's current rss value.\n\t\t\t */\n\t\t\tdown_write(&mm->mmap_sem);\n\t\t\treset_mm_hiwater_rss(mm);\n\t\t\tup_write(&mm->mmap_sem);\n\t\t\tgoto out_mm;\n\t\t}\n\n\t\tdown_read(&mm->mmap_sem);\n\t\tif (type == CLEAR_REFS_SOFT_DIRTY) {\n\t\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\t\t\tif (!(vma->vm_flags & VM_SOFTDIRTY))\n\t\t\t\t\tcontinue;\n\t\t\t\tup_read(&mm->mmap_sem);\n\t\t\t\tdown_write(&mm->mmap_sem);\n\t\t\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\t\t\t\tvma->vm_flags &= ~VM_SOFTDIRTY;\n\t\t\t\t\tvma_set_page_prot(vma);\n\t\t\t\t}\n\t\t\t\tdowngrade_write(&mm->mmap_sem);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmmu_notifier_invalidate_range_start(mm, 0, -1);\n\t\t}\n\t\twalk_page_range(0, ~0UL, &clear_refs_walk);\n\t\tif (type == CLEAR_REFS_SOFT_DIRTY)\n\t\t\tmmu_notifier_invalidate_range_end(mm, 0, -1);\n\t\tflush_tlb_mm(mm);\n\t\tup_read(&mm->mmap_sem);\nout_mm:\n\t\tmmput(mm);\n\t}\n\tput_task_struct(task);\n\n\treturn count;\n}"
  },
  {
    "function_name": "clear_refs_test_walk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "845-865",
    "snippet": "static int clear_refs_test_walk(unsigned long start, unsigned long end,\n\t\t\t\tstruct mm_walk *walk)\n{\n\tstruct clear_refs_private *cp = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\n\tif (vma->vm_flags & VM_PFNMAP)\n\t\treturn 1;\n\n\t/*\n\t * Writing 1 to /proc/pid/clear_refs affects all pages.\n\t * Writing 2 to /proc/pid/clear_refs only affects anonymous pages.\n\t * Writing 3 to /proc/pid/clear_refs only affects file mapped pages.\n\t * Writing 4 to /proc/pid/clear_refs affects all pages.\n\t */\n\tif (cp->type == CLEAR_REFS_ANON && vma->vm_file)\n\t\treturn 1;\n\tif (cp->type == CLEAR_REFS_MAPPED && !vma->vm_file)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int clear_refs_test_walk(unsigned long start, unsigned long end,\n\t\t\t\tstruct mm_walk *walk)\n{\n\tstruct clear_refs_private *cp = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\n\tif (vma->vm_flags & VM_PFNMAP)\n\t\treturn 1;\n\n\t/*\n\t * Writing 1 to /proc/pid/clear_refs affects all pages.\n\t * Writing 2 to /proc/pid/clear_refs only affects anonymous pages.\n\t * Writing 3 to /proc/pid/clear_refs only affects file mapped pages.\n\t * Writing 4 to /proc/pid/clear_refs affects all pages.\n\t */\n\tif (cp->type == CLEAR_REFS_ANON && vma->vm_file)\n\t\treturn 1;\n\tif (cp->type == CLEAR_REFS_MAPPED && !vma->vm_file)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "clear_refs_pte_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "792-843",
    "snippet": "static int clear_refs_pte_range(pmd_t *pmd, unsigned long addr,\n\t\t\t\tunsigned long end, struct mm_walk *walk)\n{\n\tstruct clear_refs_private *cp = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tpte_t *pte, ptent;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\n\tif (pmd_trans_huge_lock(pmd, vma, &ptl) == 1) {\n\t\tif (cp->type == CLEAR_REFS_SOFT_DIRTY) {\n\t\t\tclear_soft_dirty_pmd(vma, addr, pmd);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpage = pmd_page(*pmd);\n\n\t\t/* Clear accessed and referenced bits. */\n\t\tpmdp_test_and_clear_young(vma, addr, pmd);\n\t\tClearPageReferenced(page);\nout:\n\t\tspin_unlock(ptl);\n\t\treturn 0;\n\t}\n\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\n\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE) {\n\t\tptent = *pte;\n\n\t\tif (cp->type == CLEAR_REFS_SOFT_DIRTY) {\n\t\t\tclear_soft_dirty(vma, addr, pte);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!pte_present(ptent))\n\t\t\tcontinue;\n\n\t\tpage = vm_normal_page(vma, addr, ptent);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\t/* Clear accessed and referenced bits. */\n\t\tptep_test_and_clear_young(vma, addr, pte);\n\t\tClearPageReferenced(page);\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "pte - 1",
            "ptl"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageReferenced",
          "args": [
            "page"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptep_test_and_clear_young",
          "args": [
            "vma",
            "addr",
            "pte"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_normal_page",
          "args": [
            "vma",
            "addr",
            "ptent"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "ptent"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_soft_dirty",
          "args": [
            "vma",
            "addr",
            "pte"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "clear_soft_dirty_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "786-789",
          "snippet": "static inline void clear_soft_dirty_pmd(struct vm_area_struct *vma,\n\t\tunsigned long addr, pmd_t *pmdp)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic inline void clear_soft_dirty_pmd(struct vm_area_struct *vma,\n\t\tunsigned long addr, pmd_t *pmdp)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "vma->vm_mm",
            "pmd",
            "addr",
            "&ptl"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_unstable",
          "args": [
            "pmd"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageReferenced",
          "args": [
            "page"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmdp_test_and_clear_young",
          "args": [
            "vma",
            "addr",
            "pmd"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_page",
          "args": [
            "*pmd"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge_lock",
          "args": [
            "pmd",
            "vma",
            "&ptl"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int clear_refs_pte_range(pmd_t *pmd, unsigned long addr,\n\t\t\t\tunsigned long end, struct mm_walk *walk)\n{\n\tstruct clear_refs_private *cp = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tpte_t *pte, ptent;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\n\tif (pmd_trans_huge_lock(pmd, vma, &ptl) == 1) {\n\t\tif (cp->type == CLEAR_REFS_SOFT_DIRTY) {\n\t\t\tclear_soft_dirty_pmd(vma, addr, pmd);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpage = pmd_page(*pmd);\n\n\t\t/* Clear accessed and referenced bits. */\n\t\tpmdp_test_and_clear_young(vma, addr, pmd);\n\t\tClearPageReferenced(page);\nout:\n\t\tspin_unlock(ptl);\n\t\treturn 0;\n\t}\n\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\n\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE) {\n\t\tptent = *pte;\n\n\t\tif (cp->type == CLEAR_REFS_SOFT_DIRTY) {\n\t\t\tclear_soft_dirty(vma, addr, pte);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!pte_present(ptent))\n\t\t\tcontinue;\n\n\t\tpage = vm_normal_page(vma, addr, ptent);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\t/* Clear accessed and referenced bits. */\n\t\tptep_test_and_clear_young(vma, addr, pte);\n\t\tClearPageReferenced(page);\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\treturn 0;\n}"
  },
  {
    "function_name": "clear_soft_dirty_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "786-789",
    "snippet": "static inline void clear_soft_dirty_pmd(struct vm_area_struct *vma,\n\t\tunsigned long addr, pmd_t *pmdp)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic inline void clear_soft_dirty_pmd(struct vm_area_struct *vma,\n\t\tunsigned long addr, pmd_t *pmdp)\n{\n}"
  },
  {
    "function_name": "clear_soft_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "781-784",
    "snippet": "static inline void clear_soft_dirty(struct vm_area_struct *vma,\n\t\tunsigned long addr, pte_t *pte)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic inline void clear_soft_dirty(struct vm_area_struct *vma,\n\t\tunsigned long addr, pte_t *pte)\n{\n}"
  },
  {
    "function_name": "clear_soft_dirty_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "765-777",
    "snippet": "static inline void clear_soft_dirty_pmd(struct vm_area_struct *vma,\n\t\tunsigned long addr, pmd_t *pmdp)\n{\n\tpmd_t pmd = *pmdp;\n\n\tpmd = pmd_wrprotect(pmd);\n\tpmd = pmd_clear_flags(pmd, _PAGE_SOFT_DIRTY);\n\n\tif (vma->vm_flags & VM_SOFTDIRTY)\n\t\tvma->vm_flags &= ~VM_SOFTDIRTY;\n\n\tset_pmd_at(vma->vm_mm, addr, pmdp, pmd);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_pmd_at",
          "args": [
            "vma->vm_mm",
            "addr",
            "pmdp",
            "pmd"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_clear_flags",
          "args": [
            "pmd",
            "_PAGE_SOFT_DIRTY"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_wrprotect",
          "args": [
            "pmd"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic inline void clear_soft_dirty_pmd(struct vm_area_struct *vma,\n\t\tunsigned long addr, pmd_t *pmdp)\n{\n\tpmd_t pmd = *pmdp;\n\n\tpmd = pmd_wrprotect(pmd);\n\tpmd = pmd_clear_flags(pmd, _PAGE_SOFT_DIRTY);\n\n\tif (vma->vm_flags & VM_SOFTDIRTY)\n\t\tvma->vm_flags &= ~VM_SOFTDIRTY;\n\n\tset_pmd_at(vma->vm_mm, addr, pmdp, pmd);\n}"
  },
  {
    "function_name": "clear_soft_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "744-763",
    "snippet": "static inline void clear_soft_dirty(struct vm_area_struct *vma,\n\t\tunsigned long addr, pte_t *pte)\n{\n\t/*\n\t * The soft-dirty tracker uses #PF-s to catch writes\n\t * to pages, so write-protect the pte as well. See the\n\t * Documentation/vm/soft-dirty.txt for full description\n\t * of how soft-dirty works.\n\t */\n\tpte_t ptent = *pte;\n\n\tif (pte_present(ptent)) {\n\t\tptent = pte_wrprotect(ptent);\n\t\tptent = pte_clear_flags(ptent, _PAGE_SOFT_DIRTY);\n\t} else if (is_swap_pte(ptent)) {\n\t\tptent = pte_swp_clear_soft_dirty(ptent);\n\t}\n\n\tset_pte_at(vma->vm_mm, addr, pte, ptent);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "vma->vm_mm",
            "addr",
            "pte",
            "ptent"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_swp_clear_soft_dirty",
          "args": [
            "ptent"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swap_pte",
          "args": [
            "ptent"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_clear_flags",
          "args": [
            "ptent",
            "_PAGE_SOFT_DIRTY"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_wrprotect",
          "args": [
            "ptent"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "ptent"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic inline void clear_soft_dirty(struct vm_area_struct *vma,\n\t\tunsigned long addr, pte_t *pte)\n{\n\t/*\n\t * The soft-dirty tracker uses #PF-s to catch writes\n\t * to pages, so write-protect the pte as well. See the\n\t * Documentation/vm/soft-dirty.txt for full description\n\t * of how soft-dirty works.\n\t */\n\tpte_t ptent = *pte;\n\n\tif (pte_present(ptent)) {\n\t\tptent = pte_wrprotect(ptent);\n\t\tptent = pte_clear_flags(ptent, _PAGE_SOFT_DIRTY);\n\t} else if (is_swap_pte(ptent)) {\n\t\tptent = pte_swp_clear_soft_dirty(ptent);\n\t}\n\n\tset_pte_at(vma->vm_mm, addr, pte, ptent);\n}"
  },
  {
    "function_name": "tid_smaps_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "694-697",
    "snippet": "static int tid_smaps_open(struct inode *inode, struct file *file)\n{\n\treturn do_maps_open(inode, file, &proc_tid_smaps_op);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_maps_open",
          "args": [
            "inode",
            "file",
            "&proc_tid_smaps_op"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "do_maps_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "242-247",
          "snippet": "static int do_maps_open(struct inode *inode, struct file *file,\n\t\t\tconst struct seq_operations *ops)\n{\n\treturn proc_maps_open(inode, file, ops,\n\t\t\t\tsizeof(struct proc_maps_private));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int do_maps_open(struct inode *inode, struct file *file,\n\t\t\tconst struct seq_operations *ops)\n{\n\treturn proc_maps_open(inode, file, ops,\n\t\t\t\tsizeof(struct proc_maps_private));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int tid_smaps_open(struct inode *inode, struct file *file)\n{\n\treturn do_maps_open(inode, file, &proc_tid_smaps_op);\n}"
  },
  {
    "function_name": "pid_smaps_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "689-692",
    "snippet": "static int pid_smaps_open(struct inode *inode, struct file *file)\n{\n\treturn do_maps_open(inode, file, &proc_pid_smaps_op);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_maps_open",
          "args": [
            "inode",
            "file",
            "&proc_pid_smaps_op"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "do_maps_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "242-247",
          "snippet": "static int do_maps_open(struct inode *inode, struct file *file,\n\t\t\tconst struct seq_operations *ops)\n{\n\treturn proc_maps_open(inode, file, ops,\n\t\t\t\tsizeof(struct proc_maps_private));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int do_maps_open(struct inode *inode, struct file *file,\n\t\t\tconst struct seq_operations *ops)\n{\n\treturn proc_maps_open(inode, file, ops,\n\t\t\t\tsizeof(struct proc_maps_private));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int pid_smaps_open(struct inode *inode, struct file *file)\n{\n\treturn do_maps_open(inode, file, &proc_pid_smaps_op);\n}"
  },
  {
    "function_name": "show_tid_smap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "670-673",
    "snippet": "static int show_tid_smap(struct seq_file *m, void *v)\n{\n\treturn show_smap(m, v, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_smap",
          "args": [
            "m",
            "v",
            "0"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "show_smap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "613-663",
          "snippet": "static int show_smap(struct seq_file *m, void *v, int is_pid)\n{\n\tstruct vm_area_struct *vma = v;\n\tstruct mem_size_stats mss;\n\tstruct mm_walk smaps_walk = {\n\t\t.pmd_entry = smaps_pte_range,\n\t\t.mm = vma->vm_mm,\n\t\t.private = &mss,\n\t};\n\n\tmemset(&mss, 0, sizeof mss);\n\t/* mmap_sem is held in m_start */\n\twalk_page_vma(vma, &smaps_walk);\n\n\tshow_map_vma(m, vma, is_pid);\n\n\tseq_printf(m,\n\t\t   \"Size:           %8lu kB\\n\"\n\t\t   \"Rss:            %8lu kB\\n\"\n\t\t   \"Pss:            %8lu kB\\n\"\n\t\t   \"Shared_Clean:   %8lu kB\\n\"\n\t\t   \"Shared_Dirty:   %8lu kB\\n\"\n\t\t   \"Private_Clean:  %8lu kB\\n\"\n\t\t   \"Private_Dirty:  %8lu kB\\n\"\n\t\t   \"Referenced:     %8lu kB\\n\"\n\t\t   \"Anonymous:      %8lu kB\\n\"\n\t\t   \"AnonHugePages:  %8lu kB\\n\"\n\t\t   \"Swap:           %8lu kB\\n\"\n\t\t   \"KernelPageSize: %8lu kB\\n\"\n\t\t   \"MMUPageSize:    %8lu kB\\n\"\n\t\t   \"Locked:         %8lu kB\\n\",\n\t\t   (vma->vm_end - vma->vm_start) >> 10,\n\t\t   mss.resident >> 10,\n\t\t   (unsigned long)(mss.pss >> (10 + PSS_SHIFT)),\n\t\t   mss.shared_clean  >> 10,\n\t\t   mss.shared_dirty  >> 10,\n\t\t   mss.private_clean >> 10,\n\t\t   mss.private_dirty >> 10,\n\t\t   mss.referenced >> 10,\n\t\t   mss.anonymous >> 10,\n\t\t   mss.anonymous_thp >> 10,\n\t\t   mss.swap >> 10,\n\t\t   vma_kernel_pagesize(vma) >> 10,\n\t\t   vma_mmu_pagesize(vma) >> 10,\n\t\t   (vma->vm_flags & VM_LOCKED) ?\n\t\t\t(unsigned long)(mss.pss >> (10 + PSS_SHIFT)) : 0);\n\n\tshow_smap_vma_flags(m, vma);\n\tm_cache_vma(m, vma);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define PSS_SHIFT 12"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\n#define PSS_SHIFT 12\n\nstatic int show_smap(struct seq_file *m, void *v, int is_pid)\n{\n\tstruct vm_area_struct *vma = v;\n\tstruct mem_size_stats mss;\n\tstruct mm_walk smaps_walk = {\n\t\t.pmd_entry = smaps_pte_range,\n\t\t.mm = vma->vm_mm,\n\t\t.private = &mss,\n\t};\n\n\tmemset(&mss, 0, sizeof mss);\n\t/* mmap_sem is held in m_start */\n\twalk_page_vma(vma, &smaps_walk);\n\n\tshow_map_vma(m, vma, is_pid);\n\n\tseq_printf(m,\n\t\t   \"Size:           %8lu kB\\n\"\n\t\t   \"Rss:            %8lu kB\\n\"\n\t\t   \"Pss:            %8lu kB\\n\"\n\t\t   \"Shared_Clean:   %8lu kB\\n\"\n\t\t   \"Shared_Dirty:   %8lu kB\\n\"\n\t\t   \"Private_Clean:  %8lu kB\\n\"\n\t\t   \"Private_Dirty:  %8lu kB\\n\"\n\t\t   \"Referenced:     %8lu kB\\n\"\n\t\t   \"Anonymous:      %8lu kB\\n\"\n\t\t   \"AnonHugePages:  %8lu kB\\n\"\n\t\t   \"Swap:           %8lu kB\\n\"\n\t\t   \"KernelPageSize: %8lu kB\\n\"\n\t\t   \"MMUPageSize:    %8lu kB\\n\"\n\t\t   \"Locked:         %8lu kB\\n\",\n\t\t   (vma->vm_end - vma->vm_start) >> 10,\n\t\t   mss.resident >> 10,\n\t\t   (unsigned long)(mss.pss >> (10 + PSS_SHIFT)),\n\t\t   mss.shared_clean  >> 10,\n\t\t   mss.shared_dirty  >> 10,\n\t\t   mss.private_clean >> 10,\n\t\t   mss.private_dirty >> 10,\n\t\t   mss.referenced >> 10,\n\t\t   mss.anonymous >> 10,\n\t\t   mss.anonymous_thp >> 10,\n\t\t   mss.swap >> 10,\n\t\t   vma_kernel_pagesize(vma) >> 10,\n\t\t   vma_mmu_pagesize(vma) >> 10,\n\t\t   (vma->vm_flags & VM_LOCKED) ?\n\t\t\t(unsigned long)(mss.pss >> (10 + PSS_SHIFT)) : 0);\n\n\tshow_smap_vma_flags(m, vma);\n\tm_cache_vma(m, vma);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int show_tid_smap(struct seq_file *m, void *v)\n{\n\treturn show_smap(m, v, 0);\n}"
  },
  {
    "function_name": "show_pid_smap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "665-668",
    "snippet": "static int show_pid_smap(struct seq_file *m, void *v)\n{\n\treturn show_smap(m, v, 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_smap",
          "args": [
            "m",
            "v",
            "1"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "show_smap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "613-663",
          "snippet": "static int show_smap(struct seq_file *m, void *v, int is_pid)\n{\n\tstruct vm_area_struct *vma = v;\n\tstruct mem_size_stats mss;\n\tstruct mm_walk smaps_walk = {\n\t\t.pmd_entry = smaps_pte_range,\n\t\t.mm = vma->vm_mm,\n\t\t.private = &mss,\n\t};\n\n\tmemset(&mss, 0, sizeof mss);\n\t/* mmap_sem is held in m_start */\n\twalk_page_vma(vma, &smaps_walk);\n\n\tshow_map_vma(m, vma, is_pid);\n\n\tseq_printf(m,\n\t\t   \"Size:           %8lu kB\\n\"\n\t\t   \"Rss:            %8lu kB\\n\"\n\t\t   \"Pss:            %8lu kB\\n\"\n\t\t   \"Shared_Clean:   %8lu kB\\n\"\n\t\t   \"Shared_Dirty:   %8lu kB\\n\"\n\t\t   \"Private_Clean:  %8lu kB\\n\"\n\t\t   \"Private_Dirty:  %8lu kB\\n\"\n\t\t   \"Referenced:     %8lu kB\\n\"\n\t\t   \"Anonymous:      %8lu kB\\n\"\n\t\t   \"AnonHugePages:  %8lu kB\\n\"\n\t\t   \"Swap:           %8lu kB\\n\"\n\t\t   \"KernelPageSize: %8lu kB\\n\"\n\t\t   \"MMUPageSize:    %8lu kB\\n\"\n\t\t   \"Locked:         %8lu kB\\n\",\n\t\t   (vma->vm_end - vma->vm_start) >> 10,\n\t\t   mss.resident >> 10,\n\t\t   (unsigned long)(mss.pss >> (10 + PSS_SHIFT)),\n\t\t   mss.shared_clean  >> 10,\n\t\t   mss.shared_dirty  >> 10,\n\t\t   mss.private_clean >> 10,\n\t\t   mss.private_dirty >> 10,\n\t\t   mss.referenced >> 10,\n\t\t   mss.anonymous >> 10,\n\t\t   mss.anonymous_thp >> 10,\n\t\t   mss.swap >> 10,\n\t\t   vma_kernel_pagesize(vma) >> 10,\n\t\t   vma_mmu_pagesize(vma) >> 10,\n\t\t   (vma->vm_flags & VM_LOCKED) ?\n\t\t\t(unsigned long)(mss.pss >> (10 + PSS_SHIFT)) : 0);\n\n\tshow_smap_vma_flags(m, vma);\n\tm_cache_vma(m, vma);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define PSS_SHIFT 12"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\n#define PSS_SHIFT 12\n\nstatic int show_smap(struct seq_file *m, void *v, int is_pid)\n{\n\tstruct vm_area_struct *vma = v;\n\tstruct mem_size_stats mss;\n\tstruct mm_walk smaps_walk = {\n\t\t.pmd_entry = smaps_pte_range,\n\t\t.mm = vma->vm_mm,\n\t\t.private = &mss,\n\t};\n\n\tmemset(&mss, 0, sizeof mss);\n\t/* mmap_sem is held in m_start */\n\twalk_page_vma(vma, &smaps_walk);\n\n\tshow_map_vma(m, vma, is_pid);\n\n\tseq_printf(m,\n\t\t   \"Size:           %8lu kB\\n\"\n\t\t   \"Rss:            %8lu kB\\n\"\n\t\t   \"Pss:            %8lu kB\\n\"\n\t\t   \"Shared_Clean:   %8lu kB\\n\"\n\t\t   \"Shared_Dirty:   %8lu kB\\n\"\n\t\t   \"Private_Clean:  %8lu kB\\n\"\n\t\t   \"Private_Dirty:  %8lu kB\\n\"\n\t\t   \"Referenced:     %8lu kB\\n\"\n\t\t   \"Anonymous:      %8lu kB\\n\"\n\t\t   \"AnonHugePages:  %8lu kB\\n\"\n\t\t   \"Swap:           %8lu kB\\n\"\n\t\t   \"KernelPageSize: %8lu kB\\n\"\n\t\t   \"MMUPageSize:    %8lu kB\\n\"\n\t\t   \"Locked:         %8lu kB\\n\",\n\t\t   (vma->vm_end - vma->vm_start) >> 10,\n\t\t   mss.resident >> 10,\n\t\t   (unsigned long)(mss.pss >> (10 + PSS_SHIFT)),\n\t\t   mss.shared_clean  >> 10,\n\t\t   mss.shared_dirty  >> 10,\n\t\t   mss.private_clean >> 10,\n\t\t   mss.private_dirty >> 10,\n\t\t   mss.referenced >> 10,\n\t\t   mss.anonymous >> 10,\n\t\t   mss.anonymous_thp >> 10,\n\t\t   mss.swap >> 10,\n\t\t   vma_kernel_pagesize(vma) >> 10,\n\t\t   vma_mmu_pagesize(vma) >> 10,\n\t\t   (vma->vm_flags & VM_LOCKED) ?\n\t\t\t(unsigned long)(mss.pss >> (10 + PSS_SHIFT)) : 0);\n\n\tshow_smap_vma_flags(m, vma);\n\tm_cache_vma(m, vma);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int show_pid_smap(struct seq_file *m, void *v)\n{\n\treturn show_smap(m, v, 1);\n}"
  },
  {
    "function_name": "show_smap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "613-663",
    "snippet": "static int show_smap(struct seq_file *m, void *v, int is_pid)\n{\n\tstruct vm_area_struct *vma = v;\n\tstruct mem_size_stats mss;\n\tstruct mm_walk smaps_walk = {\n\t\t.pmd_entry = smaps_pte_range,\n\t\t.mm = vma->vm_mm,\n\t\t.private = &mss,\n\t};\n\n\tmemset(&mss, 0, sizeof mss);\n\t/* mmap_sem is held in m_start */\n\twalk_page_vma(vma, &smaps_walk);\n\n\tshow_map_vma(m, vma, is_pid);\n\n\tseq_printf(m,\n\t\t   \"Size:           %8lu kB\\n\"\n\t\t   \"Rss:            %8lu kB\\n\"\n\t\t   \"Pss:            %8lu kB\\n\"\n\t\t   \"Shared_Clean:   %8lu kB\\n\"\n\t\t   \"Shared_Dirty:   %8lu kB\\n\"\n\t\t   \"Private_Clean:  %8lu kB\\n\"\n\t\t   \"Private_Dirty:  %8lu kB\\n\"\n\t\t   \"Referenced:     %8lu kB\\n\"\n\t\t   \"Anonymous:      %8lu kB\\n\"\n\t\t   \"AnonHugePages:  %8lu kB\\n\"\n\t\t   \"Swap:           %8lu kB\\n\"\n\t\t   \"KernelPageSize: %8lu kB\\n\"\n\t\t   \"MMUPageSize:    %8lu kB\\n\"\n\t\t   \"Locked:         %8lu kB\\n\",\n\t\t   (vma->vm_end - vma->vm_start) >> 10,\n\t\t   mss.resident >> 10,\n\t\t   (unsigned long)(mss.pss >> (10 + PSS_SHIFT)),\n\t\t   mss.shared_clean  >> 10,\n\t\t   mss.shared_dirty  >> 10,\n\t\t   mss.private_clean >> 10,\n\t\t   mss.private_dirty >> 10,\n\t\t   mss.referenced >> 10,\n\t\t   mss.anonymous >> 10,\n\t\t   mss.anonymous_thp >> 10,\n\t\t   mss.swap >> 10,\n\t\t   vma_kernel_pagesize(vma) >> 10,\n\t\t   vma_mmu_pagesize(vma) >> 10,\n\t\t   (vma->vm_flags & VM_LOCKED) ?\n\t\t\t(unsigned long)(mss.pss >> (10 + PSS_SHIFT)) : 0);\n\n\tshow_smap_vma_flags(m, vma);\n\tm_cache_vma(m, vma);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define PSS_SHIFT 12"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_cache_vma",
          "args": [
            "m",
            "vma"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "m_cache_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "134-138",
          "snippet": "static void m_cache_vma(struct seq_file *m, struct vm_area_struct *vma)\n{\n\tif (m->count < m->size)\t/* vma is copied successfully */\n\t\tm->version = m_next_vma(m->private, vma) ? vma->vm_start : -1UL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void m_cache_vma(struct seq_file *m, struct vm_area_struct *vma)\n{\n\tif (m->count < m->size)\t/* vma is copied successfully */\n\t\tm->version = m_next_vma(m->private, vma) ? vma->vm_start : -1UL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_smap_vma_flags",
          "args": [
            "m",
            "vma"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "show_smap_vma_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "557-611",
          "snippet": "static void show_smap_vma_flags(struct seq_file *m, struct vm_area_struct *vma)\n{\n\t/*\n\t * Don't forget to update Documentation/ on changes.\n\t */\n\tstatic const char mnemonics[BITS_PER_LONG][2] = {\n\t\t/*\n\t\t * In case if we meet a flag we don't know about.\n\t\t */\n\t\t[0 ... (BITS_PER_LONG-1)] = \"??\",\n\n\t\t[ilog2(VM_READ)]\t= \"rd\",\n\t\t[ilog2(VM_WRITE)]\t= \"wr\",\n\t\t[ilog2(VM_EXEC)]\t= \"ex\",\n\t\t[ilog2(VM_SHARED)]\t= \"sh\",\n\t\t[ilog2(VM_MAYREAD)]\t= \"mr\",\n\t\t[ilog2(VM_MAYWRITE)]\t= \"mw\",\n\t\t[ilog2(VM_MAYEXEC)]\t= \"me\",\n\t\t[ilog2(VM_MAYSHARE)]\t= \"ms\",\n\t\t[ilog2(VM_GROWSDOWN)]\t= \"gd\",\n\t\t[ilog2(VM_PFNMAP)]\t= \"pf\",\n\t\t[ilog2(VM_DENYWRITE)]\t= \"dw\",\n#ifdef CONFIG_X86_INTEL_MPX\n\t\t[ilog2(VM_MPX)]\t\t= \"mp\",\n#endif\n\t\t[ilog2(VM_LOCKED)]\t= \"lo\",\n\t\t[ilog2(VM_IO)]\t\t= \"io\",\n\t\t[ilog2(VM_SEQ_READ)]\t= \"sr\",\n\t\t[ilog2(VM_RAND_READ)]\t= \"rr\",\n\t\t[ilog2(VM_DONTCOPY)]\t= \"dc\",\n\t\t[ilog2(VM_DONTEXPAND)]\t= \"de\",\n\t\t[ilog2(VM_ACCOUNT)]\t= \"ac\",\n\t\t[ilog2(VM_NORESERVE)]\t= \"nr\",\n\t\t[ilog2(VM_HUGETLB)]\t= \"ht\",\n\t\t[ilog2(VM_ARCH_1)]\t= \"ar\",\n\t\t[ilog2(VM_DONTDUMP)]\t= \"dd\",\n#ifdef CONFIG_MEM_SOFT_DIRTY\n\t\t[ilog2(VM_SOFTDIRTY)]\t= \"sd\",\n#endif\n\t\t[ilog2(VM_MIXEDMAP)]\t= \"mm\",\n\t\t[ilog2(VM_HUGEPAGE)]\t= \"hg\",\n\t\t[ilog2(VM_NOHUGEPAGE)]\t= \"nh\",\n\t\t[ilog2(VM_MERGEABLE)]\t= \"mg\",\n\t};\n\tsize_t i;\n\n\tseq_puts(m, \"VmFlags: \");\n\tfor (i = 0; i < BITS_PER_LONG; i++) {\n\t\tif (vma->vm_flags & (1UL << i)) {\n\t\t\tseq_printf(m, \"%c%c \",\n\t\t\t\t   mnemonics[i][0], mnemonics[i][1]);\n\t\t}\n\t}\n\tseq_putc(m, '\\n');\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void show_smap_vma_flags(struct seq_file *m, struct vm_area_struct *vma)\n{\n\t/*\n\t * Don't forget to update Documentation/ on changes.\n\t */\n\tstatic const char mnemonics[BITS_PER_LONG][2] = {\n\t\t/*\n\t\t * In case if we meet a flag we don't know about.\n\t\t */\n\t\t[0 ... (BITS_PER_LONG-1)] = \"??\",\n\n\t\t[ilog2(VM_READ)]\t= \"rd\",\n\t\t[ilog2(VM_WRITE)]\t= \"wr\",\n\t\t[ilog2(VM_EXEC)]\t= \"ex\",\n\t\t[ilog2(VM_SHARED)]\t= \"sh\",\n\t\t[ilog2(VM_MAYREAD)]\t= \"mr\",\n\t\t[ilog2(VM_MAYWRITE)]\t= \"mw\",\n\t\t[ilog2(VM_MAYEXEC)]\t= \"me\",\n\t\t[ilog2(VM_MAYSHARE)]\t= \"ms\",\n\t\t[ilog2(VM_GROWSDOWN)]\t= \"gd\",\n\t\t[ilog2(VM_PFNMAP)]\t= \"pf\",\n\t\t[ilog2(VM_DENYWRITE)]\t= \"dw\",\n#ifdef CONFIG_X86_INTEL_MPX\n\t\t[ilog2(VM_MPX)]\t\t= \"mp\",\n#endif\n\t\t[ilog2(VM_LOCKED)]\t= \"lo\",\n\t\t[ilog2(VM_IO)]\t\t= \"io\",\n\t\t[ilog2(VM_SEQ_READ)]\t= \"sr\",\n\t\t[ilog2(VM_RAND_READ)]\t= \"rr\",\n\t\t[ilog2(VM_DONTCOPY)]\t= \"dc\",\n\t\t[ilog2(VM_DONTEXPAND)]\t= \"de\",\n\t\t[ilog2(VM_ACCOUNT)]\t= \"ac\",\n\t\t[ilog2(VM_NORESERVE)]\t= \"nr\",\n\t\t[ilog2(VM_HUGETLB)]\t= \"ht\",\n\t\t[ilog2(VM_ARCH_1)]\t= \"ar\",\n\t\t[ilog2(VM_DONTDUMP)]\t= \"dd\",\n#ifdef CONFIG_MEM_SOFT_DIRTY\n\t\t[ilog2(VM_SOFTDIRTY)]\t= \"sd\",\n#endif\n\t\t[ilog2(VM_MIXEDMAP)]\t= \"mm\",\n\t\t[ilog2(VM_HUGEPAGE)]\t= \"hg\",\n\t\t[ilog2(VM_NOHUGEPAGE)]\t= \"nh\",\n\t\t[ilog2(VM_MERGEABLE)]\t= \"mg\",\n\t};\n\tsize_t i;\n\n\tseq_puts(m, \"VmFlags: \");\n\tfor (i = 0; i < BITS_PER_LONG; i++) {\n\t\tif (vma->vm_flags & (1UL << i)) {\n\t\t\tseq_printf(m, \"%c%c \",\n\t\t\t\t   mnemonics[i][0], mnemonics[i][1]);\n\t\t}\n\t}\n\tseq_putc(m, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Size:           %8lu kB\\n\"\n\t\t   \"Rss:            %8lu kB\\n\"\n\t\t   \"Pss:            %8lu kB\\n\"\n\t\t   \"Shared_Clean:   %8lu kB\\n\"\n\t\t   \"Shared_Dirty:   %8lu kB\\n\"\n\t\t   \"Private_Clean:  %8lu kB\\n\"\n\t\t   \"Private_Dirty:  %8lu kB\\n\"\n\t\t   \"Referenced:     %8lu kB\\n\"\n\t\t   \"Anonymous:      %8lu kB\\n\"\n\t\t   \"AnonHugePages:  %8lu kB\\n\"\n\t\t   \"Swap:           %8lu kB\\n\"\n\t\t   \"KernelPageSize: %8lu kB\\n\"\n\t\t   \"MMUPageSize:    %8lu kB\\n\"\n\t\t   \"Locked:         %8lu kB\\n\"",
            "(vma->vm_end - vma->vm_start) >> 10",
            "mss.resident >> 10",
            "(unsigned long)(mss.pss >> (10 + PSS_SHIFT))",
            "mss.shared_clean  >> 10",
            "mss.shared_dirty  >> 10",
            "mss.private_clean >> 10",
            "mss.private_dirty >> 10",
            "mss.referenced >> 10",
            "mss.anonymous >> 10",
            "mss.anonymous_thp >> 10",
            "mss.swap >> 10",
            "vma_kernel_pagesize(vma) >> 10",
            "vma_mmu_pagesize(vma) >> 10",
            "(vma->vm_flags & VM_LOCKED) ?\n\t\t\t(unsigned long)(mss.pss >> (10 + PSS_SHIFT)) : 0"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_mmu_pagesize",
          "args": [
            "vma"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_kernel_pagesize",
          "args": [
            "vma"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_map_vma",
          "args": [
            "m",
            "vma",
            "is_pid"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "show_map_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "268-361",
          "snippet": "static void\nshow_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct file *file = vma->vm_file;\n\tstruct proc_maps_private *priv = m->private;\n\tvm_flags_t flags = vma->vm_flags;\n\tunsigned long ino = 0;\n\tunsigned long long pgoff = 0;\n\tunsigned long start, end;\n\tdev_t dev = 0;\n\tconst char *name = NULL;\n\n\tif (file) {\n\t\tstruct inode *inode = file_inode(vma->vm_file);\n\t\tdev = inode->i_sb->s_dev;\n\t\tino = inode->i_ino;\n\t\tpgoff = ((loff_t)vma->vm_pgoff) << PAGE_SHIFT;\n\t}\n\n\t/* We don't show the stack guard page in /proc/maps */\n\tstart = vma->vm_start;\n\tif (stack_guard_page_start(vma, start))\n\t\tstart += PAGE_SIZE;\n\tend = vma->vm_end;\n\tif (stack_guard_page_end(vma, end))\n\t\tend -= PAGE_SIZE;\n\n\tseq_setwidth(m, 25 + sizeof(void *) * 6 - 1);\n\tseq_printf(m, \"%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu \",\n\t\t\tstart,\n\t\t\tend,\n\t\t\tflags & VM_READ ? 'r' : '-',\n\t\t\tflags & VM_WRITE ? 'w' : '-',\n\t\t\tflags & VM_EXEC ? 'x' : '-',\n\t\t\tflags & VM_MAYSHARE ? 's' : 'p',\n\t\t\tpgoff,\n\t\t\tMAJOR(dev), MINOR(dev), ino);\n\n\t/*\n\t * Print the dentry name for named mappings, and a\n\t * special [heap] marker for the heap:\n\t */\n\tif (file) {\n\t\tseq_pad(m, ' ');\n\t\tseq_path(m, &file->f_path, \"\\n\");\n\t\tgoto done;\n\t}\n\n\tif (vma->vm_ops && vma->vm_ops->name) {\n\t\tname = vma->vm_ops->name(vma);\n\t\tif (name)\n\t\t\tgoto done;\n\t}\n\n\tname = arch_vma_name(vma);\n\tif (!name) {\n\t\tpid_t tid;\n\n\t\tif (!mm) {\n\t\t\tname = \"[vdso]\";\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (vma->vm_start <= mm->brk &&\n\t\t    vma->vm_end >= mm->start_brk) {\n\t\t\tname = \"[heap]\";\n\t\t\tgoto done;\n\t\t}\n\n\t\ttid = pid_of_stack(priv, vma, is_pid);\n\t\tif (tid != 0) {\n\t\t\t/*\n\t\t\t * Thread stack in /proc/PID/task/TID/maps or\n\t\t\t * the main process stack.\n\t\t\t */\n\t\t\tif (!is_pid || (vma->vm_start <= mm->start_stack &&\n\t\t\t    vma->vm_end >= mm->start_stack)) {\n\t\t\t\tname = \"[stack]\";\n\t\t\t} else {\n\t\t\t\t/* Thread stack in /proc/PID/maps */\n\t\t\t\tseq_pad(m, ' ');\n\t\t\t\tseq_printf(m, \"[stack:%d]\", tid);\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tif (name) {\n\t\tseq_pad(m, ' ');\n\t\tseq_puts(m, name);\n\t}\n\tseq_putc(m, '\\n');\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void\nshow_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct file *file = vma->vm_file;\n\tstruct proc_maps_private *priv = m->private;\n\tvm_flags_t flags = vma->vm_flags;\n\tunsigned long ino = 0;\n\tunsigned long long pgoff = 0;\n\tunsigned long start, end;\n\tdev_t dev = 0;\n\tconst char *name = NULL;\n\n\tif (file) {\n\t\tstruct inode *inode = file_inode(vma->vm_file);\n\t\tdev = inode->i_sb->s_dev;\n\t\tino = inode->i_ino;\n\t\tpgoff = ((loff_t)vma->vm_pgoff) << PAGE_SHIFT;\n\t}\n\n\t/* We don't show the stack guard page in /proc/maps */\n\tstart = vma->vm_start;\n\tif (stack_guard_page_start(vma, start))\n\t\tstart += PAGE_SIZE;\n\tend = vma->vm_end;\n\tif (stack_guard_page_end(vma, end))\n\t\tend -= PAGE_SIZE;\n\n\tseq_setwidth(m, 25 + sizeof(void *) * 6 - 1);\n\tseq_printf(m, \"%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu \",\n\t\t\tstart,\n\t\t\tend,\n\t\t\tflags & VM_READ ? 'r' : '-',\n\t\t\tflags & VM_WRITE ? 'w' : '-',\n\t\t\tflags & VM_EXEC ? 'x' : '-',\n\t\t\tflags & VM_MAYSHARE ? 's' : 'p',\n\t\t\tpgoff,\n\t\t\tMAJOR(dev), MINOR(dev), ino);\n\n\t/*\n\t * Print the dentry name for named mappings, and a\n\t * special [heap] marker for the heap:\n\t */\n\tif (file) {\n\t\tseq_pad(m, ' ');\n\t\tseq_path(m, &file->f_path, \"\\n\");\n\t\tgoto done;\n\t}\n\n\tif (vma->vm_ops && vma->vm_ops->name) {\n\t\tname = vma->vm_ops->name(vma);\n\t\tif (name)\n\t\t\tgoto done;\n\t}\n\n\tname = arch_vma_name(vma);\n\tif (!name) {\n\t\tpid_t tid;\n\n\t\tif (!mm) {\n\t\t\tname = \"[vdso]\";\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (vma->vm_start <= mm->brk &&\n\t\t    vma->vm_end >= mm->start_brk) {\n\t\t\tname = \"[heap]\";\n\t\t\tgoto done;\n\t\t}\n\n\t\ttid = pid_of_stack(priv, vma, is_pid);\n\t\tif (tid != 0) {\n\t\t\t/*\n\t\t\t * Thread stack in /proc/PID/task/TID/maps or\n\t\t\t * the main process stack.\n\t\t\t */\n\t\t\tif (!is_pid || (vma->vm_start <= mm->start_stack &&\n\t\t\t    vma->vm_end >= mm->start_stack)) {\n\t\t\t\tname = \"[stack]\";\n\t\t\t} else {\n\t\t\t\t/* Thread stack in /proc/PID/maps */\n\t\t\t\tseq_pad(m, ' ');\n\t\t\t\tseq_printf(m, \"[stack:%d]\", tid);\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tif (name) {\n\t\tseq_pad(m, ' ');\n\t\tseq_puts(m, name);\n\t}\n\tseq_putc(m, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "walk_page_vma",
          "args": [
            "vma",
            "&smaps_walk"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&mss",
            "0",
            "sizeof mss"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\n#define PSS_SHIFT 12\n\nstatic int show_smap(struct seq_file *m, void *v, int is_pid)\n{\n\tstruct vm_area_struct *vma = v;\n\tstruct mem_size_stats mss;\n\tstruct mm_walk smaps_walk = {\n\t\t.pmd_entry = smaps_pte_range,\n\t\t.mm = vma->vm_mm,\n\t\t.private = &mss,\n\t};\n\n\tmemset(&mss, 0, sizeof mss);\n\t/* mmap_sem is held in m_start */\n\twalk_page_vma(vma, &smaps_walk);\n\n\tshow_map_vma(m, vma, is_pid);\n\n\tseq_printf(m,\n\t\t   \"Size:           %8lu kB\\n\"\n\t\t   \"Rss:            %8lu kB\\n\"\n\t\t   \"Pss:            %8lu kB\\n\"\n\t\t   \"Shared_Clean:   %8lu kB\\n\"\n\t\t   \"Shared_Dirty:   %8lu kB\\n\"\n\t\t   \"Private_Clean:  %8lu kB\\n\"\n\t\t   \"Private_Dirty:  %8lu kB\\n\"\n\t\t   \"Referenced:     %8lu kB\\n\"\n\t\t   \"Anonymous:      %8lu kB\\n\"\n\t\t   \"AnonHugePages:  %8lu kB\\n\"\n\t\t   \"Swap:           %8lu kB\\n\"\n\t\t   \"KernelPageSize: %8lu kB\\n\"\n\t\t   \"MMUPageSize:    %8lu kB\\n\"\n\t\t   \"Locked:         %8lu kB\\n\",\n\t\t   (vma->vm_end - vma->vm_start) >> 10,\n\t\t   mss.resident >> 10,\n\t\t   (unsigned long)(mss.pss >> (10 + PSS_SHIFT)),\n\t\t   mss.shared_clean  >> 10,\n\t\t   mss.shared_dirty  >> 10,\n\t\t   mss.private_clean >> 10,\n\t\t   mss.private_dirty >> 10,\n\t\t   mss.referenced >> 10,\n\t\t   mss.anonymous >> 10,\n\t\t   mss.anonymous_thp >> 10,\n\t\t   mss.swap >> 10,\n\t\t   vma_kernel_pagesize(vma) >> 10,\n\t\t   vma_mmu_pagesize(vma) >> 10,\n\t\t   (vma->vm_flags & VM_LOCKED) ?\n\t\t\t(unsigned long)(mss.pss >> (10 + PSS_SHIFT)) : 0);\n\n\tshow_smap_vma_flags(m, vma);\n\tm_cache_vma(m, vma);\n\treturn 0;\n}"
  },
  {
    "function_name": "show_smap_vma_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "557-611",
    "snippet": "static void show_smap_vma_flags(struct seq_file *m, struct vm_area_struct *vma)\n{\n\t/*\n\t * Don't forget to update Documentation/ on changes.\n\t */\n\tstatic const char mnemonics[BITS_PER_LONG][2] = {\n\t\t/*\n\t\t * In case if we meet a flag we don't know about.\n\t\t */\n\t\t[0 ... (BITS_PER_LONG-1)] = \"??\",\n\n\t\t[ilog2(VM_READ)]\t= \"rd\",\n\t\t[ilog2(VM_WRITE)]\t= \"wr\",\n\t\t[ilog2(VM_EXEC)]\t= \"ex\",\n\t\t[ilog2(VM_SHARED)]\t= \"sh\",\n\t\t[ilog2(VM_MAYREAD)]\t= \"mr\",\n\t\t[ilog2(VM_MAYWRITE)]\t= \"mw\",\n\t\t[ilog2(VM_MAYEXEC)]\t= \"me\",\n\t\t[ilog2(VM_MAYSHARE)]\t= \"ms\",\n\t\t[ilog2(VM_GROWSDOWN)]\t= \"gd\",\n\t\t[ilog2(VM_PFNMAP)]\t= \"pf\",\n\t\t[ilog2(VM_DENYWRITE)]\t= \"dw\",\n#ifdef CONFIG_X86_INTEL_MPX\n\t\t[ilog2(VM_MPX)]\t\t= \"mp\",\n#endif\n\t\t[ilog2(VM_LOCKED)]\t= \"lo\",\n\t\t[ilog2(VM_IO)]\t\t= \"io\",\n\t\t[ilog2(VM_SEQ_READ)]\t= \"sr\",\n\t\t[ilog2(VM_RAND_READ)]\t= \"rr\",\n\t\t[ilog2(VM_DONTCOPY)]\t= \"dc\",\n\t\t[ilog2(VM_DONTEXPAND)]\t= \"de\",\n\t\t[ilog2(VM_ACCOUNT)]\t= \"ac\",\n\t\t[ilog2(VM_NORESERVE)]\t= \"nr\",\n\t\t[ilog2(VM_HUGETLB)]\t= \"ht\",\n\t\t[ilog2(VM_ARCH_1)]\t= \"ar\",\n\t\t[ilog2(VM_DONTDUMP)]\t= \"dd\",\n#ifdef CONFIG_MEM_SOFT_DIRTY\n\t\t[ilog2(VM_SOFTDIRTY)]\t= \"sd\",\n#endif\n\t\t[ilog2(VM_MIXEDMAP)]\t= \"mm\",\n\t\t[ilog2(VM_HUGEPAGE)]\t= \"hg\",\n\t\t[ilog2(VM_NOHUGEPAGE)]\t= \"nh\",\n\t\t[ilog2(VM_MERGEABLE)]\t= \"mg\",\n\t};\n\tsize_t i;\n\n\tseq_puts(m, \"VmFlags: \");\n\tfor (i = 0; i < BITS_PER_LONG; i++) {\n\t\tif (vma->vm_flags & (1UL << i)) {\n\t\t\tseq_printf(m, \"%c%c \",\n\t\t\t\t   mnemonics[i][0], mnemonics[i][1]);\n\t\t}\n\t}\n\tseq_putc(m, '\\n');\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "648-655",
          "snippet": "int seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%c%c \"",
            "mnemonics[i][0]",
            "mnemonics[i][1]"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"VmFlags: \""
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_MERGEABLE"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_NOHUGEPAGE"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_HUGEPAGE"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_MIXEDMAP"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_SOFTDIRTY"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_DONTDUMP"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_ARCH_1"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_HUGETLB"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_NORESERVE"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_ACCOUNT"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_DONTEXPAND"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_DONTCOPY"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_RAND_READ"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_SEQ_READ"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_IO"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_LOCKED"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_MPX"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_DENYWRITE"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_PFNMAP"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_GROWSDOWN"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_MAYSHARE"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_MAYEXEC"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_MAYWRITE"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_MAYREAD"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_SHARED"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_EXEC"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_WRITE"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "VM_READ"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void show_smap_vma_flags(struct seq_file *m, struct vm_area_struct *vma)\n{\n\t/*\n\t * Don't forget to update Documentation/ on changes.\n\t */\n\tstatic const char mnemonics[BITS_PER_LONG][2] = {\n\t\t/*\n\t\t * In case if we meet a flag we don't know about.\n\t\t */\n\t\t[0 ... (BITS_PER_LONG-1)] = \"??\",\n\n\t\t[ilog2(VM_READ)]\t= \"rd\",\n\t\t[ilog2(VM_WRITE)]\t= \"wr\",\n\t\t[ilog2(VM_EXEC)]\t= \"ex\",\n\t\t[ilog2(VM_SHARED)]\t= \"sh\",\n\t\t[ilog2(VM_MAYREAD)]\t= \"mr\",\n\t\t[ilog2(VM_MAYWRITE)]\t= \"mw\",\n\t\t[ilog2(VM_MAYEXEC)]\t= \"me\",\n\t\t[ilog2(VM_MAYSHARE)]\t= \"ms\",\n\t\t[ilog2(VM_GROWSDOWN)]\t= \"gd\",\n\t\t[ilog2(VM_PFNMAP)]\t= \"pf\",\n\t\t[ilog2(VM_DENYWRITE)]\t= \"dw\",\n#ifdef CONFIG_X86_INTEL_MPX\n\t\t[ilog2(VM_MPX)]\t\t= \"mp\",\n#endif\n\t\t[ilog2(VM_LOCKED)]\t= \"lo\",\n\t\t[ilog2(VM_IO)]\t\t= \"io\",\n\t\t[ilog2(VM_SEQ_READ)]\t= \"sr\",\n\t\t[ilog2(VM_RAND_READ)]\t= \"rr\",\n\t\t[ilog2(VM_DONTCOPY)]\t= \"dc\",\n\t\t[ilog2(VM_DONTEXPAND)]\t= \"de\",\n\t\t[ilog2(VM_ACCOUNT)]\t= \"ac\",\n\t\t[ilog2(VM_NORESERVE)]\t= \"nr\",\n\t\t[ilog2(VM_HUGETLB)]\t= \"ht\",\n\t\t[ilog2(VM_ARCH_1)]\t= \"ar\",\n\t\t[ilog2(VM_DONTDUMP)]\t= \"dd\",\n#ifdef CONFIG_MEM_SOFT_DIRTY\n\t\t[ilog2(VM_SOFTDIRTY)]\t= \"sd\",\n#endif\n\t\t[ilog2(VM_MIXEDMAP)]\t= \"mm\",\n\t\t[ilog2(VM_HUGEPAGE)]\t= \"hg\",\n\t\t[ilog2(VM_NOHUGEPAGE)]\t= \"nh\",\n\t\t[ilog2(VM_MERGEABLE)]\t= \"mg\",\n\t};\n\tsize_t i;\n\n\tseq_puts(m, \"VmFlags: \");\n\tfor (i = 0; i < BITS_PER_LONG; i++) {\n\t\tif (vma->vm_flags & (1UL << i)) {\n\t\t\tseq_printf(m, \"%c%c \",\n\t\t\t\t   mnemonics[i][0], mnemonics[i][1]);\n\t\t}\n\t}\n\tseq_putc(m, '\\n');\n}"
  },
  {
    "function_name": "smaps_pte_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "529-555",
    "snippet": "static int smaps_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\t   struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tif (pmd_trans_huge_lock(pmd, vma, &ptl) == 1) {\n\t\tsmaps_pmd_entry(pmd, addr, walk);\n\t\tspin_unlock(ptl);\n\t\treturn 0;\n\t}\n\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\n\t/*\n\t * The mmap_sem held all the way back in m_start() is what\n\t * keeps khugepaged out of here and from collapsing things\n\t * in here.\n\t */\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE)\n\t\tsmaps_pte_entry(pte, addr, walk);\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "pte - 1",
            "ptl"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smaps_pte_entry",
          "args": [
            "pte",
            "addr",
            "walk"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "smaps_pte_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "483-504",
          "snippet": "static void smaps_pte_entry(pte_t *pte, unsigned long addr,\n\t\tstruct mm_walk *walk)\n{\n\tstruct mem_size_stats *mss = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct page *page = NULL;\n\n\tif (pte_present(*pte)) {\n\t\tpage = vm_normal_page(vma, addr, *pte);\n\t} else if (is_swap_pte(*pte)) {\n\t\tswp_entry_t swpent = pte_to_swp_entry(*pte);\n\n\t\tif (!non_swap_entry(swpent))\n\t\t\tmss->swap += PAGE_SIZE;\n\t\telse if (is_migration_entry(swpent))\n\t\t\tpage = migration_entry_to_page(swpent);\n\t}\n\n\tif (!page)\n\t\treturn;\n\tsmaps_account(mss, page, PAGE_SIZE, pte_young(*pte), pte_dirty(*pte));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void smaps_pte_entry(pte_t *pte, unsigned long addr,\n\t\tstruct mm_walk *walk)\n{\n\tstruct mem_size_stats *mss = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct page *page = NULL;\n\n\tif (pte_present(*pte)) {\n\t\tpage = vm_normal_page(vma, addr, *pte);\n\t} else if (is_swap_pte(*pte)) {\n\t\tswp_entry_t swpent = pte_to_swp_entry(*pte);\n\n\t\tif (!non_swap_entry(swpent))\n\t\t\tmss->swap += PAGE_SIZE;\n\t\telse if (is_migration_entry(swpent))\n\t\t\tpage = migration_entry_to_page(swpent);\n\t}\n\n\tif (!page)\n\t\treturn;\n\tsmaps_account(mss, page, PAGE_SIZE, pte_young(*pte), pte_dirty(*pte));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "vma->vm_mm",
            "pmd",
            "addr",
            "&ptl"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_unstable",
          "args": [
            "pmd"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "smaps_pmd_entry",
          "args": [
            "pmd",
            "addr",
            "walk"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "smaps_pmd_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "523-526",
          "snippet": "static void smaps_pmd_entry(pmd_t *pmd, unsigned long addr,\n\t\tstruct mm_walk *walk)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void smaps_pmd_entry(pmd_t *pmd, unsigned long addr,\n\t\tstruct mm_walk *walk)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge_lock",
          "args": [
            "pmd",
            "vma",
            "&ptl"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int smaps_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\t   struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tif (pmd_trans_huge_lock(pmd, vma, &ptl) == 1) {\n\t\tsmaps_pmd_entry(pmd, addr, walk);\n\t\tspin_unlock(ptl);\n\t\treturn 0;\n\t}\n\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\n\t/*\n\t * The mmap_sem held all the way back in m_start() is what\n\t * keeps khugepaged out of here and from collapsing things\n\t * in here.\n\t */\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE)\n\t\tsmaps_pte_entry(pte, addr, walk);\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\treturn 0;\n}"
  },
  {
    "function_name": "smaps_pmd_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "523-526",
    "snippet": "static void smaps_pmd_entry(pmd_t *pmd, unsigned long addr,\n\t\tstruct mm_walk *walk)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void smaps_pmd_entry(pmd_t *pmd, unsigned long addr,\n\t\tstruct mm_walk *walk)\n{\n}"
  },
  {
    "function_name": "smaps_pmd_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "507-521",
    "snippet": "static void smaps_pmd_entry(pmd_t *pmd, unsigned long addr,\n\t\tstruct mm_walk *walk)\n{\n\tstruct mem_size_stats *mss = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct page *page;\n\n\t/* FOLL_DUMP will return -EFAULT on huge zero page */\n\tpage = follow_trans_huge_pmd(vma, addr, pmd, FOLL_DUMP);\n\tif (IS_ERR_OR_NULL(page))\n\t\treturn;\n\tmss->anonymous_thp += HPAGE_PMD_SIZE;\n\tsmaps_account(mss, page, HPAGE_PMD_SIZE,\n\t\t\tpmd_young(*pmd), pmd_dirty(*pmd));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smaps_account",
          "args": [
            "mss",
            "page",
            "HPAGE_PMD_SIZE",
            "pmd_young(*pmd)",
            "pmd_dirty(*pmd)"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "smaps_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "451-481",
          "snippet": "static void smaps_account(struct mem_size_stats *mss, struct page *page,\n\t\tunsigned long size, bool young, bool dirty)\n{\n\tint mapcount;\n\n\tif (PageAnon(page))\n\t\tmss->anonymous += size;\n\n\tmss->resident += size;\n\t/* Accumulate the size in pages that have been accessed. */\n\tif (young || PageReferenced(page))\n\t\tmss->referenced += size;\n\tmapcount = page_mapcount(page);\n\tif (mapcount >= 2) {\n\t\tu64 pss_delta;\n\n\t\tif (dirty || PageDirty(page))\n\t\t\tmss->shared_dirty += size;\n\t\telse\n\t\t\tmss->shared_clean += size;\n\t\tpss_delta = (u64)size << PSS_SHIFT;\n\t\tdo_div(pss_delta, mapcount);\n\t\tmss->pss += pss_delta;\n\t} else {\n\t\tif (dirty || PageDirty(page))\n\t\t\tmss->private_dirty += size;\n\t\telse\n\t\t\tmss->private_clean += size;\n\t\tmss->pss += (u64)size << PSS_SHIFT;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define PSS_SHIFT 12"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\n#define PSS_SHIFT 12\n\nstatic void smaps_account(struct mem_size_stats *mss, struct page *page,\n\t\tunsigned long size, bool young, bool dirty)\n{\n\tint mapcount;\n\n\tif (PageAnon(page))\n\t\tmss->anonymous += size;\n\n\tmss->resident += size;\n\t/* Accumulate the size in pages that have been accessed. */\n\tif (young || PageReferenced(page))\n\t\tmss->referenced += size;\n\tmapcount = page_mapcount(page);\n\tif (mapcount >= 2) {\n\t\tu64 pss_delta;\n\n\t\tif (dirty || PageDirty(page))\n\t\t\tmss->shared_dirty += size;\n\t\telse\n\t\t\tmss->shared_clean += size;\n\t\tpss_delta = (u64)size << PSS_SHIFT;\n\t\tdo_div(pss_delta, mapcount);\n\t\tmss->pss += pss_delta;\n\t} else {\n\t\tif (dirty || PageDirty(page))\n\t\t\tmss->private_dirty += size;\n\t\telse\n\t\t\tmss->private_clean += size;\n\t\tmss->pss += (u64)size << PSS_SHIFT;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_dirty",
          "args": [
            "*pmd"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_young",
          "args": [
            "*pmd"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "page"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_trans_huge_pmd",
          "args": [
            "vma",
            "addr",
            "pmd",
            "FOLL_DUMP"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void smaps_pmd_entry(pmd_t *pmd, unsigned long addr,\n\t\tstruct mm_walk *walk)\n{\n\tstruct mem_size_stats *mss = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct page *page;\n\n\t/* FOLL_DUMP will return -EFAULT on huge zero page */\n\tpage = follow_trans_huge_pmd(vma, addr, pmd, FOLL_DUMP);\n\tif (IS_ERR_OR_NULL(page))\n\t\treturn;\n\tmss->anonymous_thp += HPAGE_PMD_SIZE;\n\tsmaps_account(mss, page, HPAGE_PMD_SIZE,\n\t\t\tpmd_young(*pmd), pmd_dirty(*pmd));\n}"
  },
  {
    "function_name": "smaps_pte_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "483-504",
    "snippet": "static void smaps_pte_entry(pte_t *pte, unsigned long addr,\n\t\tstruct mm_walk *walk)\n{\n\tstruct mem_size_stats *mss = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct page *page = NULL;\n\n\tif (pte_present(*pte)) {\n\t\tpage = vm_normal_page(vma, addr, *pte);\n\t} else if (is_swap_pte(*pte)) {\n\t\tswp_entry_t swpent = pte_to_swp_entry(*pte);\n\n\t\tif (!non_swap_entry(swpent))\n\t\t\tmss->swap += PAGE_SIZE;\n\t\telse if (is_migration_entry(swpent))\n\t\t\tpage = migration_entry_to_page(swpent);\n\t}\n\n\tif (!page)\n\t\treturn;\n\tsmaps_account(mss, page, PAGE_SIZE, pte_young(*pte), pte_dirty(*pte));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smaps_account",
          "args": [
            "mss",
            "page",
            "PAGE_SIZE",
            "pte_young(*pte)",
            "pte_dirty(*pte)"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "smaps_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "451-481",
          "snippet": "static void smaps_account(struct mem_size_stats *mss, struct page *page,\n\t\tunsigned long size, bool young, bool dirty)\n{\n\tint mapcount;\n\n\tif (PageAnon(page))\n\t\tmss->anonymous += size;\n\n\tmss->resident += size;\n\t/* Accumulate the size in pages that have been accessed. */\n\tif (young || PageReferenced(page))\n\t\tmss->referenced += size;\n\tmapcount = page_mapcount(page);\n\tif (mapcount >= 2) {\n\t\tu64 pss_delta;\n\n\t\tif (dirty || PageDirty(page))\n\t\t\tmss->shared_dirty += size;\n\t\telse\n\t\t\tmss->shared_clean += size;\n\t\tpss_delta = (u64)size << PSS_SHIFT;\n\t\tdo_div(pss_delta, mapcount);\n\t\tmss->pss += pss_delta;\n\t} else {\n\t\tif (dirty || PageDirty(page))\n\t\t\tmss->private_dirty += size;\n\t\telse\n\t\t\tmss->private_clean += size;\n\t\tmss->pss += (u64)size << PSS_SHIFT;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define PSS_SHIFT 12"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\n#define PSS_SHIFT 12\n\nstatic void smaps_account(struct mem_size_stats *mss, struct page *page,\n\t\tunsigned long size, bool young, bool dirty)\n{\n\tint mapcount;\n\n\tif (PageAnon(page))\n\t\tmss->anonymous += size;\n\n\tmss->resident += size;\n\t/* Accumulate the size in pages that have been accessed. */\n\tif (young || PageReferenced(page))\n\t\tmss->referenced += size;\n\tmapcount = page_mapcount(page);\n\tif (mapcount >= 2) {\n\t\tu64 pss_delta;\n\n\t\tif (dirty || PageDirty(page))\n\t\t\tmss->shared_dirty += size;\n\t\telse\n\t\t\tmss->shared_clean += size;\n\t\tpss_delta = (u64)size << PSS_SHIFT;\n\t\tdo_div(pss_delta, mapcount);\n\t\tmss->pss += pss_delta;\n\t} else {\n\t\tif (dirty || PageDirty(page))\n\t\t\tmss->private_dirty += size;\n\t\telse\n\t\t\tmss->private_clean += size;\n\t\tmss->pss += (u64)size << PSS_SHIFT;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_dirty",
          "args": [
            "*pte"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_young",
          "args": [
            "*pte"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migration_entry_to_page",
          "args": [
            "swpent"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migration_entry",
          "args": [
            "swpent"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "non_swap_entry",
          "args": [
            "swpent"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "*pte"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swap_pte",
          "args": [
            "*pte"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_normal_page",
          "args": [
            "vma",
            "addr",
            "*pte"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "*pte"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void smaps_pte_entry(pte_t *pte, unsigned long addr,\n\t\tstruct mm_walk *walk)\n{\n\tstruct mem_size_stats *mss = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct page *page = NULL;\n\n\tif (pte_present(*pte)) {\n\t\tpage = vm_normal_page(vma, addr, *pte);\n\t} else if (is_swap_pte(*pte)) {\n\t\tswp_entry_t swpent = pte_to_swp_entry(*pte);\n\n\t\tif (!non_swap_entry(swpent))\n\t\t\tmss->swap += PAGE_SIZE;\n\t\telse if (is_migration_entry(swpent))\n\t\t\tpage = migration_entry_to_page(swpent);\n\t}\n\n\tif (!page)\n\t\treturn;\n\tsmaps_account(mss, page, PAGE_SIZE, pte_young(*pte), pte_dirty(*pte));\n}"
  },
  {
    "function_name": "smaps_account",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "451-481",
    "snippet": "static void smaps_account(struct mem_size_stats *mss, struct page *page,\n\t\tunsigned long size, bool young, bool dirty)\n{\n\tint mapcount;\n\n\tif (PageAnon(page))\n\t\tmss->anonymous += size;\n\n\tmss->resident += size;\n\t/* Accumulate the size in pages that have been accessed. */\n\tif (young || PageReferenced(page))\n\t\tmss->referenced += size;\n\tmapcount = page_mapcount(page);\n\tif (mapcount >= 2) {\n\t\tu64 pss_delta;\n\n\t\tif (dirty || PageDirty(page))\n\t\t\tmss->shared_dirty += size;\n\t\telse\n\t\t\tmss->shared_clean += size;\n\t\tpss_delta = (u64)size << PSS_SHIFT;\n\t\tdo_div(pss_delta, mapcount);\n\t\tmss->pss += pss_delta;\n\t} else {\n\t\tif (dirty || PageDirty(page))\n\t\t\tmss->private_dirty += size;\n\t\telse\n\t\t\tmss->private_clean += size;\n\t\tmss->pss += (u64)size << PSS_SHIFT;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define PSS_SHIFT 12"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "pss_delta",
            "mapcount"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageReferenced",
          "args": [
            "page"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\n#define PSS_SHIFT 12\n\nstatic void smaps_account(struct mem_size_stats *mss, struct page *page,\n\t\tunsigned long size, bool young, bool dirty)\n{\n\tint mapcount;\n\n\tif (PageAnon(page))\n\t\tmss->anonymous += size;\n\n\tmss->resident += size;\n\t/* Accumulate the size in pages that have been accessed. */\n\tif (young || PageReferenced(page))\n\t\tmss->referenced += size;\n\tmapcount = page_mapcount(page);\n\tif (mapcount >= 2) {\n\t\tu64 pss_delta;\n\n\t\tif (dirty || PageDirty(page))\n\t\t\tmss->shared_dirty += size;\n\t\telse\n\t\t\tmss->shared_clean += size;\n\t\tpss_delta = (u64)size << PSS_SHIFT;\n\t\tdo_div(pss_delta, mapcount);\n\t\tmss->pss += pss_delta;\n\t} else {\n\t\tif (dirty || PageDirty(page))\n\t\t\tmss->private_dirty += size;\n\t\telse\n\t\t\tmss->private_clean += size;\n\t\tmss->pss += (u64)size << PSS_SHIFT;\n\t}\n}"
  },
  {
    "function_name": "tid_maps_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "399-402",
    "snippet": "static int tid_maps_open(struct inode *inode, struct file *file)\n{\n\treturn do_maps_open(inode, file, &proc_tid_maps_op);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations proc_tid_maps_op = {\n\t.start\t= m_start,\n\t.next\t= m_next,\n\t.stop\t= m_stop,\n\t.show\t= show_tid_map\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_maps_open",
          "args": [
            "inode",
            "file",
            "&proc_tid_maps_op"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "do_maps_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "242-247",
          "snippet": "static int do_maps_open(struct inode *inode, struct file *file,\n\t\t\tconst struct seq_operations *ops)\n{\n\treturn proc_maps_open(inode, file, ops,\n\t\t\t\tsizeof(struct proc_maps_private));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int do_maps_open(struct inode *inode, struct file *file,\n\t\t\tconst struct seq_operations *ops)\n{\n\treturn proc_maps_open(inode, file, ops,\n\t\t\t\tsizeof(struct proc_maps_private));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic const struct seq_operations proc_tid_maps_op = {\n\t.start\t= m_start,\n\t.next\t= m_next,\n\t.stop\t= m_stop,\n\t.show\t= show_tid_map\n};\n\nstatic int tid_maps_open(struct inode *inode, struct file *file)\n{\n\treturn do_maps_open(inode, file, &proc_tid_maps_op);\n}"
  },
  {
    "function_name": "pid_maps_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "394-397",
    "snippet": "static int pid_maps_open(struct inode *inode, struct file *file)\n{\n\treturn do_maps_open(inode, file, &proc_pid_maps_op);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations proc_pid_maps_op = {\n\t.start\t= m_start,\n\t.next\t= m_next,\n\t.stop\t= m_stop,\n\t.show\t= show_pid_map\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_maps_open",
          "args": [
            "inode",
            "file",
            "&proc_pid_maps_op"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "do_maps_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "242-247",
          "snippet": "static int do_maps_open(struct inode *inode, struct file *file,\n\t\t\tconst struct seq_operations *ops)\n{\n\treturn proc_maps_open(inode, file, ops,\n\t\t\t\tsizeof(struct proc_maps_private));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int do_maps_open(struct inode *inode, struct file *file,\n\t\t\tconst struct seq_operations *ops)\n{\n\treturn proc_maps_open(inode, file, ops,\n\t\t\t\tsizeof(struct proc_maps_private));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic const struct seq_operations proc_pid_maps_op = {\n\t.start\t= m_start,\n\t.next\t= m_next,\n\t.stop\t= m_stop,\n\t.show\t= show_pid_map\n};\n\nstatic int pid_maps_open(struct inode *inode, struct file *file)\n{\n\treturn do_maps_open(inode, file, &proc_pid_maps_op);\n}"
  },
  {
    "function_name": "show_tid_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "375-378",
    "snippet": "static int show_tid_map(struct seq_file *m, void *v)\n{\n\treturn show_map(m, v, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_map",
          "args": [
            "m",
            "v",
            "0"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "show_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "363-368",
          "snippet": "static int show_map(struct seq_file *m, void *v, int is_pid)\n{\n\tshow_map_vma(m, v, is_pid);\n\tm_cache_vma(m, v);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int show_map(struct seq_file *m, void *v, int is_pid)\n{\n\tshow_map_vma(m, v, is_pid);\n\tm_cache_vma(m, v);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int show_tid_map(struct seq_file *m, void *v)\n{\n\treturn show_map(m, v, 0);\n}"
  },
  {
    "function_name": "show_pid_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "370-373",
    "snippet": "static int show_pid_map(struct seq_file *m, void *v)\n{\n\treturn show_map(m, v, 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_map",
          "args": [
            "m",
            "v",
            "1"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "show_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "363-368",
          "snippet": "static int show_map(struct seq_file *m, void *v, int is_pid)\n{\n\tshow_map_vma(m, v, is_pid);\n\tm_cache_vma(m, v);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int show_map(struct seq_file *m, void *v, int is_pid)\n{\n\tshow_map_vma(m, v, is_pid);\n\tm_cache_vma(m, v);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int show_pid_map(struct seq_file *m, void *v)\n{\n\treturn show_map(m, v, 1);\n}"
  },
  {
    "function_name": "show_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "363-368",
    "snippet": "static int show_map(struct seq_file *m, void *v, int is_pid)\n{\n\tshow_map_vma(m, v, is_pid);\n\tm_cache_vma(m, v);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_cache_vma",
          "args": [
            "m",
            "v"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "m_cache_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "134-138",
          "snippet": "static void m_cache_vma(struct seq_file *m, struct vm_area_struct *vma)\n{\n\tif (m->count < m->size)\t/* vma is copied successfully */\n\t\tm->version = m_next_vma(m->private, vma) ? vma->vm_start : -1UL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void m_cache_vma(struct seq_file *m, struct vm_area_struct *vma)\n{\n\tif (m->count < m->size)\t/* vma is copied successfully */\n\t\tm->version = m_next_vma(m->private, vma) ? vma->vm_start : -1UL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_map_vma",
          "args": [
            "m",
            "v",
            "is_pid"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "show_map_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "268-361",
          "snippet": "static void\nshow_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct file *file = vma->vm_file;\n\tstruct proc_maps_private *priv = m->private;\n\tvm_flags_t flags = vma->vm_flags;\n\tunsigned long ino = 0;\n\tunsigned long long pgoff = 0;\n\tunsigned long start, end;\n\tdev_t dev = 0;\n\tconst char *name = NULL;\n\n\tif (file) {\n\t\tstruct inode *inode = file_inode(vma->vm_file);\n\t\tdev = inode->i_sb->s_dev;\n\t\tino = inode->i_ino;\n\t\tpgoff = ((loff_t)vma->vm_pgoff) << PAGE_SHIFT;\n\t}\n\n\t/* We don't show the stack guard page in /proc/maps */\n\tstart = vma->vm_start;\n\tif (stack_guard_page_start(vma, start))\n\t\tstart += PAGE_SIZE;\n\tend = vma->vm_end;\n\tif (stack_guard_page_end(vma, end))\n\t\tend -= PAGE_SIZE;\n\n\tseq_setwidth(m, 25 + sizeof(void *) * 6 - 1);\n\tseq_printf(m, \"%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu \",\n\t\t\tstart,\n\t\t\tend,\n\t\t\tflags & VM_READ ? 'r' : '-',\n\t\t\tflags & VM_WRITE ? 'w' : '-',\n\t\t\tflags & VM_EXEC ? 'x' : '-',\n\t\t\tflags & VM_MAYSHARE ? 's' : 'p',\n\t\t\tpgoff,\n\t\t\tMAJOR(dev), MINOR(dev), ino);\n\n\t/*\n\t * Print the dentry name for named mappings, and a\n\t * special [heap] marker for the heap:\n\t */\n\tif (file) {\n\t\tseq_pad(m, ' ');\n\t\tseq_path(m, &file->f_path, \"\\n\");\n\t\tgoto done;\n\t}\n\n\tif (vma->vm_ops && vma->vm_ops->name) {\n\t\tname = vma->vm_ops->name(vma);\n\t\tif (name)\n\t\t\tgoto done;\n\t}\n\n\tname = arch_vma_name(vma);\n\tif (!name) {\n\t\tpid_t tid;\n\n\t\tif (!mm) {\n\t\t\tname = \"[vdso]\";\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (vma->vm_start <= mm->brk &&\n\t\t    vma->vm_end >= mm->start_brk) {\n\t\t\tname = \"[heap]\";\n\t\t\tgoto done;\n\t\t}\n\n\t\ttid = pid_of_stack(priv, vma, is_pid);\n\t\tif (tid != 0) {\n\t\t\t/*\n\t\t\t * Thread stack in /proc/PID/task/TID/maps or\n\t\t\t * the main process stack.\n\t\t\t */\n\t\t\tif (!is_pid || (vma->vm_start <= mm->start_stack &&\n\t\t\t    vma->vm_end >= mm->start_stack)) {\n\t\t\t\tname = \"[stack]\";\n\t\t\t} else {\n\t\t\t\t/* Thread stack in /proc/PID/maps */\n\t\t\t\tseq_pad(m, ' ');\n\t\t\t\tseq_printf(m, \"[stack:%d]\", tid);\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tif (name) {\n\t\tseq_pad(m, ' ');\n\t\tseq_puts(m, name);\n\t}\n\tseq_putc(m, '\\n');\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void\nshow_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct file *file = vma->vm_file;\n\tstruct proc_maps_private *priv = m->private;\n\tvm_flags_t flags = vma->vm_flags;\n\tunsigned long ino = 0;\n\tunsigned long long pgoff = 0;\n\tunsigned long start, end;\n\tdev_t dev = 0;\n\tconst char *name = NULL;\n\n\tif (file) {\n\t\tstruct inode *inode = file_inode(vma->vm_file);\n\t\tdev = inode->i_sb->s_dev;\n\t\tino = inode->i_ino;\n\t\tpgoff = ((loff_t)vma->vm_pgoff) << PAGE_SHIFT;\n\t}\n\n\t/* We don't show the stack guard page in /proc/maps */\n\tstart = vma->vm_start;\n\tif (stack_guard_page_start(vma, start))\n\t\tstart += PAGE_SIZE;\n\tend = vma->vm_end;\n\tif (stack_guard_page_end(vma, end))\n\t\tend -= PAGE_SIZE;\n\n\tseq_setwidth(m, 25 + sizeof(void *) * 6 - 1);\n\tseq_printf(m, \"%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu \",\n\t\t\tstart,\n\t\t\tend,\n\t\t\tflags & VM_READ ? 'r' : '-',\n\t\t\tflags & VM_WRITE ? 'w' : '-',\n\t\t\tflags & VM_EXEC ? 'x' : '-',\n\t\t\tflags & VM_MAYSHARE ? 's' : 'p',\n\t\t\tpgoff,\n\t\t\tMAJOR(dev), MINOR(dev), ino);\n\n\t/*\n\t * Print the dentry name for named mappings, and a\n\t * special [heap] marker for the heap:\n\t */\n\tif (file) {\n\t\tseq_pad(m, ' ');\n\t\tseq_path(m, &file->f_path, \"\\n\");\n\t\tgoto done;\n\t}\n\n\tif (vma->vm_ops && vma->vm_ops->name) {\n\t\tname = vma->vm_ops->name(vma);\n\t\tif (name)\n\t\t\tgoto done;\n\t}\n\n\tname = arch_vma_name(vma);\n\tif (!name) {\n\t\tpid_t tid;\n\n\t\tif (!mm) {\n\t\t\tname = \"[vdso]\";\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (vma->vm_start <= mm->brk &&\n\t\t    vma->vm_end >= mm->start_brk) {\n\t\t\tname = \"[heap]\";\n\t\t\tgoto done;\n\t\t}\n\n\t\ttid = pid_of_stack(priv, vma, is_pid);\n\t\tif (tid != 0) {\n\t\t\t/*\n\t\t\t * Thread stack in /proc/PID/task/TID/maps or\n\t\t\t * the main process stack.\n\t\t\t */\n\t\t\tif (!is_pid || (vma->vm_start <= mm->start_stack &&\n\t\t\t    vma->vm_end >= mm->start_stack)) {\n\t\t\t\tname = \"[stack]\";\n\t\t\t} else {\n\t\t\t\t/* Thread stack in /proc/PID/maps */\n\t\t\t\tseq_pad(m, ' ');\n\t\t\t\tseq_printf(m, \"[stack:%d]\", tid);\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tif (name) {\n\t\tseq_pad(m, ' ');\n\t\tseq_puts(m, name);\n\t}\n\tseq_putc(m, '\\n');\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int show_map(struct seq_file *m, void *v, int is_pid)\n{\n\tshow_map_vma(m, v, is_pid);\n\tm_cache_vma(m, v);\n\treturn 0;\n}"
  },
  {
    "function_name": "show_map_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "268-361",
    "snippet": "static void\nshow_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct file *file = vma->vm_file;\n\tstruct proc_maps_private *priv = m->private;\n\tvm_flags_t flags = vma->vm_flags;\n\tunsigned long ino = 0;\n\tunsigned long long pgoff = 0;\n\tunsigned long start, end;\n\tdev_t dev = 0;\n\tconst char *name = NULL;\n\n\tif (file) {\n\t\tstruct inode *inode = file_inode(vma->vm_file);\n\t\tdev = inode->i_sb->s_dev;\n\t\tino = inode->i_ino;\n\t\tpgoff = ((loff_t)vma->vm_pgoff) << PAGE_SHIFT;\n\t}\n\n\t/* We don't show the stack guard page in /proc/maps */\n\tstart = vma->vm_start;\n\tif (stack_guard_page_start(vma, start))\n\t\tstart += PAGE_SIZE;\n\tend = vma->vm_end;\n\tif (stack_guard_page_end(vma, end))\n\t\tend -= PAGE_SIZE;\n\n\tseq_setwidth(m, 25 + sizeof(void *) * 6 - 1);\n\tseq_printf(m, \"%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu \",\n\t\t\tstart,\n\t\t\tend,\n\t\t\tflags & VM_READ ? 'r' : '-',\n\t\t\tflags & VM_WRITE ? 'w' : '-',\n\t\t\tflags & VM_EXEC ? 'x' : '-',\n\t\t\tflags & VM_MAYSHARE ? 's' : 'p',\n\t\t\tpgoff,\n\t\t\tMAJOR(dev), MINOR(dev), ino);\n\n\t/*\n\t * Print the dentry name for named mappings, and a\n\t * special [heap] marker for the heap:\n\t */\n\tif (file) {\n\t\tseq_pad(m, ' ');\n\t\tseq_path(m, &file->f_path, \"\\n\");\n\t\tgoto done;\n\t}\n\n\tif (vma->vm_ops && vma->vm_ops->name) {\n\t\tname = vma->vm_ops->name(vma);\n\t\tif (name)\n\t\t\tgoto done;\n\t}\n\n\tname = arch_vma_name(vma);\n\tif (!name) {\n\t\tpid_t tid;\n\n\t\tif (!mm) {\n\t\t\tname = \"[vdso]\";\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (vma->vm_start <= mm->brk &&\n\t\t    vma->vm_end >= mm->start_brk) {\n\t\t\tname = \"[heap]\";\n\t\t\tgoto done;\n\t\t}\n\n\t\ttid = pid_of_stack(priv, vma, is_pid);\n\t\tif (tid != 0) {\n\t\t\t/*\n\t\t\t * Thread stack in /proc/PID/task/TID/maps or\n\t\t\t * the main process stack.\n\t\t\t */\n\t\t\tif (!is_pid || (vma->vm_start <= mm->start_stack &&\n\t\t\t    vma->vm_end >= mm->start_stack)) {\n\t\t\t\tname = \"[stack]\";\n\t\t\t} else {\n\t\t\t\t/* Thread stack in /proc/PID/maps */\n\t\t\t\tseq_pad(m, ' ');\n\t\t\t\tseq_printf(m, \"[stack:%d]\", tid);\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tif (name) {\n\t\tseq_pad(m, ' ');\n\t\tseq_puts(m, name);\n\t}\n\tseq_putc(m, '\\n');\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "648-655",
          "snippet": "int seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "name"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_pad",
          "args": [
            "m",
            "' '"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "seq_pad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "748-755",
          "snippet": "void seq_pad(struct seq_file *m, char c)\n{\n\tint size = m->pad_until - m->count;\n\tif (size > 0)\n\t\tseq_printf(m, \"%*s\", size, \"\");\n\tif (c)\n\t\tseq_putc(m, c);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid seq_pad(struct seq_file *m, char c)\n{\n\tint size = m->pad_until - m->count;\n\tif (size > 0)\n\t\tseq_printf(m, \"%*s\", size, \"\");\n\tif (c)\n\t\tseq_putc(m, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"[stack:%d]\"",
            "tid"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_of_stack",
          "args": [
            "priv",
            "vma",
            "is_pid"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "pid_of_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "249-266",
          "snippet": "static pid_t pid_of_stack(struct proc_maps_private *priv,\n\t\t\t\tstruct vm_area_struct *vma, bool is_pid)\n{\n\tstruct inode *inode = priv->inode;\n\tstruct task_struct *task;\n\tpid_t ret = 0;\n\n\trcu_read_lock();\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\ttask = task_of_stack(task, vma, is_pid);\n\t\tif (task)\n\t\t\tret = task_pid_nr_ns(task, inode->i_sb->s_fs_info);\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic pid_t pid_of_stack(struct proc_maps_private *priv,\n\t\t\t\tstruct vm_area_struct *vma, bool is_pid)\n{\n\tstruct inode *inode = priv->inode;\n\tstruct task_struct *task;\n\tpid_t ret = 0;\n\n\trcu_read_lock();\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\ttask = task_of_stack(task, vma, is_pid);\n\t\tif (task)\n\t\t\tret = task_pid_nr_ns(task, inode->i_sb->s_fs_info);\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_vma_name",
          "args": [
            "vma"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma->vm_ops->name",
          "args": [
            "vma"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_path",
          "args": [
            "m",
            "&file->f_path",
            "\"\\n\""
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "seq_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "470-487",
          "snippet": "int seq_path(struct seq_file *m, const struct path *path, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = d_path(path, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_path(struct seq_file *m, const struct path *path, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = d_path(path, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "dev"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "dev"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_setwidth",
          "args": [
            "m",
            "25 + sizeof(void *) * 6 - 1"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack_guard_page_end",
          "args": [
            "vma",
            "end"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack_guard_page_start",
          "args": [
            "vma",
            "start"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void\nshow_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct file *file = vma->vm_file;\n\tstruct proc_maps_private *priv = m->private;\n\tvm_flags_t flags = vma->vm_flags;\n\tunsigned long ino = 0;\n\tunsigned long long pgoff = 0;\n\tunsigned long start, end;\n\tdev_t dev = 0;\n\tconst char *name = NULL;\n\n\tif (file) {\n\t\tstruct inode *inode = file_inode(vma->vm_file);\n\t\tdev = inode->i_sb->s_dev;\n\t\tino = inode->i_ino;\n\t\tpgoff = ((loff_t)vma->vm_pgoff) << PAGE_SHIFT;\n\t}\n\n\t/* We don't show the stack guard page in /proc/maps */\n\tstart = vma->vm_start;\n\tif (stack_guard_page_start(vma, start))\n\t\tstart += PAGE_SIZE;\n\tend = vma->vm_end;\n\tif (stack_guard_page_end(vma, end))\n\t\tend -= PAGE_SIZE;\n\n\tseq_setwidth(m, 25 + sizeof(void *) * 6 - 1);\n\tseq_printf(m, \"%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu \",\n\t\t\tstart,\n\t\t\tend,\n\t\t\tflags & VM_READ ? 'r' : '-',\n\t\t\tflags & VM_WRITE ? 'w' : '-',\n\t\t\tflags & VM_EXEC ? 'x' : '-',\n\t\t\tflags & VM_MAYSHARE ? 's' : 'p',\n\t\t\tpgoff,\n\t\t\tMAJOR(dev), MINOR(dev), ino);\n\n\t/*\n\t * Print the dentry name for named mappings, and a\n\t * special [heap] marker for the heap:\n\t */\n\tif (file) {\n\t\tseq_pad(m, ' ');\n\t\tseq_path(m, &file->f_path, \"\\n\");\n\t\tgoto done;\n\t}\n\n\tif (vma->vm_ops && vma->vm_ops->name) {\n\t\tname = vma->vm_ops->name(vma);\n\t\tif (name)\n\t\t\tgoto done;\n\t}\n\n\tname = arch_vma_name(vma);\n\tif (!name) {\n\t\tpid_t tid;\n\n\t\tif (!mm) {\n\t\t\tname = \"[vdso]\";\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (vma->vm_start <= mm->brk &&\n\t\t    vma->vm_end >= mm->start_brk) {\n\t\t\tname = \"[heap]\";\n\t\t\tgoto done;\n\t\t}\n\n\t\ttid = pid_of_stack(priv, vma, is_pid);\n\t\tif (tid != 0) {\n\t\t\t/*\n\t\t\t * Thread stack in /proc/PID/task/TID/maps or\n\t\t\t * the main process stack.\n\t\t\t */\n\t\t\tif (!is_pid || (vma->vm_start <= mm->start_stack &&\n\t\t\t    vma->vm_end >= mm->start_stack)) {\n\t\t\t\tname = \"[stack]\";\n\t\t\t} else {\n\t\t\t\t/* Thread stack in /proc/PID/maps */\n\t\t\t\tseq_pad(m, ' ');\n\t\t\t\tseq_printf(m, \"[stack:%d]\", tid);\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tif (name) {\n\t\tseq_pad(m, ' ');\n\t\tseq_puts(m, name);\n\t}\n\tseq_putc(m, '\\n');\n}"
  },
  {
    "function_name": "pid_of_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "249-266",
    "snippet": "static pid_t pid_of_stack(struct proc_maps_private *priv,\n\t\t\t\tstruct vm_area_struct *vma, bool is_pid)\n{\n\tstruct inode *inode = priv->inode;\n\tstruct task_struct *task;\n\tpid_t ret = 0;\n\n\trcu_read_lock();\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\ttask = task_of_stack(task, vma, is_pid);\n\t\tif (task)\n\t\t\tret = task_pid_nr_ns(task, inode->i_sb->s_fs_info);\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr_ns",
          "args": [
            "task",
            "inode->i_sb->s_fs_info"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_of_stack",
          "args": [
            "task",
            "vma",
            "is_pid"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_task",
          "args": [
            "proc_pid(inode)",
            "PIDTYPE_PID"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_pid",
          "args": [
            "inode"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "90-93",
          "snippet": "static inline struct pid *proc_pid(struct inode *inode)\n{\n\treturn PROC_I(inode)->pid;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct pid *proc_pid(struct inode *inode)\n{\n\treturn PROC_I(inode)->pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic pid_t pid_of_stack(struct proc_maps_private *priv,\n\t\t\t\tstruct vm_area_struct *vma, bool is_pid)\n{\n\tstruct inode *inode = priv->inode;\n\tstruct task_struct *task;\n\tpid_t ret = 0;\n\n\trcu_read_lock();\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\ttask = task_of_stack(task, vma, is_pid);\n\t\tif (task)\n\t\t\tret = task_pid_nr_ns(task, inode->i_sb->s_fs_info);\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "do_maps_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "242-247",
    "snippet": "static int do_maps_open(struct inode *inode, struct file *file,\n\t\t\tconst struct seq_operations *ops)\n{\n\treturn proc_maps_open(inode, file, ops,\n\t\t\t\tsizeof(struct proc_maps_private));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_maps_open",
          "args": [
            "inode",
            "file",
            "ops",
            "sizeof(struct proc_maps_private)"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "proc_maps_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "211-229",
          "snippet": "static int proc_maps_open(struct inode *inode, struct file *file,\n\t\t\tconst struct seq_operations *ops, int psize)\n{\n\tstruct proc_maps_private *priv = __seq_open_private(file, ops, psize);\n\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->inode = inode;\n\tpriv->mm = proc_mem_open(inode, PTRACE_MODE_READ);\n\tif (IS_ERR(priv->mm)) {\n\t\tint err = PTR_ERR(priv->mm);\n\n\t\tseq_release_private(inode, file);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int proc_maps_open(struct inode *inode, struct file *file,\n\t\t\tconst struct seq_operations *ops, int psize)\n{\n\tstruct proc_maps_private *priv = __seq_open_private(file, ops, psize);\n\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->inode = inode;\n\tpriv->mm = proc_mem_open(inode, PTRACE_MODE_READ);\n\tif (IS_ERR(priv->mm)) {\n\t\tint err = PTR_ERR(priv->mm);\n\n\t\tseq_release_private(inode, file);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int do_maps_open(struct inode *inode, struct file *file,\n\t\t\tconst struct seq_operations *ops)\n{\n\treturn proc_maps_open(inode, file, ops,\n\t\t\t\tsizeof(struct proc_maps_private));\n}"
  },
  {
    "function_name": "proc_map_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "231-240",
    "snippet": "static int proc_map_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct proc_maps_private *priv = seq->private;\n\n\tif (priv->mm)\n\t\tmmdrop(priv->mm);\n\n\treturn seq_release_private(inode, file);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_release_private",
          "args": [
            "inode",
            "file"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "seq_release_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "605-612",
          "snippet": "int seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmdrop",
          "args": [
            "priv->mm"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int proc_map_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct proc_maps_private *priv = seq->private;\n\n\tif (priv->mm)\n\t\tmmdrop(priv->mm);\n\n\treturn seq_release_private(inode, file);\n}"
  },
  {
    "function_name": "proc_maps_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "211-229",
    "snippet": "static int proc_maps_open(struct inode *inode, struct file *file,\n\t\t\tconst struct seq_operations *ops, int psize)\n{\n\tstruct proc_maps_private *priv = __seq_open_private(file, ops, psize);\n\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->inode = inode;\n\tpriv->mm = proc_mem_open(inode, PTRACE_MODE_READ);\n\tif (IS_ERR(priv->mm)) {\n\t\tint err = PTR_ERR(priv->mm);\n\n\t\tseq_release_private(inode, file);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_release_private",
          "args": [
            "inode",
            "file"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "seq_release_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "605-612",
          "snippet": "int seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "priv->mm"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "priv->mm"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_mem_open",
          "args": [
            "inode",
            "PTRACE_MODE_READ"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "proc_mem_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "605-623",
          "snippet": "struct mm_struct *proc_mem_open(struct inode *inode, unsigned int mode)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct mm_struct *mm = ERR_PTR(-ESRCH);\n\n\tif (task) {\n\t\tmm = mm_access(task, mode);\n\t\tput_task_struct(task);\n\n\t\tif (!IS_ERR_OR_NULL(mm)) {\n\t\t\t/* ensure this mm_struct can't be freed */\n\t\t\tatomic_inc(&mm->mm_count);\n\t\t\t/* but do not pin its memory */\n\t\t\tmmput(mm);\n\t\t}\n\t}\n\n\treturn mm;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstruct mm_struct *proc_mem_open(struct inode *inode, unsigned int mode)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct mm_struct *mm = ERR_PTR(-ESRCH);\n\n\tif (task) {\n\t\tmm = mm_access(task, mode);\n\t\tput_task_struct(task);\n\n\t\tif (!IS_ERR_OR_NULL(mm)) {\n\t\t\t/* ensure this mm_struct can't be freed */\n\t\t\tatomic_inc(&mm->mm_count);\n\t\t\t/* but do not pin its memory */\n\t\t\tmmput(mm);\n\t\t}\n\t}\n\n\treturn mm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__seq_open_private",
          "args": [
            "file",
            "ops",
            "psize"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "__seq_open_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "615-638",
          "snippet": "void *__seq_open_private(struct file *f, const struct seq_operations *ops,\n\t\tint psize)\n{\n\tint rc;\n\tvoid *private;\n\tstruct seq_file *seq;\n\n\tprivate = kzalloc(psize, GFP_KERNEL);\n\tif (private == NULL)\n\t\tgoto out;\n\n\trc = seq_open(f, ops);\n\tif (rc < 0)\n\t\tgoto out_free;\n\n\tseq = f->private_data;\n\tseq->private = private;\n\treturn private;\n\nout_free:\n\tkfree(private);\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid *__seq_open_private(struct file *f, const struct seq_operations *ops,\n\t\tint psize)\n{\n\tint rc;\n\tvoid *private;\n\tstruct seq_file *seq;\n\n\tprivate = kzalloc(psize, GFP_KERNEL);\n\tif (private == NULL)\n\t\tgoto out;\n\n\trc = seq_open(f, ops);\n\tif (rc < 0)\n\t\tgoto out_free;\n\n\tseq = f->private_data;\n\tseq->private = private;\n\treturn private;\n\nout_free:\n\tkfree(private);\nout:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic int proc_maps_open(struct inode *inode, struct file *file,\n\t\t\tconst struct seq_operations *ops, int psize)\n{\n\tstruct proc_maps_private *priv = __seq_open_private(file, ops, psize);\n\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->inode = inode;\n\tpriv->mm = proc_mem_open(inode, PTRACE_MODE_READ);\n\tif (IS_ERR(priv->mm)) {\n\t\tint err = PTR_ERR(priv->mm);\n\n\t\tseq_release_private(inode, file);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "m_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "199-209",
    "snippet": "static void m_stop(struct seq_file *m, void *v)\n{\n\tstruct proc_maps_private *priv = m->private;\n\n\tif (!IS_ERR_OR_NULL(v))\n\t\tvma_stop(priv);\n\tif (priv->task) {\n\t\tput_task_struct(priv->task);\n\t\tpriv->task = NULL;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "priv->task"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_stop",
          "args": [
            "priv"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "vma_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "117-124",
          "snippet": "static void vma_stop(struct proc_maps_private *priv)\n{\n\tstruct mm_struct *mm = priv->mm;\n\n\trelease_task_mempolicy(priv);\n\tup_read(&mm->mmap_sem);\n\tmmput(mm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void vma_stop(struct proc_maps_private *priv)\n{\n\tstruct mm_struct *mm = priv->mm;\n\n\trelease_task_mempolicy(priv);\n\tup_read(&mm->mmap_sem);\n\tmmput(mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "v"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void m_stop(struct seq_file *m, void *v)\n{\n\tstruct proc_maps_private *priv = m->private;\n\n\tif (!IS_ERR_OR_NULL(v))\n\t\tvma_stop(priv);\n\tif (priv->task) {\n\t\tput_task_struct(priv->task);\n\t\tpriv->task = NULL;\n\t}\n}"
  },
  {
    "function_name": "m_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "187-197",
    "snippet": "static void *m_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct proc_maps_private *priv = m->private;\n\tstruct vm_area_struct *next;\n\n\t(*pos)++;\n\tnext = m_next_vma(priv, v);\n\tif (!next)\n\t\tvma_stop(priv);\n\treturn next;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vma_stop",
          "args": [
            "priv"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "vma_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "117-124",
          "snippet": "static void vma_stop(struct proc_maps_private *priv)\n{\n\tstruct mm_struct *mm = priv->mm;\n\n\trelease_task_mempolicy(priv);\n\tup_read(&mm->mmap_sem);\n\tmmput(mm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void vma_stop(struct proc_maps_private *priv)\n{\n\tstruct mm_struct *mm = priv->mm;\n\n\trelease_task_mempolicy(priv);\n\tup_read(&mm->mmap_sem);\n\tmmput(mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_next_vma",
          "args": [
            "priv",
            "v"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "m_next_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "126-132",
          "snippet": "static struct vm_area_struct *\nm_next_vma(struct proc_maps_private *priv, struct vm_area_struct *vma)\n{\n\tif (vma == priv->tail_vma)\n\t\treturn NULL;\n\treturn vma->vm_next ?: priv->tail_vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic struct vm_area_struct *\nm_next_vma(struct proc_maps_private *priv, struct vm_area_struct *vma)\n{\n\tif (vma == priv->tail_vma)\n\t\treturn NULL;\n\treturn vma->vm_next ?: priv->tail_vma;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void *m_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct proc_maps_private *priv = m->private;\n\tstruct vm_area_struct *next;\n\n\t(*pos)++;\n\tnext = m_next_vma(priv, v);\n\tif (!next)\n\t\tvma_stop(priv);\n\treturn next;\n}"
  },
  {
    "function_name": "m_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "140-185",
    "snippet": "static void *m_start(struct seq_file *m, loff_t *ppos)\n{\n\tstruct proc_maps_private *priv = m->private;\n\tunsigned long last_addr = m->version;\n\tstruct mm_struct *mm;\n\tstruct vm_area_struct *vma;\n\tunsigned int pos = *ppos;\n\n\t/* See m_cache_vma(). Zero at the start or after lseek. */\n\tif (last_addr == -1UL)\n\t\treturn NULL;\n\n\tpriv->task = get_proc_task(priv->inode);\n\tif (!priv->task)\n\t\treturn ERR_PTR(-ESRCH);\n\n\tmm = priv->mm;\n\tif (!mm || !atomic_inc_not_zero(&mm->mm_users))\n\t\treturn NULL;\n\n\tdown_read(&mm->mmap_sem);\n\thold_task_mempolicy(priv);\n\tpriv->tail_vma = get_gate_vma(mm);\n\n\tif (last_addr) {\n\t\tvma = find_vma(mm, last_addr);\n\t\tif (vma && (vma = m_next_vma(priv, vma)))\n\t\t\treturn vma;\n\t}\n\n\tm->version = 0;\n\tif (pos < mm->map_count) {\n\t\tfor (vma = mm->mmap; pos; pos--) {\n\t\t\tm->version = vma->vm_start;\n\t\t\tvma = vma->vm_next;\n\t\t}\n\t\treturn vma;\n\t}\n\n\t/* we do not bother to update m->version in this case */\n\tif (pos == mm->map_count && priv->tail_vma)\n\t\treturn priv->tail_vma;\n\n\tvma_stop(priv);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vma_stop",
          "args": [
            "priv"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "vma_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "117-124",
          "snippet": "static void vma_stop(struct proc_maps_private *priv)\n{\n\tstruct mm_struct *mm = priv->mm;\n\n\trelease_task_mempolicy(priv);\n\tup_read(&mm->mmap_sem);\n\tmmput(mm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void vma_stop(struct proc_maps_private *priv)\n{\n\tstruct mm_struct *mm = priv->mm;\n\n\trelease_task_mempolicy(priv);\n\tup_read(&mm->mmap_sem);\n\tmmput(mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_next_vma",
          "args": [
            "priv",
            "vma"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "m_next_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "126-132",
          "snippet": "static struct vm_area_struct *\nm_next_vma(struct proc_maps_private *priv, struct vm_area_struct *vma)\n{\n\tif (vma == priv->tail_vma)\n\t\treturn NULL;\n\treturn vma->vm_next ?: priv->tail_vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic struct vm_area_struct *\nm_next_vma(struct proc_maps_private *priv, struct vm_area_struct *vma)\n{\n\tif (vma == priv->tail_vma)\n\t\treturn NULL;\n\treturn vma->vm_next ?: priv->tail_vma;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "mm",
            "last_addr"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_gate_vma",
          "args": [
            "mm"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hold_task_mempolicy",
          "args": [
            "priv"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "hold_task_mempolicy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "109-111",
          "snippet": "static void hold_task_mempolicy(struct proc_maps_private *priv)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void hold_task_mempolicy(struct proc_maps_private *priv)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&mm->mm_users"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESRCH"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "priv->inode"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void *m_start(struct seq_file *m, loff_t *ppos)\n{\n\tstruct proc_maps_private *priv = m->private;\n\tunsigned long last_addr = m->version;\n\tstruct mm_struct *mm;\n\tstruct vm_area_struct *vma;\n\tunsigned int pos = *ppos;\n\n\t/* See m_cache_vma(). Zero at the start or after lseek. */\n\tif (last_addr == -1UL)\n\t\treturn NULL;\n\n\tpriv->task = get_proc_task(priv->inode);\n\tif (!priv->task)\n\t\treturn ERR_PTR(-ESRCH);\n\n\tmm = priv->mm;\n\tif (!mm || !atomic_inc_not_zero(&mm->mm_users))\n\t\treturn NULL;\n\n\tdown_read(&mm->mmap_sem);\n\thold_task_mempolicy(priv);\n\tpriv->tail_vma = get_gate_vma(mm);\n\n\tif (last_addr) {\n\t\tvma = find_vma(mm, last_addr);\n\t\tif (vma && (vma = m_next_vma(priv, vma)))\n\t\t\treturn vma;\n\t}\n\n\tm->version = 0;\n\tif (pos < mm->map_count) {\n\t\tfor (vma = mm->mmap; pos; pos--) {\n\t\t\tm->version = vma->vm_start;\n\t\t\tvma = vma->vm_next;\n\t\t}\n\t\treturn vma;\n\t}\n\n\t/* we do not bother to update m->version in this case */\n\tif (pos == mm->map_count && priv->tail_vma)\n\t\treturn priv->tail_vma;\n\n\tvma_stop(priv);\n\treturn NULL;\n}"
  },
  {
    "function_name": "m_cache_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "134-138",
    "snippet": "static void m_cache_vma(struct seq_file *m, struct vm_area_struct *vma)\n{\n\tif (m->count < m->size)\t/* vma is copied successfully */\n\t\tm->version = m_next_vma(m->private, vma) ? vma->vm_start : -1UL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_next_vma",
          "args": [
            "m->private",
            "vma"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "m_next_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "126-132",
          "snippet": "static struct vm_area_struct *\nm_next_vma(struct proc_maps_private *priv, struct vm_area_struct *vma)\n{\n\tif (vma == priv->tail_vma)\n\t\treturn NULL;\n\treturn vma->vm_next ?: priv->tail_vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic struct vm_area_struct *\nm_next_vma(struct proc_maps_private *priv, struct vm_area_struct *vma)\n{\n\tif (vma == priv->tail_vma)\n\t\treturn NULL;\n\treturn vma->vm_next ?: priv->tail_vma;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void m_cache_vma(struct seq_file *m, struct vm_area_struct *vma)\n{\n\tif (m->count < m->size)\t/* vma is copied successfully */\n\t\tm->version = m_next_vma(m->private, vma) ? vma->vm_start : -1UL;\n}"
  },
  {
    "function_name": "m_next_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "126-132",
    "snippet": "static struct vm_area_struct *\nm_next_vma(struct proc_maps_private *priv, struct vm_area_struct *vma)\n{\n\tif (vma == priv->tail_vma)\n\t\treturn NULL;\n\treturn vma->vm_next ?: priv->tail_vma;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic struct vm_area_struct *\nm_next_vma(struct proc_maps_private *priv, struct vm_area_struct *vma)\n{\n\tif (vma == priv->tail_vma)\n\t\treturn NULL;\n\treturn vma->vm_next ?: priv->tail_vma;\n}"
  },
  {
    "function_name": "vma_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "117-124",
    "snippet": "static void vma_stop(struct proc_maps_private *priv)\n{\n\tstruct mm_struct *mm = priv->mm;\n\n\trelease_task_mempolicy(priv);\n\tup_read(&mm->mmap_sem);\n\tmmput(mm);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_task_mempolicy",
          "args": [
            "priv"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "release_task_mempolicy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "112-114",
          "snippet": "static void release_task_mempolicy(struct proc_maps_private *priv)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void release_task_mempolicy(struct proc_maps_private *priv)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void vma_stop(struct proc_maps_private *priv)\n{\n\tstruct mm_struct *mm = priv->mm;\n\n\trelease_task_mempolicy(priv);\n\tup_read(&mm->mmap_sem);\n\tmmput(mm);\n}"
  },
  {
    "function_name": "release_task_mempolicy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "112-114",
    "snippet": "static void release_task_mempolicy(struct proc_maps_private *priv)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void release_task_mempolicy(struct proc_maps_private *priv)\n{\n}"
  },
  {
    "function_name": "hold_task_mempolicy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "109-111",
    "snippet": "static void hold_task_mempolicy(struct proc_maps_private *priv)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void hold_task_mempolicy(struct proc_maps_private *priv)\n{\n}"
  },
  {
    "function_name": "release_task_mempolicy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "104-107",
    "snippet": "static void release_task_mempolicy(struct proc_maps_private *priv)\n{\n\tmpol_put(priv->task_mempolicy);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpol_put",
          "args": [
            "priv->task_mempolicy"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void release_task_mempolicy(struct proc_maps_private *priv)\n{\n\tmpol_put(priv->task_mempolicy);\n}"
  },
  {
    "function_name": "hold_task_mempolicy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "95-103",
    "snippet": "static void hold_task_mempolicy(struct proc_maps_private *priv)\n{\n\tstruct task_struct *task = priv->task;\n\n\ttask_lock(task);\n\tpriv->task_mempolicy = get_task_policy(task);\n\tmpol_get(priv->task_mempolicy);\n\ttask_unlock(task);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "task"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_get",
          "args": [
            "priv->task_mempolicy"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_policy",
          "args": [
            "task"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "task"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void hold_task_mempolicy(struct proc_maps_private *priv)\n{\n\tstruct task_struct *task = priv->task;\n\n\ttask_lock(task);\n\tpriv->task_mempolicy = get_task_policy(task);\n\tmpol_get(priv->task_mempolicy);\n\ttask_unlock(task);\n}"
  },
  {
    "function_name": "task_statm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "79-89",
    "snippet": "unsigned long task_statm(struct mm_struct *mm,\n\t\t\t unsigned long *shared, unsigned long *text,\n\t\t\t unsigned long *data, unsigned long *resident)\n{\n\t*shared = get_mm_counter(mm, MM_FILEPAGES);\n\t*text = (PAGE_ALIGN(mm->end_code) - (mm->start_code & PAGE_MASK))\n\t\t\t\t\t\t\t\t>> PAGE_SHIFT;\n\t*data = mm->total_vm - mm->shared_vm;\n\t*resident = *shared + get_mm_counter(mm, MM_ANONPAGES);\n\treturn mm->total_vm;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_mm_counter",
          "args": [
            "mm",
            "MM_ANONPAGES"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "mm->end_code"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mm_counter",
          "args": [
            "mm",
            "MM_FILEPAGES"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nunsigned long task_statm(struct mm_struct *mm,\n\t\t\t unsigned long *shared, unsigned long *text,\n\t\t\t unsigned long *data, unsigned long *resident)\n{\n\t*shared = get_mm_counter(mm, MM_FILEPAGES);\n\t*text = (PAGE_ALIGN(mm->end_code) - (mm->start_code & PAGE_MASK))\n\t\t\t\t\t\t\t\t>> PAGE_SHIFT;\n\t*data = mm->total_vm - mm->shared_vm;\n\t*resident = *shared + get_mm_counter(mm, MM_ANONPAGES);\n\treturn mm->total_vm;\n}"
  },
  {
    "function_name": "task_vsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "74-77",
    "snippet": "unsigned long task_vsize(struct mm_struct *mm)\n{\n\treturn PAGE_SIZE * mm->total_vm;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nunsigned long task_vsize(struct mm_struct *mm)\n{\n\treturn PAGE_SIZE * mm->total_vm;\n}"
  },
  {
    "function_name": "task_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
    "lines": "22-72",
    "snippet": "void task_mem(struct seq_file *m, struct mm_struct *mm)\n{\n\tunsigned long data, text, lib, swap, ptes, pmds;\n\tunsigned long hiwater_vm, total_vm, hiwater_rss, total_rss;\n\n\t/*\n\t * Note: to minimize their overhead, mm maintains hiwater_vm and\n\t * hiwater_rss only when about to *lower* total_vm or rss.  Any\n\t * collector of these hiwater stats must therefore get total_vm\n\t * and rss too, which will usually be the higher.  Barriers? not\n\t * worth the effort, such snapshots can always be inconsistent.\n\t */\n\thiwater_vm = total_vm = mm->total_vm;\n\tif (hiwater_vm < mm->hiwater_vm)\n\t\thiwater_vm = mm->hiwater_vm;\n\thiwater_rss = total_rss = get_mm_rss(mm);\n\tif (hiwater_rss < mm->hiwater_rss)\n\t\thiwater_rss = mm->hiwater_rss;\n\n\tdata = mm->total_vm - mm->shared_vm - mm->stack_vm;\n\ttext = (PAGE_ALIGN(mm->end_code) - (mm->start_code & PAGE_MASK)) >> 10;\n\tlib = (mm->exec_vm << (PAGE_SHIFT-10)) - text;\n\tswap = get_mm_counter(mm, MM_SWAPENTS);\n\tptes = PTRS_PER_PTE * sizeof(pte_t) * atomic_long_read(&mm->nr_ptes);\n\tpmds = PTRS_PER_PMD * sizeof(pmd_t) * mm_nr_pmds(mm);\n\tseq_printf(m,\n\t\t\"VmPeak:\\t%8lu kB\\n\"\n\t\t\"VmSize:\\t%8lu kB\\n\"\n\t\t\"VmLck:\\t%8lu kB\\n\"\n\t\t\"VmPin:\\t%8lu kB\\n\"\n\t\t\"VmHWM:\\t%8lu kB\\n\"\n\t\t\"VmRSS:\\t%8lu kB\\n\"\n\t\t\"VmData:\\t%8lu kB\\n\"\n\t\t\"VmStk:\\t%8lu kB\\n\"\n\t\t\"VmExe:\\t%8lu kB\\n\"\n\t\t\"VmLib:\\t%8lu kB\\n\"\n\t\t\"VmPTE:\\t%8lu kB\\n\"\n\t\t\"VmPMD:\\t%8lu kB\\n\"\n\t\t\"VmSwap:\\t%8lu kB\\n\",\n\t\thiwater_vm << (PAGE_SHIFT-10),\n\t\ttotal_vm << (PAGE_SHIFT-10),\n\t\tmm->locked_vm << (PAGE_SHIFT-10),\n\t\tmm->pinned_vm << (PAGE_SHIFT-10),\n\t\thiwater_rss << (PAGE_SHIFT-10),\n\t\ttotal_rss << (PAGE_SHIFT-10),\n\t\tdata << (PAGE_SHIFT-10),\n\t\tmm->stack_vm << (PAGE_SHIFT-10), text, lib,\n\t\tptes >> 10,\n\t\tpmds >> 10,\n\t\tswap << (PAGE_SHIFT-10));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/elf.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"VmPeak:\\t%8lu kB\\n\"\n\t\t\"VmSize:\\t%8lu kB\\n\"\n\t\t\"VmLck:\\t%8lu kB\\n\"\n\t\t\"VmPin:\\t%8lu kB\\n\"\n\t\t\"VmHWM:\\t%8lu kB\\n\"\n\t\t\"VmRSS:\\t%8lu kB\\n\"\n\t\t\"VmData:\\t%8lu kB\\n\"\n\t\t\"VmStk:\\t%8lu kB\\n\"\n\t\t\"VmExe:\\t%8lu kB\\n\"\n\t\t\"VmLib:\\t%8lu kB\\n\"\n\t\t\"VmPTE:\\t%8lu kB\\n\"\n\t\t\"VmPMD:\\t%8lu kB\\n\"\n\t\t\"VmSwap:\\t%8lu kB\\n\"",
            "hiwater_vm << (PAGE_SHIFT-10)",
            "total_vm << (PAGE_SHIFT-10)",
            "mm->locked_vm << (PAGE_SHIFT-10)",
            "mm->pinned_vm << (PAGE_SHIFT-10)",
            "hiwater_rss << (PAGE_SHIFT-10)",
            "total_rss << (PAGE_SHIFT-10)",
            "data << (PAGE_SHIFT-10)",
            "mm->stack_vm << (PAGE_SHIFT-10)",
            "text",
            "lib",
            "ptes >> 10",
            "pmds >> 10",
            "swap << (PAGE_SHIFT-10)"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_nr_pmds",
          "args": [
            "mm"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&mm->nr_ptes"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mm_counter",
          "args": [
            "mm",
            "MM_SWAPENTS"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "mm->end_code"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mm_rss",
          "args": [
            "mm"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nvoid task_mem(struct seq_file *m, struct mm_struct *mm)\n{\n\tunsigned long data, text, lib, swap, ptes, pmds;\n\tunsigned long hiwater_vm, total_vm, hiwater_rss, total_rss;\n\n\t/*\n\t * Note: to minimize their overhead, mm maintains hiwater_vm and\n\t * hiwater_rss only when about to *lower* total_vm or rss.  Any\n\t * collector of these hiwater stats must therefore get total_vm\n\t * and rss too, which will usually be the higher.  Barriers? not\n\t * worth the effort, such snapshots can always be inconsistent.\n\t */\n\thiwater_vm = total_vm = mm->total_vm;\n\tif (hiwater_vm < mm->hiwater_vm)\n\t\thiwater_vm = mm->hiwater_vm;\n\thiwater_rss = total_rss = get_mm_rss(mm);\n\tif (hiwater_rss < mm->hiwater_rss)\n\t\thiwater_rss = mm->hiwater_rss;\n\n\tdata = mm->total_vm - mm->shared_vm - mm->stack_vm;\n\ttext = (PAGE_ALIGN(mm->end_code) - (mm->start_code & PAGE_MASK)) >> 10;\n\tlib = (mm->exec_vm << (PAGE_SHIFT-10)) - text;\n\tswap = get_mm_counter(mm, MM_SWAPENTS);\n\tptes = PTRS_PER_PTE * sizeof(pte_t) * atomic_long_read(&mm->nr_ptes);\n\tpmds = PTRS_PER_PMD * sizeof(pmd_t) * mm_nr_pmds(mm);\n\tseq_printf(m,\n\t\t\"VmPeak:\\t%8lu kB\\n\"\n\t\t\"VmSize:\\t%8lu kB\\n\"\n\t\t\"VmLck:\\t%8lu kB\\n\"\n\t\t\"VmPin:\\t%8lu kB\\n\"\n\t\t\"VmHWM:\\t%8lu kB\\n\"\n\t\t\"VmRSS:\\t%8lu kB\\n\"\n\t\t\"VmData:\\t%8lu kB\\n\"\n\t\t\"VmStk:\\t%8lu kB\\n\"\n\t\t\"VmExe:\\t%8lu kB\\n\"\n\t\t\"VmLib:\\t%8lu kB\\n\"\n\t\t\"VmPTE:\\t%8lu kB\\n\"\n\t\t\"VmPMD:\\t%8lu kB\\n\"\n\t\t\"VmSwap:\\t%8lu kB\\n\",\n\t\thiwater_vm << (PAGE_SHIFT-10),\n\t\ttotal_vm << (PAGE_SHIFT-10),\n\t\tmm->locked_vm << (PAGE_SHIFT-10),\n\t\tmm->pinned_vm << (PAGE_SHIFT-10),\n\t\thiwater_rss << (PAGE_SHIFT-10),\n\t\ttotal_rss << (PAGE_SHIFT-10),\n\t\tdata << (PAGE_SHIFT-10),\n\t\tmm->stack_vm << (PAGE_SHIFT-10), text, lib,\n\t\tptes >> 10,\n\t\tpmds >> 10,\n\t\tswap << (PAGE_SHIFT-10));\n}"
  }
]