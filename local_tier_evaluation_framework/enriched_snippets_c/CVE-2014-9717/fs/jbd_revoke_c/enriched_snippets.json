[
  {
    "function_name": "journal_clear_revoke",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
    "lines": "716-733",
    "snippet": "void journal_clear_revoke(journal_t *journal)\n{\n\tint i;\n\tstruct list_head *hash_list;\n\tstruct jbd_revoke_record_s *record;\n\tstruct jbd_revoke_table_s *revoke;\n\n\trevoke = journal->j_revoke;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\thash_list = &revoke->hash_table[i];\n\t\twhile (!list_empty(hash_list)) {\n\t\t\trecord = (struct jbd_revoke_record_s*) hash_list->next;\n\t\t\tlist_del(&record->hash);\n\t\t\tkmem_cache_free(revoke_record_cache, record);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *revoke_record_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "revoke_record_cache",
            "record"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&record->hash"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "hash_list"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *revoke_record_cache;\n\nvoid journal_clear_revoke(journal_t *journal)\n{\n\tint i;\n\tstruct list_head *hash_list;\n\tstruct jbd_revoke_record_s *record;\n\tstruct jbd_revoke_table_s *revoke;\n\n\trevoke = journal->j_revoke;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\thash_list = &revoke->hash_table[i];\n\t\twhile (!list_empty(hash_list)) {\n\t\t\trecord = (struct jbd_revoke_record_s*) hash_list->next;\n\t\t\tlist_del(&record->hash);\n\t\t\tkmem_cache_free(revoke_record_cache, record);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "journal_test_revoke",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
    "lines": "697-709",
    "snippet": "int journal_test_revoke(journal_t *journal,\n\t\t\tunsigned int blocknr,\n\t\t\ttid_t sequence)\n{\n\tstruct jbd_revoke_record_s *record;\n\n\trecord = find_revoke_record(journal, blocknr);\n\tif (!record)\n\t\treturn 0;\n\tif (tid_gt(sequence, record->sequence))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tid_gt",
          "args": [
            "sequence",
            "record->sequence"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_revoke_record",
          "args": [
            "journal",
            "blocknr"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "find_revoke_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "169-188",
          "snippet": "static struct jbd_revoke_record_s *find_revoke_record(journal_t *journal,\n\t\t\t\t\t\t      unsigned int blocknr)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd_revoke_record_s *record;\n\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\n\tspin_lock(&journal->j_revoke_lock);\n\trecord = (struct jbd_revoke_record_s *) hash_list->next;\n\twhile (&(record->hash) != hash_list) {\n\t\tif (record->blocknr == blocknr) {\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\treturn record;\n\t\t}\n\t\trecord = (struct jbd_revoke_record_s *) record->hash.next;\n\t}\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct jbd_revoke_record_s *find_revoke_record(journal_t *journal,\n\t\t\t\t\t\t      unsigned int blocknr)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd_revoke_record_s *record;\n\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\n\tspin_lock(&journal->j_revoke_lock);\n\trecord = (struct jbd_revoke_record_s *) hash_list->next;\n\twhile (&(record->hash) != hash_list) {\n\t\tif (record->blocknr == blocknr) {\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\treturn record;\n\t\t}\n\t\trecord = (struct jbd_revoke_record_s *) record->hash.next;\n\t}\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nint journal_test_revoke(journal_t *journal,\n\t\t\tunsigned int blocknr,\n\t\t\ttid_t sequence)\n{\n\tstruct jbd_revoke_record_s *record;\n\n\trecord = find_revoke_record(journal, blocknr);\n\tif (!record)\n\t\treturn 0;\n\tif (tid_gt(sequence, record->sequence))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "journal_set_revoke",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
    "lines": "673-688",
    "snippet": "int journal_set_revoke(journal_t *journal,\n\t\t       unsigned int blocknr,\n\t\t       tid_t sequence)\n{\n\tstruct jbd_revoke_record_s *record;\n\n\trecord = find_revoke_record(journal, blocknr);\n\tif (record) {\n\t\t/* If we have multiple occurrences, only record the\n\t\t * latest sequence number in the hashed record */\n\t\tif (tid_gt(sequence, record->sequence))\n\t\t\trecord->sequence = sequence;\n\t\treturn 0;\n\t}\n\treturn insert_revoke_hash(journal, blocknr, sequence);\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert_revoke_hash",
          "args": [
            "journal",
            "blocknr",
            "sequence"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "insert_revoke_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "140-165",
          "snippet": "static int insert_revoke_hash(journal_t *journal, unsigned int blocknr,\n\t\t\t      tid_t seq)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd_revoke_record_s *record;\n\nrepeat:\n\trecord = kmem_cache_alloc(revoke_record_cache, GFP_NOFS);\n\tif (!record)\n\t\tgoto oom;\n\n\trecord->sequence = seq;\n\trecord->blocknr = blocknr;\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\tspin_lock(&journal->j_revoke_lock);\n\tlist_add(&record->hash, hash_list);\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn 0;\n\noom:\n\tif (!journal_oom_retry)\n\t\treturn -ENOMEM;\n\tjbd_debug(1, \"ENOMEM in %s, retrying\\n\", __func__);\n\tyield();\n\tgoto repeat;\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *revoke_record_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *revoke_record_cache;\n\nstatic int insert_revoke_hash(journal_t *journal, unsigned int blocknr,\n\t\t\t      tid_t seq)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd_revoke_record_s *record;\n\nrepeat:\n\trecord = kmem_cache_alloc(revoke_record_cache, GFP_NOFS);\n\tif (!record)\n\t\tgoto oom;\n\n\trecord->sequence = seq;\n\trecord->blocknr = blocknr;\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\tspin_lock(&journal->j_revoke_lock);\n\tlist_add(&record->hash, hash_list);\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn 0;\n\noom:\n\tif (!journal_oom_retry)\n\t\treturn -ENOMEM;\n\tjbd_debug(1, \"ENOMEM in %s, retrying\\n\", __func__);\n\tyield();\n\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tid_gt",
          "args": [
            "sequence",
            "record->sequence"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_revoke_record",
          "args": [
            "journal",
            "blocknr"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "find_revoke_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "169-188",
          "snippet": "static struct jbd_revoke_record_s *find_revoke_record(journal_t *journal,\n\t\t\t\t\t\t      unsigned int blocknr)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd_revoke_record_s *record;\n\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\n\tspin_lock(&journal->j_revoke_lock);\n\trecord = (struct jbd_revoke_record_s *) hash_list->next;\n\twhile (&(record->hash) != hash_list) {\n\t\tif (record->blocknr == blocknr) {\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\treturn record;\n\t\t}\n\t\trecord = (struct jbd_revoke_record_s *) record->hash.next;\n\t}\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct jbd_revoke_record_s *find_revoke_record(journal_t *journal,\n\t\t\t\t\t\t      unsigned int blocknr)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd_revoke_record_s *record;\n\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\n\tspin_lock(&journal->j_revoke_lock);\n\trecord = (struct jbd_revoke_record_s *) hash_list->next;\n\twhile (&(record->hash) != hash_list) {\n\t\tif (record->blocknr == blocknr) {\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\treturn record;\n\t\t}\n\t\trecord = (struct jbd_revoke_record_s *) record->hash.next;\n\t}\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nint journal_set_revoke(journal_t *journal,\n\t\t       unsigned int blocknr,\n\t\t       tid_t sequence)\n{\n\tstruct jbd_revoke_record_s *record;\n\n\trecord = find_revoke_record(journal, blocknr);\n\tif (record) {\n\t\t/* If we have multiple occurrences, only record the\n\t\t * latest sequence number in the hashed record */\n\t\tif (tid_gt(sequence, record->sequence))\n\t\t\trecord->sequence = sequence;\n\t\treturn 0;\n\t}\n\treturn insert_revoke_hash(journal, blocknr, sequence);\n}"
  },
  {
    "function_name": "flush_descriptor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
    "lines": "630-648",
    "snippet": "static void flush_descriptor(journal_t *journal,\n\t\t\t     struct journal_head *descriptor,\n\t\t\t     int offset, int write_op)\n{\n\tjournal_revoke_header_t *header;\n\tstruct buffer_head *bh = jh2bh(descriptor);\n\n\tif (is_journal_aborted(journal)) {\n\t\tput_bh(bh);\n\t\treturn;\n\t}\n\n\theader = (journal_revoke_header_t *) jh2bh(descriptor)->b_data;\n\theader->r_count = cpu_to_be32(offset);\n\tset_buffer_jwrite(bh);\n\tBUFFER_TRACE(bh, \"write\");\n\tset_buffer_dirty(bh);\n\twrite_dirty_buffer(bh, write_op);\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_dirty_buffer",
          "args": [
            "bh",
            "write_op"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "write_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3115-3125",
          "snippet": "void write_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tlock_buffer(bh);\n\tif (!test_clear_buffer_dirty(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn;\n\t}\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(rw, bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid write_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tlock_buffer(bh);\n\tif (!test_clear_buffer_dirty(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn;\n\t}\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(rw, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"write\""
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_jwrite",
          "args": [
            "bh"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "offset"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "descriptor"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "descriptor"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic void flush_descriptor(journal_t *journal,\n\t\t\t     struct journal_head *descriptor,\n\t\t\t     int offset, int write_op)\n{\n\tjournal_revoke_header_t *header;\n\tstruct buffer_head *bh = jh2bh(descriptor);\n\n\tif (is_journal_aborted(journal)) {\n\t\tput_bh(bh);\n\t\treturn;\n\t}\n\n\theader = (journal_revoke_header_t *) jh2bh(descriptor)->b_data;\n\theader->r_count = cpu_to_be32(offset);\n\tset_buffer_jwrite(bh);\n\tBUFFER_TRACE(bh, \"write\");\n\tset_buffer_dirty(bh);\n\twrite_dirty_buffer(bh, write_op);\n}"
  },
  {
    "function_name": "write_one_revoke_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
    "lines": "571-621",
    "snippet": "static void write_one_revoke_record(journal_t *journal,\n\t\t\t\t    transaction_t *transaction,\n\t\t\t\t    struct journal_head **descriptorp,\n\t\t\t\t    int *offsetp,\n\t\t\t\t    struct jbd_revoke_record_s *record,\n\t\t\t\t    int write_op)\n{\n\tstruct journal_head *descriptor;\n\tint offset;\n\tjournal_header_t *header;\n\n\t/* If we are already aborting, this all becomes a noop.  We\n           still need to go round the loop in\n           journal_write_revoke_records in order to free all of the\n           revoke records: only the IO to the journal is omitted. */\n\tif (is_journal_aborted(journal))\n\t\treturn;\n\n\tdescriptor = *descriptorp;\n\toffset = *offsetp;\n\n\t/* Make sure we have a descriptor with space left for the record */\n\tif (descriptor) {\n\t\tif (offset == journal->j_blocksize) {\n\t\t\tflush_descriptor(journal, descriptor, offset, write_op);\n\t\t\tdescriptor = NULL;\n\t\t}\n\t}\n\n\tif (!descriptor) {\n\t\tdescriptor = journal_get_descriptor_buffer(journal);\n\t\tif (!descriptor)\n\t\t\treturn;\n\t\theader = (journal_header_t *) &jh2bh(descriptor)->b_data[0];\n\t\theader->h_magic     = cpu_to_be32(JFS_MAGIC_NUMBER);\n\t\theader->h_blocktype = cpu_to_be32(JFS_REVOKE_BLOCK);\n\t\theader->h_sequence  = cpu_to_be32(transaction->t_tid);\n\n\t\t/* Record it so that we can wait for IO completion later */\n\t\tJBUFFER_TRACE(descriptor, \"file as BJ_LogCtl\");\n\t\tjournal_file_buffer(descriptor, transaction, BJ_LogCtl);\n\n\t\toffset = sizeof(journal_revoke_header_t);\n\t\t*descriptorp = descriptor;\n\t}\n\n\t* ((__be32 *)(&jh2bh(descriptor)->b_data[offset])) =\n\t\tcpu_to_be32(record->blocknr);\n\toffset += 4;\n\t*offsetp = offset;\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "record->blocknr"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "descriptor"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_file_buffer",
          "args": [
            "descriptor",
            "transaction",
            "BJ_LogCtl"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "journal_file_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "2156-2164",
          "snippet": "void journal_file_buffer(struct journal_head *jh,\n\t\t\t\ttransaction_t *transaction, int jlist)\n{\n\tjbd_lock_bh_state(jh2bh(jh));\n\tspin_lock(&transaction->t_journal->j_list_lock);\n\t__journal_file_buffer(jh, transaction, jlist);\n\tspin_unlock(&transaction->t_journal->j_list_lock);\n\tjbd_unlock_bh_state(jh2bh(jh));\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nvoid journal_file_buffer(struct journal_head *jh,\n\t\t\t\ttransaction_t *transaction, int jlist)\n{\n\tjbd_lock_bh_state(jh2bh(jh));\n\tspin_lock(&transaction->t_journal->j_list_lock);\n\t__journal_file_buffer(jh, transaction, jlist);\n\tspin_unlock(&transaction->t_journal->j_list_lock);\n\tjbd_unlock_bh_state(jh2bh(jh));\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "descriptor",
            "\"file as BJ_LogCtl\""
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "transaction->t_tid"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JFS_REVOKE_BLOCK"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JFS_MAGIC_NUMBER"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "descriptor"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_get_descriptor_buffer",
          "args": [
            "journal"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "journal_get_descriptor_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "708-728",
          "snippet": "struct journal_head *journal_get_descriptor_buffer(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tunsigned int blocknr;\n\tint err;\n\n\terr = journal_next_log_block(journal, &blocknr);\n\n\tif (err)\n\t\treturn NULL;\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn NULL;\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, journal->j_blocksize);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\tBUFFER_TRACE(bh, \"return this buffer\");\n\treturn journal_add_journal_head(bh);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *journal_dev_name(journal_t *journal, char *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic const char *journal_dev_name(journal_t *journal, char *buffer);\n\nstruct journal_head *journal_get_descriptor_buffer(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tunsigned int blocknr;\n\tint err;\n\n\terr = journal_next_log_block(journal, &blocknr);\n\n\tif (err)\n\t\treturn NULL;\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn NULL;\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, journal->j_blocksize);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\tBUFFER_TRACE(bh, \"return this buffer\");\n\treturn journal_add_journal_head(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_descriptor",
          "args": [
            "journal",
            "descriptor",
            "offset",
            "write_op"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "flush_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "630-648",
          "snippet": "static void flush_descriptor(journal_t *journal,\n\t\t\t     struct journal_head *descriptor,\n\t\t\t     int offset, int write_op)\n{\n\tjournal_revoke_header_t *header;\n\tstruct buffer_head *bh = jh2bh(descriptor);\n\n\tif (is_journal_aborted(journal)) {\n\t\tput_bh(bh);\n\t\treturn;\n\t}\n\n\theader = (journal_revoke_header_t *) jh2bh(descriptor)->b_data;\n\theader->r_count = cpu_to_be32(offset);\n\tset_buffer_jwrite(bh);\n\tBUFFER_TRACE(bh, \"write\");\n\tset_buffer_dirty(bh);\n\twrite_dirty_buffer(bh, write_op);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic void flush_descriptor(journal_t *journal,\n\t\t\t     struct journal_head *descriptor,\n\t\t\t     int offset, int write_op)\n{\n\tjournal_revoke_header_t *header;\n\tstruct buffer_head *bh = jh2bh(descriptor);\n\n\tif (is_journal_aborted(journal)) {\n\t\tput_bh(bh);\n\t\treturn;\n\t}\n\n\theader = (journal_revoke_header_t *) jh2bh(descriptor)->b_data;\n\theader->r_count = cpu_to_be32(offset);\n\tset_buffer_jwrite(bh);\n\tBUFFER_TRACE(bh, \"write\");\n\tset_buffer_dirty(bh);\n\twrite_dirty_buffer(bh, write_op);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic void write_one_revoke_record(journal_t *journal,\n\t\t\t\t    transaction_t *transaction,\n\t\t\t\t    struct journal_head **descriptorp,\n\t\t\t\t    int *offsetp,\n\t\t\t\t    struct jbd_revoke_record_s *record,\n\t\t\t\t    int write_op)\n{\n\tstruct journal_head *descriptor;\n\tint offset;\n\tjournal_header_t *header;\n\n\t/* If we are already aborting, this all becomes a noop.  We\n           still need to go round the loop in\n           journal_write_revoke_records in order to free all of the\n           revoke records: only the IO to the journal is omitted. */\n\tif (is_journal_aborted(journal))\n\t\treturn;\n\n\tdescriptor = *descriptorp;\n\toffset = *offsetp;\n\n\t/* Make sure we have a descriptor with space left for the record */\n\tif (descriptor) {\n\t\tif (offset == journal->j_blocksize) {\n\t\t\tflush_descriptor(journal, descriptor, offset, write_op);\n\t\t\tdescriptor = NULL;\n\t\t}\n\t}\n\n\tif (!descriptor) {\n\t\tdescriptor = journal_get_descriptor_buffer(journal);\n\t\tif (!descriptor)\n\t\t\treturn;\n\t\theader = (journal_header_t *) &jh2bh(descriptor)->b_data[0];\n\t\theader->h_magic     = cpu_to_be32(JFS_MAGIC_NUMBER);\n\t\theader->h_blocktype = cpu_to_be32(JFS_REVOKE_BLOCK);\n\t\theader->h_sequence  = cpu_to_be32(transaction->t_tid);\n\n\t\t/* Record it so that we can wait for IO completion later */\n\t\tJBUFFER_TRACE(descriptor, \"file as BJ_LogCtl\");\n\t\tjournal_file_buffer(descriptor, transaction, BJ_LogCtl);\n\n\t\toffset = sizeof(journal_revoke_header_t);\n\t\t*descriptorp = descriptor;\n\t}\n\n\t* ((__be32 *)(&jh2bh(descriptor)->b_data[offset])) =\n\t\tcpu_to_be32(record->blocknr);\n\toffset += 4;\n\t*offsetp = offset;\n}"
  },
  {
    "function_name": "journal_write_revoke_records",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
    "lines": "530-564",
    "snippet": "void journal_write_revoke_records(journal_t *journal,\n\t\t\t\t  transaction_t *transaction, int write_op)\n{\n\tstruct journal_head *descriptor;\n\tstruct jbd_revoke_record_s *record;\n\tstruct jbd_revoke_table_s *revoke;\n\tstruct list_head *hash_list;\n\tint i, offset, count;\n\n\tdescriptor = NULL;\n\toffset = 0;\n\tcount = 0;\n\n\t/* select revoke table for committing transaction */\n\trevoke = journal->j_revoke == journal->j_revoke_table[0] ?\n\t\tjournal->j_revoke_table[1] : journal->j_revoke_table[0];\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\thash_list = &revoke->hash_table[i];\n\n\t\twhile (!list_empty(hash_list)) {\n\t\t\trecord = (struct jbd_revoke_record_s *)\n\t\t\t\thash_list->next;\n\t\t\twrite_one_revoke_record(journal, transaction,\n\t\t\t\t\t\t&descriptor, &offset,\n\t\t\t\t\t\trecord, write_op);\n\t\t\tcount++;\n\t\t\tlist_del(&record->hash);\n\t\t\tkmem_cache_free(revoke_record_cache, record);\n\t\t}\n\t}\n\tif (descriptor)\n\t\tflush_descriptor(journal, descriptor, offset, write_op);\n\tjbd_debug(1, \"Wrote %d revoke records\\n\", count);\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *revoke_record_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"Wrote %d revoke records\\n\"",
            "count"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_descriptor",
          "args": [
            "journal",
            "descriptor",
            "offset",
            "write_op"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "flush_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "630-648",
          "snippet": "static void flush_descriptor(journal_t *journal,\n\t\t\t     struct journal_head *descriptor,\n\t\t\t     int offset, int write_op)\n{\n\tjournal_revoke_header_t *header;\n\tstruct buffer_head *bh = jh2bh(descriptor);\n\n\tif (is_journal_aborted(journal)) {\n\t\tput_bh(bh);\n\t\treturn;\n\t}\n\n\theader = (journal_revoke_header_t *) jh2bh(descriptor)->b_data;\n\theader->r_count = cpu_to_be32(offset);\n\tset_buffer_jwrite(bh);\n\tBUFFER_TRACE(bh, \"write\");\n\tset_buffer_dirty(bh);\n\twrite_dirty_buffer(bh, write_op);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic void flush_descriptor(journal_t *journal,\n\t\t\t     struct journal_head *descriptor,\n\t\t\t     int offset, int write_op)\n{\n\tjournal_revoke_header_t *header;\n\tstruct buffer_head *bh = jh2bh(descriptor);\n\n\tif (is_journal_aborted(journal)) {\n\t\tput_bh(bh);\n\t\treturn;\n\t}\n\n\theader = (journal_revoke_header_t *) jh2bh(descriptor)->b_data;\n\theader->r_count = cpu_to_be32(offset);\n\tset_buffer_jwrite(bh);\n\tBUFFER_TRACE(bh, \"write\");\n\tset_buffer_dirty(bh);\n\twrite_dirty_buffer(bh, write_op);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "revoke_record_cache",
            "record"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&record->hash"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_one_revoke_record",
          "args": [
            "journal",
            "transaction",
            "&descriptor",
            "&offset",
            "record",
            "write_op"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "write_one_revoke_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "571-621",
          "snippet": "static void write_one_revoke_record(journal_t *journal,\n\t\t\t\t    transaction_t *transaction,\n\t\t\t\t    struct journal_head **descriptorp,\n\t\t\t\t    int *offsetp,\n\t\t\t\t    struct jbd_revoke_record_s *record,\n\t\t\t\t    int write_op)\n{\n\tstruct journal_head *descriptor;\n\tint offset;\n\tjournal_header_t *header;\n\n\t/* If we are already aborting, this all becomes a noop.  We\n           still need to go round the loop in\n           journal_write_revoke_records in order to free all of the\n           revoke records: only the IO to the journal is omitted. */\n\tif (is_journal_aborted(journal))\n\t\treturn;\n\n\tdescriptor = *descriptorp;\n\toffset = *offsetp;\n\n\t/* Make sure we have a descriptor with space left for the record */\n\tif (descriptor) {\n\t\tif (offset == journal->j_blocksize) {\n\t\t\tflush_descriptor(journal, descriptor, offset, write_op);\n\t\t\tdescriptor = NULL;\n\t\t}\n\t}\n\n\tif (!descriptor) {\n\t\tdescriptor = journal_get_descriptor_buffer(journal);\n\t\tif (!descriptor)\n\t\t\treturn;\n\t\theader = (journal_header_t *) &jh2bh(descriptor)->b_data[0];\n\t\theader->h_magic     = cpu_to_be32(JFS_MAGIC_NUMBER);\n\t\theader->h_blocktype = cpu_to_be32(JFS_REVOKE_BLOCK);\n\t\theader->h_sequence  = cpu_to_be32(transaction->t_tid);\n\n\t\t/* Record it so that we can wait for IO completion later */\n\t\tJBUFFER_TRACE(descriptor, \"file as BJ_LogCtl\");\n\t\tjournal_file_buffer(descriptor, transaction, BJ_LogCtl);\n\n\t\toffset = sizeof(journal_revoke_header_t);\n\t\t*descriptorp = descriptor;\n\t}\n\n\t* ((__be32 *)(&jh2bh(descriptor)->b_data[offset])) =\n\t\tcpu_to_be32(record->blocknr);\n\toffset += 4;\n\t*offsetp = offset;\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic void write_one_revoke_record(journal_t *journal,\n\t\t\t\t    transaction_t *transaction,\n\t\t\t\t    struct journal_head **descriptorp,\n\t\t\t\t    int *offsetp,\n\t\t\t\t    struct jbd_revoke_record_s *record,\n\t\t\t\t    int write_op)\n{\n\tstruct journal_head *descriptor;\n\tint offset;\n\tjournal_header_t *header;\n\n\t/* If we are already aborting, this all becomes a noop.  We\n           still need to go round the loop in\n           journal_write_revoke_records in order to free all of the\n           revoke records: only the IO to the journal is omitted. */\n\tif (is_journal_aborted(journal))\n\t\treturn;\n\n\tdescriptor = *descriptorp;\n\toffset = *offsetp;\n\n\t/* Make sure we have a descriptor with space left for the record */\n\tif (descriptor) {\n\t\tif (offset == journal->j_blocksize) {\n\t\t\tflush_descriptor(journal, descriptor, offset, write_op);\n\t\t\tdescriptor = NULL;\n\t\t}\n\t}\n\n\tif (!descriptor) {\n\t\tdescriptor = journal_get_descriptor_buffer(journal);\n\t\tif (!descriptor)\n\t\t\treturn;\n\t\theader = (journal_header_t *) &jh2bh(descriptor)->b_data[0];\n\t\theader->h_magic     = cpu_to_be32(JFS_MAGIC_NUMBER);\n\t\theader->h_blocktype = cpu_to_be32(JFS_REVOKE_BLOCK);\n\t\theader->h_sequence  = cpu_to_be32(transaction->t_tid);\n\n\t\t/* Record it so that we can wait for IO completion later */\n\t\tJBUFFER_TRACE(descriptor, \"file as BJ_LogCtl\");\n\t\tjournal_file_buffer(descriptor, transaction, BJ_LogCtl);\n\n\t\toffset = sizeof(journal_revoke_header_t);\n\t\t*descriptorp = descriptor;\n\t}\n\n\t* ((__be32 *)(&jh2bh(descriptor)->b_data[offset])) =\n\t\tcpu_to_be32(record->blocknr);\n\toffset += 4;\n\t*offsetp = offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "hash_list"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *revoke_record_cache;\n\nvoid journal_write_revoke_records(journal_t *journal,\n\t\t\t\t  transaction_t *transaction, int write_op)\n{\n\tstruct journal_head *descriptor;\n\tstruct jbd_revoke_record_s *record;\n\tstruct jbd_revoke_table_s *revoke;\n\tstruct list_head *hash_list;\n\tint i, offset, count;\n\n\tdescriptor = NULL;\n\toffset = 0;\n\tcount = 0;\n\n\t/* select revoke table for committing transaction */\n\trevoke = journal->j_revoke == journal->j_revoke_table[0] ?\n\t\tjournal->j_revoke_table[1] : journal->j_revoke_table[0];\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\thash_list = &revoke->hash_table[i];\n\n\t\twhile (!list_empty(hash_list)) {\n\t\t\trecord = (struct jbd_revoke_record_s *)\n\t\t\t\thash_list->next;\n\t\t\twrite_one_revoke_record(journal, transaction,\n\t\t\t\t\t\t&descriptor, &offset,\n\t\t\t\t\t\trecord, write_op);\n\t\t\tcount++;\n\t\t\tlist_del(&record->hash);\n\t\t\tkmem_cache_free(revoke_record_cache, record);\n\t\t}\n\t}\n\tif (descriptor)\n\t\tflush_descriptor(journal, descriptor, offset, write_op);\n\tjbd_debug(1, \"Wrote %d revoke records\\n\", count);\n}"
  },
  {
    "function_name": "journal_switch_revoke_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
    "lines": "513-524",
    "snippet": "void journal_switch_revoke_table(journal_t *journal)\n{\n\tint i;\n\n\tif (journal->j_revoke == journal->j_revoke_table[0])\n\t\tjournal->j_revoke = journal->j_revoke_table[1];\n\telse\n\t\tjournal->j_revoke = journal->j_revoke_table[0];\n\n\tfor (i = 0; i < journal->j_revoke->hash_size; i++)\n\t\tINIT_LIST_HEAD(&journal->j_revoke->hash_table[i]);\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&journal->j_revoke->hash_table[i]"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nvoid journal_switch_revoke_table(journal_t *journal)\n{\n\tint i;\n\n\tif (journal->j_revoke == journal->j_revoke_table[0])\n\t\tjournal->j_revoke = journal->j_revoke_table[1];\n\telse\n\t\tjournal->j_revoke = journal->j_revoke_table[0];\n\n\tfor (i = 0; i < journal->j_revoke->hash_size; i++)\n\t\tINIT_LIST_HEAD(&journal->j_revoke->hash_table[i]);\n}"
  },
  {
    "function_name": "journal_clear_buffer_revoked_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
    "lines": "484-507",
    "snippet": "void journal_clear_buffer_revoked_flags(journal_t *journal)\n{\n\tstruct jbd_revoke_table_s *revoke = journal->j_revoke;\n\tint i = 0;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\tstruct list_head *hash_list;\n\t\tstruct list_head *list_entry;\n\t\thash_list = &revoke->hash_table[i];\n\n\t\tlist_for_each(list_entry, hash_list) {\n\t\t\tstruct jbd_revoke_record_s *record;\n\t\t\tstruct buffer_head *bh;\n\t\t\trecord = (struct jbd_revoke_record_s *)list_entry;\n\t\t\tbh = __find_get_block(journal->j_fs_dev,\n\t\t\t\t\t      record->blocknr,\n\t\t\t\t\t      journal->j_blocksize);\n\t\t\tif (bh) {\n\t\t\t\tclear_buffer_revoked(bh);\n\t\t\t\t__brelse(bh);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "bh"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_revoked",
          "args": [
            "bh"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "journal_clear_buffer_revoked_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "484-507",
          "snippet": "void journal_clear_buffer_revoked_flags(journal_t *journal)\n{\n\tstruct jbd_revoke_table_s *revoke = journal->j_revoke;\n\tint i = 0;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\tstruct list_head *hash_list;\n\t\tstruct list_head *list_entry;\n\t\thash_list = &revoke->hash_table[i];\n\n\t\tlist_for_each(list_entry, hash_list) {\n\t\t\tstruct jbd_revoke_record_s *record;\n\t\t\tstruct buffer_head *bh;\n\t\t\trecord = (struct jbd_revoke_record_s *)list_entry;\n\t\t\tbh = __find_get_block(journal->j_fs_dev,\n\t\t\t\t\t      record->blocknr,\n\t\t\t\t\t      journal->j_blocksize);\n\t\t\tif (bh) {\n\t\t\t\tclear_buffer_revoked(bh);\n\t\t\t\t__brelse(bh);\n\t\t\t}\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "__find_get_block",
          "args": [
            "journal->j_fs_dev",
            "record->blocknr",
            "journal->j_blocksize"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "__find_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1340-1354",
          "snippet": "struct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "list_entry",
            "hash_list"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nvoid journal_clear_buffer_revoked_flags(journal_t *journal)\n{\n\tstruct jbd_revoke_table_s *revoke = journal->j_revoke;\n\tint i = 0;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\tstruct list_head *hash_list;\n\t\tstruct list_head *list_entry;\n\t\thash_list = &revoke->hash_table[i];\n\n\t\tlist_for_each(list_entry, hash_list) {\n\t\t\tstruct jbd_revoke_record_s *record;\n\t\t\tstruct buffer_head *bh;\n\t\t\trecord = (struct jbd_revoke_record_s *)list_entry;\n\t\t\tbh = __find_get_block(journal->j_fs_dev,\n\t\t\t\t\t      record->blocknr,\n\t\t\t\t\t      journal->j_blocksize);\n\t\t\tif (bh) {\n\t\t\t\tclear_buffer_revoked(bh);\n\t\t\t\t__brelse(bh);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "journal_cancel_revoke",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
    "lines": "423-477",
    "snippet": "int journal_cancel_revoke(handle_t *handle, struct journal_head *jh)\n{\n\tstruct jbd_revoke_record_s *record;\n\tjournal_t *journal = handle->h_transaction->t_journal;\n\tint need_cancel;\n\tint did_revoke = 0;\t/* akpm: debug */\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_debug(4, \"journal_head %p, cancelling revoke\\n\", jh);\n\n\t/* Is the existing Revoke bit valid?  If so, we trust it, and\n\t * only perform the full cancel if the revoke bit is set.  If\n\t * not, we can't trust the revoke bit, and we need to do the\n\t * full search for a revoke record. */\n\tif (test_set_buffer_revokevalid(bh)) {\n\t\tneed_cancel = test_clear_buffer_revoked(bh);\n\t} else {\n\t\tneed_cancel = 1;\n\t\tclear_buffer_revoked(bh);\n\t}\n\n\tif (need_cancel) {\n\t\trecord = find_revoke_record(journal, bh->b_blocknr);\n\t\tif (record) {\n\t\t\tjbd_debug(4, \"cancelled existing revoke on \"\n\t\t\t\t  \"blocknr %llu\\n\", (unsigned long long)bh->b_blocknr);\n\t\t\tspin_lock(&journal->j_revoke_lock);\n\t\t\tlist_del(&record->hash);\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\tkmem_cache_free(revoke_record_cache, record);\n\t\t\tdid_revoke = 1;\n\t\t}\n\t}\n\n#ifdef JBD_EXPENSIVE_CHECKING\n\t/* There better not be one left behind by now! */\n\trecord = find_revoke_record(journal, bh->b_blocknr);\n\tJ_ASSERT_JH(jh, record == NULL);\n#endif\n\n\t/* Finally, have we just cleared revoke on an unhashed\n\t * buffer_head?  If so, we'd better make sure we clear the\n\t * revoked status on any hashed alias too, otherwise the revoke\n\t * state machine will get very upset later on. */\n\tif (need_cancel) {\n\t\tstruct buffer_head *bh2;\n\t\tbh2 = __find_get_block(bh->b_bdev, bh->b_blocknr, bh->b_size);\n\t\tif (bh2) {\n\t\t\tif (bh2 != bh)\n\t\t\t\tclear_buffer_revoked(bh2);\n\t\t\t__brelse(bh2);\n\t\t}\n\t}\n\treturn did_revoke;\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *revoke_record_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "bh2"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_revoked",
          "args": [
            "bh2"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "journal_clear_buffer_revoked_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "484-507",
          "snippet": "void journal_clear_buffer_revoked_flags(journal_t *journal)\n{\n\tstruct jbd_revoke_table_s *revoke = journal->j_revoke;\n\tint i = 0;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\tstruct list_head *hash_list;\n\t\tstruct list_head *list_entry;\n\t\thash_list = &revoke->hash_table[i];\n\n\t\tlist_for_each(list_entry, hash_list) {\n\t\t\tstruct jbd_revoke_record_s *record;\n\t\t\tstruct buffer_head *bh;\n\t\t\trecord = (struct jbd_revoke_record_s *)list_entry;\n\t\t\tbh = __find_get_block(journal->j_fs_dev,\n\t\t\t\t\t      record->blocknr,\n\t\t\t\t\t      journal->j_blocksize);\n\t\t\tif (bh) {\n\t\t\t\tclear_buffer_revoked(bh);\n\t\t\t\t__brelse(bh);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nvoid journal_clear_buffer_revoked_flags(journal_t *journal)\n{\n\tstruct jbd_revoke_table_s *revoke = journal->j_revoke;\n\tint i = 0;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\tstruct list_head *hash_list;\n\t\tstruct list_head *list_entry;\n\t\thash_list = &revoke->hash_table[i];\n\n\t\tlist_for_each(list_entry, hash_list) {\n\t\t\tstruct jbd_revoke_record_s *record;\n\t\t\tstruct buffer_head *bh;\n\t\t\trecord = (struct jbd_revoke_record_s *)list_entry;\n\t\t\tbh = __find_get_block(journal->j_fs_dev,\n\t\t\t\t\t      record->blocknr,\n\t\t\t\t\t      journal->j_blocksize);\n\t\t\tif (bh) {\n\t\t\t\tclear_buffer_revoked(bh);\n\t\t\t\t__brelse(bh);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__find_get_block",
          "args": [
            "bh->b_bdev",
            "bh->b_blocknr",
            "bh->b_size"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "__find_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1340-1354",
          "snippet": "struct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "record == NULL"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_revoke_record",
          "args": [
            "journal",
            "bh->b_blocknr"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "find_revoke_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "169-188",
          "snippet": "static struct jbd_revoke_record_s *find_revoke_record(journal_t *journal,\n\t\t\t\t\t\t      unsigned int blocknr)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd_revoke_record_s *record;\n\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\n\tspin_lock(&journal->j_revoke_lock);\n\trecord = (struct jbd_revoke_record_s *) hash_list->next;\n\twhile (&(record->hash) != hash_list) {\n\t\tif (record->blocknr == blocknr) {\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\treturn record;\n\t\t}\n\t\trecord = (struct jbd_revoke_record_s *) record->hash.next;\n\t}\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct jbd_revoke_record_s *find_revoke_record(journal_t *journal,\n\t\t\t\t\t\t      unsigned int blocknr)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd_revoke_record_s *record;\n\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\n\tspin_lock(&journal->j_revoke_lock);\n\trecord = (struct jbd_revoke_record_s *) hash_list->next;\n\twhile (&(record->hash) != hash_list) {\n\t\tif (record->blocknr == blocknr) {\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\treturn record;\n\t\t}\n\t\trecord = (struct jbd_revoke_record_s *) record->hash.next;\n\t}\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "revoke_record_cache",
            "record"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_revoke_lock"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&record->hash"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_revoke_lock"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"cancelled existing revoke on \"\n\t\t\t\t  \"blocknr %llu\\n\"",
            "(unsigned long long)bh->b_blocknr"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_clear_buffer_revoked",
          "args": [
            "bh"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_set_buffer_revokevalid",
          "args": [
            "bh"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "4",
            "\"journal_head %p, cancelling revoke\\n\"",
            "jh"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *revoke_record_cache;\n\nint journal_cancel_revoke(handle_t *handle, struct journal_head *jh)\n{\n\tstruct jbd_revoke_record_s *record;\n\tjournal_t *journal = handle->h_transaction->t_journal;\n\tint need_cancel;\n\tint did_revoke = 0;\t/* akpm: debug */\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_debug(4, \"journal_head %p, cancelling revoke\\n\", jh);\n\n\t/* Is the existing Revoke bit valid?  If so, we trust it, and\n\t * only perform the full cancel if the revoke bit is set.  If\n\t * not, we can't trust the revoke bit, and we need to do the\n\t * full search for a revoke record. */\n\tif (test_set_buffer_revokevalid(bh)) {\n\t\tneed_cancel = test_clear_buffer_revoked(bh);\n\t} else {\n\t\tneed_cancel = 1;\n\t\tclear_buffer_revoked(bh);\n\t}\n\n\tif (need_cancel) {\n\t\trecord = find_revoke_record(journal, bh->b_blocknr);\n\t\tif (record) {\n\t\t\tjbd_debug(4, \"cancelled existing revoke on \"\n\t\t\t\t  \"blocknr %llu\\n\", (unsigned long long)bh->b_blocknr);\n\t\t\tspin_lock(&journal->j_revoke_lock);\n\t\t\tlist_del(&record->hash);\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\tkmem_cache_free(revoke_record_cache, record);\n\t\t\tdid_revoke = 1;\n\t\t}\n\t}\n\n#ifdef JBD_EXPENSIVE_CHECKING\n\t/* There better not be one left behind by now! */\n\trecord = find_revoke_record(journal, bh->b_blocknr);\n\tJ_ASSERT_JH(jh, record == NULL);\n#endif\n\n\t/* Finally, have we just cleared revoke on an unhashed\n\t * buffer_head?  If so, we'd better make sure we clear the\n\t * revoked status on any hashed alias too, otherwise the revoke\n\t * state machine will get very upset later on. */\n\tif (need_cancel) {\n\t\tstruct buffer_head *bh2;\n\t\tbh2 = __find_get_block(bh->b_bdev, bh->b_blocknr, bh->b_size);\n\t\tif (bh2) {\n\t\t\tif (bh2 != bh)\n\t\t\t\tclear_buffer_revoked(bh2);\n\t\t\t__brelse(bh2);\n\t\t}\n\t}\n\treturn did_revoke;\n}"
  },
  {
    "function_name": "journal_revoke",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
    "lines": "332-406",
    "snippet": "int journal_revoke(handle_t *handle, unsigned int blocknr,\n\t\t   struct buffer_head *bh_in)\n{\n\tstruct buffer_head *bh = NULL;\n\tjournal_t *journal;\n\tstruct block_device *bdev;\n\tint err;\n\n\tmight_sleep();\n\tif (bh_in)\n\t\tBUFFER_TRACE(bh_in, \"enter\");\n\n\tjournal = handle->h_transaction->t_journal;\n\tif (!journal_set_features(journal, 0, 0, JFS_FEATURE_INCOMPAT_REVOKE)){\n\t\tJ_ASSERT (!\"Cannot set revoke feature!\");\n\t\treturn -EINVAL;\n\t}\n\n\tbdev = journal->j_fs_dev;\n\tbh = bh_in;\n\n\tif (!bh) {\n\t\tbh = __find_get_block(bdev, blocknr, journal->j_blocksize);\n\t\tif (bh)\n\t\t\tBUFFER_TRACE(bh, \"found on hash\");\n\t}\n#ifdef JBD_EXPENSIVE_CHECKING\n\telse {\n\t\tstruct buffer_head *bh2;\n\n\t\t/* If there is a different buffer_head lying around in\n\t\t * memory anywhere... */\n\t\tbh2 = __find_get_block(bdev, blocknr, journal->j_blocksize);\n\t\tif (bh2) {\n\t\t\t/* ... and it has RevokeValid status... */\n\t\t\tif (bh2 != bh && buffer_revokevalid(bh2))\n\t\t\t\t/* ...then it better be revoked too,\n\t\t\t\t * since it's illegal to create a revoke\n\t\t\t\t * record against a buffer_head which is\n\t\t\t\t * not marked revoked --- that would\n\t\t\t\t * risk missing a subsequent revoke\n\t\t\t\t * cancel. */\n\t\t\t\tJ_ASSERT_BH(bh2, buffer_revoked(bh2));\n\t\t\tput_bh(bh2);\n\t\t}\n\t}\n#endif\n\n\t/* We really ought not ever to revoke twice in a row without\n           first having the revoke cancelled: it's illegal to free a\n           block twice without allocating it in between! */\n\tif (bh) {\n\t\tif (!J_EXPECT_BH(bh, !buffer_revoked(bh),\n\t\t\t\t \"inconsistent data on disk\")) {\n\t\t\tif (!bh_in)\n\t\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t\tset_buffer_revoked(bh);\n\t\tset_buffer_revokevalid(bh);\n\t\tif (bh_in) {\n\t\t\tBUFFER_TRACE(bh_in, \"call journal_forget\");\n\t\t\tjournal_forget(handle, bh_in);\n\t\t} else {\n\t\t\tBUFFER_TRACE(bh, \"call brelse\");\n\t\t\t__brelse(bh);\n\t\t}\n\t}\n\n\tjbd_debug(2, \"insert revoke for block %u, bh_in=%p\\n\", blocknr, bh_in);\n\terr = insert_revoke_hash(journal, blocknr,\n\t\t\t\thandle->h_transaction->t_tid);\n\tBUFFER_TRACE(bh_in, \"exit\");\n\treturn err;\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh_in",
            "\"exit\""
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_revoke_hash",
          "args": [
            "journal",
            "blocknr",
            "handle->h_transaction->t_tid"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "insert_revoke_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "140-165",
          "snippet": "static int insert_revoke_hash(journal_t *journal, unsigned int blocknr,\n\t\t\t      tid_t seq)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd_revoke_record_s *record;\n\nrepeat:\n\trecord = kmem_cache_alloc(revoke_record_cache, GFP_NOFS);\n\tif (!record)\n\t\tgoto oom;\n\n\trecord->sequence = seq;\n\trecord->blocknr = blocknr;\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\tspin_lock(&journal->j_revoke_lock);\n\tlist_add(&record->hash, hash_list);\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn 0;\n\noom:\n\tif (!journal_oom_retry)\n\t\treturn -ENOMEM;\n\tjbd_debug(1, \"ENOMEM in %s, retrying\\n\", __func__);\n\tyield();\n\tgoto repeat;\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *revoke_record_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *revoke_record_cache;\n\nstatic int insert_revoke_hash(journal_t *journal, unsigned int blocknr,\n\t\t\t      tid_t seq)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd_revoke_record_s *record;\n\nrepeat:\n\trecord = kmem_cache_alloc(revoke_record_cache, GFP_NOFS);\n\tif (!record)\n\t\tgoto oom;\n\n\trecord->sequence = seq;\n\trecord->blocknr = blocknr;\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\tspin_lock(&journal->j_revoke_lock);\n\tlist_add(&record->hash, hash_list);\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn 0;\n\noom:\n\tif (!journal_oom_retry)\n\t\treturn -ENOMEM;\n\tjbd_debug(1, \"ENOMEM in %s, retrying\\n\", __func__);\n\tyield();\n\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "2",
            "\"insert revoke for block %u, bh_in=%p\\n\"",
            "blocknr",
            "bh_in"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "bh"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"call brelse\""
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_forget",
          "args": [
            "handle",
            "bh_in"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "journal_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1235-1344",
          "snippet": "int journal_forget (handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tstruct journal_head *jh;\n\tint drop_reserve = 0;\n\tint err = 0;\n\tint was_modified = 0;\n\n\tBUFFER_TRACE(bh, \"entry\");\n\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\n\tif (!buffer_jbd(bh))\n\t\tgoto not_jbd;\n\tjh = bh2jh(bh);\n\n\t/* Critical error: attempting to delete a bitmap buffer, maybe?\n\t * Don't do any jbd operations, and return an error. */\n\tif (!J_EXPECT_JH(jh, !jh->b_committed_data,\n\t\t\t \"inconsistent data on disk\")) {\n\t\terr = -EIO;\n\t\tgoto not_jbd;\n\t}\n\n\t/* keep track of whether or not this transaction modified us */\n\twas_modified = jh->b_modified;\n\n\t/*\n\t * The buffer's going from the transaction, we must drop\n\t * all references -bzzz\n\t */\n\tjh->b_modified = 0;\n\n\tif (jh->b_transaction == handle->h_transaction) {\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\n\t\t/* If we are forgetting a buffer which is already part\n\t\t * of this transaction, then we can just drop it from\n\t\t * the transaction immediately. */\n\t\tclear_buffer_dirty(bh);\n\t\tclear_buffer_jbddirty(bh);\n\n\t\tJBUFFER_TRACE(jh, \"belongs to current transaction: unfile\");\n\n\t\t/*\n\t\t * we only want to drop a reference if this transaction\n\t\t * modified the buffer\n\t\t */\n\t\tif (was_modified)\n\t\t\tdrop_reserve = 1;\n\n\t\t/*\n\t\t * We are no longer going to journal this buffer.\n\t\t * However, the commit of this transaction is still\n\t\t * important to the buffer: the delete that we are now\n\t\t * processing might obsolete an old log entry, so by\n\t\t * committing, we can satisfy the buffer's checkpoint.\n\t\t *\n\t\t * So, if we have a checkpoint on the buffer, we should\n\t\t * now refile the buffer on our BJ_Forget list so that\n\t\t * we know to remove the checkpoint after we commit.\n\t\t */\n\n\t\tif (jh->b_cp_transaction) {\n\t\t\t__journal_temp_unlink_buffer(jh);\n\t\t\t__journal_file_buffer(jh, transaction, BJ_Forget);\n\t\t} else {\n\t\t\t__journal_unfile_buffer(jh);\n\t\t\tif (!buffer_jbd(bh)) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t\t__bforget(bh);\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t}\n\t} else if (jh->b_transaction) {\n\t\tJ_ASSERT_JH(jh, (jh->b_transaction ==\n\t\t\t\t journal->j_committing_transaction));\n\t\t/* However, if the buffer is still owned by a prior\n\t\t * (committing) transaction, we can't drop it yet... */\n\t\tJBUFFER_TRACE(jh, \"belongs to older transaction\");\n\t\t/* ... but we CAN drop it from the new transaction if we\n\t\t * have also modified it since the original commit. */\n\n\t\tif (jh->b_next_transaction) {\n\t\t\tJ_ASSERT(jh->b_next_transaction == transaction);\n\t\t\tjh->b_next_transaction = NULL;\n\n\t\t\t/*\n\t\t\t * only drop a reference if this transaction modified\n\t\t\t * the buffer\n\t\t\t */\n\t\t\tif (was_modified)\n\t\t\t\tdrop_reserve = 1;\n\t\t}\n\t}\n\nnot_jbd:\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\t__brelse(bh);\ndrop:\n\tif (drop_reserve) {\n\t\t/* no need to reserve log space for this block -bzzz */\n\t\thandle->h_buffer_credits++;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nint journal_forget (handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tstruct journal_head *jh;\n\tint drop_reserve = 0;\n\tint err = 0;\n\tint was_modified = 0;\n\n\tBUFFER_TRACE(bh, \"entry\");\n\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\n\tif (!buffer_jbd(bh))\n\t\tgoto not_jbd;\n\tjh = bh2jh(bh);\n\n\t/* Critical error: attempting to delete a bitmap buffer, maybe?\n\t * Don't do any jbd operations, and return an error. */\n\tif (!J_EXPECT_JH(jh, !jh->b_committed_data,\n\t\t\t \"inconsistent data on disk\")) {\n\t\terr = -EIO;\n\t\tgoto not_jbd;\n\t}\n\n\t/* keep track of whether or not this transaction modified us */\n\twas_modified = jh->b_modified;\n\n\t/*\n\t * The buffer's going from the transaction, we must drop\n\t * all references -bzzz\n\t */\n\tjh->b_modified = 0;\n\n\tif (jh->b_transaction == handle->h_transaction) {\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\n\t\t/* If we are forgetting a buffer which is already part\n\t\t * of this transaction, then we can just drop it from\n\t\t * the transaction immediately. */\n\t\tclear_buffer_dirty(bh);\n\t\tclear_buffer_jbddirty(bh);\n\n\t\tJBUFFER_TRACE(jh, \"belongs to current transaction: unfile\");\n\n\t\t/*\n\t\t * we only want to drop a reference if this transaction\n\t\t * modified the buffer\n\t\t */\n\t\tif (was_modified)\n\t\t\tdrop_reserve = 1;\n\n\t\t/*\n\t\t * We are no longer going to journal this buffer.\n\t\t * However, the commit of this transaction is still\n\t\t * important to the buffer: the delete that we are now\n\t\t * processing might obsolete an old log entry, so by\n\t\t * committing, we can satisfy the buffer's checkpoint.\n\t\t *\n\t\t * So, if we have a checkpoint on the buffer, we should\n\t\t * now refile the buffer on our BJ_Forget list so that\n\t\t * we know to remove the checkpoint after we commit.\n\t\t */\n\n\t\tif (jh->b_cp_transaction) {\n\t\t\t__journal_temp_unlink_buffer(jh);\n\t\t\t__journal_file_buffer(jh, transaction, BJ_Forget);\n\t\t} else {\n\t\t\t__journal_unfile_buffer(jh);\n\t\t\tif (!buffer_jbd(bh)) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t\t__bforget(bh);\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t}\n\t} else if (jh->b_transaction) {\n\t\tJ_ASSERT_JH(jh, (jh->b_transaction ==\n\t\t\t\t journal->j_committing_transaction));\n\t\t/* However, if the buffer is still owned by a prior\n\t\t * (committing) transaction, we can't drop it yet... */\n\t\tJBUFFER_TRACE(jh, \"belongs to older transaction\");\n\t\t/* ... but we CAN drop it from the new transaction if we\n\t\t * have also modified it since the original commit. */\n\n\t\tif (jh->b_next_transaction) {\n\t\t\tJ_ASSERT(jh->b_next_transaction == transaction);\n\t\t\tjh->b_next_transaction = NULL;\n\n\t\t\t/*\n\t\t\t * only drop a reference if this transaction modified\n\t\t\t * the buffer\n\t\t\t */\n\t\t\tif (was_modified)\n\t\t\t\tdrop_reserve = 1;\n\t\t}\n\t}\n\nnot_jbd:\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\t__brelse(bh);\ndrop:\n\tif (drop_reserve) {\n\t\t/* no need to reserve log space for this block -bzzz */\n\t\thandle->h_buffer_credits++;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh_in",
            "\"call journal_forget\""
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_revokevalid",
          "args": [
            "bh"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_revoked",
          "args": [
            "bh"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_EXPECT_BH",
          "args": [
            "bh",
            "!buffer_revoked(bh)",
            "\"inconsistent data on disk\""
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_revoked",
          "args": [
            "bh"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "journal_clear_buffer_revoked_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "484-507",
          "snippet": "void journal_clear_buffer_revoked_flags(journal_t *journal)\n{\n\tstruct jbd_revoke_table_s *revoke = journal->j_revoke;\n\tint i = 0;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\tstruct list_head *hash_list;\n\t\tstruct list_head *list_entry;\n\t\thash_list = &revoke->hash_table[i];\n\n\t\tlist_for_each(list_entry, hash_list) {\n\t\t\tstruct jbd_revoke_record_s *record;\n\t\t\tstruct buffer_head *bh;\n\t\t\trecord = (struct jbd_revoke_record_s *)list_entry;\n\t\t\tbh = __find_get_block(journal->j_fs_dev,\n\t\t\t\t\t      record->blocknr,\n\t\t\t\t\t      journal->j_blocksize);\n\t\t\tif (bh) {\n\t\t\t\tclear_buffer_revoked(bh);\n\t\t\t\t__brelse(bh);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nvoid journal_clear_buffer_revoked_flags(journal_t *journal)\n{\n\tstruct jbd_revoke_table_s *revoke = journal->j_revoke;\n\tint i = 0;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\tstruct list_head *hash_list;\n\t\tstruct list_head *list_entry;\n\t\thash_list = &revoke->hash_table[i];\n\n\t\tlist_for_each(list_entry, hash_list) {\n\t\t\tstruct jbd_revoke_record_s *record;\n\t\t\tstruct buffer_head *bh;\n\t\t\trecord = (struct jbd_revoke_record_s *)list_entry;\n\t\t\tbh = __find_get_block(journal->j_fs_dev,\n\t\t\t\t\t      record->blocknr,\n\t\t\t\t\t      journal->j_blocksize);\n\t\t\tif (bh) {\n\t\t\t\tclear_buffer_revoked(bh);\n\t\t\t\t__brelse(bh);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh2"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_BH",
          "args": [
            "bh2",
            "buffer_revoked(bh2)"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_revokevalid",
          "args": [
            "bh2"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__find_get_block",
          "args": [
            "bdev",
            "blocknr",
            "journal->j_blocksize"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "__find_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1340-1354",
          "snippet": "struct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"found on hash\""
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "!\"Cannot set revoke feature!\""
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_set_features",
          "args": [
            "journal",
            "0",
            "0",
            "JFS_FEATURE_INCOMPAT_REVOKE"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "journal_set_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1461-1482",
          "snippet": "int journal_set_features (journal_t *journal, unsigned long compat,\n\t\t\t  unsigned long ro, unsigned long incompat)\n{\n\tjournal_superblock_t *sb;\n\n\tif (journal_check_used_features(journal, compat, ro, incompat))\n\t\treturn 1;\n\n\tif (!journal_check_available_features(journal, compat, ro, incompat))\n\t\treturn 0;\n\n\tjbd_debug(1, \"Setting new features 0x%lx/0x%lx/0x%lx\\n\",\n\t\t  compat, ro, incompat);\n\n\tsb = journal->j_superblock;\n\n\tsb->s_feature_compat    |= cpu_to_be32(compat);\n\tsb->s_feature_ro_compat |= cpu_to_be32(ro);\n\tsb->s_feature_incompat  |= cpu_to_be32(incompat);\n\n\treturn 1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nint journal_set_features (journal_t *journal, unsigned long compat,\n\t\t\t  unsigned long ro, unsigned long incompat)\n{\n\tjournal_superblock_t *sb;\n\n\tif (journal_check_used_features(journal, compat, ro, incompat))\n\t\treturn 1;\n\n\tif (!journal_check_available_features(journal, compat, ro, incompat))\n\t\treturn 0;\n\n\tjbd_debug(1, \"Setting new features 0x%lx/0x%lx/0x%lx\\n\",\n\t\t  compat, ro, incompat);\n\n\tsb = journal->j_superblock;\n\n\tsb->s_feature_compat    |= cpu_to_be32(compat);\n\tsb->s_feature_ro_compat |= cpu_to_be32(ro);\n\tsb->s_feature_incompat  |= cpu_to_be32(incompat);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh_in",
            "\"enter\""
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nint journal_revoke(handle_t *handle, unsigned int blocknr,\n\t\t   struct buffer_head *bh_in)\n{\n\tstruct buffer_head *bh = NULL;\n\tjournal_t *journal;\n\tstruct block_device *bdev;\n\tint err;\n\n\tmight_sleep();\n\tif (bh_in)\n\t\tBUFFER_TRACE(bh_in, \"enter\");\n\n\tjournal = handle->h_transaction->t_journal;\n\tif (!journal_set_features(journal, 0, 0, JFS_FEATURE_INCOMPAT_REVOKE)){\n\t\tJ_ASSERT (!\"Cannot set revoke feature!\");\n\t\treturn -EINVAL;\n\t}\n\n\tbdev = journal->j_fs_dev;\n\tbh = bh_in;\n\n\tif (!bh) {\n\t\tbh = __find_get_block(bdev, blocknr, journal->j_blocksize);\n\t\tif (bh)\n\t\t\tBUFFER_TRACE(bh, \"found on hash\");\n\t}\n#ifdef JBD_EXPENSIVE_CHECKING\n\telse {\n\t\tstruct buffer_head *bh2;\n\n\t\t/* If there is a different buffer_head lying around in\n\t\t * memory anywhere... */\n\t\tbh2 = __find_get_block(bdev, blocknr, journal->j_blocksize);\n\t\tif (bh2) {\n\t\t\t/* ... and it has RevokeValid status... */\n\t\t\tif (bh2 != bh && buffer_revokevalid(bh2))\n\t\t\t\t/* ...then it better be revoked too,\n\t\t\t\t * since it's illegal to create a revoke\n\t\t\t\t * record against a buffer_head which is\n\t\t\t\t * not marked revoked --- that would\n\t\t\t\t * risk missing a subsequent revoke\n\t\t\t\t * cancel. */\n\t\t\t\tJ_ASSERT_BH(bh2, buffer_revoked(bh2));\n\t\t\tput_bh(bh2);\n\t\t}\n\t}\n#endif\n\n\t/* We really ought not ever to revoke twice in a row without\n           first having the revoke cancelled: it's illegal to free a\n           block twice without allocating it in between! */\n\tif (bh) {\n\t\tif (!J_EXPECT_BH(bh, !buffer_revoked(bh),\n\t\t\t\t \"inconsistent data on disk\")) {\n\t\t\tif (!bh_in)\n\t\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t\tset_buffer_revoked(bh);\n\t\tset_buffer_revokevalid(bh);\n\t\tif (bh_in) {\n\t\t\tBUFFER_TRACE(bh_in, \"call journal_forget\");\n\t\t\tjournal_forget(handle, bh_in);\n\t\t} else {\n\t\t\tBUFFER_TRACE(bh, \"call brelse\");\n\t\t\t__brelse(bh);\n\t\t}\n\t}\n\n\tjbd_debug(2, \"insert revoke for block %u, bh_in=%p\\n\", blocknr, bh_in);\n\terr = insert_revoke_hash(journal, blocknr,\n\t\t\t\thandle->h_transaction->t_tid);\n\tBUFFER_TRACE(bh_in, \"exit\");\n\treturn err;\n}"
  },
  {
    "function_name": "journal_destroy_revoke",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
    "lines": "296-303",
    "snippet": "void journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[1]);\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_destroy_revoke_table",
          "args": [
            "journal->j_revoke_table[1]"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "journal_destroy_revoke_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "255-267",
          "snippet": "static void journal_destroy_revoke_table(struct jbd_revoke_table_s *table)\n{\n\tint i;\n\tstruct list_head *hash_list;\n\n\tfor (i = 0; i < table->hash_size; i++) {\n\t\thash_list = &table->hash_table[i];\n\t\tJ_ASSERT(list_empty(hash_list));\n\t}\n\n\tkfree(table->hash_table);\n\tkmem_cache_free(revoke_table_cache, table);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *revoke_table_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *revoke_table_cache;\n\nstatic void journal_destroy_revoke_table(struct jbd_revoke_table_s *table)\n{\n\tint i;\n\tstruct list_head *hash_list;\n\n\tfor (i = 0; i < table->hash_size; i++) {\n\t\thash_list = &table->hash_table[i];\n\t\tJ_ASSERT(list_empty(hash_list));\n\t}\n\n\tkfree(table->hash_table);\n\tkmem_cache_free(revoke_table_cache, table);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nvoid journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjournal_destroy_revoke_table(journal->j_revoke_table[1]);\n}"
  },
  {
    "function_name": "journal_init_revoke",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
    "lines": "270-293",
    "snippet": "int journal_init_revoke(journal_t *journal, int hash_size)\n{\n\tJ_ASSERT(journal->j_revoke_table[0] == NULL);\n\tJ_ASSERT(is_power_of_2(hash_size));\n\n\tjournal->j_revoke_table[0] = journal_init_revoke_table(hash_size);\n\tif (!journal->j_revoke_table[0])\n\t\tgoto fail0;\n\n\tjournal->j_revoke_table[1] = journal_init_revoke_table(hash_size);\n\tif (!journal->j_revoke_table[1])\n\t\tgoto fail1;\n\n\tjournal->j_revoke = journal->j_revoke_table[1];\n\n\tspin_lock_init(&journal->j_revoke_lock);\n\n\treturn 0;\n\nfail1:\n\tjournal_destroy_revoke_table(journal->j_revoke_table[0]);\nfail0:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_destroy_revoke_table",
          "args": [
            "journal->j_revoke_table[0]"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "journal_destroy_revoke_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "255-267",
          "snippet": "static void journal_destroy_revoke_table(struct jbd_revoke_table_s *table)\n{\n\tint i;\n\tstruct list_head *hash_list;\n\n\tfor (i = 0; i < table->hash_size; i++) {\n\t\thash_list = &table->hash_table[i];\n\t\tJ_ASSERT(list_empty(hash_list));\n\t}\n\n\tkfree(table->hash_table);\n\tkmem_cache_free(revoke_table_cache, table);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *revoke_table_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *revoke_table_cache;\n\nstatic void journal_destroy_revoke_table(struct jbd_revoke_table_s *table)\n{\n\tint i;\n\tstruct list_head *hash_list;\n\n\tfor (i = 0; i < table->hash_size; i++) {\n\t\thash_list = &table->hash_table[i];\n\t\tJ_ASSERT(list_empty(hash_list));\n\t}\n\n\tkfree(table->hash_table);\n\tkmem_cache_free(revoke_table_cache, table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&journal->j_revoke_lock"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_init_revoke_table",
          "args": [
            "hash_size"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "journal_init_revoke_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "229-253",
          "snippet": "static struct jbd_revoke_table_s *journal_init_revoke_table(int hash_size)\n{\n\tint i;\n\tstruct jbd_revoke_table_s *table;\n\n\ttable = kmem_cache_alloc(revoke_table_cache, GFP_KERNEL);\n\tif (!table)\n\t\tgoto out;\n\n\ttable->hash_size = hash_size;\n\ttable->hash_shift = ilog2(hash_size);\n\ttable->hash_table =\n\t\tkmalloc(hash_size * sizeof(struct list_head), GFP_KERNEL);\n\tif (!table->hash_table) {\n\t\tkmem_cache_free(revoke_table_cache, table);\n\t\ttable = NULL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < hash_size; i++)\n\t\tINIT_LIST_HEAD(&table->hash_table[i]);\n\nout:\n\treturn table;\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *revoke_table_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *revoke_table_cache;\n\nstatic struct jbd_revoke_table_s *journal_init_revoke_table(int hash_size)\n{\n\tint i;\n\tstruct jbd_revoke_table_s *table;\n\n\ttable = kmem_cache_alloc(revoke_table_cache, GFP_KERNEL);\n\tif (!table)\n\t\tgoto out;\n\n\ttable->hash_size = hash_size;\n\ttable->hash_shift = ilog2(hash_size);\n\ttable->hash_table =\n\t\tkmalloc(hash_size * sizeof(struct list_head), GFP_KERNEL);\n\tif (!table->hash_table) {\n\t\tkmem_cache_free(revoke_table_cache, table);\n\t\ttable = NULL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < hash_size; i++)\n\t\tINIT_LIST_HEAD(&table->hash_table[i]);\n\nout:\n\treturn table;\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "is_power_of_2(hash_size)"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "hash_size"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal->j_revoke_table[0] == NULL"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nint journal_init_revoke(journal_t *journal, int hash_size)\n{\n\tJ_ASSERT(journal->j_revoke_table[0] == NULL);\n\tJ_ASSERT(is_power_of_2(hash_size));\n\n\tjournal->j_revoke_table[0] = journal_init_revoke_table(hash_size);\n\tif (!journal->j_revoke_table[0])\n\t\tgoto fail0;\n\n\tjournal->j_revoke_table[1] = journal_init_revoke_table(hash_size);\n\tif (!journal->j_revoke_table[1])\n\t\tgoto fail1;\n\n\tjournal->j_revoke = journal->j_revoke_table[1];\n\n\tspin_lock_init(&journal->j_revoke_lock);\n\n\treturn 0;\n\nfail1:\n\tjournal_destroy_revoke_table(journal->j_revoke_table[0]);\nfail0:\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "journal_destroy_revoke_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
    "lines": "255-267",
    "snippet": "static void journal_destroy_revoke_table(struct jbd_revoke_table_s *table)\n{\n\tint i;\n\tstruct list_head *hash_list;\n\n\tfor (i = 0; i < table->hash_size; i++) {\n\t\thash_list = &table->hash_table[i];\n\t\tJ_ASSERT(list_empty(hash_list));\n\t}\n\n\tkfree(table->hash_table);\n\tkmem_cache_free(revoke_table_cache, table);\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *revoke_table_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "revoke_table_cache",
            "table"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "table->hash_table"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "list_empty(hash_list)"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "hash_list"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *revoke_table_cache;\n\nstatic void journal_destroy_revoke_table(struct jbd_revoke_table_s *table)\n{\n\tint i;\n\tstruct list_head *hash_list;\n\n\tfor (i = 0; i < table->hash_size; i++) {\n\t\thash_list = &table->hash_table[i];\n\t\tJ_ASSERT(list_empty(hash_list));\n\t}\n\n\tkfree(table->hash_table);\n\tkmem_cache_free(revoke_table_cache, table);\n}"
  },
  {
    "function_name": "journal_init_revoke_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
    "lines": "229-253",
    "snippet": "static struct jbd_revoke_table_s *journal_init_revoke_table(int hash_size)\n{\n\tint i;\n\tstruct jbd_revoke_table_s *table;\n\n\ttable = kmem_cache_alloc(revoke_table_cache, GFP_KERNEL);\n\tif (!table)\n\t\tgoto out;\n\n\ttable->hash_size = hash_size;\n\ttable->hash_shift = ilog2(hash_size);\n\ttable->hash_table =\n\t\tkmalloc(hash_size * sizeof(struct list_head), GFP_KERNEL);\n\tif (!table->hash_table) {\n\t\tkmem_cache_free(revoke_table_cache, table);\n\t\ttable = NULL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < hash_size; i++)\n\t\tINIT_LIST_HEAD(&table->hash_table[i]);\n\nout:\n\treturn table;\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *revoke_table_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&table->hash_table[i]"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "revoke_table_cache",
            "table"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "hash_size * sizeof(struct list_head)",
            "GFP_KERNEL"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "hash_size"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "revoke_table_cache",
            "GFP_KERNEL"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *revoke_table_cache;\n\nstatic struct jbd_revoke_table_s *journal_init_revoke_table(int hash_size)\n{\n\tint i;\n\tstruct jbd_revoke_table_s *table;\n\n\ttable = kmem_cache_alloc(revoke_table_cache, GFP_KERNEL);\n\tif (!table)\n\t\tgoto out;\n\n\ttable->hash_size = hash_size;\n\ttable->hash_shift = ilog2(hash_size);\n\ttable->hash_table =\n\t\tkmalloc(hash_size * sizeof(struct list_head), GFP_KERNEL);\n\tif (!table->hash_table) {\n\t\tkmem_cache_free(revoke_table_cache, table);\n\t\ttable = NULL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < hash_size; i++)\n\t\tINIT_LIST_HEAD(&table->hash_table[i]);\n\nout:\n\treturn table;\n}"
  },
  {
    "function_name": "journal_init_revoke_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
    "lines": "202-227",
    "snippet": "int __init journal_init_revoke_caches(void)\n{\n\tJ_ASSERT(!revoke_record_cache);\n\tJ_ASSERT(!revoke_table_cache);\n\n\trevoke_record_cache = kmem_cache_create(\"revoke_record\",\n\t\t\t\t\t   sizeof(struct jbd_revoke_record_s),\n\t\t\t\t\t   0,\n\t\t\t\t\t   SLAB_HWCACHE_ALIGN|SLAB_TEMPORARY,\n\t\t\t\t\t   NULL);\n\tif (!revoke_record_cache)\n\t\tgoto record_cache_failure;\n\n\trevoke_table_cache = kmem_cache_create(\"revoke_table\",\n\t\t\t\t\t   sizeof(struct jbd_revoke_table_s),\n\t\t\t\t\t   0, SLAB_TEMPORARY, NULL);\n\tif (!revoke_table_cache)\n\t\tgoto table_cache_failure;\n\n\treturn 0;\n\ntable_cache_failure:\n\tjournal_destroy_revoke_caches();\nrecord_cache_failure:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *revoke_record_cache;",
      "static struct kmem_cache *revoke_table_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_destroy_revoke_caches",
          "args": [],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "journal_destroy_revoke_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "190-200",
          "snippet": "void journal_destroy_revoke_caches(void)\n{\n\tif (revoke_record_cache) {\n\t\tkmem_cache_destroy(revoke_record_cache);\n\t\trevoke_record_cache = NULL;\n\t}\n\tif (revoke_table_cache) {\n\t\tkmem_cache_destroy(revoke_table_cache);\n\t\trevoke_table_cache = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *revoke_record_cache;",
            "static struct kmem_cache *revoke_table_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *revoke_record_cache;\nstatic struct kmem_cache *revoke_table_cache;\n\nvoid journal_destroy_revoke_caches(void)\n{\n\tif (revoke_record_cache) {\n\t\tkmem_cache_destroy(revoke_record_cache);\n\t\trevoke_record_cache = NULL;\n\t}\n\tif (revoke_table_cache) {\n\t\tkmem_cache_destroy(revoke_table_cache);\n\t\trevoke_table_cache = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"revoke_table\"",
            "sizeof(struct jbd_revoke_table_s)",
            "0",
            "SLAB_TEMPORARY",
            "NULL"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"revoke_record\"",
            "sizeof(struct jbd_revoke_record_s)",
            "0",
            "SLAB_HWCACHE_ALIGN|SLAB_TEMPORARY",
            "NULL"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "!revoke_table_cache"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "!revoke_record_cache"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *revoke_record_cache;\nstatic struct kmem_cache *revoke_table_cache;\n\nint __init journal_init_revoke_caches(void)\n{\n\tJ_ASSERT(!revoke_record_cache);\n\tJ_ASSERT(!revoke_table_cache);\n\n\trevoke_record_cache = kmem_cache_create(\"revoke_record\",\n\t\t\t\t\t   sizeof(struct jbd_revoke_record_s),\n\t\t\t\t\t   0,\n\t\t\t\t\t   SLAB_HWCACHE_ALIGN|SLAB_TEMPORARY,\n\t\t\t\t\t   NULL);\n\tif (!revoke_record_cache)\n\t\tgoto record_cache_failure;\n\n\trevoke_table_cache = kmem_cache_create(\"revoke_table\",\n\t\t\t\t\t   sizeof(struct jbd_revoke_table_s),\n\t\t\t\t\t   0, SLAB_TEMPORARY, NULL);\n\tif (!revoke_table_cache)\n\t\tgoto table_cache_failure;\n\n\treturn 0;\n\ntable_cache_failure:\n\tjournal_destroy_revoke_caches();\nrecord_cache_failure:\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "journal_destroy_revoke_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
    "lines": "190-200",
    "snippet": "void journal_destroy_revoke_caches(void)\n{\n\tif (revoke_record_cache) {\n\t\tkmem_cache_destroy(revoke_record_cache);\n\t\trevoke_record_cache = NULL;\n\t}\n\tif (revoke_table_cache) {\n\t\tkmem_cache_destroy(revoke_table_cache);\n\t\trevoke_table_cache = NULL;\n\t}\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *revoke_record_cache;",
      "static struct kmem_cache *revoke_table_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "revoke_table_cache"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "revoke_record_cache"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *revoke_record_cache;\nstatic struct kmem_cache *revoke_table_cache;\n\nvoid journal_destroy_revoke_caches(void)\n{\n\tif (revoke_record_cache) {\n\t\tkmem_cache_destroy(revoke_record_cache);\n\t\trevoke_record_cache = NULL;\n\t}\n\tif (revoke_table_cache) {\n\t\tkmem_cache_destroy(revoke_table_cache);\n\t\trevoke_table_cache = NULL;\n\t}\n}"
  },
  {
    "function_name": "find_revoke_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
    "lines": "169-188",
    "snippet": "static struct jbd_revoke_record_s *find_revoke_record(journal_t *journal,\n\t\t\t\t\t\t      unsigned int blocknr)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd_revoke_record_s *record;\n\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\n\tspin_lock(&journal->j_revoke_lock);\n\trecord = (struct jbd_revoke_record_s *) hash_list->next;\n\twhile (&(record->hash) != hash_list) {\n\t\tif (record->blocknr == blocknr) {\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\treturn record;\n\t\t}\n\t\trecord = (struct jbd_revoke_record_s *) record->hash.next;\n\t}\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_revoke_lock"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_revoke_lock"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "journal",
            "blocknr"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "133-138",
          "snippet": "static inline int hash(journal_t *journal, unsigned int block)\n{\n\tstruct jbd_revoke_table_s *table = journal->j_revoke;\n\n\treturn hash_32(block, table->hash_shift);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic inline int hash(journal_t *journal, unsigned int block)\n{\n\tstruct jbd_revoke_table_s *table = journal->j_revoke;\n\n\treturn hash_32(block, table->hash_shift);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct jbd_revoke_record_s *find_revoke_record(journal_t *journal,\n\t\t\t\t\t\t      unsigned int blocknr)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd_revoke_record_s *record;\n\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\n\tspin_lock(&journal->j_revoke_lock);\n\trecord = (struct jbd_revoke_record_s *) hash_list->next;\n\twhile (&(record->hash) != hash_list) {\n\t\tif (record->blocknr == blocknr) {\n\t\t\tspin_unlock(&journal->j_revoke_lock);\n\t\t\treturn record;\n\t\t}\n\t\trecord = (struct jbd_revoke_record_s *) record->hash.next;\n\t}\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn NULL;\n}"
  },
  {
    "function_name": "insert_revoke_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
    "lines": "140-165",
    "snippet": "static int insert_revoke_hash(journal_t *journal, unsigned int blocknr,\n\t\t\t      tid_t seq)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd_revoke_record_s *record;\n\nrepeat:\n\trecord = kmem_cache_alloc(revoke_record_cache, GFP_NOFS);\n\tif (!record)\n\t\tgoto oom;\n\n\trecord->sequence = seq;\n\trecord->blocknr = blocknr;\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\tspin_lock(&journal->j_revoke_lock);\n\tlist_add(&record->hash, hash_list);\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn 0;\n\noom:\n\tif (!journal_oom_retry)\n\t\treturn -ENOMEM;\n\tjbd_debug(1, \"ENOMEM in %s, retrying\\n\", __func__);\n\tyield();\n\tgoto repeat;\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *revoke_record_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "yield",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"ENOMEM in %s, retrying\\n\"",
            "__func__"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_revoke_lock"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&record->hash",
            "hash_list"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "__blist_add_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1524-1537",
          "snippet": "static inline void\n__blist_add_buffer(struct journal_head **list, struct journal_head *jh)\n{\n\tif (!*list) {\n\t\tjh->b_tnext = jh->b_tprev = jh;\n\t\t*list = jh;\n\t} else {\n\t\t/* Insert at the tail of the list to preserve order */\n\t\tstruct journal_head *first = *list, *last = first->b_tprev;\n\t\tjh->b_tprev = last;\n\t\tjh->b_tnext = first;\n\t\tlast->b_tnext = first->b_tprev = jh;\n\t}\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nstatic inline void\n__blist_add_buffer(struct journal_head **list, struct journal_head *jh)\n{\n\tif (!*list) {\n\t\tjh->b_tnext = jh->b_tprev = jh;\n\t\t*list = jh;\n\t} else {\n\t\t/* Insert at the tail of the list to preserve order */\n\t\tstruct journal_head *first = *list, *last = first->b_tprev;\n\t\tjh->b_tprev = last;\n\t\tjh->b_tnext = first;\n\t\tlast->b_tnext = first->b_tprev = jh;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_revoke_lock"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "journal",
            "blocknr"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "133-138",
          "snippet": "static inline int hash(journal_t *journal, unsigned int block)\n{\n\tstruct jbd_revoke_table_s *table = journal->j_revoke;\n\n\treturn hash_32(block, table->hash_shift);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic inline int hash(journal_t *journal, unsigned int block)\n{\n\tstruct jbd_revoke_table_s *table = journal->j_revoke;\n\n\treturn hash_32(block, table->hash_shift);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "revoke_record_cache",
            "GFP_NOFS"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *revoke_record_cache;\n\nstatic int insert_revoke_hash(journal_t *journal, unsigned int blocknr,\n\t\t\t      tid_t seq)\n{\n\tstruct list_head *hash_list;\n\tstruct jbd_revoke_record_s *record;\n\nrepeat:\n\trecord = kmem_cache_alloc(revoke_record_cache, GFP_NOFS);\n\tif (!record)\n\t\tgoto oom;\n\n\trecord->sequence = seq;\n\trecord->blocknr = blocknr;\n\thash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];\n\tspin_lock(&journal->j_revoke_lock);\n\tlist_add(&record->hash, hash_list);\n\tspin_unlock(&journal->j_revoke_lock);\n\treturn 0;\n\noom:\n\tif (!journal_oom_retry)\n\t\treturn -ENOMEM;\n\tjbd_debug(1, \"ENOMEM in %s, retrying\\n\", __func__);\n\tyield();\n\tgoto repeat;\n}"
  },
  {
    "function_name": "hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
    "lines": "133-138",
    "snippet": "static inline int hash(journal_t *journal, unsigned int block)\n{\n\tstruct jbd_revoke_table_s *table = journal->j_revoke;\n\n\treturn hash_32(block, table->hash_shift);\n}",
    "includes": [
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/bio.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_32",
          "args": [
            "block",
            "table->hash_shift"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic inline int hash(journal_t *journal, unsigned int block)\n{\n\tstruct jbd_revoke_table_s *table = journal->j_revoke;\n\n\treturn hash_32(block, table->hash_shift);\n}"
  }
]