[
  {
    "function_name": "fscache_op_work_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
    "lines": "513-529",
    "snippet": "void fscache_op_work_func(struct work_struct *work)\n{\n\tstruct fscache_operation *op =\n\t\tcontainer_of(work, struct fscache_operation, work);\n\tunsigned long start;\n\n\t_enter(\"{OBJ%x OP%x,%d}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERT(op->processor != NULL);\n\tstart = jiffies;\n\top->processor(op);\n\tfscache_hist(fscache_ops_histogram, start);\n\tfscache_put_operation(op);\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_put_operation",
          "args": [
            "op"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_put_operation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "398-455",
          "snippet": "void fscache_put_operation(struct fscache_operation *op)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\n\t_enter(\"{OBJ%x OP%x,%d}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tif (!atomic_dec_and_test(&op->usage))\n\t\treturn;\n\n\t_debug(\"PUT OP\");\n\tASSERTIFCMP(op->state != FSCACHE_OP_ST_COMPLETE,\n\t\t    op->state, ==, FSCACHE_OP_ST_CANCELLED);\n\top->state = FSCACHE_OP_ST_DEAD;\n\n\tfscache_stat(&fscache_n_op_release);\n\n\tif (op->release) {\n\t\top->release(op);\n\t\top->release = NULL;\n\t}\n\n\tobject = op->object;\n\n\tif (test_bit(FSCACHE_OP_DEC_READ_CNT, &op->flags))\n\t\tatomic_dec(&object->n_reads);\n\tif (test_bit(FSCACHE_OP_UNUSE_COOKIE, &op->flags))\n\t\tfscache_unuse_cookie(object);\n\n\t/* now... we may get called with the object spinlock held, so we\n\t * complete the cleanup here only if we can immediately acquire the\n\t * lock, and defer it otherwise */\n\tif (!spin_trylock(&object->lock)) {\n\t\t_debug(\"defer put\");\n\t\tfscache_stat(&fscache_n_op_deferred_release);\n\n\t\tcache = object->cache;\n\t\tspin_lock(&cache->op_gc_list_lock);\n\t\tlist_add_tail(&op->pend_link, &cache->op_gc_list);\n\t\tspin_unlock(&cache->op_gc_list_lock);\n\t\tschedule_work(&cache->op_gc);\n\t\t_leave(\" [defer]\");\n\t\treturn;\n\t}\n\n\tASSERTCMP(object->n_ops, >, 0);\n\tobject->n_ops--;\n\tif (object->n_ops == 0)\n\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_CLEARED);\n\n\tspin_unlock(&object->lock);\n\n\tkfree(op);\n\t_leave(\" [done]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_put_operation(struct fscache_operation *op)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\n\t_enter(\"{OBJ%x OP%x,%d}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tif (!atomic_dec_and_test(&op->usage))\n\t\treturn;\n\n\t_debug(\"PUT OP\");\n\tASSERTIFCMP(op->state != FSCACHE_OP_ST_COMPLETE,\n\t\t    op->state, ==, FSCACHE_OP_ST_CANCELLED);\n\top->state = FSCACHE_OP_ST_DEAD;\n\n\tfscache_stat(&fscache_n_op_release);\n\n\tif (op->release) {\n\t\top->release(op);\n\t\top->release = NULL;\n\t}\n\n\tobject = op->object;\n\n\tif (test_bit(FSCACHE_OP_DEC_READ_CNT, &op->flags))\n\t\tatomic_dec(&object->n_reads);\n\tif (test_bit(FSCACHE_OP_UNUSE_COOKIE, &op->flags))\n\t\tfscache_unuse_cookie(object);\n\n\t/* now... we may get called with the object spinlock held, so we\n\t * complete the cleanup here only if we can immediately acquire the\n\t * lock, and defer it otherwise */\n\tif (!spin_trylock(&object->lock)) {\n\t\t_debug(\"defer put\");\n\t\tfscache_stat(&fscache_n_op_deferred_release);\n\n\t\tcache = object->cache;\n\t\tspin_lock(&cache->op_gc_list_lock);\n\t\tlist_add_tail(&op->pend_link, &cache->op_gc_list);\n\t\tspin_unlock(&cache->op_gc_list_lock);\n\t\tschedule_work(&cache->op_gc);\n\t\t_leave(\" [defer]\");\n\t\treturn;\n\t}\n\n\tASSERTCMP(object->n_ops, >, 0);\n\tobject->n_ops--;\n\tif (object->n_ops == 0)\n\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_CLEARED);\n\n\tspin_unlock(&object->lock);\n\n\tkfree(op);\n\t_leave(\" [done]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_hist",
          "args": [
            "fscache_ops_histogram",
            "start"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_hist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "70-76",
          "snippet": "static inline void fscache_hist(atomic_t histogram[], unsigned long start_jif)\n{\n\tunsigned long jif = jiffies - start_jif;\n\tif (jif >= HZ)\n\t\tjif = HZ - 1;\n\tatomic_inc(&histogram[jif]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_hist(atomic_t histogram[], unsigned long start_jif)\n{\n\tunsigned long jif = jiffies - start_jif;\n\tif (jif >= HZ)\n\t\tjif = HZ - 1;\n\tatomic_inc(&histogram[jif]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "op->processor",
          "args": [
            "op"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "op->processor != NULL"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x OP%x,%d}\"",
            "op->object->debug_id",
            "op->debug_id",
            "atomic_read(&op->usage)"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&op->usage"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structfscache_operation",
            "work"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_op_work_func(struct work_struct *work)\n{\n\tstruct fscache_operation *op =\n\t\tcontainer_of(work, struct fscache_operation, work);\n\tunsigned long start;\n\n\t_enter(\"{OBJ%x OP%x,%d}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERT(op->processor != NULL);\n\tstart = jiffies;\n\top->processor(op);\n\tfscache_hist(fscache_ops_histogram, start);\n\tfscache_put_operation(op);\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "fscache_operation_gc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
    "lines": "461-507",
    "snippet": "void fscache_operation_gc(struct work_struct *work)\n{\n\tstruct fscache_operation *op;\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache =\n\t\tcontainer_of(work, struct fscache_cache, op_gc);\n\tint count = 0;\n\n\t_enter(\"\");\n\n\tdo {\n\t\tspin_lock(&cache->op_gc_list_lock);\n\t\tif (list_empty(&cache->op_gc_list)) {\n\t\t\tspin_unlock(&cache->op_gc_list_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\top = list_entry(cache->op_gc_list.next,\n\t\t\t\tstruct fscache_operation, pend_link);\n\t\tlist_del(&op->pend_link);\n\t\tspin_unlock(&cache->op_gc_list_lock);\n\n\t\tobject = op->object;\n\t\tspin_lock(&object->lock);\n\n\t\t_debug(\"GC DEFERRED REL OBJ%x OP%x\",\n\t\t       object->debug_id, op->debug_id);\n\t\tfscache_stat(&fscache_n_op_gc);\n\n\t\tASSERTCMP(atomic_read(&op->usage), ==, 0);\n\t\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_DEAD);\n\n\t\tASSERTCMP(object->n_ops, >, 0);\n\t\tobject->n_ops--;\n\t\tif (object->n_ops == 0)\n\t\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_CLEARED);\n\n\t\tspin_unlock(&object->lock);\n\t\tkfree(op);\n\n\t} while (count++ < 20);\n\n\tif (!list_empty(&cache->op_gc_list))\n\t\tschedule_work(&cache->op_gc);\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&cache->op_gc"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_write_schedule_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "755-771",
          "snippet": "static void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */",
            "#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */"
          ],
          "globals_used": [
            "static void nfs_direct_write_schedule_work(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work);\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cache->op_gc_list"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "op"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&object->lock"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_raise_event",
          "args": [
            "object",
            "FSCACHE_OBJECT_EV_CLEARED"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_raise_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "299-310",
          "snippet": "static inline void fscache_raise_event(struct fscache_object *object,\n\t\t\t\t       unsigned event)\n{\n\tBUG_ON(event >= NR_FSCACHE_OBJECT_EVENTS);\n#if 0\n\tprintk(\"*** fscache_raise_event(OBJ%d{%lx},%x)\\n\",\n\t       object->debug_id, object->event_mask, (1 << event));\n#endif\n\tif (!test_and_set_bit(event, &object->events) &&\n\t    test_bit(event, &object->event_mask))\n\t\tfscache_enqueue_object(object);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void fscache_enqueue_object(struct fscache_object *);",
            "extern void fscache_cancel_all_ops(struct fscache_object *);",
            "extern void fscache_abort_object(struct fscache_object *);",
            "extern void fscache_start_operations(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern void fscache_enqueue_object(struct fscache_object *);\nextern void fscache_cancel_all_ops(struct fscache_object *);\nextern void fscache_abort_object(struct fscache_object *);\nextern void fscache_start_operations(struct fscache_object *);\n\nstatic inline void fscache_raise_event(struct fscache_object *object,\n\t\t\t\t       unsigned event)\n{\n\tBUG_ON(event >= NR_FSCACHE_OBJECT_EVENTS);\n#if 0\n\tprintk(\"*** fscache_raise_event(OBJ%d{%lx},%x)\\n\",\n\t       object->debug_id, object->event_mask, (1 << event));\n#endif\n\tif (!test_and_set_bit(event, &object->events) &&\n\t    test_bit(event, &object->event_mask))\n\t\tfscache_enqueue_object(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "object->n_ops",
            ">,0"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "op->state",
            "==,FSCACHE_OP_ST_DEAD"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "atomic_read(&op->usage)",
            "==,0"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&op->usage"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_op_gc"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"GC DEFERRED REL OBJ%x OP%x\"",
            "object->debug_id",
            "op->debug_id"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&object->lock"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&op->pend_link"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "cache->op_gc_list.next",
            "structfscache_operation",
            "pend_link"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structfscache_cache",
            "op_gc"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_operation_gc(struct work_struct *work)\n{\n\tstruct fscache_operation *op;\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache =\n\t\tcontainer_of(work, struct fscache_cache, op_gc);\n\tint count = 0;\n\n\t_enter(\"\");\n\n\tdo {\n\t\tspin_lock(&cache->op_gc_list_lock);\n\t\tif (list_empty(&cache->op_gc_list)) {\n\t\t\tspin_unlock(&cache->op_gc_list_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\top = list_entry(cache->op_gc_list.next,\n\t\t\t\tstruct fscache_operation, pend_link);\n\t\tlist_del(&op->pend_link);\n\t\tspin_unlock(&cache->op_gc_list_lock);\n\n\t\tobject = op->object;\n\t\tspin_lock(&object->lock);\n\n\t\t_debug(\"GC DEFERRED REL OBJ%x OP%x\",\n\t\t       object->debug_id, op->debug_id);\n\t\tfscache_stat(&fscache_n_op_gc);\n\n\t\tASSERTCMP(atomic_read(&op->usage), ==, 0);\n\t\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_DEAD);\n\n\t\tASSERTCMP(object->n_ops, >, 0);\n\t\tobject->n_ops--;\n\t\tif (object->n_ops == 0)\n\t\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_CLEARED);\n\n\t\tspin_unlock(&object->lock);\n\t\tkfree(op);\n\n\t} while (count++ < 20);\n\n\tif (!list_empty(&cache->op_gc_list))\n\t\tschedule_work(&cache->op_gc);\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "fscache_put_operation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
    "lines": "398-455",
    "snippet": "void fscache_put_operation(struct fscache_operation *op)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\n\t_enter(\"{OBJ%x OP%x,%d}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tif (!atomic_dec_and_test(&op->usage))\n\t\treturn;\n\n\t_debug(\"PUT OP\");\n\tASSERTIFCMP(op->state != FSCACHE_OP_ST_COMPLETE,\n\t\t    op->state, ==, FSCACHE_OP_ST_CANCELLED);\n\top->state = FSCACHE_OP_ST_DEAD;\n\n\tfscache_stat(&fscache_n_op_release);\n\n\tif (op->release) {\n\t\top->release(op);\n\t\top->release = NULL;\n\t}\n\n\tobject = op->object;\n\n\tif (test_bit(FSCACHE_OP_DEC_READ_CNT, &op->flags))\n\t\tatomic_dec(&object->n_reads);\n\tif (test_bit(FSCACHE_OP_UNUSE_COOKIE, &op->flags))\n\t\tfscache_unuse_cookie(object);\n\n\t/* now... we may get called with the object spinlock held, so we\n\t * complete the cleanup here only if we can immediately acquire the\n\t * lock, and defer it otherwise */\n\tif (!spin_trylock(&object->lock)) {\n\t\t_debug(\"defer put\");\n\t\tfscache_stat(&fscache_n_op_deferred_release);\n\n\t\tcache = object->cache;\n\t\tspin_lock(&cache->op_gc_list_lock);\n\t\tlist_add_tail(&op->pend_link, &cache->op_gc_list);\n\t\tspin_unlock(&cache->op_gc_list_lock);\n\t\tschedule_work(&cache->op_gc);\n\t\t_leave(\" [defer]\");\n\t\treturn;\n\t}\n\n\tASSERTCMP(object->n_ops, >, 0);\n\tobject->n_ops--;\n\tif (object->n_ops == 0)\n\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_CLEARED);\n\n\tspin_unlock(&object->lock);\n\n\tkfree(op);\n\t_leave(\" [done]\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" [done]\""
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "op"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&object->lock"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_raise_event",
          "args": [
            "object",
            "FSCACHE_OBJECT_EV_CLEARED"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_raise_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "299-310",
          "snippet": "static inline void fscache_raise_event(struct fscache_object *object,\n\t\t\t\t       unsigned event)\n{\n\tBUG_ON(event >= NR_FSCACHE_OBJECT_EVENTS);\n#if 0\n\tprintk(\"*** fscache_raise_event(OBJ%d{%lx},%x)\\n\",\n\t       object->debug_id, object->event_mask, (1 << event));\n#endif\n\tif (!test_and_set_bit(event, &object->events) &&\n\t    test_bit(event, &object->event_mask))\n\t\tfscache_enqueue_object(object);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void fscache_enqueue_object(struct fscache_object *);",
            "extern void fscache_cancel_all_ops(struct fscache_object *);",
            "extern void fscache_abort_object(struct fscache_object *);",
            "extern void fscache_start_operations(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern void fscache_enqueue_object(struct fscache_object *);\nextern void fscache_cancel_all_ops(struct fscache_object *);\nextern void fscache_abort_object(struct fscache_object *);\nextern void fscache_start_operations(struct fscache_object *);\n\nstatic inline void fscache_raise_event(struct fscache_object *object,\n\t\t\t\t       unsigned event)\n{\n\tBUG_ON(event >= NR_FSCACHE_OBJECT_EVENTS);\n#if 0\n\tprintk(\"*** fscache_raise_event(OBJ%d{%lx},%x)\\n\",\n\t       object->debug_id, object->event_mask, (1 << event));\n#endif\n\tif (!test_and_set_bit(event, &object->events) &&\n\t    test_bit(event, &object->event_mask))\n\t\tfscache_enqueue_object(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "object->n_ops",
            ">,0"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&cache->op_gc"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_write_schedule_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "755-771",
          "snippet": "static void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */",
            "#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */"
          ],
          "globals_used": [
            "static void nfs_direct_write_schedule_work(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work);\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&op->pend_link",
            "&cache->op_gc_list"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cache->op_gc_list_lock"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_op_deferred_release"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"defer put\""
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_trylock",
          "args": [
            "&object->lock"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_unuse_cookie",
          "args": [
            "object"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "FSCACHE_OP_UNUSE_COOKIE",
            "&op->flags"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&object->n_reads"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op->release",
          "args": [
            "op"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTIFCMP",
          "args": [
            "op->state != FSCACHE_OP_ST_COMPLETE",
            "op->state",
            "==,FSCACHE_OP_ST_CANCELLED"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&op->usage"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "atomic_read(&op->usage)",
            ">,0"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&op->usage"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x OP%x,%d}\"",
            "op->object->debug_id",
            "op->debug_id",
            "atomic_read(&op->usage)"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&op->usage"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_put_operation(struct fscache_operation *op)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\n\t_enter(\"{OBJ%x OP%x,%d}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tif (!atomic_dec_and_test(&op->usage))\n\t\treturn;\n\n\t_debug(\"PUT OP\");\n\tASSERTIFCMP(op->state != FSCACHE_OP_ST_COMPLETE,\n\t\t    op->state, ==, FSCACHE_OP_ST_CANCELLED);\n\top->state = FSCACHE_OP_ST_DEAD;\n\n\tfscache_stat(&fscache_n_op_release);\n\n\tif (op->release) {\n\t\top->release(op);\n\t\top->release = NULL;\n\t}\n\n\tobject = op->object;\n\n\tif (test_bit(FSCACHE_OP_DEC_READ_CNT, &op->flags))\n\t\tatomic_dec(&object->n_reads);\n\tif (test_bit(FSCACHE_OP_UNUSE_COOKIE, &op->flags))\n\t\tfscache_unuse_cookie(object);\n\n\t/* now... we may get called with the object spinlock held, so we\n\t * complete the cleanup here only if we can immediately acquire the\n\t * lock, and defer it otherwise */\n\tif (!spin_trylock(&object->lock)) {\n\t\t_debug(\"defer put\");\n\t\tfscache_stat(&fscache_n_op_deferred_release);\n\n\t\tcache = object->cache;\n\t\tspin_lock(&cache->op_gc_list_lock);\n\t\tlist_add_tail(&op->pend_link, &cache->op_gc_list);\n\t\tspin_unlock(&cache->op_gc_list_lock);\n\t\tschedule_work(&cache->op_gc);\n\t\t_leave(\" [defer]\");\n\t\treturn;\n\t}\n\n\tASSERTCMP(object->n_ops, >, 0);\n\tobject->n_ops--;\n\tif (object->n_ops == 0)\n\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_CLEARED);\n\n\tspin_unlock(&object->lock);\n\n\tkfree(op);\n\t_leave(\" [done]\");\n}"
  },
  {
    "function_name": "fscache_op_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
    "lines": "365-391",
    "snippet": "void fscache_op_complete(struct fscache_operation *op, bool cancelled)\n{\n\tstruct fscache_object *object = op->object;\n\n\t_enter(\"OBJ%x\", object->debug_id);\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_IN_PROGRESS);\n\tASSERTCMP(object->n_in_progress, >, 0);\n\tASSERTIFCMP(test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags),\n\t\t    object->n_exclusive, >, 0);\n\tASSERTIFCMP(test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags),\n\t\t    object->n_in_progress, ==, 1);\n\n\tspin_lock(&object->lock);\n\n\top->state = cancelled ?\n\t\tFSCACHE_OP_ST_CANCELLED : FSCACHE_OP_ST_COMPLETE;\n\n\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))\n\t\tobject->n_exclusive--;\n\tobject->n_in_progress--;\n\tif (object->n_in_progress == 0)\n\t\tfscache_start_operations(object);\n\n\tspin_unlock(&object->lock);\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&object->lock"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_start_operations",
          "args": [
            "object"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_start_operations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "265-290",
          "snippet": "void fscache_start_operations(struct fscache_object *object)\n{\n\tstruct fscache_operation *op;\n\tbool stop = false;\n\n\twhile (!list_empty(&object->pending_ops) && !stop) {\n\t\top = list_entry(object->pending_ops.next,\n\t\t\t\tstruct fscache_operation, pend_link);\n\n\t\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags)) {\n\t\t\tif (object->n_in_progress > 0)\n\t\t\t\tbreak;\n\t\t\tstop = true;\n\t\t}\n\t\tlist_del_init(&op->pend_link);\n\t\tfscache_run_op(object, op);\n\n\t\t/* the pending queue was holding a ref on the object */\n\t\tfscache_put_operation(op);\n\t}\n\n\tASSERTCMP(object->n_in_progress, <=, object->n_ops);\n\n\t_debug(\"woke %d ops on OBJ%x\",\n\t       object->n_in_progress, object->debug_id);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_start_operations(struct fscache_object *object)\n{\n\tstruct fscache_operation *op;\n\tbool stop = false;\n\n\twhile (!list_empty(&object->pending_ops) && !stop) {\n\t\top = list_entry(object->pending_ops.next,\n\t\t\t\tstruct fscache_operation, pend_link);\n\n\t\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags)) {\n\t\t\tif (object->n_in_progress > 0)\n\t\t\t\tbreak;\n\t\t\tstop = true;\n\t\t}\n\t\tlist_del_init(&op->pend_link);\n\t\tfscache_run_op(object, op);\n\n\t\t/* the pending queue was holding a ref on the object */\n\t\tfscache_put_operation(op);\n\t}\n\n\tASSERTCMP(object->n_in_progress, <=, object->n_ops);\n\n\t_debug(\"woke %d ops on OBJ%x\",\n\t       object->n_in_progress, object->debug_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "FSCACHE_OP_EXCLUSIVE",
            "&op->flags"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&object->lock"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTIFCMP",
          "args": [
            "test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags)",
            "object->n_in_progress",
            "==,1"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTIFCMP",
          "args": [
            "test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags)",
            "object->n_exclusive",
            ">,0"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "object->n_in_progress",
            ">,0"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "op->state",
            "==,FSCACHE_OP_ST_IN_PROGRESS"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"OBJ%x\"",
            "object->debug_id"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_op_complete(struct fscache_operation *op, bool cancelled)\n{\n\tstruct fscache_object *object = op->object;\n\n\t_enter(\"OBJ%x\", object->debug_id);\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_IN_PROGRESS);\n\tASSERTCMP(object->n_in_progress, >, 0);\n\tASSERTIFCMP(test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags),\n\t\t    object->n_exclusive, >, 0);\n\tASSERTIFCMP(test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags),\n\t\t    object->n_in_progress, ==, 1);\n\n\tspin_lock(&object->lock);\n\n\top->state = cancelled ?\n\t\tFSCACHE_OP_ST_CANCELLED : FSCACHE_OP_ST_COMPLETE;\n\n\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))\n\t\tobject->n_exclusive--;\n\tobject->n_in_progress--;\n\tif (object->n_in_progress == 0)\n\t\tfscache_start_operations(object);\n\n\tspin_unlock(&object->lock);\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "fscache_cancel_all_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
    "lines": "333-360",
    "snippet": "void fscache_cancel_all_ops(struct fscache_object *object)\n{\n\tstruct fscache_operation *op;\n\n\t_enter(\"OBJ%x\", object->debug_id);\n\n\tspin_lock(&object->lock);\n\n\twhile (!list_empty(&object->pending_ops)) {\n\t\top = list_entry(object->pending_ops.next,\n\t\t\t\tstruct fscache_operation, pend_link);\n\t\tfscache_stat(&fscache_n_op_cancelled);\n\t\tlist_del_init(&op->pend_link);\n\n\t\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_PENDING);\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\n\t\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))\n\t\t\tobject->n_exclusive--;\n\t\tif (test_and_clear_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\t\twake_up_bit(&op->flags, FSCACHE_OP_WAITING);\n\t\tfscache_put_operation(op);\n\t\tcond_resched_lock(&object->lock);\n\t}\n\n\tspin_unlock(&object->lock);\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&object->lock"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched_lock",
          "args": [
            "&object->lock"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_put_operation",
          "args": [
            "op"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_put_operation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "398-455",
          "snippet": "void fscache_put_operation(struct fscache_operation *op)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\n\t_enter(\"{OBJ%x OP%x,%d}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tif (!atomic_dec_and_test(&op->usage))\n\t\treturn;\n\n\t_debug(\"PUT OP\");\n\tASSERTIFCMP(op->state != FSCACHE_OP_ST_COMPLETE,\n\t\t    op->state, ==, FSCACHE_OP_ST_CANCELLED);\n\top->state = FSCACHE_OP_ST_DEAD;\n\n\tfscache_stat(&fscache_n_op_release);\n\n\tif (op->release) {\n\t\top->release(op);\n\t\top->release = NULL;\n\t}\n\n\tobject = op->object;\n\n\tif (test_bit(FSCACHE_OP_DEC_READ_CNT, &op->flags))\n\t\tatomic_dec(&object->n_reads);\n\tif (test_bit(FSCACHE_OP_UNUSE_COOKIE, &op->flags))\n\t\tfscache_unuse_cookie(object);\n\n\t/* now... we may get called with the object spinlock held, so we\n\t * complete the cleanup here only if we can immediately acquire the\n\t * lock, and defer it otherwise */\n\tif (!spin_trylock(&object->lock)) {\n\t\t_debug(\"defer put\");\n\t\tfscache_stat(&fscache_n_op_deferred_release);\n\n\t\tcache = object->cache;\n\t\tspin_lock(&cache->op_gc_list_lock);\n\t\tlist_add_tail(&op->pend_link, &cache->op_gc_list);\n\t\tspin_unlock(&cache->op_gc_list_lock);\n\t\tschedule_work(&cache->op_gc);\n\t\t_leave(\" [defer]\");\n\t\treturn;\n\t}\n\n\tASSERTCMP(object->n_ops, >, 0);\n\tobject->n_ops--;\n\tif (object->n_ops == 0)\n\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_CLEARED);\n\n\tspin_unlock(&object->lock);\n\n\tkfree(op);\n\t_leave(\" [done]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_put_operation(struct fscache_operation *op)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\n\t_enter(\"{OBJ%x OP%x,%d}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tif (!atomic_dec_and_test(&op->usage))\n\t\treturn;\n\n\t_debug(\"PUT OP\");\n\tASSERTIFCMP(op->state != FSCACHE_OP_ST_COMPLETE,\n\t\t    op->state, ==, FSCACHE_OP_ST_CANCELLED);\n\top->state = FSCACHE_OP_ST_DEAD;\n\n\tfscache_stat(&fscache_n_op_release);\n\n\tif (op->release) {\n\t\top->release(op);\n\t\top->release = NULL;\n\t}\n\n\tobject = op->object;\n\n\tif (test_bit(FSCACHE_OP_DEC_READ_CNT, &op->flags))\n\t\tatomic_dec(&object->n_reads);\n\tif (test_bit(FSCACHE_OP_UNUSE_COOKIE, &op->flags))\n\t\tfscache_unuse_cookie(object);\n\n\t/* now... we may get called with the object spinlock held, so we\n\t * complete the cleanup here only if we can immediately acquire the\n\t * lock, and defer it otherwise */\n\tif (!spin_trylock(&object->lock)) {\n\t\t_debug(\"defer put\");\n\t\tfscache_stat(&fscache_n_op_deferred_release);\n\n\t\tcache = object->cache;\n\t\tspin_lock(&cache->op_gc_list_lock);\n\t\tlist_add_tail(&op->pend_link, &cache->op_gc_list);\n\t\tspin_unlock(&cache->op_gc_list_lock);\n\t\tschedule_work(&cache->op_gc);\n\t\t_leave(\" [defer]\");\n\t\treturn;\n\t}\n\n\tASSERTCMP(object->n_ops, >, 0);\n\tobject->n_ops--;\n\tif (object->n_ops == 0)\n\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_CLEARED);\n\n\tspin_unlock(&object->lock);\n\n\tkfree(op);\n\t_leave(\" [done]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&op->flags",
            "FSCACHE_OP_WAITING"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "FSCACHE_OP_WAITING",
            "&op->flags"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "FSCACHE_OP_EXCLUSIVE",
            "&op->flags"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "op->state",
            "==,FSCACHE_OP_ST_PENDING"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&op->pend_link"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_op_cancelled"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "object->pending_ops.next",
            "structfscache_operation",
            "pend_link"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&object->pending_ops"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&object->lock"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"OBJ%x\"",
            "object->debug_id"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_cancel_all_ops(struct fscache_object *object)\n{\n\tstruct fscache_operation *op;\n\n\t_enter(\"OBJ%x\", object->debug_id);\n\n\tspin_lock(&object->lock);\n\n\twhile (!list_empty(&object->pending_ops)) {\n\t\top = list_entry(object->pending_ops.next,\n\t\t\t\tstruct fscache_operation, pend_link);\n\t\tfscache_stat(&fscache_n_op_cancelled);\n\t\tlist_del_init(&op->pend_link);\n\n\t\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_PENDING);\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\n\t\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))\n\t\t\tobject->n_exclusive--;\n\t\tif (test_and_clear_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\t\twake_up_bit(&op->flags, FSCACHE_OP_WAITING);\n\t\tfscache_put_operation(op);\n\t\tcond_resched_lock(&object->lock);\n\t}\n\n\tspin_unlock(&object->lock);\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "fscache_cancel_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
    "lines": "295-328",
    "snippet": "int fscache_cancel_op(struct fscache_operation *op,\n\t\t      void (*do_cancel)(struct fscache_operation *))\n{\n\tstruct fscache_object *object = op->object;\n\tint ret;\n\n\t_enter(\"OBJ%x OP%x}\", op->object->debug_id, op->debug_id);\n\n\tASSERTCMP(op->state, >=, FSCACHE_OP_ST_PENDING);\n\tASSERTCMP(op->state, !=, FSCACHE_OP_ST_CANCELLED);\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tspin_lock(&object->lock);\n\n\tret = -EBUSY;\n\tif (op->state == FSCACHE_OP_ST_PENDING) {\n\t\tASSERT(!list_empty(&op->pend_link));\n\t\tfscache_stat(&fscache_n_op_cancelled);\n\t\tlist_del_init(&op->pend_link);\n\t\tif (do_cancel)\n\t\t\tdo_cancel(op);\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))\n\t\t\tobject->n_exclusive--;\n\t\tif (test_and_clear_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\t\twake_up_bit(&op->flags, FSCACHE_OP_WAITING);\n\t\tfscache_put_operation(op);\n\t\tret = 0;\n\t}\n\n\tspin_unlock(&object->lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&object->lock"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_put_operation",
          "args": [
            "op"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_put_operation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "398-455",
          "snippet": "void fscache_put_operation(struct fscache_operation *op)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\n\t_enter(\"{OBJ%x OP%x,%d}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tif (!atomic_dec_and_test(&op->usage))\n\t\treturn;\n\n\t_debug(\"PUT OP\");\n\tASSERTIFCMP(op->state != FSCACHE_OP_ST_COMPLETE,\n\t\t    op->state, ==, FSCACHE_OP_ST_CANCELLED);\n\top->state = FSCACHE_OP_ST_DEAD;\n\n\tfscache_stat(&fscache_n_op_release);\n\n\tif (op->release) {\n\t\top->release(op);\n\t\top->release = NULL;\n\t}\n\n\tobject = op->object;\n\n\tif (test_bit(FSCACHE_OP_DEC_READ_CNT, &op->flags))\n\t\tatomic_dec(&object->n_reads);\n\tif (test_bit(FSCACHE_OP_UNUSE_COOKIE, &op->flags))\n\t\tfscache_unuse_cookie(object);\n\n\t/* now... we may get called with the object spinlock held, so we\n\t * complete the cleanup here only if we can immediately acquire the\n\t * lock, and defer it otherwise */\n\tif (!spin_trylock(&object->lock)) {\n\t\t_debug(\"defer put\");\n\t\tfscache_stat(&fscache_n_op_deferred_release);\n\n\t\tcache = object->cache;\n\t\tspin_lock(&cache->op_gc_list_lock);\n\t\tlist_add_tail(&op->pend_link, &cache->op_gc_list);\n\t\tspin_unlock(&cache->op_gc_list_lock);\n\t\tschedule_work(&cache->op_gc);\n\t\t_leave(\" [defer]\");\n\t\treturn;\n\t}\n\n\tASSERTCMP(object->n_ops, >, 0);\n\tobject->n_ops--;\n\tif (object->n_ops == 0)\n\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_CLEARED);\n\n\tspin_unlock(&object->lock);\n\n\tkfree(op);\n\t_leave(\" [done]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_put_operation(struct fscache_operation *op)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\n\t_enter(\"{OBJ%x OP%x,%d}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tif (!atomic_dec_and_test(&op->usage))\n\t\treturn;\n\n\t_debug(\"PUT OP\");\n\tASSERTIFCMP(op->state != FSCACHE_OP_ST_COMPLETE,\n\t\t    op->state, ==, FSCACHE_OP_ST_CANCELLED);\n\top->state = FSCACHE_OP_ST_DEAD;\n\n\tfscache_stat(&fscache_n_op_release);\n\n\tif (op->release) {\n\t\top->release(op);\n\t\top->release = NULL;\n\t}\n\n\tobject = op->object;\n\n\tif (test_bit(FSCACHE_OP_DEC_READ_CNT, &op->flags))\n\t\tatomic_dec(&object->n_reads);\n\tif (test_bit(FSCACHE_OP_UNUSE_COOKIE, &op->flags))\n\t\tfscache_unuse_cookie(object);\n\n\t/* now... we may get called with the object spinlock held, so we\n\t * complete the cleanup here only if we can immediately acquire the\n\t * lock, and defer it otherwise */\n\tif (!spin_trylock(&object->lock)) {\n\t\t_debug(\"defer put\");\n\t\tfscache_stat(&fscache_n_op_deferred_release);\n\n\t\tcache = object->cache;\n\t\tspin_lock(&cache->op_gc_list_lock);\n\t\tlist_add_tail(&op->pend_link, &cache->op_gc_list);\n\t\tspin_unlock(&cache->op_gc_list_lock);\n\t\tschedule_work(&cache->op_gc);\n\t\t_leave(\" [defer]\");\n\t\treturn;\n\t}\n\n\tASSERTCMP(object->n_ops, >, 0);\n\tobject->n_ops--;\n\tif (object->n_ops == 0)\n\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_CLEARED);\n\n\tspin_unlock(&object->lock);\n\n\tkfree(op);\n\t_leave(\" [done]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&op->flags",
            "FSCACHE_OP_WAITING"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "FSCACHE_OP_WAITING",
            "&op->flags"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "FSCACHE_OP_EXCLUSIVE",
            "&op->flags"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_cancel",
          "args": [
            "op"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_do_cancel_retrieval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "335-341",
          "snippet": "static void fscache_do_cancel_retrieval(struct fscache_operation *_op)\n{\n\tstruct fscache_retrieval *op =\n\t\tcontainer_of(_op, struct fscache_retrieval, op);\n\n\tatomic_set(&op->n_pages, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nstatic void fscache_do_cancel_retrieval(struct fscache_operation *_op)\n{\n\tstruct fscache_retrieval *op =\n\t\tcontainer_of(_op, struct fscache_retrieval, op);\n\n\tatomic_set(&op->n_pages, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&op->pend_link"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_op_cancelled"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!list_empty(&op->pend_link)"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&op->pend_link"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&object->lock"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "atomic_read(&op->usage)",
            ">,0"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&op->usage"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "op->state",
            "!=, FSCACHE_OP_ST_CANCELLED"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "op->state",
            ">=,FSCACHE_OP_ST_PENDING"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"OBJ%x OP%x}\"",
            "op->object->debug_id",
            "op->debug_id"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nint fscache_cancel_op(struct fscache_operation *op,\n\t\t      void (*do_cancel)(struct fscache_operation *))\n{\n\tstruct fscache_object *object = op->object;\n\tint ret;\n\n\t_enter(\"OBJ%x OP%x}\", op->object->debug_id, op->debug_id);\n\n\tASSERTCMP(op->state, >=, FSCACHE_OP_ST_PENDING);\n\tASSERTCMP(op->state, !=, FSCACHE_OP_ST_CANCELLED);\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tspin_lock(&object->lock);\n\n\tret = -EBUSY;\n\tif (op->state == FSCACHE_OP_ST_PENDING) {\n\t\tASSERT(!list_empty(&op->pend_link));\n\t\tfscache_stat(&fscache_n_op_cancelled);\n\t\tlist_del_init(&op->pend_link);\n\t\tif (do_cancel)\n\t\t\tdo_cancel(op);\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))\n\t\t\tobject->n_exclusive--;\n\t\tif (test_and_clear_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\t\twake_up_bit(&op->flags, FSCACHE_OP_WAITING);\n\t\tfscache_put_operation(op);\n\t\tret = 0;\n\t}\n\n\tspin_unlock(&object->lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "fscache_start_operations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
    "lines": "265-290",
    "snippet": "void fscache_start_operations(struct fscache_object *object)\n{\n\tstruct fscache_operation *op;\n\tbool stop = false;\n\n\twhile (!list_empty(&object->pending_ops) && !stop) {\n\t\top = list_entry(object->pending_ops.next,\n\t\t\t\tstruct fscache_operation, pend_link);\n\n\t\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags)) {\n\t\t\tif (object->n_in_progress > 0)\n\t\t\t\tbreak;\n\t\t\tstop = true;\n\t\t}\n\t\tlist_del_init(&op->pend_link);\n\t\tfscache_run_op(object, op);\n\n\t\t/* the pending queue was holding a ref on the object */\n\t\tfscache_put_operation(op);\n\t}\n\n\tASSERTCMP(object->n_in_progress, <=, object->n_ops);\n\n\t_debug(\"woke %d ops on OBJ%x\",\n\t       object->n_in_progress, object->debug_id);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"woke %d ops on OBJ%x\"",
            "object->n_in_progress",
            "object->debug_id"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "object->n_in_progress",
            "<=,object->n_ops"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_put_operation",
          "args": [
            "op"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_put_operation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "398-455",
          "snippet": "void fscache_put_operation(struct fscache_operation *op)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\n\t_enter(\"{OBJ%x OP%x,%d}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tif (!atomic_dec_and_test(&op->usage))\n\t\treturn;\n\n\t_debug(\"PUT OP\");\n\tASSERTIFCMP(op->state != FSCACHE_OP_ST_COMPLETE,\n\t\t    op->state, ==, FSCACHE_OP_ST_CANCELLED);\n\top->state = FSCACHE_OP_ST_DEAD;\n\n\tfscache_stat(&fscache_n_op_release);\n\n\tif (op->release) {\n\t\top->release(op);\n\t\top->release = NULL;\n\t}\n\n\tobject = op->object;\n\n\tif (test_bit(FSCACHE_OP_DEC_READ_CNT, &op->flags))\n\t\tatomic_dec(&object->n_reads);\n\tif (test_bit(FSCACHE_OP_UNUSE_COOKIE, &op->flags))\n\t\tfscache_unuse_cookie(object);\n\n\t/* now... we may get called with the object spinlock held, so we\n\t * complete the cleanup here only if we can immediately acquire the\n\t * lock, and defer it otherwise */\n\tif (!spin_trylock(&object->lock)) {\n\t\t_debug(\"defer put\");\n\t\tfscache_stat(&fscache_n_op_deferred_release);\n\n\t\tcache = object->cache;\n\t\tspin_lock(&cache->op_gc_list_lock);\n\t\tlist_add_tail(&op->pend_link, &cache->op_gc_list);\n\t\tspin_unlock(&cache->op_gc_list_lock);\n\t\tschedule_work(&cache->op_gc);\n\t\t_leave(\" [defer]\");\n\t\treturn;\n\t}\n\n\tASSERTCMP(object->n_ops, >, 0);\n\tobject->n_ops--;\n\tif (object->n_ops == 0)\n\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_CLEARED);\n\n\tspin_unlock(&object->lock);\n\n\tkfree(op);\n\t_leave(\" [done]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_put_operation(struct fscache_operation *op)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\n\t_enter(\"{OBJ%x OP%x,%d}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tif (!atomic_dec_and_test(&op->usage))\n\t\treturn;\n\n\t_debug(\"PUT OP\");\n\tASSERTIFCMP(op->state != FSCACHE_OP_ST_COMPLETE,\n\t\t    op->state, ==, FSCACHE_OP_ST_CANCELLED);\n\top->state = FSCACHE_OP_ST_DEAD;\n\n\tfscache_stat(&fscache_n_op_release);\n\n\tif (op->release) {\n\t\top->release(op);\n\t\top->release = NULL;\n\t}\n\n\tobject = op->object;\n\n\tif (test_bit(FSCACHE_OP_DEC_READ_CNT, &op->flags))\n\t\tatomic_dec(&object->n_reads);\n\tif (test_bit(FSCACHE_OP_UNUSE_COOKIE, &op->flags))\n\t\tfscache_unuse_cookie(object);\n\n\t/* now... we may get called with the object spinlock held, so we\n\t * complete the cleanup here only if we can immediately acquire the\n\t * lock, and defer it otherwise */\n\tif (!spin_trylock(&object->lock)) {\n\t\t_debug(\"defer put\");\n\t\tfscache_stat(&fscache_n_op_deferred_release);\n\n\t\tcache = object->cache;\n\t\tspin_lock(&cache->op_gc_list_lock);\n\t\tlist_add_tail(&op->pend_link, &cache->op_gc_list);\n\t\tspin_unlock(&cache->op_gc_list_lock);\n\t\tschedule_work(&cache->op_gc);\n\t\t_leave(\" [defer]\");\n\t\treturn;\n\t}\n\n\tASSERTCMP(object->n_ops, >, 0);\n\tobject->n_ops--;\n\tif (object->n_ops == 0)\n\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_CLEARED);\n\n\tspin_unlock(&object->lock);\n\n\tkfree(op);\n\t_leave(\" [done]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_run_op",
          "args": [
            "object",
            "op"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_run_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "64-76",
          "snippet": "static void fscache_run_op(struct fscache_object *object,\n\t\t\t   struct fscache_operation *op)\n{\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_PENDING);\n\n\top->state = FSCACHE_OP_ST_IN_PROGRESS;\n\tobject->n_in_progress++;\n\tif (test_and_clear_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\twake_up_bit(&op->flags, FSCACHE_OP_WAITING);\n\tif (op->processor)\n\t\tfscache_enqueue_operation(op);\n\tfscache_stat(&fscache_n_op_run);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nstatic void fscache_run_op(struct fscache_object *object,\n\t\t\t   struct fscache_operation *op)\n{\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_PENDING);\n\n\top->state = FSCACHE_OP_ST_IN_PROGRESS;\n\tobject->n_in_progress++;\n\tif (test_and_clear_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\twake_up_bit(&op->flags, FSCACHE_OP_WAITING);\n\tif (op->processor)\n\t\tfscache_enqueue_operation(op);\n\tfscache_stat(&fscache_n_op_run);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&op->pend_link"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "FSCACHE_OP_EXCLUSIVE",
            "&op->flags"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "object->pending_ops.next",
            "structfscache_operation",
            "pend_link"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&object->pending_ops"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_start_operations(struct fscache_object *object)\n{\n\tstruct fscache_operation *op;\n\tbool stop = false;\n\n\twhile (!list_empty(&object->pending_ops) && !stop) {\n\t\top = list_entry(object->pending_ops.next,\n\t\t\t\tstruct fscache_operation, pend_link);\n\n\t\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags)) {\n\t\t\tif (object->n_in_progress > 0)\n\t\t\t\tbreak;\n\t\t\tstop = true;\n\t\t}\n\t\tlist_del_init(&op->pend_link);\n\t\tfscache_run_op(object, op);\n\n\t\t/* the pending queue was holding a ref on the object */\n\t\tfscache_put_operation(op);\n\t}\n\n\tASSERTCMP(object->n_in_progress, <=, object->n_ops);\n\n\t_debug(\"woke %d ops on OBJ%x\",\n\t       object->n_in_progress, object->debug_id);\n}"
  },
  {
    "function_name": "fscache_abort_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
    "lines": "254-259",
    "snippet": "void fscache_abort_object(struct fscache_object *object)\n{\n\t_enter(\"{OBJ%x}\", object->debug_id);\n\n\tfscache_raise_event(object, FSCACHE_OBJECT_EV_ERROR);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_raise_event",
          "args": [
            "object",
            "FSCACHE_OBJECT_EV_ERROR"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_raise_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "299-310",
          "snippet": "static inline void fscache_raise_event(struct fscache_object *object,\n\t\t\t\t       unsigned event)\n{\n\tBUG_ON(event >= NR_FSCACHE_OBJECT_EVENTS);\n#if 0\n\tprintk(\"*** fscache_raise_event(OBJ%d{%lx},%x)\\n\",\n\t       object->debug_id, object->event_mask, (1 << event));\n#endif\n\tif (!test_and_set_bit(event, &object->events) &&\n\t    test_bit(event, &object->event_mask))\n\t\tfscache_enqueue_object(object);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void fscache_enqueue_object(struct fscache_object *);",
            "extern void fscache_cancel_all_ops(struct fscache_object *);",
            "extern void fscache_abort_object(struct fscache_object *);",
            "extern void fscache_start_operations(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern void fscache_enqueue_object(struct fscache_object *);\nextern void fscache_cancel_all_ops(struct fscache_object *);\nextern void fscache_abort_object(struct fscache_object *);\nextern void fscache_start_operations(struct fscache_object *);\n\nstatic inline void fscache_raise_event(struct fscache_object *object,\n\t\t\t\t       unsigned event)\n{\n\tBUG_ON(event >= NR_FSCACHE_OBJECT_EVENTS);\n#if 0\n\tprintk(\"*** fscache_raise_event(OBJ%d{%lx},%x)\\n\",\n\t       object->debug_id, object->event_mask, (1 << event));\n#endif\n\tif (!test_and_set_bit(event, &object->events) &&\n\t    test_bit(event, &object->event_mask))\n\t\tfscache_enqueue_object(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x}\"",
            "object->debug_id"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_abort_object(struct fscache_object *object)\n{\n\t_enter(\"{OBJ%x}\", object->debug_id);\n\n\tfscache_raise_event(object, FSCACHE_OBJECT_EV_ERROR);\n}"
  },
  {
    "function_name": "fscache_submit_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
    "lines": "186-248",
    "snippet": "int fscache_submit_op(struct fscache_object *object,\n\t\t      struct fscache_operation *op)\n{\n\tconst struct fscache_state *ostate;\n\tint ret;\n\n\t_enter(\"{OBJ%x OP%x},{%u}\",\n\t       object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_INITIALISED);\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tspin_lock(&object->lock);\n\tASSERTCMP(object->n_ops, >=, object->n_in_progress);\n\tASSERTCMP(object->n_ops, >=, object->n_exclusive);\n\tASSERT(list_empty(&op->pend_link));\n\n\tostate = object->state;\n\tsmp_rmb();\n\n\top->state = FSCACHE_OP_ST_PENDING;\n\tif (fscache_object_is_active(object)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\n\t\tif (object->n_exclusive > 0) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t} else if (!list_empty(&object->pending_ops)) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t\tfscache_start_operations(object);\n\t\t} else {\n\t\t\tASSERTCMP(object->n_exclusive, ==, 0);\n\t\t\tfscache_run_op(object, op);\n\t\t}\n\t\tret = 0;\n\t} else if (test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\t\tatomic_inc(&op->usage);\n\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\tfscache_stat(&fscache_n_op_pend);\n\t\tret = 0;\n\t} else if (fscache_object_is_dying(object)) {\n\t\tfscache_stat(&fscache_n_op_rejected);\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t} else if (!test_bit(FSCACHE_IOERROR, &object->cache->flags)) {\n\t\tfscache_report_unexpected_submission(object, op, ostate);\n\t\tASSERT(!fscache_object_is_active(object));\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t} else {\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t}\n\n\tspin_unlock(&object->lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&object->lock"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!fscache_object_is_active(object)"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_object_is_active",
          "args": [
            "object"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_report_unexpected_submission",
          "args": [
            "object",
            "op",
            "ostate"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_report_unexpected_submission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "144-176",
          "snippet": "static void fscache_report_unexpected_submission(struct fscache_object *object,\n\t\t\t\t\t\t struct fscache_operation *op,\n\t\t\t\t\t\t const struct fscache_state *ostate)\n{\n\tstatic bool once_only;\n\tstruct fscache_operation *p;\n\tunsigned n;\n\n\tif (once_only)\n\t\treturn;\n\tonce_only = true;\n\n\tkdebug(\"unexpected submission OP%x [OBJ%x %s]\",\n\t       op->debug_id, object->debug_id, object->state->name);\n\tkdebug(\"objstate=%s [%s]\", object->state->name, ostate->name);\n\tkdebug(\"objflags=%lx\", object->flags);\n\tkdebug(\"objevent=%lx [%lx]\", object->events, object->event_mask);\n\tkdebug(\"ops=%u inp=%u exc=%u\",\n\t       object->n_ops, object->n_in_progress, object->n_exclusive);\n\n\tif (!list_empty(&object->pending_ops)) {\n\t\tn = 0;\n\t\tlist_for_each_entry(p, &object->pending_ops, pend_link) {\n\t\t\tASSERTCMP(p->object, ==, object);\n\t\t\tkdebug(\"%p %p\", op->processor, op->release);\n\t\t\tn++;\n\t\t}\n\n\t\tkdebug(\"n=%u\", n);\n\t}\n\n\tdump_stack();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nstatic void fscache_report_unexpected_submission(struct fscache_object *object,\n\t\t\t\t\t\t struct fscache_operation *op,\n\t\t\t\t\t\t const struct fscache_state *ostate)\n{\n\tstatic bool once_only;\n\tstruct fscache_operation *p;\n\tunsigned n;\n\n\tif (once_only)\n\t\treturn;\n\tonce_only = true;\n\n\tkdebug(\"unexpected submission OP%x [OBJ%x %s]\",\n\t       op->debug_id, object->debug_id, object->state->name);\n\tkdebug(\"objstate=%s [%s]\", object->state->name, ostate->name);\n\tkdebug(\"objflags=%lx\", object->flags);\n\tkdebug(\"objevent=%lx [%lx]\", object->events, object->event_mask);\n\tkdebug(\"ops=%u inp=%u exc=%u\",\n\t       object->n_ops, object->n_in_progress, object->n_exclusive);\n\n\tif (!list_empty(&object->pending_ops)) {\n\t\tn = 0;\n\t\tlist_for_each_entry(p, &object->pending_ops, pend_link) {\n\t\t\tASSERTCMP(p->object, ==, object);\n\t\t\tkdebug(\"%p %p\", op->processor, op->release);\n\t\t\tn++;\n\t\t}\n\n\t\tkdebug(\"n=%u\", n);\n\t}\n\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "FSCACHE_IOERROR",
            "&object->cache->flags"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_op_rejected"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_object_is_dying",
          "args": [
            "object"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&op->pend_link",
            "&object->pending_ops"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&op->usage"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_run_op",
          "args": [
            "object",
            "op"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_run_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "64-76",
          "snippet": "static void fscache_run_op(struct fscache_object *object,\n\t\t\t   struct fscache_operation *op)\n{\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_PENDING);\n\n\top->state = FSCACHE_OP_ST_IN_PROGRESS;\n\tobject->n_in_progress++;\n\tif (test_and_clear_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\twake_up_bit(&op->flags, FSCACHE_OP_WAITING);\n\tif (op->processor)\n\t\tfscache_enqueue_operation(op);\n\tfscache_stat(&fscache_n_op_run);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nstatic void fscache_run_op(struct fscache_object *object,\n\t\t\t   struct fscache_operation *op)\n{\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_PENDING);\n\n\top->state = FSCACHE_OP_ST_IN_PROGRESS;\n\tobject->n_in_progress++;\n\tif (test_and_clear_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\twake_up_bit(&op->flags, FSCACHE_OP_WAITING);\n\tif (op->processor)\n\t\tfscache_enqueue_operation(op);\n\tfscache_stat(&fscache_n_op_run);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "object->n_exclusive",
            "==,0"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_start_operations",
          "args": [
            "object"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_start_operations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "265-290",
          "snippet": "void fscache_start_operations(struct fscache_object *object)\n{\n\tstruct fscache_operation *op;\n\tbool stop = false;\n\n\twhile (!list_empty(&object->pending_ops) && !stop) {\n\t\top = list_entry(object->pending_ops.next,\n\t\t\t\tstruct fscache_operation, pend_link);\n\n\t\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags)) {\n\t\t\tif (object->n_in_progress > 0)\n\t\t\t\tbreak;\n\t\t\tstop = true;\n\t\t}\n\t\tlist_del_init(&op->pend_link);\n\t\tfscache_run_op(object, op);\n\n\t\t/* the pending queue was holding a ref on the object */\n\t\tfscache_put_operation(op);\n\t}\n\n\tASSERTCMP(object->n_in_progress, <=, object->n_ops);\n\n\t_debug(\"woke %d ops on OBJ%x\",\n\t       object->n_in_progress, object->debug_id);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_start_operations(struct fscache_object *object)\n{\n\tstruct fscache_operation *op;\n\tbool stop = false;\n\n\twhile (!list_empty(&object->pending_ops) && !stop) {\n\t\top = list_entry(object->pending_ops.next,\n\t\t\t\tstruct fscache_operation, pend_link);\n\n\t\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags)) {\n\t\t\tif (object->n_in_progress > 0)\n\t\t\t\tbreak;\n\t\t\tstop = true;\n\t\t}\n\t\tlist_del_init(&op->pend_link);\n\t\tfscache_run_op(object, op);\n\n\t\t/* the pending queue was holding a ref on the object */\n\t\tfscache_put_operation(op);\n\t}\n\n\tASSERTCMP(object->n_in_progress, <=, object->n_ops);\n\n\t_debug(\"woke %d ops on OBJ%x\",\n\t       object->n_in_progress, object->debug_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&op->pend_link",
            "&object->pending_ops"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&op->usage"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&object->pending_ops"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&op->pend_link",
            "&object->pending_ops"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&op->usage"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_object_is_active",
          "args": [
            "object"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "list_empty(&op->pend_link)"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "object->n_ops",
            ">=,object->n_exclusive"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "object->n_ops",
            ">=,object->n_in_progress"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&object->lock"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "atomic_read(&op->usage)",
            ">,0"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&op->usage"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "op->state",
            "==,FSCACHE_OP_ST_INITIALISED"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x OP%x},{%u}\"",
            "object->debug_id",
            "op->debug_id",
            "atomic_read(&op->usage)"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&op->usage"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nint fscache_submit_op(struct fscache_object *object,\n\t\t      struct fscache_operation *op)\n{\n\tconst struct fscache_state *ostate;\n\tint ret;\n\n\t_enter(\"{OBJ%x OP%x},{%u}\",\n\t       object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_INITIALISED);\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tspin_lock(&object->lock);\n\tASSERTCMP(object->n_ops, >=, object->n_in_progress);\n\tASSERTCMP(object->n_ops, >=, object->n_exclusive);\n\tASSERT(list_empty(&op->pend_link));\n\n\tostate = object->state;\n\tsmp_rmb();\n\n\top->state = FSCACHE_OP_ST_PENDING;\n\tif (fscache_object_is_active(object)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\n\t\tif (object->n_exclusive > 0) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t} else if (!list_empty(&object->pending_ops)) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t\tfscache_start_operations(object);\n\t\t} else {\n\t\t\tASSERTCMP(object->n_exclusive, ==, 0);\n\t\t\tfscache_run_op(object, op);\n\t\t}\n\t\tret = 0;\n\t} else if (test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\t\tatomic_inc(&op->usage);\n\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\tfscache_stat(&fscache_n_op_pend);\n\t\tret = 0;\n\t} else if (fscache_object_is_dying(object)) {\n\t\tfscache_stat(&fscache_n_op_rejected);\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t} else if (!test_bit(FSCACHE_IOERROR, &object->cache->flags)) {\n\t\tfscache_report_unexpected_submission(object, op, ostate);\n\t\tASSERT(!fscache_object_is_active(object));\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t} else {\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t}\n\n\tspin_unlock(&object->lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "fscache_report_unexpected_submission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
    "lines": "144-176",
    "snippet": "static void fscache_report_unexpected_submission(struct fscache_object *object,\n\t\t\t\t\t\t struct fscache_operation *op,\n\t\t\t\t\t\t const struct fscache_state *ostate)\n{\n\tstatic bool once_only;\n\tstruct fscache_operation *p;\n\tunsigned n;\n\n\tif (once_only)\n\t\treturn;\n\tonce_only = true;\n\n\tkdebug(\"unexpected submission OP%x [OBJ%x %s]\",\n\t       op->debug_id, object->debug_id, object->state->name);\n\tkdebug(\"objstate=%s [%s]\", object->state->name, ostate->name);\n\tkdebug(\"objflags=%lx\", object->flags);\n\tkdebug(\"objevent=%lx [%lx]\", object->events, object->event_mask);\n\tkdebug(\"ops=%u inp=%u exc=%u\",\n\t       object->n_ops, object->n_in_progress, object->n_exclusive);\n\n\tif (!list_empty(&object->pending_ops)) {\n\t\tn = 0;\n\t\tlist_for_each_entry(p, &object->pending_ops, pend_link) {\n\t\t\tASSERTCMP(p->object, ==, object);\n\t\t\tkdebug(\"%p %p\", op->processor, op->release);\n\t\t\tn++;\n\t\t}\n\n\t\tkdebug(\"n=%u\", n);\n\t}\n\n\tdump_stack();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"n=%u\"",
            "n"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"%p %p\"",
            "op->processor",
            "op->release"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "p->object",
            "==,object"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&object->pending_ops",
            "pend_link"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&object->pending_ops"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"ops=%u inp=%u exc=%u\"",
            "object->n_ops",
            "object->n_in_progress",
            "object->n_exclusive"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"objevent=%lx [%lx]\"",
            "object->events",
            "object->event_mask"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"objflags=%lx\"",
            "object->flags"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"objstate=%s [%s]\"",
            "object->state->name",
            "ostate->name"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"unexpected submission OP%x [OBJ%x %s]\"",
            "op->debug_id",
            "object->debug_id",
            "object->state->name"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nstatic void fscache_report_unexpected_submission(struct fscache_object *object,\n\t\t\t\t\t\t struct fscache_operation *op,\n\t\t\t\t\t\t const struct fscache_state *ostate)\n{\n\tstatic bool once_only;\n\tstruct fscache_operation *p;\n\tunsigned n;\n\n\tif (once_only)\n\t\treturn;\n\tonce_only = true;\n\n\tkdebug(\"unexpected submission OP%x [OBJ%x %s]\",\n\t       op->debug_id, object->debug_id, object->state->name);\n\tkdebug(\"objstate=%s [%s]\", object->state->name, ostate->name);\n\tkdebug(\"objflags=%lx\", object->flags);\n\tkdebug(\"objevent=%lx [%lx]\", object->events, object->event_mask);\n\tkdebug(\"ops=%u inp=%u exc=%u\",\n\t       object->n_ops, object->n_in_progress, object->n_exclusive);\n\n\tif (!list_empty(&object->pending_ops)) {\n\t\tn = 0;\n\t\tlist_for_each_entry(p, &object->pending_ops, pend_link) {\n\t\t\tASSERTCMP(p->object, ==, object);\n\t\t\tkdebug(\"%p %p\", op->processor, op->release);\n\t\t\tn++;\n\t\t}\n\n\t\tkdebug(\"n=%u\", n);\n\t}\n\n\tdump_stack();\n}"
  },
  {
    "function_name": "fscache_submit_exclusive_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
    "lines": "83-139",
    "snippet": "int fscache_submit_exclusive_op(struct fscache_object *object,\n\t\t\t\tstruct fscache_operation *op)\n{\n\tint ret;\n\n\t_enter(\"{OBJ%x OP%x},\", object->debug_id, op->debug_id);\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_INITIALISED);\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tspin_lock(&object->lock);\n\tASSERTCMP(object->n_ops, >=, object->n_in_progress);\n\tASSERTCMP(object->n_ops, >=, object->n_exclusive);\n\tASSERT(list_empty(&op->pend_link));\n\n\top->state = FSCACHE_OP_ST_PENDING;\n\tif (fscache_object_is_active(object)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\t\tobject->n_exclusive++;\t/* reads and writes must wait */\n\n\t\tif (object->n_in_progress > 0) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t} else if (!list_empty(&object->pending_ops)) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t\tfscache_start_operations(object);\n\t\t} else {\n\t\t\tASSERTCMP(object->n_in_progress, ==, 0);\n\t\t\tfscache_run_op(object, op);\n\t\t}\n\n\t\t/* need to issue a new write op after this */\n\t\tclear_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags);\n\t\tret = 0;\n\t} else if (test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\t\tobject->n_exclusive++;\t/* reads and writes must wait */\n\t\tatomic_inc(&op->usage);\n\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\tfscache_stat(&fscache_n_op_pend);\n\t\tret = 0;\n\t} else {\n\t\t/* If we're in any other state, there must have been an I/O\n\t\t * error of some nature.\n\t\t */\n\t\tASSERT(test_bit(FSCACHE_IOERROR, &object->cache->flags));\n\t\tret = -EIO;\n\t}\n\n\tspin_unlock(&object->lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&object->lock"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "test_bit(FSCACHE_IOERROR, &object->cache->flags)"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "FSCACHE_IOERROR",
            "&object->cache->flags"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_op_pend"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&op->pend_link",
            "&object->pending_ops"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&op->usage"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "FSCACHE_OBJECT_PENDING_WRITE",
            "&object->flags"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_run_op",
          "args": [
            "object",
            "op"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_run_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "64-76",
          "snippet": "static void fscache_run_op(struct fscache_object *object,\n\t\t\t   struct fscache_operation *op)\n{\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_PENDING);\n\n\top->state = FSCACHE_OP_ST_IN_PROGRESS;\n\tobject->n_in_progress++;\n\tif (test_and_clear_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\twake_up_bit(&op->flags, FSCACHE_OP_WAITING);\n\tif (op->processor)\n\t\tfscache_enqueue_operation(op);\n\tfscache_stat(&fscache_n_op_run);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nstatic void fscache_run_op(struct fscache_object *object,\n\t\t\t   struct fscache_operation *op)\n{\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_PENDING);\n\n\top->state = FSCACHE_OP_ST_IN_PROGRESS;\n\tobject->n_in_progress++;\n\tif (test_and_clear_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\twake_up_bit(&op->flags, FSCACHE_OP_WAITING);\n\tif (op->processor)\n\t\tfscache_enqueue_operation(op);\n\tfscache_stat(&fscache_n_op_run);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "object->n_in_progress",
            "==,0"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_start_operations",
          "args": [
            "object"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_start_operations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "265-290",
          "snippet": "void fscache_start_operations(struct fscache_object *object)\n{\n\tstruct fscache_operation *op;\n\tbool stop = false;\n\n\twhile (!list_empty(&object->pending_ops) && !stop) {\n\t\top = list_entry(object->pending_ops.next,\n\t\t\t\tstruct fscache_operation, pend_link);\n\n\t\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags)) {\n\t\t\tif (object->n_in_progress > 0)\n\t\t\t\tbreak;\n\t\t\tstop = true;\n\t\t}\n\t\tlist_del_init(&op->pend_link);\n\t\tfscache_run_op(object, op);\n\n\t\t/* the pending queue was holding a ref on the object */\n\t\tfscache_put_operation(op);\n\t}\n\n\tASSERTCMP(object->n_in_progress, <=, object->n_ops);\n\n\t_debug(\"woke %d ops on OBJ%x\",\n\t       object->n_in_progress, object->debug_id);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_start_operations(struct fscache_object *object)\n{\n\tstruct fscache_operation *op;\n\tbool stop = false;\n\n\twhile (!list_empty(&object->pending_ops) && !stop) {\n\t\top = list_entry(object->pending_ops.next,\n\t\t\t\tstruct fscache_operation, pend_link);\n\n\t\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags)) {\n\t\t\tif (object->n_in_progress > 0)\n\t\t\t\tbreak;\n\t\t\tstop = true;\n\t\t}\n\t\tlist_del_init(&op->pend_link);\n\t\tfscache_run_op(object, op);\n\n\t\t/* the pending queue was holding a ref on the object */\n\t\tfscache_put_operation(op);\n\t}\n\n\tASSERTCMP(object->n_in_progress, <=, object->n_ops);\n\n\t_debug(\"woke %d ops on OBJ%x\",\n\t       object->n_in_progress, object->debug_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&op->pend_link",
            "&object->pending_ops"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&op->usage"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&object->pending_ops"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&op->pend_link",
            "&object->pending_ops"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&op->usage"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_object_is_active",
          "args": [
            "object"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "list_empty(&op->pend_link)"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "object->n_ops",
            ">=,object->n_exclusive"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "object->n_ops",
            ">=,object->n_in_progress"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&object->lock"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "atomic_read(&op->usage)",
            ">,0"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&op->usage"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "op->state",
            "==,FSCACHE_OP_ST_INITIALISED"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x OP%x},\"",
            "object->debug_id",
            "op->debug_id"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nint fscache_submit_exclusive_op(struct fscache_object *object,\n\t\t\t\tstruct fscache_operation *op)\n{\n\tint ret;\n\n\t_enter(\"{OBJ%x OP%x},\", object->debug_id, op->debug_id);\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_INITIALISED);\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tspin_lock(&object->lock);\n\tASSERTCMP(object->n_ops, >=, object->n_in_progress);\n\tASSERTCMP(object->n_ops, >=, object->n_exclusive);\n\tASSERT(list_empty(&op->pend_link));\n\n\top->state = FSCACHE_OP_ST_PENDING;\n\tif (fscache_object_is_active(object)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\t\tobject->n_exclusive++;\t/* reads and writes must wait */\n\n\t\tif (object->n_in_progress > 0) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t} else if (!list_empty(&object->pending_ops)) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t\tfscache_start_operations(object);\n\t\t} else {\n\t\t\tASSERTCMP(object->n_in_progress, ==, 0);\n\t\t\tfscache_run_op(object, op);\n\t\t}\n\n\t\t/* need to issue a new write op after this */\n\t\tclear_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags);\n\t\tret = 0;\n\t} else if (test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\t\tobject->n_exclusive++;\t/* reads and writes must wait */\n\t\tatomic_inc(&op->usage);\n\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\tfscache_stat(&fscache_n_op_pend);\n\t\tret = 0;\n\t} else {\n\t\t/* If we're in any other state, there must have been an I/O\n\t\t * error of some nature.\n\t\t */\n\t\tASSERT(test_bit(FSCACHE_IOERROR, &object->cache->flags));\n\t\tret = -EIO;\n\t}\n\n\tspin_unlock(&object->lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "fscache_run_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
    "lines": "64-76",
    "snippet": "static void fscache_run_op(struct fscache_object *object,\n\t\t\t   struct fscache_operation *op)\n{\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_PENDING);\n\n\top->state = FSCACHE_OP_ST_IN_PROGRESS;\n\tobject->n_in_progress++;\n\tif (test_and_clear_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\twake_up_bit(&op->flags, FSCACHE_OP_WAITING);\n\tif (op->processor)\n\t\tfscache_enqueue_operation(op);\n\tfscache_stat(&fscache_n_op_run);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_op_run"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_enqueue_operation",
          "args": [
            "op"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_enqueue_operation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "31-58",
          "snippet": "void fscache_enqueue_operation(struct fscache_operation *op)\n{\n\t_enter(\"{OBJ%x OP%x,%u}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERT(list_empty(&op->pend_link));\n\tASSERT(op->processor != NULL);\n\tASSERT(fscache_object_is_available(op->object));\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_IN_PROGRESS);\n\n\tfscache_stat(&fscache_n_op_enqueue);\n\tswitch (op->flags & FSCACHE_OP_TYPE) {\n\tcase FSCACHE_OP_ASYNC:\n\t\t_debug(\"queue async\");\n\t\tatomic_inc(&op->usage);\n\t\tif (!queue_work(fscache_op_wq, &op->work))\n\t\t\tfscache_put_operation(op);\n\t\tbreak;\n\tcase FSCACHE_OP_MYTHREAD:\n\t\t_debug(\"queue for caller's attention\");\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unexpected op type %lx\", op->flags);\n\t\tBUG();\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_enqueue_operation(struct fscache_operation *op)\n{\n\t_enter(\"{OBJ%x OP%x,%u}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERT(list_empty(&op->pend_link));\n\tASSERT(op->processor != NULL);\n\tASSERT(fscache_object_is_available(op->object));\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_IN_PROGRESS);\n\n\tfscache_stat(&fscache_n_op_enqueue);\n\tswitch (op->flags & FSCACHE_OP_TYPE) {\n\tcase FSCACHE_OP_ASYNC:\n\t\t_debug(\"queue async\");\n\t\tatomic_inc(&op->usage);\n\t\tif (!queue_work(fscache_op_wq, &op->work))\n\t\t\tfscache_put_operation(op);\n\t\tbreak;\n\tcase FSCACHE_OP_MYTHREAD:\n\t\t_debug(\"queue for caller's attention\");\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unexpected op type %lx\", op->flags);\n\t\tBUG();\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&op->flags",
            "FSCACHE_OP_WAITING"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "FSCACHE_OP_WAITING",
            "&op->flags"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "op->state",
            "==,FSCACHE_OP_ST_PENDING"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nstatic void fscache_run_op(struct fscache_object *object,\n\t\t\t   struct fscache_operation *op)\n{\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_PENDING);\n\n\top->state = FSCACHE_OP_ST_IN_PROGRESS;\n\tobject->n_in_progress++;\n\tif (test_and_clear_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\twake_up_bit(&op->flags, FSCACHE_OP_WAITING);\n\tif (op->processor)\n\t\tfscache_enqueue_operation(op);\n\tfscache_stat(&fscache_n_op_run);\n}"
  },
  {
    "function_name": "fscache_enqueue_operation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
    "lines": "31-58",
    "snippet": "void fscache_enqueue_operation(struct fscache_operation *op)\n{\n\t_enter(\"{OBJ%x OP%x,%u}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERT(list_empty(&op->pend_link));\n\tASSERT(op->processor != NULL);\n\tASSERT(fscache_object_is_available(op->object));\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_IN_PROGRESS);\n\n\tfscache_stat(&fscache_n_op_enqueue);\n\tswitch (op->flags & FSCACHE_OP_TYPE) {\n\tcase FSCACHE_OP_ASYNC:\n\t\t_debug(\"queue async\");\n\t\tatomic_inc(&op->usage);\n\t\tif (!queue_work(fscache_op_wq, &op->work))\n\t\t\tfscache_put_operation(op);\n\t\tbreak;\n\tcase FSCACHE_OP_MYTHREAD:\n\t\t_debug(\"queue for caller's attention\");\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unexpected op type %lx\", op->flags);\n\t\tBUG();\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unexpected op type %lx\"",
            "op->flags"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"queue for caller's attention\""
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_put_operation",
          "args": [
            "op"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_put_operation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "398-455",
          "snippet": "void fscache_put_operation(struct fscache_operation *op)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\n\t_enter(\"{OBJ%x OP%x,%d}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tif (!atomic_dec_and_test(&op->usage))\n\t\treturn;\n\n\t_debug(\"PUT OP\");\n\tASSERTIFCMP(op->state != FSCACHE_OP_ST_COMPLETE,\n\t\t    op->state, ==, FSCACHE_OP_ST_CANCELLED);\n\top->state = FSCACHE_OP_ST_DEAD;\n\n\tfscache_stat(&fscache_n_op_release);\n\n\tif (op->release) {\n\t\top->release(op);\n\t\top->release = NULL;\n\t}\n\n\tobject = op->object;\n\n\tif (test_bit(FSCACHE_OP_DEC_READ_CNT, &op->flags))\n\t\tatomic_dec(&object->n_reads);\n\tif (test_bit(FSCACHE_OP_UNUSE_COOKIE, &op->flags))\n\t\tfscache_unuse_cookie(object);\n\n\t/* now... we may get called with the object spinlock held, so we\n\t * complete the cleanup here only if we can immediately acquire the\n\t * lock, and defer it otherwise */\n\tif (!spin_trylock(&object->lock)) {\n\t\t_debug(\"defer put\");\n\t\tfscache_stat(&fscache_n_op_deferred_release);\n\n\t\tcache = object->cache;\n\t\tspin_lock(&cache->op_gc_list_lock);\n\t\tlist_add_tail(&op->pend_link, &cache->op_gc_list);\n\t\tspin_unlock(&cache->op_gc_list_lock);\n\t\tschedule_work(&cache->op_gc);\n\t\t_leave(\" [defer]\");\n\t\treturn;\n\t}\n\n\tASSERTCMP(object->n_ops, >, 0);\n\tobject->n_ops--;\n\tif (object->n_ops == 0)\n\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_CLEARED);\n\n\tspin_unlock(&object->lock);\n\n\tkfree(op);\n\t_leave(\" [done]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_put_operation(struct fscache_operation *op)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\n\t_enter(\"{OBJ%x OP%x,%d}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tif (!atomic_dec_and_test(&op->usage))\n\t\treturn;\n\n\t_debug(\"PUT OP\");\n\tASSERTIFCMP(op->state != FSCACHE_OP_ST_COMPLETE,\n\t\t    op->state, ==, FSCACHE_OP_ST_CANCELLED);\n\top->state = FSCACHE_OP_ST_DEAD;\n\n\tfscache_stat(&fscache_n_op_release);\n\n\tif (op->release) {\n\t\top->release(op);\n\t\top->release = NULL;\n\t}\n\n\tobject = op->object;\n\n\tif (test_bit(FSCACHE_OP_DEC_READ_CNT, &op->flags))\n\t\tatomic_dec(&object->n_reads);\n\tif (test_bit(FSCACHE_OP_UNUSE_COOKIE, &op->flags))\n\t\tfscache_unuse_cookie(object);\n\n\t/* now... we may get called with the object spinlock held, so we\n\t * complete the cleanup here only if we can immediately acquire the\n\t * lock, and defer it otherwise */\n\tif (!spin_trylock(&object->lock)) {\n\t\t_debug(\"defer put\");\n\t\tfscache_stat(&fscache_n_op_deferred_release);\n\n\t\tcache = object->cache;\n\t\tspin_lock(&cache->op_gc_list_lock);\n\t\tlist_add_tail(&op->pend_link, &cache->op_gc_list);\n\t\tspin_unlock(&cache->op_gc_list_lock);\n\t\tschedule_work(&cache->op_gc);\n\t\t_leave(\" [defer]\");\n\t\treturn;\n\t}\n\n\tASSERTCMP(object->n_ops, >, 0);\n\tobject->n_ops--;\n\tif (object->n_ops == 0)\n\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_CLEARED);\n\n\tspin_unlock(&object->lock);\n\n\tkfree(op);\n\t_leave(\" [done]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "fscache_op_wq",
            "&op->work"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&op->usage"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_op_enqueue"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "op->state",
            "==,FSCACHE_OP_ST_IN_PROGRESS"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "atomic_read(&op->usage)",
            ">,0"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&op->usage"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "fscache_object_is_available(op->object)"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_object_is_available",
          "args": [
            "op->object"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "op->processor != NULL"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "list_empty(&op->pend_link)"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&op->pend_link"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x OP%x,%u}\"",
            "op->object->debug_id",
            "op->debug_id",
            "atomic_read(&op->usage)"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&op->usage"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_enqueue_operation(struct fscache_operation *op)\n{\n\t_enter(\"{OBJ%x OP%x,%u}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERT(list_empty(&op->pend_link));\n\tASSERT(op->processor != NULL);\n\tASSERT(fscache_object_is_available(op->object));\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_IN_PROGRESS);\n\n\tfscache_stat(&fscache_n_op_enqueue);\n\tswitch (op->flags & FSCACHE_OP_TYPE) {\n\tcase FSCACHE_OP_ASYNC:\n\t\t_debug(\"queue async\");\n\t\tatomic_inc(&op->usage);\n\t\tif (!queue_work(fscache_op_wq, &op->work))\n\t\t\tfscache_put_operation(op);\n\t\tbreak;\n\tcase FSCACHE_OP_MYTHREAD:\n\t\t_debug(\"queue for caller's attention\");\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unexpected op type %lx\", op->flags);\n\t\tBUG();\n\t\tbreak;\n\t}\n}"
  }
]